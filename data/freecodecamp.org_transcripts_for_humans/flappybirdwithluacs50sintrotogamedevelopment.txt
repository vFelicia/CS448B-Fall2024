With timestamps:

00:00 - [Music]
00:16 - hi everybody my name is colton ogden
00:19 - this is gd 50 lecture one
00:21 - and today we'll be covering flappy bird
00:24 - so uh last year we are last week sorry
00:26 - we covered pong which was uh just you
00:28 - know basic shapes and colors today we'll
00:30 - actually be diving into sprites as we
00:32 - can see here we've got some pipes and a
00:34 - bird and we're covering a few other
00:35 - concepts such as gravity and more
00:39 - today the topics that we'll be covering
00:41 - are in a nutshell images and sprites as
00:43 - i just said so loading images from
00:44 - memory from our hard drive and actually
00:46 - drawing them to the screen instead of
00:48 - just uh you know rectangles and whatnot
00:50 - uh we'll be covering infinite scrolling
00:52 - so seeing things like and if you've
00:54 - played the game pipes are infinitely
00:56 - going from right to left how to actually
00:58 - get that going infinitely so that we're
00:59 - not using up also infinite memory
01:02 - we'll be discussing how games and in the
01:04 - similar vein are illusions in the sense
01:07 - that um a lot of the perceived vastness
01:10 - and perceived complexity of games is
01:12 - often just due to camera trickery and
01:14 - more
01:15 - because of limited hardware
01:17 - we'll be covering procedural generation
01:19 - which ties also into infinite scrolling
01:21 - procedures generation is a topic that
01:23 - i'm actually very interested in and
01:24 - we'll be touching on it throughout the
01:26 - course in several locations but in the
01:28 - cons or in the context of today's
01:29 - lecture we'll be using it uh for the
01:31 - pipes because the pipes they spawn from
01:33 - right to left and flappy bird as you're
01:35 - infinitely going through the level but
01:36 - they can spawn at various heights and
01:38 - the gaps are shifting as a result of
01:41 - that therefore creating this sort of
01:42 - infinite level
01:44 - we'll be talking more in detail on state
01:46 - machines so last week we covered state
01:47 - machines in a very abstract sense we
01:49 - used a just basically a string as a
01:51 - variable and then used if conditions
01:52 - today we'll be actually using a state
01:54 - machine class replete with various
01:56 - methods that allow us to transition in
01:58 - and out of these states
01:59 - very cleanly and allow us to break out
02:01 - all of this logic that we previously had
02:03 - in our update and render functions and
02:05 - then put them separately into their own
02:07 - state classes
02:09 - and then lastly we'll also be touching
02:10 - on mouse input and a point that i forgot
02:13 - to mention here whoops is
02:17 - also
02:18 - we'll be talking about music which is
02:19 - just basically sound which we did last
02:20 - week but we'll add that as a polishing
02:23 - touch
02:24 - if you guys want to download the demo
02:25 - code we have a repo up
02:27 - right now on github slash games 50
02:30 - 50 bird that's our take on flappy bird
02:34 - a couple of things i've been asked a
02:35 - couple of times whether we have reading
02:37 - materials for the course uh and there
02:39 - are no formal reading materials but
02:40 - there are a couple of resources that i
02:42 - really enjoyed reading especially as i
02:44 - was getting more into lua and love2d
02:46 - they are two books uh one is an online
02:49 - book actually they're both online books
02:51 - but the latter of which has a physical
02:53 - form as well the four first of these is
02:55 - how to make an rpg by dan scholler which
02:57 - is actually completely written in lua
02:59 - he uses a custom game engine very
03:01 - similar to love2d but it's handwritten
03:03 - by him but a lot of the same ideas apply
03:06 - and it's a great opportunity it's how i
03:08 - cut my teeth on lua and i would
03:09 - encourage you to take a look at that if
03:11 - that's something you're interested in or
03:12 - if you like rpgs
03:14 - and then also game programming patterns
03:16 - by robert nystrom is a very great
03:18 - general purpose game development book
03:20 - that talks about a lot of these sort of
03:22 - more abstract high-level concepts with
03:23 - large-scale game development but yeah
03:25 - beyond that no formal reading those
03:27 - aren't formal reading either those are
03:28 - just if you're curious and you want to
03:30 - read some resources that i found very
03:31 - interesting feel free to do so today's
03:33 - goal is to implement what looks like
03:35 - this this is a this is our version of
03:37 - flappy bird
03:38 - we didn't use the same exact sprites for
03:40 - copyright purposes but we note that we
03:42 - have a bird in the middle of the screen
03:45 - this bird on click or on space bar will
03:48 - jump up and down and your goal is to
03:50 - prevent the bird from touching either
03:52 - the pipes or the ground itself
03:55 - every time you make it past a pair of
03:56 - pipes you will score a point as soon as
03:59 - you touch a pipe or hit the ground game
04:00 - is over and
04:02 - that's that
04:03 - so
04:04 - today we'll be covering uh i'll doing a
04:06 - little bit more live coding so the very
04:08 - first example that i want to cover is
04:10 - the day zero update
04:11 - for flappy bird and a important function
04:14 - that is going to be probably the most
04:15 - noticeable the most visibly obvious
04:17 - function we'll be using throughout this
04:19 - lecture is
04:21 - love.graphics.new image which takes a
04:23 - path
04:24 - this function
04:25 - all it does is load a image file from
04:27 - your disk you specify it as a string
04:30 - and you can then use it as an object and
04:32 - draw anywhere you want at an x y
04:34 - coordinate and we'll see this in
04:36 - practice here so i'm going to go ahead
04:38 - if you're looking in the repo all of
04:39 - these examples are covered 0 through 12.
04:44 - i'm going to start from scratch in a new
04:47 - folder that i've created i'm going to
04:48 - create a brand new
04:50 - main.lua completely fresh
04:53 - and
04:54 - first thing i want to do is because we
04:56 - are
04:57 - going to use a virtual resolution just
04:59 - like we did last week so that we have a
05:00 - more retro aesthetic i'm going to go
05:01 - ahead and require the push library so
05:03 - push equals require push just like that
05:06 - i've pre put push lua into this
05:08 - directory it'll just load by default in
05:11 - the same directory the current working
05:12 - directory of your script when you run
05:15 - love
05:16 - next thing i'm going to do i'm going to
05:17 - define some constants so window width
05:19 - should be 1280 and then window height is
05:21 - going to be
05:22 - 720. those are our physical window
05:25 - dimensions but then we also need a
05:27 - virtual width
05:28 - and we're going to use 512 by 288 this
05:31 - is a
05:32 - resolution that i found worked pretty
05:33 - well for the assets we'll be using today
05:36 - but you can make this most anything you
05:37 - want to
05:38 - as long as it's somewhat in that range
05:40 - it is a 16x9 resolution as well so that
05:42 - it fits comfortably on um
05:45 - modern widescreen 16x9 monitors um what
05:48 - we're going to do is the first goal that
05:50 - we have today is to sort of
05:52 - draw
05:53 - two images to the screen
05:55 - we want a foreground and a background
05:57 - because notice if we go back to the
05:58 - slides we can see in the very background
06:01 - we have a
06:03 - sort of hill
06:04 - landscape and then on the bottom we have
06:07 - a
06:07 - ground and there the two of those are
06:09 - going to eventually scroll at different
06:11 - rates it's going to be called parallax
06:13 - scrolling but just for our very first
06:15 - example we have something very basic i
06:16 - just want to draw two images to the
06:17 - screen so we're going to go ahead and do
06:19 - that here by setting a local variable
06:22 - remember local means that it's just
06:24 - defined to the scope that it's in rather
06:26 - than being global which means we cannot
06:27 - access this variable outside of this
06:30 - file
06:31 - local background gets love.graphic
06:34 - image the function that we just talked
06:36 - about let me go ahead and hide this
06:37 - inspector here so we can have more room
06:39 - to code
06:40 - and then it's just going to take a
06:42 - string so background.png
06:44 - and i realize i actually didn't include
06:45 - those files in the directory so i'm
06:47 - going to need to do that as well
06:49 - same thing for the ground exact same
06:51 - function love.graphics.new image except
06:53 - ground.png
06:55 - and before i forget let's go ahead and
06:56 - do that right now
06:59 - i have the
07:00 - files here ground and background and
07:03 - copy those from the
07:05 - repo the distro repo into my bird zero
07:08 - directory that i'm currently developing
07:10 - in right now
07:12 - and so as soon as we're done with that
07:13 - we're going to go ahead and we're going
07:14 - to define love.load which is the
07:16 - function lov2d calls at the beginning of
07:18 - your program execution
07:20 - in there because we don't want these
07:22 - images to
07:24 - look blurry when they get loaded and
07:26 - upscaled we want to go ahead and set our
07:28 - default filter to nearest on min and mag
07:31 - which means on upscale and downscale
07:33 - apply nearest neighbor filtering which
07:34 - means
07:35 - no
07:36 - blurriness no interpolation of the
07:38 - pixels
07:40 - and then
07:42 - one thing that
07:43 - is just a small little touch
07:46 - love.window.set title 50 bird because uh
07:50 - is gd50 and then we're going to go ahead
07:52 - and set up our screen here with our
07:55 - virtual width
07:56 - virtual height window width
08:00 - window height
08:01 - it's getting a bit long
08:03 - and then it takes in a table
08:05 - recall tables just take in keys
08:08 - like so unlike in python where you might
08:11 - use a colon we use an equal sign in love
08:14 - or in lua i should say
08:16 - resizable to true
08:19 - and that is the end of our
08:23 - load function now does anybody recall
08:24 - how
08:25 - we if we want to resize so notice i said
08:28 - resizable to true do we know how we want
08:30 - how we can send a message to push to
08:32 - resize our screen for us
08:37 - so love 2d defines a function called
08:39 - love.resize which takes in a width and a
08:42 - height
08:43 - and in there all we're going to do is
08:45 - defer
08:46 - that call to push recall the exact same
08:48 - function on push it takes a width and a
08:50 - height and that will take care of
08:51 - dynamically
08:52 - re-scaling the canvas it uses internally
08:55 - it renders to a texture and it's going
08:57 - to render to the texture that we set as
08:58 - the virtual width and virtual height and
09:00 - it's going to scale it to fit our screen
09:02 - and it needs to know our physical screen
09:04 - dimension so that it can actually
09:06 - properly scale that internal canvas
09:08 - appropriately
09:10 - does anybody remember the function that
09:12 - we use to get input from the user
09:17 - so function.love.keypressed
09:20 - recall it takes in a key love is going
09:23 - to call this automatically every time we
09:25 - press a key and that's going to be
09:27 - we're going to have access to that key
09:29 - and we can do any sort of logic that we
09:31 - want
09:32 - on
09:33 - that key or using that key and we're
09:36 - just going to call love.event.quit
09:38 - because i don't like to press command q
09:40 - or click the red x i just want to hit
09:41 - escape be done with it
09:44 - and then what's our render what's love's
09:46 - render function called
09:49 - it's called love.draw
09:52 - so call love.draw
09:55 - and then uh
09:56 - because we're using push does anybody
09:58 - remember what we need to actually do to
09:59 - get push to render our screen to a
10:01 - virtual resolution
10:06 - so recall
10:09 - that there's actually two ways we can do
10:10 - it we can call push start and push
10:13 - finish
10:14 - which we didn't cover last week
10:16 - or we can call and that's actually the
10:18 - new
10:19 - like sort of de facto way to do it
10:21 - or we can do push apply
10:24 - start which is the deprecated way to do
10:26 - it
10:27 - but
10:28 - starting from here on out we're just
10:29 - going to call push start
10:31 - and push finish
10:34 - and then last we have our images we've
10:37 - allocated them as objects up here we
10:40 - have a background and a ground
10:44 - all we need to do now is just draw them
10:46 - to the screen
10:47 - so this is a new
10:48 - function or it's actually uh
10:51 - not a new function it is a new function
10:53 - actually
10:54 - love dot graphics.rectangle is what we
10:56 - used last week for all of the draw calls
10:59 - in this case we want to draw a graph a
11:01 - image object a texture object that we
11:03 - have in memory so we're going to call
11:05 - love.graphics.draw and it takes a
11:07 - drawable which means anything that love
11:09 - has defined as something that can be
11:11 - drawn in this case images are drawables
11:13 - they can be drawn and they can be drawn
11:15 - at any given position that you specify
11:18 - so if we wanted to draw it at the top
11:19 - left corner we would just say
11:21 - love.graphics.dropbackground at zero
11:23 - zero and it has that effect and we're
11:25 - gonna do the exact same thing with our
11:29 - ground
11:30 - the only difference being that obviously
11:32 - we don't want to draw at the top left
11:33 - corner we want to draw at the bottom of
11:34 - the screen so
11:38 - we just call
11:39 - virtual height minus 16 which happens to
11:41 - be the height of our image so if you run
11:43 - this i'm going to go ahead
11:45 - and make sure i'm in the right directory
11:48 - i'm not in the right directory so i'm
11:49 - going to go into
11:51 - a directory i wrote 50 bird
11:53 - scratch going into bird zero
11:56 - and if i run this i should theoretically
11:58 - have
11:59 - just two images layered on top of each
12:01 - other
12:02 - which i do not
12:06 - so
12:07 - let me make sure that it gets saved
12:10 - remember to always save your work
12:12 - and
12:14 - there we go
12:15 - so all we're doing now is it looks
12:17 - infinitely better than last week already
12:19 - but it's very simple very few lines of
12:21 - code all the effort that we've put into
12:22 - it has been in our sprite editor of
12:24 - choice and you can use most any
12:25 - application you want to do this sort of
12:27 - stuff i use a program called a sprite i
12:29 - like a lot but you could do this in
12:31 - which is free you could do it in
12:32 - photoshop you could do it in microsoft
12:34 - paint if you wanted to
12:36 - um
12:37 - godspeed if you do
12:39 - um
12:40 - but yeah so that's that's as simple as
12:42 - it is just to draw images to the screen
12:43 - so we've already made quite a lot of
12:45 - progress in a very short period of time
12:47 - in terms of the visual aspect of our
12:49 - game but it's not interesting to look at
12:52 - beyond the initial sort of honeymoon
12:53 - period of now we have colors on the
12:55 - screen we want to actually get
12:57 - scrolling
12:58 - because the game
13:00 - recall is a scrolling game and actually
13:03 - would anybody be willing to volunteer to
13:05 - come up and play flappy bird just so we
13:07 - can see it live on the stage
13:13 - david do you want to come up and play oh
13:15 - doesn't volunteer
13:18 - stephen you want to come up and play
13:23 - thank you for volunteering
13:30 - i guarantee you're better at this game
13:32 - than i am so
13:34 - i'm going to go ahead and cd into uh
13:37 - bird
13:38 - bird 12
13:39 - in the directory which is uh the final
13:42 - version of the game complete so i'm
13:44 - going to go ahead and hit enter
13:47 - so already we can see
13:49 - the uh
13:51 - parallax scrolling that i referred to
13:52 - before which is the floor and the
13:54 - background are scrolling at different
13:56 - rates and we'll see this very shortly in
13:57 - the next example
13:59 - we have a prompt we have text we've
14:00 - already used this before with a font so
14:02 - go ahead if you press enter
14:04 - you're going to get a countdown so space
14:06 - is to jump
14:08 - so we have our bird jumping in the
14:10 - middle of the screen we have a score at
14:11 - the top
14:12 - goal is to avoid hitting the pipes
14:16 - oh i got a score of one we'll try again
14:22 - [Music]
14:23 - so it keeps track of his position and
14:25 - every time he gets past the right edge
14:27 - of a pair of pipes as you can see that's
14:29 - when he gets a point
14:32 - so if you recall from last week
14:35 - what do we think is what what's what's
14:37 - detecting the collision if you remember
14:38 - last week what's the term
14:40 - anybody remember
14:42 - access a bound a a b b collision
14:44 - detection access a line bounding box is
14:46 - the same thing that we did with pong
14:48 - except now we're doing it we have
14:49 - graphics but that's the same same as
14:51 - that concept we're just using
14:53 - rectangles and when one rectangle
14:55 - overlaps with another rectangle we
14:57 - trigger
14:58 - depth
15:02 - so one last iteration i think and then
15:04 - we'll
15:04 - oh
15:06 - we'll let you try one more time
15:08 - go ahead i'll give it a shot all right
15:11 - i'm gonna lose on purpose yeah okay here
15:12 - we go
15:14 - so to be to be unfair i i got plenty of
15:17 - practice while i was developing this but
15:18 - we'll see if that actually holds true
15:20 - here
15:22 - all right so notice also the pipes
15:25 - there's their the procedure generation
15:26 - that i oh i lost three points
15:28 - let me explain a little bit more i guess
15:30 - we'll do one more iteration but the
15:32 - pipes themselves every time we start
15:34 - they're spawning at a different location
15:35 - this is procedural generation
15:38 - pretty much the most simplest way
15:40 - possible
15:41 - um and notice that the pipes are
15:43 - shifting gradually so this is sort of
15:45 - like the makeup of our level
15:47 - um and it's just generating bit by bit
15:50 - uh due to some simple algorithm that we
15:52 - have that just says hey respond to the
15:53 - pipe here shift it by some amount
15:55 - and
15:57 - this very simple approach allows us to
15:58 - have an infinite level over and over
16:00 - again it's very efficient we only ever
16:02 - have as many pipes on the screen and as
16:04 - we'll see soon
16:06 - we only have as many pipes in memory as
16:08 - we can see on the screen at one time
16:10 - despite the fact that this level could
16:11 - theoretically go on infinitely
16:14 - and so it's very cost efficient
16:16 - so bird one uh is the example it's the
16:18 - parallax update so parallax scrolling is
16:20 - an important concept in 2d
16:23 - and also 3d but 2d game development it
16:26 - refers to the illusion of movement given
16:29 - two
16:30 - two frames of reference that are that
16:32 - moving at different rates so if you're
16:33 - driving on the highway and you see a
16:35 - fence next to you
16:37 - and you see mountains in the distance
16:38 - you're observing parallax scroll by
16:40 - seeing how fast the fence moves relative
16:42 - to the mountains the mountains are going
16:43 - to move a lot more slowly than the fence
16:45 - is right next to you and we accomplish
16:47 - the same exact illusion in our game by
16:50 - ref by using this sort of uh graphical
16:52 - illusion
16:54 - and so i'm going to go ahead in my
16:56 - directory here
16:57 - in bird one which is a unpopulated
17:01 - direct it's populated with the contents
17:03 - of bird zero the complete contents of
17:05 - bird zero
17:06 - your the version that you'll see will
17:08 - have uh all of the code but i'm gonna go
17:11 - ahead and
17:12 - if we run bird
17:14 - zero
17:15 - uh in that directory so i think right
17:17 - now i'm still in the
17:18 - full distro so let me go ahead go into
17:21 - 50 bird scratch again
17:26 - oops where am i
17:31 - and then i'm gonna go into bird one and
17:33 - run it
17:34 - and i get the exact same image that we
17:36 - had last time so everything is there
17:37 - from before just two images nothing
17:39 - moving no parallax that we can observe
17:41 - i'm gonna go ahead and start
17:42 - implementing
17:44 - the uh basics of this parallax
17:47 - so if i go ahead in my main
17:51 - so i'm gonna go down here to
17:54 - where we have our background so we need
17:56 - a couple of new things
17:58 - so along with our background image we
18:00 - need to keep track of how much it's
18:01 - scrolled because we're going to start
18:03 - drawing this image to the screen but if
18:05 - we're going to scroll it that means that
18:06 - we need to shift its x offset we need to
18:08 - instead of drawing it at 0 0 if we want
18:10 - it to scroll we have to draw it at some
18:12 - negative value instead
18:15 - over time this will have the effect of
18:16 - it moving right to left so i'm going to
18:19 - go ahead and keep track of a i'm going
18:20 - to use a variable to keep track of the
18:22 - scroll amount for both of these images
18:24 - and we're going to call them background
18:25 - scroll and ground scroll and set them to
18:26 - zero so this is going to have the effect
18:28 - of no x offset so i could use this
18:31 - variable right now
18:32 - in this draw call down here which i'm
18:34 - actually going to do i'm going to go
18:36 - ahead and go to
18:38 - i'm just going to find that that is
18:39 - correct i'm going to go ahead and set
18:42 - that to
18:43 - negative
18:45 - background scroll whoops
18:49 - and here i'm going to set this to
18:51 - negative ground scroll so this is not
18:53 - going to change anything yet it's going
18:55 - to be the exact same thing because
18:56 - they're both 0 they were 0 before
18:58 - but
18:59 - we're going to change them over time
19:02 - and in order to do this i'm going to go
19:04 - ahead and go into
19:10 - are
19:12 - uh
19:13 - up here uh one thing before we before we
19:15 - do that actually uh we need to set a
19:16 - speed for this this is going to happen
19:18 - over time but
19:19 - since they need to occur at different
19:20 - rates the background needs to go at a
19:22 - slower rate than the foreground so that
19:23 - we do get this parallax effect we need
19:25 - two separate speed variables
19:28 - generally the
19:30 - norm for something that is not going to
19:31 - change is to write it in caps with
19:34 - underscores this is constant notation
19:35 - this is frequently seen in most
19:37 - programming languages we'll use it here
19:39 - i'm going to set a variable called
19:40 - background scroll speed and i'm just
19:41 - going to set that to 30.
19:43 - i'm going to do the same thing ground
19:45 - scroll speed
19:48 - does this need to be higher or lower
19:49 - than the background scroll speed
19:54 - the ground is going to move the so the
19:56 - background needs to move slower than the
19:57 - ground does
19:59 - so this is going to be higher so we're
20:00 - just going to set it to 60. you can set
20:02 - it to whatever you want to get the
20:03 - effect that you want but this will
20:04 - already be quite noticeable the ground
20:06 - is going to move twice as fast as the
20:07 - background
20:09 - and so what we're going to do also
20:12 - is
20:14 - if we just so what's going to happen if
20:15 - we just let our
20:18 - image scroll infinitely what's going to
20:19 - happen at a certain point
20:22 - it's going to run out of image so
20:24 - how do we fix this problem
20:27 - loop it exactly so we're going to go
20:29 - ahead and set a looping point so
20:32 - another
20:32 - constant background looping point
20:35 - and we're going to set this to 413 which
20:38 - you kind of have to look at your image
20:40 - and determine you you sort of have to
20:42 - set your images up if you want to
20:43 - achieve this effect by having them be a
20:46 - looping image so have either two copies
20:48 - of the exact same thing that's their
20:50 - screen with or just copy the same chunk
20:52 - over and over again there's many ways to
20:54 - do it in this case the looping point of
20:56 - the image of our our background is 413
20:58 - on the x-axis so we're going to set that
21:00 - to
21:00 - 413.
21:02 - and then we're going to go ahead the
21:04 - next step is we actually have to start
21:05 - uh changing the value so in our our
21:08 - update function which is where this is
21:09 - going to happen
21:12 - i'm going to go ahead and define
21:13 - love.update which recall lov2d will call
21:15 - for you but you must define it yourself
21:19 - i'm going to go ahead and set background
21:21 - scroll to
21:32 - so what this is going to do background
21:33 - scroll gets
21:35 - background scroll to itself plus the
21:37 - speed we set before times delta time so
21:40 - it stays frame rate independent
21:43 - um
21:45 - that'll have the effect of adding the
21:47 - speed to our image but we need to reset
21:49 - it we need to actually perform the reset
21:50 - and to do that we'll just be using
21:52 - modulus which recall from languages like
21:56 - c
21:57 - simply
21:58 - divides basically sets that value to uh
22:02 - the remainder of that division so in
22:04 - this case so
22:06 - 10 modulo
22:08 - 5 would be 0 but 10 modulo
22:13 - 9 would be
22:15 - 1 effectively because we have 0 left
22:18 - over once we divide 10 by 5 we have 1
22:20 - left over once we divide 10 by 9.
22:26 - so i apologize if that concept is uh
22:29 - not new
22:30 - but
22:31 - we're going to do the same exact thing
22:33 - for our ground
22:40 - only we're going to modulo by the ground
22:43 - or uh
22:44 - of our virtual width in this case
22:47 - i did not set a looping point i do in
22:49 - later examples but the our ground image
22:51 - is very uh it's consistent enough such
22:53 - that you don't even notice it when it
22:54 - loops without using a with just uh
22:57 - without just using the virtual width so
22:58 - we're just gonna use the virtual width
22:59 - in that case it's very
23:01 - um patterned and very small
23:04 - um and aside from that yeah we already
23:06 - have the off the background scrolls here
23:09 - in our render or draw functions so when
23:11 - we run this code we should theoretically
23:13 - have
23:15 - scrolling background
23:17 - so does the images have to be twice the
23:20 - width
23:21 - they do at least twice the width yes
23:23 - there's ways you could effectively tile
23:25 - your image
23:27 - and do it that way to save memory on on
23:29 - a texture size if you have like maybe
23:31 - something that's a quarter of the screen
23:33 - size that you want to loop over and over
23:34 - again you don't want to have that as one
23:35 - big image you'll just draw four copies
23:38 - of that image to fill your screen and
23:39 - then just shift all of them or maybe
23:41 - five actually so you have a little bit
23:42 - beyond the edge of the screen and then
23:44 - just put all of them back to
23:48 - the bottom line the zero is
23:51 - you you wouldn't know
23:52 - if you
23:53 - just restarted showing the image but the
23:56 - the larger background you would have to
23:57 - worry about
23:59 - the mountain getting cut in half when
24:00 - you replaced it right exactly
24:03 - so like we could uh we could actually i
24:05 - could show you right now what that'll
24:06 - look like so if we just take out the
24:08 - looping point here
24:10 - or we set it to some like value that's
24:12 - completely inaccurate like 270
24:15 - and then we run it
24:17 - after a while
24:23 - should just cut yep right there so are
24:26 - you stacked so are you drawing it twice
24:28 - really like one after another when it
24:29 - runs out
24:30 - no the image is so wide that it always
24:33 - will fill the screen even after it's
24:35 - been uh set back to even after it's gone
24:37 - past the looping point i forget how
24:39 - large the texture is
24:40 - it is
24:42 - yeah 1157 pixels wide so it's more than
24:44 - twice the screen width actually i think
24:46 - it is exactly twice the screen width um
24:48 - no it's not exactly how the screen is
24:49 - but it's more than twice the screen
24:51 - width so that when the amount the 413
24:53 - pixels has elapsed it's still plenty
24:55 - past the right edge of the screen and
24:57 - the looping part
24:59 - it'll be the exact same
25:01 - appearance on the texture but it's
25:02 - completely been shifted back to the
25:04 - right so that zero zero is now at zero
25:06 - the zero zero of our image is now at
25:08 - zero zero in our screen space
25:13 - it's just taking it your image is here
25:15 - moving and then just instantly back to
25:17 - the beginning and then and moving back
25:19 - to it that's why and the setting it back
25:21 - to zero or however technically how many
25:23 - pixels has gone past the edge of the
25:25 - screen
25:27 - because using modulo
25:31 - yep
25:32 - it's a translation it's an instant
25:34 - translation it takes place over one
25:35 - frame so you don't notice it your human
25:36 - eye can't see it because it literally
25:38 - happens in one frame and it the exact
25:40 - the the image data is the exact same at
25:42 - those two points
25:43 - because we have a texture we've
25:45 - pre-created a texture that has the exact
25:47 - same data so that you have that effect
25:49 - you have to have a texture that allows
25:51 - you to do this or smartly draw four of
25:54 - the same images keep track of all four
25:56 - of them or actually eight of them so
25:58 - that you can move them to the left and
26:00 - then shift them all back to the right
26:11 - when we get to super mario brothers
26:12 - we'll be talking about a concept called
26:14 - tile mapping which is where we take a
26:16 - sprite sheet and then you uh
26:18 - basically chop it up into pieces have a
26:21 - map in that is basically numerical so
26:23 - that a brick is uh like one the value
26:26 - one and then you look through this giant
26:27 - two-dimensional array that you have and
26:29 - then go over it iterate over it and then
26:31 - draw a tile like give at an offset based
26:33 - on your index into that map
26:35 - so it's a little bit more complicated
26:37 - and you actually a lot more memory
26:38 - efficient but
26:40 - slightly different slightly different
26:42 - implementation
26:48 - okay so
26:51 - we have parallax scrolling now
26:53 - um i want to take a moment to
26:55 - because we've touched on we've sort of
26:58 - this is this is a very sort of
26:59 - introductory way of demonstrating that
27:00 - games our illusions by using parallax
27:02 - scrolling we've all we've done really is
27:04 - just set two things to scroll at
27:06 - different rates and this has made us
27:07 - feel like we have depth in our scene but
27:09 - all we're doing we have two images we're
27:10 - scrolling them at different rates um
27:13 - but this is a common theme in game
27:15 - development is taking trying to devise a
27:18 - scene that maybe is very elaborate
27:20 - but doing it on very resource intensive
27:22 - devices uh like your iphone or like you
27:25 - know old consoles like the nintendo 64
27:27 - these sort of illusions are all over the
27:29 - place and a youtube channel that i um
27:34 - that i recently found that i really like
27:37 - is it's called the name of the channel
27:39 - is she says but the actual show that
27:41 - they have is called boundary break and
27:42 - what they do is they take a camera
27:45 - that it goes beyond what the game
27:47 - developers allowed it to do was they
27:49 - basically hacked the game camera so you
27:51 - can see in places where you weren't
27:52 - supposed to see before and you can see a
27:54 - lot of really cool trickery um i'm about
27:57 - to show you a couple of video clips but
27:59 - here's the youtube url if you're curious
28:00 - to see the exact video it's about 33
28:03 - minute video um it's on zelda ocarina of
28:06 - time for the n64
28:07 - uh and
28:09 - i'm i extracted a couple of particularly
28:11 - noteworthy clips that i thought were
28:12 - kind of interesting and also humorous
28:15 - i'm gonna go ahead and show the clip now
28:16 - so if we could dim the lights
28:20 - i'll go ahead and start this is a the
28:22 - first example
28:24 - okay so there's a lot to talk about with
28:25 - the shop owners in ocarina of time so
28:27 - i'm gonna just condense it down to the
28:29 - most interesting and the first one we're
28:30 - going to talk about is the bizarre shop
28:32 - owner in hyrule now in majora's mask
28:35 - this very same character is actually
28:37 - shown with legs but in our current time
28:40 - he did not have those in fact he looks
28:43 - extremely hilarious
28:45 - without his legs
28:50 - so this is a
28:52 - do we do does anybody have an instinct
28:53 - as to why they might have done this this
28:55 - way
28:57 - exactly and beyond that also just saving
29:00 - on
29:00 - memory right like not having to load a
29:02 - character model the vertices and
29:03 - textures associated with it
29:05 - on a such a memory constrained device
29:07 - like the n64 i forget how many how much
29:09 - memory it had like four megabytes of
29:11 - memory i think less than that um and so
29:14 - they were obviously cutting however many
29:15 - corners they could in this case by
29:17 - literally using
29:18 - the illusion of looking at not the
29:20 - illusion but just sort of like the fact
29:21 - that you only could see over the counter
29:24 - and sort of giving you the illusion that
29:25 - there's a fully living talking
29:27 - shopkeeper there but it's just a half a
29:28 - model
29:30 - and another example here uh is more to
29:33 - show how uh ocarina of time used its
29:36 - limited memory the n64 limited memory to
29:39 - give you the sense of being in a very
29:40 - large level when you might not actually
29:42 - have been so if you get in the lights
29:43 - one more time i'll go ahead and show
29:45 - this
29:46 - so this one was apparently a hot
29:48 - suggestion
29:51 - which is free camera on death mountain
29:53 - including our friend big goron
29:56 - the smoke halo looks sort of weird
29:58 - against the black sky
29:59 - and here you can see a nintendo fuldas
30:02 - it's not a full mountain only the cliff
30:04 - face is actually rendered
30:06 - that's the path leading towards the fire
30:07 - temple
30:09 - and if we zoom out we can see the scale
30:11 - of the whole map
30:12 - bigger than i thought it'd be actually
30:15 - the battle music's not quite fitting for
30:16 - an epic panning shot though
30:19 - same idea here really just limited
30:22 - memory space so let's load you know as
30:24 - much as we could possibly ever see from
30:26 - the perspective the camera of link
30:29 - and it's actually very similar to how i
30:31 - guess people
30:32 - create stages in real life to make you
30:34 - feel as if you're in a when you go to a
30:36 - play feel like you're actually in a
30:38 - scene but you know they've clearly cut
30:41 - as many corners as possible but it works
30:42 - in the game you can't tell and that's
30:44 - very common in game development and
30:46 - something
30:47 - if you're trying to achieve a
30:48 - particularly grand effect is something
30:50 - to think about is how can i make it seem
30:52 - like i'm doing something but i'm
30:54 - actually not how can i make it seem like
30:56 - i'm a bird flying through an infinite
30:58 - series of levels but i'm actually not
31:01 - we have a lot of
31:03 - sort of more of that to show coming up
31:05 - soon we have uh so so far we have
31:09 - our background but we don't have the uh
31:12 - title character of our game
31:14 - in the in this case uh 50 bird so i'm
31:16 - going to go ahead and
31:18 - illustrate how we can get a bird
31:20 - actually rendering on the screen
31:23 - so i'm going to go ahead into my
31:25 - bird 2 directory here that i've created
31:28 - note again bird 2 in your directory if
31:30 - you've loaded the code is going to have
31:31 - the complete implementation
31:34 - but in main
31:37 - i'm going to do a couple things so
31:38 - actually first thing i'm going to do
31:39 - we're going to notice that i've included
31:42 - actually i haven't included the
31:44 - class um
31:47 - file so i'm going to do that right now
31:49 - so in bird one or sorry i'm gonna take
31:52 - from bird three the class.lua i'm gonna
31:53 - go ahead and put it into bird two
31:56 - because we're gonna make a bird class
31:57 - recall from last week a class is just a
31:59 - way of taking several variables that we
32:01 - might once have had disparate from one
32:02 - another putting them in together in a
32:04 - package putting functions associated
32:06 - with those variables together so that we
32:08 - can call
32:09 - we we can sort of think of our world our
32:10 - game world more abstractly
32:13 - and more compartmentalized and cleaner
32:15 - so i'm going to go ahead and now i have
32:17 - in bird 2 the class.lua that's just the
32:19 - library we're using to get classes in
32:21 - love2d in lua i'm going to go ahead and
32:24 - i'm going to create a new file
32:25 - this one's called bird.lua so remember
32:27 - the trend is for classes capitalize them
32:30 - to differentiate them from
32:32 - functions and variables
32:35 - this one i'm going to go ahead and just
32:38 - go ahead and
32:39 - use my cheat sheet here
32:47 - poetry
32:51 - my sheets are sticking together
32:53 - okay
32:55 - so this bird class is actually fairly
32:56 - simple uh recall that all we have to do
32:59 - to create a class is just use the class
33:00 - library the capital c with the brackets
33:03 - there to initialize it
33:05 - we're going to go ahead and define our
33:06 - init function so every
33:08 - class has an init function which
33:10 - initializes the object that it's going
33:13 - to refer to later
33:16 - in this case we're going to need a few
33:17 - things so we're going to need an image
33:19 - for our bird because we want to draw to
33:21 - the screen and so what we need to do
33:23 - same thing that we did before
33:24 - love.graphics.new image i'm going to go
33:26 - ahead and hide this really fast and then
33:29 - bird.png
33:31 - simple easy
33:33 - we want the
33:34 - width and the height of our bird
33:37 - so i'm going to go ahead and
33:39 - set that too so uh
33:41 - every image has a
33:43 - set of functions associated with it that
33:45 - love implements for us the image that we
33:47 - get back from love.graphics.new image is
33:50 - itself sort of a class which has a
33:52 - function called get with so this will
33:55 - allow us to achieve the width
33:56 - dynamically of whatever
33:58 - class we
34:00 - whatever image file we happen to
34:02 - allocate and create an object from
34:05 - and then we're going to go ahead and set
34:06 - our x and y because recall we have to
34:08 - draw it somewhere we want to draw our
34:09 - bird in the middle of the screen so
34:11 - we're going to go ahead and just
34:13 - calculate this based on our virtual
34:14 - width so we're going to do virtual width
34:16 - divided by 2. so it's halfway in the
34:18 - middle of the screen but
34:19 - since it draws from the top left corner
34:20 - we want to shift it to the left so we're
34:22 - going to use our width that we just uh
34:27 - instant error we just initialized from
34:29 - the image data
34:30 - and then we're going to call it our do a
34:32 - self.width divided by 2. so we're going
34:34 - to divide the width by 2
34:36 - shift that to the left on our x-axis
34:38 - that's going to put us in the middle
34:40 - horizontally vertically it's the exact
34:42 - same thing
34:43 - except we're using height instead of
34:45 - width and that's pretty much it except
34:48 - for one last
34:50 - bit here we want to be able to render
34:52 - our bird pretty important so we're going
34:54 - to do love.graphics.draw
34:57 - um our image
34:59 - and then at self.x self.y
35:03 - and so this is uh all we really need
35:05 - just to get a very simple sprite onto
35:07 - the screen now it's not going to do
35:09 - anything because this sort of lives in a
35:11 - vacuum at the moment what we need to do
35:13 - is in our main file we're going to
35:15 - require bird
35:17 - which is going to actually put it into
35:18 - our allow us to use it in our code
35:22 - we're going to
35:28 - create a local
35:31 - bird variable we're just going to call
35:33 - it bird
35:35 - we're going to after that
35:39 - simply
35:44 - render to the screen like that
35:47 - and if all
35:48 - is done and well
35:49 - and if i'm in the right directory
35:54 - uh it did not work
35:58 - make sure make sure you save your work
36:00 - again
36:02 - uh oh i
36:05 - did not require class my bad so also we
36:08 - need to do
36:10 - this since we added that to our
36:12 - directory
36:14 - uh i did not include the bird.png as
36:17 - well so i'm gonna go ahead and do that
36:19 - i'm gonna borrow that from the next
36:20 - directory
36:21 - that should be all we need to do and
36:25 - uh
36:26 - attempt to call method render a nil
36:28 - value
36:29 - interesting
36:32 - did i not save bird i did not save bird
36:36 - there we go we did it
36:38 - so uh not particularly interesting but
36:40 - it's sort of you know we're making steps
36:42 - remember to save your work
36:44 - yes
36:44 - we can see i do not
36:47 - um but we're making progress we have we
36:49 - have our our entity that we will control
36:52 - so uh you know we have visually we have
36:54 - we're getting very close but a lot of
36:56 - important details are missing
36:59 - what
37:01 - should be the next step do we think
37:10 - and we'll do that with the help of a
37:12 - notion that's common in platformers and
37:14 - a lot of games really but gravity how do
37:16 - we how do we think we can simulate
37:17 - gravity in the context of 2d game
37:19 - development
37:22 - just by default fall at a constant rate
37:25 - we could do that certainly um and that's
37:27 - effectively what we will be doing we'll
37:29 - be using
37:30 - something that we used last week which
37:32 - was
37:33 - velocity delta y
37:36 - and applying that velocity
37:38 - uh
37:39 - to our
37:41 - bird's y frame by frame and that will
37:43 - give it the illusion
37:46 - of falling now falling at a constant
37:48 - rate isn't accurate to what gravity
37:50 - actually does what we want to do
37:52 - probably is some gravity
37:54 - over and over again increment our
37:55 - gravity by some sort of constant value
37:58 - so that just like in real life things
38:00 - fall faster and faster
38:02 - and then we want to we want to add that
38:03 - to our y value
38:05 - so i'm going to go ahead and start
38:06 - implementing that now in bird three uh
38:08 - wrong repo so bird three
38:12 - we have everything that we had from
38:14 - before
38:16 - um except now
38:18 - i'm going to go ahead and in main.lua
38:25 - in our
38:31 - update function
38:34 - this is where we're actually going to
38:35 - want to
38:36 - perform the update logic
38:39 - for
38:41 - making the velocity apply to the bird
38:44 - we're going to defer that to the bird
38:45 - class we're going to assume that we have
38:46 - a method called update in our bird class
38:48 - which we're going to implement shortly
38:53 - and that's actually all we need to do in
38:55 - our main class it's sort of the beauty
38:57 - of having classes that you can delegate
39:00 - all this work to your main file though
39:03 - it's still getting quite large it's 108
39:05 - lines
39:06 - it's not
39:07 - two 300 400 you know thousands of lines
39:10 - of code because we're able to break out
39:11 - this code and sort of
39:14 - encapsulate it elsewhere
39:16 - so i'm going to remember to save it this
39:17 - time and then i'm going to go into the
39:20 - bird.lua file
39:23 - in that directory which is the same
39:25 - with comments because i loaded it from
39:27 - the official repo
39:29 - the same bird code that we wrote before
39:33 - i'm going to go ahead and do a couple of
39:34 - things so the first thing that i'm going
39:36 - to do
39:37 - is define a constant so
39:39 - i mentioned gravity before
39:42 - gravity is going to be a constant value
39:44 - just like it is in real life
39:47 - i'm going to define it to 20. or just
39:49 - some arbitrary value this is the value
39:50 - that i decided felt right but you can
39:53 - tune this however you want there's no
39:54 - right or wrong way to do it the less the
39:56 - gravity is the slower it'll fall and the
39:59 - more you'll feel like you're sort of in
40:00 - outer space or on the moon or whatnot
40:05 - we're going to also
40:06 - go ahead and
40:08 - define recall that we need some way to
40:11 - keep track of how our
40:13 - position is or how our bird is falling
40:15 - we want a velocity a y velocity this is
40:18 - going to update our position each frame
40:20 - and it's going to make it feel like
40:20 - we're falling so we're going to set our
40:23 - initial velocity to zero the burst is
40:24 - going to be in the middle it's not going
40:25 - to be falling yet
40:26 - what we want to do is apply this
40:29 - velocity
40:31 - so remember in our main file we had an
40:33 - up we assumed that we had an update
40:35 - function but we haven't actually
40:36 - implemented it yet so we're going to do
40:38 - that right now we're going to say
40:40 - word update dt it's going to we're going
40:42 - to pass it in the same dt that we use in
40:44 - our main file
40:47 - and we're going to go ahead and just say
40:50 - our velocity is equal to
40:53 - our current velocity
40:56 - plus
40:58 - gravity times delta time we're just
40:59 - going to scale gravity by delta time so
41:01 - it'll move the same amount no matter
41:04 - whether we're running at 10 10 frames
41:05 - per second or 60 frames per second
41:07 - and then we're going to go ahead
41:09 - we have a velocity but it's not actually
41:10 - changing our y value the y value is what
41:13 - ultimately moves us on the screen so we
41:14 - need to apply that uh our new delta y to
41:17 - our y so we're going to go ahead and
41:18 - just do
41:20 - that self.y gets self.y plus self.delta
41:23 - y d y
41:26 - and so if i go back into
41:28 - bird three
41:30 - assuming i saved everything we should
41:32 - just fall straight to the screen which
41:34 - we do not terribly useful
41:37 - but notice it it's kind of it's slightly
41:39 - hard to tell maybe but it does move
41:41 - faster and faster frame by frame because
41:43 - that delta y is increasing as well as
41:45 - our y and that that delta y is getting
41:48 - applied to our y frame by frame i'll do
41:50 - it one more time just let's find a look
41:51 - at all right so we have basic gravity
41:54 - super super basic computation just keep
41:56 - track of some gravity constant a delta y
42:01 - increase that and apply that to your y
42:03 - and that gives you gravity
42:05 - but flappy bird can jump so we need to
42:07 - define a way to defy gravity so we're
42:10 - going to do the in bird 4 we're going to
42:12 - call this the anti-gravity update and
42:14 - we're going to
42:16 - uh
42:17 - talk about how we can actually get that
42:19 - going so i found this diagram which i
42:20 - thought was pretty apt um and it also
42:22 - covers a few of the other concepts we're
42:24 - talking about today but see here this
42:26 - gravity that's the constant we just
42:28 - defined before the 20 or whatever and
42:30 - this gets applied at whatever value you
42:32 - want it to be this gets applied frame by
42:34 - frame to your y
42:36 - what we want is this this vector here
42:38 - this jump velocity
42:40 - we want some value
42:41 - to sort of counteract this gravity that
42:45 - we've been accumulating so how do we
42:47 - think we can go about doing this
42:51 - we can set gravity to some
42:54 - perhaps negative value a high value
42:56 - and that'll have the effect of
42:58 - frame by frame if we if we go from you
43:00 - know some positive value which is taking
43:02 - us down on the y-axis and we go to a
43:04 - negative value it's going to start frame
43:06 - by frame it's going to say let's say we
43:08 - start at negative 5 or we set its
43:10 - velocity to negative five
43:12 - it's going to set y to negative it's
43:14 - going to set it to plus negative 5
43:16 - pixels plus negative 4.9 pixels 4.8
43:19 - pixels it's going to shoot us up pretty
43:21 - fast in a series of pixels but since
43:23 - we're applying gravity frame by frame
43:25 - this value that we set before 20
43:28 - it's going to have the effect 20 times
43:30 - delta time so it gets effectively
43:31 - divided by 60.
43:33 - it's going to counteract this again so
43:36 - we're going to shoot up pretty fast but
43:39 - gravity is going to start taking hold
43:40 - immediately after and we're going to
43:41 - start getting
43:43 - the effect of our bird jumping and then
43:45 - falling down to the ground
43:47 - a couple of other things that this
43:48 - diagram shows which i thought were
43:49 - pretty cool
43:51 - this pipe gap or
43:53 - pipe gap distance here something that
43:55 - we'll be talking about pretty shortly
43:56 - because this needs to be defined so that
43:58 - we can offset our pipes
44:00 - pipe separation that's another thing
44:01 - we'll be talking about and also pipe
44:03 - width which is just an intrinsic value
44:04 - characteristic of the pipe sprite we'll
44:06 - be using but i thought it was a very apt
44:09 - nyu did a a nice little article if you
44:11 - want to look at this about exploring
44:12 - game space they computationally
44:14 - determined uh what would make a flappy
44:16 - bird level difficult or not and rated
44:18 - flappy bird levels that were dynamically
44:20 - generated based on some sort of scale so
44:22 - if you're curious it's in the slides but
44:24 - i thought it was a cool find as i was
44:26 - putting together this lecture
44:28 - so what we need to do is then simply add
44:31 - some negative
44:32 - value to gravity negative sort of
44:35 - anti-gravity so we're going to go ahead
44:36 - and do that so in bird four
44:39 - of the
44:40 - little mini ripa that i have here
44:46 - we're going to go ahead in main first
44:55 - one thing that we want to do
44:58 - is
44:59 - because another part of this is taking
45:01 - input from the user being able to jump
45:04 - we want to be able to
45:05 - detect whether they've pressed space
45:08 - but if we
45:09 - want to
45:10 - detect input for every single entity
45:13 - that we ever like in a game in an
45:15 - instance like this it's not terribly
45:17 - important
45:18 - but let's say we have like
45:20 - 20 or 30 different kinds of entities and
45:22 - they all have their own input handling
45:25 - we don't want to clobber maine with that
45:26 - necessarily so we can dedicate that
45:30 - delegate that i should say to another
45:33 - section of the code in this case we can
45:35 - sort of put our bird's input handling
45:37 - together with our bird class
45:39 - right and sort of expand up upon the
45:41 - model of the class or taking control of
45:44 - the code and data for that particular
45:47 - object in our scene
45:49 - so what we're going to do
45:52 - is
45:56 - in our
45:58 - love dot load
46:01 - i'm gonna go ahead and do
46:03 - something here i'm gonna go ahead and
46:04 - set i'm gonna go ahead and set
46:07 - love.keyboard.keys pressed equals a
46:09 - table and what i'm doing is just adding
46:12 - on
46:13 - to a table that love defines called love
46:16 - dot keyboard i'm adding my own value
46:18 - into it called keys pressed
46:20 - and i'm assigning it to an empty table
46:22 - so what we're going to do this is part
46:24 - of this is now part of what love gives
46:26 - us
46:27 - as part of its sdk but
46:30 - it's something that we've created
46:31 - ourselves and you can do this because
46:33 - in lua basically everything beyond basic
46:36 - variables or just tables and you can
46:38 - manipulate tables however you want in
46:40 - this case love.keyboard is a table i'm
46:42 - just adding a new key called keys press
46:43 - and i'm assigning it to an empty table
46:44 - of my own
46:46 - and we're going to see
46:47 - how this is actually used in just a
46:49 - moment
46:50 - so i'm going to go ahead in our key
46:52 - pressed function
46:54 - here
46:58 - this function gets called every time a
47:00 - user presses a key in the game but
47:04 - i'm going to use it
47:06 - because this because it does that
47:08 - i can go ahead and just do something
47:09 - like this
47:11 - love.keyboard.keys pressed
47:14 - key
47:15 - gets true
47:17 - and what that means is in this table
47:19 - that we've just defined we've created
47:20 - ourselves
47:22 - anytime the user presses any key because
47:24 - love.keypressed gets called for you
47:27 - we can safely rest assured that this is
47:28 - going to get populated no matter what
47:30 - key they've pressed because it's just
47:31 - something that love2d takes care of you
47:33 - but it's not getting stored until now
47:35 - now we're actually going to keep track
47:36 - of it in our own table
47:39 - for reasons that will become apparent
47:41 - very shortly
47:43 - the next part of this code
47:46 - is defining a custom function
47:49 - so the the impetus for this is
47:53 - love defines a couple of functions it
47:55 - defines a function called uh
47:58 - love.keyboard.isdown which takes in some
48:00 - key value and you can use it to test for
48:02 - continuous input which we did in the
48:04 - last
48:05 - the last lecture we're saying hey if up
48:08 - is down right now or down is down then
48:10 - we need to update our y velocity
48:12 - accordingly
48:13 - but it doesn't have a mechanism like
48:15 - this for let's say we want in some file
48:17 - other than main to check for if key was
48:19 - just pressed one time
48:21 - um it has this function love.keypressed
48:24 - which takes a key and that will trigger
48:25 - it but we can't access this outside of
48:28 - this function because if we define this
48:29 - function in bird.lua it's going to
48:32 - overwrite this implementation
48:34 - and we don't necessarily want to have to
48:36 - worry about other files overriding these
48:38 - functions because who knows if you're on
48:40 - a team especially who knows who's
48:41 - overwritten love.keypressed and what
48:43 - module and what order does it get loaded
48:44 - in and what function's actually valid
48:47 - we're going to take care of this problem
48:48 - by
48:49 - giving ourselves the ability to test for
48:51 - whether a key has been pressed on the
48:53 - last frame
48:54 - by
48:56 - implementing a function that we are also
48:58 - adding to the keyboard namespace the
49:00 - keyboard table ourselves called was
49:03 - pressed it's going to take a key
49:06 - and all it's going to do
49:08 - is check that table that we created
49:10 - before it's going to say if
49:12 - love.keyboard.keys pressed
49:14 - key then
49:18 - return true
49:21 - else
49:22 - return false and you could actually just
49:24 - return
49:25 - love.keyboard.keys pressed key and it'll
49:27 - be the exact same thing
49:29 - and so what this has the effect of doing
49:31 - is saying okay because on the update
49:34 - which we're about to see actually i
49:36 - should probably do that before so this
49:38 - all gets tied together
49:40 - um
49:41 - love dot at the end of love.update we're
49:44 - gonna do one last thing and that's reset
49:45 - that table
49:47 - because we wanna just check frame by
49:48 - frame
49:50 - so
49:52 - we have we have a table a global table
49:54 - that we've created to check for whether
49:56 - a key is pressed we have a callback
49:58 - function that love2td gives us that
49:59 - allows us to do that so every time a key
50:01 - gets pressed we're going to just add
50:03 - that key to that table and set it to
50:05 - true
50:07 - now we can just simply query that table
50:09 - anytime we want to with this function
50:10 - that we've created called
50:11 - love.keyboard.was pressed key which
50:14 - means on the last frame was that key
50:16 - pressed
50:18 - basically return whether it's true or
50:19 - false now the only problem is we're not
50:21 - flushing it we're not ever setting that
50:23 - to false that is the effect of if we
50:26 - just press all the keys in our keyboard
50:27 - those will always be false always be
50:29 - true
50:30 - until we reinitialize the table to some
50:33 - empty value which is what we do here on
50:35 - the update which takes place after all
50:37 - inputs been detected
50:39 - we're going to just set that table
50:42 - to an empty table again and on the next
50:45 - frame
50:46 - it's going to whatever keys we pressed
50:48 - those will get set to true and then we
50:50 - can just query that table here as needed
50:52 - and any update henceforth
50:55 - so does anybody anybody have any
50:57 - questions as to how this is operating
51:02 - and so the ultimate
51:04 - driving factor for us as to why we want
51:07 - to do this we want to put in the work to
51:08 - sort of keep track of this global input
51:10 - table
51:13 - is uh
51:14 - so that we can actually
51:16 - query input single key input
51:19 - based on
51:21 - or based in other files outside of
51:23 - main.lua because currently all we can do
51:25 - to check for single key presses is look
51:28 - in main.lua but that's not what we want
51:29 - to do
51:30 - we're going to go ahead
51:32 - and go to our bird.lua
51:36 - and in our update function this is where
51:39 - we actually get to use our efforts
51:42 - and say if love.keyboard.was pressed
51:47 - space
51:49 - which is the key that we want to
51:51 - actually allow us to jump
51:54 - go ahead and set self d y to what should
51:56 - we set self dot d y to when we press
51:58 - space bar
52:01 - should be a positive or a negative value
52:05 - a negative value
52:06 - we'll say it's negative five
52:08 - and we should probably define this as an
52:10 - anti-gravity constant up here but just
52:12 - for the sake of speed we'll say self.dy
52:14 - gets negative five
52:18 - and so
52:19 - and i did save that right i did save
52:21 - that i'm gonna go ahead and go into bird
52:23 - four
52:25 - go ahead and run this example
52:28 - and look at that
52:31 - we're jumping
52:32 - but we can still fall through the ground
52:34 - and we don't have any real gameplay but
52:36 - we've come a long ways now we've taken
52:38 - input single key input that we otherwise
52:41 - didn't have the ability to do in love2d
52:43 - and we've made it possible by just
52:44 - keeping track of our global input state
52:46 - and flushing it every update
52:49 - so does anybody have any questions as to
52:51 - how that works
52:53 - okay
52:55 - so
52:56 - the other big major visual component of
52:59 - flappy bird are these pipes that we see
53:01 - here on the screen we have
53:03 - two pipes there but the screen is filled
53:05 - with infinite pipes
53:07 - so
53:09 - does anybody have any instinct as to how
53:11 - we can implement this
53:16 - well we'll see before long but
53:18 - suffice to say we'll need a new sprite
53:22 - we'll need some sort of way of keeping
53:25 - track of when to spawn them
53:27 - because they sort of spawn you know
53:30 - after a period of time
53:32 - and that'll be sort of our gap
53:34 - and then what happened will happen if we
53:35 - just let it spawn forever and ever
53:42 - we do because if we don't do that after
53:43 - a certain period of time we're
53:44 - allocating memory for each of these
53:46 - pipes not a ton of memory
53:48 - um just you know essentially an x a y
53:51 - width and a height but
53:52 - because they all reference the same they
53:54 - will reference the same sprite image but
53:56 - given enough time eventually you're
53:58 - going to allocate a certain number of
53:59 - bytes that will exceed your computer's
54:01 - memory or the amount of allocated memory
54:03 - and you'll either hang infinitely or
54:05 - crash
54:06 - and so we want to destroy them as they
54:08 - go as well
54:11 - so we're going to go ahead and look at
54:14 - sort of the final live coded example
54:16 - just because from here on out it's going
54:18 - to be a little bit much i'm going to go
54:20 - ahead and go to
54:24 - main.lua first
54:30 - so
54:32 - just get my notes in order
54:35 - the first thing we want to do
54:37 - oh i'm actually in the wrong repo too i
54:38 - apologize i was in the district repo i
54:40 - want to be in the scratch repo
54:43 - so i'm going to go ahead go into main
54:50 - i'm going to require pipe now we don't
54:53 - have a pipe yet but this is a perfect
54:55 - example of how we can sort of
54:57 - keep abstracting our game we have
55:00 - a bird class but we should also probably
55:02 - have a pipe class because a pipe is a
55:04 - distinct type of entity in our game
55:05 - world we can sort of model it as a unit
55:08 - we can give it functions we can give it
55:09 - data and think about it in terms of it
55:12 - being a pipe not being a set of
55:14 - x y with height you know etcetera
55:17 - whatever whatever data you want to
55:19 - ascribe to it we can abstract that out
55:21 - and think in more abstract terms
55:23 - which will allow us to scale a little
55:24 - bit better so we're going to go ahead
55:26 - and assume that we have a pipe class i'm
55:28 - going to go ahead and go ahead and add
55:30 - it to our folder here right now so
55:32 - do a new file
55:35 - pipe.lua
55:38 - and i'm going to go ahead and reference
55:40 - my notes here for just a second
55:49 - go ahead
55:50 - and
55:52 - so the pipe class is actually quite
55:54 - simple
55:56 - just like the bird class was initially
55:59 - we don't need to keep track of a lot of
56:00 - data but we do want to keep track of a
56:03 - few things so the bird
56:06 - there's only ever going to be one bird
56:08 - out at once
56:09 - but with the pipes we're going to be
56:10 - spawning them over and over again and so
56:13 - if we allocate them
56:15 - out for each
56:16 - pipe that we instantiate if we allocate
56:18 - a new image
56:19 - this is probably not super efficient
56:21 - right we're using the same exact data we
56:24 - have a bunch of pipes we only really
56:25 - need one sprite
56:28 - so outside of the init function so just
56:31 - below where we're declaring that pipe is
56:33 - a class
56:35 - we're going to go ahead and create a
56:36 - local variable that is still scoped to
56:37 - this file
56:39 - but there's only ever going to be one
56:41 - copy of this object
56:44 - we're going to go ahead and call it
56:46 - say that we have pipe.png in this folder
56:50 - and this is sort of separated out from
56:51 - the functions that we're going to be
56:52 - defining in here but this has the effect
56:54 - of sort of creating a semi global
56:58 - graphics object even though it's
56:59 - contained within this this class file
57:02 - it's not accessible outside of this
57:03 - class file because we don't need it to
57:04 - be but it's also not being instantiated
57:07 - every single time because recall if we
57:09 - look at bird.lua
57:13 - here
57:15 - we're just setting it as self.image gets
57:19 - love.graphics.newimagebird.png this will
57:20 - have the effect of allocating a new
57:23 - image every time we create a bird object
57:25 - but we only ever create one bird object
57:27 - so it's not really an important design
57:29 - consideration for us to say maybe we
57:31 - should create a you know
57:33 - global semi-global
57:35 - image up here it's not
57:37 - it's not important in this in this
57:38 - context probably good style to do so
57:40 - anyway for larger projects but um just a
57:43 - consideration for here not really
57:45 - something we need to worry about but yes
57:47 - definitely
57:49 - try to take an asset and reference it as
57:52 - reference it rather than allocate it as
57:55 - many times as possible
57:57 - um
57:58 - we want our pipes to scroll so we need
58:01 - some sort of value just like we did with
58:02 - the backgrounds we need some value that
58:04 - keeps track of whether these pipes are
58:06 - scrolling and it can be a constant value
58:08 - we're going to directly call it negative
58:10 - 60 this time and not sort of negate it
58:12 - when we add it to our
58:15 - position later on
58:18 - so
58:19 - pipe scroll negative 60 we can just add
58:21 - it directly to our
58:22 - x or to our
58:24 - well yeah in this case just to our x and
58:26 - then we'll have the times delta time of
58:27 - course
58:28 - and
58:29 - that'll have the effect of shifting it
58:30 - left because it's a negative number
58:33 - we'll define the init function here so
58:35 - pipe init
58:37 - within the init function we're gonna do
58:39 - a couple of things so uh it's x where
58:43 - should the x be
58:45 - what should the x be set to
58:47 - let's say if we want the pipe to spawn
58:49 - beyond the right edge of the screen
58:52 - yep
58:55 - virtual width
58:57 - and you could you could also say virtual
58:58 - width plus some number if you wanted to
59:01 - because it's set to zero zero uh it's
59:03 - going to have the you won't see it on
59:05 - the frame that it gets instantiated
59:07 - but
59:08 - yes virtual width or virtual width plus
59:10 - some constant value or some value that
59:12 - you've uh allocated ahead of time we'll
59:14 - just set it to virtual width so as soon
59:16 - as the pipe gets initialized it will be
59:17 - invisible but it's going to be right on
59:19 - the right edge of the screen
59:22 - what about our y value
59:24 - first of all let's take a look at what
59:26 - the image looks like so we can
59:28 - see
59:29 - it's going to be in our
59:31 - i don't think i have the actual image in
59:33 - that directory so i'm going to come here
59:35 - when i grab the pipe this is what the
59:36 - pipe looks like
59:38 - let's see if i can expand it a little
59:39 - bit
59:44 - so it's kind of tall where should we
59:46 - probably place it if we want it to look
59:49 - sort of similar to flappy bird
59:54 - probably towards like the lower end of
59:56 - the screen
59:57 - we can get fancy with it too and we can
59:59 - even maybe make it randomized
60:02 - just like flappy bird so we'll go ahead
60:03 - and do that i'm going to go ahead and
60:04 - copy this
60:05 - and put it into our scratch folder here
60:10 - back in the init function i'm going to
60:11 - go ahead and set self.y too
60:14 - because
60:15 - we want to talk about procedural
60:16 - generation this will be sort of our
60:17 - first foray into how we randomize this
60:19 - we'll be using the function that we used
60:22 - last week and this is a ubiquitous
60:24 - function you'll see this everywhere and
60:25 - any framework or game engine you use
60:29 - math.random
60:31 - we want it to be
60:32 - the lower half of the screen so let's
60:34 - say
60:35 - virtual height divided by 4 is the upper
60:37 - bound and maybe virtual height minus
60:40 - 10. as the upper bound
60:44 - so that'll have the effect of setting it
60:46 - to
60:46 - roughly a quarter of the screen or sorry
60:49 - virtual height divided by 4 is towards
60:51 - the top end of the screen
60:53 - and then virtual height minus 10 is the
60:54 - lower end of the screen so it's actually
60:55 - going to cover
60:56 - anywhere from the first quarter below
60:58 - that down to about 10 pixels from the
61:00 - bottom
61:04 - i do it in main so in this file i
61:07 - am not sure if i did it for this
61:10 - demonstration it is definitely set in
61:12 - the repo
61:14 - the
61:16 - i don't think i said it in this example
61:17 - but yes you would set the random seed
61:19 - here if you wanted to run every time oh
61:21 - sorry and the question was do we uh
61:24 - should we set the random seed in the
61:26 - bird file or should we set it in
61:27 - main.lua typically you want to set it at
61:30 - the top level of your application so
61:32 - we're going to set it in um
61:36 - we're going to go ahead and set it in
61:37 - the
61:39 - in main
61:41 - and the
61:43 - function itself
61:45 - is
61:52 - here and i think it's starting in bird
61:53 - six onwards so it'll be
61:58 - uh
62:00 - did i not set it i may not have set uh
62:02 - the random seed until later in the repo
62:04 - let's check bird 12.
62:09 - so yes math.randomseed and then
62:11 - seedbyos.time as we used last week in
62:14 - class
62:16 - um i won't
62:18 - i'll set it here um
62:20 - probably will only run it once but it'll
62:22 - it'll have the effect now we can run it
62:24 - several times just to see the the
62:25 - difference in the pipes
62:27 - let's go back to
62:29 - our
62:30 - pipe.lua here
62:34 - and we have the x we have the y so those
62:37 - are set accordingly
62:39 - we also want to set the width does
62:41 - anybody recall uh
62:43 - what the function is to get a the width
62:45 - of a graphics object
62:50 - and the syntax for that
62:53 - so we have our image up here
62:55 - pipe image
62:56 - love.graphics.new image pipe.png
63:03 - exactly so we're going to go ahead and
63:04 - set this to pipe image colon get width
63:08 - and that will become our new that'll
63:10 - allow us to start with for when we um
63:13 - we will use it later
63:17 - um
63:18 - and then we need a few other functions
63:20 - so the pipe will spawn but it won't move
63:23 - because we haven't applied any sort of
63:25 - scrolling to it we have the scrolling
63:27 - variable up on line five but we need to
63:29 - actually apply it to our pipe so we're
63:31 - gonna go ahead and create an update
63:32 - function
63:35 - and then in that update function very
63:37 - similar to what we've seen before
63:39 - already
63:40 - pipe scroll times delta time
63:43 - and then lastly we want to render our
63:45 - pipe so we're going to go ahead and call
63:49 - function that we've seen already today
63:50 - love.graphics.draw we're going to use
63:52 - the pipe image
63:53 - up above
63:56 - and then we're going to go ahead and uh
63:59 - use self.x
64:01 - and self.y and that's all we need for
64:04 - our pipe
64:07 - and
64:08 - let me make sure that that's all we
64:09 - really need so in main.load we got to go
64:11 - back to main.lua too because we actually
64:12 - have to start spawning pipes
64:15 - um
64:17 - so let's go ahead and go to
64:21 - pull up my
64:22 - code here one more time
64:26 - in
64:27 - maine so on line
64:29 - 59 or sorry you won't see it you'll see
64:32 - it line 59 in the actual distro code but
64:34 - um
64:35 - for me it's going to be different
64:36 - slightly different
64:38 - we're going to go ahead and create a new
64:40 - table to keep track of all the pipes
64:42 - that we want to spawn
64:43 - because we need a way to store them in
64:44 - memory we can't just set you know one
64:46 - variable to
64:48 - basically a dynamic almost like a
64:49 - dynamic array in this case
64:51 - but we're going to or a linked list
64:53 - rather we're going to use this table
64:55 - just to hold them we're not going to
64:56 - give them keys we're just going to
64:57 - insert them like we would do with just a
64:59 - linked list like in python for example
65:03 - we're going to go ahead and
65:07 - what do we need to do if we want to
65:10 - sort of have them spawn after a certain
65:12 - period of time
65:16 - probably want to like have some sort of
65:18 - timer we want to like keep track of how
65:20 - much time has passed and maybe have some
65:22 - sort of amount of time that's our like
65:24 - trigger to spawn up a pipe let's say
65:26 - maybe like two seconds
65:28 - so
65:29 - if we set a timer to zero it's gonna
65:31 - start just at zero but we can add to
65:34 - this frame by frame we can just increase
65:36 - this timer by delta time whatever that
65:39 - is frame by frame it'll be about a 60th
65:41 - of a second
65:42 - so um
65:45 - after 60 frames have passed we'll get
65:46 - one second after 120 frames of pass
65:49 - we'll have two seconds at that point we
65:51 - can then decide okay now it's time to
65:53 - spawn a new pipe let's go ahead and do
65:54 - that
65:56 - so i'm going to go ahead and
65:57 - [Applause]
65:59 - in our
66:01 - update function
66:06 - we want to
66:08 - handle
66:10 - the actual
66:11 - increasing of this timer so
66:14 - it's as simple as
66:16 - make sure that i called it spawn timer i
66:18 - don't i just called it timer let's go
66:20 - ahead and call it spawn timer be a
66:21 - little more uh specific about what we
66:23 - want here so our spawn timer and then
66:26 - we're going to go ahead in our update
66:27 - and set spawn timer equal to
66:30 - spawn timer plus delta time
66:34 - and then
66:37 - what we need to do is then check
66:39 - is our spawn timer
66:41 - greater than because it keeps track of
66:43 - time in seconds delta time will give you
66:44 - a fractional amount in seconds so it'll
66:46 - be at .013 or something like that
66:49 - we want to keep track of whether spawn
66:50 - timer's gone past two
66:53 - right so if spawn timer
66:57 - is greater than two
67:00 - we want to
67:01 - add a new pipe does anybody remember the
67:03 - function for how to add to a table in
67:05 - lua
67:09 - so it's table dot insert
67:12 - so table dot
67:13 - will take in a table so in this case we
67:16 - want the pipes table that we allocated
67:18 - before
67:19 - and then we're going to put in a new
67:21 - pipe object we're going to call this is
67:23 - how you instantiate an object or call
67:25 - parentheses
67:26 - that will have the effect of now our
67:28 - pipes
67:29 - table
67:30 - is going to every time we call this it's
67:31 - going to get a new index so it's going
67:33 - to start at 1. lua tables are indexed at
67:35 - 1.
67:37 - first time it happens index 1 is going
67:39 - to be equal to a new pipe object which
67:42 - is going to start its x y at the edge of
67:44 - the screen
67:45 - then
67:46 - index 2 will be the exact same thing a
67:48 - new pipe that's at the edge of the
67:49 - screen and so on and so forth every time
67:52 - we call table.insert
67:56 - once our spine timer has exceeded two if
67:58 - we want this to not spawn a pipe every
68:01 - frame here after
68:03 - which would quickly clog up our uh our
68:05 - world we want to reset our spawn timer
68:07 - to zero so this will have the effect of
68:08 - now it's going to wait another two
68:10 - seconds
68:11 - and then this condition will be true
68:12 - again and then we can add a new pipe to
68:14 - the scene
68:18 - let's go ahead and look at
68:22 - a we're going to need to add a new um
68:27 - set of logic here actually i'm going to
68:29 - put all of this above
68:32 - the bird dot update
68:38 - and then below that i'm going to go
68:40 - ahead and do
68:42 - i'm not sure if we've covered this
68:43 - already don't think we have but if we
68:44 - want to iterate over a table there's a
68:47 - function that lua gives you called pairs
68:48 - it will give you all the key value pairs
68:51 - of a table
68:52 - that you can then use while you're
68:54 - iterating over it similar to enumerate
68:56 - and python if familiar except this will
68:58 - actually give you the keys
69:00 - rather than just the indices so we can
69:02 - do for k pipe in pairs of pipes
69:06 - do
69:10 - some body of code and then we have
69:12 - access to the key and the pipe within
69:14 - this we can just iterate over it and use
69:16 - it
69:17 - so first thing we want to do is we want
69:18 - to update our pipe
69:20 - so for each pipe update it give it the
69:22 - delta time of the current frame
69:26 - and then what was the other important
69:28 - feature so this will have the effect of
69:30 - scrolling it now it's going to get its x
69:32 - shifted but what was the other important
69:33 - thing we need to do with every pipe in
69:35 - our scene
69:42 - yes
69:43 - that is exactly true so what we're going
69:45 - to do is if
69:47 - pipe.x
69:49 - is less than
69:50 - so if we did less than zero
69:53 - what do we think would happen
69:57 - it would have it would we would see it
69:59 - instantly disappear because it's
70:01 - they're based on the top left coordinate
70:03 - so what we need to do is keep track of
70:06 - its width so what we'll do is we'll just
70:08 - say if pipe dot x is less than
70:11 - negative pipe dot width
70:14 - which will allow the pipe to go all the
70:15 - way past the edge of the screen
70:19 - we'll call a function called
70:21 - table.remove which takes a table in this
70:23 - case pipes
70:24 - and then it takes a key and the key we
70:27 - have access to up above on line 124 we
70:29 - can just say
70:30 - k and that'll have the effect of
70:32 - removing that pipe from the scene
70:36 - and then as soon as that's done uh
70:39 - we're good to go the last thing that we
70:41 - need to do
70:42 - is currently we're not actually drawing
70:43 - the pipes to the screen so
70:45 - down below in our render function we're
70:48 - going to go ahead and up above before we
70:51 - do the ground
70:52 - because if we do it normally if we do it
70:55 - after we we render the ground it's going
70:57 - to the pipes are going to look like
70:58 - they're just kind of like layered on top
70:59 - of the ground we want it to look as if
71:01 - they're sticking out from the ground so
71:03 - what we want to do
71:04 - is have a correct render layer a render
71:07 - draw order to the screen we draw the
71:08 - background we draw the pipes then we
71:10 - draw the ground and this will have the
71:12 - effect of looking as if the pipes are
71:13 - sticking out of the ground so what we'll
71:15 - do is we'll do the exact same thing we
71:17 - just did up above
71:19 - by saying for k
71:20 - comma pipe in pairs of pipes
71:24 - do
71:29 - uh pipe and then the render function
71:31 - that we defined in pipe and also the
71:33 - effect of iterating through all the
71:34 - pipes in our scene every draw call
71:37 - and drawing them before it draws the
71:39 - ground and before it draws the bird and
71:41 - that should be all that we need to
71:43 - illustrate this example make sure
71:45 - everything is saved i'm going to go
71:46 - ahead and go into bird five
71:50 - if i did everything correctly this
71:52 - should
71:54 - after a certain period of time
71:56 - draw pipes to the screen that are
71:58 - scrolling and they're randomized their y
72:00 - value is getting set to
72:02 - some value between the top quarter of
72:04 - the screen so about starting right about
72:06 - right where flappy bird is right now
72:08 - down to about 10 pixels above the width
72:11 - of the screen which actually that looks
72:12 - like 10 pixels above so that's a slight
72:13 - bug should probably be something along
72:15 - the lines of 30 or 40.
72:17 - we won't encounter that in the final
72:19 - distro because they're not set to spawn
72:21 - that low
72:22 - but you can see how this is sort of the
72:25 - beginning of our procedural level
72:27 - generation system
72:28 - and we have most all the components of
72:30 - our scene now
72:32 - we get normally in flappy bird we have
72:34 - two pipes we have a pipe that's above
72:37 - and then a pipe that's below and they're
72:38 - sort of in pairs and the next example
72:41 - we're actually going to start
72:41 - illustrating this we're going to have
72:42 - pairs of pipes that are joined together
72:45 - which scroll together that once you fly
72:47 - through them you score a point
72:51 - but for now we sort of have all the
72:52 - pieces that we need in order to get uh
72:55 - you know
72:55 - sort of have the basic visual
72:58 - uh sense of the game completed we're
73:00 - going to take a like a five minute break
73:02 - now and then once we come back we'll
73:04 - actually dive into how we can get pairs
73:06 - of pipes into our scene and may start
73:08 - getting into scoring and some other fun
73:09 - things like music so
73:13 - all right welcome back so the next part
73:16 - so before we establish the
73:18 - bird the background the pipes we have
73:20 - all the visual aspects of our game
73:22 - sorted ready to go
73:23 - the next important piece of the puzzle
73:25 - to really solve is how can we start
73:26 - scoring
73:28 - our game and also how can we get the
73:29 - pipes matching the way that they are
73:31 - implemented in the actual game which
73:33 - recall they're
73:35 - normally in pairs as illustrated here
73:38 - and we also see on the right hand side
73:40 - as we've covered already so far we have
73:41 - the spawn zone for our pipes and on the
73:43 - left we have what i've labeled the dead
73:45 - zone where pipes are sort of
73:46 - de-instantiated
73:48 - once they've gotten past the negative
73:51 - width of themselves but pipes come in
73:53 - pairs they get shifted and the once the
73:56 - bird flies between these gaps is
73:59 - ultimately when they've scored a point
74:00 - and so we need a way to pair pipes
74:02 - together and sort of
74:04 - uh define this sort of logic for how can
74:07 - we tell whether the bird has gone past
74:09 - the the gap and whether or not
74:12 - the pipes have been de-instantiated so
74:15 - we're going to go ahead and i'm going to
74:17 - probably stop live coding for the rest
74:19 - of the demonstrations because they're
74:21 - going to be a little bit more complex
74:23 - but
74:25 - i believe my code editor is over here
74:28 - i'm going to go ahead and open up
74:30 - oh this is my other editor okay so in
74:33 - the base repo now we're going to go
74:35 - ahead and look at the full example so in
74:37 - bird six which is the pair uh pipe pair
74:40 - update our current subfolder that we're
74:42 - looking at
74:44 - we're going to start in main so on line
74:46 - 33
74:49 - in main
74:51 - we can see that we're requiring pipe
74:53 - pair which is a new class we're defining
74:55 - we're taking the pipe that we had before
74:58 - and we're sort of creating a new
74:59 - composite class we're going to take a
75:01 - class that sort of encapsulates two
75:03 - pipes together a pair of pipes and we're
75:05 - going to use this to think about our
75:07 - problem more abstractly than we already
75:09 - are and this sort of layering of
75:11 - abstractions is a very important um
75:13 - concept in computer science generally
75:14 - speaking but especially in games where
75:16 - you might have objects that are
75:18 - composites of objects that are
75:19 - composites of objects and these abstract
75:21 - hierarchies are sort of what keeps
75:23 - programmers sane when dealing with such
75:24 - um you know large levels of i mean you
75:27 - have thousands of lines of code sort of
75:28 - the only way you can really make sense
75:30 - of it
75:32 - so on line 65 if we look now instead of
75:36 - a table that's called pipes where we've
75:37 - renamed it to pipe pairs we're no longer
75:39 - going to store individual pipes in our
75:41 - scene we're going to sort of take these
75:42 - pipe pairs that we're going to create
75:44 - and store them
75:46 - in our table as well as whole as like
75:48 - individual units
75:51 - on line 71 we need a variable to keep
75:54 - track of the uh we're calling it last y
75:58 - the purpose of this variable is so that
76:00 - we can keep track of where the last set
76:02 - of pipes sort of spawned their gap right
76:04 - because we if we made our gaps
76:06 - completely random
76:07 - it will have the sort of effect of
76:11 - not looking continuous for one and also
76:13 - potentially being impossible to beat we
76:15 - want some sort of
76:16 - smooth
76:18 - so contour to our gap so that we can fly
76:20 - through them reasonably and that it
76:21 - looks as if it was almost pre-made and
76:23 - smooth so we're going to keep track of a
76:25 - variable called last y we're going to
76:27 - start it off at negative pipe height
76:30 - so
76:31 - up past the top of the screen plus some
76:33 - sort of value
76:35 - between
76:36 - between 1 and 80 and 20. so it's going
76:38 - to be it's going to be roughly towards
76:39 - the top of the screen
76:42 - and this is important because last y is
76:45 - going to be we're going to end up
76:47 - flipping our sprite and
76:49 - a
76:50 - flip on the y-axis has the result of the
76:53 - sprite sort of looking as if it's gone
76:56 - its whole
76:57 - height above where its actual y is and
76:59 - we'll see um in more detail shortly why
77:02 - this ends up working the way it does
77:05 - we're going to go down to line 132
77:12 - and in our sort of condition if our
77:15 - spawn timer is greater than two
77:18 - um what we're going to do is this is
77:20 - where we spawned our pipes before but
77:22 - now we're spawning pairs of pipes
77:26 - so
77:26 - we're going to set a local variable y
77:29 - it's going to be
77:31 - this is the the clamp operation that we
77:32 - talked about sort of last week using
77:34 - math.max and math.min to sort of com
77:36 - like apply some sort of operation in
77:38 - this case we're going to add a random
77:40 - value between negative 20 and 20 to
77:42 - whatever our last y value was which is
77:44 - going to shift the gap effectively by
77:46 - negative 20 or 20 pixels
77:49 - we're going to clamp it between negative
77:50 - pipe height plus 10 so about 10 pixels
77:54 - from the top of the screen
77:56 - and then uh
77:57 - we're gonna set the upper bound to
78:00 - virtual height minus 90 minus pipe
78:03 - height and this minus pipe height is
78:05 - only because we're doing a flip
78:07 - operation on our y-axis for our sprite
78:09 - i'll go into it in a little bit more
78:11 - detail sort of try to
78:13 - make it clear as to why we're doing it
78:14 - and maybe i'll take out
78:16 - some codes to illustrate what it looks
78:17 - like without that operation applied
78:20 - but basically it has the effect of 90
78:22 - pixels from the bottom is where the pipe
78:24 - could
78:25 - the gap could spawn
78:26 - so basically the pipe at the very bottom
78:29 - recall that this gap is where the this
78:31 - uh value is where the the gap itself
78:34 - begins not necessarily where the pipe
78:35 - starts
78:38 - it'll be between negative pi pipe plus
78:40 - 10
78:41 - between negative basically effectively
78:44 - between 10 pixels from the top of the
78:45 - screen between negative or between 90
78:48 - pixels from the bottom of the screen
78:50 - and then we're going to apply
78:52 - a random
78:54 - permutation of this value we're going to
78:55 - add some value between negative 20 and
78:57 - 20 and that will sort of give us a
79:00 - contour and it'll be sort of a
79:02 - randomized contour
79:06 - line 136 we have pipe pairs table insert
79:10 - into that instead of pipes and we're
79:12 - just adding a new pipe pair and we're
79:14 - setting it to uh that the value y
79:17 - and then this the pipe pair takes in a y
79:20 - value and that'll be where the start of
79:22 - the gap is and what what this will have
79:25 - the effect of doing is it's going to
79:26 - flip a sprite above the gap so that we
79:30 - have a pipe right above where the gap
79:31 - starts and then it's going to draw
79:33 - another pipe unflipped about 90 pixels
79:36 - below that and that will be how it sort
79:38 - of puts the two together
79:42 - line
79:43 - 144
79:46 - is a loop that just updates our pairs
79:48 - instead of our pipes so we've just all
79:49 - we've done here is just renamed it from
79:51 - pipe to pair and we've instead of pipe
79:54 - instead of pipes we're using pipe pairs
79:57 - we're doing the same exact thing here
79:59 - one on line 153
80:01 - we've done 4k pair in pairs of pipe
80:03 - pairs
80:05 - and then line 150
80:08 - sorry line 175
80:10 - is where we are or sorry 170 is where we
80:13 - are rendering each
80:15 - pair instead of each pipe and so if we
80:18 - open up
80:19 - pipe pair here
80:22 - we can take a look at this class from
80:24 - scratch so it's a new class we're going
80:26 - to set our gap height to 90 pixels and
80:29 - so this is just some arbitrary value
80:30 - that i felt was like a pretty fair value
80:33 - in terms of size but you could tune this
80:34 - to whatever you want you could set this
80:36 - to
80:37 - if you want to be really cruel you could
80:38 - set it to something like 50 or if you
80:40 - wanted to be really generous to the
80:42 - player you could set it to something
80:43 - like 150 and make it fairly easy for
80:45 - them to get through or as part of the
80:47 - assignment you could randomize it so
80:49 - that the uh
80:50 - so that it varies uh you know pair by
80:53 - pair and you get more of an organic
80:55 - looking obstacle course still shifted by
80:57 - negative 20 to 20 pixels but now your
80:59 - gap varies and you can also randomize
81:02 - the shift amount if you wanted to as
81:03 - well let's say you wanted maybe the
81:05 - maybe you want the gaps to be
81:07 - up to 40 pixels difference instead of 20
81:10 - pixels difference on negative and
81:12 - positive value you could easily do that
81:13 - as well
81:17 - on line 18 we're just setting our x to
81:20 - just like we did before virtual width
81:21 - plus 32 so we're setting it to the uh
81:24 - actually before we just set it to
81:26 - virtual width now we're setting it to
81:27 - virtual width plus 32
81:29 - both are
81:30 - pretty much equal this will just give it
81:32 - a little bit of a delay before it ends
81:33 - up going onto the screen but you could
81:36 - effectively just do this virtual width
81:40 - the on the next line 24
81:44 - this is where we sort of bundle together
81:47 - the pipes that we're going to end up
81:49 - actually rendering and updating to the
81:51 - screen instead of having just one pipe a
81:54 - pipe pairs two pipes we can easily put
81:56 - this together in a table so we'll just
81:58 - create self.pipes we'll set it to a
82:00 - table that has two keys upper and lower
82:03 - and the upper pipe is just a pipe
82:06 - and notice one thing is different about
82:08 - pipe now before it took no arguments it
82:10 - was just a regular pipe pipes had their
82:12 - own logic they set their own x and y
82:15 - they didn't need any sort of you know
82:17 - parameterization beyond that it was all
82:19 - taken care of for them randomly
82:22 - now they take a string
82:24 - so this top string means that this would
82:26 - be a top pipe so that means that if this
82:29 - pipe is a top pipe there's probably
82:30 - going to be logic and pipe that now
82:33 - checks to see whether it's top or bottom
82:35 - if it's top
82:37 - then we need to render it upside down we
82:39 - need to flip it along the y axis
82:42 - and then we're going to set it to self.y
82:46 - and recall that we set self.y we passed
82:50 - in
82:50 - self.y in main actually i'm not sure if
82:53 - i touched on that let's go back to main
82:55 - here so if we go to
83:02 - figure out where i actually instantiate
83:05 - by the pipes
83:07 - here on line 136 after we've calculated
83:10 - where we want the gap to be for this
83:12 - pipe pair we're going to go ahead and
83:13 - insert
83:15 - into pipe pairs a pipe pair at y why was
83:18 - the calculation um between we basically
83:20 - took the last um
83:24 - y value the last gap that we
83:26 - instantiated and then shifted it by some
83:28 - negative 20 to 20 pixels randomly and
83:31 - made sure it didn't go above or beyond
83:33 - above or below the edges of the screen
83:36 - the
83:38 - back and pipe pair
83:40 - we're going to go ahead and look at
83:43 - line
83:45 - 30 or sorry actually we'll let's take a
83:47 - look a little bit more closely here at
83:49 - line 26.
83:50 - so upper gets top and self.y that's
83:53 - where the gap is and that's the sprite's
83:55 - going to be flipped upon that
83:58 - value
83:59 - the lower value is going to be a shift
84:02 - of that so the lower sprite needs to
84:04 - spawn
84:05 - below
84:07 - the top pipe by the gap amount so that
84:10 - the two are sort of you know top to
84:12 - bottom but there needs to be that space
84:13 - between the two of them so we need to
84:15 - take that pipe shift it down and then
84:16 - draw the next pipe so we're going to
84:19 - take self.y
84:21 - plus pipe height
84:22 - plus gap height
84:25 - and that'll have the effect remember gap
84:26 - height was 90 pixels
84:29 - the pipe height is a result of sort of
84:32 - flipping the uh the y ax the y-axis and
84:36 - having to shift it down the actual um
84:38 - position
84:40 - so if we go back to
84:43 - um
84:47 - line 30.
84:49 - so this is a
84:51 - this is an interesting sort of
84:53 - uh
84:55 - illustration of what happens when you
84:57 - edit a table while you're iterating over
84:59 - a table and i'll show you this in detail
85:01 - shortly but basically on line 30 we're
85:03 - setting a flag called remove to false
85:05 - and what this is going to do
85:06 - is before we were just destroying the
85:08 - objects whenever it got past the edge of
85:10 - the screen we just destroyed it but if
85:12 - we're iterating over a table of values
85:15 - let's say a table of pipe pairs
85:18 - when you do a removal in
85:22 - most programming languages in lua when
85:24 - you do a removal of a table of a table
85:26 - value and it's non-indexed or it's
85:29 - non-keyed which means that it's indexed
85:30 - by
85:31 - you know numerical indices this will
85:33 - shift every other value down and so when
85:36 - you're iterating it and you shift
85:38 - everything down the value you are
85:40 - currently manipulating let's say it's
85:41 - equal to one
85:43 - if you remove that value you shift
85:46 - everything beyond it down by one
85:48 - but then you're going to increment up to
85:50 - two and you're skipping over what was
85:52 - previously just two and is now one
85:55 - so you see effectively skipping over one
85:57 - of your entries and that has buggy
86:00 - behavior and a lot of
86:01 - scenarios in this case it causes the
86:03 - graphics to sort of glitch a little bit
86:06 - because it doesn't apply a uh a pixel
86:08 - shift on one frame and so
86:11 - as pix as whenever a pipe gets removed
86:14 - and i can actually show this visually uh
86:16 - the first pipe left after that table of
86:19 - that pipe gets removed ends up moving a
86:21 - little bit to the right and so you get
86:22 - weird pipes shifting to the left of the
86:24 - bird on each frame so
86:26 - whenever you edit a table in place
86:29 - make sure not to delete while you're
86:30 - iterating over it it's going to cause
86:32 - buggy behavior
86:34 - and like i said i'll show you i'll
86:36 - illustrate this for you
86:38 - very shortly
86:40 - on line 36
86:42 - we are
86:44 - performing the update logic now a pipe
86:46 - pair has two pipes each with their own
86:49 - render components and their own
86:51 - positions we we're using the code that
86:53 - we wrote before for pipe and we're going
86:55 - to try to expand upon it a little bit so
86:57 - we want to defer we still want to defer
86:59 - a lot of that code to
87:02 - uh the pipe class and we want to update
87:05 - the pipes based on um
87:09 - whether they we want to still keep track
87:11 - of their own x and their render
87:12 - functions and so we're going to see if
87:15 - uh basically if our
87:17 - pipe pair x
87:19 - is greater than negative pipe width
87:20 - which is the same exact logic that we're
87:22 - using before
87:24 - set our own x
87:26 - to
87:27 - um
87:29 - the
87:31 - that minus pipe speed times delta time
87:33 - which is the same operation we were
87:34 - doing before but we are also
87:37 - editing the x of our self.pipes lower
87:41 - and upper and this will allow us to on
87:44 - line 46 render the pipes just as we were
87:47 - doing before because they're getting
87:48 - their x values updated just as they were
87:50 - before so we're effectively deferring
87:53 - the render phase to our pipes and not
87:55 - really needing to add any additional
87:57 - logic for that in our code
88:01 - if we've made changes to pipe.lua as
88:03 - well so i'm going to go ahead and open
88:05 - up pipe
88:08 - here
88:10 - whoops
88:14 - and
88:17 - we've set the height and width of it as
88:19 - constants here so pipe height gets 288
88:22 - and that happens to be about the size of
88:23 - the screen
88:24 - pipe width gets 70.
88:28 - on 31 we're setting self.orientation
88:31 - gets orientation notice our init
88:32 - function which was previously just empty
88:35 - it took no parameters now takes an
88:36 - orientation and it takes a y value the
88:38 - orientation is going to be going to
88:41 - allow us to say to ask
88:43 - basically is our code a top pipe or a
88:45 - bottom pipe and if it's top pipe we need
88:47 - to flip it draw it and shift it
88:49 - if it's a
88:51 - bottom pipe we're just going to draw
88:52 - normal and not perform any sort of fancy
88:55 - you know sprite flipping or anything
88:57 - like that
88:58 - down here on the render function is
88:59 - where this actually happens
89:01 - so on line 39 we're drawing the pipe
89:04 - image as usual at x but
89:07 - at y
89:08 - because
89:10 - when you flip a sprite it ends up
89:13 - completely uh
89:15 - flipping the white but it basically
89:16 - performs a mirror on it but it not at
89:18 - zero zero it it basically
89:21 - shifts it up by pipe height amount we
89:24 - need to keep track of that and draw it
89:27 - at
89:28 - self.y plus pipe height because if we
89:30 - draw it at just self.y
89:32 - because it's going to be mirrored and
89:34 - it's going to get shifted by pipe height
89:36 - amount it's going to be beyond the top
89:37 - edge of the screen and we we need to
89:39 - account for that account for the fact
89:41 - that we're flipping it on the y-axis and
89:43 - bring it down
89:47 - the code where we the question is
89:48 - where's the code where we flip it so
89:49 - that's actually here on this line
89:52 - on this condition we're saying
89:54 - if self.orientation is equal to top
89:57 - then we want to so the parameters here
89:59 - i'll comment this just for clarification
90:05 - it does uh and i'll show you here so
90:07 - this is zero we've added a few new
90:08 - parameters to our love.graphics.draw
90:11 - function 0 is rotation we're not going
90:13 - to rotate it at all this is the scale on
90:16 - the x axis so x scale and this is the
90:19 - scale on the y-axis so if we apply a
90:22 - scale operation of one it's the same
90:24 - thing as applying no scale like doing no
90:27 - scale at all it's just gonna draw it on
90:29 - the x-axis it's just gonna draw it
90:30 - normally but
90:32 - if it's top
90:34 - if where if this pipe has been set to an
90:36 - orientation of top
90:38 - we need to we're going to set the scale
90:40 - to negative one when you set a sprite
90:43 - its scale factor to negative one it
90:46 - flips it along that axis effectively
90:48 - and so that's how you get mirroring in
90:51 - most engines that allow you to sort of
90:53 - apply scale operations to 2d textures or
90:55 - 2d sprites a negative operation on an
90:58 - axis will mirror it on that axis and so
91:01 - that's what we're doing here so we're
91:02 - mirroring it
91:03 - um if it's a top pipe and we're also
91:06 - shifting its draw location as well
91:08 - because when we mirror it it's going to
91:10 - at 0 0 it's going to do the same it's
91:12 - going to
91:13 - basically draw the same exact thing but
91:15 - mirror it on the y-axis so it's going to
91:17 - need if we want to draw at a given
91:19 - location flipped like still draw it at 0
91:21 - 0 but have it be flipped we need to
91:23 - account for that flip and shift it
91:25 - downwards if that makes sense
91:29 - so that's essentially all that's
91:31 - involved there
91:33 - and i think that's pretty much all of
91:36 - the
91:37 - code so we have our
91:39 - pipes now that are being uh when it's
91:41 - flipped if it's a top pipe it's going to
91:42 - get drawn shifted it's going to have its
91:45 - other pipe shifted down by that amount
91:47 - and set to negative or set and increased
91:50 - uh
91:51 - its y-axis is going to be increased by
91:53 - the gap height so that it gets drawn you
91:54 - know 90 pixels however many pixels you
91:56 - want to set below that pipe so we're
91:59 - going to go into
92:01 - demonstrate this go up to
92:06 - 50 bird the actual repo now and the
92:08 - actual distro code i'm going to go into
92:11 - bird six
92:12 - and i'm going to run it
92:14 - whoops
92:16 - and now we have pipes that are actually
92:17 - rendering
92:19 - but
92:20 - we're missing a couple of important
92:22 - things
92:24 - foremost among them being that now we
92:26 - don't have we don't have collision
92:27 - detection yet so we can just fly through
92:28 - this course you know infinitely but
92:30 - notice that they're being shifted by you
92:32 - know random value between negative 20
92:34 - and 20 pixels
92:37 - it looks more or less like it's being
92:39 - generated
92:40 - with some sort of goal in mind it's it's
92:43 - not you know haphazard it's not all over
92:44 - the place but you could easily find ways
92:46 - to tweak this such that you know maybe
92:49 - the gap height is some value between you
92:51 - know 60 and 120 and so you have
92:54 - easy and difficult pipes or maybe you
92:56 - have
92:57 - i think i'm so far below the screen that
92:59 - i can't even get back up anymore but
93:01 - uh
93:02 - oh okay i just that's
93:04 - physics error and when you when your
93:06 - value gets to a certain point i think
93:08 - that's actually uh what it's doing is
93:10 - actually overflowing the value and
93:12 - setting it to a negative or underflowing
93:14 - it and saying it to a negative value and
93:16 - then uh incrementing it
93:18 - because it's gotten so large
93:19 - but
93:20 - the uh but you could easily
93:23 - modulate parameters such as the width
93:25 - between the pipes as we saw on the
93:26 - diagram before or the or the height or
93:29 - even the speed at which they move and
93:31 - find ways to you know tune it to
93:33 - make gameplay that actually
93:35 - works
93:37 - for whatever goal you have in mind
93:38 - making it easier or more difficult and
93:40 - that's actually a topic that they talked
93:41 - about in that article that i linked to
93:42 - before where they generated levels
93:44 - programmatically and then tested them
93:45 - programmatically to determine what makes
93:47 - a level in flappy bird difficult or easy
93:50 - and so
93:51 - basically that's
93:54 - those are the parameters you need to
93:55 - sort of weigh as you're thinking of
93:57 - procedural generation and procedure
93:58 - generation ultimately is just taking
94:00 - values that you construct your scene
94:02 - with and just finding ways to just
94:03 - manipulate them
94:04 - randomly math.random some value and
94:07 - that's how you make random levels
94:09 - in a nutshell
94:11 - making good random levels is another
94:14 - question
94:14 - but
94:15 - uh
94:18 - he did he did there was a big
94:20 - controversy around this game back in
94:21 - 2013 but
94:24 - uh i didn't know if i read too much into
94:26 - that but i i was doing a little bit of a
94:29 - little bit of research and was reading
94:30 - about some of that stuff but i mean got
94:32 - to give them props for you know banking
94:34 - on that
94:37 - but yeah that's you know now we have
94:39 - pipe pairs that's arguably the most
94:40 - complex part of the program because
94:44 - going forward now
94:45 - as we get into collision and some more
94:47 - concepts collision is actually something
94:49 - that we touched on last week and it's
94:51 - all basically the same stuff
94:54 - so if we go into bird seven
94:57 - uh the next iteration of our application
95:00 - i'm going to go ahead and open up
95:01 - main.lua
95:07 - and then we're going to go to
95:09 - line
95:12 - 74. and um in order to test collision
95:17 - we don't we don't have scoring in place
95:18 - yet but we need some way to just to
95:20 - determine oh we we collided with the
95:22 - pipe we need some sort of feedback so
95:24 - what we're going to do is
95:26 - i've just decided we should just pause
95:27 - the game so once we once we collide with
95:30 - the pipe let's just pause instantly so
95:32 - we know immediately oh we collided with
95:33 - a pipe so i'm going to set some variable
95:35 - called scrolling at the top of the
95:37 - program in main to true it's going to
95:39 - we're scrolling we're going to start
95:40 - scrolling
95:41 - but when i don't want to scroll anymore
95:43 - when i want to pause the game this
95:44 - should get set to false
95:47 - so
95:48 - on line 120
95:52 - if scrolling
95:53 - then do all of this update logic that we
95:56 - did before
95:58 - and then at the very end of that we're
95:59 - resetting our input table so we can
96:01 - still take input but no updates will
96:03 - take place if scrolling is set to false
96:05 - all of this stuff is within this
96:08 - if excuse me if scrolling then so very
96:11 - simple just encapsulate it all within
96:12 - some variable that we can turn on and
96:14 - off
96:16 - and then on 152
96:19 - within that chunk of code that is being
96:23 - sort of contained within that if
96:24 - condition we're just doing a very simple
96:27 - iteration
96:28 - for each pipe
96:30 - it should be for l pair in pairs of uh
96:33 - oh no sorry for every pipe in
96:36 - the pairs of
96:38 - uh it's a nest it's a nested for loop in
96:41 - this case so basically within the the
96:42 - loop that looks over every single pair
96:45 - to update it
96:46 - we're doing another loop that's looping
96:48 - through with the pipes in that pair so
96:49 - it's only a loop of two iterations with
96:52 - the upper and the lower pipe we could
96:53 - just also say if bird collides with
96:57 - upper
96:58 - basically if pair dot upper pair dot
96:59 - lower or peridot pipes upper paired up
97:01 - pipes down lower but this is a little
97:03 - cleaner it's more scalable we can add
97:05 - more pipes if we want to even though it
97:06 - wouldn't happen
97:07 - but for every pipe in peridot pipes
97:11 - we have a function here that we haven't
97:12 - defined yet called bird collides so if
97:15 - bird collides pipe so it takes in a pipe
97:18 - so is going to return a true or false
97:20 - value we know that
97:21 - set scrolling to false so we collide
97:24 - scrolling set to false
97:25 - update logic is going to get shut off
97:27 - completely so we're going to have the
97:28 - effect of pause in the game
97:31 - we're going to go into
97:32 - bird.lua right now we're going to
97:34 - actually see how we implement this and
97:36 - it's going to look very familiar
97:38 - to what we did last week so in bird.lua
97:44 - this function here
97:46 - from 29 down to 45 it's just an aabb
97:48 - collision detection test that we did
97:50 - last week we're just checking to make
97:52 - sure any edges are you know right edge
97:55 - make sure that is
97:57 - to the left of the right edge of the
97:59 - second box bottom edge of box one should
98:02 - be our bottom edge of box one should be
98:03 - above bottom edge or top edge of box two
98:06 - if all these things hold true
98:08 - then return true
98:10 - else return false which means we have a
98:11 - collision
98:12 - and notice that i've shifted everything
98:14 - here by
98:16 - a couple of constant values does anybody
98:18 - have any instincts so why i'm saying
98:20 - self.x plus 2 instead of just self.x or
98:24 - self.with minus 4 why we're checking for
98:27 - that offset for the bird in this case
98:30 - when it is compared with the pipe
98:34 - it's not quite half it's a few pixels
98:36 - smaller do we know why we want to do
98:38 - this why we want to like we're basically
98:40 - shrinking the box why would we want to
98:42 - shrink the box
98:49 - so not quite so there isn't an actual
98:52 - gap between the drawing it's more of a
98:54 - question of
98:55 - how much do we want to frustrate how
98:57 - much do we want to frustrate our users
98:59 - right if if we're pixel perfect
99:02 - colliding with the pipes
99:04 - you know there's there's no give and
99:05 - take it's like you you collide and even
99:08 - if it might even look as if you're not
99:09 - even colliding with the
99:11 - pipe and you're still getting a
99:12 - collision your users are thinking well
99:14 - that's not fair that's really harsh
99:16 - we're shrinking our box so that you know
99:18 - even if they're just like a pixel off
99:19 - they'll still get a little bit of leeway
99:21 - and it'll be a little bit
99:23 - less strict in terms of the collision
99:25 - and this is a very common thing in games
99:27 - when you have
99:28 - characters whose sprites may not
99:30 - necessarily fill the entire box that
99:32 - you've allocated for them even though
99:34 - you're doing box collision just give
99:35 - your users a couple pixels
99:37 - deep however however many you want and
99:40 - they can overlap with whatever they're
99:42 - colliding with just a tiny bit before it
99:44 - actually
99:44 - triggers a true on the collision and it
99:46 - makes your game feel more forgiving and
99:48 - then also more fun as a result of that
99:51 - so that's why we have where instead of
99:53 - testing directly on x0 of that box we're
99:56 - testing x plus two and then self.with
99:58 - minus four because when we shift we add
100:01 - width to a plus two value we need minus
100:03 - four so that we get two off the right
100:05 - edge and same thing goes for the height
100:07 - and the y value
100:09 - and so this just performs aabb collision
100:11 - detection
100:13 - expects a pipe which
100:15 - means that we need to ensure that that
100:17 - pipe has an x and a y a width and a
100:19 - height which it does actually just a
100:21 - constant here we're just checking pipe
100:23 - width and pipe height we probably
100:24 - shouldn't do that it should be pipe dot
100:27 - width pipe dot height in that case
100:29 - because then this couldn't necessarily
100:30 - just be a pipe it could be anything in
100:32 - our scene that has a xy a width and a
100:34 - height it could be a general purpose
100:36 - collision and actually something you can
100:38 - also do if you wanted to is just write a
100:40 - function called collides that takes in
100:43 - two two things that you know have
100:45 - bounding boxes and will allow you to
100:46 - perform closing detection on anything in
100:48 - your scene any between any two entities
100:50 - that would be a
100:52 - more
100:52 - scalable way i guess of dealing with it
100:54 - rather than necessarily having it
100:56 - specifically defined as birds and pipes
100:59 - being the colliders but in this case
101:00 - this is the only thing we're really
101:01 - colliding with except from the ground
101:03 - but when you collab with the ground all
101:04 - you need to do is just check to see
101:05 - whether your y position plus uh your
101:09 - height has gone below the edge of the
101:11 - screen
101:12 - so
101:13 - any questions as to how that
101:20 - so the question was why did we add 2 and
101:23 - subtract 4 instead of just subtract 2
101:26 - because
101:29 - when you add a because we're doing
101:31 - self.x plus two basically we're shifting
101:34 - the whole box essentially here in this
101:36 - part so self.x plus two
101:39 - brings the beginning of the box that
101:40 - we're that we're colliding with two
101:42 - pixels to the right
101:43 - but if we just do two pixels minus two
101:46 - then the boxes x
101:49 - right edge is still the right edge of
101:50 - the box we want it to be shifted inwards
101:52 - by two by two pixels
101:54 - because we've shifted at the start of
101:56 - our box the x position two pixels over
101:59 - we need to shift it four pixels inwards
102:02 - because that will give us the um that'll
102:04 - have the effect of our box having being
102:07 - uh two pixels uh into the right edge
102:10 - does that make sense
102:16 - okay so i think that's everything for
102:18 - bird seven
102:20 - um
102:23 - we're gonna go ahead and run bird seven
102:25 - now
102:28 - and
102:29 - recall if we hit a pipe we should
102:31 - instantly pause
102:34 - so balancing bouncing bouncing
102:36 - i'm gonna go through one pair of pipes
102:38 - here
102:39 - and then i'm gonna hit this one on
102:40 - purpose oh we paused and notice that we
102:43 - have a little bit of leeway we got a
102:44 - couple pixels there just to give us you
102:46 - know in case we accidentally uh and also
102:48 - it takes into consideration you could
102:49 - move because of your velocity a couple
102:52 - pixels beyond the uh necessarily the
102:54 - strict hard edge of what you're
102:56 - colliding with based on how many you
102:58 - know how many frames have passed and
102:59 - what you're dealt with you're basically
103:01 - essentially what your velocity is and
103:02 - what your position is
103:04 - in this case i think it looks like we're
103:05 - actually like three or four pixels above
103:07 - the edge because our velocity was so
103:08 - high because we jumped
103:11 - but
103:12 - as soon as it detected the collision as
103:13 - soon as we were
103:15 - on that frame where our position was
103:16 - such that we did trigger true for our
103:18 - collision detection it paused the game
103:20 - looping was set to false we no longer
103:22 - ran any update logic and this is our
103:25 - basic way of getting feedback about that
103:27 - however
103:29 - it's not particularly compelling
103:31 - gameplay wise and so
103:34 - we want to get into scoring
103:37 - before we get into scoring though
103:39 - and also associated with that different
103:41 - states of our game so if we get into
103:43 - scoring clearly we want to have a screen
103:44 - that tells us when we lost and how what
103:46 - our score was we should also probably
103:48 - have a title screen because we're just
103:50 - jumping right into the game gameplay we
103:51 - want a screen that lets us play through
103:53 - the game and um as we'll see in a little
103:56 - bit a screen that also gives some time
103:58 - to uh once we start the game to sort of
104:00 - count down sort of say oh three two one
104:03 - go rather than just oh go and oh i don't
104:05 - know what i'm doing i'm bewildered so
104:07 - this is a sort of a diagram that sort of
104:09 - models the state flow that we're going
104:11 - to be using in our program here our game
104:14 - we're going to assume that we start on
104:16 - some sort of title screen state so going
104:18 - left to right a title screen state will
104:20 - transition to the countdown state and
104:22 - then
104:23 - we can define however we want those
104:25 - transitions to be in this case let's
104:27 - just say we press enter title screen
104:28 - state goes to countdown state once
104:30 - countdown state has
104:32 - once the transition is triggered for
104:34 - that
104:35 - we should go to the play state
104:36 - and then once the transition triggers
104:38 - for play state we're going to go down to
104:39 - the score state and then score state
104:41 - should go back into countdown state and
104:43 - this models our entire
104:46 - applications flow uh you know sort of
104:48 - top to bottom left to right
104:50 - chronologically
104:52 - so let's go ahead and take a look at
104:54 - some code as how we're going to
104:55 - accomplish this last week i alluded to
104:57 - taking us and actually earlier in
104:59 - lecture us going from sort of this
105:01 - string based approach to keeping track
105:03 - of our state with if conditions to a
105:05 - class-based approach and that's what
105:06 - we're going to illustrate today so i'm
105:08 - going to go ahead and open up bird eight
105:10 - and in bird eight i'm going to go ahead
105:12 - and start with maine
105:14 - so in main
105:16 - on line
105:18 - 36
105:20 - we're acquiring a new class called state
105:22 - machine and a few other classes that
105:24 - we're defining called base state play
105:26 - state and title screen state and these
105:29 - are the components of our state machine
105:31 - and they've now instead of being just
105:33 - blocks of code in our update function
105:34 - they're separate blocks separate modules
105:37 - that have their own logic their own
105:39 - update and render logic and we'll see
105:40 - that very shortly
105:41 - on line 78
105:43 - if you go down here
105:45 - separate from that i'm also
105:46 - instantiating a bunch of fonts we did
105:48 - this last week so love.graphics.new font
105:51 - takes in a file and then a size i've
105:53 - created a few different fonts here
105:54 - because we have a few different ways of
105:56 - giving
105:57 - feedback to the user we want a small
105:58 - font for displaying you know uh press
106:00 - enter to start or something like that we
106:02 - want a medium font for to display the
106:04 - name of the game perhaps or i think
106:06 - actually flappy font's responsible for
106:08 - that medium font i think was for score
106:10 - huge font for our countdown we want a
106:12 - big font right in the middle of the
106:13 - screen that says three two one and then
106:15 - we start and then we're just going to
106:16 - start off by setting it to flappy font
106:18 - which is our gonna be our title font so
106:20 - nothing really new but uh the beginning
106:23 - of our ui so to speak
106:25 - on line 92
106:27 - this is new and actually this is a
106:29 - demonstration of a type of naming
106:32 - convention you'll see often in game code
106:34 - bases we haven't used it yet but we will
106:36 - start using it in the future we prefix a
106:39 - global variable with a lowercase g this
106:42 - lets you know when you're digging
106:43 - through a bunch of files that oh this is
106:45 - a global variable okay so i should
106:47 - probably know um it's probably not
106:49 - defined in this
106:51 - module maybe it is but i know it's
106:53 - global
106:54 - other things you might see are lowercase
106:56 - m for member which means that this is a
106:59 - sort of a member uh function or a field
107:02 - of a class
107:03 - and you can instantly see it at a glance
107:06 - and know okay if i want to find the
107:07 - definition for this it looks like it's a
107:09 - member function so it's probably in this
107:11 - class here at some line you can easily
107:13 - find it
107:15 - and so
107:16 - in future lectures we'll be using more
107:18 - of this sort of g lowercase g for global
107:20 - variables that we use module to module
107:22 - in this case we're instantiating a state
107:24 - machine
107:25 - so we're using the class that we've that
107:28 - we will take a look at in a second the
107:29 - state machine takes in a table with keys
107:32 - that map to functions that will return
107:35 - our states
107:36 - so we can just call
107:38 - change some
107:40 - some value and it'll have in our state
107:43 - machine it'll basically reference that
107:45 - key in this table here
107:48 - and it'll call
107:49 - that function based on it'll basically
107:51 - set current uh the current state of that
107:54 - state machine to whatever
107:56 - state gets returned by the function at
107:59 - that key so in this case
108:01 - change is going to trigger
108:03 - return new title screen state and we're
108:05 - going to get the state machine is going
108:06 - to be set to the title screen
108:07 - effectively and we'll take a look at
108:09 - what the title screen looks like
108:10 - momentarily
108:12 - on line 96 yep we're changing to title
108:15 - screen on line 134 notice that we don't
108:19 - really have much update logic in this
108:20 - application anymore we're still updating
108:22 - the scrolls
108:24 - because this is behavior we want across
108:26 - all our states no matter what state
108:27 - we're in we want to make sure that
108:29 - our background and our ground scroll so
108:31 - that we have movement we don't need to
108:33 - duplicate this behavior state to state
108:35 - this is a global feature of our game so
108:37 - we're just
108:38 - keeping track of it here just as we
108:40 - would before but
108:41 - anything else in our game that needs to
108:43 - be updated can now be deferred to our
108:45 - state machine class
108:47 - and when we call g state machine update
108:50 - delta time it's going to look and see
108:52 - what's our current state
108:53 - and it's going to update that state
108:55 - and that's going to basically be that
108:57 - chunk that if chunk do this logic that
109:00 - we were doing from before last week when
109:02 - we had a sort of prim more primitive
109:03 - state machine
109:05 - line 46 same exact thing
109:08 - between the background and the ground
109:09 - because those will always render scene
109:11 - to scene we want to render our current
109:14 - active state using our state machine
109:16 - render function
109:18 - and so let's go ahead and just look
109:20 - briefly at our state machine library
109:23 - it's a very simple
109:24 - code it's actually taken from the book i
109:27 - alluded to earlier in the lecture how to
109:29 - make an rpg they give you the state
109:31 - machine which sort of um really cleanly
109:34 - i think handles a state transition
109:37 - basically takes an init and then a
109:38 - series of states
109:40 - sets it has a an empty
109:43 - uh class or empty table so all of these
109:45 - are just empty
109:48 - um
109:50 - if there is no this is a a thing you can
109:52 - do in lua which just lets you initialize
109:54 - a variable if it's not given a value in
109:57 - your function
110:01 - so self.states gets states or some value
110:04 - which means that if states is equal to
110:06 - like a falsie value is equal to nothing
110:08 - just set it to this empty table so it's
110:10 - just a shorthand for instead of saying
110:12 - you know if states equals nothing then
110:14 - set states to empty table
110:17 - self.current is just an empty
110:20 - class
110:21 - so our empty
110:23 - state so this is basically what a state
110:24 - is it's just a set of methods a render
110:27 - update enter and exit function that's a
110:28 - state and then you define all of the
110:31 - behavior in each of these functions and
110:32 - that compiles your state more or less
110:36 - our change function takes in a name and
110:37 - then also some optional parameters that
110:39 - we can use to enter that state
110:41 - um when we set the
110:44 - when we change the state set whatever or
110:46 - call the exit
110:47 - function of whatever state we're in so
110:49 - exit that state maybe your function
110:51 - needs you to de-allocate some memory
110:53 - set the current equal to taking that
110:55 - name and then call whatever function's
110:57 - there so it's going to return in that
110:59 - case we saw earlier it's going to return
111:00 - a new title screen state
111:02 - so that's going to be what current is
111:04 - with self.current we're going to then
111:06 - enter
111:07 - that state machine so we're going to
111:09 - call the enter function that we've
111:10 - defined there with whatever enter
111:12 - parameters we pass into change which are
111:15 - optional
111:16 - and then here state machine update just
111:19 - updates whatever the current
111:21 - state is and render updates whatever the
111:24 - current uh
111:25 - state is as well
111:26 - and so
111:28 - i'm going to start going a little bit
111:29 - quickly just because running short on
111:30 - time base state is a all it does is just
111:34 - implements empty methods so that you can
111:36 - just
111:37 - inherit this state and you can choose
111:39 - which methods you want to define without
111:40 - throwing any errors because it blindly
111:42 - will call all these functions not
111:44 - checking to see whether they're actually
111:45 - implemented and so this is a way for you
111:47 - to just quickly uh avoid
111:50 - a lot of boilerplate code essentially
111:52 - the title screen state here
111:55 - uh this is your way of with the class
111:58 - function class
111:59 - library just including
112:02 - everything that belongs to bay state so
112:04 - inheriting if you're familiar with other
112:06 - languages that use inheritance take an
112:08 - object
112:09 - copy everything from that object or that
112:10 - class
112:11 - put it into this one and then add new
112:13 - stuff to it that's basically what
112:14 - inheritance is we're inheriting from
112:16 - base state so it has all the functions
112:17 - base state has and then on top of that
112:20 - we're defining an update function
112:22 - so if we press enter return
112:25 - change the state machine the global
112:26 - state machine to the play state and then
112:28 - for the render we're just going to
112:30 - render 50 bird and press enter halfway
112:33 - in the middle of the screen and then the
112:34 - play state essentially to some basically
112:36 - what the play state is is all of the
112:38 - code that we ran before
112:40 - only now we're just putting it in the
112:42 - update function here and the render
112:44 - function here
112:46 - and
112:47 - making bird pipe pairs timer and last y
112:50 - member fields of this
112:52 - sort of state object so we'll go ahead
112:54 - and run this really fast
112:59 - and then we have uh this is our title
113:01 - screen state so we at the very beginning
113:03 - we change to title screen state all it
113:05 - does is render and then the scrolling
113:07 - behavior is throughout all classes all
113:09 - states so we'll see that no matter what
113:11 - once you press enter it'll trigger
113:12 - change to play which will return a play
113:15 - state
113:16 - and then now we're back where we were
113:18 - before and we're
113:20 - seeing the difference now and having a
113:22 - couple of different states
113:24 - so
113:24 - quickly i'll go through the score update
113:27 - so this is a little bit
113:29 - um more
113:31 - complicated than the last example but to
113:32 - summarize
113:34 - in uh bird oh sorry we're in bird nine
113:38 - so in bird nine
113:40 - if we go
113:42 - here
113:43 - we're going to go to main so
113:46 - notice that
113:47 - in main down where we define our state
113:49 - machine we're going to go ahead and also
113:52 - note that we require a new score state
113:54 - because now we want to display a score
113:56 - screen
113:57 - down on line
113:59 - 96 score gets a function where we return
114:03 - a score state object so now we can
114:06 - change to score and it'll return that
114:08 - state and we can define all the behavior
114:10 - within a score state that we need
114:14 - to display a score
114:16 - in
114:17 - pipe pair
114:19 - we have a
114:21 - new variable called self.scored
114:24 - set it to true or false we're going to
114:26 - set it to true if the bird has gone past
114:27 - the right edge of the of the pair of
114:30 - pipes that'll have the effect of
114:33 - us scoring a point effectively because
114:34 - all we need to do is just make sure the
114:36 - bird's gone past that pair of pipes
114:38 - because otherwise it'll have collided
114:39 - with it if it does go past it uh
114:42 - set it to true and then add a point to
114:44 - our score and in our play state we can
114:47 - see
114:48 - that we've added a point
114:52 - so if we go to
114:54 - uh our play state 26 is where we
114:57 - actually keep track of our score
114:58 - self.score gets zero in our play state
115:00 - we're going to go ahead and go down to
115:02 - line 56 so for every pair if it's not
115:05 - been scored yet
115:06 - because we don't need to calculate this
115:08 - if it's already been scored it should we
115:09 - should ignore it in terms of scoring
115:10 - once it's been scored
115:13 - if
115:14 - the x plus width
115:16 - is less than our bird.x
115:19 - meaning our bird is beyond the right
115:20 - edge of the pair of pipes increment our
115:23 - score and set that pair to true we will
115:25 - then thereafter because of this
115:26 - condition ignore it and we're also going
115:28 - to increment our score so it's going to
115:30 - be kept track of
115:33 - on 83 notice that if we're colliding
115:35 - with a pipe we should transition to our
115:37 - score state now so and we're also
115:39 - passing in
115:40 - scoregetself.score as a table because
115:42 - remember we can pass in parameters when
115:44 - we call change and this will be passed
115:46 - into our enter function in our state and
115:49 - then score is going to equal self.score
115:51 - we'll have access to the score within
115:53 - that score state we don't have to keep
115:54 - track of it as a global variable to see
115:56 - it in both locations
116:00 - 93 the same exact thing this is
116:02 - collision to check whether we've
116:04 - collided with the bottom of the screen
116:05 - if our y is greater than virtual height
116:07 - minus 15 do the exact same thing
116:09 - transition to the score state and pass
116:11 - it in our current score so
116:13 - another death condition and then 104
116:15 - we're just going to set flappy font and
116:17 - then we're going to render our score at
116:19 - the top left of the screen at 8 8 and
116:21 - that'll have that effect and so
116:24 - lastly here our score state is pretty
116:26 - simple
116:29 - all it is is we're going to get from
116:30 - those parameters we passed in by a
116:32 - change self.score equals params.score
116:35 - we're going to when we press enter go
116:37 - back to play and then we're going to
116:38 - render
116:40 - you lost
116:41 - and the score which we have access to
116:42 - self.score and then press enter to play
116:44 - again changing fonts along the way and
116:46 - so if we go back to bird9 and then we
116:49 - run this
116:51 - notice that now we have a score in the
116:52 - top left
116:54 - and
116:55 - i'm going to get one point
117:00 - and then die and we go to our score
117:02 - screen now it just remember we passed
117:04 - score into it from uh our play state we
117:07 - passed it as parameters and then
117:12 - we can press enter again go back to
117:14 - playstate and when we fall to the ground
117:16 - we do it as well so we're just taking a
117:18 - look at how to add scoring to our game
117:21 - but what if we want to add a countdown
117:23 - screen maybe we want the users to be
117:25 - prompted three two one before the actual
117:28 - game starts you know throwing pipes at
117:30 - them give them the time to you know sort
117:31 - of get acclimated we're going to go
117:33 - ahead and take a look at how we might do
117:35 - this using another state very similar to
117:37 - the last example we're going to add a
117:39 - new state called countdown state which
117:41 - is shown here on line 38.
117:44 - we're also going to down in our state
117:46 - machine add a new key which returns one
117:49 - of the new countdown states just as
117:51 - before and then we're going to go ahead
117:52 - and take a look at our actual countdown
117:54 - state here
117:56 - so
117:56 - in our countdown state dot lua which is
117:59 - in our states folder
118:01 - as the others
118:03 - it includes from base it uh inherits
118:05 - from base state we have initialized the
118:07 - countdown time to 0.75 this is time in
118:09 - seconds one second is a little long so i
118:12 - made it 0.75 seconds we're going to
118:14 - initialize a count to three and a timer
118:16 - to zero the count is going to start it's
118:18 - going to use a timer once the countdown
118:20 - time has elapsed
118:22 - right here as this logic shows increase
118:24 - the timer once the timer has gone past
118:26 - countdown time we want to go ahead and
118:28 - set it to uh we're in a modulo by
118:30 - countdown time so loop it back to zero
118:32 - plus whatever amount beyond the count on
118:34 - time we went so that we have a smooth
118:36 - track of time
118:38 - we're going to set
118:39 - self.count minus itself by one so that
118:42 - we go three two one and then if our
118:45 - count is zero which means that we've
118:46 - gone all the way down in our account
118:48 - we're going to go ahead and use our
118:49 - state machine and change to the play
118:50 - state and here we're setting our font to
118:52 - a font that we've set huge font and then
118:55 - we're just to string a little function
118:57 - that takes a string or it takes a number
118:59 - converts to a string we're displaying
119:00 - self.count at 0 120
119:03 - and then our ver it's printf so we're
119:06 - basically starting at 0
119:08 - y120
119:09 - virtual width alignment and then we're
119:11 - centering it so
119:12 - the one last piece of that that we need
119:14 - to change is in our title screen state
119:18 - instead of going straight to a play
119:20 - state here on line 15 we're going to a
119:22 - countdown state and what this has the
119:24 - effect of doing if we go into
119:27 - bird 10
119:29 - is when we press enter notice that we're
119:31 - going 3 2 1 then going into our play
119:35 - state not just going straight into the
119:37 - place as before giving our user a little
119:38 - bit of time to sort of catch their
119:40 - breath and then if we die we go to our
119:42 - score state but once we press enter
119:45 - notice we're doing that as well
119:48 - so in our score state we also are
119:49 - changing to the countdown state
119:53 - so that was how to make a countdown
119:54 - state probably my favorite part of many
119:56 - of these examples and of this example as
119:58 - well is adding audio to our
120:01 - application music and sound effects
120:03 - which really sort of tie everything
120:04 - together so we're going to go ahead and
120:05 - take a look at this it's very simple
120:08 - very similar to what we learned last
120:10 - week when we even when we just did pong
120:12 - so in maine da lua of bird 11 which is
120:15 - what we're going to look at now
120:18 - we're going to take a look at
120:20 - a table of sounds that we've initialized
120:23 - on line 88 we've given them all keys
120:26 - jump explosion hurt score these are all
120:28 - sound effects that i've generated with
120:30 - the bfxer program that we used last week
120:32 - if you recall and then a music track
120:34 - that i found online on free sound which
120:36 - is free to use
120:38 - the link is here if curious uh just a
120:40 - nice sort of happy sound track uh that i
120:44 - found for this
120:45 - game on line 99 to 100 we're going to
120:48 - take do one additional step before we
120:49 - start the music we're going to set
120:51 - looping on that to true because in games
120:54 - that are sort of infinite like this we
120:55 - don't want our music to just go and then
120:57 - stop abruptly we want to you know have
121:00 - it loop so
121:02 - play it after set looping to true
121:04 - initially actually begin the play of
121:06 - that music outside of any of our states
121:08 - because it's going to be a global music
121:10 - track
121:11 - and then
121:13 - that's the music we also need sound
121:14 - effects
121:16 - so if we do
121:17 - in our if we look in our bird file here
121:20 - on line 45 which is where we have the
121:24 - logic for jumping we're also playing a
121:26 - sound of the jump sound effect that
121:28 - we've generated
121:30 - additionally in our play state if we
121:32 - take a look there
121:33 - we can go ahead and see in our states
121:35 - folder here go to playstate and take a
121:38 - look at line 58
121:41 - this is where we score a point so we
121:43 - should play our score sound effect here
121:45 - simply put and then the same thing on
121:47 - line 80 to
121:49 - collide the sound effect here which is
121:52 - we're actually layering two sounds on
121:53 - top of each other which is a common
121:54 - thing
121:55 - to do in sound design and game design
121:57 - one sound often isn't all you need to
122:00 - accomplish a particular effect so i have
122:02 - an explosion sound which is kind of a
122:03 - white noise effect and then a hurt sound
122:05 - effect is kind of like a
122:06 - sort of like a downward uh like sine
122:09 - wave type of sound we're doing the exact
122:11 - same here on 95 to 96.
122:14 - once we put all these pieces together
122:15 - we're going to run bird 11.
122:18 - we get music
122:19 - [Music]
122:24 - we get a jump sound effect
122:28 - and when we score a point
122:30 - [Music]
122:33 - another sound effect
122:34 - and then if we hit a pipe notice that we
122:37 - have the sort of
122:38 - and a white noise there explosion effect
122:41 - layered together
122:42 - so
122:43 - that sort of brings everything together
122:45 - creatively and artistically as an
122:47 - exercise to the viewer
122:49 - in bird 12 in the github repo we have
122:52 - some code that allows you to actually
122:53 - add mouse clicks to the flappy bird in
122:55 - order to make it a little bit more like
122:57 - the actual game which was an ios game so
122:59 - it relied on taps
123:01 - the function that you might want to use
123:02 - is love.mouse pressed xy button and i
123:06 - would encourage you to think about how
123:07 - we took input and made it global in the
123:09 - context of the keyboard
123:11 - in one of our earlier examples so that
123:13 - we can call this sort of was the mouse
123:15 - just pressed in our bird.lua file as
123:17 - opposed to the
123:19 - as opposed to the main file
123:22 - and so next time we're going to be
123:23 - covering a few new concepts so sprite
123:25 - sheets so taking a large file of images
123:28 - and sort of taking out chunks of that so
123:30 - we don't have to have a million graphic
123:32 - files procedural layouts uh this will be
123:34 - in the context of the game breakout so
123:36 - we want to lay out uh all the bricks in
123:38 - our game sort of procedurally the way
123:39 - that in the sort of the same way that
123:41 - we've procedurally created
123:42 - a sort of pipe level in this game we'll
123:45 - be talking about separate levels and
123:47 - having them stored in memory as opposed
123:48 - to just one continuous level
123:50 - we'll be talking about health we'll be
123:52 - talking about particle systems which is
123:54 - spawning little mini graphics to
123:55 - accomplish various effects that are
123:57 - otherwise difficult to capture in a
123:59 - simple sprite animation
124:01 - a little bit fancier collision detection
124:03 - based on input so that we can sort of
124:05 - drive ball behavior the way we want to
124:07 - and then also persistent save data how
124:09 - can we take a high score and not have it
124:11 - refreshed to zero every time we run the
124:12 - application but rather save it to disk
124:15 - so that every time we run the program
124:16 - thereafter we can see what we've gotten
124:19 - scored in days past the first assignment
124:22 - or rather the second assignment
124:23 - assignment one
124:24 - is going to be a little bit more
124:26 - complicated than last week's but still
124:27 - fairly doable make pipe gaps slightly
124:30 - random being the first component of this
124:31 - so before pipe gap is set to a constant
124:33 - value maybe make it some sort of random
124:35 - value pipe intervals as well so we're
124:37 - spawning every two seconds maybe we want
124:39 - to change that up make pipes spawn a
124:40 - little differently a little more
124:42 - sporadically
124:43 - uh the more complicated aspect of this
124:45 - assignment is going to be awarding
124:47 - players a medal based on their
124:48 - performance so have like a maybe a
124:50 - bronze a silver and a gold medal an
124:52 - image that you display in the score
124:53 - screen in addition to just their score
124:55 - just to give them a little bit of
124:57 - personal feedback and sort of make them
124:59 - feel rewarded for their effort and make
125:00 - them strive to sort of get that last
125:02 - that last medal and then lastly you
125:04 - implement a pause feature which we
125:06 - talked about in class so that when you
125:07 - press for example to keep p the game
125:10 - will stop but unlike that example when
125:12 - we press p again the game should resume
125:14 - just as it was in its prior state
125:16 - so that'll be it uh for flappy bird i'll
125:19 - see you guys next time thanks a lot

Cleaned transcript:

hi everybody my name is colton ogden this is gd 50 lecture one and today we'll be covering flappy bird so uh last year we are last week sorry we covered pong which was uh just you know basic shapes and colors today we'll actually be diving into sprites as we can see here we've got some pipes and a bird and we're covering a few other concepts such as gravity and more today the topics that we'll be covering are in a nutshell images and sprites as i just said so loading images from memory from our hard drive and actually drawing them to the screen instead of just uh you know rectangles and whatnot uh we'll be covering infinite scrolling so seeing things like and if you've played the game pipes are infinitely going from right to left how to actually get that going infinitely so that we're not using up also infinite memory we'll be discussing how games and in the similar vein are illusions in the sense that um a lot of the perceived vastness and perceived complexity of games is often just due to camera trickery and more because of limited hardware we'll be covering procedural generation which ties also into infinite scrolling procedures generation is a topic that i'm actually very interested in and we'll be touching on it throughout the course in several locations but in the cons or in the context of today's lecture we'll be using it uh for the pipes because the pipes they spawn from right to left and flappy bird as you're infinitely going through the level but they can spawn at various heights and the gaps are shifting as a result of that therefore creating this sort of infinite level we'll be talking more in detail on state machines so last week we covered state machines in a very abstract sense we used a just basically a string as a variable and then used if conditions today we'll be actually using a state machine class replete with various methods that allow us to transition in and out of these states very cleanly and allow us to break out all of this logic that we previously had in our update and render functions and then put them separately into their own state classes and then lastly we'll also be touching on mouse input and a point that i forgot to mention here whoops is also we'll be talking about music which is just basically sound which we did last week but we'll add that as a polishing touch if you guys want to download the demo code we have a repo up right now on github slash games 50 50 bird that's our take on flappy bird a couple of things i've been asked a couple of times whether we have reading materials for the course uh and there are no formal reading materials but there are a couple of resources that i really enjoyed reading especially as i was getting more into lua and love2d they are two books uh one is an online book actually they're both online books but the latter of which has a physical form as well the four first of these is how to make an rpg by dan scholler which is actually completely written in lua he uses a custom game engine very similar to love2d but it's handwritten by him but a lot of the same ideas apply and it's a great opportunity it's how i cut my teeth on lua and i would encourage you to take a look at that if that's something you're interested in or if you like rpgs and then also game programming patterns by robert nystrom is a very great general purpose game development book that talks about a lot of these sort of more abstract highlevel concepts with largescale game development but yeah beyond that no formal reading those aren't formal reading either those are just if you're curious and you want to read some resources that i found very interesting feel free to do so today's goal is to implement what looks like this this is a this is our version of flappy bird we didn't use the same exact sprites for copyright purposes but we note that we have a bird in the middle of the screen this bird on click or on space bar will jump up and down and your goal is to prevent the bird from touching either the pipes or the ground itself every time you make it past a pair of pipes you will score a point as soon as you touch a pipe or hit the ground game is over and that's that so today we'll be covering uh i'll doing a little bit more live coding so the very first example that i want to cover is the day zero update for flappy bird and a important function that is going to be probably the most noticeable the most visibly obvious function we'll be using throughout this lecture is love.graphics.new image which takes a path this function all it does is load a image file from your disk you specify it as a string and you can then use it as an object and draw anywhere you want at an x y coordinate and we'll see this in practice here so i'm going to go ahead if you're looking in the repo all of these examples are covered 0 through 12. i'm going to start from scratch in a new folder that i've created i'm going to create a brand new main.lua completely fresh and first thing i want to do is because we are going to use a virtual resolution just like we did last week so that we have a more retro aesthetic i'm going to go ahead and require the push library so push equals require push just like that i've pre put push lua into this directory it'll just load by default in the same directory the current working directory of your script when you run love next thing i'm going to do i'm going to define some constants so window width should be 1280 and then window height is going to be 720. those are our physical window dimensions but then we also need a virtual width and we're going to use 512 by 288 this is a resolution that i found worked pretty well for the assets we'll be using today but you can make this most anything you want to as long as it's somewhat in that range it is a 16x9 resolution as well so that it fits comfortably on um modern widescreen 16x9 monitors um what we're going to do is the first goal that we have today is to sort of draw two images to the screen we want a foreground and a background because notice if we go back to the slides we can see in the very background we have a sort of hill landscape and then on the bottom we have a ground and there the two of those are going to eventually scroll at different rates it's going to be called parallax scrolling but just for our very first example we have something very basic i just want to draw two images to the screen so we're going to go ahead and do that here by setting a local variable remember local means that it's just defined to the scope that it's in rather than being global which means we cannot access this variable outside of this file local background gets love.graphic image the function that we just talked about let me go ahead and hide this inspector here so we can have more room to code and then it's just going to take a string so background.png and i realize i actually didn't include those files in the directory so i'm going to need to do that as well same thing for the ground exact same function love.graphics.new image except ground.png and before i forget let's go ahead and do that right now i have the files here ground and background and copy those from the repo the distro repo into my bird zero directory that i'm currently developing in right now and so as soon as we're done with that we're going to go ahead and we're going to define love.load which is the function lov2d calls at the beginning of your program execution in there because we don't want these images to look blurry when they get loaded and upscaled we want to go ahead and set our default filter to nearest on min and mag which means on upscale and downscale apply nearest neighbor filtering which means no blurriness no interpolation of the pixels and then one thing that is just a small little touch love.window.set title 50 bird because uh is gd50 and then we're going to go ahead and set up our screen here with our virtual width virtual height window width window height it's getting a bit long and then it takes in a table recall tables just take in keys like so unlike in python where you might use a colon we use an equal sign in love or in lua i should say resizable to true and that is the end of our load function now does anybody recall how we if we want to resize so notice i said resizable to true do we know how we want how we can send a message to push to resize our screen for us so love 2d defines a function called love.resize which takes in a width and a height and in there all we're going to do is defer that call to push recall the exact same function on push it takes a width and a height and that will take care of dynamically rescaling the canvas it uses internally it renders to a texture and it's going to render to the texture that we set as the virtual width and virtual height and it's going to scale it to fit our screen and it needs to know our physical screen dimension so that it can actually properly scale that internal canvas appropriately does anybody remember the function that we use to get input from the user so function.love.keypressed recall it takes in a key love is going to call this automatically every time we press a key and that's going to be we're going to have access to that key and we can do any sort of logic that we want on that key or using that key and we're just going to call love.event.quit because i don't like to press command q or click the red x i just want to hit escape be done with it and then what's our render what's love's render function called it's called love.draw so call love.draw and then uh because we're using push does anybody remember what we need to actually do to get push to render our screen to a virtual resolution so recall that there's actually two ways we can do it we can call push start and push finish which we didn't cover last week or we can call and that's actually the new like sort of de facto way to do it or we can do push apply start which is the deprecated way to do it but starting from here on out we're just going to call push start and push finish and then last we have our images we've allocated them as objects up here we have a background and a ground all we need to do now is just draw them to the screen so this is a new function or it's actually uh not a new function it is a new function actually love dot graphics.rectangle is what we used last week for all of the draw calls in this case we want to draw a graph a image object a texture object that we have in memory so we're going to call love.graphics.draw and it takes a drawable which means anything that love has defined as something that can be drawn in this case images are drawables they can be drawn and they can be drawn at any given position that you specify so if we wanted to draw it at the top left corner we would just say love.graphics.dropbackground at zero zero and it has that effect and we're gonna do the exact same thing with our ground the only difference being that obviously we don't want to draw at the top left corner we want to draw at the bottom of the screen so we just call virtual height minus 16 which happens to be the height of our image so if you run this i'm going to go ahead and make sure i'm in the right directory i'm not in the right directory so i'm going to go into a directory i wrote 50 bird scratch going into bird zero and if i run this i should theoretically have just two images layered on top of each other which i do not so let me make sure that it gets saved remember to always save your work and there we go so all we're doing now is it looks infinitely better than last week already but it's very simple very few lines of code all the effort that we've put into it has been in our sprite editor of choice and you can use most any application you want to do this sort of stuff i use a program called a sprite i like a lot but you could do this in which is free you could do it in photoshop you could do it in microsoft paint if you wanted to um godspeed if you do um but yeah so that's that's as simple as it is just to draw images to the screen so we've already made quite a lot of progress in a very short period of time in terms of the visual aspect of our game but it's not interesting to look at beyond the initial sort of honeymoon period of now we have colors on the screen we want to actually get scrolling because the game recall is a scrolling game and actually would anybody be willing to volunteer to come up and play flappy bird just so we can see it live on the stage david do you want to come up and play oh doesn't volunteer stephen you want to come up and play thank you for volunteering i guarantee you're better at this game than i am so i'm going to go ahead and cd into uh bird bird 12 in the directory which is uh the final version of the game complete so i'm going to go ahead and hit enter so already we can see the uh parallax scrolling that i referred to before which is the floor and the background are scrolling at different rates and we'll see this very shortly in the next example we have a prompt we have text we've already used this before with a font so go ahead if you press enter you're going to get a countdown so space is to jump so we have our bird jumping in the middle of the screen we have a score at the top goal is to avoid hitting the pipes oh i got a score of one we'll try again so it keeps track of his position and every time he gets past the right edge of a pair of pipes as you can see that's when he gets a point so if you recall from last week what do we think is what what's what's detecting the collision if you remember last week what's the term anybody remember access a bound a a b b collision detection access a line bounding box is the same thing that we did with pong except now we're doing it we have graphics but that's the same same as that concept we're just using rectangles and when one rectangle overlaps with another rectangle we trigger depth so one last iteration i think and then we'll oh we'll let you try one more time go ahead i'll give it a shot all right i'm gonna lose on purpose yeah okay here we go so to be to be unfair i i got plenty of practice while i was developing this but we'll see if that actually holds true here all right so notice also the pipes there's their the procedure generation that i oh i lost three points let me explain a little bit more i guess we'll do one more iteration but the pipes themselves every time we start they're spawning at a different location this is procedural generation pretty much the most simplest way possible um and notice that the pipes are shifting gradually so this is sort of like the makeup of our level um and it's just generating bit by bit uh due to some simple algorithm that we have that just says hey respond to the pipe here shift it by some amount and this very simple approach allows us to have an infinite level over and over again it's very efficient we only ever have as many pipes on the screen and as we'll see soon we only have as many pipes in memory as we can see on the screen at one time despite the fact that this level could theoretically go on infinitely and so it's very cost efficient so bird one uh is the example it's the parallax update so parallax scrolling is an important concept in 2d and also 3d but 2d game development it refers to the illusion of movement given two two frames of reference that are that moving at different rates so if you're driving on the highway and you see a fence next to you and you see mountains in the distance you're observing parallax scroll by seeing how fast the fence moves relative to the mountains the mountains are going to move a lot more slowly than the fence is right next to you and we accomplish the same exact illusion in our game by ref by using this sort of uh graphical illusion and so i'm going to go ahead in my directory here in bird one which is a unpopulated direct it's populated with the contents of bird zero the complete contents of bird zero your the version that you'll see will have uh all of the code but i'm gonna go ahead and if we run bird zero uh in that directory so i think right now i'm still in the full distro so let me go ahead go into 50 bird scratch again oops where am i and then i'm gonna go into bird one and run it and i get the exact same image that we had last time so everything is there from before just two images nothing moving no parallax that we can observe i'm gonna go ahead and start implementing the uh basics of this parallax so if i go ahead in my main so i'm gonna go down here to where we have our background so we need a couple of new things so along with our background image we need to keep track of how much it's scrolled because we're going to start drawing this image to the screen but if we're going to scroll it that means that we need to shift its x offset we need to instead of drawing it at 0 0 if we want it to scroll we have to draw it at some negative value instead over time this will have the effect of it moving right to left so i'm going to go ahead and keep track of a i'm going to use a variable to keep track of the scroll amount for both of these images and we're going to call them background scroll and ground scroll and set them to zero so this is going to have the effect of no x offset so i could use this variable right now in this draw call down here which i'm actually going to do i'm going to go ahead and go to i'm just going to find that that is correct i'm going to go ahead and set that to negative background scroll whoops and here i'm going to set this to negative ground scroll so this is not going to change anything yet it's going to be the exact same thing because they're both 0 they were 0 before but we're going to change them over time and in order to do this i'm going to go ahead and go into are uh up here uh one thing before we before we do that actually uh we need to set a speed for this this is going to happen over time but since they need to occur at different rates the background needs to go at a slower rate than the foreground so that we do get this parallax effect we need two separate speed variables generally the norm for something that is not going to change is to write it in caps with underscores this is constant notation this is frequently seen in most programming languages we'll use it here i'm going to set a variable called background scroll speed and i'm just going to set that to 30. i'm going to do the same thing ground scroll speed does this need to be higher or lower than the background scroll speed the ground is going to move the so the background needs to move slower than the ground does so this is going to be higher so we're just going to set it to 60. you can set it to whatever you want to get the effect that you want but this will already be quite noticeable the ground is going to move twice as fast as the background and so what we're going to do also is if we just so what's going to happen if we just let our image scroll infinitely what's going to happen at a certain point it's going to run out of image so how do we fix this problem loop it exactly so we're going to go ahead and set a looping point so another constant background looping point and we're going to set this to 413 which you kind of have to look at your image and determine you you sort of have to set your images up if you want to achieve this effect by having them be a looping image so have either two copies of the exact same thing that's their screen with or just copy the same chunk over and over again there's many ways to do it in this case the looping point of the image of our our background is 413 on the xaxis so we're going to set that to 413. and then we're going to go ahead the next step is we actually have to start uh changing the value so in our our update function which is where this is going to happen i'm going to go ahead and define love.update which recall lov2d will call for you but you must define it yourself i'm going to go ahead and set background scroll to so what this is going to do background scroll gets background scroll to itself plus the speed we set before times delta time so it stays frame rate independent um that'll have the effect of adding the speed to our image but we need to reset it we need to actually perform the reset and to do that we'll just be using modulus which recall from languages like c simply divides basically sets that value to uh the remainder of that division so in this case so 10 modulo 5 would be 0 but 10 modulo 9 would be 1 effectively because we have 0 left over once we divide 10 by 5 we have 1 left over once we divide 10 by 9. so i apologize if that concept is uh not new but we're going to do the same exact thing for our ground only we're going to modulo by the ground or uh of our virtual width in this case i did not set a looping point i do in later examples but the our ground image is very uh it's consistent enough such that you don't even notice it when it loops without using a with just uh without just using the virtual width so we're just gonna use the virtual width in that case it's very um patterned and very small um and aside from that yeah we already have the off the background scrolls here in our render or draw functions so when we run this code we should theoretically have scrolling background so does the images have to be twice the width they do at least twice the width yes there's ways you could effectively tile your image and do it that way to save memory on on a texture size if you have like maybe something that's a quarter of the screen size that you want to loop over and over again you don't want to have that as one big image you'll just draw four copies of that image to fill your screen and then just shift all of them or maybe five actually so you have a little bit beyond the edge of the screen and then just put all of them back to the bottom line the zero is you you wouldn't know if you just restarted showing the image but the the larger background you would have to worry about the mountain getting cut in half when you replaced it right exactly so like we could uh we could actually i could show you right now what that'll look like so if we just take out the looping point here or we set it to some like value that's completely inaccurate like 270 and then we run it after a while should just cut yep right there so are you stacked so are you drawing it twice really like one after another when it runs out no the image is so wide that it always will fill the screen even after it's been uh set back to even after it's gone past the looping point i forget how large the texture is it is yeah 1157 pixels wide so it's more than twice the screen width actually i think it is exactly twice the screen width um no it's not exactly how the screen is but it's more than twice the screen width so that when the amount the 413 pixels has elapsed it's still plenty past the right edge of the screen and the looping part it'll be the exact same appearance on the texture but it's completely been shifted back to the right so that zero zero is now at zero the zero zero of our image is now at zero zero in our screen space it's just taking it your image is here moving and then just instantly back to the beginning and then and moving back to it that's why and the setting it back to zero or however technically how many pixels has gone past the edge of the screen because using modulo yep it's a translation it's an instant translation it takes place over one frame so you don't notice it your human eye can't see it because it literally happens in one frame and it the exact the the image data is the exact same at those two points because we have a texture we've precreated a texture that has the exact same data so that you have that effect you have to have a texture that allows you to do this or smartly draw four of the same images keep track of all four of them or actually eight of them so that you can move them to the left and then shift them all back to the right when we get to super mario brothers we'll be talking about a concept called tile mapping which is where we take a sprite sheet and then you uh basically chop it up into pieces have a map in that is basically numerical so that a brick is uh like one the value one and then you look through this giant twodimensional array that you have and then go over it iterate over it and then draw a tile like give at an offset based on your index into that map so it's a little bit more complicated and you actually a lot more memory efficient but slightly different slightly different implementation okay so we have parallax scrolling now um i want to take a moment to because we've touched on we've sort of this is this is a very sort of introductory way of demonstrating that games our illusions by using parallax scrolling we've all we've done really is just set two things to scroll at different rates and this has made us feel like we have depth in our scene but all we're doing we have two images we're scrolling them at different rates um but this is a common theme in game development is taking trying to devise a scene that maybe is very elaborate but doing it on very resource intensive devices uh like your iphone or like you know old consoles like the nintendo 64 these sort of illusions are all over the place and a youtube channel that i um that i recently found that i really like is it's called the name of the channel is she says but the actual show that they have is called boundary break and what they do is they take a camera that it goes beyond what the game developers allowed it to do was they basically hacked the game camera so you can see in places where you weren't supposed to see before and you can see a lot of really cool trickery um i'm about to show you a couple of video clips but here's the youtube url if you're curious to see the exact video it's about 33 minute video um it's on zelda ocarina of time for the n64 uh and i'm i extracted a couple of particularly noteworthy clips that i thought were kind of interesting and also humorous i'm gonna go ahead and show the clip now so if we could dim the lights i'll go ahead and start this is a the first example okay so there's a lot to talk about with the shop owners in ocarina of time so i'm gonna just condense it down to the most interesting and the first one we're going to talk about is the bizarre shop owner in hyrule now in majora's mask this very same character is actually shown with legs but in our current time he did not have those in fact he looks extremely hilarious without his legs so this is a do we do does anybody have an instinct as to why they might have done this this way exactly and beyond that also just saving on memory right like not having to load a character model the vertices and textures associated with it on a such a memory constrained device like the n64 i forget how many how much memory it had like four megabytes of memory i think less than that um and so they were obviously cutting however many corners they could in this case by literally using the illusion of looking at not the illusion but just sort of like the fact that you only could see over the counter and sort of giving you the illusion that there's a fully living talking shopkeeper there but it's just a half a model and another example here uh is more to show how uh ocarina of time used its limited memory the n64 limited memory to give you the sense of being in a very large level when you might not actually have been so if you get in the lights one more time i'll go ahead and show this so this one was apparently a hot suggestion which is free camera on death mountain including our friend big goron the smoke halo looks sort of weird against the black sky and here you can see a nintendo fuldas it's not a full mountain only the cliff face is actually rendered that's the path leading towards the fire temple and if we zoom out we can see the scale of the whole map bigger than i thought it'd be actually the battle music's not quite fitting for an epic panning shot though same idea here really just limited memory space so let's load you know as much as we could possibly ever see from the perspective the camera of link and it's actually very similar to how i guess people create stages in real life to make you feel as if you're in a when you go to a play feel like you're actually in a scene but you know they've clearly cut as many corners as possible but it works in the game you can't tell and that's very common in game development and something if you're trying to achieve a particularly grand effect is something to think about is how can i make it seem like i'm doing something but i'm actually not how can i make it seem like i'm a bird flying through an infinite series of levels but i'm actually not we have a lot of sort of more of that to show coming up soon we have uh so so far we have our background but we don't have the uh title character of our game in the in this case uh 50 bird so i'm going to go ahead and illustrate how we can get a bird actually rendering on the screen so i'm going to go ahead into my bird 2 directory here that i've created note again bird 2 in your directory if you've loaded the code is going to have the complete implementation but in main i'm going to do a couple things so actually first thing i'm going to do we're going to notice that i've included actually i haven't included the class um file so i'm going to do that right now so in bird one or sorry i'm gonna take from bird three the class.lua i'm gonna go ahead and put it into bird two because we're gonna make a bird class recall from last week a class is just a way of taking several variables that we might once have had disparate from one another putting them in together in a package putting functions associated with those variables together so that we can call we we can sort of think of our world our game world more abstractly and more compartmentalized and cleaner so i'm going to go ahead and now i have in bird 2 the class.lua that's just the library we're using to get classes in love2d in lua i'm going to go ahead and i'm going to create a new file this one's called bird.lua so remember the trend is for classes capitalize them to differentiate them from functions and variables this one i'm going to go ahead and just go ahead and use my cheat sheet here poetry my sheets are sticking together okay so this bird class is actually fairly simple uh recall that all we have to do to create a class is just use the class library the capital c with the brackets there to initialize it we're going to go ahead and define our init function so every class has an init function which initializes the object that it's going to refer to later in this case we're going to need a few things so we're going to need an image for our bird because we want to draw to the screen and so what we need to do same thing that we did before love.graphics.new image i'm going to go ahead and hide this really fast and then bird.png simple easy we want the width and the height of our bird so i'm going to go ahead and set that too so uh every image has a set of functions associated with it that love implements for us the image that we get back from love.graphics.new image is itself sort of a class which has a function called get with so this will allow us to achieve the width dynamically of whatever class we whatever image file we happen to allocate and create an object from and then we're going to go ahead and set our x and y because recall we have to draw it somewhere we want to draw our bird in the middle of the screen so we're going to go ahead and just calculate this based on our virtual width so we're going to do virtual width divided by 2. so it's halfway in the middle of the screen but since it draws from the top left corner we want to shift it to the left so we're going to use our width that we just uh instant error we just initialized from the image data and then we're going to call it our do a self.width divided by 2. so we're going to divide the width by 2 shift that to the left on our xaxis that's going to put us in the middle horizontally vertically it's the exact same thing except we're using height instead of width and that's pretty much it except for one last bit here we want to be able to render our bird pretty important so we're going to do love.graphics.draw um our image and then at self.x self.y and so this is uh all we really need just to get a very simple sprite onto the screen now it's not going to do anything because this sort of lives in a vacuum at the moment what we need to do is in our main file we're going to require bird which is going to actually put it into our allow us to use it in our code we're going to create a local bird variable we're just going to call it bird we're going to after that simply render to the screen like that and if all is done and well and if i'm in the right directory uh it did not work make sure make sure you save your work again uh oh i did not require class my bad so also we need to do this since we added that to our directory uh i did not include the bird.png as well so i'm gonna go ahead and do that i'm gonna borrow that from the next directory that should be all we need to do and uh attempt to call method render a nil value interesting did i not save bird i did not save bird there we go we did it so uh not particularly interesting but it's sort of you know we're making steps remember to save your work yes we can see i do not um but we're making progress we have we have our our entity that we will control so uh you know we have visually we have we're getting very close but a lot of important details are missing what should be the next step do we think and we'll do that with the help of a notion that's common in platformers and a lot of games really but gravity how do we how do we think we can simulate gravity in the context of 2d game development just by default fall at a constant rate we could do that certainly um and that's effectively what we will be doing we'll be using something that we used last week which was velocity delta y and applying that velocity uh to our bird's y frame by frame and that will give it the illusion of falling now falling at a constant rate isn't accurate to what gravity actually does what we want to do probably is some gravity over and over again increment our gravity by some sort of constant value so that just like in real life things fall faster and faster and then we want to we want to add that to our y value so i'm going to go ahead and start implementing that now in bird three uh wrong repo so bird three we have everything that we had from before um except now i'm going to go ahead and in main.lua in our update function this is where we're actually going to want to perform the update logic for making the velocity apply to the bird we're going to defer that to the bird class we're going to assume that we have a method called update in our bird class which we're going to implement shortly and that's actually all we need to do in our main class it's sort of the beauty of having classes that you can delegate all this work to your main file though it's still getting quite large it's 108 lines it's not two 300 400 you know thousands of lines of code because we're able to break out this code and sort of encapsulate it elsewhere so i'm going to remember to save it this time and then i'm going to go into the bird.lua file in that directory which is the same with comments because i loaded it from the official repo the same bird code that we wrote before i'm going to go ahead and do a couple of things so the first thing that i'm going to do is define a constant so i mentioned gravity before gravity is going to be a constant value just like it is in real life i'm going to define it to 20. or just some arbitrary value this is the value that i decided felt right but you can tune this however you want there's no right or wrong way to do it the less the gravity is the slower it'll fall and the more you'll feel like you're sort of in outer space or on the moon or whatnot we're going to also go ahead and define recall that we need some way to keep track of how our position is or how our bird is falling we want a velocity a y velocity this is going to update our position each frame and it's going to make it feel like we're falling so we're going to set our initial velocity to zero the burst is going to be in the middle it's not going to be falling yet what we want to do is apply this velocity so remember in our main file we had an up we assumed that we had an update function but we haven't actually implemented it yet so we're going to do that right now we're going to say word update dt it's going to we're going to pass it in the same dt that we use in our main file and we're going to go ahead and just say our velocity is equal to our current velocity plus gravity times delta time we're just going to scale gravity by delta time so it'll move the same amount no matter whether we're running at 10 10 frames per second or 60 frames per second and then we're going to go ahead we have a velocity but it's not actually changing our y value the y value is what ultimately moves us on the screen so we need to apply that uh our new delta y to our y so we're going to go ahead and just do that self.y gets self.y plus self.delta y d y and so if i go back into bird three assuming i saved everything we should just fall straight to the screen which we do not terribly useful but notice it it's kind of it's slightly hard to tell maybe but it does move faster and faster frame by frame because that delta y is increasing as well as our y and that that delta y is getting applied to our y frame by frame i'll do it one more time just let's find a look at all right so we have basic gravity super super basic computation just keep track of some gravity constant a delta y increase that and apply that to your y and that gives you gravity but flappy bird can jump so we need to define a way to defy gravity so we're going to do the in bird 4 we're going to call this the antigravity update and we're going to uh talk about how we can actually get that going so i found this diagram which i thought was pretty apt um and it also covers a few of the other concepts we're talking about today but see here this gravity that's the constant we just defined before the 20 or whatever and this gets applied at whatever value you want it to be this gets applied frame by frame to your y what we want is this this vector here this jump velocity we want some value to sort of counteract this gravity that we've been accumulating so how do we think we can go about doing this we can set gravity to some perhaps negative value a high value and that'll have the effect of frame by frame if we if we go from you know some positive value which is taking us down on the yaxis and we go to a negative value it's going to start frame by frame it's going to say let's say we start at negative 5 or we set its velocity to negative five it's going to set y to negative it's going to set it to plus negative 5 pixels plus negative 4.9 pixels 4.8 pixels it's going to shoot us up pretty fast in a series of pixels but since we're applying gravity frame by frame this value that we set before 20 it's going to have the effect 20 times delta time so it gets effectively divided by 60. it's going to counteract this again so we're going to shoot up pretty fast but gravity is going to start taking hold immediately after and we're going to start getting the effect of our bird jumping and then falling down to the ground a couple of other things that this diagram shows which i thought were pretty cool this pipe gap or pipe gap distance here something that we'll be talking about pretty shortly because this needs to be defined so that we can offset our pipes pipe separation that's another thing we'll be talking about and also pipe width which is just an intrinsic value characteristic of the pipe sprite we'll be using but i thought it was a very apt nyu did a a nice little article if you want to look at this about exploring game space they computationally determined uh what would make a flappy bird level difficult or not and rated flappy bird levels that were dynamically generated based on some sort of scale so if you're curious it's in the slides but i thought it was a cool find as i was putting together this lecture so what we need to do is then simply add some negative value to gravity negative sort of antigravity so we're going to go ahead and do that so in bird four of the little mini ripa that i have here we're going to go ahead in main first one thing that we want to do is because another part of this is taking input from the user being able to jump we want to be able to detect whether they've pressed space but if we want to detect input for every single entity that we ever like in a game in an instance like this it's not terribly important but let's say we have like 20 or 30 different kinds of entities and they all have their own input handling we don't want to clobber maine with that necessarily so we can dedicate that delegate that i should say to another section of the code in this case we can sort of put our bird's input handling together with our bird class right and sort of expand up upon the model of the class or taking control of the code and data for that particular object in our scene so what we're going to do is in our love dot load i'm gonna go ahead and do something here i'm gonna go ahead and set i'm gonna go ahead and set love.keyboard.keys pressed equals a table and what i'm doing is just adding on to a table that love defines called love dot keyboard i'm adding my own value into it called keys pressed and i'm assigning it to an empty table so what we're going to do this is part of this is now part of what love gives us as part of its sdk but it's something that we've created ourselves and you can do this because in lua basically everything beyond basic variables or just tables and you can manipulate tables however you want in this case love.keyboard is a table i'm just adding a new key called keys press and i'm assigning it to an empty table of my own and we're going to see how this is actually used in just a moment so i'm going to go ahead in our key pressed function here this function gets called every time a user presses a key in the game but i'm going to use it because this because it does that i can go ahead and just do something like this love.keyboard.keys pressed key gets true and what that means is in this table that we've just defined we've created ourselves anytime the user presses any key because love.keypressed gets called for you we can safely rest assured that this is going to get populated no matter what key they've pressed because it's just something that love2d takes care of you but it's not getting stored until now now we're actually going to keep track of it in our own table for reasons that will become apparent very shortly the next part of this code is defining a custom function so the the impetus for this is love defines a couple of functions it defines a function called uh love.keyboard.isdown which takes in some key value and you can use it to test for continuous input which we did in the last the last lecture we're saying hey if up is down right now or down is down then we need to update our y velocity accordingly but it doesn't have a mechanism like this for let's say we want in some file other than main to check for if key was just pressed one time um it has this function love.keypressed which takes a key and that will trigger it but we can't access this outside of this function because if we define this function in bird.lua it's going to overwrite this implementation and we don't necessarily want to have to worry about other files overriding these functions because who knows if you're on a team especially who knows who's overwritten love.keypressed and what module and what order does it get loaded in and what function's actually valid we're going to take care of this problem by giving ourselves the ability to test for whether a key has been pressed on the last frame by implementing a function that we are also adding to the keyboard namespace the keyboard table ourselves called was pressed it's going to take a key and all it's going to do is check that table that we created before it's going to say if love.keyboard.keys pressed key then return true else return false and you could actually just return love.keyboard.keys pressed key and it'll be the exact same thing and so what this has the effect of doing is saying okay because on the update which we're about to see actually i should probably do that before so this all gets tied together um love dot at the end of love.update we're gonna do one last thing and that's reset that table because we wanna just check frame by frame so we have we have a table a global table that we've created to check for whether a key is pressed we have a callback function that love2td gives us that allows us to do that so every time a key gets pressed we're going to just add that key to that table and set it to true now we can just simply query that table anytime we want to with this function that we've created called love.keyboard.was pressed key which means on the last frame was that key pressed basically return whether it's true or false now the only problem is we're not flushing it we're not ever setting that to false that is the effect of if we just press all the keys in our keyboard those will always be false always be true until we reinitialize the table to some empty value which is what we do here on the update which takes place after all inputs been detected we're going to just set that table to an empty table again and on the next frame it's going to whatever keys we pressed those will get set to true and then we can just query that table here as needed and any update henceforth so does anybody anybody have any questions as to how this is operating and so the ultimate driving factor for us as to why we want to do this we want to put in the work to sort of keep track of this global input table is uh so that we can actually query input single key input based on or based in other files outside of main.lua because currently all we can do to check for single key presses is look in main.lua but that's not what we want to do we're going to go ahead and go to our bird.lua and in our update function this is where we actually get to use our efforts and say if love.keyboard.was pressed space which is the key that we want to actually allow us to jump go ahead and set self d y to what should we set self dot d y to when we press space bar should be a positive or a negative value a negative value we'll say it's negative five and we should probably define this as an antigravity constant up here but just for the sake of speed we'll say self.dy gets negative five and so and i did save that right i did save that i'm gonna go ahead and go into bird four go ahead and run this example and look at that we're jumping but we can still fall through the ground and we don't have any real gameplay but we've come a long ways now we've taken input single key input that we otherwise didn't have the ability to do in love2d and we've made it possible by just keeping track of our global input state and flushing it every update so does anybody have any questions as to how that works okay so the other big major visual component of flappy bird are these pipes that we see here on the screen we have two pipes there but the screen is filled with infinite pipes so does anybody have any instinct as to how we can implement this well we'll see before long but suffice to say we'll need a new sprite we'll need some sort of way of keeping track of when to spawn them because they sort of spawn you know after a period of time and that'll be sort of our gap and then what happened will happen if we just let it spawn forever and ever we do because if we don't do that after a certain period of time we're allocating memory for each of these pipes not a ton of memory um just you know essentially an x a y width and a height but because they all reference the same they will reference the same sprite image but given enough time eventually you're going to allocate a certain number of bytes that will exceed your computer's memory or the amount of allocated memory and you'll either hang infinitely or crash and so we want to destroy them as they go as well so we're going to go ahead and look at sort of the final live coded example just because from here on out it's going to be a little bit much i'm going to go ahead and go to main.lua first so just get my notes in order the first thing we want to do oh i'm actually in the wrong repo too i apologize i was in the district repo i want to be in the scratch repo so i'm going to go ahead go into main i'm going to require pipe now we don't have a pipe yet but this is a perfect example of how we can sort of keep abstracting our game we have a bird class but we should also probably have a pipe class because a pipe is a distinct type of entity in our game world we can sort of model it as a unit we can give it functions we can give it data and think about it in terms of it being a pipe not being a set of x y with height you know etcetera whatever whatever data you want to ascribe to it we can abstract that out and think in more abstract terms which will allow us to scale a little bit better so we're going to go ahead and assume that we have a pipe class i'm going to go ahead and go ahead and add it to our folder here right now so do a new file pipe.lua and i'm going to go ahead and reference my notes here for just a second go ahead and so the pipe class is actually quite simple just like the bird class was initially we don't need to keep track of a lot of data but we do want to keep track of a few things so the bird there's only ever going to be one bird out at once but with the pipes we're going to be spawning them over and over again and so if we allocate them out for each pipe that we instantiate if we allocate a new image this is probably not super efficient right we're using the same exact data we have a bunch of pipes we only really need one sprite so outside of the init function so just below where we're declaring that pipe is a class we're going to go ahead and create a local variable that is still scoped to this file but there's only ever going to be one copy of this object we're going to go ahead and call it say that we have pipe.png in this folder and this is sort of separated out from the functions that we're going to be defining in here but this has the effect of sort of creating a semi global graphics object even though it's contained within this this class file it's not accessible outside of this class file because we don't need it to be but it's also not being instantiated every single time because recall if we look at bird.lua here we're just setting it as self.image gets love.graphics.newimagebird.png this will have the effect of allocating a new image every time we create a bird object but we only ever create one bird object so it's not really an important design consideration for us to say maybe we should create a you know global semiglobal image up here it's not it's not important in this in this context probably good style to do so anyway for larger projects but um just a consideration for here not really something we need to worry about but yes definitely try to take an asset and reference it as reference it rather than allocate it as many times as possible um we want our pipes to scroll so we need some sort of value just like we did with the backgrounds we need some value that keeps track of whether these pipes are scrolling and it can be a constant value we're going to directly call it negative 60 this time and not sort of negate it when we add it to our position later on so pipe scroll negative 60 we can just add it directly to our x or to our well yeah in this case just to our x and then we'll have the times delta time of course and that'll have the effect of shifting it left because it's a negative number we'll define the init function here so pipe init within the init function we're gonna do a couple of things so uh it's x where should the x be what should the x be set to let's say if we want the pipe to spawn beyond the right edge of the screen yep virtual width and you could you could also say virtual width plus some number if you wanted to because it's set to zero zero uh it's going to have the you won't see it on the frame that it gets instantiated but yes virtual width or virtual width plus some constant value or some value that you've uh allocated ahead of time we'll just set it to virtual width so as soon as the pipe gets initialized it will be invisible but it's going to be right on the right edge of the screen what about our y value first of all let's take a look at what the image looks like so we can see it's going to be in our i don't think i have the actual image in that directory so i'm going to come here when i grab the pipe this is what the pipe looks like let's see if i can expand it a little bit so it's kind of tall where should we probably place it if we want it to look sort of similar to flappy bird probably towards like the lower end of the screen we can get fancy with it too and we can even maybe make it randomized just like flappy bird so we'll go ahead and do that i'm going to go ahead and copy this and put it into our scratch folder here back in the init function i'm going to go ahead and set self.y too because we want to talk about procedural generation this will be sort of our first foray into how we randomize this we'll be using the function that we used last week and this is a ubiquitous function you'll see this everywhere and any framework or game engine you use math.random we want it to be the lower half of the screen so let's say virtual height divided by 4 is the upper bound and maybe virtual height minus 10. as the upper bound so that'll have the effect of setting it to roughly a quarter of the screen or sorry virtual height divided by 4 is towards the top end of the screen and then virtual height minus 10 is the lower end of the screen so it's actually going to cover anywhere from the first quarter below that down to about 10 pixels from the bottom i do it in main so in this file i am not sure if i did it for this demonstration it is definitely set in the repo the i don't think i said it in this example but yes you would set the random seed here if you wanted to run every time oh sorry and the question was do we uh should we set the random seed in the bird file or should we set it in main.lua typically you want to set it at the top level of your application so we're going to set it in um we're going to go ahead and set it in the in main and the function itself is here and i think it's starting in bird six onwards so it'll be uh did i not set it i may not have set uh the random seed until later in the repo let's check bird 12. so yes math.randomseed and then seedbyos.time as we used last week in class um i won't i'll set it here um probably will only run it once but it'll it'll have the effect now we can run it several times just to see the the difference in the pipes let's go back to our pipe.lua here and we have the x we have the y so those are set accordingly we also want to set the width does anybody recall uh what the function is to get a the width of a graphics object and the syntax for that so we have our image up here pipe image love.graphics.new image pipe.png exactly so we're going to go ahead and set this to pipe image colon get width and that will become our new that'll allow us to start with for when we um we will use it later um and then we need a few other functions so the pipe will spawn but it won't move because we haven't applied any sort of scrolling to it we have the scrolling variable up on line five but we need to actually apply it to our pipe so we're gonna go ahead and create an update function and then in that update function very similar to what we've seen before already pipe scroll times delta time and then lastly we want to render our pipe so we're going to go ahead and call function that we've seen already today love.graphics.draw we're going to use the pipe image up above and then we're going to go ahead and uh use self.x and self.y and that's all we need for our pipe and let me make sure that that's all we really need so in main.load we got to go back to main.lua too because we actually have to start spawning pipes um so let's go ahead and go to pull up my code here one more time in maine so on line 59 or sorry you won't see it you'll see it line 59 in the actual distro code but um for me it's going to be different slightly different we're going to go ahead and create a new table to keep track of all the pipes that we want to spawn because we need a way to store them in memory we can't just set you know one variable to basically a dynamic almost like a dynamic array in this case but we're going to or a linked list rather we're going to use this table just to hold them we're not going to give them keys we're just going to insert them like we would do with just a linked list like in python for example we're going to go ahead and what do we need to do if we want to sort of have them spawn after a certain period of time probably want to like have some sort of timer we want to like keep track of how much time has passed and maybe have some sort of amount of time that's our like trigger to spawn up a pipe let's say maybe like two seconds so if we set a timer to zero it's gonna start just at zero but we can add to this frame by frame we can just increase this timer by delta time whatever that is frame by frame it'll be about a 60th of a second so um after 60 frames have passed we'll get one second after 120 frames of pass we'll have two seconds at that point we can then decide okay now it's time to spawn a new pipe let's go ahead and do that so i'm going to go ahead and in our update function we want to handle the actual increasing of this timer so it's as simple as make sure that i called it spawn timer i don't i just called it timer let's go ahead and call it spawn timer be a little more uh specific about what we want here so our spawn timer and then we're going to go ahead in our update and set spawn timer equal to spawn timer plus delta time and then what we need to do is then check is our spawn timer greater than because it keeps track of time in seconds delta time will give you a fractional amount in seconds so it'll be at .013 or something like that we want to keep track of whether spawn timer's gone past two right so if spawn timer is greater than two we want to add a new pipe does anybody remember the function for how to add to a table in lua so it's table dot insert so table dot will take in a table so in this case we want the pipes table that we allocated before and then we're going to put in a new pipe object we're going to call this is how you instantiate an object or call parentheses that will have the effect of now our pipes table is going to every time we call this it's going to get a new index so it's going to start at 1. lua tables are indexed at 1. first time it happens index 1 is going to be equal to a new pipe object which is going to start its x y at the edge of the screen then index 2 will be the exact same thing a new pipe that's at the edge of the screen and so on and so forth every time we call table.insert once our spine timer has exceeded two if we want this to not spawn a pipe every frame here after which would quickly clog up our uh our world we want to reset our spawn timer to zero so this will have the effect of now it's going to wait another two seconds and then this condition will be true again and then we can add a new pipe to the scene let's go ahead and look at a we're going to need to add a new um set of logic here actually i'm going to put all of this above the bird dot update and then below that i'm going to go ahead and do i'm not sure if we've covered this already don't think we have but if we want to iterate over a table there's a function that lua gives you called pairs it will give you all the key value pairs of a table that you can then use while you're iterating over it similar to enumerate and python if familiar except this will actually give you the keys rather than just the indices so we can do for k pipe in pairs of pipes do some body of code and then we have access to the key and the pipe within this we can just iterate over it and use it so first thing we want to do is we want to update our pipe so for each pipe update it give it the delta time of the current frame and then what was the other important feature so this will have the effect of scrolling it now it's going to get its x shifted but what was the other important thing we need to do with every pipe in our scene yes that is exactly true so what we're going to do is if pipe.x is less than so if we did less than zero what do we think would happen it would have it would we would see it instantly disappear because it's they're based on the top left coordinate so what we need to do is keep track of its width so what we'll do is we'll just say if pipe dot x is less than negative pipe dot width which will allow the pipe to go all the way past the edge of the screen we'll call a function called table.remove which takes a table in this case pipes and then it takes a key and the key we have access to up above on line 124 we can just say k and that'll have the effect of removing that pipe from the scene and then as soon as that's done uh we're good to go the last thing that we need to do is currently we're not actually drawing the pipes to the screen so down below in our render function we're going to go ahead and up above before we do the ground because if we do it normally if we do it after we we render the ground it's going to the pipes are going to look like they're just kind of like layered on top of the ground we want it to look as if they're sticking out from the ground so what we want to do is have a correct render layer a render draw order to the screen we draw the background we draw the pipes then we draw the ground and this will have the effect of looking as if the pipes are sticking out of the ground so what we'll do is we'll do the exact same thing we just did up above by saying for k comma pipe in pairs of pipes do uh pipe and then the render function that we defined in pipe and also the effect of iterating through all the pipes in our scene every draw call and drawing them before it draws the ground and before it draws the bird and that should be all that we need to illustrate this example make sure everything is saved i'm going to go ahead and go into bird five if i did everything correctly this should after a certain period of time draw pipes to the screen that are scrolling and they're randomized their y value is getting set to some value between the top quarter of the screen so about starting right about right where flappy bird is right now down to about 10 pixels above the width of the screen which actually that looks like 10 pixels above so that's a slight bug should probably be something along the lines of 30 or 40. we won't encounter that in the final distro because they're not set to spawn that low but you can see how this is sort of the beginning of our procedural level generation system and we have most all the components of our scene now we get normally in flappy bird we have two pipes we have a pipe that's above and then a pipe that's below and they're sort of in pairs and the next example we're actually going to start illustrating this we're going to have pairs of pipes that are joined together which scroll together that once you fly through them you score a point but for now we sort of have all the pieces that we need in order to get uh you know sort of have the basic visual uh sense of the game completed we're going to take a like a five minute break now and then once we come back we'll actually dive into how we can get pairs of pipes into our scene and may start getting into scoring and some other fun things like music so all right welcome back so the next part so before we establish the bird the background the pipes we have all the visual aspects of our game sorted ready to go the next important piece of the puzzle to really solve is how can we start scoring our game and also how can we get the pipes matching the way that they are implemented in the actual game which recall they're normally in pairs as illustrated here and we also see on the right hand side as we've covered already so far we have the spawn zone for our pipes and on the left we have what i've labeled the dead zone where pipes are sort of deinstantiated once they've gotten past the negative width of themselves but pipes come in pairs they get shifted and the once the bird flies between these gaps is ultimately when they've scored a point and so we need a way to pair pipes together and sort of uh define this sort of logic for how can we tell whether the bird has gone past the the gap and whether or not the pipes have been deinstantiated so we're going to go ahead and i'm going to probably stop live coding for the rest of the demonstrations because they're going to be a little bit more complex but i believe my code editor is over here i'm going to go ahead and open up oh this is my other editor okay so in the base repo now we're going to go ahead and look at the full example so in bird six which is the pair uh pipe pair update our current subfolder that we're looking at we're going to start in main so on line 33 in main we can see that we're requiring pipe pair which is a new class we're defining we're taking the pipe that we had before and we're sort of creating a new composite class we're going to take a class that sort of encapsulates two pipes together a pair of pipes and we're going to use this to think about our problem more abstractly than we already are and this sort of layering of abstractions is a very important um concept in computer science generally speaking but especially in games where you might have objects that are composites of objects that are composites of objects and these abstract hierarchies are sort of what keeps programmers sane when dealing with such um you know large levels of i mean you have thousands of lines of code sort of the only way you can really make sense of it so on line 65 if we look now instead of a table that's called pipes where we've renamed it to pipe pairs we're no longer going to store individual pipes in our scene we're going to sort of take these pipe pairs that we're going to create and store them in our table as well as whole as like individual units on line 71 we need a variable to keep track of the uh we're calling it last y the purpose of this variable is so that we can keep track of where the last set of pipes sort of spawned their gap right because we if we made our gaps completely random it will have the sort of effect of not looking continuous for one and also potentially being impossible to beat we want some sort of smooth so contour to our gap so that we can fly through them reasonably and that it looks as if it was almost premade and smooth so we're going to keep track of a variable called last y we're going to start it off at negative pipe height so up past the top of the screen plus some sort of value between between 1 and 80 and 20. so it's going to be it's going to be roughly towards the top of the screen and this is important because last y is going to be we're going to end up flipping our sprite and a flip on the yaxis has the result of the sprite sort of looking as if it's gone its whole height above where its actual y is and we'll see um in more detail shortly why this ends up working the way it does we're going to go down to line 132 and in our sort of condition if our spawn timer is greater than two um what we're going to do is this is where we spawned our pipes before but now we're spawning pairs of pipes so we're going to set a local variable y it's going to be this is the the clamp operation that we talked about sort of last week using math.max and math.min to sort of com like apply some sort of operation in this case we're going to add a random value between negative 20 and 20 to whatever our last y value was which is going to shift the gap effectively by negative 20 or 20 pixels we're going to clamp it between negative pipe height plus 10 so about 10 pixels from the top of the screen and then uh we're gonna set the upper bound to virtual height minus 90 minus pipe height and this minus pipe height is only because we're doing a flip operation on our yaxis for our sprite i'll go into it in a little bit more detail sort of try to make it clear as to why we're doing it and maybe i'll take out some codes to illustrate what it looks like without that operation applied but basically it has the effect of 90 pixels from the bottom is where the pipe could the gap could spawn so basically the pipe at the very bottom recall that this gap is where the this uh value is where the the gap itself begins not necessarily where the pipe starts it'll be between negative pi pipe plus 10 between negative basically effectively between 10 pixels from the top of the screen between negative or between 90 pixels from the bottom of the screen and then we're going to apply a random permutation of this value we're going to add some value between negative 20 and 20 and that will sort of give us a contour and it'll be sort of a randomized contour line 136 we have pipe pairs table insert into that instead of pipes and we're just adding a new pipe pair and we're setting it to uh that the value y and then this the pipe pair takes in a y value and that'll be where the start of the gap is and what what this will have the effect of doing is it's going to flip a sprite above the gap so that we have a pipe right above where the gap starts and then it's going to draw another pipe unflipped about 90 pixels below that and that will be how it sort of puts the two together line 144 is a loop that just updates our pairs instead of our pipes so we've just all we've done here is just renamed it from pipe to pair and we've instead of pipe instead of pipes we're using pipe pairs we're doing the same exact thing here one on line 153 we've done 4k pair in pairs of pipe pairs and then line 150 sorry line 175 is where we are or sorry 170 is where we are rendering each pair instead of each pipe and so if we open up pipe pair here we can take a look at this class from scratch so it's a new class we're going to set our gap height to 90 pixels and so this is just some arbitrary value that i felt was like a pretty fair value in terms of size but you could tune this to whatever you want you could set this to if you want to be really cruel you could set it to something like 50 or if you wanted to be really generous to the player you could set it to something like 150 and make it fairly easy for them to get through or as part of the assignment you could randomize it so that the uh so that it varies uh you know pair by pair and you get more of an organic looking obstacle course still shifted by negative 20 to 20 pixels but now your gap varies and you can also randomize the shift amount if you wanted to as well let's say you wanted maybe the maybe you want the gaps to be up to 40 pixels difference instead of 20 pixels difference on negative and positive value you could easily do that as well on line 18 we're just setting our x to just like we did before virtual width plus 32 so we're setting it to the uh actually before we just set it to virtual width now we're setting it to virtual width plus 32 both are pretty much equal this will just give it a little bit of a delay before it ends up going onto the screen but you could effectively just do this virtual width the on the next line 24 this is where we sort of bundle together the pipes that we're going to end up actually rendering and updating to the screen instead of having just one pipe a pipe pairs two pipes we can easily put this together in a table so we'll just create self.pipes we'll set it to a table that has two keys upper and lower and the upper pipe is just a pipe and notice one thing is different about pipe now before it took no arguments it was just a regular pipe pipes had their own logic they set their own x and y they didn't need any sort of you know parameterization beyond that it was all taken care of for them randomly now they take a string so this top string means that this would be a top pipe so that means that if this pipe is a top pipe there's probably going to be logic and pipe that now checks to see whether it's top or bottom if it's top then we need to render it upside down we need to flip it along the y axis and then we're going to set it to self.y and recall that we set self.y we passed in self.y in main actually i'm not sure if i touched on that let's go back to main here so if we go to figure out where i actually instantiate by the pipes here on line 136 after we've calculated where we want the gap to be for this pipe pair we're going to go ahead and insert into pipe pairs a pipe pair at y why was the calculation um between we basically took the last um y value the last gap that we instantiated and then shifted it by some negative 20 to 20 pixels randomly and made sure it didn't go above or beyond above or below the edges of the screen the back and pipe pair we're going to go ahead and look at line 30 or sorry actually we'll let's take a look a little bit more closely here at line 26. so upper gets top and self.y that's where the gap is and that's the sprite's going to be flipped upon that value the lower value is going to be a shift of that so the lower sprite needs to spawn below the top pipe by the gap amount so that the two are sort of you know top to bottom but there needs to be that space between the two of them so we need to take that pipe shift it down and then draw the next pipe so we're going to take self.y plus pipe height plus gap height and that'll have the effect remember gap height was 90 pixels the pipe height is a result of sort of flipping the uh the y ax the yaxis and having to shift it down the actual um position so if we go back to um line 30. so this is a this is an interesting sort of uh illustration of what happens when you edit a table while you're iterating over a table and i'll show you this in detail shortly but basically on line 30 we're setting a flag called remove to false and what this is going to do is before we were just destroying the objects whenever it got past the edge of the screen we just destroyed it but if we're iterating over a table of values let's say a table of pipe pairs when you do a removal in most programming languages in lua when you do a removal of a table of a table value and it's nonindexed or it's nonkeyed which means that it's indexed by you know numerical indices this will shift every other value down and so when you're iterating it and you shift everything down the value you are currently manipulating let's say it's equal to one if you remove that value you shift everything beyond it down by one but then you're going to increment up to two and you're skipping over what was previously just two and is now one so you see effectively skipping over one of your entries and that has buggy behavior and a lot of scenarios in this case it causes the graphics to sort of glitch a little bit because it doesn't apply a uh a pixel shift on one frame and so as pix as whenever a pipe gets removed and i can actually show this visually uh the first pipe left after that table of that pipe gets removed ends up moving a little bit to the right and so you get weird pipes shifting to the left of the bird on each frame so whenever you edit a table in place make sure not to delete while you're iterating over it it's going to cause buggy behavior and like i said i'll show you i'll illustrate this for you very shortly on line 36 we are performing the update logic now a pipe pair has two pipes each with their own render components and their own positions we we're using the code that we wrote before for pipe and we're going to try to expand upon it a little bit so we want to defer we still want to defer a lot of that code to uh the pipe class and we want to update the pipes based on um whether they we want to still keep track of their own x and their render functions and so we're going to see if uh basically if our pipe pair x is greater than negative pipe width which is the same exact logic that we're using before set our own x to um the that minus pipe speed times delta time which is the same operation we were doing before but we are also editing the x of our self.pipes lower and upper and this will allow us to on line 46 render the pipes just as we were doing before because they're getting their x values updated just as they were before so we're effectively deferring the render phase to our pipes and not really needing to add any additional logic for that in our code if we've made changes to pipe.lua as well so i'm going to go ahead and open up pipe here whoops and we've set the height and width of it as constants here so pipe height gets 288 and that happens to be about the size of the screen pipe width gets 70. on 31 we're setting self.orientation gets orientation notice our init function which was previously just empty it took no parameters now takes an orientation and it takes a y value the orientation is going to be going to allow us to say to ask basically is our code a top pipe or a bottom pipe and if it's top pipe we need to flip it draw it and shift it if it's a bottom pipe we're just going to draw normal and not perform any sort of fancy you know sprite flipping or anything like that down here on the render function is where this actually happens so on line 39 we're drawing the pipe image as usual at x but at y because when you flip a sprite it ends up completely uh flipping the white but it basically performs a mirror on it but it not at zero zero it it basically shifts it up by pipe height amount we need to keep track of that and draw it at self.y plus pipe height because if we draw it at just self.y because it's going to be mirrored and it's going to get shifted by pipe height amount it's going to be beyond the top edge of the screen and we we need to account for that account for the fact that we're flipping it on the yaxis and bring it down the code where we the question is where's the code where we flip it so that's actually here on this line on this condition we're saying if self.orientation is equal to top then we want to so the parameters here i'll comment this just for clarification it does uh and i'll show you here so this is zero we've added a few new parameters to our love.graphics.draw function 0 is rotation we're not going to rotate it at all this is the scale on the x axis so x scale and this is the scale on the yaxis so if we apply a scale operation of one it's the same thing as applying no scale like doing no scale at all it's just gonna draw it on the xaxis it's just gonna draw it normally but if it's top if where if this pipe has been set to an orientation of top we need to we're going to set the scale to negative one when you set a sprite its scale factor to negative one it flips it along that axis effectively and so that's how you get mirroring in most engines that allow you to sort of apply scale operations to 2d textures or 2d sprites a negative operation on an axis will mirror it on that axis and so that's what we're doing here so we're mirroring it um if it's a top pipe and we're also shifting its draw location as well because when we mirror it it's going to at 0 0 it's going to do the same it's going to basically draw the same exact thing but mirror it on the yaxis so it's going to need if we want to draw at a given location flipped like still draw it at 0 0 but have it be flipped we need to account for that flip and shift it downwards if that makes sense so that's essentially all that's involved there and i think that's pretty much all of the code so we have our pipes now that are being uh when it's flipped if it's a top pipe it's going to get drawn shifted it's going to have its other pipe shifted down by that amount and set to negative or set and increased uh its yaxis is going to be increased by the gap height so that it gets drawn you know 90 pixels however many pixels you want to set below that pipe so we're going to go into demonstrate this go up to 50 bird the actual repo now and the actual distro code i'm going to go into bird six and i'm going to run it whoops and now we have pipes that are actually rendering but we're missing a couple of important things foremost among them being that now we don't have we don't have collision detection yet so we can just fly through this course you know infinitely but notice that they're being shifted by you know random value between negative 20 and 20 pixels it looks more or less like it's being generated with some sort of goal in mind it's it's not you know haphazard it's not all over the place but you could easily find ways to tweak this such that you know maybe the gap height is some value between you know 60 and 120 and so you have easy and difficult pipes or maybe you have i think i'm so far below the screen that i can't even get back up anymore but uh oh okay i just that's physics error and when you when your value gets to a certain point i think that's actually uh what it's doing is actually overflowing the value and setting it to a negative or underflowing it and saying it to a negative value and then uh incrementing it because it's gotten so large but the uh but you could easily modulate parameters such as the width between the pipes as we saw on the diagram before or the or the height or even the speed at which they move and find ways to you know tune it to make gameplay that actually works for whatever goal you have in mind making it easier or more difficult and that's actually a topic that they talked about in that article that i linked to before where they generated levels programmatically and then tested them programmatically to determine what makes a level in flappy bird difficult or easy and so basically that's those are the parameters you need to sort of weigh as you're thinking of procedural generation and procedure generation ultimately is just taking values that you construct your scene with and just finding ways to just manipulate them randomly math.random some value and that's how you make random levels in a nutshell making good random levels is another question but uh he did he did there was a big controversy around this game back in 2013 but uh i didn't know if i read too much into that but i i was doing a little bit of a little bit of research and was reading about some of that stuff but i mean got to give them props for you know banking on that but yeah that's you know now we have pipe pairs that's arguably the most complex part of the program because going forward now as we get into collision and some more concepts collision is actually something that we touched on last week and it's all basically the same stuff so if we go into bird seven uh the next iteration of our application i'm going to go ahead and open up main.lua and then we're going to go to line 74. and um in order to test collision we don't we don't have scoring in place yet but we need some way to just to determine oh we we collided with the pipe we need some sort of feedback so what we're going to do is i've just decided we should just pause the game so once we once we collide with the pipe let's just pause instantly so we know immediately oh we collided with a pipe so i'm going to set some variable called scrolling at the top of the program in main to true it's going to we're scrolling we're going to start scrolling but when i don't want to scroll anymore when i want to pause the game this should get set to false so on line 120 if scrolling then do all of this update logic that we did before and then at the very end of that we're resetting our input table so we can still take input but no updates will take place if scrolling is set to false all of this stuff is within this if excuse me if scrolling then so very simple just encapsulate it all within some variable that we can turn on and off and then on 152 within that chunk of code that is being sort of contained within that if condition we're just doing a very simple iteration for each pipe it should be for l pair in pairs of uh oh no sorry for every pipe in the pairs of uh it's a nest it's a nested for loop in this case so basically within the the loop that looks over every single pair to update it we're doing another loop that's looping through with the pipes in that pair so it's only a loop of two iterations with the upper and the lower pipe we could just also say if bird collides with upper basically if pair dot upper pair dot lower or peridot pipes upper paired up pipes down lower but this is a little cleaner it's more scalable we can add more pipes if we want to even though it wouldn't happen but for every pipe in peridot pipes we have a function here that we haven't defined yet called bird collides so if bird collides pipe so it takes in a pipe so is going to return a true or false value we know that set scrolling to false so we collide scrolling set to false update logic is going to get shut off completely so we're going to have the effect of pause in the game we're going to go into bird.lua right now we're going to actually see how we implement this and it's going to look very familiar to what we did last week so in bird.lua this function here from 29 down to 45 it's just an aabb collision detection test that we did last week we're just checking to make sure any edges are you know right edge make sure that is to the left of the right edge of the second box bottom edge of box one should be our bottom edge of box one should be above bottom edge or top edge of box two if all these things hold true then return true else return false which means we have a collision and notice that i've shifted everything here by a couple of constant values does anybody have any instincts so why i'm saying self.x plus 2 instead of just self.x or self.with minus 4 why we're checking for that offset for the bird in this case when it is compared with the pipe it's not quite half it's a few pixels smaller do we know why we want to do this why we want to like we're basically shrinking the box why would we want to shrink the box so not quite so there isn't an actual gap between the drawing it's more of a question of how much do we want to frustrate how much do we want to frustrate our users right if if we're pixel perfect colliding with the pipes you know there's there's no give and take it's like you you collide and even if it might even look as if you're not even colliding with the pipe and you're still getting a collision your users are thinking well that's not fair that's really harsh we're shrinking our box so that you know even if they're just like a pixel off they'll still get a little bit of leeway and it'll be a little bit less strict in terms of the collision and this is a very common thing in games when you have characters whose sprites may not necessarily fill the entire box that you've allocated for them even though you're doing box collision just give your users a couple pixels deep however however many you want and they can overlap with whatever they're colliding with just a tiny bit before it actually triggers a true on the collision and it makes your game feel more forgiving and then also more fun as a result of that so that's why we have where instead of testing directly on x0 of that box we're testing x plus two and then self.with minus four because when we shift we add width to a plus two value we need minus four so that we get two off the right edge and same thing goes for the height and the y value and so this just performs aabb collision detection expects a pipe which means that we need to ensure that that pipe has an x and a y a width and a height which it does actually just a constant here we're just checking pipe width and pipe height we probably shouldn't do that it should be pipe dot width pipe dot height in that case because then this couldn't necessarily just be a pipe it could be anything in our scene that has a xy a width and a height it could be a general purpose collision and actually something you can also do if you wanted to is just write a function called collides that takes in two two things that you know have bounding boxes and will allow you to perform closing detection on anything in your scene any between any two entities that would be a more scalable way i guess of dealing with it rather than necessarily having it specifically defined as birds and pipes being the colliders but in this case this is the only thing we're really colliding with except from the ground but when you collab with the ground all you need to do is just check to see whether your y position plus uh your height has gone below the edge of the screen so any questions as to how that so the question was why did we add 2 and subtract 4 instead of just subtract 2 because when you add a because we're doing self.x plus two basically we're shifting the whole box essentially here in this part so self.x plus two brings the beginning of the box that we're that we're colliding with two pixels to the right but if we just do two pixels minus two then the boxes x right edge is still the right edge of the box we want it to be shifted inwards by two by two pixels because we've shifted at the start of our box the x position two pixels over we need to shift it four pixels inwards because that will give us the um that'll have the effect of our box having being uh two pixels uh into the right edge does that make sense okay so i think that's everything for bird seven um we're gonna go ahead and run bird seven now and recall if we hit a pipe we should instantly pause so balancing bouncing bouncing i'm gonna go through one pair of pipes here and then i'm gonna hit this one on purpose oh we paused and notice that we have a little bit of leeway we got a couple pixels there just to give us you know in case we accidentally uh and also it takes into consideration you could move because of your velocity a couple pixels beyond the uh necessarily the strict hard edge of what you're colliding with based on how many you know how many frames have passed and what you're dealt with you're basically essentially what your velocity is and what your position is in this case i think it looks like we're actually like three or four pixels above the edge because our velocity was so high because we jumped but as soon as it detected the collision as soon as we were on that frame where our position was such that we did trigger true for our collision detection it paused the game looping was set to false we no longer ran any update logic and this is our basic way of getting feedback about that however it's not particularly compelling gameplay wise and so we want to get into scoring before we get into scoring though and also associated with that different states of our game so if we get into scoring clearly we want to have a screen that tells us when we lost and how what our score was we should also probably have a title screen because we're just jumping right into the game gameplay we want a screen that lets us play through the game and um as we'll see in a little bit a screen that also gives some time to uh once we start the game to sort of count down sort of say oh three two one go rather than just oh go and oh i don't know what i'm doing i'm bewildered so this is a sort of a diagram that sort of models the state flow that we're going to be using in our program here our game we're going to assume that we start on some sort of title screen state so going left to right a title screen state will transition to the countdown state and then we can define however we want those transitions to be in this case let's just say we press enter title screen state goes to countdown state once countdown state has once the transition is triggered for that we should go to the play state and then once the transition triggers for play state we're going to go down to the score state and then score state should go back into countdown state and this models our entire applications flow uh you know sort of top to bottom left to right chronologically so let's go ahead and take a look at some code as how we're going to accomplish this last week i alluded to taking us and actually earlier in lecture us going from sort of this string based approach to keeping track of our state with if conditions to a classbased approach and that's what we're going to illustrate today so i'm going to go ahead and open up bird eight and in bird eight i'm going to go ahead and start with maine so in main on line 36 we're acquiring a new class called state machine and a few other classes that we're defining called base state play state and title screen state and these are the components of our state machine and they've now instead of being just blocks of code in our update function they're separate blocks separate modules that have their own logic their own update and render logic and we'll see that very shortly on line 78 if you go down here separate from that i'm also instantiating a bunch of fonts we did this last week so love.graphics.new font takes in a file and then a size i've created a few different fonts here because we have a few different ways of giving feedback to the user we want a small font for displaying you know uh press enter to start or something like that we want a medium font for to display the name of the game perhaps or i think actually flappy font's responsible for that medium font i think was for score huge font for our countdown we want a big font right in the middle of the screen that says three two one and then we start and then we're just going to start off by setting it to flappy font which is our gonna be our title font so nothing really new but uh the beginning of our ui so to speak on line 92 this is new and actually this is a demonstration of a type of naming convention you'll see often in game code bases we haven't used it yet but we will start using it in the future we prefix a global variable with a lowercase g this lets you know when you're digging through a bunch of files that oh this is a global variable okay so i should probably know um it's probably not defined in this module maybe it is but i know it's global other things you might see are lowercase m for member which means that this is a sort of a member uh function or a field of a class and you can instantly see it at a glance and know okay if i want to find the definition for this it looks like it's a member function so it's probably in this class here at some line you can easily find it and so in future lectures we'll be using more of this sort of g lowercase g for global variables that we use module to module in this case we're instantiating a state machine so we're using the class that we've that we will take a look at in a second the state machine takes in a table with keys that map to functions that will return our states so we can just call change some some value and it'll have in our state machine it'll basically reference that key in this table here and it'll call that function based on it'll basically set current uh the current state of that state machine to whatever state gets returned by the function at that key so in this case change is going to trigger return new title screen state and we're going to get the state machine is going to be set to the title screen effectively and we'll take a look at what the title screen looks like momentarily on line 96 yep we're changing to title screen on line 134 notice that we don't really have much update logic in this application anymore we're still updating the scrolls because this is behavior we want across all our states no matter what state we're in we want to make sure that our background and our ground scroll so that we have movement we don't need to duplicate this behavior state to state this is a global feature of our game so we're just keeping track of it here just as we would before but anything else in our game that needs to be updated can now be deferred to our state machine class and when we call g state machine update delta time it's going to look and see what's our current state and it's going to update that state and that's going to basically be that chunk that if chunk do this logic that we were doing from before last week when we had a sort of prim more primitive state machine line 46 same exact thing between the background and the ground because those will always render scene to scene we want to render our current active state using our state machine render function and so let's go ahead and just look briefly at our state machine library it's a very simple code it's actually taken from the book i alluded to earlier in the lecture how to make an rpg they give you the state machine which sort of um really cleanly i think handles a state transition basically takes an init and then a series of states sets it has a an empty uh class or empty table so all of these are just empty um if there is no this is a a thing you can do in lua which just lets you initialize a variable if it's not given a value in your function so self.states gets states or some value which means that if states is equal to like a falsie value is equal to nothing just set it to this empty table so it's just a shorthand for instead of saying you know if states equals nothing then set states to empty table self.current is just an empty class so our empty state so this is basically what a state is it's just a set of methods a render update enter and exit function that's a state and then you define all of the behavior in each of these functions and that compiles your state more or less our change function takes in a name and then also some optional parameters that we can use to enter that state um when we set the when we change the state set whatever or call the exit function of whatever state we're in so exit that state maybe your function needs you to deallocate some memory set the current equal to taking that name and then call whatever function's there so it's going to return in that case we saw earlier it's going to return a new title screen state so that's going to be what current is with self.current we're going to then enter that state machine so we're going to call the enter function that we've defined there with whatever enter parameters we pass into change which are optional and then here state machine update just updates whatever the current state is and render updates whatever the current uh state is as well and so i'm going to start going a little bit quickly just because running short on time base state is a all it does is just implements empty methods so that you can just inherit this state and you can choose which methods you want to define without throwing any errors because it blindly will call all these functions not checking to see whether they're actually implemented and so this is a way for you to just quickly uh avoid a lot of boilerplate code essentially the title screen state here uh this is your way of with the class function class library just including everything that belongs to bay state so inheriting if you're familiar with other languages that use inheritance take an object copy everything from that object or that class put it into this one and then add new stuff to it that's basically what inheritance is we're inheriting from base state so it has all the functions base state has and then on top of that we're defining an update function so if we press enter return change the state machine the global state machine to the play state and then for the render we're just going to render 50 bird and press enter halfway in the middle of the screen and then the play state essentially to some basically what the play state is is all of the code that we ran before only now we're just putting it in the update function here and the render function here and making bird pipe pairs timer and last y member fields of this sort of state object so we'll go ahead and run this really fast and then we have uh this is our title screen state so we at the very beginning we change to title screen state all it does is render and then the scrolling behavior is throughout all classes all states so we'll see that no matter what once you press enter it'll trigger change to play which will return a play state and then now we're back where we were before and we're seeing the difference now and having a couple of different states so quickly i'll go through the score update so this is a little bit um more complicated than the last example but to summarize in uh bird oh sorry we're in bird nine so in bird nine if we go here we're going to go to main so notice that in main down where we define our state machine we're going to go ahead and also note that we require a new score state because now we want to display a score screen down on line 96 score gets a function where we return a score state object so now we can change to score and it'll return that state and we can define all the behavior within a score state that we need to display a score in pipe pair we have a new variable called self.scored set it to true or false we're going to set it to true if the bird has gone past the right edge of the of the pair of pipes that'll have the effect of us scoring a point effectively because all we need to do is just make sure the bird's gone past that pair of pipes because otherwise it'll have collided with it if it does go past it uh set it to true and then add a point to our score and in our play state we can see that we've added a point so if we go to uh our play state 26 is where we actually keep track of our score self.score gets zero in our play state we're going to go ahead and go down to line 56 so for every pair if it's not been scored yet because we don't need to calculate this if it's already been scored it should we should ignore it in terms of scoring once it's been scored if the x plus width is less than our bird.x meaning our bird is beyond the right edge of the pair of pipes increment our score and set that pair to true we will then thereafter because of this condition ignore it and we're also going to increment our score so it's going to be kept track of on 83 notice that if we're colliding with a pipe we should transition to our score state now so and we're also passing in scoregetself.score as a table because remember we can pass in parameters when we call change and this will be passed into our enter function in our state and then score is going to equal self.score we'll have access to the score within that score state we don't have to keep track of it as a global variable to see it in both locations 93 the same exact thing this is collision to check whether we've collided with the bottom of the screen if our y is greater than virtual height minus 15 do the exact same thing transition to the score state and pass it in our current score so another death condition and then 104 we're just going to set flappy font and then we're going to render our score at the top left of the screen at 8 8 and that'll have that effect and so lastly here our score state is pretty simple all it is is we're going to get from those parameters we passed in by a change self.score equals params.score we're going to when we press enter go back to play and then we're going to render you lost and the score which we have access to self.score and then press enter to play again changing fonts along the way and so if we go back to bird9 and then we run this notice that now we have a score in the top left and i'm going to get one point and then die and we go to our score screen now it just remember we passed score into it from uh our play state we passed it as parameters and then we can press enter again go back to playstate and when we fall to the ground we do it as well so we're just taking a look at how to add scoring to our game but what if we want to add a countdown screen maybe we want the users to be prompted three two one before the actual game starts you know throwing pipes at them give them the time to you know sort of get acclimated we're going to go ahead and take a look at how we might do this using another state very similar to the last example we're going to add a new state called countdown state which is shown here on line 38. we're also going to down in our state machine add a new key which returns one of the new countdown states just as before and then we're going to go ahead and take a look at our actual countdown state here so in our countdown state dot lua which is in our states folder as the others it includes from base it uh inherits from base state we have initialized the countdown time to 0.75 this is time in seconds one second is a little long so i made it 0.75 seconds we're going to initialize a count to three and a timer to zero the count is going to start it's going to use a timer once the countdown time has elapsed right here as this logic shows increase the timer once the timer has gone past countdown time we want to go ahead and set it to uh we're in a modulo by countdown time so loop it back to zero plus whatever amount beyond the count on time we went so that we have a smooth track of time we're going to set self.count minus itself by one so that we go three two one and then if our count is zero which means that we've gone all the way down in our account we're going to go ahead and use our state machine and change to the play state and here we're setting our font to a font that we've set huge font and then we're just to string a little function that takes a string or it takes a number converts to a string we're displaying self.count at 0 120 and then our ver it's printf so we're basically starting at 0 y120 virtual width alignment and then we're centering it so the one last piece of that that we need to change is in our title screen state instead of going straight to a play state here on line 15 we're going to a countdown state and what this has the effect of doing if we go into bird 10 is when we press enter notice that we're going 3 2 1 then going into our play state not just going straight into the place as before giving our user a little bit of time to sort of catch their breath and then if we die we go to our score state but once we press enter notice we're doing that as well so in our score state we also are changing to the countdown state so that was how to make a countdown state probably my favorite part of many of these examples and of this example as well is adding audio to our application music and sound effects which really sort of tie everything together so we're going to go ahead and take a look at this it's very simple very similar to what we learned last week when we even when we just did pong so in maine da lua of bird 11 which is what we're going to look at now we're going to take a look at a table of sounds that we've initialized on line 88 we've given them all keys jump explosion hurt score these are all sound effects that i've generated with the bfxer program that we used last week if you recall and then a music track that i found online on free sound which is free to use the link is here if curious uh just a nice sort of happy sound track uh that i found for this game on line 99 to 100 we're going to take do one additional step before we start the music we're going to set looping on that to true because in games that are sort of infinite like this we don't want our music to just go and then stop abruptly we want to you know have it loop so play it after set looping to true initially actually begin the play of that music outside of any of our states because it's going to be a global music track and then that's the music we also need sound effects so if we do in our if we look in our bird file here on line 45 which is where we have the logic for jumping we're also playing a sound of the jump sound effect that we've generated additionally in our play state if we take a look there we can go ahead and see in our states folder here go to playstate and take a look at line 58 this is where we score a point so we should play our score sound effect here simply put and then the same thing on line 80 to collide the sound effect here which is we're actually layering two sounds on top of each other which is a common thing to do in sound design and game design one sound often isn't all you need to accomplish a particular effect so i have an explosion sound which is kind of a white noise effect and then a hurt sound effect is kind of like a sort of like a downward uh like sine wave type of sound we're doing the exact same here on 95 to 96. once we put all these pieces together we're going to run bird 11. we get music we get a jump sound effect and when we score a point another sound effect and then if we hit a pipe notice that we have the sort of and a white noise there explosion effect layered together so that sort of brings everything together creatively and artistically as an exercise to the viewer in bird 12 in the github repo we have some code that allows you to actually add mouse clicks to the flappy bird in order to make it a little bit more like the actual game which was an ios game so it relied on taps the function that you might want to use is love.mouse pressed xy button and i would encourage you to think about how we took input and made it global in the context of the keyboard in one of our earlier examples so that we can call this sort of was the mouse just pressed in our bird.lua file as opposed to the as opposed to the main file and so next time we're going to be covering a few new concepts so sprite sheets so taking a large file of images and sort of taking out chunks of that so we don't have to have a million graphic files procedural layouts uh this will be in the context of the game breakout so we want to lay out uh all the bricks in our game sort of procedurally the way that in the sort of the same way that we've procedurally created a sort of pipe level in this game we'll be talking about separate levels and having them stored in memory as opposed to just one continuous level we'll be talking about health we'll be talking about particle systems which is spawning little mini graphics to accomplish various effects that are otherwise difficult to capture in a simple sprite animation a little bit fancier collision detection based on input so that we can sort of drive ball behavior the way we want to and then also persistent save data how can we take a high score and not have it refreshed to zero every time we run the application but rather save it to disk so that every time we run the program thereafter we can see what we've gotten scored in days past the first assignment or rather the second assignment assignment one is going to be a little bit more complicated than last week's but still fairly doable make pipe gaps slightly random being the first component of this so before pipe gap is set to a constant value maybe make it some sort of random value pipe intervals as well so we're spawning every two seconds maybe we want to change that up make pipes spawn a little differently a little more sporadically uh the more complicated aspect of this assignment is going to be awarding players a medal based on their performance so have like a maybe a bronze a silver and a gold medal an image that you display in the score screen in addition to just their score just to give them a little bit of personal feedback and sort of make them feel rewarded for their effort and make them strive to sort of get that last that last medal and then lastly you implement a pause feature which we talked about in class so that when you press for example to keep p the game will stop but unlike that example when we press p again the game should resume just as it was in its prior state so that'll be it uh for flappy bird i'll see you guys next time thanks a lot
