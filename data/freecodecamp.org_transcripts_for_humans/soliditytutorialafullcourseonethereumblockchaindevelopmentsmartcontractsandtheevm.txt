With timestamps:

00:00 - hey everybody this is gregory from daf
00:01 - university so i'm so excited to be on
00:04 - free code camp today to teach you how to
00:06 - become a blockchain developer i'm going
00:08 - to take you over the shoulder and teach
00:09 - you how to write ethereum smart
00:11 - contracts with a solidity programming
00:12 - language for the blockchain and you
00:14 - don't even have to know anything about
00:16 - solidity or blockchain to follow along
00:18 - so i've compiled this multi-part
00:20 - tutorial series into one massive video
00:22 - for free codecamp and you can follow
00:24 - along with the code examples step by
00:27 - step on my website there's an article
00:28 - that i'm going to put a link to down in
00:30 - the description below and finally if
00:31 - you're serious about becoming a
00:33 - blockchain developer you need to join my
00:35 - free training on my website over at
00:37 - daffy diversity dot com forward slash
00:39 - boot camp and i'll also put a link to
00:40 - that down in the description below
00:42 - solidity is the main programming
00:44 - language for writing smart contracts on
00:46 - the ethereum blockchain
00:48 - it's a contract oriented language
00:51 - which basically means that you know
00:52 - smart contracts are the main way that
00:54 - you organize code and like store data
00:57 - and write all of your programming logic
00:59 - and you know it's a high level language
01:01 - for implementing these smart contracts
01:03 - it looks a lot like
01:05 - javascript and you know python and c
01:07 - plus plus as you see right here
01:10 - and it's used to run on the ethereum
01:11 - virtual machine which is basically you
01:14 - know uh the thing that runs the code on
01:16 - the ethereum blockchain
01:18 - so solidity is statically typed um as
01:21 - opposed to a dynamically typed language
01:23 - and it supports stuff like inheritance
01:25 - libraries and lots of other stuff so
01:28 - enough of talking about solidity let's
01:29 - actually jump in and start writing some
01:31 - solidity code this is a website that
01:33 - allows you to write solidity smart
01:35 - contracts
01:36 - in your browser and you know it has a
01:38 - text editor here and allows you to
01:40 - compile them and deploy them and run
01:42 - them and that's exactly what i'm going
01:43 - to use for this tutorial uh you won't
01:45 - have to download anything on your
01:46 - computer you won't have to install
01:48 - anything you can just visit this website
01:51 - to use remix and we'll write the smart
01:52 - contracts that way
01:54 - so in order to do that i'm going to go
01:56 - over here to this browser folder
01:58 - you can see the file browser over here
02:00 - this is some basic smart contracts that
02:02 - come pre-loaded inside of this ide
02:05 - i'm just going to create a new one here
02:07 - i think i can just create a new file
02:10 - this will be a solidity file
02:12 - we'll call it my contract
02:14 - and we're going to write a smart
02:15 - contract inside of here i'll do this by
02:18 - first declaring the version of solidity
02:20 - that we want to use we do that like this
02:22 - we say fragma
02:24 - solidity
02:25 - and i'm using carrot to specify a
02:28 - version greater than the one we want to
02:29 - use and i'm going to say version 0.4.24
02:36 - i'm going to end each line like this
02:38 - with a semicolon
02:40 - and next i'm actually going to declare
02:41 - the smart contract
02:43 - so before i do that i'll explain a
02:45 - little bit more about what a smart
02:46 - contract is
02:47 - you know smart contract is code that
02:50 - gets executed on the blockchain in this
02:52 - case this is going to be the ethereum's
02:54 - blockchain since we're using you know
02:56 - solidity for this ethereum smart
02:57 - contract
02:58 - and this smart contract is kind of be
03:01 - kind of like a microservice out on the
03:02 - web it's going to be accessible to
03:05 - everyone on the blockchain they'll be
03:07 - able to you know see this smart contract
03:08 - they'll be able to use it
03:10 - they'll be able to read and write data
03:12 - with it and actually you know execute
03:14 - any code that we write inside of here
03:17 - so it's going to be public
03:18 - and that's kind of why i call it like a
03:20 - microservice it's more it's more than
03:21 - just a class like in an object-oriented
03:24 - system or something like that it's
03:26 - actually something that's publicly
03:27 - accessible
03:29 - so it's going to look something like a
03:31 - class though because that's how we're
03:32 - going to actually you know
03:34 - keep all the code inside of here
03:36 - so i'll show you how to do that we'll
03:38 - call we'll start by saying contract
03:41 - say my contract
03:43 - and i'm open this with some curly braces
03:45 - and it'll notice that the editor closes
03:48 - this automatically for us which is
03:49 - really nice
03:51 - and what i'm going to do first is just
03:54 - show you how to read and write a value
03:56 - from a variable inside of here
03:59 - now like i said
04:01 - earlier solidity is a statically typed
04:03 - language so we're going to actually have
04:05 - to declare the type uh the data type of
04:08 - the variable we want to store
04:11 - so in this case we're just going to
04:12 - store a string
04:13 - and we'll declare a string we'll say
04:15 - value now let me explain something about
04:17 - this value
04:18 - this value is going to represent
04:21 - you know a variable that belongs to this
04:23 - entire smart contract so this isn't like
04:25 - a local variable it's actually a
04:27 - variable that this entire contract will
04:30 - know about
04:31 - and what that means with a smart
04:33 - contract is
04:35 - that data is actually going to get
04:36 - stored on the blockchain in storage
04:39 - so
04:40 - if we set this value we're actually
04:41 - going to be writing data to the
04:43 - blockchain
04:45 - that's different from a local variable
04:46 - that i might just you know set inside of
04:48 - a function
04:49 - that would be you know local to that
04:50 - function scope
04:52 - and would you know disappear instantly
04:54 - once that function is called instead
04:56 - this value is actually going to be you
04:57 - know stored on the blockchain
05:00 - so let's create a way to
05:02 - uh
05:03 - just read this value so i can do this by
05:05 - writing a function in solidity like this
05:07 - we start with the function keyword and i
05:10 - say i'm just going to call the function
05:11 - get it's going to get this value
05:14 - and we'll say we'll just open the braces
05:16 - for now i'm going to write some more
05:17 - code here in a second we can see some
05:19 - warnings coming up
05:20 - but i'll fill this out more we'll say
05:23 - just return
05:25 - value
05:26 - okay
05:28 - and that's a really basic way to do this
05:31 - i'm going to add some more to this
05:33 - i'm going to say this is also public
05:35 - all right which basically is setting the
05:37 - visibility of this function that's what
05:39 - that's called and solidity is setting
05:40 - the visibility so that knows that this
05:42 - function can be called by anyone who has
05:44 - access to the smart contract on the
05:46 - blockchain not just inside this contract
05:50 - so i'm also going to set a return value
05:52 - say returns
05:55 - uh string
05:57 - all right that makes our warning
05:58 - disappear down here and i just tell our
06:00 - function that we're always going to
06:01 - return a string data type and we know
06:04 - that's the same
06:05 - data type as value because we declared
06:07 - it here now i'm also going to look at
06:08 - this warning down here which says
06:10 - this function state mutability can be
06:12 - restricted so basically what this is
06:14 - saying is
06:15 - in solidity now in this newest version
06:18 - since we're not actually changing this
06:19 - value we're not changing anything inside
06:22 - this function we want to add an
06:23 - additional modifier here which just says
06:26 - view
06:27 - all right and that makes that warning go
06:28 - away
06:30 - so now i'm going to set a new function
06:33 - or write a new function
06:34 - that's called set let's say function
06:36 - that's going to allow us to set this
06:37 - value say set
06:39 - and say string
06:41 - i'll say value
06:42 - all right
06:43 - and i'm also going to you know set the
06:45 - visibility of this function we're going
06:48 - to call it public
06:49 - which means that anyone will be able to
06:51 - set this value on the blockchain
06:54 - and i'll say value equals this value
06:57 - that we're passing in
06:58 - all right
06:59 - let me explain that i'm using value as
07:02 - an underscore here because i want to
07:05 - differentiate between this value that's
07:07 - getting passed in and the value
07:10 - that's referenced here
07:12 - now inside of here you know this value
07:15 - without an underscore
07:16 - is referencing this you know state
07:18 - variable that we set up earlier that's
07:20 - actually getting stored to the
07:21 - blockchain and this value sliding knows
07:24 - that it's just a local variable because
07:26 - i passed it in and i you know prepended
07:28 - it with an underscore like this
07:30 - and also notice that i declare the uh
07:34 - data type of the function argument we
07:36 - need that inside solidity because it
07:38 - needs to know the type of the data
07:40 - that's getting passed in all right and
07:41 - now we have a way to actually read this
07:44 - value and set it
07:47 - the next thing i'm going to show you is
07:48 - how to set this value
07:51 - whenever you deploy the smart contract
07:53 - or whenever it's generated for the first
07:54 - time
07:56 - and i'm going to do this with a
07:57 - constructor function
07:58 - so if you're familiar with other
08:00 - programming languages where you might
08:01 - write you know classes or something like
08:03 - that you might be familiar with a
08:05 - constructor function
08:06 - which is basically a function that's
08:08 - called whenever this contract is
08:10 - instantiated or in this case it's going
08:11 - to be whatever the contract is created
08:14 - or whenever the smart contract is
08:15 - deployed to the blockchain
08:17 - and in the newer versions of solidity we
08:20 - do that like this we say constructor
08:23 - and we just you know say it's public
08:27 - and we can you know write code inside of
08:30 - this constructor that gets called
08:31 - whenever this contract is created
08:34 - and we'll say you know value we'll just
08:36 - set it as uh you know my value
08:41 - all right
08:43 - there we go
08:44 - so that's a complete smart contract that
08:47 - you know sets this value whenever it's
08:48 - deployed so it will have some sort of
08:50 - default value and then we'll have you
08:52 - know some functions that allow us to
08:54 - read that value from the blockchain and
08:56 - then we'll have a function that allows
08:58 - us to create that value as well
09:01 - so now i can go to this tab over here in
09:04 - remix and i can compile it we can select
09:07 - the compiler version
09:09 - and i'm going to say
09:10 - let's see here
09:13 - 0.4.25 we'll start to compile it and see
09:16 - what happens
09:19 - all right
09:21 - and now what i'm going to do is actually
09:23 - run the smart contract
09:25 - you'll see some options over here
09:27 - i'm just going to
09:29 - say javascript virtual machine which
09:31 - basically what that's going to do is
09:33 - give us a test block chain in the
09:34 - browser so we don't have to connect to a
09:37 - blockchain of any kind we can just you
09:38 - know compile this and run it and deploy
09:40 - it inside of our browser which is pretty
09:42 - cool
09:43 - and it's going to give us some you know
09:45 - free ethereum accounts over here i don't
09:47 - worry if you don't quite understand what
09:49 - all these values mean just yet that's
09:50 - okay i can explain those more
09:54 - but for now we're going to just keep my
09:56 - contract and we're going to deploy it
09:59 - all right there we go it's deployed
10:01 - so now what i can do is
10:04 - click on this little down arrow here and
10:06 - we can see the functions that are
10:08 - available to us in the smart contract we
10:10 - can see the set function and the get
10:12 - function you know these are the
10:13 - functions that we created over here
10:15 - the set function is going to allow us to
10:17 - update it and the get functions allow us
10:19 - to get it so i'll click get and we
10:21 - should probably see the value that we
10:24 - created inside the constructor we set it
10:26 - here so let's get it
10:28 - all right there we go it's my value
10:31 - and we can see some activity in this log
10:34 - down here we can see that we there's a
10:36 - call to mycontract.get
10:39 - and now let's set it so i'm going to
10:42 - enter
10:43 - the quotations for the string and i'm
10:45 - going to say new value
10:49 - all right let's click set
10:52 - all right and we can see that worked so
10:55 - you can see the transaction history over
10:56 - here let's get the value
10:59 - all right it's new value there we go
11:00 - that's a complete smart contract that
11:03 - allows you to get instead of value on
11:04 - the blockchain
11:06 - now let me explain what's going on here
11:08 - this is a list of transactions that are
11:10 - occurring on the ethereum blockchain
11:12 - so the ethereum blockchain is made up of
11:15 - you know bundles of records that are
11:17 - chained together into blocks that are
11:20 - make up the blockchain
11:22 - and you know the basic units of all
11:24 - those blocks are these transactions
11:27 - so we can see
11:28 - transaction receipts
11:30 - we can actually click the down arrows
11:32 - here
11:33 - we can see all the details those
11:34 - transaction receipts and i've got other
11:36 - videos on this channel that kind of talk
11:37 - about that in detail if you want to know
11:39 - more about that just feel free to look
11:41 - for those all right that's it guys
11:42 - that's how you can write your first
11:43 - smart contract in the solidity
11:45 - programming language
11:46 - again that's supposed to be just a high
11:48 - level overview of solidity and how to
11:50 - get started writing your first smart
11:52 - contracts and using the programming
11:54 - language itself and using the remix ide
11:57 - in your browser to get started easily
11:59 - without having to download any tools or
12:01 - anything like that
12:06 - the first thing i want to do in this
12:07 - video is actually update the smart
12:09 - contract code that we wrote in the last
12:11 - video to support the newest version of
12:13 - the solidity programming language which
12:15 - is 0.5
12:18 - 0.1 i believe now you can actually see
12:21 - the compiler version over here has
12:22 - changed and in the last video you know
12:26 - we wrote this smart contract and there's
12:27 - some actually some compilation errors
12:30 - you can see over here on the right so
12:32 - you have to update this code to support
12:34 - the newest version of the solidity
12:35 - programming language and i want to go i
12:37 - wanted to go ahead and do this i wanted
12:39 - to go ahead and support the new version
12:40 - of solidity so that when i make more
12:42 - videos in this series um they'll be up
12:44 - to date and you'll have the newest
12:46 - version so let's see what we need to do
12:49 - we can read the error it says
12:52 - basically the data location must be
12:54 - memory
12:55 - and that's actually the error in both
12:56 - cases so all we need to do in this case
12:58 - is actually just return a
13:01 - memory here
13:03 - and then
13:04 - whenever we're passing in the value a
13:06 - string
13:08 - we actually need to
13:09 - put memory here as well
13:11 - all right
13:12 - actually that needs to be before value
13:14 - my fault
13:16 - and now we there's go away
13:18 - so we will select the newest compiler
13:21 - version we'll say uh let's do the latest
13:24 - complete version 0.5.1
13:26 - start to compile
13:29 - and hopefully the compilation will work
13:30 - yep it worked so let's go to run and
13:34 - we'll deploy
13:36 - and see if it worked
13:37 - so get the value
13:40 - yep it worked awesome
13:42 - now let's move on to the next part of
13:44 - this tutorial where we'll actually cover
13:46 - the content for this video which is
13:47 - going to be you know the basic data
13:49 - types and data structures and solidity
13:51 - and how you can use them when you're
13:53 - developing your own smart contracts
13:55 - so i will change some values in here to
13:57 - kind of show you what that is the first
13:59 - thing i want to talk about are you know
14:02 - the different ways we can work with
14:03 - these state variables right so the first
14:05 - thing i want to mention is you know we
14:07 - had this string value here
14:10 - that we declared we set it here inside
14:12 - this set function and we had this getter
14:15 - function where we read that value right
14:19 - so solidity has a shortcut where i don't
14:21 - even need this function i can actually
14:23 - just read uh this string value for free
14:27 - i can actually get this function for
14:29 - free take this out and just declare this
14:32 - public
14:33 - that's that's declaring the visibility
14:35 - of the uh state variable here
14:39 - actually probably goes before so i'll
14:41 - save that
14:42 - and i'll compile it
14:46 - and i'll run it
14:48 - and we'll see that a
14:50 - get getter function called value the
14:53 - same name as the state variable was
14:54 - exposed to us by the smart contract and
14:56 - we can see it works just the same way as
14:58 - the other function did so that's a
15:00 - really nice way to save yourself from
15:02 - writing extra code you can just get that
15:04 - function for free exposed to the public
15:06 - interface of the smart contract whenever
15:08 - you store your state variables that way
15:11 - okay so the next thing i want to talk
15:12 - about inside of here
15:14 - is actually you know we could set this
15:16 - as a default value we don't necessarily
15:19 - have to put you know my value here in
15:21 - the constructor we could just say this
15:24 - right
15:25 - we could take this away oops
15:28 - take this away
15:30 - and we will um
15:33 - run that again let's just clear this out
15:35 - deploy
15:37 - all right and we can uh actually sorry
15:40 - compile it first
15:44 - deploy it again
15:46 - get the value and we can see it's my
15:48 - value we can also set this value as a
15:50 - constant if we don't want it to change
15:52 - um you know if we don't want to allow a
15:54 - user to set this value if we want to
15:56 - stay the same we can just say constant
15:59 - all right that actually declares a
16:00 - constant we have to remove this function
16:02 - we can't update this value at all solid
16:04 - t won't let us do that so we could just
16:06 - do that
16:07 - i'll deploy this again and we can still
16:10 - see our values here as my value
16:12 - so yeah that's how you would add a
16:14 - constant to your state variables
16:16 - or make your state variables constant
16:19 - now let's look at some other data types
16:20 - and solidity let's just change this name
16:23 - we'll call this like string value
16:27 - all right let's just deploy that we can
16:29 - see this instance here again
16:31 - string value all right it's my value
16:34 - now let's explore some other data types
16:36 - we can say
16:37 - uh boolean type we'll say bool public
16:41 - is equal to i'm going to remove this
16:43 - constant for now
16:44 - um
16:46 - my
16:47 - bool equals true
16:49 - all right
16:50 - so this just accepts true or false we
16:52 - can deploy that
16:54 - see this
16:55 - oh my bull right it's true string value
16:58 - is my value
17:00 - say uh
17:01 - or my string
17:03 - just save that just for fun
17:05 - and we can also see that you know we
17:07 - support data types like um
17:10 - integers so integers can be signed or
17:12 - unsigned so what does that mean uh well
17:15 - we can do a default
17:17 - int which would be
17:19 - public my int equals one
17:22 - right so we can deploy this
17:25 - and see
17:27 - let's actually just clear this out
17:30 - sorry deploy this and see my int is
17:33 - equal to one so the difference between
17:35 - uh an int and a uint or an unsigned
17:39 - integer
17:43 - uh is that an integer can be signed in a
17:47 - or sorry uh yeah an integer can be
17:49 - signed and a unit can be unsigned so
17:51 - what does that mean well
17:53 - basically an int can be negative so i
17:55 - can do minus one
17:57 - all right
17:58 - and deploy that that's a signed integer
18:00 - it has a sign in front of it it can be
18:02 - positive or negative and a uint can't
18:04 - so we'll deploy that
18:06 - uh clear these out
18:08 - and see my uint
18:10 - all right and my int all right yeah so
18:13 - negative one can work for an int and uh
18:15 - they can't do negatives on unsigned
18:17 - integers
18:18 - you can also specify the amount of bytes
18:21 - or bits
18:22 - um in an integer so we can say you went
18:26 - eight
18:28 - black equals my unit eight
18:33 - sorry
18:35 - equals like
18:36 - all right
18:37 - oops
18:39 - let's do a small number
18:42 - and we can see my unit eight
18:45 - all right
18:46 - and so if we do you ant here it defaults
18:48 - to 256 i believe
18:51 - uh unit 256 public my unit okay
18:55 - so that gives you a basic overview of
18:57 - all those basic data types um i don't
18:58 - want to bore you with all the pedantic
19:00 - details of this kind of stuff but this
19:02 - is helpful to know if you like the next
19:03 - thing i want to show you is an enum so
19:06 - what is an enum and how do you use it
19:09 - well an enum is basically an enumerated
19:12 - list that's going to allow us to keep
19:14 - track of um you know a set list of
19:17 - things in our contract so i'll show you
19:18 - what that means so basically i can
19:20 - declare an editing like this i'll say
19:22 - enum
19:23 - state
19:25 - and i'll give it some options here i'll
19:27 - say waiting
19:28 - ready
19:29 - active all right
19:31 - and this is going to allow us to keep a
19:32 - list of these three states inside the
19:35 - smart contract we'll be able to
19:36 - reference this to see what the current
19:38 - state is
19:39 - and it'll give us some options whenever
19:41 - we're updating the state and like
19:42 - checking against this so
19:44 - i'll show you an example we'll actually
19:45 - store this like this we'll declare state
19:48 - public
19:50 - state this right
19:52 - so basically this is going to give us um
19:55 - a public uh we're gonna be able to
19:58 - access this publicly with that uh getter
20:01 - so inside of here i'll do a constructor
20:03 - i'll say
20:04 - constructor
20:06 - i'll say public
20:09 - say state
20:11 - equals state
20:13 - active
20:15 - all right so i'll go ahead and set the
20:16 - default state to
20:19 - active right
20:21 - so actually let's do this let's do
20:23 - waiting
20:24 - and then i'll say i'll create a function
20:26 - to activate it
20:28 - and i'll say activate
20:32 - and say public
20:34 - state equals state dot
20:38 - active
20:39 - so we can actually choose sorry
20:42 - we can choose this value out of this
20:44 - enum list and update the state to that
20:46 - value all right so whenever we call this
20:48 - function it'll change the state to the
20:49 - active state
20:51 - and let's get a function that checks to
20:53 - see if the state is active we'll say
20:55 - function
20:56 - is
20:57 - active
20:59 - and we'll say public view returns
21:03 - boom
21:06 - all right we'll say return state equal
21:09 - to
21:09 - state dot active so that's we'll do
21:12 - inside here we'll just check to see if
21:13 - the state currently is active all right
21:15 - so let's see if you have any errors
21:17 - looks good
21:18 - um i will compile this
21:20 - all right we'll run
21:22 - deploy
21:24 - and all right let's check the state so
21:25 - is the state active all right no it's
21:28 - false
21:29 - so that's that's true it's not active um
21:32 - it's in waiting so let's actually check
21:33 - the state so state is zero so zero
21:36 - corresponds to the first uh item in this
21:39 - list zero which is waiting
21:41 - and i'll click activate
21:43 - all right
21:44 - so actually called the activate function
21:46 - um which you know updates the state to
21:49 - active let's see if it's active yep it's
21:51 - true and let's check the state so now
21:54 - the state is 2 which is 0 1 2. all right
21:58 - so that's an idea of how you use enums
22:01 - um let's look at the next concept that i
22:03 - wanna show you
22:05 - the next comment i wanna show you is
22:07 - uh let's do let's do structs so structs
22:10 - are basically a way for you to define
22:12 - your own
22:13 - data structures inside solidity we'll do
22:15 - that like this
22:17 - we'll say
22:18 - uh we'll create a struct right here
22:20 - we'll call it person it's a struct
22:23 - person
22:24 - and we'll give it some
22:27 - look at some some characteristics we'll
22:29 - say string
22:31 - uh first name
22:33 - and string
22:35 - last name
22:36 - okay
22:38 - so basically what's going on here is
22:40 - this allows us to basically model you
22:42 - know our own sort of arbitrary data i'm
22:44 - just going to model a person with this
22:45 - struct that's going to have a few
22:46 - attributes it's going to have a first
22:48 - name attribute that's going to be a
22:49 - string and a last name attribute that's
22:51 - also going to be a string and we can put
22:53 - these structs inside of like arrays and
22:56 - mappings and things like that i'll show
22:57 - you that here in a minute inside this
22:58 - video but for now just know that we
23:00 - declare that we've defined this new data
23:03 - type person inside the smart contract
23:06 - with a struct that's going to have a
23:07 - first name and a last name
23:10 - okay so let's actually
23:12 - uh
23:14 - create a function that allows us to
23:16 - instantiate a new person create a new
23:18 - one and we'll actually keep track of a
23:21 - bunch of these person structs inside of
23:24 - a people array all right
23:27 - so let's do that like this
23:29 - let's say let's let's keep track of
23:32 - a bunch of different persons so we can
23:34 - create new ones we'll say
23:36 - person
23:37 - this will be an array public people
23:40 - all right so let's see what's happening
23:42 - here
23:42 - people's estate variable here and it's
23:44 - in a it's public so we can read it
23:46 - outside the smart contract
23:48 - and it's
23:50 - an array here
23:52 - of these data type person right so we
23:55 - declared the data type first which is
23:57 - person which we defined here with struct
23:59 - it's an array that you know contains
24:01 - these person structs it's public and
24:04 - it's stored with the people
24:06 - state variable
24:07 - so we can add people to this array or
24:11 - person structs to this array like this
24:13 - so create a function say function add
24:15 - person
24:16 - it's a string uh this is a solidity five
24:19 - updates uh memory
24:22 - or 0.5 sorry first name
24:26 - and then we'll say string
24:28 - memory
24:31 - last name we'll say public
24:35 - and we'll do this inside here say people
24:39 - push
24:40 - so push is you know a function we can
24:42 - call an erase to add a new item at the
24:45 - the
24:46 - to the array
24:48 - and we'll push a new instance of this
24:51 - person struct so we can
24:53 - um
24:55 - create a new instance like this we just
24:57 - call person right
24:59 - and we pass in these attributes so say
25:01 - first name
25:04 - oops sorry
25:05 - name and last name
25:08 - all right
25:11 - and
25:12 - what we can do here
25:15 - is well yeah we've added it let's go
25:17 - ahead and do it
25:18 - so let's just let's just compile this a
25:20 - minute
25:21 - um
25:22 - i'll deploy this
25:24 - all right
25:25 - so let's see what happens so people
25:28 - um
25:30 - it's going to add the person
25:33 - add person
25:35 - oops sorry let's do the first name so
25:37 - first name will be dap last name will be
25:39 - university
25:42 - add person
25:43 - okay
25:44 - awesome so that didn't give us any
25:45 - errors now how do we read this person
25:47 - out of here that's a good question
25:50 - so we added this person to an array
25:53 - um but this function you know whatever
25:55 - we call this person
25:57 - or sorry this people function
25:59 - it's not going to return the entire
26:00 - array of people
26:02 - that's because this is
26:04 - uh you know we don't know the size of
26:06 - this array is in solidity
26:08 - and we have an array of unknown size
26:10 - it's not going to return the entire
26:12 - array so basically we need to reference
26:15 - uh the person by id so whenever we get
26:17 - this function it expects an argument
26:19 - which is going to be the index of the
26:21 - person inside this
26:23 - array so for example we know we added
26:25 - one person in there so we will add
26:27 - people we'll say zero all right there
26:29 - you go
26:30 - dap university
26:32 - so what happens if we reference you know
26:35 - a person that doesn't exist say a person
26:37 - you know one
26:39 - people
26:40 - it's gonna give us an error it's an
26:42 - invalid opcode error that's because
26:44 - there's no one in there at position one
26:47 - so how do we how do we like you know how
26:50 - do we fix that problem let's keep track
26:51 - of that like this
26:52 - so basically we would keep an internal
26:54 - count of the people we'd say something
26:56 - like this unit 256
26:58 - people count
27:00 - okay
27:01 - and that's going to basically have give
27:02 - us a counter cash that will increment
27:05 - every time a person's added so we can
27:07 - say something like
27:08 - um
27:10 - people count
27:12 - plus
27:13 - equals one
27:15 - all right
27:17 - and we do that after i guess
27:21 - all right save that deploy
27:24 - and now we can uh actually make this
27:26 - public
27:29 - oops sorry as before
27:34 - let's try it again
27:37 - so now we can add the person dap
27:40 - university
27:45 - add person
27:46 - and we can see uh people count is one so
27:50 - we would do one minus that
27:52 - people
27:53 - all right dap university
27:55 - we do one minus that because it's a zero
27:56 - based index
27:58 - which means the first item you know is
28:00 - an index zero and the second one's index
28:02 - one etc etc the next thing i want to
28:04 - show you is how to do a similar concept
28:07 - here but model it a little differently
28:09 - so instead of using an array we're
28:11 - actually gonna use a mapping
28:12 - so what is a mapping
28:14 - a mapping is basically like an
28:16 - associative array so instead of having
28:19 - you know just an array
28:20 - um
28:21 - and we know that each index of the item
28:23 - in the array we can actually associate
28:25 - it to a value so that's that's like a
28:27 - like a hash table or a hash map or a
28:29 - hash
28:30 - and other programming languages that you
28:32 - might be familiar with or basically you
28:34 - can reference things by you know a key
28:36 - value it's key key value pair
28:39 - so instead of
28:40 - having people like this instead of being
28:43 - an array
28:44 - um
28:45 - i'm going to change it down here
28:49 - i'm going to say
28:50 - this is going to be mapping
28:53 - mapping
28:55 - uint
28:57 - person
28:58 - okay
29:00 - so uint is going to be
29:02 - the key and the person is going to be a
29:04 - value so this mapping is like i said an
29:05 - associative array that's going to take a
29:07 - key value pair the key is going to be an
29:09 - unsigned integer we'll treat this like
29:11 - an id so it'd be kind of like our
29:12 - database lookup where we have an id and
29:15 - then a record so this is going to return
29:17 - kind of like a record like a person
29:19 - record or a person's struct in this case
29:22 - it'll be public and it'll be people
29:24 - and it is kind of a fair comparison to
29:26 - compare this to uh a database because
29:28 - you know we're blockchain kind of is a
29:30 - big database and these structs are you
29:32 - know getting stored in storage on the
29:34 - blockchain with this mapping
29:36 - all right so person string first name
29:38 - last name and we'll do add person so
29:41 - when we need to modify this function
29:42 - we'll still take the first name we'll
29:43 - still look at the last name but we're
29:44 - going to put this in the mapping instead
29:47 - of the array
29:48 - so i'm going to move this people count
29:50 - back up here we're going to want to keep
29:51 - track of this
29:52 - just like we did earlier so we know how
29:54 - many people are in this mapping but
29:56 - we'll add it to the mapping like this
29:58 - we'll say people
30:01 - um
30:03 - people count
30:04 - this will be our id so if it starts at
30:06 - zero which it will do this
30:10 - all right people count plus equals one
30:14 - that'll be the new id of the person
30:15 - that's going to go in here so this will
30:16 - be person number one the first time we
30:18 - add this
30:19 - we'll say this is going to be a new
30:21 - person
30:22 - it'll be uh
30:24 - we'll give it a we'll give this an id
30:27 - we'll say uh
30:29 - unt
30:32 - id
30:33 - okay
30:34 - people count
30:37 - and then we'll say first name
30:41 - and then last name
30:45 - all right and we'll take this out
30:48 - all right let's see if that worked clear
30:50 - this out
30:52 - um
30:53 - deploy the contract
30:57 - so we'll do first name is dap
31:02 - university
31:05 - the ad person
31:07 - okay so see people count is one now and
31:10 - we'll go to people this time it won't be
31:12 - uh based on the array index it'll
31:14 - actually be on the id so we can actually
31:16 - reference person one all right we'll do
31:19 - people
31:20 - one
31:21 - there we go dappy diversity
31:24 - so let me explain a couple more things
31:25 - about structs while we're here um you
31:28 - know we need to keep track of this
31:29 - people count because there's no way to
31:31 - know the size this mapping and solidity
31:33 - uh basically any key that doesn't have a
31:36 - value set for it's going to turn a
31:37 - default value which is going to be like
31:39 - an empty struct here
31:41 - so if i do like you know
31:43 - person
31:45 - no 10 or like 99999
31:48 - to people it's usually going to return
31:49 - default values so what are the default
31:51 - values for the struct person id for uint
31:55 - is going to be 0 and then these blank
31:57 - strings for first name and last name so
31:59 - that's why we need to have a person
32:00 - count so if you were going to use this
32:01 - like as a data storage um and you wanted
32:04 - to like show all the people or all the
32:06 - persons and your in your people
32:08 - mapping in your app or something like
32:10 - that reading for the smart contract you
32:11 - want to know
32:13 - how many are actually in there and you
32:14 - want to do that with a counter cache
32:16 - um so that way you know if you wanted to
32:19 - basically like
32:20 - the same thing with with those variable
32:22 - size arrays like if you wanted to get
32:24 - all the items you need to first make a
32:26 - call to find out how many there are
32:28 - that's what you use the counter cache
32:29 - for and then you basically create a loop
32:32 - to read out each one
32:34 - one by one
32:36 - so yeah it's it can be kind of a pain
32:38 - but uh that's sort of the state of
32:40 - things and what you have to do
32:45 - i'm going to go ahead and pick up where
32:46 - we left off in the last video i'm going
32:48 - to use this you know my contract that we
32:49 - built where we added a person a person
32:52 - struck to this mapping of people
32:55 - if you haven't seen that last video go
32:56 - ahead and check that out it's not
32:57 - necessary but you can probably follow
32:59 - along with this video if you want to
33:01 - what i'm going to do now is
33:03 - show you a little more about these
33:05 - modifiers like public
33:07 - and things like that i think we talked
33:08 - about that in the first video but i'm
33:10 - gonna go just a little further so what i
33:12 - can do is you know show you another
33:13 - modifier which is basically like
33:16 - internal um
33:17 - so that's different from public you know
33:19 - public is a function that can be called
33:21 - uh you know the public interface at the
33:23 - smart contract you can see you know the
33:25 - public functions listed here on the side
33:27 - so go ahead and create a private
33:28 - function or an internal function excuse
33:30 - me it'll say function
33:32 - uh we're just gonna take this people
33:33 - count and wrap it in its own function to
33:35 - show you how that works we'll say uh
33:38 - increment
33:40 - count
33:41 - we'll just make this a function and we
33:43 - can call it uh internal
33:45 - that's a different modifier
33:46 - we'll just take this people account
33:48 - we'll paste it inside of here
33:50 - all right and we'll just say increment
33:52 - count
33:53 - call that function
33:55 - and we'll run it
33:59 - see the smart contract we'll add the
34:00 - person we'll say dap oops
34:03 - dap
34:05 - university
34:07 - and i'll click add person
34:10 - and there we go it incremented the
34:11 - account
34:12 - you can see the people count has been
34:14 - changed you can say joe
34:18 - blow and the accounts changed
34:21 - so that's a way that you can you know
34:23 - use other functions that are going to be
34:24 - internal and we can see this increment
34:26 - count function isn't uh added to this
34:28 - list over here it's not exposed to you
34:31 - know things outside of the smart
34:32 - contract external callers can't use it
34:35 - so that's an example of you know other
34:37 - you know types of visibility of
34:39 - functions and solidity let's talk about
34:41 - function modifiers so we can add you
34:44 - know more you know words and terms to
34:47 - the end of this function to change how
34:49 - it behaves and i'll show you an example
34:52 - so we're going to create our own custom
34:54 - modifier actually inside of this smart
34:56 - contract so that only certain people can
34:59 - call this add person function all right
35:03 - so what i'm going to do is basically
35:05 - you know make this smart contract
35:08 - have an owner or like an admin
35:10 - and we're going to say that only the
35:12 - owner can call this ad person function
35:15 - and any other account connected to the
35:17 - network you know whenever they try to
35:20 - you know add a person they won't be able
35:21 - to
35:22 - and that'll show you how we can add an
35:24 - extra modifier to this function to make
35:26 - that happen basically we'll just add a
35:27 - modifier to the only the owner of this
35:29 - smart contract can do that
35:32 - so first we need to well actually
35:34 - that'll just look like this we'll say
35:36 - only
35:37 - owner
35:38 - that's what the modifier will look like
35:40 - now this only owner modifier doesn't
35:42 - exist yet so let's go ahead and create
35:43 - it
35:46 - all right so
35:47 - we'll do that like this first we need to
35:49 - keep track of it owner we'll say the
35:51 - owner is
35:53 - you know address
35:55 - i'm not sure if we talked about this in
35:57 - the data types uh video but you know an
35:59 - address is a data type inside of
36:01 - solidity you know like an address that's
36:03 - on the network an account
36:05 - so this will be the address we're just
36:06 - going to declare it here we're not going
36:07 - to set it just yet
36:09 - we can set it like this we can do it
36:11 - inside the constructor well actually
36:13 - nothing that just yet um so that would
36:15 - be the owner
36:17 - we basically just create a modifier like
36:18 - this we say modifier
36:21 - see only owner
36:24 - looks like a function and what we'll do
36:27 - inside of here is write the logic that
36:29 - makes sure that you know whoever's you
36:32 - know calling the smart contract is the
36:34 - owner so that's what we're defining here
36:35 - only owner and only owner
36:38 - so how do we do that how do we say
36:40 - the person who's calling this function
36:42 - is the owner of this smart contract well
36:44 - we're going to compare it to this owner
36:45 - right here but how do we know who's
36:47 - calling the function
36:48 - well solidity has a global keyword
36:51 - called msg which basically
36:54 - stands for the function metadata that's
36:56 - passed in
36:58 - we're not actually going to pass in any
36:59 - metadata here it's going to be implied
37:02 - so basically
37:03 - we have access to msu.sender
37:06 - and this is basically a special
37:08 - uh you know thing inside of solidity
37:10 - that tells us the account you know this
37:13 - address who called the function
37:16 - and basically
37:18 - we can just say you know is this person
37:20 - the owner we can just you know compare
37:23 - equality of the person who's calling the
37:25 - function with this owner that we're
37:26 - going to store here in a second all
37:28 - right
37:29 - and if they're not we actually want to
37:31 - throw an error
37:33 - right
37:34 - so this is going to show you another
37:36 - concept in solidity about error handling
37:39 - so we can throw an error in solidity
37:42 - like you know i think earlier we had
37:43 - some errors happen like here's an error
37:45 - we actually want to trigger an error if
37:47 - this person um
37:49 - you know it's not the owner we want to
37:51 - we want to revert the transaction and we
37:52 - do that like this we say require
37:56 - um sorry
37:59 - msg.sender is equal to the owner so
38:01 - basically anything inside of this
38:03 - require um
38:05 - if if it evaluates to true
38:08 - then this passes if it evaluates to
38:10 - false then this will throw an error we
38:13 - basically are saying require that
38:15 - whatever you put inside of here is true
38:17 - all right
38:18 - and then after this we can basically
38:20 - just do this
38:22 - all right
38:23 - and now our um
38:25 - only on only one modifier is complete
38:28 - so basically now we have this modifier
38:31 - that's you know defined here and we add
38:33 - it here and basically say if the person
38:35 - who is you know calling this function is
38:37 - the owner uh then you know we can
38:39 - actually run this function and if
38:41 - they're not we're going to you know
38:42 - create a failure we're going to revert
38:44 - the transaction and also whoever's doing
38:47 - this you know whatever
38:49 - like this code runs they won't pay this
38:51 - gas fee
38:53 - all right so now we need to set the
38:55 - owner
38:56 - and i'm just going to do that inside of
38:57 - constructor we'll use msg.sender as well
39:00 - say function constructor
39:04 - and we'll just open this curly braces
39:07 - and we'll say owner equals to msg sri
39:11 - msg.sender
39:13 - sorry i don't need the function keyword
39:14 - here
39:18 - and we also need to make this public
39:20 - all right
39:22 - so i'll save that so whenever you deploy
39:23 - the smart contract like you know this
39:25 - constructor gets run and the msg.send is
39:28 - actually the account that deploys the
39:29 - smart contract
39:30 - and they're going to get set to this
39:32 - owner state variable
39:33 - right it's address owner
39:35 - and basically
39:36 - that same you know address is the only
39:38 - person that's going to be able to call
39:40 - this add person function all right
39:43 - and if they um
39:46 - you know this code will run and we'll
39:48 - add a person
39:49 - and if we switch accounts to some other
39:51 - account over here then it won't work so
39:53 - let's just try
39:54 - that deploy this
39:58 - we will uh you know deploy with this
40:01 - account so let's change to that account
40:03 - we'll add the person actually
40:06 - i don't know if it deployed that account
40:07 - or not let's try it again
40:08 - so make sure on the first account we'll
40:10 - deploy
40:11 - all right
40:12 - we'll add a person we'll say dap
40:14 - university
40:19 - add the person
40:20 - all right let's see here all right it
40:21 - worked
40:23 - people count is one
40:25 - now we'll say you know joe
40:27 - blow and we'll change accounts to this
40:31 - one
40:32 - and we'll try to call it again add
40:34 - person
40:34 - and we see it as failed and the people
40:37 - count has not changed at all
40:39 - so it worked
40:40 - so we've kept track of the owner and we
40:42 - say only the owner can do it now while
40:44 - we're here i'm going to show you a
40:45 - little code formatting that i like to do
40:47 - sometimes this is getting kind of long
40:49 - and sometimes you know if you're like me
40:50 - and you have a text editor with a whole
40:52 - bunch of panes open
40:54 - i like to keep my columns kind of short
40:56 - sometimes especially with solidity and
40:58 - it kind of makes it easier to maintain
40:59 - these functions when the arguments are
41:01 - getting long and using git and things
41:02 - like that sometimes i will just break
41:04 - these up like this
41:08 - all right and then i'll actually put the
41:09 - modifiers if you have a bunch of
41:10 - modifiers sometimes this makes it easier
41:12 - to read
41:13 - and also when i'm writing my own
41:15 - solidity source code i only use two
41:17 - spaces i don't use four uh but yeah
41:20 - that's sometimes how i break these
41:22 - functions up so i can see the function
41:23 - name and then the arguments
41:25 - um then i can see the modifiers and then
41:27 - i can actually see the code that gets
41:29 - executed inside here and it can make
41:31 - your smart contract kind of long but
41:33 - it can be
41:35 - sometimes this will catch you
41:37 - if you have too many you know if you
41:38 - have three visibility and modifiers on
41:40 - here sometimes it can be kind of tricky
41:42 - so i like doing this
41:43 - all right so next i'm going to show you
41:46 - how to work with time and solidity okay
41:49 - so what we can do is basically compare
41:52 - time and solidity and instead of um this
41:56 - saying only owner can do this let's say
41:59 - you can only call this function if a
42:01 - certain time has passed so let's pretend
42:03 - like you know this is uh a contract that
42:07 - is only open at a certain time so we'll
42:09 - say instead of only owner we'll say only
42:11 - while open only while open
42:15 - all right and this opening uh
42:18 - state is going to be determined by a
42:20 - time so once we've passed a certain time
42:22 - in history in the future
42:25 - then we'll let you call this function if
42:27 - it's before that we won't do it
42:29 - so that's really useful if like you're
42:30 - building a crowd sale or something like
42:32 - that that has an opening time like an
42:33 - ico smart contract and you say hey we
42:36 - can only let you contribute ether like
42:38 - after you know the first of the month
42:39 - well you just figure out what time that
42:41 - is and say hey you know if you make a
42:43 - contribution before then we'll throw an
42:44 - error
42:46 - so i'll say only
42:48 - while open all right and instead of
42:51 - requiring that uh msg
42:54 - that sender is the owner right we're
42:56 - actually going to just take this out
42:59 - we're gonna say
43:02 - uh
43:03 - we're gonna make sure that the current
43:05 - time
43:06 - is
43:08 - uh in the future beyond a certain like
43:10 - uh opening time so let's do
43:12 - uint 256 opening time
43:17 - all right
43:20 - so how do we do this
43:21 - well we need to set this opening time
43:24 - somehow
43:25 - all right
43:26 - so the opening time is actually
43:28 - expressed in seconds and
43:31 - you know inside solidity or these
43:33 - time stamps are expressed in seconds
43:34 - inside solidity and you know seconds of
43:37 - what well it's epic time which if you're
43:39 - not familiar with that it's um
43:42 - a concept in computer science that's
43:44 - like the epic is a is a specific time i
43:47 - can't remember the actual date it's like
43:49 - a date in the 60s or 70s or something
43:51 - like that um and basically we just add
43:55 - seconds since that point in time in
43:57 - history so this is the current epic time
43:59 - stamp is this many seconds
44:01 - uh since the epic time and i guess
44:03 - there's probably a link here where you
44:04 - can read more about that yeah the unix
44:06 - epic clock um yeah i'm sure you can get
44:09 - on wikipedia and figure all that out but
44:12 - basically uh this is the current epic
44:14 - time and it's changing so we use these
44:15 - seconds values so this is like the
44:17 - current you know epic timestamp we'll
44:19 - say this
44:21 - all right so this is how we could set
44:23 - this and it's you know uh 256 is going
44:25 - to store this big number of seconds
44:27 - since that time stamp and that's going
44:29 - to be our opening time and so how do we
44:31 - compare that to now so how do you get
44:33 - now in solidity well there's no perfect
44:35 - way to do it but the best way is to get
44:38 - the current blocks timestamp all right
44:42 - so how do we do that well just like msg
44:45 - there's a global
44:46 - variable in solidity called block
44:50 - dot and we can say block dot timestamp
44:54 - all right and we can say is the block
44:56 - dot
44:57 - timestamp is it greater than or equal to
45:01 - the opening
45:02 - time all right
45:06 - so basically
45:07 - if
45:08 - it's after the opening time we're gonna
45:10 - let you call this function
45:12 - and if it's not
45:13 - um
45:14 - then we won't
45:16 - all right so let's give this a try i'm
45:18 - going to update this time stamp let's
45:20 - refresh it let's see this is the current
45:21 - one
45:23 - i'll paste this in here
45:24 - so 15 i'm going to add 60 seconds so a
45:27 - minute
45:29 - um
45:30 - so i'm going to deploy this and it will
45:32 - be
45:33 - uh
45:33 - it shouldn't work right now so we can
45:35 - try to call add person
45:37 - i'll try to add dap
45:40 - university
45:43 - okay we'll add person and we'll see that
45:45 - it reverted okay and now we can check
45:47 - the time stamp we're not there yet so
45:49 - i'll just pause the video wait for this
45:50 - to pass 75 i think that's the actual
45:52 - time yeah 75
45:54 - all right
45:55 - i'll pause the video
45:57 - pause the video giving us plenty of time
45:59 - we're past the timestamp you can see
46:00 - it's 793 and we're at uh 775.
46:04 - so let's deploy it again oh actually
46:05 - let's not deploy it again let's just do
46:07 - joe
46:09 - blow add a person
46:11 - and it worked
46:12 - so that's how you can use um time and
46:15 - solidity you can get the current time
46:17 - and set of time value with seconds
46:19 - and so that's what i'm going to call
46:20 - today guys i hope you all like this
46:22 - video let me know how you're enjoying
46:24 - these solidity videos let me know if i
46:26 - missed anything or if there's something
46:27 - you want to learn or if you're just not
46:28 - liking them that's okay too just let me
46:30 - know down in the comment section below
46:35 - let's use the same my contract example
46:37 - that we've been you know using
46:38 - throughout this tutorial series and you
46:41 - don't necessarily have to have been
46:42 - following along with every video in this
46:43 - series you can kind of just pick back up
46:45 - with this one probably
46:47 - so yeah let's go ahead and jump in and
46:48 - start programming
46:50 - what i'm going to show you first is how
46:52 - to
46:53 - write a function that accepts ether so
46:56 - basically like how can we send ether in
46:59 - when we call a function and do stuff
47:01 - with it so i'll show you how to do that
47:03 - first we'll create a function
47:05 - called buy token
47:08 - say by
47:09 - token
47:10 - and this function is going to kind of
47:12 - emulate what happens in an ico uh like a
47:14 - crowd sale or a pre-sale or something
47:16 - like that on ethereum where you're
47:18 - buying erc20 tokens i'm not gonna like
47:20 - code out an entire erc20 token smart
47:23 - contract right here or you know cut out
47:25 - a crowd sales smart contract i've got
47:27 - several other tutorials that show you
47:28 - how to you know co-drum cryptocurrency
47:30 - on ethereum with you know build an erc20
47:32 - token step by step and a real world
47:34 - crowd sale things like that so you can
47:35 - check out those other videos if you're
47:37 - interested
47:38 - but uh what we're going to do is
47:40 - basically create this
47:41 - uh function called buy token it's going
47:43 - to simulate what happens it's not going
47:45 - to do everything but at least give you
47:47 - an idea of how that works so we'll call
47:49 - this
47:51 - you know buy token
47:52 - and inside here what we basically want
47:54 - to do
47:55 - is buy a token
47:58 - and we also want to send ether to
48:02 - the wallet
48:04 - so what's going to happen is someone's
48:06 - going to call this function and they're
48:08 - going to send ether when they call this
48:10 - function and when they do
48:12 - we're going to issue them a token and
48:14 - then the wallet is actually going to
48:15 - receive the ether that they sent in when
48:17 - they call this function so i'll show you
48:19 - how to do that first i'm going to create
48:22 - um a way to track the tokens and
48:24 - basically all this is going to do
48:27 - is
48:28 - you know track this person's balance so
48:30 - we'll use a mapping for that we'll say
48:32 - mapping and again uh if you didn't check
48:35 - the other videos the mapping is like an
48:37 - associative array where we have key
48:38 - value pairs so we'll say address
48:41 - will be the key and the value will be an
48:43 - unsigned integer
48:47 - all right and this will be public
48:49 - all right this will give us a function
48:51 - for free that'll allow us to read this
48:52 - value and we'll just call this uh
48:54 - balances
48:56 - so
48:57 - what we'll do and when we buy a token
48:59 - we'll basically just say
49:00 - balances
49:02 - of whoever called this function so if
49:04 - you'll remember from the last videos in
49:06 - the series
49:07 - we we get that value with msg.sender
49:10 - this is the account that's calling this
49:12 - function
49:13 - and we will just increment this count by
49:16 - one
49:17 - now this is not really fancy um you know
49:20 - we're basically just saying whenever you
49:21 - call this function you're going to buy
49:22 - one token we're not using a rate of
49:25 - redemption or anything like that this is
49:26 - just to kind of show you how this works
49:28 - this is not very sophisticated um but
49:31 - basically that'll just
49:33 - increment your balance you know inside
49:35 - this token uh contract by one
49:38 - whenever we do that we want to transfer
49:41 - funds that are sent in with this smart
49:43 - contract to a wallet all right so how do
49:47 - we do that well first we keep track of a
49:49 - wallet
49:50 - uh we'll just declare a state variable
49:51 - here we'll say address wallet
49:55 - and we want to send funds to this wallet
49:58 - okay
50:00 - and we do that like this and i'm
50:01 - actually going to show you something in
50:02 - a minute that's going to be a solidity
50:04 - 0.5 update so if you've been using
50:06 - previous version solidity we have to
50:08 - make a change here i'll go back to that
50:09 - in a minute
50:10 - but anyways let's uh transfer funds to
50:12 - this wallet we'll do that like this so
50:14 - we'll say wallet
50:17 - uh transfer
50:19 - and we want to transfer in the funds
50:21 - that are sent by this function uh sorry
50:24 - transfer the funds that are sent in by
50:25 - this function to this wallet so how do
50:27 - we do that
50:28 - well how do we actually know what the
50:31 - the value
50:32 - is that's getting sent in well just like
50:35 - msg.sender
50:37 - msg has another property called value so
50:40 - i can say msg.value
50:44 - all right
50:45 - and that's going to tell us exactly how
50:47 - much ether or whey is sent in by the
50:51 - person who's sent this function
50:54 - so i'll show you how that works
50:56 - so that's going to do is
50:58 - take the ether that's sent in with this
51:00 - you know function call and transfer it
51:02 - to this wallet right here
51:04 - now there's this is not complete
51:07 - there's a lot of things that actually
51:08 - need to change in order for this to work
51:10 - properly you can see these x's over here
51:12 - uh these you know compiler errors
51:15 - so the first thing we need to do is uh
51:17 - set a wallet let's do that inside a
51:19 - constructor we'll do that whenever we
51:20 - deploy the smart contract so we'll say
51:24 - constructor
51:27 - we'll say address
51:31 - wallet
51:32 - we'll say public
51:35 - and we'll say wallet is just equal to
51:37 - the wall we pass in
51:39 - all right so we're still getting errors
51:41 - now let's see what they are
51:43 - the first thing we need to do in order
51:45 - to make uh this function accept ether
51:49 - well actually first we need to make it
51:50 - public so that people can call it let me
51:52 - say public
51:54 - all right
51:55 - so now people will actually be able to
51:56 - call this function and send ethernet
51:58 - stuff like that
52:00 - and in order for people to in order for
52:02 - this to accept ether we have to add
52:04 - another modifier here which is payable
52:08 - all right and if we don't do that this
52:11 - won't allow us to send ethereum with the
52:13 - transaction
52:14 - so this is how we declare that this
52:15 - function will accept ether okay
52:18 - now here's a new solidity update it
52:20 - requires explicitness
52:22 - whenever you're
52:24 - declaring an address that can accept
52:26 - ether inside of a smart contract
52:28 - and we do that like this we say address
52:31 - payable
52:33 - wallet all right
52:36 - and then likewise
52:39 - we say
52:40 - address payable
52:43 - wallet whenever we pass this function
52:45 - into the constructor
52:47 - all right
52:49 - so
52:50 - that should be a working implementation
52:53 - if we want to see
52:55 - so let's deploy the smart contract and
52:57 - try it out
52:59 - i will uh
53:00 - you know take one of these addresses and
53:02 - we'll take the second address here in
53:04 - the list and we'll use that as the
53:06 - wallet we'll actually check its balance
53:07 - here in a second
53:09 - um so we'll deploy the smart contract we
53:10 - need to pass in a wallet whenever we
53:12 - deploy
53:12 - just paste this in click deploy
53:15 - all right looks like it was successful
53:17 - let's try to do the buy token function
53:19 - okay it's just going to buy one token
53:21 - for us
53:22 - so make sure we've got the first account
53:23 - the list selected by token
53:26 - all right looks like it was successful
53:28 - let's check the balance
53:29 - of this
53:31 - oops actually pasted in the wrong
53:32 - address uh pasted in the second address
53:35 - so let's try the balance again all right
53:37 - it's one all right now all that did was
53:38 - actually uh transfer
53:41 - you know
53:42 - all that did was buy a token it didn't
53:43 - actually transfer ether
53:45 - to the wallet and that's what we want to
53:46 - show so in order to like send ether in
53:49 - and actually transfer funds to the
53:51 - wallet uh we do that like this we'd
53:53 - change this to ether
53:55 - i'm going to send one ether in with this
53:57 - transaction where we call the buy tokens
53:58 - function we'll do that from this account
54:01 - and we'll click uh
54:03 - buy token
54:05 - all right boom so let's check the
54:06 - balance again
54:07 - all right the balance is two
54:09 - now
54:11 - let's see what happened we can see that
54:12 - the ether value decreased here from you
54:14 - know 99.9 to 98.9 it actually
54:18 - took ether out of our wallet because we
54:20 - sent it in with the transaction and we
54:22 - can see that the second account in the
54:25 - list uh which i used as the wallet
54:27 - whenever we deployed has been credited
54:29 - with that ether so
54:32 - our smart contract worked
54:34 - it actually sent you know the
54:36 - uh value that we sent in with this to
54:39 - that account
54:41 - all right so the next thing i want to
54:42 - show you
54:43 - is
54:44 - how you can create basically a fallback
54:46 - function in solidity this is what it's
54:48 - called at least that's what i've seen it
54:50 - called i'm not sure what the official
54:51 - name is
54:52 - but basically it's going to be like a
54:54 - default function that you can um
54:57 - wrap this in so whenever you just send
55:00 - ether to the smart contract it executes
55:02 - a function you'll see that a lot like
55:03 - icos where you know they have an address
55:06 - posted and they say hey send ether to
55:08 - that smart contract and it'll actually
55:10 - buy the tokens for you
55:12 - now this is just a kind of pseudo code
55:14 - implementation again of like a a
55:17 - purchase
55:18 - function uh you know real ico function
55:21 - functionality would be much more complex
55:22 - than this but uh you get the idea
55:25 - so do this fallback function we'll do
55:27 - like this we'll just say function
55:30 - all right and we'll say external
55:33 - payable
55:35 - and we'll just wrap this with the buy
55:38 - token function
55:40 - all right
55:42 - so here's a new modifier i don't think
55:43 - we've used yet which is external
55:46 - so that's different from public because
55:47 - public can be called you know inside of
55:50 - our smart contract as well as outside
55:52 - but external can only be called outside
55:54 - so we don't want to like call this you
55:56 - know inside the smart contract somehow
55:59 - so now if we just compile this again and
56:02 - deploy
56:03 - uh i'm going to paste the
56:07 - wallet in here
56:09 - deploy we'll see you have a new function
56:11 - just called fallback
56:12 - um and we can
56:14 - basically just uh
56:17 - do that like this
56:19 - so we'll just
56:21 - send them on ether
56:23 - from account number one
56:25 - call the file back and it worked we can
56:27 - see our account balance went down this
56:29 - one up and the balance of
56:32 - first count should be one
56:35 - yep it's one
56:36 - so now i want to show you events inside
56:38 - of solidity so what do we use events for
56:41 - so events are a way for
56:43 - external consumers to kind of listen for
56:45 - things that happen on a smart contract
56:48 - so basically external consumers can
56:50 - subscribe to events on a smart contract
56:53 - and uh you know wait for something to
56:55 - happen so we'll do inside of this buy
56:58 - token uh function we'll actually trigger
57:00 - an event that lets you know anyone
57:02 - connected to the blockchain really to
57:04 - know
57:06 - that a token has been purchased from the
57:07 - smart contract if they were to listen
57:09 - for it
57:10 - so
57:11 - i'll create an event like this
57:14 - do it up here let's say event
57:17 - purchase
57:19 - and i'll just say uh
57:21 - i'll break this line right here
57:26 - oops
57:28 - i'll say address
57:30 - uh in oh yeah a buyer
57:34 - and i'll say uint 256 amount
57:38 - okay
57:40 - so that's how we declare an event just
57:42 - like that
57:44 - and inside of this function whenever the
57:46 - token is purchased we'll trigger it and
57:48 - we trigger the event like this
57:50 - we say emit
57:52 - purchase
57:54 - and we pass in the buyer we pass in the
57:56 - amount
57:57 - so the buyer in this case is msg.sender
57:59 - you know the account that's calling this
58:01 - function
58:02 - and the value in this case is just one
58:06 - semicolon
58:08 - all right so there you go
58:09 - now another thing you can do with these
58:11 - events um
58:12 - you can create an index like this
58:14 - indexed
58:16 - okay and that will allow you to you
58:18 - filter events that are only from certain
58:20 - buyers so basically like if you wanted
58:22 - to only listen to events from the smart
58:24 - contract
58:25 - that uh you know a certain person uh did
58:29 - a certain account or maybe even just you
58:32 - you could subscribe based on a specific
58:34 - address
58:36 - so i'll show you how that works
58:38 - all right
58:40 - let's compile this and run it
58:42 - i'm going to take the uh
58:44 - wallet paste it in here
58:47 - play
58:49 - all right
58:50 - now we'll call the buy tokens function
58:52 - um
58:53 - we'll send in one ether
58:58 - oops
59:01 - all right it worked
59:02 - now how we know the event worked
59:04 - so we can look inside of this
59:06 - transaction here see the log
59:10 - and we can see uh right here here's the
59:13 - log
59:14 - and inside this log we have some
59:15 - messages and this basically is is the
59:18 - event we can see uh the buyer listed
59:21 - here and the amount see the buyer was
59:23 - this address
59:25 - and here's the amount
59:26 - so what are events for really there's
59:29 - there's two kind of main use cases for
59:31 - events
59:32 - you know because um
59:34 - of the
59:35 - asynchronous nature of the blockchain
59:37 - you know if you're building an
59:38 - application that um
59:42 - uh you know if you're building an
59:43 - application that talks to the smart
59:45 - contract you know you might
59:48 - you you might call
59:50 - a function
59:51 - like by token like if you're writing a
59:54 - javascript application you might like
59:55 - call this function
59:57 - and then you know you your application
59:59 - would just know that you called this
60:01 - function but you might want to actually
60:02 - wait for this to finish and execute wait
60:04 - for this event to be
60:05 - emitted so you can basically wait for
60:08 - that and subscribe to this event um and
60:12 - filter for only ones you know that are
60:14 - applicable to you
60:16 - and whenever that happens you know you
60:18 - can you can wait for that to happen and
60:19 - then you know reload your application
60:21 - state whenever that event's been
60:22 - triggered so that's one popular use case
60:25 - another use case is you can get the
60:27 - entire event stream from a smart
60:29 - contract like this so you could
60:31 - basically see all of the purchase events
60:34 - because they're you know listed in these
60:35 - logs they're actually listed in the
60:37 - transactions
60:38 - uh you know that are contained in the
60:40 - blocks of the blockchain
60:42 - and that's a way to see all the
60:43 - purchases that have ever happened
60:45 - inside a smart contract like this
60:51 - i'll go ahead and use the smart contract
60:53 - that we were working on in the last
60:54 - video as the basis for this one um so in
60:57 - this video we're going to be talking
60:58 - about how to use multiple smart
61:00 - contracts in the solidity programming
61:01 - language um you know two different
61:03 - ethereum smart contracts one that will
61:05 - talk to the other
61:07 - and i'll also show you how to like write
61:09 - uh you know parent-child relationships
61:11 - with smart contracts we'll have uh
61:13 - what's about inheritance you know a a
61:16 - contract that inherits from another one
61:18 - so i'm going to go ahead and clear out
61:20 - some of this code
61:22 - from the last video to kind of get it
61:24 - where we want it to be
61:26 - the first thing i'll do is um
61:29 - let's see here we'll basically what
61:30 - we'll do is we'll go ahead with this
61:32 - scenario where we're still going to buy
61:34 - a token but instead of you know
61:37 - keeping track of the balance inside this
61:39 - smart contract
61:40 - we'll actually move it to a token
61:42 - contract
61:43 - uh to you know kind of separate concerns
61:46 - a little bit
61:47 - so actually tell you what let's go ahead
61:48 - and create the token smart contract like
61:50 - this and again this is going to be a
61:51 - really just basic uh you know it's kind
61:53 - of almost like pseudo code example it's
61:55 - not going to be a full erc20 token but
61:57 - this will just give you an idea of like
61:59 - what's going to happen when you know two
62:01 - smart contracts call one another at a
62:03 - very simple example so we'll say
62:04 - contract
62:06 - erc
62:07 - 20 token
62:10 - and again if you want to see more you
62:12 - know videos about erc20 tokens i've got
62:14 - plenty on my channel so i say string
62:16 - name so we're going to have a state
62:18 - variable that keeps track of the name
62:20 - here let's actually make this
62:22 - public
62:25 - and we'll do a mapping we'll just
62:27 - basically move this
62:28 - balances mapping up here
62:31 - take it out of this
62:32 - contract and we're going to
62:36 - um extract this balances
62:39 - you know increment here and put it into
62:41 - its own function
62:43 - so we'll just call this function
62:45 - mint say function uh
62:50 - mint
62:51 - i'll make this public
62:53 - and inside of here we're just going to
62:55 - do this we'll take this balances
62:58 - and increment it here
62:59 - just like that
63:01 - and also we can rewrite this just to say
63:03 - plus plus which will increment by one
63:06 - refactor that a little bit make it a
63:07 - little nicer a little cleaner
63:10 - all right
63:12 - and now
63:14 - you should be able to clean up this
63:15 - little bit take these comments out
63:20 - let's see here
63:22 - let's actually
63:23 - simplify this we'll take this purchase
63:25 - event out we don't need all this
63:27 - that was mostly to show you how events
63:28 - worked in the last video i just want to
63:30 - simplify the code a little bit so that
63:32 - it's easier to follow along with
63:35 - all right
63:37 - so inside of here
63:39 - we want to mint tokens
63:42 - inside of this contract so you want to
63:44 - call
63:45 - the erc20 token from this
63:48 - buy token function so how do we do that
63:51 - well
63:53 - you know we created this smart contract
63:55 - in the same file so because this is in
63:57 - the same file uh this contract knows
64:00 - that this contract is here
64:02 - before we compile it and deploy it
64:05 - so the source code you know
64:06 - this one will know about this one
64:10 - so we can basically uh be explicit
64:14 - and tell this contract that we want to
64:16 - mint tokens in this contract
64:19 - so in order to do that there's a couple
64:20 - things that we need
64:23 - we need to know the address of this
64:25 - contract once it's deployed
64:27 - because you know this will get deployed
64:29 - and this will get deployed and we'll
64:30 - have two separate addresses and then my
64:32 - contract needs to know about the erc20
64:34 - token contract where it is
64:36 - and then we'll basically just reference
64:38 - that smart contract with the address
64:43 - and we'll basically get an instance of
64:45 - it kind of
64:47 - and then we'll just call the mint
64:48 - function on it
64:49 - all right
64:51 - so there's a two-step process the first
64:53 - is we need this contract's address and
64:55 - then we need to instantiate this
64:56 - contract and then i guess really the
64:58 - third step is we call the mint function
65:01 - so first we'll get
65:03 - access to this token address let's say
65:05 - address
65:06 - token all right we'll make that public
65:10 - uh
65:11 - so we'll just say token it's equal to
65:13 - token that we pass in
65:15 - and we will uh keep track of it here say
65:19 - address
65:20 - token all right we can also make this
65:23 - public if you wanted to so now that we
65:25 - have the address we need to
65:27 - basically get a
65:29 - instance of it
65:31 - so we can do that like this like i said
65:33 - this contract source code knows about
65:35 - this erc20 token here
65:37 - so basically what i'll do is say
65:40 - i'll create a new one
65:42 - so i can say erc20 token
65:45 - all right and we're going to basically
65:47 - instantiate it
65:49 - and we do that by passing in the token
65:51 - address that we've kept track of here
65:54 - so it can be explicit which i think
65:55 - solidity 0.5 requires this to be
65:58 - explicit so i'll say address
66:01 - and i'll say token
66:03 - all right
66:04 - so that will
66:06 - uh reference this ert20 token it's
66:08 - actually deployed it knows about this
66:10 - source code and then it's going to get
66:12 - the deployed token from the blockchain
66:13 - like this
66:14 - and now we can use this token to call
66:16 - the mint function
66:18 - so i'll show you a couple ways of doing
66:20 - this the first one is we can store this
66:22 - to a variable like this
66:24 - you know when we create variables and
66:25 - solidity we you know whenever we declare
66:27 - them we must uh specify the type first
66:30 - so the type is going to be erc20 token
66:32 - contract
66:33 - and this is a local variable it's not a
66:35 - state variable so i'm going to pre-pend
66:37 - it with an underscore just kind of a
66:39 - convention so again
66:41 - it's not necessary for solidity but
66:44 - i do this a lot you'll see this you know
66:46 - all over the place
66:48 - and now we can mint the token like this
66:51 - we just say token
66:53 - dot mint
66:55 - all right
66:57 - so now we can call this buy token
66:59 - function from this smart contract and it
67:02 - will
67:04 - you know use this
67:05 - you'll call the mint function to from
67:07 - the smart contract
67:08 - so let's check it out
67:10 - all right we'll run it
67:12 - so first we have to deploy this in two
67:14 - steps since there's two smart contracts
67:16 - in this file
67:17 - we'll deploy the erc20 token contract
67:19 - first we'll deploy it oh sorry i'm
67:22 - actually going to uh
67:24 - use the javascript vm
67:26 - we'll deploy it
67:28 - all right and now we can just copy the
67:30 - address of the smart contract that was
67:32 - deployed down here um
67:34 - from the transaction receipt
67:36 - let's say contract address
67:40 - and then now we'll go to my contract and
67:43 - deploy it
67:45 - so it's asking for a wallet and a token
67:46 - address let's paste in the token address
67:49 - the second argument
67:50 - and the first argument i'll just get the
67:52 - wallet so i'll just copy the
67:55 - basically this the second account from
67:58 - here
67:59 - so we'll do
68:01 - this account
68:03 - alright
68:05 - and deploy
68:08 - okay
68:09 - and now call the buy token function
68:13 - boom
68:14 - we can also see the token address here
68:17 - and now we'll say uh take the balance of
68:21 - our current address that we're connected
68:22 - with to see if it worked
68:27 - all right so why is that
68:30 - why is it zero
68:33 - well
68:34 - i'll show you why
68:36 - well first this was successful the buy
68:39 - tokens function worked it actually did
68:41 - call the mint function here
68:44 - but it's confusing because our
68:47 - uh you know balance from the account
68:49 - that we did it with is wrong
68:51 - so i'll show you
68:52 - what's right
68:54 - all right
68:56 - so let's go let's
68:58 - let you guess as to why this might be
69:01 - wrong
69:02 - well instead of leaving a suspense
69:06 - it's got to do with msg.sender here
69:09 - okay
69:10 - so this can be a real gotcha when you're
69:13 - programming in solidity and you want to
69:15 - call you know a smart contract function
69:18 - from another smart contract so earlier
69:20 - when we built this we call this mint
69:22 - function directly like if we go here and
69:24 - click mint
69:25 - right and now i click balance it goes up
69:27 - by one
69:29 - but if we do it from here
69:31 - you know we can click it again
69:34 - buy token let me see it's working
69:37 - but our balance doesn't increase at all
69:39 - but if i demand here it does increase
69:43 - that's because msg.sender in this case
69:46 - is the address of the contract that
69:47 - called the function not who sent it
69:51 - okay
69:53 - now that's kind of tricky
69:56 - so
69:58 - we can actually get the address of the
69:59 - person who sent
70:01 - the initial transaction
70:03 - instead of msg sender we also have
70:05 - access to tx.origin
70:09 - all right and that will actually mint
70:12 - functions for whoever initiates you know
70:14 - initiated this transaction so if we call
70:16 - mint function directly on the smart
70:17 - contract it'll increment our balance
70:20 - uh and if we call it from the smart
70:21 - contract it'll also increment the
70:23 - balance of the person who called this
70:24 - buy token function
70:26 - so that's a real gotcha when you're you
70:28 - know programming with multiple smart
70:29 - contracts and solidity that i wanted you
70:30 - to know about now i'll show you how this
70:32 - works so i'll deploy the token first
70:34 - we'll deploy it
70:36 - all right and i'm going to uh
70:39 - deploy you know my contract next
70:42 - say my contract
70:44 - and we'll paste in the address
70:48 - okay it'll be the uh
70:53 - wall address and we'll also paste in the
70:56 - um
70:58 - smart contract address
71:00 - like this
71:01 - all right we'll deploy it
71:03 - now
71:04 - let's uh try to buy tokens again
71:08 - we'll do a buy token
71:11 - all right it worked
71:12 - so now let's go look at balances of
71:16 - uh this account we're connected to you
71:18 - know account 33c this is account
71:21 - uh 33c we'll do balance and it's one
71:24 - if we mint tokens here as well
71:27 - it also increases
71:29 - so that's how tx origin works um you
71:31 - know it's different from msg.sender it's
71:33 - always the person who originated the
71:35 - transaction even if a smart contract is
71:37 - calling the function so i wanted y'all
71:39 - to know that because it definitely
71:40 - definitely can be a gotcha whenever you
71:42 - are programming smart contracts that
71:44 - talk to one another
71:47 - all right
71:48 - so i'll show you one other thing before
71:50 - i move on uh there's a shorthand here
71:53 - so
71:54 - whenever we met this token
71:56 - we can do this
71:59 - we can we don't destroy this token as a
72:00 - variable we can just say erc20 token
72:04 - and then just call the min function on
72:06 - it directly like this
72:08 - and that was the exact same thing so i
72:10 - want to walk you through all that but i
72:12 - just wanted to show you that that's uh
72:14 - also a nice clean shorthand valid way of
72:17 - writing this in one line instead of two
72:21 - okay so now i do want to talk about the
72:24 - next topic which is how to inherit smart
72:26 - contracts so inheritance so having a
72:29 - parent and a child relationship
72:32 - now we'll create a token that inherits
72:34 - from this basic you know erc20 token
72:37 - to do two things so we'll keep this
72:39 - functionality the same
72:41 - um and what we'll do is basically
72:44 - give out you know give this token
72:46 - you know the second token down here
72:49 - um we'll give it its own characteristics
72:51 - so we'll give it its own name
72:53 - and we'll also override some of the
72:56 - minting functions to you know wire up
72:58 - some of our own behavior in our own sort
73:00 - of pseudo token that we're going to
73:02 - create
73:03 - so i'll say my token
73:06 - all right so that's what this will be
73:08 - this mile token will
73:10 - inherit from this one
73:12 - and we do basic inheritance just like
73:14 - this we just say is
73:16 - erc20 token
73:18 - so let's customize this token i mean the
73:21 - first thing we could do is basically
73:22 - override the name we could say string
73:25 - a public
73:27 - name we could set it to something you
73:28 - know default like
73:30 - my token
73:32 - right
73:34 - and that would uh technically override
73:36 - this right that'd be basic inheritance
73:38 - because if we defined it a second time
73:40 - uh it would override whatever's in this
73:42 - parent class or parent contract and that
73:44 - shows you how that works but it doesn't
73:46 - really give us a whole lot of extra
73:47 - functionality so let's show you how this
73:49 - works in a different way so i'll set the
73:51 - name inside this parent contract like
73:53 - this we'll say constructor
73:57 - say string memory name
74:00 - say public
74:03 - and i'll say name equals name right so
74:05 - basically we'll just have a constructor
74:07 - function that's roman this contract is
74:08 - deployed and we'll take a name and we'll
74:11 - set it to the state variable here
74:14 - so we can actually override this
74:15 - whenever we deploy our own smart
74:17 - contract like this
74:19 - we can say instead of just storing
74:21 - having the hard value we can also
74:23 - inherit that
74:24 - uh
74:26 - let me do like this instructor
74:29 - string
74:31 - memory
74:33 - uh let's see name
74:36 - and i can say erc20
74:39 - token
74:42 - name and that'll pass the name in from
74:43 - this constructor along to
74:46 - this
74:46 - all right
74:49 - and
74:50 - let's say public
74:53 - let's say we also wanted our token have
74:54 - a symbol
74:55 - you just say string
74:57 - memory
74:58 - oops
75:01 - symbol
75:03 - okay
75:04 - and we'll just say symbol
75:06 - equals to
75:08 - symbol we'll say string
75:13 - public
75:14 - symbol
75:17 - all right so that's a way for us to
75:18 - accept our own you know argument to our
75:21 - own constructor but still take
75:23 - constructor parameters from the parent
75:25 - contract
75:27 - and i'm going to break this up like this
75:28 - to make it a little easier to read
75:32 - i do this a lot in my you know
75:33 - production smart contracts i break up
75:35 - the lines like this so it's easier to
75:37 - read
75:39 - all right
75:41 - so that's how you you know override
75:42 - constructors like that
75:44 - now inside of here let's override this
75:46 - mint function as well okay
75:49 - let's basically add some extra behavior
75:51 - we want to preserve this minute function
75:53 - we still want to keep track of the
75:54 - balance
75:56 - but
75:56 - we also want to
75:59 - just do some extra stuff let's keep
76:00 - track of the people who actually own the
76:02 - tokens so first we'll say
76:04 - i'll keep an array of owners we'll say
76:06 - address
76:08 - this will be array of addresses say
76:09 - public owners
76:11 - all right
76:12 - and then we'll say we'll keep a counter
76:14 - cache with the people who own the token
76:15 - say uint
76:17 - 256
76:19 - owner count
76:21 - all right
76:23 - and
76:25 - now we will update these values in our
76:27 - own min function
76:29 - so we're going to create a mint function
76:30 - that
76:31 - basically preserves the functionality of
76:33 - this but adds some additional behavior
76:36 - so we say that is going to be function
76:40 - mint so we're going to override it say
76:42 - public
76:44 - okay
76:45 - so first thing we want to do is call
76:47 - this mint function so that this you know
76:49 - behavior is preserved we just say super
76:53 - mint
76:54 - all right
76:56 - and now we say owner count
77:00 - plus
77:00 - plus we say owners
77:04 - push
77:05 - msg.sender
77:08 - okay
77:09 - and that is basically going to um
77:15 - call the met function the parent
77:16 - contract to uh update the balances
77:19 - then it will increment the number of
77:20 - people who own the token right here and
77:23 - it will um
77:26 - add them to the array of owners
77:28 - okay all right
77:30 - so now let's just compile it run it
77:32 - and so when we do this we don't have to
77:34 - deploy two smart contracts all we have
77:36 - to do is deploy this one
77:38 - so you can say your rc20 token
77:41 - see the string
77:44 - actually let's do this
77:46 - let's do my token so string name will be
77:49 - my token
77:50 - and symbol will be mtk
77:53 - deploy
77:55 - all right
77:57 - so let's call the mint function
78:00 - all right it worked
78:01 - so let's see the balances of the current
78:07 - the current address that we're connected
78:09 - with
78:10 - we'll say balance is this
78:12 - okay all right
78:14 - we'll do the uh name
78:16 - my token
78:17 - and the owners of the first person in
78:20 - the list
78:21 - is our address
78:22 - and a symbol
78:24 - okay
78:25 - all right
78:27 - and we could also make this public if
78:29 - you want to read the owner count
78:31 - all right guys so that's how you inherit
78:34 - smart contracts in solidity
78:38 - i'm going gonna be talking about two
78:39 - different topics in this video that are
78:41 - somewhat related the first topic is uh
78:44 - libraries how to use them in solidity
78:47 - and the second topic is math you know
78:49 - how to do math in the solidity
78:50 - programming language and these are
78:52 - somewhat related because you know
78:54 - we use libraries to uh manage math
78:58 - functions all the time in solidity um is
79:01 - a really common use case so i figured i
79:03 - would just record both of those in the
79:04 - same video
79:06 - so you know what is a library if you're
79:08 - not familiar you know library is
79:10 - basically a way
79:11 - uh to organize code that can be reused
79:15 - in multiple places inside your project
79:18 - so that's one of the main reasons we use
79:19 - libraries essentially to dry code up so
79:22 - if you're not familiar with dry dry
79:25 - that's an acronym for don't repeat
79:27 - yourself
79:30 - right
79:30 - so basically if we have a function that
79:32 - we want to use in multiple smart
79:33 - contracts we could define inside of a
79:35 - library and then use that library to use
79:38 - that function and that way if that
79:39 - function ever changes the change is
79:41 - absorbed by any place that we use it
79:44 - so
79:45 - how do we declare a library in solidity
79:49 - well like this
79:50 - first we use the library keyword say
79:54 - library
79:55 - and i'm going to call this library just
79:57 - math
79:58 - okay
80:00 - so in the earlier videos you know i said
80:03 - that you know smart contracts um are the
80:05 - main way that we organize code inside of
80:07 - solidity uh you know it's called a
80:09 - contract oriented language and that's
80:11 - true but we also have libraries where we
80:13 - can you define functions inside of here
80:16 - and store variables and things like that
80:19 - and that's another way to organize code
80:21 - inside solidity but really at the end of
80:23 - the day a library belongs you know
80:25 - inside of a smart contract so it can get
80:27 - called and used
80:29 - you know libraries don't have the full
80:30 - behavior of a smart contract
80:33 - they don't really have storage in and of
80:35 - themselves they don't um
80:38 - you know you can't inherit from a
80:39 - library things like that so it's not
80:41 - really like a smart contract at the end
80:42 - of the day it's meant to be used inside
80:44 - of a smart contract
80:46 - so we can define a function inside a
80:47 - library like this
80:49 - i'm going to create my own divide
80:50 - function say function
80:53 - divide
80:54 - all right
80:55 - i'll just leave this here for a second
80:58 - so why we want to use divide function
81:00 - well i'll show you
81:02 - let's create an example
81:04 - inside of my contract where we would you
81:07 - know basically just do some math first
81:09 - of all we'll declare a value we'll say
81:11 - unit
81:12 - 256.
81:13 - say public
81:15 - value we'll just store the value here
81:18 - and now i'll actually store this value
81:20 - up but we'll we'll compute it so we'll
81:22 - say function
81:23 - i'll say calculate
81:27 - and we'll take a value we'll say you
81:29 - went we'll say value one i'll say unt
81:33 - value
81:34 - to
81:35 - say public
81:38 - and inside of here we'll basically just
81:39 - set the value
81:41 - to whatever the calculated value is
81:43 - we'll say
81:45 - a value one
81:48 - divided by
81:50 - value two
81:51 - now this is a basic way to do division
81:53 - inside of solidity we just use this
81:55 - operator here it's the division operator
81:58 - so why might we want to use a library
82:00 - for this well
82:02 - you might notice a problem
82:04 - it's value two
82:06 - what if value two is zero
82:08 - right there be a problem with this
82:12 - we get some sort of uh exception because
82:15 - you know we can't divide by zero
82:18 - and that's a really common use case for
82:20 - a library basically we can write some
82:22 - code inside of here that prevents this
82:24 - divide by zero error we can actually
82:26 - stop the function before that happens
82:29 - so basically we could do like this
82:32 - we could define this function and say
82:34 - divide is equal to you know the input
82:37 - let's say you went 256 let's just say a
82:41 - you went 256 b
82:44 - we'll say internal
82:46 - pure returns
82:49 - you want
82:50 - 256. and we'll do the division inside of
82:53 - here say require
82:55 - that b
82:56 - is greater than zero that's the first
82:59 - thing we'll do we'll take the
83:00 - denominator and make sure the
83:02 - denominator is greater than zero so that
83:03 - we don't divide by zero then we'll
83:06 - actually
83:07 - create a return value of c which is c
83:11 - divided by b or the numerator divided by
83:14 - the denominator and we'll just return
83:15 - that value return c
83:18 - sorry this is supposed to be a so now we
83:20 - can actually use this divide instead of
83:23 - this divide here as a safer way to do
83:26 - division inside of solidity that's a
83:28 - really common use case for a library so
83:31 - how do we do that
83:33 - how do we take this function out of this
83:34 - library and uh use it inside this
83:36 - calculate function like this
83:39 - well
83:40 - we can say
83:42 - math
83:43 - dot divide
83:45 - and then just pass in
83:47 - value 1
83:48 - and
83:49 - value 2
83:51 - and we store the output to value
83:55 - just like that
83:57 - all right now i'll erase this
84:00 - all right now let's try to run this code
84:03 - so
84:04 - whenever we deploy this
84:06 - i'm going to select my contract instead
84:08 - of math
84:09 - and whenever this is decompiled and
84:11 - deployed
84:13 - um it knows that
84:15 - my contract depends upon math so it's
84:18 - already going to get compiled and
84:19 - deployed automatically we don't have to
84:21 - deploy this first and then this this in
84:23 - the whole compilation process of this
84:25 - file
84:26 - the math
84:27 - library at least the part that gets used
84:29 - is going to get compiled because it's
84:31 - dependent upon right here
84:33 - so let's try this first we can see the
84:35 - value is 0
84:37 - and we'll say value 1 is
84:40 - say 100
84:41 - and value 2 is 10
84:43 - all right
84:45 - okay that was successful we see the
84:46 - value is 10.
84:48 - now it happens if we try to divide by
84:49 - zero
84:50 - calculate and we get an error just as we
84:52 - expect
84:54 - you know we can also do some other
84:55 - values just to make sure it works say
84:57 - 144
84:58 - divided by 12 should also be 12.
85:02 - yep all right
85:04 - so that's how you uh you know that's a
85:06 - basic example of how you import a math
85:08 - function from a library
85:10 - now there are a few other ways we can do
85:12 - this
85:14 - you know instead of having this uh
85:16 - library just at the top of our file here
85:19 - we can actually move it to another file
85:22 - and import it inside of this file so we
85:26 - can clean this up and we're only looking
85:27 - at one you know sort of
85:30 - unit at a time we like to look at the
85:31 - smart contract we don't have to look at
85:33 - this library
85:34 - so i'll show you how to do that we'll go
85:35 - over here to our browser and we'll
85:37 - create a new file we'll call this math
85:38 - does so well
85:41 - all right
85:43 - now we'll just copy the math library
85:45 - from here
85:46 - we'll actually just uh copy it with the
85:48 - solidity programming language
85:50 - declaration
85:51 - and we'll paste it in here
85:53 - save
85:56 - now we can require the file
85:58 - just like this
86:00 - we say
86:01 - import
86:03 - we use double quotes
86:06 - math
86:07 - so well
86:09 - all right and notice i use the dot
86:11 - to indicate the current directory
86:13 - forward slash then the file name which
86:15 - is math.sol
86:17 - followed by semicolon
86:19 - all right that'll do the same thing so
86:21 - we can go back to here and deploy this
86:23 - say math
86:24 - sorry go to my contract and deploy
86:27 - and we'll see say 188
86:31 - and 9.
86:36 - all right there we go that's doing
86:38 - integer division that's why it's uh has
86:40 - no remainder
86:42 - okay
86:44 - so that's how you import a library from
86:45 - another file in solidity
86:47 - now i'll show you one more thing i want
86:49 - to introduce you to a really common
86:52 - library which is called safe math which
86:55 - is put out by open zeppelin
86:57 - you can go to that repository here if
86:59 - you want to read more about it
87:00 - basically it implements a lot of uh
87:03 - helpful functions that i use a lot when
87:06 - developing smart contracts and doing
87:08 - math they've you know um
87:12 - they they solved a lot of problems like
87:14 - guarding from overflow and things like
87:16 - that
87:17 - um and so
87:19 - i use this library a lot so it's a
87:21 - really common use case for me i'm going
87:23 - to show you how to use that library
87:24 - inside of here because it works a little
87:26 - bit differently than how we implemented
87:28 - our math library so i'm going to delete
87:30 - this file
87:32 - and create a new one
87:34 - say
87:35 - safe math
87:39 - i'm just going to copy the code here
87:41 - from github
87:42 - click edit
87:45 - and go oh sorry not edit i want to do
87:47 - raw
87:50 - i'm just going to copy all that
87:53 - go back to remix and paste this in here
87:56 - all right now let's actually change the
87:57 - selective programming language version
87:59 - so 0.5.1 i think it should probably be
88:01 - up to date oops
88:05 - yep looks good
88:06 - all right so let's save that go back to
88:09 - my contract instead of importing math
88:11 - we'll do
88:12 - safe math
88:15 - all right
88:17 - and instead of you know calling a
88:19 - library like this
88:21 - we're gonna do a different way
88:24 - all right and this is pretty cool
88:27 - so
88:28 - we can take all these functions in here
88:30 - like multiply
88:31 - and divide and subtract and add we can
88:34 - actually call them on unsigned integers
88:37 - directly all right
88:39 - and we do that like this we can say
88:41 - using
88:43 - safe math
88:45 - for
88:46 - unit 256
88:50 - all right
88:51 - now that's pretty cool i'll show you
88:53 - what that does
88:55 - instead of doing this we can basically
88:57 - say
88:58 - uh value one
89:00 - div
89:03 - value two
89:06 - there you go
89:08 - that's pretty slick so let's try that uh
89:10 - go to mic on track we'll deploy
89:12 - click this value value uh one would be
89:15 - 144
89:16 - and value 2 is 12.
89:19 - all right value it's 12. there we go
89:22 - say 133
89:25 - 33 by 11.
89:29 - yeah
89:31 - 100 divided by 10.
89:35 - there we go
89:36 - awesome
89:37 - all right so that's all i got for this
89:39 - video today guys again you can find all
89:41 - the code examples of this on my website
89:43 - over at dap university dot com forward
89:45 - slash article forward slash solidity
89:47 - tutorial i'll put a link to that down in
89:49 - the description below and again if
89:50 - you're serious about becoming a
89:52 - blockchain developer you need to join my
89:53 - free training on my website over at
89:55 - dappydiversity.com forward slash boot
89:58 - camp alright until next time thanks for
90:00 - watching dap university

Cleaned transcript:

hey everybody this is gregory from daf university so i'm so excited to be on free code camp today to teach you how to become a blockchain developer i'm going to take you over the shoulder and teach you how to write ethereum smart contracts with a solidity programming language for the blockchain and you don't even have to know anything about solidity or blockchain to follow along so i've compiled this multipart tutorial series into one massive video for free codecamp and you can follow along with the code examples step by step on my website there's an article that i'm going to put a link to down in the description below and finally if you're serious about becoming a blockchain developer you need to join my free training on my website over at daffy diversity dot com forward slash boot camp and i'll also put a link to that down in the description below solidity is the main programming language for writing smart contracts on the ethereum blockchain it's a contract oriented language which basically means that you know smart contracts are the main way that you organize code and like store data and write all of your programming logic and you know it's a high level language for implementing these smart contracts it looks a lot like javascript and you know python and c plus plus as you see right here and it's used to run on the ethereum virtual machine which is basically you know uh the thing that runs the code on the ethereum blockchain so solidity is statically typed um as opposed to a dynamically typed language and it supports stuff like inheritance libraries and lots of other stuff so enough of talking about solidity let's actually jump in and start writing some solidity code this is a website that allows you to write solidity smart contracts in your browser and you know it has a text editor here and allows you to compile them and deploy them and run them and that's exactly what i'm going to use for this tutorial uh you won't have to download anything on your computer you won't have to install anything you can just visit this website to use remix and we'll write the smart contracts that way so in order to do that i'm going to go over here to this browser folder you can see the file browser over here this is some basic smart contracts that come preloaded inside of this ide i'm just going to create a new one here i think i can just create a new file this will be a solidity file we'll call it my contract and we're going to write a smart contract inside of here i'll do this by first declaring the version of solidity that we want to use we do that like this we say fragma solidity and i'm using carrot to specify a version greater than the one we want to use and i'm going to say version 0.4.24 i'm going to end each line like this with a semicolon and next i'm actually going to declare the smart contract so before i do that i'll explain a little bit more about what a smart contract is you know smart contract is code that gets executed on the blockchain in this case this is going to be the ethereum's blockchain since we're using you know solidity for this ethereum smart contract and this smart contract is kind of be kind of like a microservice out on the web it's going to be accessible to everyone on the blockchain they'll be able to you know see this smart contract they'll be able to use it they'll be able to read and write data with it and actually you know execute any code that we write inside of here so it's going to be public and that's kind of why i call it like a microservice it's more it's more than just a class like in an objectoriented system or something like that it's actually something that's publicly accessible so it's going to look something like a class though because that's how we're going to actually you know keep all the code inside of here so i'll show you how to do that we'll call we'll start by saying contract say my contract and i'm open this with some curly braces and it'll notice that the editor closes this automatically for us which is really nice and what i'm going to do first is just show you how to read and write a value from a variable inside of here now like i said earlier solidity is a statically typed language so we're going to actually have to declare the type uh the data type of the variable we want to store so in this case we're just going to store a string and we'll declare a string we'll say value now let me explain something about this value this value is going to represent you know a variable that belongs to this entire smart contract so this isn't like a local variable it's actually a variable that this entire contract will know about and what that means with a smart contract is that data is actually going to get stored on the blockchain in storage so if we set this value we're actually going to be writing data to the blockchain that's different from a local variable that i might just you know set inside of a function that would be you know local to that function scope and would you know disappear instantly once that function is called instead this value is actually going to be you know stored on the blockchain so let's create a way to uh just read this value so i can do this by writing a function in solidity like this we start with the function keyword and i say i'm just going to call the function get it's going to get this value and we'll say we'll just open the braces for now i'm going to write some more code here in a second we can see some warnings coming up but i'll fill this out more we'll say just return value okay and that's a really basic way to do this i'm going to add some more to this i'm going to say this is also public all right which basically is setting the visibility of this function that's what that's called and solidity is setting the visibility so that knows that this function can be called by anyone who has access to the smart contract on the blockchain not just inside this contract so i'm also going to set a return value say returns uh string all right that makes our warning disappear down here and i just tell our function that we're always going to return a string data type and we know that's the same data type as value because we declared it here now i'm also going to look at this warning down here which says this function state mutability can be restricted so basically what this is saying is in solidity now in this newest version since we're not actually changing this value we're not changing anything inside this function we want to add an additional modifier here which just says view all right and that makes that warning go away so now i'm going to set a new function or write a new function that's called set let's say function that's going to allow us to set this value say set and say string i'll say value all right and i'm also going to you know set the visibility of this function we're going to call it public which means that anyone will be able to set this value on the blockchain and i'll say value equals this value that we're passing in all right let me explain that i'm using value as an underscore here because i want to differentiate between this value that's getting passed in and the value that's referenced here now inside of here you know this value without an underscore is referencing this you know state variable that we set up earlier that's actually getting stored to the blockchain and this value sliding knows that it's just a local variable because i passed it in and i you know prepended it with an underscore like this and also notice that i declare the uh data type of the function argument we need that inside solidity because it needs to know the type of the data that's getting passed in all right and now we have a way to actually read this value and set it the next thing i'm going to show you is how to set this value whenever you deploy the smart contract or whenever it's generated for the first time and i'm going to do this with a constructor function so if you're familiar with other programming languages where you might write you know classes or something like that you might be familiar with a constructor function which is basically a function that's called whenever this contract is instantiated or in this case it's going to be whatever the contract is created or whenever the smart contract is deployed to the blockchain and in the newer versions of solidity we do that like this we say constructor and we just you know say it's public and we can you know write code inside of this constructor that gets called whenever this contract is created and we'll say you know value we'll just set it as uh you know my value all right there we go so that's a complete smart contract that you know sets this value whenever it's deployed so it will have some sort of default value and then we'll have you know some functions that allow us to read that value from the blockchain and then we'll have a function that allows us to create that value as well so now i can go to this tab over here in remix and i can compile it we can select the compiler version and i'm going to say let's see here 0.4.25 we'll start to compile it and see what happens all right and now what i'm going to do is actually run the smart contract you'll see some options over here i'm just going to say javascript virtual machine which basically what that's going to do is give us a test block chain in the browser so we don't have to connect to a blockchain of any kind we can just you know compile this and run it and deploy it inside of our browser which is pretty cool and it's going to give us some you know free ethereum accounts over here i don't worry if you don't quite understand what all these values mean just yet that's okay i can explain those more but for now we're going to just keep my contract and we're going to deploy it all right there we go it's deployed so now what i can do is click on this little down arrow here and we can see the functions that are available to us in the smart contract we can see the set function and the get function you know these are the functions that we created over here the set function is going to allow us to update it and the get functions allow us to get it so i'll click get and we should probably see the value that we created inside the constructor we set it here so let's get it all right there we go it's my value and we can see some activity in this log down here we can see that we there's a call to mycontract.get and now let's set it so i'm going to enter the quotations for the string and i'm going to say new value all right let's click set all right and we can see that worked so you can see the transaction history over here let's get the value all right it's new value there we go that's a complete smart contract that allows you to get instead of value on the blockchain now let me explain what's going on here this is a list of transactions that are occurring on the ethereum blockchain so the ethereum blockchain is made up of you know bundles of records that are chained together into blocks that are make up the blockchain and you know the basic units of all those blocks are these transactions so we can see transaction receipts we can actually click the down arrows here we can see all the details those transaction receipts and i've got other videos on this channel that kind of talk about that in detail if you want to know more about that just feel free to look for those all right that's it guys that's how you can write your first smart contract in the solidity programming language again that's supposed to be just a high level overview of solidity and how to get started writing your first smart contracts and using the programming language itself and using the remix ide in your browser to get started easily without having to download any tools or anything like that the first thing i want to do in this video is actually update the smart contract code that we wrote in the last video to support the newest version of the solidity programming language which is 0.5 0.1 i believe now you can actually see the compiler version over here has changed and in the last video you know we wrote this smart contract and there's some actually some compilation errors you can see over here on the right so you have to update this code to support the newest version of the solidity programming language and i want to go i wanted to go ahead and do this i wanted to go ahead and support the new version of solidity so that when i make more videos in this series um they'll be up to date and you'll have the newest version so let's see what we need to do we can read the error it says basically the data location must be memory and that's actually the error in both cases so all we need to do in this case is actually just return a memory here and then whenever we're passing in the value a string we actually need to put memory here as well all right actually that needs to be before value my fault and now we there's go away so we will select the newest compiler version we'll say uh let's do the latest complete version 0.5.1 start to compile and hopefully the compilation will work yep it worked so let's go to run and we'll deploy and see if it worked so get the value yep it worked awesome now let's move on to the next part of this tutorial where we'll actually cover the content for this video which is going to be you know the basic data types and data structures and solidity and how you can use them when you're developing your own smart contracts so i will change some values in here to kind of show you what that is the first thing i want to talk about are you know the different ways we can work with these state variables right so the first thing i want to mention is you know we had this string value here that we declared we set it here inside this set function and we had this getter function where we read that value right so solidity has a shortcut where i don't even need this function i can actually just read uh this string value for free i can actually get this function for free take this out and just declare this public that's that's declaring the visibility of the uh state variable here actually probably goes before so i'll save that and i'll compile it and i'll run it and we'll see that a get getter function called value the same name as the state variable was exposed to us by the smart contract and we can see it works just the same way as the other function did so that's a really nice way to save yourself from writing extra code you can just get that function for free exposed to the public interface of the smart contract whenever you store your state variables that way okay so the next thing i want to talk about inside of here is actually you know we could set this as a default value we don't necessarily have to put you know my value here in the constructor we could just say this right we could take this away oops take this away and we will um run that again let's just clear this out deploy all right and we can uh actually sorry compile it first deploy it again get the value and we can see it's my value we can also set this value as a constant if we don't want it to change um you know if we don't want to allow a user to set this value if we want to stay the same we can just say constant all right that actually declares a constant we have to remove this function we can't update this value at all solid t won't let us do that so we could just do that i'll deploy this again and we can still see our values here as my value so yeah that's how you would add a constant to your state variables or make your state variables constant now let's look at some other data types and solidity let's just change this name we'll call this like string value all right let's just deploy that we can see this instance here again string value all right it's my value now let's explore some other data types we can say uh boolean type we'll say bool public is equal to i'm going to remove this constant for now um my bool equals true all right so this just accepts true or false we can deploy that see this oh my bull right it's true string value is my value say uh or my string just save that just for fun and we can also see that you know we support data types like um integers so integers can be signed or unsigned so what does that mean uh well we can do a default int which would be public my int equals one right so we can deploy this and see let's actually just clear this out sorry deploy this and see my int is equal to one so the difference between uh an int and a uint or an unsigned integer uh is that an integer can be signed in a or sorry uh yeah an integer can be signed and a unit can be unsigned so what does that mean well basically an int can be negative so i can do minus one all right and deploy that that's a signed integer it has a sign in front of it it can be positive or negative and a uint can't so we'll deploy that uh clear these out and see my uint all right and my int all right yeah so negative one can work for an int and uh they can't do negatives on unsigned integers you can also specify the amount of bytes or bits um in an integer so we can say you went eight black equals my unit eight sorry equals like all right oops let's do a small number and we can see my unit eight all right and so if we do you ant here it defaults to 256 i believe uh unit 256 public my unit okay so that gives you a basic overview of all those basic data types um i don't want to bore you with all the pedantic details of this kind of stuff but this is helpful to know if you like the next thing i want to show you is an enum so what is an enum and how do you use it well an enum is basically an enumerated list that's going to allow us to keep track of um you know a set list of things in our contract so i'll show you what that means so basically i can declare an editing like this i'll say enum state and i'll give it some options here i'll say waiting ready active all right and this is going to allow us to keep a list of these three states inside the smart contract we'll be able to reference this to see what the current state is and it'll give us some options whenever we're updating the state and like checking against this so i'll show you an example we'll actually store this like this we'll declare state public state this right so basically this is going to give us um a public uh we're gonna be able to access this publicly with that uh getter so inside of here i'll do a constructor i'll say constructor i'll say public say state equals state active all right so i'll go ahead and set the default state to active right so actually let's do this let's do waiting and then i'll say i'll create a function to activate it and i'll say activate and say public state equals state dot active so we can actually choose sorry we can choose this value out of this enum list and update the state to that value all right so whenever we call this function it'll change the state to the active state and let's get a function that checks to see if the state is active we'll say function is active and we'll say public view returns boom all right we'll say return state equal to state dot active so that's we'll do inside here we'll just check to see if the state currently is active all right so let's see if you have any errors looks good um i will compile this all right we'll run deploy and all right let's check the state so is the state active all right no it's false so that's that's true it's not active um it's in waiting so let's actually check the state so state is zero so zero corresponds to the first uh item in this list zero which is waiting and i'll click activate all right so actually called the activate function um which you know updates the state to active let's see if it's active yep it's true and let's check the state so now the state is 2 which is 0 1 2. all right so that's an idea of how you use enums um let's look at the next concept that i wanna show you the next comment i wanna show you is uh let's do let's do structs so structs are basically a way for you to define your own data structures inside solidity we'll do that like this we'll say uh we'll create a struct right here we'll call it person it's a struct person and we'll give it some look at some some characteristics we'll say string uh first name and string last name okay so basically what's going on here is this allows us to basically model you know our own sort of arbitrary data i'm just going to model a person with this struct that's going to have a few attributes it's going to have a first name attribute that's going to be a string and a last name attribute that's also going to be a string and we can put these structs inside of like arrays and mappings and things like that i'll show you that here in a minute inside this video but for now just know that we declare that we've defined this new data type person inside the smart contract with a struct that's going to have a first name and a last name okay so let's actually uh create a function that allows us to instantiate a new person create a new one and we'll actually keep track of a bunch of these person structs inside of a people array all right so let's do that like this let's say let's let's keep track of a bunch of different persons so we can create new ones we'll say person this will be an array public people all right so let's see what's happening here people's estate variable here and it's in a it's public so we can read it outside the smart contract and it's an array here of these data type person right so we declared the data type first which is person which we defined here with struct it's an array that you know contains these person structs it's public and it's stored with the people state variable so we can add people to this array or person structs to this array like this so create a function say function add person it's a string uh this is a solidity five updates uh memory or 0.5 sorry first name and then we'll say string memory last name we'll say public and we'll do this inside here say people push so push is you know a function we can call an erase to add a new item at the the to the array and we'll push a new instance of this person struct so we can um create a new instance like this we just call person right and we pass in these attributes so say first name oops sorry name and last name all right and what we can do here is well yeah we've added it let's go ahead and do it so let's just let's just compile this a minute um i'll deploy this all right so let's see what happens so people um it's going to add the person add person oops sorry let's do the first name so first name will be dap last name will be university add person okay awesome so that didn't give us any errors now how do we read this person out of here that's a good question so we added this person to an array um but this function you know whatever we call this person or sorry this people function it's not going to return the entire array of people that's because this is uh you know we don't know the size of this array is in solidity and we have an array of unknown size it's not going to return the entire array so basically we need to reference uh the person by id so whenever we get this function it expects an argument which is going to be the index of the person inside this array so for example we know we added one person in there so we will add people we'll say zero all right there you go dap university so what happens if we reference you know a person that doesn't exist say a person you know one people it's gonna give us an error it's an invalid opcode error that's because there's no one in there at position one so how do we how do we like you know how do we fix that problem let's keep track of that like this so basically we would keep an internal count of the people we'd say something like this unit 256 people count okay and that's going to basically have give us a counter cash that will increment every time a person's added so we can say something like um people count plus equals one all right and we do that after i guess all right save that deploy and now we can uh actually make this public oops sorry as before let's try it again so now we can add the person dap university add person and we can see uh people count is one so we would do one minus that people all right dap university we do one minus that because it's a zero based index which means the first item you know is an index zero and the second one's index one etc etc the next thing i want to show you is how to do a similar concept here but model it a little differently so instead of using an array we're actually gonna use a mapping so what is a mapping a mapping is basically like an associative array so instead of having you know just an array um and we know that each index of the item in the array we can actually associate it to a value so that's that's like a like a hash table or a hash map or a hash and other programming languages that you might be familiar with or basically you can reference things by you know a key value it's key key value pair so instead of having people like this instead of being an array um i'm going to change it down here i'm going to say this is going to be mapping mapping uint person okay so uint is going to be the key and the person is going to be a value so this mapping is like i said an associative array that's going to take a key value pair the key is going to be an unsigned integer we'll treat this like an id so it'd be kind of like our database lookup where we have an id and then a record so this is going to return kind of like a record like a person record or a person's struct in this case it'll be public and it'll be people and it is kind of a fair comparison to compare this to uh a database because you know we're blockchain kind of is a big database and these structs are you know getting stored in storage on the blockchain with this mapping all right so person string first name last name and we'll do add person so when we need to modify this function we'll still take the first name we'll still look at the last name but we're going to put this in the mapping instead of the array so i'm going to move this people count back up here we're going to want to keep track of this just like we did earlier so we know how many people are in this mapping but we'll add it to the mapping like this we'll say people um people count this will be our id so if it starts at zero which it will do this all right people count plus equals one that'll be the new id of the person that's going to go in here so this will be person number one the first time we add this we'll say this is going to be a new person it'll be uh we'll give it a we'll give this an id we'll say uh unt id okay people count and then we'll say first name and then last name all right and we'll take this out all right let's see if that worked clear this out um deploy the contract so we'll do first name is dap university the ad person okay so see people count is one now and we'll go to people this time it won't be uh based on the array index it'll actually be on the id so we can actually reference person one all right we'll do people one there we go dappy diversity so let me explain a couple more things about structs while we're here um you know we need to keep track of this people count because there's no way to know the size this mapping and solidity uh basically any key that doesn't have a value set for it's going to turn a default value which is going to be like an empty struct here so if i do like you know person no 10 or like 99999 to people it's usually going to return default values so what are the default values for the struct person id for uint is going to be 0 and then these blank strings for first name and last name so that's why we need to have a person count so if you were going to use this like as a data storage um and you wanted to like show all the people or all the persons and your in your people mapping in your app or something like that reading for the smart contract you want to know how many are actually in there and you want to do that with a counter cache um so that way you know if you wanted to basically like the same thing with with those variable size arrays like if you wanted to get all the items you need to first make a call to find out how many there are that's what you use the counter cache for and then you basically create a loop to read out each one one by one so yeah it's it can be kind of a pain but uh that's sort of the state of things and what you have to do i'm going to go ahead and pick up where we left off in the last video i'm going to use this you know my contract that we built where we added a person a person struck to this mapping of people if you haven't seen that last video go ahead and check that out it's not necessary but you can probably follow along with this video if you want to what i'm going to do now is show you a little more about these modifiers like public and things like that i think we talked about that in the first video but i'm gonna go just a little further so what i can do is you know show you another modifier which is basically like internal um so that's different from public you know public is a function that can be called uh you know the public interface at the smart contract you can see you know the public functions listed here on the side so go ahead and create a private function or an internal function excuse me it'll say function uh we're just gonna take this people count and wrap it in its own function to show you how that works we'll say uh increment count we'll just make this a function and we can call it uh internal that's a different modifier we'll just take this people account we'll paste it inside of here all right and we'll just say increment count call that function and we'll run it see the smart contract we'll add the person we'll say dap oops dap university and i'll click add person and there we go it incremented the account you can see the people count has been changed you can say joe blow and the accounts changed so that's a way that you can you know use other functions that are going to be internal and we can see this increment count function isn't uh added to this list over here it's not exposed to you know things outside of the smart contract external callers can't use it so that's an example of you know other you know types of visibility of functions and solidity let's talk about function modifiers so we can add you know more you know words and terms to the end of this function to change how it behaves and i'll show you an example so we're going to create our own custom modifier actually inside of this smart contract so that only certain people can call this add person function all right so what i'm going to do is basically you know make this smart contract have an owner or like an admin and we're going to say that only the owner can call this ad person function and any other account connected to the network you know whenever they try to you know add a person they won't be able to and that'll show you how we can add an extra modifier to this function to make that happen basically we'll just add a modifier to the only the owner of this smart contract can do that so first we need to well actually that'll just look like this we'll say only owner that's what the modifier will look like now this only owner modifier doesn't exist yet so let's go ahead and create it all right so we'll do that like this first we need to keep track of it owner we'll say the owner is you know address i'm not sure if we talked about this in the data types uh video but you know an address is a data type inside of solidity you know like an address that's on the network an account so this will be the address we're just going to declare it here we're not going to set it just yet we can set it like this we can do it inside the constructor well actually nothing that just yet um so that would be the owner we basically just create a modifier like this we say modifier see only owner looks like a function and what we'll do inside of here is write the logic that makes sure that you know whoever's you know calling the smart contract is the owner so that's what we're defining here only owner and only owner so how do we do that how do we say the person who's calling this function is the owner of this smart contract well we're going to compare it to this owner right here but how do we know who's calling the function well solidity has a global keyword called msg which basically stands for the function metadata that's passed in we're not actually going to pass in any metadata here it's going to be implied so basically we have access to msu.sender and this is basically a special uh you know thing inside of solidity that tells us the account you know this address who called the function and basically we can just say you know is this person the owner we can just you know compare equality of the person who's calling the function with this owner that we're going to store here in a second all right and if they're not we actually want to throw an error right so this is going to show you another concept in solidity about error handling so we can throw an error in solidity like you know i think earlier we had some errors happen like here's an error we actually want to trigger an error if this person um you know it's not the owner we want to we want to revert the transaction and we do that like this we say require um sorry msg.sender is equal to the owner so basically anything inside of this require um if if it evaluates to true then this passes if it evaluates to false then this will throw an error we basically are saying require that whatever you put inside of here is true all right and then after this we can basically just do this all right and now our um only on only one modifier is complete so basically now we have this modifier that's you know defined here and we add it here and basically say if the person who is you know calling this function is the owner uh then you know we can actually run this function and if they're not we're going to you know create a failure we're going to revert the transaction and also whoever's doing this you know whatever like this code runs they won't pay this gas fee all right so now we need to set the owner and i'm just going to do that inside of constructor we'll use msg.sender as well say function constructor and we'll just open this curly braces and we'll say owner equals to msg sri msg.sender sorry i don't need the function keyword here and we also need to make this public all right so i'll save that so whenever you deploy the smart contract like you know this constructor gets run and the msg.send is actually the account that deploys the smart contract and they're going to get set to this owner state variable right it's address owner and basically that same you know address is the only person that's going to be able to call this add person function all right and if they um you know this code will run and we'll add a person and if we switch accounts to some other account over here then it won't work so let's just try that deploy this we will uh you know deploy with this account so let's change to that account we'll add the person actually i don't know if it deployed that account or not let's try it again so make sure on the first account we'll deploy all right we'll add a person we'll say dap university add the person all right let's see here all right it worked people count is one now we'll say you know joe blow and we'll change accounts to this one and we'll try to call it again add person and we see it as failed and the people count has not changed at all so it worked so we've kept track of the owner and we say only the owner can do it now while we're here i'm going to show you a little code formatting that i like to do sometimes this is getting kind of long and sometimes you know if you're like me and you have a text editor with a whole bunch of panes open i like to keep my columns kind of short sometimes especially with solidity and it kind of makes it easier to maintain these functions when the arguments are getting long and using git and things like that sometimes i will just break these up like this all right and then i'll actually put the modifiers if you have a bunch of modifiers sometimes this makes it easier to read and also when i'm writing my own solidity source code i only use two spaces i don't use four uh but yeah that's sometimes how i break these functions up so i can see the function name and then the arguments um then i can see the modifiers and then i can actually see the code that gets executed inside here and it can make your smart contract kind of long but it can be sometimes this will catch you if you have too many you know if you have three visibility and modifiers on here sometimes it can be kind of tricky so i like doing this all right so next i'm going to show you how to work with time and solidity okay so what we can do is basically compare time and solidity and instead of um this saying only owner can do this let's say you can only call this function if a certain time has passed so let's pretend like you know this is uh a contract that is only open at a certain time so we'll say instead of only owner we'll say only while open only while open all right and this opening uh state is going to be determined by a time so once we've passed a certain time in history in the future then we'll let you call this function if it's before that we won't do it so that's really useful if like you're building a crowd sale or something like that that has an opening time like an ico smart contract and you say hey we can only let you contribute ether like after you know the first of the month well you just figure out what time that is and say hey you know if you make a contribution before then we'll throw an error so i'll say only while open all right and instead of requiring that uh msg that sender is the owner right we're actually going to just take this out we're gonna say uh we're gonna make sure that the current time is uh in the future beyond a certain like uh opening time so let's do uint 256 opening time all right so how do we do this well we need to set this opening time somehow all right so the opening time is actually expressed in seconds and you know inside solidity or these time stamps are expressed in seconds inside solidity and you know seconds of what well it's epic time which if you're not familiar with that it's um a concept in computer science that's like the epic is a is a specific time i can't remember the actual date it's like a date in the 60s or 70s or something like that um and basically we just add seconds since that point in time in history so this is the current epic time stamp is this many seconds uh since the epic time and i guess there's probably a link here where you can read more about that yeah the unix epic clock um yeah i'm sure you can get on wikipedia and figure all that out but basically uh this is the current epic time and it's changing so we use these seconds values so this is like the current you know epic timestamp we'll say this all right so this is how we could set this and it's you know uh 256 is going to store this big number of seconds since that time stamp and that's going to be our opening time and so how do we compare that to now so how do you get now in solidity well there's no perfect way to do it but the best way is to get the current blocks timestamp all right so how do we do that well just like msg there's a global variable in solidity called block dot and we can say block dot timestamp all right and we can say is the block dot timestamp is it greater than or equal to the opening time all right so basically if it's after the opening time we're gonna let you call this function and if it's not um then we won't all right so let's give this a try i'm going to update this time stamp let's refresh it let's see this is the current one i'll paste this in here so 15 i'm going to add 60 seconds so a minute um so i'm going to deploy this and it will be uh it shouldn't work right now so we can try to call add person i'll try to add dap university okay we'll add person and we'll see that it reverted okay and now we can check the time stamp we're not there yet so i'll just pause the video wait for this to pass 75 i think that's the actual time yeah 75 all right i'll pause the video pause the video giving us plenty of time we're past the timestamp you can see it's 793 and we're at uh 775. so let's deploy it again oh actually let's not deploy it again let's just do joe blow add a person and it worked so that's how you can use um time and solidity you can get the current time and set of time value with seconds and so that's what i'm going to call today guys i hope you all like this video let me know how you're enjoying these solidity videos let me know if i missed anything or if there's something you want to learn or if you're just not liking them that's okay too just let me know down in the comment section below let's use the same my contract example that we've been you know using throughout this tutorial series and you don't necessarily have to have been following along with every video in this series you can kind of just pick back up with this one probably so yeah let's go ahead and jump in and start programming what i'm going to show you first is how to write a function that accepts ether so basically like how can we send ether in when we call a function and do stuff with it so i'll show you how to do that first we'll create a function called buy token say by token and this function is going to kind of emulate what happens in an ico uh like a crowd sale or a presale or something like that on ethereum where you're buying erc20 tokens i'm not gonna like code out an entire erc20 token smart contract right here or you know cut out a crowd sales smart contract i've got several other tutorials that show you how to you know codrum cryptocurrency on ethereum with you know build an erc20 token step by step and a real world crowd sale things like that so you can check out those other videos if you're interested but uh what we're going to do is basically create this uh function called buy token it's going to simulate what happens it's not going to do everything but at least give you an idea of how that works so we'll call this you know buy token and inside here what we basically want to do is buy a token and we also want to send ether to the wallet so what's going to happen is someone's going to call this function and they're going to send ether when they call this function and when they do we're going to issue them a token and then the wallet is actually going to receive the ether that they sent in when they call this function so i'll show you how to do that first i'm going to create um a way to track the tokens and basically all this is going to do is you know track this person's balance so we'll use a mapping for that we'll say mapping and again uh if you didn't check the other videos the mapping is like an associative array where we have key value pairs so we'll say address will be the key and the value will be an unsigned integer all right and this will be public all right this will give us a function for free that'll allow us to read this value and we'll just call this uh balances so what we'll do and when we buy a token we'll basically just say balances of whoever called this function so if you'll remember from the last videos in the series we we get that value with msg.sender this is the account that's calling this function and we will just increment this count by one now this is not really fancy um you know we're basically just saying whenever you call this function you're going to buy one token we're not using a rate of redemption or anything like that this is just to kind of show you how this works this is not very sophisticated um but basically that'll just increment your balance you know inside this token uh contract by one whenever we do that we want to transfer funds that are sent in with this smart contract to a wallet all right so how do we do that well first we keep track of a wallet uh we'll just declare a state variable here we'll say address wallet and we want to send funds to this wallet okay and we do that like this and i'm actually going to show you something in a minute that's going to be a solidity 0.5 update so if you've been using previous version solidity we have to make a change here i'll go back to that in a minute but anyways let's uh transfer funds to this wallet we'll do that like this so we'll say wallet uh transfer and we want to transfer in the funds that are sent by this function uh sorry transfer the funds that are sent in by this function to this wallet so how do we do that well how do we actually know what the the value is that's getting sent in well just like msg.sender msg has another property called value so i can say msg.value all right and that's going to tell us exactly how much ether or whey is sent in by the person who's sent this function so i'll show you how that works so that's going to do is take the ether that's sent in with this you know function call and transfer it to this wallet right here now there's this is not complete there's a lot of things that actually need to change in order for this to work properly you can see these x's over here uh these you know compiler errors so the first thing we need to do is uh set a wallet let's do that inside a constructor we'll do that whenever we deploy the smart contract so we'll say constructor we'll say address wallet we'll say public and we'll say wallet is just equal to the wall we pass in all right so we're still getting errors now let's see what they are the first thing we need to do in order to make uh this function accept ether well actually first we need to make it public so that people can call it let me say public all right so now people will actually be able to call this function and send ethernet stuff like that and in order for people to in order for this to accept ether we have to add another modifier here which is payable all right and if we don't do that this won't allow us to send ethereum with the transaction so this is how we declare that this function will accept ether okay now here's a new solidity update it requires explicitness whenever you're declaring an address that can accept ether inside of a smart contract and we do that like this we say address payable wallet all right and then likewise we say address payable wallet whenever we pass this function into the constructor all right so that should be a working implementation if we want to see so let's deploy the smart contract and try it out i will uh you know take one of these addresses and we'll take the second address here in the list and we'll use that as the wallet we'll actually check its balance here in a second um so we'll deploy the smart contract we need to pass in a wallet whenever we deploy just paste this in click deploy all right looks like it was successful let's try to do the buy token function okay it's just going to buy one token for us so make sure we've got the first account the list selected by token all right looks like it was successful let's check the balance of this oops actually pasted in the wrong address uh pasted in the second address so let's try the balance again all right it's one all right now all that did was actually uh transfer you know all that did was buy a token it didn't actually transfer ether to the wallet and that's what we want to show so in order to like send ether in and actually transfer funds to the wallet uh we do that like this we'd change this to ether i'm going to send one ether in with this transaction where we call the buy tokens function we'll do that from this account and we'll click uh buy token all right boom so let's check the balance again all right the balance is two now let's see what happened we can see that the ether value decreased here from you know 99.9 to 98.9 it actually took ether out of our wallet because we sent it in with the transaction and we can see that the second account in the list uh which i used as the wallet whenever we deployed has been credited with that ether so our smart contract worked it actually sent you know the uh value that we sent in with this to that account all right so the next thing i want to show you is how you can create basically a fallback function in solidity this is what it's called at least that's what i've seen it called i'm not sure what the official name is but basically it's going to be like a default function that you can um wrap this in so whenever you just send ether to the smart contract it executes a function you'll see that a lot like icos where you know they have an address posted and they say hey send ether to that smart contract and it'll actually buy the tokens for you now this is just a kind of pseudo code implementation again of like a a purchase function uh you know real ico function functionality would be much more complex than this but uh you get the idea so do this fallback function we'll do like this we'll just say function all right and we'll say external payable and we'll just wrap this with the buy token function all right so here's a new modifier i don't think we've used yet which is external so that's different from public because public can be called you know inside of our smart contract as well as outside but external can only be called outside so we don't want to like call this you know inside the smart contract somehow so now if we just compile this again and deploy uh i'm going to paste the wallet in here deploy we'll see you have a new function just called fallback um and we can basically just uh do that like this so we'll just send them on ether from account number one call the file back and it worked we can see our account balance went down this one up and the balance of first count should be one yep it's one so now i want to show you events inside of solidity so what do we use events for so events are a way for external consumers to kind of listen for things that happen on a smart contract so basically external consumers can subscribe to events on a smart contract and uh you know wait for something to happen so we'll do inside of this buy token uh function we'll actually trigger an event that lets you know anyone connected to the blockchain really to know that a token has been purchased from the smart contract if they were to listen for it so i'll create an event like this do it up here let's say event purchase and i'll just say uh i'll break this line right here oops i'll say address uh in oh yeah a buyer and i'll say uint 256 amount okay so that's how we declare an event just like that and inside of this function whenever the token is purchased we'll trigger it and we trigger the event like this we say emit purchase and we pass in the buyer we pass in the amount so the buyer in this case is msg.sender you know the account that's calling this function and the value in this case is just one semicolon all right so there you go now another thing you can do with these events um you can create an index like this indexed okay and that will allow you to you filter events that are only from certain buyers so basically like if you wanted to only listen to events from the smart contract that uh you know a certain person uh did a certain account or maybe even just you you could subscribe based on a specific address so i'll show you how that works all right let's compile this and run it i'm going to take the uh wallet paste it in here play all right now we'll call the buy tokens function um we'll send in one ether oops all right it worked now how we know the event worked so we can look inside of this transaction here see the log and we can see uh right here here's the log and inside this log we have some messages and this basically is is the event we can see uh the buyer listed here and the amount see the buyer was this address and here's the amount so what are events for really there's there's two kind of main use cases for events you know because um of the asynchronous nature of the blockchain you know if you're building an application that um uh you know if you're building an application that talks to the smart contract you know you might you you might call a function like by token like if you're writing a javascript application you might like call this function and then you know you your application would just know that you called this function but you might want to actually wait for this to finish and execute wait for this event to be emitted so you can basically wait for that and subscribe to this event um and filter for only ones you know that are applicable to you and whenever that happens you know you can you can wait for that to happen and then you know reload your application state whenever that event's been triggered so that's one popular use case another use case is you can get the entire event stream from a smart contract like this so you could basically see all of the purchase events because they're you know listed in these logs they're actually listed in the transactions uh you know that are contained in the blocks of the blockchain and that's a way to see all the purchases that have ever happened inside a smart contract like this i'll go ahead and use the smart contract that we were working on in the last video as the basis for this one um so in this video we're going to be talking about how to use multiple smart contracts in the solidity programming language um you know two different ethereum smart contracts one that will talk to the other and i'll also show you how to like write uh you know parentchild relationships with smart contracts we'll have uh what's about inheritance you know a a contract that inherits from another one so i'm going to go ahead and clear out some of this code from the last video to kind of get it where we want it to be the first thing i'll do is um let's see here we'll basically what we'll do is we'll go ahead with this scenario where we're still going to buy a token but instead of you know keeping track of the balance inside this smart contract we'll actually move it to a token contract uh to you know kind of separate concerns a little bit so actually tell you what let's go ahead and create the token smart contract like this and again this is going to be a really just basic uh you know it's kind of almost like pseudo code example it's not going to be a full erc20 token but this will just give you an idea of like what's going to happen when you know two smart contracts call one another at a very simple example so we'll say contract erc 20 token and again if you want to see more you know videos about erc20 tokens i've got plenty on my channel so i say string name so we're going to have a state variable that keeps track of the name here let's actually make this public and we'll do a mapping we'll just basically move this balances mapping up here take it out of this contract and we're going to um extract this balances you know increment here and put it into its own function so we'll just call this function mint say function uh mint i'll make this public and inside of here we're just going to do this we'll take this balances and increment it here just like that and also we can rewrite this just to say plus plus which will increment by one refactor that a little bit make it a little nicer a little cleaner all right and now you should be able to clean up this little bit take these comments out let's see here let's actually simplify this we'll take this purchase event out we don't need all this that was mostly to show you how events worked in the last video i just want to simplify the code a little bit so that it's easier to follow along with all right so inside of here we want to mint tokens inside of this contract so you want to call the erc20 token from this buy token function so how do we do that well you know we created this smart contract in the same file so because this is in the same file uh this contract knows that this contract is here before we compile it and deploy it so the source code you know this one will know about this one so we can basically uh be explicit and tell this contract that we want to mint tokens in this contract so in order to do that there's a couple things that we need we need to know the address of this contract once it's deployed because you know this will get deployed and this will get deployed and we'll have two separate addresses and then my contract needs to know about the erc20 token contract where it is and then we'll basically just reference that smart contract with the address and we'll basically get an instance of it kind of and then we'll just call the mint function on it all right so there's a twostep process the first is we need this contract's address and then we need to instantiate this contract and then i guess really the third step is we call the mint function so first we'll get access to this token address let's say address token all right we'll make that public uh so we'll just say token it's equal to token that we pass in and we will uh keep track of it here say address token all right we can also make this public if you wanted to so now that we have the address we need to basically get a instance of it so we can do that like this like i said this contract source code knows about this erc20 token here so basically what i'll do is say i'll create a new one so i can say erc20 token all right and we're going to basically instantiate it and we do that by passing in the token address that we've kept track of here so it can be explicit which i think solidity 0.5 requires this to be explicit so i'll say address and i'll say token all right so that will uh reference this ert20 token it's actually deployed it knows about this source code and then it's going to get the deployed token from the blockchain like this and now we can use this token to call the mint function so i'll show you a couple ways of doing this the first one is we can store this to a variable like this you know when we create variables and solidity we you know whenever we declare them we must uh specify the type first so the type is going to be erc20 token contract and this is a local variable it's not a state variable so i'm going to prepend it with an underscore just kind of a convention so again it's not necessary for solidity but i do this a lot you'll see this you know all over the place and now we can mint the token like this we just say token dot mint all right so now we can call this buy token function from this smart contract and it will you know use this you'll call the mint function to from the smart contract so let's check it out all right we'll run it so first we have to deploy this in two steps since there's two smart contracts in this file we'll deploy the erc20 token contract first we'll deploy it oh sorry i'm actually going to uh use the javascript vm we'll deploy it all right and now we can just copy the address of the smart contract that was deployed down here um from the transaction receipt let's say contract address and then now we'll go to my contract and deploy it so it's asking for a wallet and a token address let's paste in the token address the second argument and the first argument i'll just get the wallet so i'll just copy the basically this the second account from here so we'll do this account alright and deploy okay and now call the buy token function boom we can also see the token address here and now we'll say uh take the balance of our current address that we're connected with to see if it worked all right so why is that why is it zero well i'll show you why well first this was successful the buy tokens function worked it actually did call the mint function here but it's confusing because our uh you know balance from the account that we did it with is wrong so i'll show you what's right all right so let's go let's let you guess as to why this might be wrong well instead of leaving a suspense it's got to do with msg.sender here okay so this can be a real gotcha when you're programming in solidity and you want to call you know a smart contract function from another smart contract so earlier when we built this we call this mint function directly like if we go here and click mint right and now i click balance it goes up by one but if we do it from here you know we can click it again buy token let me see it's working but our balance doesn't increase at all but if i demand here it does increase that's because msg.sender in this case is the address of the contract that called the function not who sent it okay now that's kind of tricky so we can actually get the address of the person who sent the initial transaction instead of msg sender we also have access to tx.origin all right and that will actually mint functions for whoever initiates you know initiated this transaction so if we call mint function directly on the smart contract it'll increment our balance uh and if we call it from the smart contract it'll also increment the balance of the person who called this buy token function so that's a real gotcha when you're you know programming with multiple smart contracts and solidity that i wanted you to know about now i'll show you how this works so i'll deploy the token first we'll deploy it all right and i'm going to uh deploy you know my contract next say my contract and we'll paste in the address okay it'll be the uh wall address and we'll also paste in the um smart contract address like this all right we'll deploy it now let's uh try to buy tokens again we'll do a buy token all right it worked so now let's go look at balances of uh this account we're connected to you know account 33c this is account uh 33c we'll do balance and it's one if we mint tokens here as well it also increases so that's how tx origin works um you know it's different from msg.sender it's always the person who originated the transaction even if a smart contract is calling the function so i wanted y'all to know that because it definitely definitely can be a gotcha whenever you are programming smart contracts that talk to one another all right so i'll show you one other thing before i move on uh there's a shorthand here so whenever we met this token we can do this we can we don't destroy this token as a variable we can just say erc20 token and then just call the min function on it directly like this and that was the exact same thing so i want to walk you through all that but i just wanted to show you that that's uh also a nice clean shorthand valid way of writing this in one line instead of two okay so now i do want to talk about the next topic which is how to inherit smart contracts so inheritance so having a parent and a child relationship now we'll create a token that inherits from this basic you know erc20 token to do two things so we'll keep this functionality the same um and what we'll do is basically give out you know give this token you know the second token down here um we'll give it its own characteristics so we'll give it its own name and we'll also override some of the minting functions to you know wire up some of our own behavior in our own sort of pseudo token that we're going to create so i'll say my token all right so that's what this will be this mile token will inherit from this one and we do basic inheritance just like this we just say is erc20 token so let's customize this token i mean the first thing we could do is basically override the name we could say string a public name we could set it to something you know default like my token right and that would uh technically override this right that'd be basic inheritance because if we defined it a second time uh it would override whatever's in this parent class or parent contract and that shows you how that works but it doesn't really give us a whole lot of extra functionality so let's show you how this works in a different way so i'll set the name inside this parent contract like this we'll say constructor say string memory name say public and i'll say name equals name right so basically we'll just have a constructor function that's roman this contract is deployed and we'll take a name and we'll set it to the state variable here so we can actually override this whenever we deploy our own smart contract like this we can say instead of just storing having the hard value we can also inherit that uh let me do like this instructor string memory uh let's see name and i can say erc20 token name and that'll pass the name in from this constructor along to this all right and let's say public let's say we also wanted our token have a symbol you just say string memory oops symbol okay and we'll just say symbol equals to symbol we'll say string public symbol all right so that's a way for us to accept our own you know argument to our own constructor but still take constructor parameters from the parent contract and i'm going to break this up like this to make it a little easier to read i do this a lot in my you know production smart contracts i break up the lines like this so it's easier to read all right so that's how you you know override constructors like that now inside of here let's override this mint function as well okay let's basically add some extra behavior we want to preserve this minute function we still want to keep track of the balance but we also want to just do some extra stuff let's keep track of the people who actually own the tokens so first we'll say i'll keep an array of owners we'll say address this will be array of addresses say public owners all right and then we'll say we'll keep a counter cache with the people who own the token say uint 256 owner count all right and now we will update these values in our own min function so we're going to create a mint function that basically preserves the functionality of this but adds some additional behavior so we say that is going to be function mint so we're going to override it say public okay so first thing we want to do is call this mint function so that this you know behavior is preserved we just say super mint all right and now we say owner count plus plus we say owners push msg.sender okay and that is basically going to um call the met function the parent contract to uh update the balances then it will increment the number of people who own the token right here and it will um add them to the array of owners okay all right so now let's just compile it run it and so when we do this we don't have to deploy two smart contracts all we have to do is deploy this one so you can say your rc20 token see the string actually let's do this let's do my token so string name will be my token and symbol will be mtk deploy all right so let's call the mint function all right it worked so let's see the balances of the current the current address that we're connected with we'll say balance is this okay all right we'll do the uh name my token and the owners of the first person in the list is our address and a symbol okay all right and we could also make this public if you want to read the owner count all right guys so that's how you inherit smart contracts in solidity i'm going gonna be talking about two different topics in this video that are somewhat related the first topic is uh libraries how to use them in solidity and the second topic is math you know how to do math in the solidity programming language and these are somewhat related because you know we use libraries to uh manage math functions all the time in solidity um is a really common use case so i figured i would just record both of those in the same video so you know what is a library if you're not familiar you know library is basically a way uh to organize code that can be reused in multiple places inside your project so that's one of the main reasons we use libraries essentially to dry code up so if you're not familiar with dry dry that's an acronym for don't repeat yourself right so basically if we have a function that we want to use in multiple smart contracts we could define inside of a library and then use that library to use that function and that way if that function ever changes the change is absorbed by any place that we use it so how do we declare a library in solidity well like this first we use the library keyword say library and i'm going to call this library just math okay so in the earlier videos you know i said that you know smart contracts um are the main way that we organize code inside of solidity uh you know it's called a contract oriented language and that's true but we also have libraries where we can you define functions inside of here and store variables and things like that and that's another way to organize code inside solidity but really at the end of the day a library belongs you know inside of a smart contract so it can get called and used you know libraries don't have the full behavior of a smart contract they don't really have storage in and of themselves they don't um you know you can't inherit from a library things like that so it's not really like a smart contract at the end of the day it's meant to be used inside of a smart contract so we can define a function inside a library like this i'm going to create my own divide function say function divide all right i'll just leave this here for a second so why we want to use divide function well i'll show you let's create an example inside of my contract where we would you know basically just do some math first of all we'll declare a value we'll say unit 256. say public value we'll just store the value here and now i'll actually store this value up but we'll we'll compute it so we'll say function i'll say calculate and we'll take a value we'll say you went we'll say value one i'll say unt value to say public and inside of here we'll basically just set the value to whatever the calculated value is we'll say a value one divided by value two now this is a basic way to do division inside of solidity we just use this operator here it's the division operator so why might we want to use a library for this well you might notice a problem it's value two what if value two is zero right there be a problem with this we get some sort of uh exception because you know we can't divide by zero and that's a really common use case for a library basically we can write some code inside of here that prevents this divide by zero error we can actually stop the function before that happens so basically we could do like this we could define this function and say divide is equal to you know the input let's say you went 256 let's just say a you went 256 b we'll say internal pure returns you want 256. and we'll do the division inside of here say require that b is greater than zero that's the first thing we'll do we'll take the denominator and make sure the denominator is greater than zero so that we don't divide by zero then we'll actually create a return value of c which is c divided by b or the numerator divided by the denominator and we'll just return that value return c sorry this is supposed to be a so now we can actually use this divide instead of this divide here as a safer way to do division inside of solidity that's a really common use case for a library so how do we do that how do we take this function out of this library and uh use it inside this calculate function like this well we can say math dot divide and then just pass in value 1 and value 2 and we store the output to value just like that all right now i'll erase this all right now let's try to run this code so whenever we deploy this i'm going to select my contract instead of math and whenever this is decompiled and deployed um it knows that my contract depends upon math so it's already going to get compiled and deployed automatically we don't have to deploy this first and then this this in the whole compilation process of this file the math library at least the part that gets used is going to get compiled because it's dependent upon right here so let's try this first we can see the value is 0 and we'll say value 1 is say 100 and value 2 is 10 all right okay that was successful we see the value is 10. now it happens if we try to divide by zero calculate and we get an error just as we expect you know we can also do some other values just to make sure it works say 144 divided by 12 should also be 12. yep all right so that's how you uh you know that's a basic example of how you import a math function from a library now there are a few other ways we can do this you know instead of having this uh library just at the top of our file here we can actually move it to another file and import it inside of this file so we can clean this up and we're only looking at one you know sort of unit at a time we like to look at the smart contract we don't have to look at this library so i'll show you how to do that we'll go over here to our browser and we'll create a new file we'll call this math does so well all right now we'll just copy the math library from here we'll actually just uh copy it with the solidity programming language declaration and we'll paste it in here save now we can require the file just like this we say import we use double quotes math so well all right and notice i use the dot to indicate the current directory forward slash then the file name which is math.sol followed by semicolon all right that'll do the same thing so we can go back to here and deploy this say math sorry go to my contract and deploy and we'll see say 188 and 9. all right there we go that's doing integer division that's why it's uh has no remainder okay so that's how you import a library from another file in solidity now i'll show you one more thing i want to introduce you to a really common library which is called safe math which is put out by open zeppelin you can go to that repository here if you want to read more about it basically it implements a lot of uh helpful functions that i use a lot when developing smart contracts and doing math they've you know um they they solved a lot of problems like guarding from overflow and things like that um and so i use this library a lot so it's a really common use case for me i'm going to show you how to use that library inside of here because it works a little bit differently than how we implemented our math library so i'm going to delete this file and create a new one say safe math i'm just going to copy the code here from github click edit and go oh sorry not edit i want to do raw i'm just going to copy all that go back to remix and paste this in here all right now let's actually change the selective programming language version so 0.5.1 i think it should probably be up to date oops yep looks good all right so let's save that go back to my contract instead of importing math we'll do safe math all right and instead of you know calling a library like this we're gonna do a different way all right and this is pretty cool so we can take all these functions in here like multiply and divide and subtract and add we can actually call them on unsigned integers directly all right and we do that like this we can say using safe math for unit 256 all right now that's pretty cool i'll show you what that does instead of doing this we can basically say uh value one div value two there you go that's pretty slick so let's try that uh go to mic on track we'll deploy click this value value uh one would be 144 and value 2 is 12. all right value it's 12. there we go say 133 33 by 11. yeah 100 divided by 10. there we go awesome all right so that's all i got for this video today guys again you can find all the code examples of this on my website over at dap university dot com forward slash article forward slash solidity tutorial i'll put a link to that down in the description below and again if you're serious about becoming a blockchain developer you need to join my free training on my website over at dappydiversity.com forward slash boot camp alright until next time thanks for watching dap university
