With timestamps:

00:01 - hello my name is utab Saha I'm a teacher
00:03 - for free code Camp the goal of this
00:06 - tutorial series is to learn the skills
00:08 - of a senior software developer in this
00:11 - tutorial we're going to chat with a
00:13 - senior developer we'll walk through a
00:15 - specific challenge that he faced and get
00:17 - into the nitty-gritty of how he thought
00:19 - about it what was a stop process and
00:21 - then we're going to do something new
00:22 - that I haven't done before we're going
00:24 - to walk through some code that he wrote
00:27 - One caveat it did get a little
00:28 - complicated don't worry about
00:30 - understanding every single line of code
00:32 - that he wrote instead pay attention to
00:35 - what comes afterwards the key takeway or
00:38 - the Insight that you can then apply to
00:41 - your own code finally there will be a
00:43 - call to action where I'll explain how
00:46 - you can build something for your
00:48 - portfolio that demonstrates the skills
00:50 - you see in this video today we're here
00:53 - with Mike
00:54 - triten who previously worked at Google
00:58 - and within Google he worked on on the
01:00 - search engine itself which uh you can
01:02 - imagine Google might be pretty
01:03 - protective of that code more recently he
01:07 - co-founded a company called
01:09 - WorkFlowy which is a way of organizing
01:12 - your thoughts plans to-do lists and um
01:17 - it's pretty cool last time I asked it
01:18 - had around 1 million users I myself use
01:21 - it for a few
01:23 - things and this is me
01:27 - udab so today Mike is going to talk
01:29 - about a specific skill that he believes
01:32 - separates senior developers from Junior
01:35 - developers and that is a skill of
01:38 - knowing how to organize your code so uh
01:42 - that could mean for example organizing
01:44 - it so that it's flexible to change in
01:46 - case the requirements of your project
01:49 - change and it could mean a lot of other
01:51 - things too and let's hear how Mike
01:53 - thinks about it you said flexible to
01:56 - change I think that's a good that's a
01:58 - good point and and I guess flexible to
02:01 - change partly
02:02 - means understandable by other people or
02:06 - understandable by yourself three months
02:07 - from now um because I would I would say
02:10 - that that is a big thing I've noticed
02:12 - among less experienced programmers is is
02:16 - um the tendency to write code in kind of
02:19 - an ad hoc way where it makes sense like
02:23 - in a particular frame of mind at a
02:26 - particular time but then even for that
02:28 - developer three months later I've seen
02:31 - people have a lot of trouble making
02:33 - changes to their own code because it
02:35 - wasn't it wasn't kind of structured in a
02:37 - way which at a like maybe each function
02:41 - made sense but at a more high level um
02:43 - there wasn't some sort of overarching
02:46 - thought process regarding the structure
02:48 - and the uh the code and the data
02:50 - structures used and such so it doesn't
02:52 - it doesn't have kind of like a logical
02:54 - Simplicity to it um and it's hard hard
02:58 - for anyone else to make changes to or or
03:00 - even the same person who wrote it later
03:02 - down the road to
03:04 - me okay great so Mike I'm hearing that
03:08 - you have a particular passion for this
03:13 - skill writing well-designed code that's
03:15 - flexible to change I'm wondering if we
03:18 - could drill into that a little bit more
03:21 - and I'm wondering if there's a specific
03:25 - example from
03:28 - your history maybe a challenging
03:30 - situation that you've dealt with that
03:33 - could maybe demonstrate how you
03:35 - approached
03:37 - this uh this issue of of how to design
03:40 - your code well sure so um I mean we can
03:44 - talk about this VR side project that
03:46 - I've been having which is like pretty
03:49 - early stages um and doesn't do a whole
03:52 - lot yet but I've definitely had to uh
03:55 - think a lot about I I'll just kind of
03:57 - describe the general idea of it so
04:00 - partly to kind of like get started on on
04:02 - doing this development I'm not sure how
04:04 - serious I am about this project in terms
04:06 - of like making it into a real
04:08 - professional thing but the thing I'm
04:10 - starting out with is a VR music
04:11 - visualizer so um I don't know if
04:15 - everyone is familiar with music
04:16 - visualizer but like you can see them in
04:19 - like iTunes and this older program
04:21 - called Winamp uh where you know you can
04:23 - play your MP3s or whatever kind of audio
04:26 - you have and um you'll see often kind of
04:29 - Tri
04:30 - psychedelic visuals that are you know
04:33 - will move around in response to like
04:35 - what's going on in the music um so you
04:37 - know I thought this would be a cool
04:38 - thing to experiment with in VR where you
04:41 - are kind of inside the visualization
04:44 - instead of just looking at it on your
04:45 - screen um sure so um this has been a
04:50 - project which I keep keeps ending up
04:53 - being more complicated than I originally
04:54 - thought it was going to be which I think
04:56 - is pretty typical of software projects I
04:58 - think it's especially typical of
05:00 - projects when you're going into a new
05:01 - area you don't have that much experience
05:05 - with maybe it would be helpful just to
05:07 - know at a high
05:09 - level what are even the how do you even
05:13 - approach something like this what's like
05:15 - the overall strategy for building this
05:17 - right so I think I I like to design
05:20 - things in a top down way at the
05:22 - beginning so I think you know first of
05:23 - all what am I trying to do here I'm
05:25 - trying to make computer Graphics do
05:28 - stuff and resp response to music so I
05:31 - mean that suggests I would say three
05:35 - components at the very least those three
05:37 - components being one capturing the music
05:40 - and and I guess I would say that I
05:42 - wanted to be able to capture the music
05:44 - the operating system is playing um as
05:48 - opposed to making like an MP3 player
05:50 - within my software um partly because I
05:52 - wanted to avoid having to write that
05:53 - code and partly to allow people to like
05:55 - play Spotify or whatever and View and
05:58 - use that audio um so so that suggests
06:02 - step one capture the audio step two
06:05 - process the audio for information that
06:08 - can be used to drive a visualization um
06:11 - because without any processing all you
06:13 - have is this time ordered list of audio
06:16 - samples which are just numbers and all
06:19 - you really know from that is like what
06:20 - the average amplitude of the sound is at
06:22 - a particular time you don't really have
06:24 - any more interesting information about
06:26 - it so um so you need to process audio
06:29 - and then the third step would be
06:32 - generate Graphics based on the processed
06:34 - audio okay um so those are those are
06:38 - sort of like the the bare minimum
06:40 - possible things so I knew I was going to
06:42 - have to do those three things um but
06:45 - then then I then I but then that doesn't
06:47 - necessarily suggest how the code is
06:51 - organized um so for so so what I decided
06:54 - to do was I basically have one component
06:56 - that captures the music and um and that
06:59 - component is a C++ class um that uh it
07:04 - that class encapsulates A lot of
07:06 - platform specific code and by that I
07:08 - mean Windows operating system code
07:11 - because this is running on Windows um so
07:14 - that that's one thing I generally try to
07:16 - do is if I'm writing platform specific
07:18 - code I try to isolate it into as small
07:20 - of an area as possible um because one
07:24 - one alternative would be to be you know
07:26 - like intermingling the audio capturing
07:28 - code with the audio processing code um
07:31 - the problem with that being that if if
07:33 - you wanted to Port the application to
07:35 - another operating system you would have
07:38 - a a much larger chunk of code where you
07:40 - were making changes as opposed to just
07:42 - swapping out the windows audio capturing
07:45 - class with the Mac audio capturing class
07:48 - basically to have all of that code and
07:51 - nothing else in a single module with a
07:55 - generic interface that didn't assume
07:57 - that it was for Windows
08:01 - right um and and so that was one
08:03 - decision I made was to decouple the
08:05 - audio capturing from the audio
08:07 - processing
08:09 - code okay we've thrown around a bunch of
08:12 - Concepts here platform specific code the
08:15 - capsulation generic interfaces
08:17 - decoupling what do all these things mean
08:20 - let's take a look at a quick example so
08:22 - here I have this function extract audio
08:25 - that's going to read in the audio data
08:27 - in a Json file
08:31 - here and it's just going to print out
08:33 - that data notice here that the C colon
08:36 - in the file path means that it only
08:38 - works on Windows this is an example of
08:41 - platform specific code if I were to run
08:43 - this on my Mac it wouldn't work to make
08:46 - this code more portable to other
08:48 - platforms we'll put all the platform
08:50 - specific code inside of a separate
08:53 - module here we have a module Windows
08:55 - code notice that the file path is now
08:58 - stored in a very variable called audio
09:00 - location now I'll import the
09:04 - module and call it platform specific
09:07 - code and I'll refer to its audio
09:11 - location
09:13 - [Music]
09:16 - variable in this way the extract audio
09:19 - function no longer needs to know the
09:21 - exact file path that detail is hidden
09:25 - away inside the module behind this
09:27 - generic variable name called audio
09:30 - location this process of hiding details
09:33 - about your data inside of a module is
09:35 - called encapsulation now how do we make
09:38 - this code run on a Mac we can create a
09:40 - new Mac code module and paste in a
09:44 - different file name that's valid on
09:46 - maaps then back in our extract audio
09:50 - function we can simply swap in the Mac
09:53 - module for the windows module and this
09:56 - will just work because the variable name
09:58 - is the same in both the windows code and
10:02 - the Mac code is both it's called audio
10:05 - location in both cases this this is what
10:07 - Mike meant by a generic interface notice
10:11 - that we had to change very little code
10:13 - when switching between Mac and windows
10:16 - uh this that means we can say that the
10:19 - extract audio function and the platform
10:21 - specific code are
10:22 - decoupled okay so you just saw me walk
10:25 - through a very simple example next we'll
10:27 - start getting into the code that m wrote
10:29 - and we'll start with a high level
10:31 - overview of how we organize this code
10:34 - one second here I I want to find a way
10:35 - to draw that somehow um do you have any
10:40 - recommendations I mean you could just
10:42 - have two circles audio capture process
10:45 - or something I don't know okay audio
10:48 - capture and the C I mean the capture is
10:50 - like sending information to the
10:52 - processor something like that with an
10:54 - arrow or whatever okay cool I like that
10:57 - and then uh
11:01 - processing and then you were saying that
11:06 - uh
11:08 - that the platform specific stuff was
11:12 - mainly here in the audio capture land
11:16 - right um yeah well it's it's in terms of
11:20 - audio it's all there no there's no
11:22 - platform specific code in the processing
11:24 - section right and that's that's to make
11:27 - it so in the future if I want to Port
11:29 - this which I may very well want to do I
11:32 - can literally swap in a new audio
11:35 - capture class versus if they were which
11:38 - which will duplicate virtually zero code
11:40 - with the old audio capture class um
11:43 - whereas if
11:44 - I if I had them combined then I would be
11:48 - either duplicating code or be doing a
11:51 - bunch of uh I don't know things would
11:55 - get ugly basically if I didn't decouple
11:58 - them and wanted to extend to another
12:00 - platform so I think that's just a
12:03 - general principle I would say is if if
12:05 - you're doing platform specific code try
12:06 - to have it in as small of a have it as
12:10 - small of an area as possible and with no
12:12 - non-platform specific
12:13 - code so we're about to walk through the
12:16 - code that Mike wrote for his project one
12:19 - warning about this it's written in C++
12:22 - it's complicated it might be hard to
12:23 - follow I don't expect anyone to be able
12:25 - to follow along with all the details
12:27 - here the most important thing
12:29 - look for the key takeaway at the end of
12:31 - this walkthrough where I'll explain what
12:34 - are the main principles here that you
12:36 - can apply to code that you write whether
12:39 - it's C++ or JavaScript or any other
12:42 - language okay so I'm
12:44 - gonna I'm going to briefly show the
12:46 - classes that I was discussing earlier so
12:49 - um we have the first one which is the
12:52 - audio capturing class and
12:55 - uh this um so right now it has has a
12:59 - very simple interface um so it has down
13:01 - here in the bottom it has a bunch of
13:03 - really um because one unfortunate thing
13:06 - about C++ is you have to Define in your
13:08 - header file all the member variables of
13:10 - the class so so I mean they're private
13:13 - so nothing else can actually access them
13:15 - but it does create this kind of massive
13:17 - indecipherable stuff anyway on the
13:20 - bottom we have indecipherable Windows
13:21 - specific stuff but then on the top in
13:24 - the public section we can see there's
13:26 - this
13:27 - Constructor um which is it it basically
13:30 - takes no arguments you can take one
13:31 - argument to write the captured audio to
13:33 - an output file and then it has two
13:36 - methods um one to get the sampling rate
13:39 - um of the audio like you know CD quality
13:42 - audio would be 44.1 khz um and then this
13:47 - call back or or this function process
13:49 - new frames so a frame is a collection of
13:51 - audio samples captured from the
13:53 - operating system and then that takes a
13:56 - call back and um I uh if I remember
13:59 - correctly I think I used a callback um
14:02 - to avoid having to do unnecessary data
14:05 - copying um basically it's kind of like a
14:09 - a optimization type thing but it's done
14:11 - in a way where it doesn't really add
14:13 - much additional complexity so basically
14:15 - you call Process new frames to get the
14:18 - most recent audio that the operating
14:21 - system is outputting um and you give it
14:23 - a call back which takes a pointer to the
14:27 - uh the audio samples and how many of
14:31 - them there are um so uh you can see that
14:35 - I I'll just briefly look at the
14:36 - implementation of that just to show how
14:38 - incredibly long- winded and ugly it is
14:42 - so we have like cocreate instance uuid
14:46 - all this I mean basically there's just
14:48 - like pages of of like I mean it's kind
14:52 - of crazy how much code needs to be
14:55 - involved just to capture audio anyway
14:58 - that is why in its own classes so all
14:59 - that stuff is not elsewhere um so then
15:02 - we have um so I think well briefly
15:05 - there's I separated I have the
15:07 - application which the way I view the
15:10 - application is it's it's the thing which
15:12 - is actually um visualizing music it's
15:16 - not it's not capturing the audio it's
15:18 - not processing the audio it's not like
15:19 - setting up the windows the window it's
15:22 - not like talking to the VR device it's
15:25 - just like generating a scene and then
15:28 - rendering it um so what is this
15:32 - application class in relation to the two
15:37 - decoupled modules we talked about
15:38 - earlier there's a capture and the
15:40 - processor where does application fit
15:42 - into
15:43 - this um okay so the application so if I
15:46 - remember correctly the application is
15:50 - instantiating the processor so the
15:53 - application actually owns the uh the
15:57 - application owns an audio processor
15:59 - object which is defined right here and
16:02 - um but but the uh so I have another
16:05 - section of code which is the platform
16:08 - specific non- application code which is
16:11 - the code which is like you know like
16:13 - capturing keyboard input and on Windows
16:16 - and like opening up the window on
16:18 - Windows setting like initializing the VR
16:21 - headset so and also initializing the
16:23 - autoc capturing code so basically the
16:26 - the application is getting sense
16:29 - uh audio frames from the audio capturer
16:32 - using this method I'm highlighting and
16:34 - then it's passing those on to the oh
16:37 - sorry to the audio processor which it
16:40 - instantiates um I could I could have had
16:42 - the audio processor be something which
16:43 - is owned outside of the application
16:46 - module but I decided that I think I
16:48 - basically decided that all I was going
16:50 - to have the application own all not
16:52 - non-platform specific code all right so
16:55 - I want to emphasize an important
16:57 - principle that came up in how Mike
16:59 - organized his code he paid special
17:02 - attention to managing dependencies in
17:04 - his code so first of all what is a
17:07 - dependency a dependency occurs when one
17:10 - piece of your software relies on another
17:13 - piece now in Mike's Music visualizer the
17:17 - music visualization logic depends on
17:20 - audio captured from the operating system
17:23 - so the app depends on the operating
17:25 - system now Mike Mike was concerned about
17:29 - the this dependency and here is a cue
17:32 - that he noticed that let him know that
17:34 - hey there's something dangerous about
17:36 - this there are two factors one how is
17:40 - How likely is the dependency to change
17:42 - significantly in the future and two how
17:45 - many parts of the code touch this
17:48 - dependency if both of these numbers are
17:50 - high this can create problems because
17:53 - then you may find yourself having to
17:54 - rewrite many parts of your code base
17:57 - over time so in Mike's Music visualizer
18:01 - the operating system could change in a
18:03 - very big way let's say he moved from a
18:05 - Windows platform to a Mac well Mac could
18:08 - have a very different way of capturing
18:11 - audio so it could change in a pretty big
18:14 - way this number was high now what about
18:16 - number two how many parts of the code
18:18 - touch this dependency well it turns out
18:20 - that the music visualizer needs to
18:22 - interact with the operating system in a
18:24 - few different ways and it required a lot
18:27 - of ugly code as Mike put it so this
18:30 - number is high
18:32 - too okay so this was concerning to Mike
18:36 - because if the operating system ever
18:38 - changed well he would need to rewrite a
18:41 - bunch of code many every part of his
18:44 - music visualizer logic that interacted
18:46 - with the operating system so he designed
18:49 - his code in such a way to make it
18:51 - flexible to changing the operating
18:54 - system now the solution for this
18:57 - situation that he came up with was well
19:01 - since this number is high let's try to
19:02 - reduce this number and reduce the number
19:05 - basically reduce a number of parts of
19:07 - his code that interacted with the
19:09 - dependency and he did this by
19:11 - introducing an audio capture class now
19:13 - all of the operating system interactions
19:17 - are now handled in here you could say he
19:20 - took all of the operating system logic
19:22 - and isolated them in one place meanwhile
19:26 - the music visualization Cod code only
19:28 - interacts with the audio capture class
19:31 - with this one function
19:34 - process new
19:37 - frames this process is called decoupling
19:40 - or you can say that these two things the
19:44 - music visualizer logic and the operating
19:46 - system dependency are now Loosely
19:48 - coupled the advantage of this is this
19:51 - allows Mike to swap in a totally
19:53 - different operating system in the future
19:55 - and none of this music visualization
19:58 - code which is the core business logic of
20:00 - his app would have to change okay I want
20:03 - to address some of the nuances around
20:06 - this topic of dependencies you saw one
20:09 - example here how the dependency was
20:12 - concerning to Mike and so he put that
20:15 - dependency in a small part of the code
20:17 - base and minimized how often other parts
20:20 - of the code touched it that's definitely
20:22 - a pattern that you can learn from and
20:23 - apply to your own code but I want to
20:26 - emphasize the dependencies are not
20:28 - always bad uh remember the key cue here
20:31 - was the dependency changed a lot and
20:34 - many parts of the code base touched the
20:36 - dependency there are other situations
20:38 - like the dependency might not change a l
20:41 - or it could be somewhere in between and
20:45 - uh there's there's a lot of nuances here
20:47 - so um in fact these nuances were covered
20:51 - in the original case study I did with
20:52 - Mike but it was just too much
20:54 - information to put in one video
20:56 - so all release another video covering
21:00 - some of those nuances from the original
21:03 - uh interview I did with
21:06 - Mike okay you've seen Mike demonstrate
21:09 - the skill of how he organizes his code
21:12 - and I've shown you a key takeaway that
21:13 - you can start applying in your own code
21:15 - that you write now I want to make sure
21:18 - that you do actually write some code
21:20 - that demonstrates the skill I want you
21:22 - all to have a solid portfolio project
21:24 - that you can showcase at your next job
21:25 - interview in front of your future
21:27 - employer where you can explain the
21:29 - nuances of why you organized the code
21:31 - the way that you
21:33 - did one powerful way to build your
21:36 - portfolio is to contribute to an open
21:38 - source project now free code Camp
21:40 - happens to be the most starred project
21:42 - on GitHub it's a respected open source
21:44 - project and I've put together a guide
21:47 - which will help you get up to speed on
21:49 - the codebase and start contributing you
21:51 - can go over to arena.com freecamp to get
21:55 - that for free look down in the
21:57 - description below the video for a link
21:59 - to that and um as an extra bonus if you
22:03 - go through the guide I'll personally
22:05 - help you find a feature that you can
22:06 - build for free code camp and I'll help
22:09 - you get started I'll even give you some
22:11 - pointers on how to think about
22:12 - organizing your code for the feature
22:14 - that you buil all right now I have
22:16 - another call to action specifically for
22:18 - folks who are from minority groups that
22:21 - are underrepresented in Tech like racial
22:23 - minorities and women this goes back to
22:26 - the reason that I teach people to code
22:29 - and the reason that I make these videos
22:31 - I personally enjoy a lot of mentorship
22:33 - growing up and I believe this is the
22:35 - main reason I was able to even have a
22:37 - career as a software developer I believe
22:40 - that if everyone enjoyed as much
22:42 - mentorship as I did then everyone could
22:45 - also find their dream Tech job just like
22:47 - I did I believe this so much that I bet
22:49 - my future on this I left my job as a
22:52 - software developer two years ago to help
22:55 - develop a system of mentorship that
22:57 - won't cost you any to enter in fact you
22:59 - can even get paid as you as you're going
23:01 - through the program you can find out
23:03 - more about this at arena.com
23:07 - freecamp all right thanks everyone for
23:09 - watching stay tuned for more videos if
23:12 - you have feedback on what you liked
23:13 - about these videos or what I can do to
23:15 - make them better please leave comments
23:17 - down below or reach me at utab arena.com
23:20 - I got some great feedback from a few of
23:23 - you last time so please keep doing that

Cleaned transcript:

hello my name is utab Saha I'm a teacher for free code Camp the goal of this tutorial series is to learn the skills of a senior software developer in this tutorial we're going to chat with a senior developer we'll walk through a specific challenge that he faced and get into the nittygritty of how he thought about it what was a stop process and then we're going to do something new that I haven't done before we're going to walk through some code that he wrote One caveat it did get a little complicated don't worry about understanding every single line of code that he wrote instead pay attention to what comes afterwards the key takeway or the Insight that you can then apply to your own code finally there will be a call to action where I'll explain how you can build something for your portfolio that demonstrates the skills you see in this video today we're here with Mike triten who previously worked at Google and within Google he worked on on the search engine itself which uh you can imagine Google might be pretty protective of that code more recently he cofounded a company called WorkFlowy which is a way of organizing your thoughts plans todo lists and um it's pretty cool last time I asked it had around 1 million users I myself use it for a few things and this is me udab so today Mike is going to talk about a specific skill that he believes separates senior developers from Junior developers and that is a skill of knowing how to organize your code so uh that could mean for example organizing it so that it's flexible to change in case the requirements of your project change and it could mean a lot of other things too and let's hear how Mike thinks about it you said flexible to change I think that's a good that's a good point and and I guess flexible to change partly means understandable by other people or understandable by yourself three months from now um because I would I would say that that is a big thing I've noticed among less experienced programmers is is um the tendency to write code in kind of an ad hoc way where it makes sense like in a particular frame of mind at a particular time but then even for that developer three months later I've seen people have a lot of trouble making changes to their own code because it wasn't it wasn't kind of structured in a way which at a like maybe each function made sense but at a more high level um there wasn't some sort of overarching thought process regarding the structure and the uh the code and the data structures used and such so it doesn't it doesn't have kind of like a logical Simplicity to it um and it's hard hard for anyone else to make changes to or or even the same person who wrote it later down the road to me okay great so Mike I'm hearing that you have a particular passion for this skill writing welldesigned code that's flexible to change I'm wondering if we could drill into that a little bit more and I'm wondering if there's a specific example from your history maybe a challenging situation that you've dealt with that could maybe demonstrate how you approached this uh this issue of of how to design your code well sure so um I mean we can talk about this VR side project that I've been having which is like pretty early stages um and doesn't do a whole lot yet but I've definitely had to uh think a lot about I I'll just kind of describe the general idea of it so partly to kind of like get started on on doing this development I'm not sure how serious I am about this project in terms of like making it into a real professional thing but the thing I'm starting out with is a VR music visualizer so um I don't know if everyone is familiar with music visualizer but like you can see them in like iTunes and this older program called Winamp uh where you know you can play your MP3s or whatever kind of audio you have and um you'll see often kind of Tri psychedelic visuals that are you know will move around in response to like what's going on in the music um so you know I thought this would be a cool thing to experiment with in VR where you are kind of inside the visualization instead of just looking at it on your screen um sure so um this has been a project which I keep keeps ending up being more complicated than I originally thought it was going to be which I think is pretty typical of software projects I think it's especially typical of projects when you're going into a new area you don't have that much experience with maybe it would be helpful just to know at a high level what are even the how do you even approach something like this what's like the overall strategy for building this right so I think I I like to design things in a top down way at the beginning so I think you know first of all what am I trying to do here I'm trying to make computer Graphics do stuff and resp response to music so I mean that suggests I would say three components at the very least those three components being one capturing the music and and I guess I would say that I wanted to be able to capture the music the operating system is playing um as opposed to making like an MP3 player within my software um partly because I wanted to avoid having to write that code and partly to allow people to like play Spotify or whatever and View and use that audio um so so that suggests step one capture the audio step two process the audio for information that can be used to drive a visualization um because without any processing all you have is this time ordered list of audio samples which are just numbers and all you really know from that is like what the average amplitude of the sound is at a particular time you don't really have any more interesting information about it so um so you need to process audio and then the third step would be generate Graphics based on the processed audio okay um so those are those are sort of like the the bare minimum possible things so I knew I was going to have to do those three things um but then then I then I but then that doesn't necessarily suggest how the code is organized um so for so so what I decided to do was I basically have one component that captures the music and um and that component is a C++ class um that uh it that class encapsulates A lot of platform specific code and by that I mean Windows operating system code because this is running on Windows um so that that's one thing I generally try to do is if I'm writing platform specific code I try to isolate it into as small of an area as possible um because one one alternative would be to be you know like intermingling the audio capturing code with the audio processing code um the problem with that being that if if you wanted to Port the application to another operating system you would have a a much larger chunk of code where you were making changes as opposed to just swapping out the windows audio capturing class with the Mac audio capturing class basically to have all of that code and nothing else in a single module with a generic interface that didn't assume that it was for Windows right um and and so that was one decision I made was to decouple the audio capturing from the audio processing code okay we've thrown around a bunch of Concepts here platform specific code the capsulation generic interfaces decoupling what do all these things mean let's take a look at a quick example so here I have this function extract audio that's going to read in the audio data in a Json file here and it's just going to print out that data notice here that the C colon in the file path means that it only works on Windows this is an example of platform specific code if I were to run this on my Mac it wouldn't work to make this code more portable to other platforms we'll put all the platform specific code inside of a separate module here we have a module Windows code notice that the file path is now stored in a very variable called audio location now I'll import the module and call it platform specific code and I'll refer to its audio location variable in this way the extract audio function no longer needs to know the exact file path that detail is hidden away inside the module behind this generic variable name called audio location this process of hiding details about your data inside of a module is called encapsulation now how do we make this code run on a Mac we can create a new Mac code module and paste in a different file name that's valid on maaps then back in our extract audio function we can simply swap in the Mac module for the windows module and this will just work because the variable name is the same in both the windows code and the Mac code is both it's called audio location in both cases this this is what Mike meant by a generic interface notice that we had to change very little code when switching between Mac and windows uh this that means we can say that the extract audio function and the platform specific code are decoupled okay so you just saw me walk through a very simple example next we'll start getting into the code that m wrote and we'll start with a high level overview of how we organize this code one second here I I want to find a way to draw that somehow um do you have any recommendations I mean you could just have two circles audio capture process or something I don't know okay audio capture and the C I mean the capture is like sending information to the processor something like that with an arrow or whatever okay cool I like that and then uh processing and then you were saying that uh that the platform specific stuff was mainly here in the audio capture land right um yeah well it's it's in terms of audio it's all there no there's no platform specific code in the processing section right and that's that's to make it so in the future if I want to Port this which I may very well want to do I can literally swap in a new audio capture class versus if they were which which will duplicate virtually zero code with the old audio capture class um whereas if I if I had them combined then I would be either duplicating code or be doing a bunch of uh I don't know things would get ugly basically if I didn't decouple them and wanted to extend to another platform so I think that's just a general principle I would say is if if you're doing platform specific code try to have it in as small of a have it as small of an area as possible and with no nonplatform specific code so we're about to walk through the code that Mike wrote for his project one warning about this it's written in C++ it's complicated it might be hard to follow I don't expect anyone to be able to follow along with all the details here the most important thing look for the key takeaway at the end of this walkthrough where I'll explain what are the main principles here that you can apply to code that you write whether it's C++ or JavaScript or any other language okay so I'm gonna I'm going to briefly show the classes that I was discussing earlier so um we have the first one which is the audio capturing class and uh this um so right now it has has a very simple interface um so it has down here in the bottom it has a bunch of really um because one unfortunate thing about C++ is you have to Define in your header file all the member variables of the class so so I mean they're private so nothing else can actually access them but it does create this kind of massive indecipherable stuff anyway on the bottom we have indecipherable Windows specific stuff but then on the top in the public section we can see there's this Constructor um which is it it basically takes no arguments you can take one argument to write the captured audio to an output file and then it has two methods um one to get the sampling rate um of the audio like you know CD quality audio would be 44.1 khz um and then this call back or or this function process new frames so a frame is a collection of audio samples captured from the operating system and then that takes a call back and um I uh if I remember correctly I think I used a callback um to avoid having to do unnecessary data copying um basically it's kind of like a a optimization type thing but it's done in a way where it doesn't really add much additional complexity so basically you call Process new frames to get the most recent audio that the operating system is outputting um and you give it a call back which takes a pointer to the uh the audio samples and how many of them there are um so uh you can see that I I'll just briefly look at the implementation of that just to show how incredibly long winded and ugly it is so we have like cocreate instance uuid all this I mean basically there's just like pages of of like I mean it's kind of crazy how much code needs to be involved just to capture audio anyway that is why in its own classes so all that stuff is not elsewhere um so then we have um so I think well briefly there's I separated I have the application which the way I view the application is it's it's the thing which is actually um visualizing music it's not it's not capturing the audio it's not processing the audio it's not like setting up the windows the window it's not like talking to the VR device it's just like generating a scene and then rendering it um so what is this application class in relation to the two decoupled modules we talked about earlier there's a capture and the processor where does application fit into this um okay so the application so if I remember correctly the application is instantiating the processor so the application actually owns the uh the application owns an audio processor object which is defined right here and um but but the uh so I have another section of code which is the platform specific non application code which is the code which is like you know like capturing keyboard input and on Windows and like opening up the window on Windows setting like initializing the VR headset so and also initializing the autoc capturing code so basically the the application is getting sense uh audio frames from the audio capturer using this method I'm highlighting and then it's passing those on to the oh sorry to the audio processor which it instantiates um I could I could have had the audio processor be something which is owned outside of the application module but I decided that I think I basically decided that all I was going to have the application own all not nonplatform specific code all right so I want to emphasize an important principle that came up in how Mike organized his code he paid special attention to managing dependencies in his code so first of all what is a dependency a dependency occurs when one piece of your software relies on another piece now in Mike's Music visualizer the music visualization logic depends on audio captured from the operating system so the app depends on the operating system now Mike Mike was concerned about the this dependency and here is a cue that he noticed that let him know that hey there's something dangerous about this there are two factors one how is How likely is the dependency to change significantly in the future and two how many parts of the code touch this dependency if both of these numbers are high this can create problems because then you may find yourself having to rewrite many parts of your code base over time so in Mike's Music visualizer the operating system could change in a very big way let's say he moved from a Windows platform to a Mac well Mac could have a very different way of capturing audio so it could change in a pretty big way this number was high now what about number two how many parts of the code touch this dependency well it turns out that the music visualizer needs to interact with the operating system in a few different ways and it required a lot of ugly code as Mike put it so this number is high too okay so this was concerning to Mike because if the operating system ever changed well he would need to rewrite a bunch of code many every part of his music visualizer logic that interacted with the operating system so he designed his code in such a way to make it flexible to changing the operating system now the solution for this situation that he came up with was well since this number is high let's try to reduce this number and reduce the number basically reduce a number of parts of his code that interacted with the dependency and he did this by introducing an audio capture class now all of the operating system interactions are now handled in here you could say he took all of the operating system logic and isolated them in one place meanwhile the music visualization Cod code only interacts with the audio capture class with this one function process new frames this process is called decoupling or you can say that these two things the music visualizer logic and the operating system dependency are now Loosely coupled the advantage of this is this allows Mike to swap in a totally different operating system in the future and none of this music visualization code which is the core business logic of his app would have to change okay I want to address some of the nuances around this topic of dependencies you saw one example here how the dependency was concerning to Mike and so he put that dependency in a small part of the code base and minimized how often other parts of the code touched it that's definitely a pattern that you can learn from and apply to your own code but I want to emphasize the dependencies are not always bad uh remember the key cue here was the dependency changed a lot and many parts of the code base touched the dependency there are other situations like the dependency might not change a l or it could be somewhere in between and uh there's there's a lot of nuances here so um in fact these nuances were covered in the original case study I did with Mike but it was just too much information to put in one video so all release another video covering some of those nuances from the original uh interview I did with Mike okay you've seen Mike demonstrate the skill of how he organizes his code and I've shown you a key takeaway that you can start applying in your own code that you write now I want to make sure that you do actually write some code that demonstrates the skill I want you all to have a solid portfolio project that you can showcase at your next job interview in front of your future employer where you can explain the nuances of why you organized the code the way that you did one powerful way to build your portfolio is to contribute to an open source project now free code Camp happens to be the most starred project on GitHub it's a respected open source project and I've put together a guide which will help you get up to speed on the codebase and start contributing you can go over to arena.com freecamp to get that for free look down in the description below the video for a link to that and um as an extra bonus if you go through the guide I'll personally help you find a feature that you can build for free code camp and I'll help you get started I'll even give you some pointers on how to think about organizing your code for the feature that you buil all right now I have another call to action specifically for folks who are from minority groups that are underrepresented in Tech like racial minorities and women this goes back to the reason that I teach people to code and the reason that I make these videos I personally enjoy a lot of mentorship growing up and I believe this is the main reason I was able to even have a career as a software developer I believe that if everyone enjoyed as much mentorship as I did then everyone could also find their dream Tech job just like I did I believe this so much that I bet my future on this I left my job as a software developer two years ago to help develop a system of mentorship that won't cost you any to enter in fact you can even get paid as you as you're going through the program you can find out more about this at arena.com freecamp all right thanks everyone for watching stay tuned for more videos if you have feedback on what you liked about these videos or what I can do to make them better please leave comments down below or reach me at utab arena.com I got some great feedback from a few of you last time so please keep doing that
