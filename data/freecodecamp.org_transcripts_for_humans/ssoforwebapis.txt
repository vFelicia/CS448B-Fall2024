With timestamps:

00:01 - [Applause]
00:01 - [Music]
00:06 - okay welcome
00:08 - nice to meet you
00:11 - to one of the most annoying topics of
00:13 - development security
00:17 - okay
00:19 - my name is nico quibbler i'm from
00:21 - germany i'm a freelance guy and
00:25 - i'm more than 20 years in i.t business i
00:28 - recognize it a few weeks ago when i got
00:32 - my new fitness tracker it has a very
00:34 - small display and i
00:36 - have to put my wrist far away from my
00:38 - eyes so i'm
00:40 - getting pretty old
00:42 - um besides my day job i co-organizing a
00:45 - local java user group in darmstadt it's
00:47 - nearby frankfurt and speak occasionally
00:50 - at tech conferences all over the world
00:53 - and last year i wrote a book about
00:55 - serverless computing in the cloud but
00:58 - that's not the topic i will talk
01:00 - about today and of course as every
01:03 - speaker and developer or whatever guy
01:05 - i'm on twitter
01:07 - so let's start
01:09 - talking about security
01:11 - who of you
01:12 - likes to
01:14 - deal with security
01:18 - one two three four
01:20 - three and a half okay three and a half
01:22 - it's not that pretty much
01:24 - um so did i
01:27 - until a few years ago
01:31 - the reason was for me i didn't
01:33 - understand it
01:35 - then
01:36 - i took the time and
01:39 - tried to understand it read the specs
01:41 - and suddenly it made hey it's easy it's
01:44 - pretty easy
01:46 - but you have to have to take the time
01:49 - and understand
01:50 - how all this stuff really works
01:53 - and security is a wide range of topics
01:56 - and there are also the
01:58 - overs top 10
02:00 - which deal with the most
02:03 - most frequent security issues
02:06 - and what we don't want to talk about um
02:09 - the the obvious top 10 today we want to
02:11 - talk about authentication and
02:13 - authorization
02:15 - so
02:17 - who of you thinks
02:20 - he or she knows what's the difference
02:22 - because between authorization and
02:24 - authentication
02:27 - okay
02:29 - a bit more than the half
02:33 - it's pretty easy i think but every time
02:35 - i'm talking to customers most of them
02:39 - don't get it right
02:40 - and
02:41 - it's
02:42 - easy as authentication is i don't know
02:45 - who you are please authenticate yourself
02:47 - tell me who you are and
02:50 - how can i make sure that you
02:53 - the person
02:54 - you tell me you are
02:56 - an authorization is the next step after
02:59 - i know who you are
03:01 - i have to check what are you allowed to
03:04 - do
03:04 - this is authorization
03:06 - and
03:09 - yeah
03:11 - also
03:12 - i mix it up
03:14 - still in my daily business business when
03:17 - talking to customers
03:19 - sometimes i say authentication when i
03:21 - mean authorization and vice versa
03:23 - so
03:24 - if i mix it up today
03:27 - please don't be angry with me
03:30 - but um also the http status codes
03:34 - mix it up a bit and these these are
03:36 - pretty old so the guys you made who um
03:41 - who built up the status codes
03:43 - didn't get it either
03:45 - we have the 401
03:46 - which means which which is called
03:49 - unauthorized
03:50 - but it means
03:52 - unauthenticated or not authenticated 401
03:56 - is
03:56 - not really
03:58 - it does not deal with authorization it
04:00 - deals with authentication and once
04:03 - you're authenticated the status code 403
04:06 - tells you
04:07 - you don't you are you're not allowed to
04:10 - do anything you're forbidden
04:12 - so for one unauthorized it's not it's
04:15 - not really correct
04:18 - so
04:22 - and we are in distributed apis
04:25 - nowadays distributed systems distributed
04:28 - apis
04:30 - um
04:31 - at least we have a single page
04:32 - application in the back end that's also
04:34 - a distributed system and
04:37 - how do we log in
04:39 - in such a system
04:41 - in a secure way
04:43 - and when
04:44 - talking
04:45 - when apis are talking to each other we
04:48 - how do they
04:50 - authenticate and authorize
04:52 - each other
04:54 - and when it comes
04:56 - oh yeah
04:59 - when we have distributed apis or
05:00 - distributed systems should we have a
05:02 - centralized approach
05:04 - when it comes to authorization or
05:06 - authentication
05:08 - i think yes because it's called a single
05:10 - sign on and single sign-on means
05:12 - there's only one system who knows my
05:15 - credentials and
05:17 - um which knows how to to
05:21 - verify these credentials
05:23 - and not
05:25 - two or three or more replicated systems
05:28 - with replicated data because then the
05:31 - the
05:32 - data the credential data of our users is
05:34 - replicated
05:36 - and many systems
05:38 - uh have have have a knowledge about this
05:41 - and
05:42 - we don't want to have many systems or
05:45 - more more than one system to have the
05:47 - knowledge
05:48 - how to verify the credentials only one
05:51 - system that's because it it's called
05:54 - single sign-on single-sign-on does not
05:56 - mean our users
05:57 - only have to log in once when they come
06:00 - into the office in the morning and grab
06:02 - a coffee
06:03 - and
06:04 - they can work with uh ff system that's a
06:07 - side effect of single sign-on but not
06:09 - that's not um the root
06:12 - of the word single sign-on the signal is
06:14 - really a single system who knows about
06:17 - our credentials
06:20 - yeah and when
06:22 - it comes to to real users
06:25 - of course they want to have a simple and
06:27 - secure
06:29 - solution
06:31 - and
06:33 - you all know simply simple and secure
06:36 - these are two choose one
06:40 - you always
06:43 - have to choose what is
06:45 - more relevant for you
06:47 - has it to be more simple or has it to be
06:50 - more secure the more secure the less
06:53 - simple
06:54 - um
06:55 - it will be at least for you as a
06:57 - developer
06:58 - if you want to make it simple for the
07:00 - for the users for the end users
07:03 - and secure
07:04 - for the data then
07:06 - the effort is
07:08 - at your side the developers side
07:13 - yeah how do you authenticate
07:16 - of course with our username email
07:19 - whatever a password a simple secret a
07:23 - temporary link or a mobile phone or
07:27 - whatever
07:28 - but
07:29 - then how do we
07:31 - transport these authentication infos to
07:35 - all the systems
07:37 - of course with the token
07:39 - and
07:40 - the token is nothing new
07:44 - already in the beginning of 2000s
07:46 - we have the the summer the security
07:48 - search and markup language which is
07:50 - pretty cool xml no xml and cool doesn't
07:54 - work doesn't fit together
07:57 - it's yeah it's powerful
07:59 - but it's
08:00 - kind of complex and it doesn't feel
08:04 - good and
08:06 - all these claims are difficult to handle
08:09 - and um
08:11 - when we talked today about
08:13 - uh web applications and lightweight
08:17 - um
08:18 - lightweight serialization and such
08:20 - things like json
08:22 - javascript
08:25 - it's really hard to handle xml with
08:28 - javascript
08:30 - i tried it once and i gave up after
08:33 - two days
08:38 - but
08:40 - the token itself is nothing really new
08:45 - and because samoa isn't working pretty
08:48 - good with web technologies in nowadays
08:52 - there's the oauth 2
08:55 - framework or specification
08:58 - which deals with authorization
09:03 - of 2 has nothing to do with
09:05 - authentication
09:06 - it just deals with authorization
09:10 - who is allowed to do what which system
09:13 - may access another system in your name
09:18 - of course you have to be authenticated
09:20 - before you can
09:22 - give
09:24 - another third-party system the authority
09:26 - to access your own system
09:29 - but the authentication process
09:32 - is no standard way
09:34 - when using oauth2
09:36 - or f2 is just authorization
09:39 - and um
09:40 - the
09:41 - the the
09:42 - authentication process is completely
09:45 - different uh implemented when um looking
09:48 - at the oauth implementation of twitter
09:51 - or facebook or github or whatever
09:54 - so
09:56 - you can use
09:58 - the the login feature
10:01 - of
10:02 - twitter or facebook google for your
10:05 - application
10:07 - but that's not really um
10:11 - authentication that's only authorization
10:14 - you grant access to
10:16 - your application to access twitter in
10:19 - your name when you're not
10:21 - in front of your computer
10:25 - and furthermore if you implement many
10:29 - of these providers
10:31 - you have to
10:32 - implement
10:33 - different ways of how to retrieve the
10:36 - user
10:37 - information the user profile information
10:40 - because every response from every system
10:42 - looks different so oauth2 is just for
10:46 - authorization and not for authentication
10:50 - um but it's pretty uh powerful when it
10:52 - comes to uh web
10:55 - web applications
10:56 - or handling in the web and it has
10:59 - different
11:00 - so-called crunch types or authorization
11:03 - flows
11:04 - there if the authorization code flows
11:06 - the standard flow
11:08 - which deals with many redirects between
11:10 - the systems and the browser
11:13 - and simple said
11:16 - the the user
11:18 - wants to access um okay i can show you
11:21 - here
11:22 - an abstract protocol flow
11:24 - the user wants to access
11:27 - a secured
11:30 - resource on the
11:33 - resource server
11:34 - and
11:35 - the resource server says hey you're not
11:38 - authenticated please log in authenticate
11:40 - yourself and then i will see if you're
11:43 - allowed to do
11:45 - and redirects the user to a login page
11:48 - of the authorization server
11:51 - and
11:52 - after the user logs in the authorization
11:54 - server sends back a
11:58 - authorization code
11:59 - that's why it's called authorization
12:01 - code flow
12:03 - and the authorization with the
12:04 - authorization code flow
12:06 - in the browser with a redirect to the
12:10 - application the client wants to access
12:13 - the application itself can
12:15 - grab the token from the
12:18 - authorization server and the token
12:21 - expresses what the user is allowed to do
12:25 - so with the token um the resource server
12:27 - can deliver the protected resource
12:31 - to the client
12:34 - that's the most powerful
12:36 - ground type or author
12:38 - authorization flow
12:40 - authorization code
12:42 - and
12:45 - if you don't have the the possibility to
12:48 - um
12:50 - to take the authorization code flow and
12:54 - um grab the token from the authorization
12:56 - server because that's uh
13:00 - you need you need an additional secret
13:03 - for
13:04 - the
13:05 - for the client fetching the the token at
13:07 - the authorization server and
13:09 - if you can't provide this secret
13:12 - for example in a public
13:15 - website javascript site
13:18 - you need something other because
13:21 - yeah you can somehow encrypt
13:24 - or hash the secret but it's still in the
13:27 - in the front and the browser and the
13:29 - user's
13:31 - device so the secret isn't a secret
13:33 - anymore
13:34 - and therefore you have the implicit flow
13:37 - and with implicit flow
13:39 - you get
13:40 - implicit the token back to the response
13:43 - after the user logs in successfully
13:51 - if you don't have any
13:54 - chances or you don't want to have some
13:56 - redirects between the systems and the
13:59 - user's browser you can use the resource
14:02 - owner password credentials flow
14:04 - it's probably quite a
14:06 - nice word resource owner password
14:07 - credentials
14:08 - i have to read it every time and that's
14:12 - kind uh of an api sending the
14:16 - credentials directly to the
14:17 - authorization server and get back the
14:19 - token
14:21 - but this is the
14:23 - least
14:24 - least secure possibility because
14:30 - you as as the client application
14:34 - have the
14:35 - you have to have the
14:36 - credentials
14:38 - in
14:39 - uh in your application to send it to the
14:41 - authorization server
14:43 - in the regular cases of authorization
14:45 - code or implicit flow
14:47 - the author's authorization server
14:49 - delivers the
14:51 - login page and the user enters his
14:53 - credentials directly at the author
14:55 - authorization server and with the
14:58 - resource owner password credentials flow
15:01 - the
15:02 - user enters the credentials at your
15:04 - application and you take the application
15:07 - the credentials and send them to the
15:10 - authorization server so there are
15:12 - chances for man-to-middle attacks
15:17 - and when it comes to
15:20 - system to system authorization
15:23 - there's the client credentials flow
15:25 - this is
15:26 - just for it's like it's like the the
15:28 - authorization code
15:30 - um or the implicit flow but just for
15:33 - back-end applications there's no browser
15:35 - involved and no redirects
15:39 - and um
15:40 - lastly you have the refresh token flow
15:43 - because um every token has a special
15:47 - lifetime and after the token is invalid
15:50 - you have to renew to refresh the token
15:53 - you can do this with the refresh token
15:55 - flow
16:00 - and that's
16:03 - how the access token response looks like
16:06 - when your application gets
16:10 - the response from the the
16:12 - token fetch or from the authorization
16:14 - server
16:18 - you have the access token itself
16:23 - it can be just a
16:25 - opaque string
16:27 - with no means
16:29 - for
16:30 - outside world
16:31 - the token type is bearer
16:35 - it's always better when dealing with
16:38 - oauth 2
16:39 - this is
16:40 - written in the spec
16:42 - it has an expiry
16:45 - range it expires in 3600 seconds and we
16:49 - have the refresh token with the refresh
16:51 - token you can refresh
16:53 - an invalid access token
16:55 - so normally the access token has a very
16:57 - short lifetime
16:59 - between
17:00 - a few seconds and
17:02 - i say
17:03 - five minutes
17:05 - and the refresh token has a long
17:07 - lifetime
17:08 - um
17:10 - let's say
17:12 - half an hour hour or whatever
17:14 - so um this access token
17:19 - you can take this access token the the
17:21 - string and um
17:23 - to know what
17:25 - your user or your client is allowed to
17:28 - do you have to take this access token
17:30 - and ask the authorization server what is
17:32 - this user with this access token allowed
17:34 - to do
17:37 - and additionally you don't know who is
17:40 - this user
17:42 - you can only check what is this user
17:44 - allowed to do you don't know who is this
17:47 - user
17:48 - and this is where open id connect came
17:50 - in
17:52 - open id connect
17:53 - is not open id it has nothing to do with
17:57 - openid
17:58 - it's just
18:02 - hosted by the open id foundation which
18:05 - is also doing open id
18:07 - and
18:09 - but it's called open id connect and it's
18:11 - based technically is based on
18:14 - oauth2 with a worth two flows
18:18 - and
18:19 - it
18:20 - standardizes
18:22 - profile user profile information and
18:25 - identity information
18:26 - so it brings in an identity token
18:29 - to the additionally to the access token
18:32 - we have an identity token
18:34 - and
18:35 - it adds an
18:37 - user profile endpoint
18:41 - where you can grab
18:44 - identity information profile information
18:46 - of the user with his current access
18:49 - token
18:51 - and a few more
18:55 - restful endpoints for dealing with all
18:57 - this stuff
19:01 - um
19:02 - so this is the identity token coming in
19:04 - into the response we have the access
19:06 - token
19:07 - the refresh token now we have the
19:09 - identity token but how does it look like
19:12 - how is the identity
19:14 - stored into the token
19:16 - and this is where json web tokens
19:19 - come in
19:21 - json web token that's the standard
19:23 - since 2015 three years old
19:26 - and
19:28 - json web tokens are
19:30 - simply
19:31 - three
19:32 - concatenated
19:34 - base64 encoded strings
19:39 - so if the
19:40 - three uh strings mentioned in different
19:43 - colors
19:44 - and what it is like it's it's a header
19:47 - it's payload and it's a signature
19:49 - and if you decode this can you read it
19:52 - yeah i think yes
19:54 - um
19:55 - you see the header it just contains
19:58 - the type
20:00 - the jbt has
20:01 - the jwt has the type jwt okay
20:04 - and the algorithm
20:06 - with which the signature is signed or
20:09 - the signature is
20:12 - created
20:14 - then you have the payload
20:17 - for the payload you have a few reserved
20:20 - claims we come to this in the next slide
20:23 - the possible claims or the attributes
20:25 - are called claims
20:27 - in terms of jwt
20:30 - and
20:32 - the signature
20:33 - is
20:34 - um
20:35 - is a string uh concatenated of a base 64
20:40 - encoded header and payload and depending
20:44 - on the the type of algorithm used um
20:52 - [Music]
20:53 - a synchronized algorithm the hs256 with
20:56 - just a secret or you can use the rs256
20:59 - for a
21:00 - private public key usage
21:04 - so
21:05 - the token itself
21:07 - is so-called self-contained and you can
21:09 - always check if the token
21:13 - was
21:14 - changed by some third party when you get
21:17 - the token
21:19 - and
21:21 - so you have a certain kind of trust
21:23 - level when you get the token if the
21:25 - token itself is valid
21:27 - or is not valid
21:28 - because only if you knew
21:30 - even though the the secret
21:32 - when it comes to
21:34 - synchronized
21:36 - signature or you have to know the
21:38 - private key when dealing with public
21:41 - private public key encryption
21:45 - so you don't have to
21:47 - check the token
21:48 - at a another end point
21:50 - you can this can do this of course if
21:53 - you really
21:54 - need this kind of security but you don't
21:56 - have to
21:57 - use this endpoint
22:02 - yeah the payload itself it has some
22:04 - reserved claims the subject issuer
22:06 - audition and expiry
22:10 - these are the only claims jwt
22:13 - claims for itself the subject is for
22:16 - for whom is the the token issued
22:19 - most of the time this is kind of a user
22:21 - id
22:23 - the issuer is the issuing system
22:26 - represented as an url
22:30 - the audition
22:33 - for which client application
22:36 - this token was
22:38 - issued for my api or for my shop or for
22:42 - whatever system
22:44 - and the expiry date
22:47 - and
22:49 - as the specs says
22:50 - jwt
22:52 - must be used when the expiry date
22:55 - has expired
22:57 - so
22:58 - you have to check the signature if the
23:00 - signature is valid
23:02 - then you can use the token otherwise you
23:04 - must not use this token and um it has to
23:08 - have a valid expiry date
23:11 - the rest of the payload you can choose
23:14 - freely whatever you want to put in the
23:16 - payload
23:19 - as you like
23:21 - open idconnect
23:23 - adds a more
23:24 - some more
23:26 - claims standard claims to the jwt token
23:30 - so if you use jwt in terms of opm id
23:34 - connect
23:35 - you have to use
23:36 - these
23:37 - claims
23:38 - i know i don't know
23:40 - it's difficult to read
23:42 - there was no other way to fit all the
23:44 - information to one slide
23:46 - it's but it's not a website of open id
23:50 - so we have
23:51 - claims for
23:53 - the name the given name the family and
23:54 - the middle name the nickname preferred
23:56 - username and so on
23:58 - also in the bottom you can see
24:00 - there's also address and address is not
24:02 - only a string it's a json object so we
24:04 - have a nested object for the address
24:07 - information
24:09 - and the address object itself is also
24:11 - specified
24:17 - so using jwt
24:20 - changes our access token response
24:23 - to look like this we have the access
24:25 - token the access token itself is
24:27 - when using open id connect
24:30 - also expressed in jwt
24:33 - and
24:34 - we have the token type the expiries in
24:38 - when using jwt you don't need to use
24:42 - this expires in at report
24:44 - because the token itself has an expiry
24:46 - date
24:48 - and you have the identity token in a jwt
24:51 - format and the refresh token also
24:55 - it doesn't make real sense to have the
24:56 - refresh token as a
24:58 - jwt but
25:01 - yeah
25:04 - for simplicity reasons all tokens are
25:06 - jwt tokens
25:09 - the refresh token itself contains just
25:13 - unique string for identifying
25:16 - this
25:18 - session on the authorization server
25:22 - okay and how can this token be used
25:26 - the user after author successful
25:29 - authentication has a token he passes to
25:32 - the web application and the web
25:34 - application itself can pass
25:37 - the same token
25:38 - to
25:40 - backend systems if this application
25:43 - needs to access third-party or
25:45 - further backend systems
25:51 - as we can see later in the demo
25:53 - it's also possible
25:56 - that the web application
26:00 - grabs an own
26:03 - so-called service account token
26:05 - for authentication authenticate
26:07 - authenticating itself against
26:10 - back-end systems or it can
26:13 - pass the the user token to the backend
26:15 - systems
26:18 - so
26:20 - short conclusion for tokens
26:23 - a token is signed we have seen this and
26:25 - contains all necessary necessary
26:27 - information
26:28 - about a user and its roles so in the
26:31 - access token
26:32 - all the roles
26:34 - the user has
26:36 - should be included
26:40 - we have different kinds of tokens with
26:42 - identity tokens refresh tokens access
26:44 - tokens and sometimes you have things
26:46 - like like an offline token
26:49 - an offline token
26:53 - you can
26:54 - a user can
26:55 - can request to have an offline token
26:58 - issued for another application
27:00 - and
27:02 - this this other application can use this
27:04 - offline token for perhaps
27:08 - regular
27:09 - tasks at night when the user is not
27:11 - online
27:13 - creating reports or whatever sending
27:15 - emails to
27:18 - to exchange this offline token to valid
27:20 - access token and act on behalf of the
27:23 - user
27:24 - even if the user is not
27:26 - online
27:27 - but the user has to
27:32 - has to initiate uh the process for um
27:37 - for creating an offline token
27:39 - so there's no global offline token as a
27:42 - system can use to act on behalf of a
27:44 - user
27:46 - the tokens are sent in bearer format
27:48 - most often in the http header
27:51 - authorization
27:53 - and we have a total time to live
27:56 - and of course tokens must be
27:59 - revocable
28:00 - um i forgot this to mention
28:04 - an access token itself
28:06 - once it is issued
28:09 - it doesn't need to be verified at the
28:12 - authorization server i said before
28:15 - that's right because it's
28:17 - um signed and it's self-contained so
28:20 - once it is issued it is well it and
28:22 - every system using it can be uh
28:25 - can be sure that it's valid
28:28 - but what what if um
28:31 - the the the token
28:33 - um is stolen or whatever
28:38 - um
28:39 - that's because the
28:42 - the access token should have a very very
28:44 - short
28:46 - total time to live
28:47 - i recommend most often between 30
28:50 - seconds and two minutes
28:53 - because that's
28:54 - the time amount of time
28:57 - a third party
29:00 - can misuse this token if it gets the
29:03 - token
29:04 - and after this time
29:06 - you have to use the refresh token and to
29:09 - refresh the access token to get a new
29:11 - access token and if you have in the
29:13 - meantime
29:15 - the token the session
29:16 - revoked at the
29:18 - authorization server
29:20 - the server
29:22 - won't access a new exit it won't
29:27 - create a new access token and um
29:31 - and the third party
29:33 - can't use
29:35 - the token anymore
29:36 - so this must be revocable
29:41 - and as i'm a java developer most of the
29:43 - times currently i'm dealing with the
29:45 - javascript
29:48 - i asked myself what does java offer to
29:50 - deal with
29:52 - oauth2 and open id connect
29:55 - and unfortunately it's not that much
29:58 - it's
29:59 - becoming better but
30:03 - it's very sad
30:06 - the big java ee standard now it's called
30:09 - jakarta ieee
30:12 - has a new
30:14 - security api jsrf275
30:20 - which is quite nice this api but
30:23 - it doesn't deal with um
30:25 - off 2 or almighty connect jwt
30:30 - there are some discussions on the on the
30:31 - mailing list
30:33 - and
30:34 - the issue list to integrate it or not
30:37 - and how to do it but for now there's
30:40 - nothing included
30:43 - and
30:45 - spring security already made oauth2 a
30:49 - first-class citizen in its
30:51 - implementation
30:53 - and
30:57 - before security 5
30:59 - you had to use a third-party
31:02 - library to to use oauth 2 and open id
31:05 - connect with spring security now it's
31:08 - included out of the box
31:11 - in spring security
31:14 - and there's
31:15 - some other libraries for example there's
31:18 - apache shiro
31:20 - one of the the
31:22 - well-known libraries dealing with
31:23 - security but also shiro doesn't have
31:26 - oauth2 or id connect jwt included
31:30 - there's some community efforts but
31:33 - nothing in the library itself
31:35 - but there's another
31:37 - library called apache all 2
31:40 - which does contain all the
31:42 - standards
31:44 - and my favorite question at every
31:46 - conference who knows all two
31:50 - one
31:51 - okay
31:53 - um yeah
31:56 - even me didn't know this library until i
31:59 - prepared the talk and had a look um
32:02 - which libraries are out there dealing
32:04 - with um
32:05 - oauth 2 and
32:06 - yeah
32:07 - it seems it's it's a it's powerful
32:09 - library but
32:11 - nobody knows there are lots of more
32:14 - libraries
32:15 - available some dealing with oauth 2 of
32:17 - my dconnect some not
32:20 - and there are of course a lot of
32:23 - libraries dealing with
32:25 - jwt
32:28 - looking at the ecosystem
32:32 - what's available for
32:35 - storing user data and
32:39 - providing all the
32:41 - flows and processes end points
32:44 - of course you can use
32:47 - off zero or hws cognito storm path
32:51 - as some managed services
32:54 - providing
32:55 - all this functionality but you have to
32:57 - outsource your users data the
32:59 - credentials
33:00 - and that's
33:01 - um
33:02 - i think most of the time not
33:05 - that's what you want to do
33:07 - to give
33:08 - other companies the credentials of your
33:10 - users
33:12 - and
33:15 - besides other projects
33:18 - i like to to use
33:20 - key clock
33:21 - from jboss it's an open source project
33:25 - it's not just a library it's a complete
33:28 - system
33:29 - providing all
33:32 - the services for
33:33 - identity and access management
33:36 - and yeah in most of the cases it can be
33:39 - a good fit
33:41 - uh i also had some case use cases at
33:44 - customers where i said okay key cloak
33:48 - can do it but it's not the best fit for
33:50 - you needs take another solution
33:54 - but in the last few years
33:56 - most of the projects
33:58 - i did with my customers
34:00 - i introduced key cloak to them and
34:02 - they're pretty happy
34:04 - so let's look into some
34:07 - demo
34:08 - how i did it
34:11 - first the architecture it's pretty
34:13 - simple i have a shop system as the the
34:16 - main system a user interacts with and
34:20 - the stock service and the shipping
34:21 - service in the back end
34:23 - and
34:24 - the user gets a user token
34:28 - pass it to the shop
34:31 - and the shop itself um
34:34 - gets a service account token issued for
34:37 - accessing the stock service because the
34:39 - stock service is also secured
34:41 - only allowed
34:44 - resources may access the stock service
34:47 - and for calculating the shipping costs
34:50 - the the shipping service
34:52 - needs the user token so the shop
34:55 - passes the user token to the shipping
34:57 - service
35:02 - this is key cloak
35:04 - this is the uh the admin interface
35:07 - and um
35:12 - i have to
35:14 - make it so it looks better yeah
35:17 - i have um created a shop client this is
35:20 - my shop application
35:22 - and the client protocol is open id
35:25 - connect
35:26 - key clock also supports saml but
35:28 - we don't want to deal with someone
35:32 - only to deal with openid connect
35:34 - and this is a confidential um client
35:38 - which means um this client
35:40 - has a secret for accessing
35:43 - the key clock server
35:46 - like a password for for the for the
35:48 - system itself
35:50 - and um
35:52 - you can find it here it's a secret it's
35:54 - generated
35:56 - and
35:57 - yeah we have
35:59 - a user
36:01 - user has username user
36:04 - and
36:07 - this user has a role
36:09 - called user
36:11 - very surprising
36:13 - and
36:14 - yeah
36:16 - we can now access our shop
36:19 - oh i have to start it first
36:22 - it's a spring
36:24 - spring boot application
36:27 - i will show you some some code in a few
36:30 - minutes
36:32 - so we have the
36:34 - shop
36:36 - localhost 8081.
36:40 - now
36:45 - looks better that's my shop
36:49 - i come from germany that's because the
36:52 - euro symbol
36:53 - and
36:54 - i want to access a secured
36:57 - secured resource
36:59 - and the application redirects me to the
37:02 - key cloud server to log in
37:05 - and all the things you can see on this
37:07 - page are
37:09 - coming with key clock you don't have to
37:10 - implement them themselves the login
37:13 - process you have a register option you
37:17 - have a forgotten password option
37:20 - you have a remember me option
37:22 - you have the option to to use uh social
37:25 - login providers or you can
37:29 - connect your your
37:32 - your
37:33 - ldap or active directory to key cloak so
37:36 - that key cloak
37:38 - just does the authentication process but
37:41 - the
37:43 - credentials are stored in an active
37:44 - directory and all this stuff you don't
37:46 - have to implement it yourself
37:49 - and then we can log in as a user
37:53 - and that's my cat shop you can buy cats
38:00 - you can see i'm the user
38:03 - and now i can
38:04 - put cats into
38:07 - the the cart
38:11 - some
38:13 - double rounding feature
38:16 - um
38:18 - we can see we have some stock
38:20 - information about the cats
38:23 - and
38:25 - the image service is a bit
38:26 - slow it's a public service with random
38:29 - picks
38:30 - [Music]
38:32 - and we have shipping costs of um
38:35 - uh approximately 10 euro
38:38 - and
38:41 - if i now log out and do some
38:44 - reconfiguration
38:46 - of my user
38:50 - i tell
38:53 - it's a vip i give the user just a simple
38:57 - attribute
39:00 - with the value true
39:02 - and
39:02 - now
39:04 - if i
39:07 - log in again
39:10 - and
39:11 - put
39:12 - cats into my cart
39:14 - you can see there are no shipping costs
39:16 - because if the user has
39:18 - a vip attribute
39:20 - there are no shipping costs
39:22 - used
39:23 - so that's the application itself let's
39:24 - look into the code how or what i had
39:28 - to do to realize all this besides of the
39:31 - of the business logic
39:34 - for configuration of key cloak for
39:37 - spring boot application and
39:39 - spring boot it's really simple but
39:42 - other java application servers are quite
39:45 - similar
39:47 - we have to provide some configuration
39:50 - it's a realm
39:52 - it's called workstorage
39:55 - let's look here it's called voxturish
39:58 - this is the realm
40:00 - configured in key cloak
40:03 - we have a server url it's localhost 8080
40:07 - we have the the secret
40:11 - our resource is called shop we we saw
40:13 - this
40:14 - and
40:16 - in our principal attribute
40:18 - we want to have the preferred username
40:21 - claim this one of the open id connect
40:24 - reserved claims
40:26 - and
40:27 - we use the
40:30 - servlet
40:31 - security
40:32 - specification
40:34 - to configure
40:36 - a security collection
40:38 - which
40:39 - says all
40:41 - resources beneath the path shop
40:44 - should require
40:46 - a user role
40:47 - that's why we were redirected to the
40:50 - login page
40:53 - i didn't
40:56 - write
40:57 - wrote any code to redirect the user to
41:00 - the login page just this configuration
41:02 - leads
41:04 - to the login page of key cloud because
41:06 - the key clock adapter which is included
41:08 - in the application
41:10 - which is just a dependency in the palm
41:13 - we have um
41:16 - key clock spring boot starter
41:19 - um and this dependency brings all the
41:22 - adapter logic to redirect
41:25 - to
41:26 - the server
41:28 - and
41:31 - if i authenticate myself come back to
41:33 - the application
41:34 - then the application fetches the access
41:37 - token from the keylog server and knows
41:39 - i'm a valid user with a user role
41:44 - and leads me to
41:46 - the catalog
41:48 - which is
41:50 - done by the shop controller
41:53 - and
41:55 - when we have a look to the
41:59 - stocks
42:00 - get stocks method we have the stock
42:02 - service get stocks
42:04 - and
42:05 - we use a rest template
42:08 - um
42:09 - which i i called key clock client auth
42:12 - rest template
42:14 - and i implemented uh myself it's just an
42:18 - extended standard rest template from
42:20 - spring
42:21 - and um
42:22 - [Music]
42:24 - did some
42:25 - configuration magic
42:27 - um this is the off arrest template and
42:30 - make use of the
42:33 - auth client offset client
42:37 - this client can comes with
42:40 - key cloak adapters the dependency
42:42 - mentioned in the palm xml
42:45 - and
42:46 - this client
42:48 - eases the process for authentication
42:51 - authenticating the
42:54 - the the application itself against key
42:57 - cloak
42:59 - to get an
43:00 - service account access token
43:03 - which is needed by the the stock service
43:07 - and
43:08 - we can
43:09 - see the stock service the stock service
43:11 - itself
43:12 - needs the role stocks
43:15 - and as we can see it our user
43:18 - our user
43:22 - doesn't have
43:23 - the roll stocks it's available but it's
43:25 - not assigned
43:26 - and our client
43:28 - shop
43:31 - [Music]
43:35 - service the controls there it is
43:37 - um
43:41 - an assigned role stocks so the shop
43:44 - application itself verifies
43:47 - authenticates itself
43:48 - at key clock gets an access token
43:51 - and passes it to the stock service
43:54 - and because
43:56 - the the token contains the stocks rule
43:59 - it's allowed to access
44:01 - the stock service
44:03 - and
44:05 - we have the the shipping service
44:08 - at last service
44:10 - this also needs the
44:12 - user's role and
44:14 - key cloak forwards the
44:17 - user token
44:19 - to the
44:20 - to the shipping service
44:22 - and in the
44:25 - shipping controller
44:27 - i can get i can access the key clock
44:29 - security context
44:31 - through the the request
44:33 - and in this context i can get a token or
44:36 - also i can
44:38 - get some identity token
44:40 - to get identity information or whatever
44:43 - i need and here i
44:45 - check the the vip claim
44:49 - just for completeness and
44:52 - the interesting part is in the shop
44:55 - application again
44:56 - um
44:59 - shipping service
45:01 - i just use a regular rest template
45:05 - but i configured the rest template
45:09 - to use the key clock rest template
45:11 - customizer
45:13 - this also comes with key clock
45:15 - and the key clock rest template
45:17 - customizer is
45:22 - so
45:22 - i need to find it
45:25 - [Music]
45:29 - no that's just the interface
45:33 - the interceptor yes the interceptor
45:36 - and the interceptor just cares about
45:40 - getting
45:42 - attributes from the request get the user
45:45 - principle
45:46 - and
45:48 - somewhere
45:49 - yeah getting the key clock security
45:51 - context and putting
45:55 - the
45:57 - the token the token from the security
45:59 - context into the request
46:01 - to the shipping service to the back end
46:04 - so
46:06 - i didn't
46:07 - write any code to secure my applications
46:10 - just did configuration using
46:13 - the key clock application
46:15 - the key clock
46:16 - system server
46:18 - and
46:21 - can can make use of a highly
46:24 - secured application landscape
46:31 - so
46:31 - that's it time is over
46:35 - i hope you enjoyed the session and if
46:37 - you have any questions we have
46:40 - some four minutes left
46:43 - uh
46:44 - just ask your questions raise your hands
46:45 - or come in front of me
46:52 - um the code is not yet online
46:56 - but i can put it online later on
46:59 - and i will tweet
47:02 - the pass through repository
47:04 - so just follow me at desniko and
47:08 - you will be informed
47:10 - okay
47:12 - because but
47:14 - it's no real code it's just
47:16 - configuration
47:18 - the code is a standard java spring boot
47:21 - code it's nothing there's no security
47:23 - code it's just configuration i'll make
47:25 - use of the the key cloak
47:27 - some key cloak
47:29 - magic about the configuration of the
47:30 - rest templates but nothing more yeah
47:36 - okay
47:37 - there's one more
47:47 - how
47:51 - to secure
47:52 - the communication between the shop
47:55 - services
47:57 - and
47:58 - the other two services i mean
48:01 - speaking about the normal way we should
48:03 - be in a
48:04 - safe
48:08 - um
48:09 - did everybody understand the question or
48:11 - should i repeat it
48:14 - okay um what's the what's the purpose of
48:16 - securing uh the bose back uh backend
48:19 - systems the stock service and the
48:20 - shipping service
48:22 - because
48:23 - normally we should be in a
48:26 - controlled and secured
48:28 - area
48:32 - if it's really secured
48:35 - in this area
48:40 - most of the the the um attacks
48:44 - in
48:45 - systems came from internal net internal
48:50 - networks
48:51 - and
48:53 - even if you're in your own intranet
48:56 - controlled whatever
48:59 - at least the the
49:00 - administrator knows how to attack a
49:03 - system
49:04 - and you should secure all your systems
49:08 - regardless
49:09 - if the
49:10 - if the environment
49:12 - claims to be secure or not
49:14 - you should always use https you should
49:17 - always
49:18 - use
49:19 - authentication and authorization so you
49:22 - always can can check at the stock
49:24 - service
49:26 - when and
49:27 - how often the shop accessed
49:30 - the stock service
49:33 - so for auditing reasons or whatever you
49:35 - can you have
49:38 - the the best basics
49:45 - in the second
49:47 - you you propagate the user identity to
49:49 - the shipping service yes
49:52 - but this
49:54 - can be can be needed because some vrp's
49:57 - don't have to pay
49:59 - shipping costs uh whatever yeah
50:03 - but this always also can be can be a
50:06 - risk of propagating user identities to
50:09 - other systems
50:10 - so we have always to deal with the
50:13 - pros and cons of your solution
50:16 - no system is perfectly secure
50:27 - isn't it usually done by this one i saw
50:30 - that you used now the user wrote
50:33 - a feature or a missing feature in key
50:36 - clouds
50:40 - um
50:47 - he asked if i missed why i missed the
50:51 - the scopes from oauth2 and
50:55 - if it's a missing feature of key cloak
50:57 - why i'm using roles and not scopes
51:05 - which which scopes exactly do you mean
51:08 - from from earth to
51:12 - so basically
51:20 - array of strings
51:31 - okay okay is this is this really a
51:34 - part of the specification or is this
51:38 - a way of
51:40 - most companies do it
51:47 - okay
51:48 - um
51:50 - yeah
51:51 - key clock first of all makes use of open
51:54 - id connect
51:55 - and
51:56 - jwt
51:58 - and
52:00 - open id connect
52:02 - is based on oauth2
52:04 - just for the the the flows
52:07 - and
52:08 - because
52:09 - open id connect uses jwt and jwt
52:14 - can express all what you want you don't
52:16 - have to use some other
52:19 - possibilities scopes into
52:23 - additionally to
52:25 - jwt so you can put all the information
52:27 - you need in your token
52:29 - so you don't have to use scopes from one
52:31 - technology
52:33 - from the auth 2 technology and use
52:35 - tokens from
52:38 - from
52:39 - open id connect
52:41 - of course you can mix it if you want you
52:43 - can
52:44 - how you you
52:46 - you put your
52:47 - um
52:50 - your your
52:52 - authorization information into the token
52:54 - if it's roles or scopes it's completely
52:57 - up to you
53:00 - but
53:01 - open id connect deals not with
53:03 - authorization it deals with
53:04 - authentication
53:06 - and in authentication you don't need
53:09 - roles or scopes it's just an addition
53:12 - to all this kind of stuff and
53:15 - yeah
53:16 - authorization with key clock
53:18 - can be a pain in my eyes
53:22 - for authentication it's pretty good
53:24 - authority um authentication and
53:26 - authorization can be really pain
53:28 - okay time is over thank you for
53:31 - listening
53:32 - and have a nice day

Cleaned transcript:

okay welcome nice to meet you to one of the most annoying topics of development security okay my name is nico quibbler i'm from germany i'm a freelance guy and i'm more than 20 years in i.t business i recognize it a few weeks ago when i got my new fitness tracker it has a very small display and i have to put my wrist far away from my eyes so i'm getting pretty old um besides my day job i coorganizing a local java user group in darmstadt it's nearby frankfurt and speak occasionally at tech conferences all over the world and last year i wrote a book about serverless computing in the cloud but that's not the topic i will talk about today and of course as every speaker and developer or whatever guy i'm on twitter so let's start talking about security who of you likes to deal with security one two three four three and a half okay three and a half it's not that pretty much um so did i until a few years ago the reason was for me i didn't understand it then i took the time and tried to understand it read the specs and suddenly it made hey it's easy it's pretty easy but you have to have to take the time and understand how all this stuff really works and security is a wide range of topics and there are also the overs top 10 which deal with the most most frequent security issues and what we don't want to talk about um the the obvious top 10 today we want to talk about authentication and authorization so who of you thinks he or she knows what's the difference because between authorization and authentication okay a bit more than the half it's pretty easy i think but every time i'm talking to customers most of them don't get it right and it's easy as authentication is i don't know who you are please authenticate yourself tell me who you are and how can i make sure that you the person you tell me you are an authorization is the next step after i know who you are i have to check what are you allowed to do this is authorization and yeah also i mix it up still in my daily business business when talking to customers sometimes i say authentication when i mean authorization and vice versa so if i mix it up today please don't be angry with me but um also the http status codes mix it up a bit and these these are pretty old so the guys you made who um who built up the status codes didn't get it either we have the 401 which means which which is called unauthorized but it means unauthenticated or not authenticated 401 is not really it does not deal with authorization it deals with authentication and once you're authenticated the status code 403 tells you you don't you are you're not allowed to do anything you're forbidden so for one unauthorized it's not it's not really correct so and we are in distributed apis nowadays distributed systems distributed apis um at least we have a single page application in the back end that's also a distributed system and how do we log in in such a system in a secure way and when talking when apis are talking to each other we how do they authenticate and authorize each other and when it comes oh yeah when we have distributed apis or distributed systems should we have a centralized approach when it comes to authorization or authentication i think yes because it's called a single sign on and single signon means there's only one system who knows my credentials and um which knows how to to verify these credentials and not two or three or more replicated systems with replicated data because then the the data the credential data of our users is replicated and many systems uh have have have a knowledge about this and we don't want to have many systems or more more than one system to have the knowledge how to verify the credentials only one system that's because it it's called single signon singlesignon does not mean our users only have to log in once when they come into the office in the morning and grab a coffee and they can work with uh ff system that's a side effect of single signon but not that's not um the root of the word single signon the signal is really a single system who knows about our credentials yeah and when it comes to to real users of course they want to have a simple and secure solution and you all know simply simple and secure these are two choose one you always have to choose what is more relevant for you has it to be more simple or has it to be more secure the more secure the less simple um it will be at least for you as a developer if you want to make it simple for the for the users for the end users and secure for the data then the effort is at your side the developers side yeah how do you authenticate of course with our username email whatever a password a simple secret a temporary link or a mobile phone or whatever but then how do we transport these authentication infos to all the systems of course with the token and the token is nothing new already in the beginning of 2000s we have the the summer the security search and markup language which is pretty cool xml no xml and cool doesn't work doesn't fit together it's yeah it's powerful but it's kind of complex and it doesn't feel good and all these claims are difficult to handle and um when we talked today about uh web applications and lightweight um lightweight serialization and such things like json javascript it's really hard to handle xml with javascript i tried it once and i gave up after two days but the token itself is nothing really new and because samoa isn't working pretty good with web technologies in nowadays there's the oauth 2 framework or specification which deals with authorization of 2 has nothing to do with authentication it just deals with authorization who is allowed to do what which system may access another system in your name of course you have to be authenticated before you can give another thirdparty system the authority to access your own system but the authentication process is no standard way when using oauth2 or f2 is just authorization and um the the the authentication process is completely different uh implemented when um looking at the oauth implementation of twitter or facebook or github or whatever so you can use the the login feature of twitter or facebook google for your application but that's not really um authentication that's only authorization you grant access to your application to access twitter in your name when you're not in front of your computer and furthermore if you implement many of these providers you have to implement different ways of how to retrieve the user information the user profile information because every response from every system looks different so oauth2 is just for authorization and not for authentication um but it's pretty uh powerful when it comes to uh web web applications or handling in the web and it has different socalled crunch types or authorization flows there if the authorization code flows the standard flow which deals with many redirects between the systems and the browser and simple said the the user wants to access um okay i can show you here an abstract protocol flow the user wants to access a secured resource on the resource server and the resource server says hey you're not authenticated please log in authenticate yourself and then i will see if you're allowed to do and redirects the user to a login page of the authorization server and after the user logs in the authorization server sends back a authorization code that's why it's called authorization code flow and the authorization with the authorization code flow in the browser with a redirect to the application the client wants to access the application itself can grab the token from the authorization server and the token expresses what the user is allowed to do so with the token um the resource server can deliver the protected resource to the client that's the most powerful ground type or author authorization flow authorization code and if you don't have the the possibility to um to take the authorization code flow and um grab the token from the authorization server because that's uh you need you need an additional secret for the for the client fetching the the token at the authorization server and if you can't provide this secret for example in a public website javascript site you need something other because yeah you can somehow encrypt or hash the secret but it's still in the in the front and the browser and the user's device so the secret isn't a secret anymore and therefore you have the implicit flow and with implicit flow you get implicit the token back to the response after the user logs in successfully if you don't have any chances or you don't want to have some redirects between the systems and the user's browser you can use the resource owner password credentials flow it's probably quite a nice word resource owner password credentials i have to read it every time and that's kind uh of an api sending the credentials directly to the authorization server and get back the token but this is the least least secure possibility because you as as the client application have the you have to have the credentials in uh in your application to send it to the authorization server in the regular cases of authorization code or implicit flow the author's authorization server delivers the login page and the user enters his credentials directly at the author authorization server and with the resource owner password credentials flow the user enters the credentials at your application and you take the application the credentials and send them to the authorization server so there are chances for mantomiddle attacks and when it comes to system to system authorization there's the client credentials flow this is just for it's like it's like the the authorization code um or the implicit flow but just for backend applications there's no browser involved and no redirects and um lastly you have the refresh token flow because um every token has a special lifetime and after the token is invalid you have to renew to refresh the token you can do this with the refresh token flow and that's how the access token response looks like when your application gets the response from the the token fetch or from the authorization server you have the access token itself it can be just a opaque string with no means for outside world the token type is bearer it's always better when dealing with oauth 2 this is written in the spec it has an expiry range it expires in 3600 seconds and we have the refresh token with the refresh token you can refresh an invalid access token so normally the access token has a very short lifetime between a few seconds and i say five minutes and the refresh token has a long lifetime um let's say half an hour hour or whatever so um this access token you can take this access token the the string and um to know what your user or your client is allowed to do you have to take this access token and ask the authorization server what is this user with this access token allowed to do and additionally you don't know who is this user you can only check what is this user allowed to do you don't know who is this user and this is where open id connect came in open id connect is not open id it has nothing to do with openid it's just hosted by the open id foundation which is also doing open id and but it's called open id connect and it's based technically is based on oauth2 with a worth two flows and it standardizes profile user profile information and identity information so it brings in an identity token to the additionally to the access token we have an identity token and it adds an user profile endpoint where you can grab identity information profile information of the user with his current access token and a few more restful endpoints for dealing with all this stuff um so this is the identity token coming in into the response we have the access token the refresh token now we have the identity token but how does it look like how is the identity stored into the token and this is where json web tokens come in json web token that's the standard since 2015 three years old and json web tokens are simply three concatenated base64 encoded strings so if the three uh strings mentioned in different colors and what it is like it's it's a header it's payload and it's a signature and if you decode this can you read it yeah i think yes um you see the header it just contains the type the jbt has the jwt has the type jwt okay and the algorithm with which the signature is signed or the signature is created then you have the payload for the payload you have a few reserved claims we come to this in the next slide the possible claims or the attributes are called claims in terms of jwt and the signature is um is a string uh concatenated of a base 64 encoded header and payload and depending on the the type of algorithm used um a synchronized algorithm the hs256 with just a secret or you can use the rs256 for a private public key usage so the token itself is socalled selfcontained and you can always check if the token was changed by some third party when you get the token and so you have a certain kind of trust level when you get the token if the token itself is valid or is not valid because only if you knew even though the the secret when it comes to synchronized signature or you have to know the private key when dealing with public private public key encryption so you don't have to check the token at a another end point you can this can do this of course if you really need this kind of security but you don't have to use this endpoint yeah the payload itself it has some reserved claims the subject issuer audition and expiry these are the only claims jwt claims for itself the subject is for for whom is the the token issued most of the time this is kind of a user id the issuer is the issuing system represented as an url the audition for which client application this token was issued for my api or for my shop or for whatever system and the expiry date and as the specs says jwt must be used when the expiry date has expired so you have to check the signature if the signature is valid then you can use the token otherwise you must not use this token and um it has to have a valid expiry date the rest of the payload you can choose freely whatever you want to put in the payload as you like open idconnect adds a more some more claims standard claims to the jwt token so if you use jwt in terms of opm id connect you have to use these claims i know i don't know it's difficult to read there was no other way to fit all the information to one slide it's but it's not a website of open id so we have claims for the name the given name the family and the middle name the nickname preferred username and so on also in the bottom you can see there's also address and address is not only a string it's a json object so we have a nested object for the address information and the address object itself is also specified so using jwt changes our access token response to look like this we have the access token the access token itself is when using open id connect also expressed in jwt and we have the token type the expiries in when using jwt you don't need to use this expires in at report because the token itself has an expiry date and you have the identity token in a jwt format and the refresh token also it doesn't make real sense to have the refresh token as a jwt but yeah for simplicity reasons all tokens are jwt tokens the refresh token itself contains just unique string for identifying this session on the authorization server okay and how can this token be used the user after author successful authentication has a token he passes to the web application and the web application itself can pass the same token to backend systems if this application needs to access thirdparty or further backend systems as we can see later in the demo it's also possible that the web application grabs an own socalled service account token for authentication authenticate authenticating itself against backend systems or it can pass the the user token to the backend systems so short conclusion for tokens a token is signed we have seen this and contains all necessary necessary information about a user and its roles so in the access token all the roles the user has should be included we have different kinds of tokens with identity tokens refresh tokens access tokens and sometimes you have things like like an offline token an offline token you can a user can can request to have an offline token issued for another application and this this other application can use this offline token for perhaps regular tasks at night when the user is not online creating reports or whatever sending emails to to exchange this offline token to valid access token and act on behalf of the user even if the user is not online but the user has to has to initiate uh the process for um for creating an offline token so there's no global offline token as a system can use to act on behalf of a user the tokens are sent in bearer format most often in the http header authorization and we have a total time to live and of course tokens must be revocable um i forgot this to mention an access token itself once it is issued it doesn't need to be verified at the authorization server i said before that's right because it's um signed and it's selfcontained so once it is issued it is well it and every system using it can be uh can be sure that it's valid but what what if um the the the token um is stolen or whatever um that's because the the access token should have a very very short total time to live i recommend most often between 30 seconds and two minutes because that's the time amount of time a third party can misuse this token if it gets the token and after this time you have to use the refresh token and to refresh the access token to get a new access token and if you have in the meantime the token the session revoked at the authorization server the server won't access a new exit it won't create a new access token and um and the third party can't use the token anymore so this must be revocable and as i'm a java developer most of the times currently i'm dealing with the javascript i asked myself what does java offer to deal with oauth2 and open id connect and unfortunately it's not that much it's becoming better but it's very sad the big java ee standard now it's called jakarta ieee has a new security api jsrf275 which is quite nice this api but it doesn't deal with um off 2 or almighty connect jwt there are some discussions on the on the mailing list and the issue list to integrate it or not and how to do it but for now there's nothing included and spring security already made oauth2 a firstclass citizen in its implementation and before security 5 you had to use a thirdparty library to to use oauth 2 and open id connect with spring security now it's included out of the box in spring security and there's some other libraries for example there's apache shiro one of the the wellknown libraries dealing with security but also shiro doesn't have oauth2 or id connect jwt included there's some community efforts but nothing in the library itself but there's another library called apache all 2 which does contain all the standards and my favorite question at every conference who knows all two one okay um yeah even me didn't know this library until i prepared the talk and had a look um which libraries are out there dealing with um oauth 2 and yeah it seems it's it's a it's powerful library but nobody knows there are lots of more libraries available some dealing with oauth 2 of my dconnect some not and there are of course a lot of libraries dealing with jwt looking at the ecosystem what's available for storing user data and providing all the flows and processes end points of course you can use off zero or hws cognito storm path as some managed services providing all this functionality but you have to outsource your users data the credentials and that's um i think most of the time not that's what you want to do to give other companies the credentials of your users and besides other projects i like to to use key clock from jboss it's an open source project it's not just a library it's a complete system providing all the services for identity and access management and yeah in most of the cases it can be a good fit uh i also had some case use cases at customers where i said okay key cloak can do it but it's not the best fit for you needs take another solution but in the last few years most of the projects i did with my customers i introduced key cloak to them and they're pretty happy so let's look into some demo how i did it first the architecture it's pretty simple i have a shop system as the the main system a user interacts with and the stock service and the shipping service in the back end and the user gets a user token pass it to the shop and the shop itself um gets a service account token issued for accessing the stock service because the stock service is also secured only allowed resources may access the stock service and for calculating the shipping costs the the shipping service needs the user token so the shop passes the user token to the shipping service this is key cloak this is the uh the admin interface and um i have to make it so it looks better yeah i have um created a shop client this is my shop application and the client protocol is open id connect key clock also supports saml but we don't want to deal with someone only to deal with openid connect and this is a confidential um client which means um this client has a secret for accessing the key clock server like a password for for the for the system itself and um you can find it here it's a secret it's generated and yeah we have a user user has username user and this user has a role called user very surprising and yeah we can now access our shop oh i have to start it first it's a spring spring boot application i will show you some some code in a few minutes so we have the shop localhost 8081. now looks better that's my shop i come from germany that's because the euro symbol and i want to access a secured secured resource and the application redirects me to the key cloud server to log in and all the things you can see on this page are coming with key clock you don't have to implement them themselves the login process you have a register option you have a forgotten password option you have a remember me option you have the option to to use uh social login providers or you can connect your your your ldap or active directory to key cloak so that key cloak just does the authentication process but the credentials are stored in an active directory and all this stuff you don't have to implement it yourself and then we can log in as a user and that's my cat shop you can buy cats you can see i'm the user and now i can put cats into the the cart some double rounding feature um we can see we have some stock information about the cats and the image service is a bit slow it's a public service with random picks and we have shipping costs of um uh approximately 10 euro and if i now log out and do some reconfiguration of my user i tell it's a vip i give the user just a simple attribute with the value true and now if i log in again and put cats into my cart you can see there are no shipping costs because if the user has a vip attribute there are no shipping costs used so that's the application itself let's look into the code how or what i had to do to realize all this besides of the of the business logic for configuration of key cloak for spring boot application and spring boot it's really simple but other java application servers are quite similar we have to provide some configuration it's a realm it's called workstorage let's look here it's called voxturish this is the realm configured in key cloak we have a server url it's localhost 8080 we have the the secret our resource is called shop we we saw this and in our principal attribute we want to have the preferred username claim this one of the open id connect reserved claims and we use the servlet security specification to configure a security collection which says all resources beneath the path shop should require a user role that's why we were redirected to the login page i didn't write wrote any code to redirect the user to the login page just this configuration leads to the login page of key cloud because the key clock adapter which is included in the application which is just a dependency in the palm we have um key clock spring boot starter um and this dependency brings all the adapter logic to redirect to the server and if i authenticate myself come back to the application then the application fetches the access token from the keylog server and knows i'm a valid user with a user role and leads me to the catalog which is done by the shop controller and when we have a look to the stocks get stocks method we have the stock service get stocks and we use a rest template um which i i called key clock client auth rest template and i implemented uh myself it's just an extended standard rest template from spring and um did some configuration magic um this is the off arrest template and make use of the auth client offset client this client can comes with key cloak adapters the dependency mentioned in the palm xml and this client eases the process for authentication authenticating the the the application itself against key cloak to get an service account access token which is needed by the the stock service and we can see the stock service the stock service itself needs the role stocks and as we can see it our user our user doesn't have the roll stocks it's available but it's not assigned and our client shop service the controls there it is um an assigned role stocks so the shop application itself verifies authenticates itself at key clock gets an access token and passes it to the stock service and because the the token contains the stocks rule it's allowed to access the stock service and we have the the shipping service at last service this also needs the user's role and key cloak forwards the user token to the to the shipping service and in the shipping controller i can get i can access the key clock security context through the the request and in this context i can get a token or also i can get some identity token to get identity information or whatever i need and here i check the the vip claim just for completeness and the interesting part is in the shop application again um shipping service i just use a regular rest template but i configured the rest template to use the key clock rest template customizer this also comes with key clock and the key clock rest template customizer is so i need to find it no that's just the interface the interceptor yes the interceptor and the interceptor just cares about getting attributes from the request get the user principle and somewhere yeah getting the key clock security context and putting the the token the token from the security context into the request to the shipping service to the back end so i didn't write any code to secure my applications just did configuration using the key clock application the key clock system server and can can make use of a highly secured application landscape so that's it time is over i hope you enjoyed the session and if you have any questions we have some four minutes left uh just ask your questions raise your hands or come in front of me um the code is not yet online but i can put it online later on and i will tweet the pass through repository so just follow me at desniko and you will be informed okay because but it's no real code it's just configuration the code is a standard java spring boot code it's nothing there's no security code it's just configuration i'll make use of the the key cloak some key cloak magic about the configuration of the rest templates but nothing more yeah okay there's one more how to secure the communication between the shop services and the other two services i mean speaking about the normal way we should be in a safe um did everybody understand the question or should i repeat it okay um what's the what's the purpose of securing uh the bose back uh backend systems the stock service and the shipping service because normally we should be in a controlled and secured area if it's really secured in this area most of the the the um attacks in systems came from internal net internal networks and even if you're in your own intranet controlled whatever at least the the administrator knows how to attack a system and you should secure all your systems regardless if the if the environment claims to be secure or not you should always use https you should always use authentication and authorization so you always can can check at the stock service when and how often the shop accessed the stock service so for auditing reasons or whatever you can you have the the best basics in the second you you propagate the user identity to the shipping service yes but this can be can be needed because some vrp's don't have to pay shipping costs uh whatever yeah but this always also can be can be a risk of propagating user identities to other systems so we have always to deal with the pros and cons of your solution no system is perfectly secure isn't it usually done by this one i saw that you used now the user wrote a feature or a missing feature in key clouds um he asked if i missed why i missed the the scopes from oauth2 and if it's a missing feature of key cloak why i'm using roles and not scopes which which scopes exactly do you mean from from earth to so basically array of strings okay okay is this is this really a part of the specification or is this a way of most companies do it okay um yeah key clock first of all makes use of open id connect and jwt and open id connect is based on oauth2 just for the the the flows and because open id connect uses jwt and jwt can express all what you want you don't have to use some other possibilities scopes into additionally to jwt so you can put all the information you need in your token so you don't have to use scopes from one technology from the auth 2 technology and use tokens from from open id connect of course you can mix it if you want you can how you you you put your um your your authorization information into the token if it's roles or scopes it's completely up to you but open id connect deals not with authorization it deals with authentication and in authentication you don't need roles or scopes it's just an addition to all this kind of stuff and yeah authorization with key clock can be a pain in my eyes for authentication it's pretty good authority um authentication and authorization can be really pain okay time is over thank you for listening and have a nice day
