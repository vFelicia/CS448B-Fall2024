With timestamps:

00:00 - hello everybody and welcome to the free
00:01 - code camp blockchain and solidity
00:04 - beginner to expert full course python
00:07 - edition we're going to go through
00:09 - everything you need to know for
00:10 - developing on a blockchain using
00:12 - solidity and engaging in the future of
00:14 - finance we're going to cover topics that
00:15 - will teach you all the skills you need
00:17 - to become a smart contract expert that
00:19 - you can take with you no matter which
00:21 - blockchain you're developing on
00:23 - blockchain engineers are in extreme
00:24 - demand and they're building billion
00:26 - dollar applications almost every day at
00:28 - this point at the time of filming
00:30 - protocols like ave yearn.finance and
00:33 - synthetics have billions of dollars of
00:35 - locked value in them allowing people to
00:37 - engage in decentralized finance or defy
00:40 - this allows people to make censorship
00:42 - resistant moves and so much more some of
00:45 - these protocols with billions of dollars
00:46 - are even less than a year old so whether
00:49 - or not you're brand new to this space or
00:50 - you've been in here a while hi my name
00:52 - is patrick collins and i live in the
00:54 - smart contract world i'll be taking you
00:56 - through your journey to becoming a
00:58 - blockchain and smart contract expert a
01:00 - little bit of background on myself i'm
01:02 - an engineer and developer advocate on
01:04 - the chain link protocol and i also have
01:06 - my own blockchain infrastructure company
01:08 - called alphachain where i run different
01:11 - nodes and different infrastructure for
01:12 - blockchains including one of the main
01:14 - technologies we're going to be talking
01:15 - about today which is ethereum i love
01:18 - being a pioneer in the smart contract
01:20 - ecosystem and i love taking new users
01:23 - like yourself along to the journey with
01:25 - us and we are going to teach you to
01:27 - become a smart contract expert building
01:30 - blockchain and solidity applications is
01:32 - building a world of more trust and
01:35 - accountability it means building a
01:37 - financially free future and we get to be
01:39 - the ones that will go down in the
01:40 - history books as the pioneers of this
01:42 - space additionally blockchain and smart
01:45 - contract engineering skills are some of
01:46 - the most sought after in the world with
01:48 - an average salary of a solidity
01:50 - developer being between 150 and 175 000
01:55 - in this video we're going to teach you
01:56 - how to become one of these developers
01:59 - and go out into the world and
02:00 - participate in the world of smart
02:02 - contracts in the world of blockchain
02:04 - this course is ideally for engineers who
02:06 - know a little bit of python programming
02:08 - and you can have any level of smart
02:09 - contract engineering whether you're a
02:12 - complete beginner to blockchains and you
02:13 - don't even know what one is or you're an
02:15 - advanced solidity engineer and you're
02:17 - looking to learn more this is the
02:18 - perfect place for you having a little
02:20 - bit of experience in other
02:22 - object-oriented programming language
02:23 - like javascript as well will be helpful
02:25 - here too and if you're brand new to
02:27 - coding in general that's all right
02:28 - because we're going to take you step by
02:30 - step through everything if you do want a
02:32 - little bit more in-depth python coding
02:34 - video there is a fantastic free code
02:36 - camp video in the description if you do
02:38 - prefer javascript we will also be
02:40 - releasing a javascript edition of this
02:42 - video as well but everything that you
02:44 - learn here will be applicable there and
02:46 - if you watch both you'll learn even more
02:48 - you can find the entire itinerary for
02:51 - this entire course along with all of the
02:53 - code associated with everything that we
02:55 - do and additionally discussions and
02:57 - support and everything else in this
02:59 - smart contract kit
03:00 - full blockchain solidity course pi
03:03 - github repository it has a table of
03:04 - contents and then the entire itinerary
03:07 - of everything that we're going to go
03:08 - over in this course and like i said with
03:10 - helpful tips resources for getting
03:12 - support and resources for getting help
03:14 - now for your convenience every single
03:16 - piece of code that we're going to go
03:17 - over in this video has a github
03:19 - repository associated with it so be sure
03:22 - to grab the link in the description grab
03:24 - that github repository and look through
03:26 - all the different repos that we're going
03:27 - to give you if you ever get lost or need
03:29 - to refer to some code or want to copy
03:31 - paste some code all of it will be there
03:33 - for you it'll also be a great place to
03:35 - reference in the future when you're
03:36 - working on some project and you want to
03:38 - remember how to do something so be sure
03:40 - to start and refer back to it as you
03:42 - watch this video so let's talk a little
03:44 - bit about some best practices for
03:46 - watching this video this space moves
03:48 - really quickly so if we show you some
03:50 - documentation it might be a good idea
03:52 - for you to open that documentation up as
03:54 - well read through it as we do so you can
03:56 - stay up to speed now we've packed a ton
03:59 - of information in this video and studies
04:01 - have shown if you try to digest a
04:03 - massive amount of information in a short
04:05 - period of time your retention isn't as
04:07 - good so it's highly recommended that
04:10 - every 25 minutes to half an hour you
04:12 - take a five minute break and then every
04:14 - two hours maybe you take an additional
04:16 - 30 minute or an hour long break you can
04:18 - pause bookmark areas and come back later
04:20 - and learn at your own speed there are
04:22 - timestamps in the description that will
04:24 - help you come back to where you left off
04:26 - and you don't even have to go in order
04:28 - if you want to bounce around from topic
04:30 - to topic you're absolutely free to do so
04:32 - we're also going to get really technical
04:34 - with the fundamentals of blockchain and
04:36 - if you want to just jump right into
04:37 - solidity you can jump down the
04:38 - timestamps below and get right into it
04:42 - and if you're watching this on youtube
04:43 - you can adjust the speed that i talk and
04:45 - then i give this presentation so if i'm
04:48 - talking way too quickly for you you can
04:49 - slow it down or if i'm talking too
04:52 - slowly for you you can have me speed up
04:54 - so be sure to set me at the pace that
04:56 - you like best you are highly encouraged
04:58 - to pause come back and ask questions the
05:01 - blockchain in smart contract world is a
05:03 - very collaborative community so if you
05:06 - have questions some of the best places
05:07 - that you can go going to stack overflow
05:10 - and tagging your question with the
05:12 - specific technologies that you're
05:13 - working on make an issue on the github
05:15 - repo that we're working with go to stack
05:18 - exchange eth and make a question there
05:20 - as well jump into the discord of the
05:22 - technology that you're working with or
05:24 - even on github discussions if those are
05:26 - there learning to become a blockchain
05:28 - and solidity engineer is actually a lot
05:30 - more than just learning solidity
05:31 - becoming comfortable with all the tools
05:33 - in the space is going to be just as
05:35 - essential as becoming familiar with
05:37 - solidity itself and continuing the
05:39 - conversation on maybe twitter or reddit
05:42 - or any of these other channels and maybe
05:44 - even showing your stuff in the next
05:45 - ethereum or chainlink hackathon are
05:47 - going to be majorly beneficial to
05:49 - increasing your skill as an engineer
05:51 - now before we get actually coding a lot
05:53 - of people want to understand what is
05:55 - actually happening with all this
05:57 - blockchain stuff what is blockchain what
06:00 - is a smart contract how did this all get
06:02 - started and understanding these core
06:04 - fundamentals will actually shape the way
06:06 - you code and architect your smart
06:08 - contract applications so learning these
06:11 - is really really critical
06:12 - however if you're already familiar with
06:14 - blockchain and you just want to jump
06:16 - into the solidity feel free to grab a
06:18 - timestamp from the description and jump
06:20 - to that section
06:25 - now since you're here though you've
06:26 - probably heard of bitcoin before bitcoin
06:30 - was one of the first protocols to use
06:32 - this revolutionary technology called
06:34 - blockchain the bitcoin whitepaper was
06:37 - released by the pseudo-anonymous satoshi
06:39 - nakamoto and it outlined how bitcoin
06:42 - could be used to make peer-to-peer
06:43 - transactions in a decentralized network
06:46 - this network is powered by cryptography
06:49 - and allows people to engage in
06:51 - censorship resistant finance in a
06:54 - decentralized manner due to some of the
06:56 - features of bitcoin a lot of people took
06:58 - it to be as a superior store of value
07:00 - over another asset like let's say gold
07:03 - and that's why it's commonly referred to
07:05 - as digital gold similar to gold there is
07:08 - a scarce and set amount of it on the
07:10 - planet and people use it to buy and sell
07:13 - similar to other assets you can read
07:15 - more about the original vision in the
07:17 - white paper and there's a link to it in
07:18 - the description
07:20 - now this was a fantastic breakthrough
07:22 - and in a little bit we're actually going
07:23 - to look through how blockchains can
07:25 - actually work and how all of this is
07:27 - possible but some people took this and
07:29 - saw this technology and thought that
07:31 - they could do even more a few years
07:33 - later a man named metallic buterin
07:36 - released a white paper describing a new
07:38 - protocol called ethereum which used this
07:41 - same blockchain infrastructure but
07:44 - with an additional feature and in 2015
07:47 - they released this project called
07:49 - ethereum him and a number of other
07:51 - co-founders took this blockchain
07:52 - technology and applied it in ways that
07:55 - people can make entirely decentralized
07:57 - applications decentralize organizations
08:00 - and build smart contracts and engage in
08:03 - agreements without a third-party
08:05 - intermediary or centralized governing
08:07 - force their idea was to take the same
08:10 - pieces that made bitcoin great and add
08:12 - smart contracts to it and in fact this
08:15 - technically wasn't even a new idea back
08:18 - in 1994 a man named nick zabo proposed a
08:22 - technology called smart contracts a
08:24 - smart contract is a self-executing set
08:27 - of instructions that is executed without
08:30 - a third party intermediary they come to
08:32 - life on a blockchain and these smart
08:35 - contracts are really going to be the
08:37 - core thing that we're going to be
08:39 - working with and we're going to be
08:40 - developing smart contracts are similar
08:42 - to regular traditional contracts that
08:44 - people make between each other but
08:46 - instead of writing these contracts down
08:48 - on pen and paper or typing that on the
08:49 - computer it's entirely written in code
08:53 - the terms of the agreement are written
08:55 - in code and automatically executed by
08:58 - the decentralized blockchain network
09:00 - instead of being written pen and paper
09:02 - and executed by the two parties or three
09:04 - parties or however many parties involved
09:06 - this is one of the main differentiators
09:08 - between the ethereum protocol and the
09:10 - bitcoin protocol now technically bitcoin
09:13 - does also have smart contracts however
09:15 - they're not touring complete meaning
09:17 - that they don't have the full range of
09:19 - capabilities as a turing complete
09:21 - application like ethereum this is
09:23 - actually an intentional move by the
09:25 - bitcoin developers they view the bitcoin
09:27 - network as an asset whereas ethereum and
09:30 - the ethereum and developers viewed that
09:32 - acid as an asset and also a utility for
09:35 - people to build these smart contracts
09:37 - now these smart contracts are
09:38 - revolutionary technologies and we're
09:40 - going to talk a little bit more about
09:41 - what their advantage is in a little bit
09:43 - but they actually come with a fatal flaw
09:46 - with what's known as the oracle problem
09:48 - these blockchains are deterministic
09:50 - systems and we'll learn why they're
09:51 - deterministic very soon and this
09:53 - determinism means that they're a walled
09:55 - garden meaning that everything that
09:57 - happens in these smart contracts and on
09:58 - this blockchain happens in this little
10:01 - box now of course if you want these
10:03 - smart contracts to actually be these
10:04 - digital superior agreements then they
10:06 - need some way to interact with the real
10:08 - world and get real data and external
10:11 - outside the blockchain computation this
10:13 - is where oracles come into play oracles
10:15 - are devices that bring data into a
10:18 - blockchain or
10:19 - execute some type of external
10:21 - computation so great so oracles are the
10:23 - solution now blockchains can talk to the
10:25 - real world right
10:27 - well not quite our blockchains and smart
10:29 - contracts are these decentralized
10:30 - applications and in order for them to
10:33 - stay decentralized that means they would
10:35 - also need to get their data and external
10:37 - computation from a decentralized manner
10:39 - as well your on-chain logic will be
10:41 - decentralized on the blockchain but
10:43 - you'll also need your off-chain data and
10:45 - external computation decentralized as
10:47 - well combining these on-chain logic
10:49 - settlement layers and these off-chain
10:51 - data and external computation
10:53 - builds what's called hybrid smart
10:55 - contracts and a large majority of d5
10:57 - applications in the largest applications
10:59 - today are these hybrid smart contracts
11:01 - this is where the protocol chain link
11:02 - comes into play chain link is a
11:04 - decentralized modular oracle network
11:07 - that allows you to bring data into your
11:09 - smart contracts and do external
11:11 - computation and it's these hybrid smart
11:13 - contracts that can have this on-chain
11:15 - settlement and interact with the real
11:17 - world in some meaningful way chain link
11:19 - is an incredibly powerful oracle network
11:21 - because it allows us to get data get
11:23 - randomness do some type of upkeep or
11:25 - really customize our smart contracts in
11:28 - any way we want and elevate them to do
11:30 - anything that we want them to do now
11:32 - throughout the course when we're talking
11:34 - about smart contracts oftentimes we are
11:36 - also talking about hybrid smart
11:38 - contracts smart contracts is used a
11:40 - little bit interchangeably with hybrid
11:41 - smart contracts but just know that when
11:43 - we say hybrid smart contract we're
11:45 - talking specifically about smart
11:46 - contracts with an off chain component
11:49 - now throughout this video you'll hear
11:50 - people say smart contract you'll hear
11:52 - people say decentralized protocol
11:55 - decentralized application or dap and
11:58 - they kind of all are a little bit
12:00 - interchangeable a decentralized
12:02 - application is usually a combination of
12:04 - several smart contracts
12:06 - and when we start coding some solidity
12:08 - you'll see what a singular smart
12:10 - contract or singular contract looks like
12:12 - smart contracts are going to be what we
12:14 - code write and deploy for the majority
12:17 - of this video and learning some of these
12:19 - fundamental concepts will allow us to be
12:21 - better smart contract and better
12:22 - solidity developers now since its
12:25 - inception the ethereum protocol has
12:27 - given rise to many new paradigms and
12:29 - industries including d5 nfts
12:33 - dows or decentralized autonomous
12:35 - organizations
12:36 - layer twos and so much more
12:39 - and a couple of other protocols have
12:40 - taken this ethereum vision and gone in a
12:42 - different direction with it like polygon
12:45 - polka dot or avalanche if we learn the
12:48 - core basics of smart contract
12:49 - development on the ethereum platform all
12:52 - these skills translate to these other
12:54 - chains as well so don't worry about
12:56 - learning a specific tool or chain
12:57 - because most of them work together
12:59 - pretty seamlessly
13:01 - now there are a few exceptions to this
13:03 - rule and there are some smart contract
13:05 - platforms aka blockchains that don't use
13:08 - solidity however learning the
13:10 - fundamental skills here will still
13:12 - translate to every single other
13:14 - blockchain
13:15 - and ethereum is by far the most popular
13:19 - and most used smart contract blockchain
13:21 - or smart contract protocol you'll also
13:23 - hear those words used a little
13:25 - interchangeably as well sometimes i'll
13:27 - say blockchain or sometimes i'll say
13:29 - smart contract platform smart contract
13:31 - protocol and the like similarly chain
13:34 - link is the most popular and powerful
13:36 - decentralized oracle network and is
13:37 - going to be the one that we're going to
13:38 - focus on here chain link is also
13:40 - blockchain and smart contract platform
13:42 - agnostic meaning it'll work on ethereum
13:45 - avalanche polygon polka or really any
13:48 - blockchain or smart contract platform
13:50 - out there
13:51 - even in this introduction we've already
13:53 - learned a lot so let's do a quick
13:54 - summary of what we've talked about
13:56 - bitcoin was the first application to
13:58 - take the blockchain technology into the
14:00 - limelight and into a meaningful way
14:02 - bitcoin is a sort of digital gold able
14:05 - to make transactions between users as
14:07 - almost a sort of currency ethereum takes
14:09 - this blockchain technology one step
14:11 - further but you can also build smart
14:14 - contract or decentralized applications
14:16 - decentralized autonomous organizations
14:18 - and more because you can code with smart
14:21 - contracts these smart contracts can then
14:24 - access external data and external
14:25 - computation outside the blockchain using
14:28 - what's called oracles chain link is the
14:30 - most powerful decentralized oracle
14:32 - network and allows us to build these
14:34 - hybrid smart contracts which is a
14:35 - combination of decentralized on-chain
14:38 - logic settlement layer and any
14:40 - decentralized external off-chain data or
14:43 - computation hybrid smart contracts and
14:45 - smart contracts are often used
14:46 - interchangeably now you're probably
14:48 - asking yourself a lot of questions right
14:49 - now like what makes bitcoin so
14:51 - interesting what makes it like a digital
14:53 - gold and how are these smart contracts
14:55 - going to add any value to the real world
14:57 - and that's what we're going to go into
14:58 - now so before we get into the
15:00 - nitty-gritty of how these blockchains
15:02 - and how these smart contracts actually
15:04 - work from a low level let's go
15:06 - high level and talk about some of the
15:08 - features and massive advantages that
15:11 - blockchains and smart contracts have
15:12 - over our traditional environments the
15:15 - first feature that these have is they
15:16 - are decentralized and you'll hear this
15:19 - term used a lot because it has a massive
15:22 - benefit blockchains are decentralized
15:25 - meaning there's no centralized source
15:27 - that controls the blockchain the
15:29 - individuals that make up blockchain are
15:32 - known as node operators and they are the
15:34 - independent individuals running the
15:36 - software that connects the whole
15:38 - blockchain together it's all these
15:40 - different independent individuals that
15:42 - make the blockchain and blockchain like
15:44 - networks decentralized we'll dive deeper
15:47 - into that concept later great example of
15:50 - why this is so fundamentally
15:52 - groundbreaking is if we go back to what
15:54 - happened recently even with robinhood
15:56 - and gamestop gamestop shares were no
15:59 - longer allowed to be bought because a
16:01 - centralized entity didn't want them to
16:04 - be bought anymore so they
16:06 - flipped a switch and nobody could buy
16:08 - that stock anymore essentially having a
16:10 - single entity controlling the entire
16:13 - financial market the fact that a single
16:15 - entity has the power to make these
16:17 - choices for us is a travesty and
16:20 - blockchain is here to solve that there's
16:22 - a narrative here called the bankless
16:24 - narrative where users can actually live
16:26 - in a world where they don't have a bank
16:28 - banks while good in their own right have
16:31 - a history of doing some shady things
16:33 - they also have the power to potentially
16:35 - freeze your funds not letting you
16:37 - withdraw or move or do anything because
16:39 - they are a centralized entity that again
16:41 - can
16:42 - flip a switch and control how you
16:44 - interact with your life every day being
16:47 - free of these centralized entities have
16:49 - this much power and this much control
16:51 - over your life has widespread positive
16:54 - ramifications transparency and
16:56 - flexibility
16:58 - everything that's done on a blockchain
17:00 - and all the rules that are made can be
17:02 - seen by everyone there's no backdoor
17:05 - deals there's no shady happenings
17:07 - everything that happens on chain you can
17:10 - see this means that there's no special
17:12 - information that a few have
17:14 - everyone has to play by the same rules
17:16 - and everyone can see exactly what those
17:19 - rules are
17:20 - now additionally this doesn't mean that
17:23 - everything you do is tracked the
17:24 - blockchain is pseudo-anonymous so you
17:27 - can create different accounts and you
17:28 - can interact with it in many different
17:30 - ways this leads me to my freedom point
17:33 - but i'll get there in a second speed and
17:35 - efficiency have you ever tried to make a
17:37 - withdrawal from the bank and it took
17:39 - three to five days
17:41 - all the bank is doing is adding and
17:43 - subtracting numbers
17:44 - basic first grade math
17:47 - so why does it take so long because
17:49 - blockchains are verified by a
17:51 - decentralized collective the settlement
17:53 - or withdrawal period in this case is
17:56 - substantially faster and depending on
17:58 - the blockchain that you're using it can
17:59 - be from
18:00 - 10 minutes all the way down to just a
18:03 - couple of seconds in the stock trading
18:05 - or hedge fund world it can actually take
18:06 - up to a week for your buy or sell of a
18:10 - stock to go through security and
18:12 - immutability blockchains are immutable
18:15 - which means they can't be changed and
18:17 - because of this it means that they can't
18:19 - be tampered with or corrupted in any way
18:22 - shape or form this allows us to have
18:24 - massive security on our data on our
18:27 - transactions and anything of the like if
18:29 - your computer goes down and your backup
18:31 - computers go down
18:34 - in the regular world your data is gone
18:36 - if all your data is on those two
18:37 - computers you're out of luck on a
18:39 - blockchain if several nodes go down it
18:42 - doesn't matter because as long as one
18:45 - node and the entire system is running
18:47 - the data is safe and secure there are
18:50 - thousands or hundreds of thousands of
18:52 - nodes running these blockchain softwares
18:54 - meaning that everything that happens
18:56 - happens and is immutable and won't
18:58 - change
18:59 - hacking the blockchain is nearly
19:02 - impossible and substantially harder than
19:05 - hacking a centralized entity and this is
19:07 - also much more secure in the asset sense
19:09 - as well instead of having gold in a
19:11 - vault or contract written on a piece of
19:13 - paper or on your computer you have a
19:16 - asset that is
19:18 - locked on the blockchain forever and all
19:20 - you need to do to access it is have a
19:22 - private key or mnemonic
19:25 - which is essentially a password so you
19:28 - don't have to lug your gold around or
19:30 - lug your contracts around with you it is
19:32 - always on the blockchain smart contracts
19:35 - in particular remove a massive conflict
19:38 - of interest in the traditional world
19:40 - when we engage with users or individuals
19:43 - they don't always have our best
19:45 - interests at heart
19:46 - a lot of them are usually self-motivated
19:49 - in some sense and there's nothing wrong
19:51 - with that that's how a lot of people are
19:52 - however when we make an agreement with
19:54 - them this agreement can have a massive
19:57 - conflict of interest with the user who's
19:59 - supposed to execute that agreement
20:01 - let's take insurance for example if i
20:03 - pay an insurance provider 100 a month
20:05 - i'm paying them a hundred dollars and in
20:07 - the event that i get hit by a bus we've
20:09 - made an agreement or a contract that
20:12 - they're going to pay my medical bills or
20:14 - bail me out however they have this
20:17 - massive conflict of interest insurance
20:19 - companies aren't in the business of
20:20 - giving out money they're in the business
20:23 - of making money so even though they've
20:25 - signed this agreement when this event
20:28 - occurs they still don't want to pay this
20:31 - money out to me and if they can find a
20:33 - loophole in the contract they will
20:35 - because that is what they are motivated
20:37 - to do so they sign this agreement but
20:40 - it's not in their best interest to do so
20:42 - so they have this massive conflict of
20:44 - interest and this is native in all of
20:46 - the agreements that we make today they
20:48 - are the ones who decides whether or not
20:50 - they're going to execute their agreement
20:52 - giving execution power to the party that
20:54 - doesn't want to execute something has
20:57 - often led to frustration now the
20:59 - follow-up is you can always sue them and
21:01 - go through this process but now you're
21:03 - wasting all this time going through this
21:05 - long process to get something that you
21:07 - should have originally gotten in the
21:09 - first place
21:10 - this leads me to one of the biggest
21:12 - value adds to smart contracts smart
21:14 - contracts allow us to engage in
21:16 - trustless and trust minimized agreements
21:20 - we currently live in a world of
21:22 - brand-based agreements
21:24 - if i engage in some agreement and i
21:26 - don't like the service that i'm provided
21:28 - my alternative to this is to waltz down
21:31 - the street to another brand to another
21:34 - service who's going to make the exact
21:36 - same set of promises to me and then i
21:38 - have to trust them that they're going to
21:41 - execute faithfully smart contracts allow
21:43 - us to move from this brand based
21:46 - agreements to
21:48 - math-based agreements these math-based
21:50 - agreements we don't even have to trust
21:53 - that they're going to do the right thing
21:54 - hence the name trustless one plus one is
21:58 - always going to equal two in a math
22:00 - world whatever the code determines is
22:02 - the input output that's exactly what's
22:05 - gonna happen every single time
22:08 - now for me these really all add up to
22:10 - two major pieces
22:12 - freedom
22:13 - and trustless all these pieces allow us
22:16 - to live in a world that's more
22:17 - accountable more trusting more friendly
22:21 - and
22:21 - just better it allows us to work in an
22:24 - environment and a universe where things
22:25 - just
22:26 - work
22:27 - it allows us to do the freedom to engage
22:30 - with other people how we wish because
22:32 - there's no centralized controlling body
22:35 - influencing every action that we make
22:37 - all the rules are the same and nobody's
22:40 - getting special treatment
22:42 - this brings out this new world of
22:43 - economic opportunity as well and as our
22:46 - lives become more and more digital we're
22:48 - constantly being bombarded with
22:50 - centralized services that want us to use
22:52 - their interface so they can profit on
22:55 - how we interact and force us or push us
22:58 - to making the decisions that they're
23:00 - motivated for us to make smart contracts
23:03 - decentralized applications and
23:05 - blockchain
23:06 - allows us to be free of these repressors
23:10 - and live in an environment that's truly
23:13 - free and trustless
23:15 - so with all that high level being said
23:18 - let's do a quick summary of what we just
23:20 - learned blockchains are decentralized
23:24 - meaning that they are not controlled by
23:25 - a single centralized entity it is run by
23:28 - a network of independent users
23:32 - transparency blockchains are transparent
23:35 - everything that happens on a blockchain
23:37 - everybody else can see and everybody
23:40 - else can work with and see that
23:41 - everyone's playing by the same rules
23:44 - blockchains are quick and efficient
23:46 - especially when it comes to monetary
23:47 - policy settlement on blockchains are
23:50 - fast and easy immutability and security
23:53 - blockchains can't be changed or tampered
23:56 - with or corrupted and are incredibly
23:59 - incredibly secure smart contracts remove
24:02 - the massive conflict of interest
24:04 - traditional agreements have smart
24:06 - contracts allow us to move away from
24:08 - political brand-based agreements to
24:10 - secure
24:12 - math-based agreements smart contracts
24:14 - allow us to engage in trustless and
24:16 - trust minimized agreements
24:18 - smart contracts are a set of
24:20 - instructions which when placed on a
24:22 - blockchain are self-executing pieces of
24:24 - code not run by any centralized
24:27 - intermediary in addition smart contracts
24:29 - are typically paired with some type of
24:31 - oracle to get some information about the
24:33 - real world when smart contracts are
24:34 - paired with an oracle they're called
24:36 - hybrid smart contracts chain link is a
24:38 - secure decentralized modular oracle
24:41 - network used to bring data into your
24:43 - smart contracts and also make some type
24:45 - of external computation i also briefly
24:47 - want to mention dao's or decentralized
24:49 - autonomous organizations you'll hear
24:51 - this referred to a lot as well
24:53 - decentralized autonomous organizations
24:55 - are organizations that live online and
24:58 - live in these smart contracts they're
25:00 - similar to a regular organization in the
25:02 - traditional world however they have
25:04 - people who maybe hold governance tokens
25:05 - to make voting decisions or they do all
25:07 - their governance on chain
25:10 - on this decentralized settlement layer
25:12 - giving us the freedom to engage with
25:14 - each other as we please
25:16 - so now that we've taken our first dive
25:18 - into blockchains and smart contracts and
25:20 - at least from a high level understood
25:22 - why they're so advantageous let's jump
25:24 - in let's get an ethereum wallet and
25:27 - let's make our first transaction on a
25:31 - live blockchain are you ready now let's
25:34 - jump into ethereum we're going to make
25:36 - our first interaction with the ethereum
25:38 - blockchain and once we do this
25:40 - interaction once we make this
25:41 - transaction
25:42 - then we're going to go back and look at
25:44 - what actually happened what were the
25:46 - technical implications that allowed this
25:47 - transaction to go through so in order
25:50 - for us to interact with the blockchain
25:52 - the first thing that we're going to need
25:53 - is an ethereum wallet
25:56 - so i'm going to go ahead and go to
25:58 - metamask because it's one of the most
25:59 - popular wallets and one of the easiest
26:02 - to use we're going to go ahead and
26:03 - download it
26:05 - i'm using the brave browser but it works
26:07 - for chrome firefox or really any other
26:09 - browsers
26:10 - and it's just going to be a little
26:12 - extension in the top right hand
26:14 - of your browser
26:16 - this way we can really easily see at any
26:18 - time what we have in our wallet
26:21 - this will store all of our ethereum
26:23 - based currencies
26:25 - so i'm going to go ahead and install
26:26 - metamask for brave
26:28 - add to brave
26:30 - add extension
26:32 - and now we can go ahead and get started
26:34 - with working with brave this is the
26:37 - first step you absolutely need to take
26:38 - when starting your journey and one of
26:40 - the easiest steps to take so we're going
26:42 - to go ahead and get started
26:44 - and we're going to create a brand new
26:46 - wallet so we're going to go ahead and
26:47 - hit create wallet
26:48 - if you already have a wallet you can
26:51 - actually import it via i have a seed
26:53 - phrase and we'll talk about the seed
26:55 - phrase or secret phrase in a little bit
26:57 - so let's go ahead and create a new
26:58 - wallet
26:59 - and sure we'll agree to help out
27:01 - metamask now we will create our password
27:04 - make sure that this is really secure
27:06 - for the purpose of this demo my
27:08 - passwords are just gonna be password but
27:10 - please don't have that be a password now
27:11 - when i'm doing my testing when i'm doing
27:13 - my coding i actually use a separate
27:15 - account from the account that i actually
27:16 - have real money in however if you want
27:19 - to use this account and actually put
27:20 - real ethereum and put real money into it
27:23 - you absolutely 100
27:25 - need to back this up so we're gonna go
27:27 - ahead and click reveal secret words i'm
27:30 - showing you guys here because
27:32 - uh this is just a demo and i don't
27:34 - really care however if you show this
27:36 - secret phrase to anybody else they will
27:39 - have access to
27:40 - all funds
27:42 - so everything that we're gonna do in
27:43 - this tutorial we're gonna use fake money
27:45 - we're gonna use not real money so it
27:47 - doesn't matter however if you're going
27:49 - to actually put money in here you
27:50 - absolutely need to have this written
27:52 - down because if you lose access to this
27:54 - and or your private keys which we'll
27:56 - talk about in a little bit you will lose
27:57 - access to your wallet and you will lose
28:00 - access to all your funds
28:01 - so they give some tips like store this
28:03 - phrase and a password manager like one
28:05 - password write this phrase down on a
28:07 - piece of paper put it in a secure
28:09 - location memorize it whatever you want
28:11 - to do just make sure you have this
28:13 - backed up somewhere
28:14 - i'm just going to go ahead and hit
28:15 - download this for now and i'm going to
28:17 - save it on my computer it's not best
28:19 - practice to save to your computer it is
28:21 - much better to use a password manager or
28:23 - write it down on a piece of paper or
28:24 - something
28:25 - but again because we're just demoing
28:26 - here
28:27 - i'm going to show you it here and we're
28:29 - not going to put any real funds into
28:30 - this
28:31 - so we're going to go ahead and hit next
28:33 - and we're it's going to ask us to
28:36 - make sure we and it's going to ask us to
28:38 - verify that we actually have it written
28:39 - down
28:43 - and we're gonna go ahead and hit confirm
28:45 - and great and it gives us a couple other
28:47 - tips remember definitely take these tips
28:49 - very seriously especially if you're
28:51 - gonna use this for real money like i
28:52 - said for this demo we're just gonna use
28:54 - test money so it's not as big of a deal
28:56 - but if you put real money in you
28:58 - absolutely need to back up this seed
29:00 - phrase or secret phrase or we're going
29:02 - to refer to it as our mnemonic phrase
29:05 - awesome now we can see the user
29:07 - interface of this wallet
29:09 - and depending on your browser if you
29:10 - actually go ahead and look in your
29:12 - extensions you can pin it to your
29:14 - browser and you can even just click it
29:16 - and get the same interface here let's
29:18 - take some inventory of what is actually
29:20 - going on in here and what we actually
29:22 - have our mnemonic phrase that secret
29:25 - phrase that we got
29:26 - has given us access to a new account and
29:30 - here's the address of our account we can
29:32 - use a tool like etherscan to view
29:34 - different addresses and what's been
29:36 - going on with them so if we look at this
29:39 - address that we just created on
29:40 - etherscan we can see that no
29:42 - transactions have happened it's empty it
29:44 - has zero ether in it it has zero dollars
29:47 - worth of value in it and this address
29:49 - here
29:49 - is our unique address this address
29:52 - represents
29:53 - exclusively this single account that we
29:56 - just created we'll talk a little bit
29:58 - more about etherscan in a bit as it's a
30:00 - tool that we're going to use more and
30:01 - more now we can even click this
30:04 - circle here and we can even create more
30:07 - accounts and give it a different account
30:09 - name
30:10 - we'll call it account 2.
30:12 - this one has a different address so if
30:15 - we go ahead go back to etherscan and
30:17 - look this up this one has a different
30:19 - address here
30:20 - so we can have multiple addresses in
30:22 - here and now if i click this i have two
30:24 - accounts account one
30:26 - and account two
30:28 - the mnemonic that we've been given
30:30 - gives us access to create multiple
30:33 - accounts with that same mnemonic so
30:35 - having that mnemonic will give us access
30:37 - to every single account that's ever
30:39 - created with that mnemonic this is why
30:41 - securing your mnemonic is so crucial
30:43 - especially if you create multiple
30:45 - different accounts
30:46 - now each account
30:48 - has a unique identifier with them as
30:51 - well so so this right here is the public
30:54 - address when we copy this this is the
30:56 - public address of that account
30:58 - however there's also a private key to
31:01 - work with this account a secret key
31:03 - and we can go ahead and view it by
31:05 - clicking these three dots go to account
31:06 - details and export private key
31:10 - put our password in and confirm
31:12 - so this is going to be our private key
31:14 - so this is a single
31:16 - password associated with this account if
31:19 - you give somebody else access to this
31:21 - private key they will have access to my
31:23 - account too they won't have access to my
31:26 - account one because the private key of
31:28 - account two is only associated with
31:29 - account two the mnemonic however is
31:32 - associated with all accounts and this is
31:34 - why when people say store your private
31:36 - keys in a safe place or store your keys
31:38 - in a safe face they're usually referring
31:40 - to both your mnemonic and your private
31:42 - keys
31:43 - if you lose your private key you lose
31:45 - access to this account if you lose your
31:47 - mnemonic you lose access to all your
31:49 - accounts so long story short back up
31:52 - your mnemonic since it has access to
31:54 - everything and back up your private keys
31:56 - too but just keep in mind they only have
31:58 - access to the individual accounts and
32:00 - great those are some of the main
32:01 - security pieces here
32:02 - now what else is going on in metamask is
32:04 - we can see this section here that says
32:06 - ethereum mainnet if we click it we
32:08 - actually see a bunch of other networks
32:10 - in here
32:11 - so when you buy eth and when you work
32:13 - with eth you're working on the ethereum
32:15 - mainnet when you interact with smart
32:16 - contracts or d5 or any things that we're
32:19 - going to talk about later on mainnet
32:21 - with real value you're going to be
32:23 - working on the mainnet
32:25 - however since we're engineers oftentimes
32:28 - we're going to want to test our
32:29 - applications or do some type of
32:31 - integration tests or just make sure our
32:33 - code actually works
32:35 - so there's also what's called test nets
32:38 - these are networks that resemble
32:40 - ethereum and work exactly the same way
32:43 - as ethereum does
32:44 - however they're not with real money and
32:47 - it's just for testing your applications
32:49 - so we can even go to ether scan and look
32:51 - up
32:52 - brinkp ether scan
32:54 - we can see the rink be test on explorer
32:57 - we look up at our address and it's the
32:59 - exact same
33:00 - information here
33:02 - nothing has gone on on rink b and this
33:04 - is totally different so when we make a
33:06 - transaction these are all different
33:08 - networks and it says test network it's
33:10 - made to be made without real money later
33:13 - on we're actually going to show you how
33:14 - to work with other evm compatible chains
33:17 - don't worry about what evm compatible
33:19 - means for now but we can work with
33:21 - avalanche polygon and other applications
33:24 - through this networks interface as well
33:26 - so remember a testnet blockchain is a
33:28 - blockchain where the currency doesn't
33:30 - have any real value but it resembles and
33:32 - acts exactly like the ethereum mainnet
33:34 - so we can test our applications
33:36 - so we can test and practice our
33:37 - applications
33:39 - in fact what we're going to do right now
33:41 - is make our first transaction on the
33:43 - rink b test net and this will simulate
33:45 - exactly what it's like to make a
33:47 - transaction on the ethereum mainnet so
33:49 - we're going to go to this application
33:50 - called the rink b faucet this is where
33:53 - we're going to make our first
33:54 - transaction ring b is going to be one of
33:57 - two test nets that we're actually going
33:59 - to work with the other test net that
34:01 - we're going to work with is going to be
34:02 - coven it's important to know how to
34:04 - switch between test nets and evm
34:07 - compatible chains which is why we're
34:09 - going to be working with both for now
34:10 - we're just going to be working with rink
34:12 - b
34:12 - a faucet is a tested application that
34:15 - gives us free test ethereum hence why it
34:18 - has no value because anybody can get it
34:19 - for free from one of these faucets so to
34:21 - get tested ethereum with this
34:23 - application we actually have to post a
34:25 - tweet or a facebook post
34:28 - with this tweet so i'm actually going to
34:31 - i'm going to sign in real quick
34:33 - and now that i'm signed in i can post
34:35 - this tweet requesting faucet funds into
34:39 - and this is where i'm going to put my
34:41 - address
34:42 - on the rinkby ethereum test network i'm
34:45 - going to go ahead and tweet that out
34:47 - now that i have this
34:49 - we're gonna copy link to tweet
34:51 - and we're gonna place it in here and
34:54 - we're gonna hit give me ether and we're
34:56 - gonna say 18.75 ether for three days and
34:59 - it said funding request accepted for
35:02 - patrick alpha c
35:03 - into this
35:05 - and what we can do then
35:07 - is if we take this address again
35:10 - we go over to rink b ether scan
35:16 - we now see that the balance is 18.75
35:20 - and we can even see that
35:22 - in our wallet on the ringbeat network we
35:24 - have 18.75 eth but again if we look at
35:27 - mainnet we have nothing there if we look
35:30 - at robson we have nothing there if we
35:32 - look at rink b we have 18.75 right so
35:34 - these are very different networks and
35:36 - we've just made our first transaction
35:39 - we've been given
35:40 - 18.75 eth and if we refresh this page we
35:44 - also see that this is our first
35:46 - transaction that was made
35:48 - some account sent us 18.75 ether
35:52 - from
35:53 - this account to us and we can actually
35:56 - even look at the details of this
35:57 - transaction
35:59 - etherscan is what's known as a block
36:01 - explorer block explorers are
36:03 - applications that allow us to see
36:05 - details of things that happen on a
36:07 - blockchain easily we can see the
36:08 - transaction details of this transaction
36:11 - here and whenever we work with smart
36:13 - contracts we will also see them in a
36:15 - transaction similar to what we're seeing
36:16 - right here and again we'll talk about
36:18 - that soon now we can see a number of
36:20 - information here we see a unique
36:22 - transaction hash this hash or this
36:25 - unique identifier uniquely identifies
36:28 - this transaction
36:29 - as the key of what this transaction is
36:32 - we see that it was a successful
36:33 - transaction this is the block number
36:36 - which we'll talk about in a little bit
36:38 - we see it was from this unique account
36:41 - which looks like they did a ton of
36:43 - transactions because this is the faucet
36:44 - account
36:45 - to our account that we created
36:47 - value was 18.75 ether
36:50 - and then we have these transaction fees
36:53 - gas price gas limit and gas used now gas
36:56 - refers to the fee paid to node operators
36:59 - for successfully including a transaction
37:02 - in a blockchain
37:03 - now exactly how this works is actually
37:05 - going to change pretty soon but the
37:07 - concept is basically anytime you want to
37:09 - change the state of blockchain whether
37:11 - this is sending some ethereum or making
37:14 - any type of transaction
37:16 - you actually have to pay a little bit of
37:18 - ethereum or a little bit of that native
37:20 - blockchain token to actually execute
37:23 - that transaction whenever we do
37:25 - something on the blockchain
37:27 - it costs gas and if we do something that
37:30 - would take a lot of energy for the
37:31 - blockchain to do it will cost more gas
37:34 - so if i send a single transaction that's
37:36 - going to cost 21 000 gas however if i
37:39 - were to do if i were to send a
37:41 - transaction that called the smart
37:42 - contract function and did a whole bunch
37:44 - of other stuff it would cost more gas so
37:47 - we see here when we got sent
37:49 - 18.75 eth whoever sent us that eth also
37:53 - paid the blockchain miners or the
37:56 - blockchain validators a little bit of
37:58 - ethereum to include our transaction now
38:00 - we actually get to pick how much of a
38:02 - fee we want to send with our
38:03 - transactions so let's look at another
38:06 - example so
38:07 - in our accounts in metamask let's even
38:10 - expand the view here
38:12 - we have two different accounts we have
38:14 - account one and account two account one
38:16 - has 18.75 account two has zero
38:20 - we can actually send money from account
38:22 - one to account two and again remember
38:24 - this is all fake money so so we're gonna
38:26 - go ahead and hit transfer between my
38:28 - accounts so we're gonna send money to
38:30 - account two
38:32 - and here's where we can see some
38:33 - transaction details and we see the asset
38:36 - that we're going to send which we only
38:38 - have ethereum in this wallet so we're
38:40 - only going to send ethereum later on
38:41 - we'll learn how to get different assets
38:43 - into this wallet we're going to choose
38:44 - an amount i'm just going to choose to
38:46 - send one and then we have these pieces
38:49 - here
38:50 - associated with the transaction fee so
38:52 - we have a gas price in guay and a gas
38:55 - limit so when we send a transaction we
38:57 - can choose a gas limit we can say hey if
39:00 - this transaction is going to spend more
39:02 - gas than
39:03 - 21 000 gas we're not going to do it
39:07 - we also get to set a gas price in guay
39:11 - but here's the quick example of guay
39:13 - versus ethereum
39:14 - [Music]
39:17 - one ether is
39:20 - this many gray
39:21 - and one gray is this much ether because
39:24 - if we just said hey could you send me
39:26 - .00001
39:29 - that would be
39:30 - kind of really obnoxious so we just just
39:32 - say send me one way or send me one way
39:35 - so i know we've been throwing this gas
39:37 - term around for a little bit but here is
39:39 - it basically simplified gas is going to
39:41 - be the measurement of how much
39:43 - computation something uses the gas price
39:46 - is going to be how much it costs per
39:48 - unit of gas a gas limit is going to be
39:51 - the maximum amount of gas that can be
39:53 - used in transaction so for example if we
39:56 - make a transaction that uses 21 000 gas
40:01 - and each one gas is one way
40:05 - in price that means we're going to pay
40:07 - 21 000 way
40:09 - in transaction fee
40:11 - so back in our transaction we have we're
40:13 - saying the gas price
40:15 - is going to be one way so the
40:17 - transaction fee is going to be the gas
40:19 - that we use which will be up to this gas
40:21 - amount
40:22 - times the gas price so it'll be 21 000
40:26 - way will be the transaction fee so then
40:28 - the question is well why would we ever
40:30 - bump it up why would we want to pay more
40:33 - gas price why do i even have the option
40:35 - to pay more well and this comes down to
40:38 - block space we'll talk about this a
40:40 - little bit more when we get into how the
40:41 - blockchain actually works but the
40:43 - blockchain can only
40:45 - process so many transactions at a time
40:47 - and nodes and blockchain nodes can only
40:49 - process so many at a time so when i make
40:52 - a transaction a node has to decide why
40:55 - they want to include my transaction into
40:57 - the block and if there are a ton of
40:59 - people
41:00 - looking to make these transactions then
41:02 - the nodes are going to be highly
41:04 - incentivized to pick the transactions
41:07 - that are going to give them a high price
41:09 - that are going to give them a lot of
41:10 - money for including that transaction
41:13 - so this is what's called eath gas
41:15 - station and it is a a gas estimator of
41:19 - the blockchain it currently says that if
41:21 - you want to get your
41:23 - transaction in right away it's going to
41:25 - cost you 31 way to do so if you want to
41:28 - get it in less than five minutes it's
41:29 - going to take you maybe about 21 gway
41:32 - so the gas prices of ethereum fluctuate
41:35 - with how much people use it and the gas
41:37 - prices of all these blockchains
41:38 - fluctuate with how much people use it
41:41 - so this is an important concept so
41:43 - typically when you're setting your gas
41:45 - price in a transaction you can take a
41:47 - look-see at you know gas station and say
41:49 - okay if i want mine to go in right away
41:51 - i'm going to do asap if i want to go in
41:53 - fast maybe i'll do you know this fast
41:55 - amount standard i'll do this standard
41:57 - amount but it all depends on how many
42:00 - people are looking to work with this
42:01 - blockchain at the same time and and as
42:03 - you can see it fluctuates pretty quickly
42:05 - right it just went all the way up to 46
42:06 - so maybe more people are using the
42:08 - blockchain now this is obviously for the
42:10 - eth main net and on the test net there's
42:12 - not going to be that same competition
42:13 - but we can still change it anyway so if
42:15 - i go ahead and do 100 for the gas price
42:18 - and i hit next and i hit confirm if i go
42:20 - to activity
42:22 - i now have
42:23 - this transaction
42:25 - in my
42:27 - metamask but i can go ahead and view
42:29 - this on etherscan as well
42:31 - and we can see this is what it looks
42:33 - like when it's still processing this
42:34 - transaction and now we can see that it's
42:36 - passed and now if we look at the gas
42:38 - price we see it's a hundred gray and
42:41 - this is what we set it as when we were
42:42 - working with it before so gas prices 100
42:45 - way here versus our first original
42:47 - transaction was just one way
42:50 - now if we look at our metamask we can
42:52 - see that
42:53 - the funds have indeed been
42:55 - subtracted from this account and they
42:57 - have been added to this account now
42:59 - there's one eighth in this account
43:01 - awesome and you can see the activity
43:02 - there's one ethan here so again the
43:04 - reason that these gas prices exist is
43:06 - because nodes can only put so many
43:09 - transactions into a block so they're
43:11 - highly incentivized to input the
43:13 - transactions that are going to give them
43:15 - a higher fee so in times when a lot of
43:18 - people are looking to use a blockchain
43:19 - prices will get very high and when very
43:21 - few people are using a blockchain prices
43:23 - will be very low this ether scan tool is
43:26 - incredibly incredibly powerful and we'll
43:28 - be using it more and more as time goes
43:30 - on now here's something that's
43:31 - incredibly exciting with just this
43:32 - little bit of information you now know
43:34 - how to interact with blockchains and
43:36 - interact with the ethereum protocol so
43:38 - if you don't want to learn how to code
43:40 - anything you can go and you can start
43:42 - interacting with ethereum and interact
43:44 - with protocols with just this much
43:46 - information however i know most of you
43:48 - guys are here to learn how to code so
43:49 - let's look under the hood of ethereum
43:51 - and what is actually going on with these
43:53 - transactions
43:54 - and with these gas and with these
43:55 - blockchains and what's really going on
43:58 - let's learn all the fundamentals of a
44:00 - blockchain now if you want to just go
44:01 - ahead and jump into the coding go ahead
44:03 - and grab a timestamp from the
44:05 - description however learning exactly how
44:08 - the blockchain works is going to make
44:09 - you an incredibly powerful developer so
44:11 - let's take a look at that first so we're
44:13 - going to be going through this
44:13 - blockchain demo on this site right here
44:15 - now the creator of the site has a
44:17 - fantastic video and a fantastic
44:19 - walkthrough blockchain 101 it is right
44:21 - on their site so if you're looking for
44:23 - another explanation definitely check out
44:25 - his video it is absolutely fantastic but
44:27 - the first thing that we really need to
44:28 - do in order to understand blockchain in
44:30 - order to find really anything and
44:31 - everything that's going on here we first
44:33 - really need to understand this shot 256
44:35 - hash or hashing just kind of in general
44:38 - let's first understand what a hash is a
44:40 - hash is a unique fixed length string
44:43 - meant to identify any piece of data they
44:46 - are created by putting some piece of
44:48 - data into a hash function
44:50 - in this example
44:52 - the hashing algorithm used is sha256 now
44:55 - ethereum actually uses this this right
44:57 - here for its hashing algorithm which
44:59 - isn't quite um sha256 but is in kind of
45:02 - this shaw family but it's it's really
45:05 - just another way to hash things and uh
45:07 - the specific hash algorithm doesn't
45:09 - matter uh so much so uh this example
45:12 - uses sha-256 but you can imagine it's
45:14 - the same as the ethereum hash they're
45:15 - just gonna you know result in a
45:17 - different hash
45:18 - so what's going to happen in this
45:20 - application here is whatever
45:22 - data or whatever information we put into
45:25 - this data section here as you can see
45:27 - below this hash
45:29 - changes
45:30 - so what's happening is this data is
45:33 - running through the sha 256 hash
45:36 - algorithm and it's outputting this
45:38 - unique hash so this
45:41 - hash is a unique fixed length string
45:44 - that's going to identify like a blank
45:46 - data piece here right so if i put in you
45:47 - know my name like you know patrick
45:49 - collins
45:50 - this is the hash that's going to
45:52 - represent patrick collins right and you
45:54 - can see
45:55 - even when i put you know tons and tons
45:58 - of data in here the length of the string
46:02 - doesn't change
46:03 - right
46:04 - so it's always going to be the same
46:06 - amount we can put
46:07 - almost any amount of data in here there
46:09 - is an upper limit on the max size of the
46:12 - data but for all intents and purposes we
46:14 - can pretty much put any length in here
46:17 - and you'll see too that you know every
46:18 - time i type in patrick collins
46:20 - this hash is always going to be this
46:22 - 7e5b right i'm going to delete i'm going
46:24 - to do
46:24 - patrick collins again
46:26 - you know seven e5b it's always this this
46:29 - unique hash is always going to be
46:31 - unique right it's always gonna be this
46:32 - fixed length string here so now we can
46:35 - take this idea right of putting this
46:36 - data in here and we can move on to
46:38 - uh this concept of a block so with this
46:41 - block concept we're going to take the
46:43 - exact same thing with this hash this
46:44 - this data section right but instead of
46:46 - having everything just being this this
46:48 - singular data area right here we're
46:50 - going to split this data up into block
46:53 - nuns and data so all so what we're going
46:55 - to do is we're actually going to hash
46:57 - all three of these to get to get this
46:59 - hash right we're going to put all three
47:00 - of these we're going to say all three of
47:01 - these are combined uh together we're
47:04 - going to put every all three of them
47:05 - into this hashing algorithm uh to figure
47:07 - it out so if i type a bunch of stuff
47:09 - here
47:10 - we can see that block one
47:12 - with nuns you know this nonce and this
47:15 - data we're gonna get this hash and as
47:17 - you can see actually
47:18 - the screen turns red this block turned
47:21 - red now
47:23 - what happens when i hit this mine button
47:25 - when i hit this mine button it's
47:27 - actually going to take some time it's
47:28 - going to think for a little bit and we
47:30 - can see that the nuns here actually
47:32 - changed right the nuns is different from
47:34 - what it was before and
47:36 - this hash now starts with four zeros
47:40 - okay and then it the the back turned
47:41 - green when we're talking about mining
47:43 - we're talking about miners solving some
47:45 - type of very difficult problem that
47:47 - takes a lot of time to do now in this
47:49 - example here the problem that the miners
47:53 - had to solve was they had to find a nuns
47:56 - or or a value in this nun section that
47:58 - when hashed with at block number one
48:00 - with this data
48:02 - it would start with four zeros
48:04 - so the problem here the miners had to
48:06 - solve was to start with four zeros and
48:07 - the only way for them to really do that
48:10 - is kind of this brute force you know
48:12 - trying stuff so they tried one okay one
48:13 - didn't work okay two nope two didn't
48:15 - work three no four or five six okay five
48:18 - well that started with one zero but it's
48:19 - not four and they have to keep trying
48:22 - all these numbers until they uh get to
48:24 - this one where you know let's hit mine
48:26 - again
48:29 - where it has four zeros at the top at
48:31 - the start
48:32 - now
48:33 - this specific problem changes blockchain
48:35 - to blockchain right ethereum has a
48:37 - different problem for miners to solve um
48:39 - bitcoin has different problems for minor
48:41 - itself but this concept is going to be
48:42 - the same
48:43 - so they have to take
48:45 - one block is going to be this
48:47 - uh this concept is going to be all this
48:49 - data it's going to be the block number
48:52 - and it's going to be this nunce right
48:54 - and so this nunce is the solution um is
48:57 - is going to be the the number that they
48:58 - use to get like the solution to the
49:00 - problem right so if i go to one
49:03 - here you know when i do this again
49:06 - i'm gonna hit mine
49:08 - and the nuns has changed right it went
49:09 - from one to
49:11 - thirty three thousand one hundred and
49:12 - twenty eight because this is the nuns
49:13 - that allowed this hash to start with
49:16 - four zeros and so that's what's
49:17 - happening
49:18 - when uh blockchain miners are mining
49:21 - they're going through this process this
49:22 - very computationally intensive process
49:25 - of trying to find a nuns that fulfills
49:27 - whatever the problem is so that's really
49:29 - it actually so that's a block and that's
49:31 - really what's happening when miners are
49:33 - mining they're just looking there's
49:34 - trial and error brute force trying to
49:36 - find this nut so so now that we know
49:39 - what a block is let's go to the next
49:40 - step and figure out okay well what's a
49:42 - block chain so here we have an example
49:45 - of what a block chain is going to look
49:47 - like right we have a combination you
49:50 - know we have back here in the block
49:51 - section we have one what one block looks
49:53 - like now here we have multiple different
49:56 - blocks right each one of these
49:57 - represents a different block but we have
49:59 - an additional column here or we have
50:01 - additional uh variable here so like
50:04 - before you know we have block nuns and
50:06 - data
50:07 - right we have block nun's data but we
50:09 - also have this thing called previous
50:11 - right and so this is actually pointing
50:13 - to the previous hash of the last block
50:17 - so for example if we go to the the last
50:19 - block in this blockchain it says
50:20 - previous is 008 and if we look at the
50:23 - hash of block number four it's zero zero
50:25 - zero zero eight e eight and then we look
50:27 - at its previous it's uh four zeros b9 we
50:31 - have four zeros b9 and so on all the way
50:33 - back to our first block which has
50:35 - previous of just all zeros right and so
50:38 - the block with the previous of all zeros
50:41 - is going to be known as the genesis
50:43 - block so you've probably heard that
50:44 - before the genesis block it's the first
50:45 - block in the blockchain where the
50:47 - previous hash points to a hash that
50:50 - doesn't actually exist now as you can
50:52 - imagine kind of the same as how this
50:53 - block worked how the block nuns and data
50:56 - all go through the hashing algorithm in
50:58 - the blockchain the block nuns data and
51:01 - previous hash all go through this
51:03 - hashing algorithm to figure out you know
51:05 - what the hash is okay so if we go to
51:07 - over here you know for example if i type
51:09 - in you know patrick
51:10 - obviously this is now no longer valid
51:12 - right because this nuns uh combined with
51:15 - the block the data and the previous hash
51:17 - aren't gonna solve you know our problem
51:19 - of having four zeros at the start right
51:21 - so i'm going to go and fix that and and
51:23 - that's that's kind of an easy way to see
51:24 - it being broken but
51:26 - but let's take a look if i break
51:29 - this block right here what happens if i
51:31 - if i break the data in here if i do like
51:33 - trick in here you can see that both of
51:36 - these
51:37 - are now red both of these are now
51:39 - invalid right because the block hashed
51:42 - with the nuns hash with the new data
51:44 - which is my name patrick has worked
51:46 - hashed with the previous block
51:48 - is now a brand new hash right and this
51:51 - block
51:52 - is still pointing to this previous hash
51:55 - right here right it's pointing to this
51:56 - previous block and now it is wrong and
51:59 - it is messed up and now um and now it's
52:02 - nuns with this previous hash is also
52:05 - wrong
52:05 - right and this is where when we talk
52:07 - about uh blockchains being immutable
52:09 - this is exactly how it's immutable right
52:12 - because if i go back and i change
52:14 - anything you know if i've just
52:16 - typed a right here the entire blockchain
52:18 - is now invalidated because none of these
52:21 - are going to have
52:23 - nunses that solve this equation anymore
52:25 - so this is why blockchains are immutable
52:27 - is because anytime you change one thing
52:30 - you ruin the rest of the blockchain okay
52:33 - so however though you know if if an a
52:34 - was here originally we can go ahead and
52:36 - mine these
52:38 - we can mine all these but as you can see
52:39 - you know this is going to start getting
52:41 - very
52:42 - computationally expensive
52:43 - because i have to go redo basically the
52:46 - entire blockchain
52:47 - and the farther and farther down the
52:49 - line you get the harder and harder it
52:50 - becomes to you know rehash and redo all
52:53 - these different blockchains here now
52:54 - this makes a lot of sense right so we
52:55 - have this blockchain it's really hard to
52:57 - change something in the past but if we
52:58 - do we can just go ahead and remind it
53:00 - now if i'm the one who controls the
53:02 - blockchain right if i'm the one who
53:03 - controls this you know and i want to
53:04 - change something in the past well okay
53:06 - great all i got to do is change this
53:08 - data here and then you know mine each
53:10 - one of these and you know obviously it's
53:11 - going to be very computationally
53:13 - expensive but it's something that i can
53:14 - do right if i'm the one who owns the
53:16 - blockchain
53:18 - now here's where the decentralized
53:21 - nature or the distributed nature really
53:23 - uh makes it incredibly powerful so we're
53:26 - gonna go to the distributed tab here
53:28 - which i also refer to as the
53:29 - decentralized tab here
53:31 - it's going to show us what a blockchain
53:33 - looks like
53:34 - in a decentralized manner so we have
53:36 - this exact same initial setup here we
53:38 - have distributed blockchain we have you
53:40 - know our first block chain which is kind
53:42 - of exactly as the one from here but we
53:43 - also have
53:45 - more than one so we have peer a peer b
53:48 - and peer c and when people are talking
53:49 - about peer to peer appear to be your
53:51 - transactions they're really talking uh
53:52 - this is kind of that concept that
53:54 - they're talking about right so we have a
53:55 - number of different peers who are
53:57 - running this blockchain technology
53:59 - they're all weighted equally right each
54:01 - one of these peers or each one of these
54:03 - nodes each one of these entities running
54:05 - a blockchain
54:07 - has the exact same power as anybody else
54:10 - right so the way that we can tell very
54:13 - easily which blockchain is correct or
54:15 - which ones are correct are by looking at
54:18 - this end
54:19 - hash here right or by looking at where
54:21 - we are
54:22 - in the blockchain because again remember
54:24 - because again remember this this hash
54:26 - that this this in this last block here
54:29 - is going to encompass
54:31 - all of the blocks from before right
54:34 - because this last hash is going to have
54:35 - the previous hash here which includes
54:37 - the previous hash here which this hash
54:39 - includes the previous hash here in which
54:41 - so this last hash is encompasses
54:43 - everything in here right and we can look
54:46 - we can look at the hash of pure c which
54:48 - is four zeros and then e4b we can look
54:50 - at the latest hash of peer b which is
54:53 - four zeros e4b
54:54 - and then pure a which is for zeros e4b
54:57 - so all of these peers all of these nodes
55:00 - all of these decentralized you know
55:02 - these independent
55:04 - all these independent users running this
55:06 - blockchain software they're all matched
55:08 - up it's very easy for their nodes to
55:10 - look at each other and say hey great we
55:12 - are all matched up
55:13 - now
55:14 - what let's say that a decides that you
55:17 - know something happened on the
55:18 - blockchain that they didn't like and
55:19 - they wanted to go back and change
55:21 - something right so let's say they change
55:23 - here you know obviously
55:25 - the rest of their blockchain is
55:26 - invalidated and they have to spend a lot
55:28 - of computational power to catch up to
55:29 - speed so let's go ahead and humor it
55:31 - let's say that they they did they ended
55:33 - up catching up
55:35 - uh they ended up catching up you know
55:36 - they ended up mining everything
55:38 - and now they have a valid blockchain
55:40 - right it solves the equation awesome
55:43 - however
55:44 - in block number three
55:46 - there's something new
55:47 - right this is here and it shouldn't have
55:49 - been here this is something that pier a
55:51 - put in by themselves
55:53 - all that happens now
55:55 - is we look at all the blockchains that
55:58 - are running the software and we're
55:59 - looking at all the hashes at hash at
56:02 - block number five so pier a has this new
56:05 - hash now 009 bc
56:08 - but peer b has a different hash 0 e4b
56:12 - right so who's right is it is it pier a
56:14 - with their new stuff or is it peer b
56:16 - well that's where the decentralizator
56:19 - comes in because then we can look at
56:20 - pier c and pierce c
56:22 - also has e4b so
56:24 - pure b and pure c both say hey pure a
56:27 - you're wrong
56:28 - get out right and peer a will stop being
56:31 - able to participate in the mining
56:32 - rewards because they have essentially
56:34 - forked uh the blockchain and started
56:36 - their own little blockchain right with
56:38 - their own history because they're the
56:40 - only ones with this this piece of data
56:43 - in block three whereas peer b
56:46 - and peer c have nothing in there so that
56:48 - really shows why uh in these blockchain
56:50 - worlds in this decentralized world there
56:52 - really is no central identity you know
56:53 - pier a you know might have been
56:55 - maliciously motivated to change you know
56:57 - this block number three however
56:59 - democracy rules right the majority rules
57:01 - in the blockchain peer b and pc both say
57:04 - hey you know that's cute and all pure a
57:06 - but
57:07 - you're wrong right that that's not right
57:08 - now it might be a little abstract that
57:10 - you just look at data and you know us
57:12 - typing kind of random stuff in here and
57:13 - think okay yeah that's that's data right
57:15 - that makes sense you know just kind of
57:17 - random strings in here doesn't really do
57:19 - anything for us so if we actually go
57:21 - over to the token section here this is
57:23 - where everything really starts to make a
57:25 - lot of sense so we have the exact same
57:27 - setup here with peer a peer b peer c
57:30 - except the difference is instead of
57:33 - having kind of this this data section we
57:35 - have this
57:36 - tx this transaction section right and
57:38 - this represents all the transactions
57:41 - that are happening in this block right
57:43 - so we're we're sending 25 dollars from
57:45 - darcy to bingle or to bingley uh force
57:48 - uh four dollars and 27 cents here uh
57:51 - 1922 right and it's the exact same thing
57:54 - so this all these transactions are going
57:56 - to get hashed in the exact same way uh
57:59 - that the data is going to get hashed and
58:01 - and this is why it's so powerful because
58:02 - again you know if i want to be malicious
58:04 - right if uh if i want to say hey i
58:07 - really wanted to give jane
58:08 - a lot more money from elizabeth so i'm
58:10 - pure a and i go back and i change it to
58:12 - 100 well now
58:13 - you know not only do i does my whole
58:15 - blockchain
58:16 - get invalidated because that was so far
58:18 - so long ago but i'm not going to match
58:21 - any of these other chains right and so
58:23 - my blockchain is going to be excluded
58:25 - from the overall blockchain so and let's
58:27 - let's go ahead and fix this and it's the
58:29 - same thing if down here if i become
58:31 - malicious and i want to send you know i
58:34 - want
58:34 - uh miss audrey to have less money maybe
58:37 - i want to send a dollar and i go ahead
58:39 - and mind it the same thing here
58:41 - this hash now this 2a1 is not going to
58:45 - match
58:46 - peer b's
58:48 - pre-b's hash of bba and it's not going
58:50 - to match pc's hash of bba as well so the
58:53 - two of them are going to say hey this
58:55 - your blockchain isn't valid it's not
58:57 - matching the majority you know you're
58:59 - out right
59:01 - so that's really how these blockchains
59:03 - work at a low level and it all goes back
59:06 - to this this understanding this hash
59:08 - idea and using it in this very
59:10 - sophisticated manner uh to kind of
59:12 - cryptographically prove
59:13 - um you know where where stuff lies now
59:16 - the way the blockchain works is that
59:17 - instead of random stuff put in this data
59:19 - section it's actually going to be
59:21 - solidity code in here to finding ways to
59:23 - interact with different blocks and
59:24 - different protocols that are on chain or
59:27 - as we've said before different smart
59:29 - contracts
59:31 - now the next question that you might be
59:33 - asking is okay well
59:34 - how do i know how can i be sure that i'm
59:38 - the one
59:39 - uh you know let's say this is let's say
59:40 - i'm darcy right how can i be sure that i
59:42 - was that darcy was the one to actually
59:44 - send this money here how do we know that
59:46 - darcy sent 25
59:48 - to
59:49 - bingley well this is where we get into
59:52 - uh private keys and public keys and
59:54 - that's what we're going to go into now
59:55 - let's just do a quick recap of what
59:58 - we've learned in this section so far
59:59 - right we've learned that
60:01 - ethereum actually runs on this ketchup
60:03 - 256 but you know we used shot to v6 for
60:06 - this demo it doesn't really matter we're
60:08 - just talking about hashing algorithms so
60:11 - again a hash is a unique fixed length
60:14 - string meant to identify any piece of
60:17 - datum a hash algorithm or a hash
60:19 - function is a function or algorithm that
60:22 - computes any type of data into a unique
60:25 - hash
60:26 - mining is the process of finding the
60:28 - solution to the blockchain problem in
60:31 - our example the problem was to find a
60:33 - hash that starts with four zeros
60:35 - whenever a node mines a block they get
60:38 - paid a little bit of that gas we were
60:39 - talking about earlier for doing
60:41 - something a block in a blockchain is
60:43 - basically a combination of a block nonce
60:45 - transaction and previous hash to create
60:48 - this unique hash for this block and
60:50 - again depending on the blockchain
60:52 - implementation this might have a couple
60:54 - other fields or might have different
60:55 - fields but this is essentially what's
60:57 - going on blockchains are decentralized
60:59 - and distributed because
61:00 - many independent users are going to run
61:02 - this blockchain software and they will
61:04 - check and they will compare against each
61:05 - other to see which blockchains are
61:07 - acting honestly and which ones are
61:09 - acting maliciously in the blockchain
61:11 - world majority rules the nuns here is
61:14 - the answer used or the number used to
61:17 - get this hash now nuns is kind of an
61:19 - overloaded term it's actually used for a
61:21 - number of different reasons in this case
61:23 - we're using it to solve this problem of
61:25 - getting you know four or five zeroes at
61:27 - the stop of the hash however in ethereum
61:29 - it'll also be often used as the number
61:31 - of transactions from a given address so
61:34 - now we're going to talk a little bit
61:35 - about signing these transactions and
61:37 - private keys and some other cryptography
61:39 - pieces right because in this blockchain
61:41 - demo here we can see we hover these
61:43 - these fantastic transactions right all
61:45 - these things went through but how do we
61:46 - know that it was darcy who was the one
61:49 - to send 25
61:51 - to bingley right how do we know that
61:53 - actually happened and this is where
61:55 - all those pieces that we just learned
61:57 - about uh in our our test net in our
62:00 - metamask account are really going to
62:01 - start to to come to life here a little
62:03 - bit here so here we have an example of
62:06 - public and private keys okay at the top
62:09 - we have this private key right that was
62:11 - that was randomly generated a private
62:13 - key is is you know as it kind of states
62:15 - is a key that you really want to keep
62:17 - secret because you're going to be using
62:18 - this
62:19 - as kind of your secret password for all
62:22 - your transactions right i can really
62:23 - pick you know any
62:25 - any any private key anything that i want
62:28 - and with it uh
62:30 - this algorithm they're going to use an
62:32 - algorithm you know for ethereum in
62:33 - bitcoin they both use this elliptic
62:35 - curve digital signature algorithm it's a
62:38 - variant of just a digital signature
62:40 - algorithm and it's going to create this
62:42 - this public key right i'm really not
62:43 - going to go at all into kind of this
62:45 - digital signature algorithm but just
62:47 - know it does use some of these some of
62:49 - the hash
62:51 - knowledge that we just learned combined
62:52 - with some other pieces
62:54 - to kind of get this this public here so
62:56 - i'm not going to go too deep into it but
62:57 - we have this private key that we create
63:00 - and we get this public key now this
63:01 - public key we want everybody to have
63:04 - access to right this is yeah whole world
63:06 - can see this this private key we really
63:08 - want it to be uh private we don't want
63:10 - people to see this we're going to use
63:12 - this private key as like a password to
63:14 - quote unquote digitally signed
63:17 - transactions and then people can verify
63:20 - them with this public key so let's let's
63:22 - see what this actually looks like let's
63:23 - pick a random key a more secure key
63:25 - right because the longer it is the more
63:27 - secure it's going to be
63:29 - and if we go to signatures now
63:31 - right
63:32 - let's say we have this
63:34 - this message that we want right we'll
63:35 - say hi world right we want this to be
63:38 - the message what's going to happen
63:40 - is this private key that we've created
63:42 - we can use to sign this data right
63:44 - remember how in the blockchain demo you
63:46 - know we were kind of we were hashing
63:48 - stuff right we were we're using this uh
63:50 - shay256 hash to to get this hash well
63:53 - we're doing something similar but
63:54 - instead of hashing we're we're using
63:56 - this digital signature algorithm to
63:58 - create this message signature
64:00 - now what's really powerful about how
64:02 - this uh this algorithm works is that you
64:05 - can create this message signature with
64:08 - your private key but somebody else can't
64:10 - derive your private key from the message
64:13 - signature and that's what makes this
64:15 - really really powerful however if we go
64:17 - to verify using this public key right
64:20 - and so this is the
64:21 - this is that o four zero three this is
64:23 - that same public key using this using
64:26 - this public key
64:27 - anybody can verify let's go ahead and
64:29 - sign again anybody can verify
64:32 - that the signature
64:34 - is yours right so you have a public a
64:37 - private key
64:38 - just for you so you can sign things and
64:40 - a public key that anybody can verify
64:42 - something right so anybody can verify
64:44 - this and let's say somebody tries to
64:46 - fake a transaction from you they say hey
64:49 - you know this is this is this is their
64:51 - transaction
64:53 - all they have to do is verify
64:54 - that this
64:56 - signature against your public key and
64:59 - very easily this whole thing turns red
65:01 - because
65:02 - it isn't verified right the the
65:04 - algorithm says hey
65:05 - that's wrong so we can go ahead and take
65:07 - that into transactions in this exact
65:10 - same way so if i want to send money
65:12 - you know if i want to send
65:14 - 400
65:15 - from you know my address to another
65:18 - address using my private key i can sign
65:21 - that transaction
65:23 - and anybody else in the world can then
65:25 - verify this transaction right and this
65:27 - is why when people say
65:29 - hide your keys you know protect your
65:30 - keys this is what we're talking about
65:32 - in our accounts here
65:34 - right if we go to
65:36 - uh settings and again the only reason
65:38 - that i'm showing you guys
65:40 - my mnemonic in my private key is because
65:42 - this is a
65:43 - uh this is a dumpster account i'm gonna
65:44 - throw this away at the end of this video
65:46 - or i'm just not gonna put any real money
65:47 - in it
65:48 - um
65:49 - but
65:52 - when we look at our our metamask here we
65:55 - have this mnemonic phrase which allows
65:57 - us to
65:59 - easily get these different private keys
66:01 - right so
66:02 - demonic phrase combined uh with you know
66:06 - whatever account number will get us a
66:07 - private key so demonic phrase combined
66:09 - with one we're going to get this private
66:11 - key and this is when we look at account
66:13 - details export private key
66:18 - password confirm this is going to be the
66:21 - private key that we're going to use to
66:23 - sign our transactions right this if
66:25 - anybody else gets access to this private
66:27 - key they then can sign transactions for
66:30 - us and they can send transactions for us
66:32 - and that's why we want to keep these
66:33 - private
66:34 - so it works the exact same way right so
66:36 - this is why it's so important to hide
66:38 - your private keys and hide your
66:40 - mnemonics now
66:41 - your ethereum address is actually
66:44 - a piece
66:48 - is actually a piece of your public key
66:50 - now to get our address in ethereum all
66:53 - we have to do is take this public key
66:54 - that we've created with our private key
66:57 - hash it using that same ethereum hashing
66:59 - algorithm and then take the last 20
67:00 - bytes and that's how we'll actually
67:02 - derive to our um to our address here now
67:05 - knowing the exact methodology of how to
67:08 - get the address doesn't really matter
67:10 - because it could change blockchain to
67:11 - blockchain and could even change an too
67:13 - but just know that that is essentially
67:15 - how kind of these addresses are derived
67:17 - right there's some derivative of the
67:19 - public key right because the public key
67:21 - is public and you know using the public
67:24 - key in kind of any public way is is
67:25 - totally fine
67:27 - but not the private key so that is how
67:29 - we sign our transactions note though
67:31 - this isn't how we send the transaction
67:33 - so so this is just going to sign it
67:34 - create a transaction for us to send
67:36 - we'll learn later on how to send these
67:38 - transactions
67:40 - so that was a lot of information there
67:41 - too let's do a quick recap your public
67:44 - key is derived by using a digital
67:46 - signature algorithm on your private key
67:49 - right and you want to keep your private
67:50 - key private at all times because you're
67:52 - going to use your private key to sign
67:55 - transactions
67:56 - signing transactions with your private
67:58 - key you are the only one who can
67:59 - actually do this because you can't get
68:02 - the private key from a message signature
68:04 - however using your public key you can
68:08 - anybody can very easily verify that a
68:10 - signature that's signed by you is in
68:12 - fact signed by you in our metamask our
68:14 - private keys are located in this account
68:17 - details section you just hit
68:19 - show private keys and type in your
68:21 - password and you'll get your private key
68:23 - here
68:24 - a quick note here is often times when
68:26 - using your private key somewhere they
68:28 - want it in hexadecimal form so if we're
68:30 - going to use our private key
68:32 - for something like brownie which we'll
68:34 - go into later we need to actually append
68:36 - in a 0x to the front but we'll get into
68:38 - that later
68:39 - and the address
68:41 - of your account is derived from this so
68:44 - if you think about it your private key
68:46 - creates your public key which then can
68:48 - create your address and there's a little
68:50 - barrier
68:52 - or a big barrier here
68:54 - because your private key you want to
68:55 - keep private and your public key and
68:57 - your address can all be public
68:58 - information awesome so now that we know
69:00 - all the cryptography pieces and all the
69:02 - little nitty gritties of how the
69:03 - blockchain actually works and how our
69:05 - signatures work and how everything
69:06 - sticks together let's talk a little bit
69:08 - about how this works in actuality and
69:11 - what's really going on now for a lot of
69:13 - this each different blockchain has
69:15 - slightly different algorithms and
69:16 - slightly different metrics and criteria
69:19 - for doing a lot of the stuff so when
69:21 - we're talking about these specific
69:23 - implementations keep in mind the exact
69:25 - algorithm might be a little bit
69:26 - different but the concepts are all still
69:28 - going to be exactly the same hashing and
69:31 - hash function is going to be the same no
69:32 - matter where you look a decentralized
69:34 - blockchain is going to be the same no
69:36 - matter where you look how it's actually
69:38 - implemented is going to be a little bit
69:40 - different now traditionally when you run
69:42 - an application you know be it a website
69:44 - or something that connects to some
69:46 - server you are interacting with a
69:48 - centralized entity and unlike how we saw
69:51 - with the blockchain with multiple
69:52 - different peers it's going to be run by
69:55 - a single centralized group now it still
69:57 - could be run on many different servers
69:59 - but all those servers are still going to
70:00 - be controlled by the same centralized
70:03 - group blockchains as we saw run on a
70:06 - network of different independent nodes
70:09 - when we saw peer a peer b peer c those
70:11 - were different examples of different
70:13 - independent users running the blockchain
70:16 - technology on their own node now when i
70:18 - use the term node i'm usually referring
70:20 - to a single instance of a decentralized
70:22 - system so when i say a single node when
70:24 - i'm talking about a blockchain i'm
70:26 - talking about one of those peer a's peer
70:28 - b's pcs running that blockchain software
70:30 - i'm talking about one server running
70:32 - this technology and again it's this
70:35 - network it's this combination of these
70:36 - nodes interacting with each other that
70:38 - creates this entire blockchain what
70:40 - makes this so potent too is that anybody
70:42 - can join the network and that's why
70:44 - there's decentralized the barrier to
70:46 - entry is a little bit of hardware
70:47 - requirements you're getting the correct
70:49 - materials to run the software and then
70:51 - you running the software anybody can
70:53 - join these networks and participate and
70:54 - that's what makes it truly decentralized
70:57 - in fact you can go to github right now
70:59 - and run your own ethereum node in a few
71:01 - seconds now in the traditional world
71:03 - applications are run by centralized
71:05 - entities and if that entity goes down or
71:08 - is maliciously bribed or decides that
71:10 - they want to shut off they just can't
71:13 - because they're the ones that control
71:15 - everything blockchains by contrast don't
71:17 - have this problem if one node or one
71:20 - entity that runs several nodes goes down
71:22 - since there are so many other
71:24 - independent nodes running that it
71:26 - doesn't matter the blockchain and the
71:28 - system will persist so long as there is
71:30 - at least one node always running and
71:33 - luckily for us most of the most popular
71:35 - chains like bitcoin and ethereum have
71:37 - thousands and thousands of nodes and as
71:39 - we showed in our demo if one node acts
71:41 - maliciously all the other nodes will
71:45 - ignore that node and kick that out or
71:47 - even punish it in some systems because
71:49 - they can easily check everybody else's
71:51 - node and see okay this one is out of
71:54 - sync with the majority and yes majority
71:56 - rules when it comes to the blockchain
71:57 - each blockchain keeps a full list of
71:59 - every transaction and interaction that's
72:02 - happened on that blockchain and we saw
72:04 - if a node tries to act maliciously
72:06 - then all their hashes are going to be
72:07 - way out of whack and they're not going
72:08 - to match everybody else this gives
72:10 - blockchains this incredibly potent
72:12 - immutability trait where nothing can be
72:15 - changed or corrupted so in essence we
72:17 - can think of a blockchain as a
72:18 - decentralized database and with ethereum
72:21 - it has an extra additional feature where
72:23 - it also can do computation in a
72:26 - decentralized manner now let's talk
72:27 - consensus proof of work and proof of
72:30 - stake because you've probably heard
72:31 - these before and they're really
72:33 - important to how these blockchains
72:35 - actually work we went through that
72:36 - blockchain example and we did that
72:38 - mining feature this is what's known as
72:40 - proof of work proof of work and proof of
72:43 - stake fall under this umbrella of
72:45 - consensus and consensus is a really
72:48 - important topic when it comes to
72:49 - blockchains consensus is defined as the
72:51 - mechanism used to reach an agreement on
72:54 - the state or a single value on the
72:56 - blockchain especially in a decentralized
72:58 - system i briefly alluded to this
73:00 - consensus mechanism in our blockchain
73:02 - example when i said if one changes
73:04 - something and the other two
73:06 - don't then majority will rule and kick
73:08 - that one out this is part of that
73:10 - consensus mechanism now very roughly a
73:13 - consensus protocol in a blockchain or
73:14 - decentralized system can be broken down
73:16 - into two pieces a chain selection
73:18 - algorithm and a civil resistance
73:20 - mechanism that mining piece that we were
73:22 - doing or or the proof of work algorithm
73:25 - is what's known as a civil resistance
73:27 - mechanism and this is what ethereum and
73:29 - bitcoin currently use please note that
73:32 - depending on when you're watching this
73:34 - if eth2 is out then it's no longer proof
73:36 - of work now proof of work is known as a
73:38 - civil resistance mechanism because it
73:39 - defines a way to figure out who is the
73:41 - block author which node is going to be
73:44 - the node who did the work to find that
73:46 - mine and be the author of that block so
73:48 - all the other nodes can verify that it's
73:50 - accurate civil resistance is a
73:52 - blockchain's ability to defend against
73:54 - users creating a large number of
73:56 - pseudo-anonymous identities to gain a
73:58 - disproportionately advantageous
74:00 - influence over said system
74:03 - and in layman's terms it's basically a
74:04 - way for a blockchain to defend against
74:06 - somebody making a bunch of fake
74:07 - blockchains so that they can get more
74:09 - and more rewards now there are two types
74:11 - of the civil resistance mechanisms that
74:12 - we're going to talk about here namely
74:14 - proof of work and proof of stake let's
74:17 - talk about proof of work a little bit
74:18 - more in depth first in proof of work
74:20 - this is silver resistant because a
74:22 - single node has to go through a very
74:24 - computationally expensive
74:26 - process called mining which we
74:28 - demonstrated earlier to figure out the
74:30 - answer to the blockchain's riddle of
74:31 - finding that correct nonsore or whatever
74:33 - the blockchain system has in place in
74:35 - proof of work this works because
74:36 - no matter how many pseudo-anonymous
74:38 - accounts you make each one still has to
74:41 - undergo this very computationally
74:42 - expensive activity of finding the answer
74:45 - to the proof-of-work problem or the
74:47 - proof-of-work riddle which again in our
74:49 - demonstration it was finding a nunce
74:51 - with that first four zeros but again
74:53 - each blockchain might change the riddle
74:55 - work or change the problem to be a
74:56 - little bit different in fact some of
74:58 - these blockchains make this riddle
74:59 - intentionally hard or intentionally easy
75:02 - to change what's called the block time
75:04 - the block time is how long it takes
75:05 - between blocks being published and it's
75:07 - proportional to how hard these
75:09 - algorithms are so these problems
75:11 - actually can change depending on how
75:13 - long they want the block tone to be if
75:15 - the system wants the block time to be
75:17 - very very long they just make the
75:19 - problem very very hard if they want to
75:21 - be very short to make the problem a lot
75:23 - easier we'll talk about civil attacks in
75:25 - a little bit and how they can affect the
75:26 - system but with proof of work it's a
75:28 - verifiable way to figure out who the
75:30 - block author is and be civil resistant
75:33 - now you need to combine this with a
75:34 - chain selection rule create this
75:36 - consensus now there are some consensus
75:38 - protocols that have more features but
75:40 - very very roughly these are the two
75:41 - pieces that we're going to look at the
75:43 - second piece is going to be a chain
75:45 - selection rule
75:46 - how do we know which blockchain is
75:48 - actually the real blockchain and the
75:50 - true blockchain now on bitcoin and
75:51 - ethereum they both use a form of
75:53 - consensus called nakamoto consensus and
75:56 - this is a combination of proof of work
75:58 - and longest chain rule the decentralized
76:00 - network decides that whichever
76:02 - blockchain has the longest chain or the
76:04 - most number of blocks on it is going to
76:06 - be the chain that they use this makes a
76:08 - lot of sense because every additional
76:10 - block that a chain is behind it's going
76:12 - to take more and more computation for it
76:14 - to come up
76:16 - that's why when we saw in our
76:17 - transaction we actually saw
76:18 - confirmations the number of
76:20 - confirmations is the number of
76:22 - additional blocks added on after our
76:25 - transaction went through in a block so
76:27 - if we see confirmations is two it means
76:29 - that the block that our transaction was
76:31 - in has two blocks ahead of it in the
76:33 - longest chain now i do want to point out
76:35 - that a lot of people use proof of work
76:37 - as a consensus protocol and i do want to
76:39 - say that this is a little bit inaccurate
76:42 - but sometimes people use it
76:43 - interchangeably proof of work is a piece
76:46 - of the overall consensus protocol which
76:48 - in bitcoin and ethereum one's current
76:50 - case is nakamoto consensus nakamoto
76:53 - consensus is a combination of proof of
76:56 - work and its longest chain rule both
76:58 - equally and very very important now
77:01 - proof of work also tells us where these
77:03 - transaction fees and these block rewards
77:05 - go to remember how when we made this
77:07 - transaction we had to talk about gas and
77:10 - a transaction fee so who's getting paid
77:12 - who is getting this transaction and this
77:14 - transaction fee is going to the miners
77:16 - or the validators in a proof of work
77:18 - network they're called miners and in the
77:20 - proof of stake network they're called
77:23 - validators there are a little bit
77:24 - different and we'll get into that when
77:26 - we talk about proof of stake in this
77:27 - proof of work system all these nodes are
77:29 - competing against each other to find the
77:32 - answer to the blockchain riddle remember
77:34 - in our example it was to find a hash
77:36 - that has four zeros at the start and
77:38 - again depending on the blockchain
77:40 - implementation that riddle is going to
77:41 - be a little bit different but all the
77:43 - nodes are trying as many as possible to
77:46 - try to get this answer first why because
77:49 - the first node to figure out the answer
77:51 - to the blockchain rule is going to get
77:52 - that transaction fee they're going to
77:54 - get paid from that now when a node gets
77:56 - paid they actually get paid in two
77:57 - different ways one is going to be with a
77:59 - transaction fee and another piece is
78:01 - going to be the block reward remember
78:03 - how we talked about alternating the gas
78:05 - price or the way on our transaction well
78:07 - that's the transaction fee that we're
78:09 - going to pay to these blockchain nodes
78:11 - for including our transaction the block
78:13 - reward is given to these nodes from the
78:15 - protocol from the blockchain itself
78:18 - you've probably heard of the bitcoin
78:19 - having before the having is referring to
78:22 - this block reward getting cut in half
78:25 - and it's supposed to be cut in half
78:26 - roughly every four years this block
78:29 - reward increases the circulating amount
78:31 - of whatever cryptocurrency that is being
78:33 - rewarded for example on ethereum the
78:35 - block reward is giving out ethereum and
78:37 - on bitcoin the block reward is giving
78:38 - out bitcoin so these nodes are competing
78:40 - against each other to be the first one
78:42 - to find this transaction to be the first
78:44 - one to find the answer to this problem
78:46 - so that they can be the ones to win both
78:48 - this block reward and your transaction
78:51 - fee some blockchains like bitcoin for
78:53 - example have a set time when they are no
78:56 - longer going to give out block rewards
78:57 - and the miners or the nodes are only
78:59 - going to get paid from transaction fees
79:02 - now this gas fee again is paid by
79:04 - whoever initialized the transaction when
79:07 - we got our funds from the faucet there
79:09 - was some server and somebody else was
79:11 - paying the transaction fee for us
79:13 - however when we sent ether from one
79:15 - account to another our first account
79:18 - actually paid some transaction fee to
79:20 - send that ether in proof of stake
79:22 - there's also a gas fee but it's paid out
79:24 - to validators instead of miners and
79:27 - we'll talk about that in a little bit
79:28 - now let's talk about two types of
79:29 - attacks that can happen in these
79:31 - blockchain worlds let's talk about the
79:32 - first one being the sybil attack the
79:34 - simple attack is when a user creates a
79:36 - whole bunch of pseudo-anonymous accounts
79:38 - to try to influence a network now
79:41 - obviously on bitcoin and ethereum this
79:43 - is really really difficult because the
79:45 - user needs to do all this work in proof
79:47 - of work or have a ton of collateral in
79:49 - proof of stake which again we'll talk
79:50 - about in a bit the other more prevalent
79:52 - attack is what's known as a 51 percent
79:55 - attack now as we saw as part of our
79:56 - consensus protocol these blockchains are
79:59 - going to agree that the longest chain is
80:01 - the one that they're going to go with so
80:03 - long as it matches up with 51 percent of
80:05 - the rest of the network
80:07 - this means that if you have the longest
80:09 - chain and you have more than 51 percent
80:11 - of the rest of the network you can do
80:13 - what's called a fork in the network and
80:15 - bring the network onto your now longest
80:17 - chain now sybil attacks obviously are
80:19 - when a single node or a single entity
80:21 - tries to affect the decentrality of the
80:23 - network by pretending to be multiple
80:25 - different people although they're just
80:27 - the same person or entity and like i
80:29 - said it's really difficult to do in
80:30 - proof of work and proof of stake so you
80:32 - can see now that blockchains are very
80:33 - democratic whichever blockchain has the
80:36 - most buy-in and is the longest is the
80:38 - blockchain that the whole system is
80:40 - going to corroborate when nodes produce
80:42 - a new block and add to the longest chain
80:44 - the other nodes will follow this longest
80:46 - chain that the rest of the network is
80:47 - agreeing with add those blocks to their
80:49 - chain and follow up so very small
80:51 - reorganizations are actually pretty
80:53 - common when a blockchain picks a block
80:55 - from a different longest chain puts it
80:57 - on and then has to
80:58 - swap it out for another block and
81:00 - continue with a different blockchain
81:02 - however if a group of nodes had enough
81:04 - nodes or enough power they could
81:05 - essentially be 51 of the network and
81:08 - influence the network in whatever
81:10 - direction that they wanted this is
81:12 - what's known as a 51 attack and it's
81:14 - happened on blockchains like ethereum
81:16 - classic which is not ethereum this is
81:18 - why the bigger a blockchain is the more
81:20 - decentralized and the more secure it
81:22 - becomes so after you watch this video
81:24 - and you become a blockchain engineering
81:26 - expert i definitely recommend you run a
81:27 - note as well because you are going to
81:29 - increase the security of the network as
81:31 - a whole by running a node so proof of
81:33 - work is fantastic because it allows us
81:35 - to very easily protect against these
81:37 - civil attacks and keep our blockchains
81:39 - decentralized and secure
81:41 - however it has some drawbacks as well
81:43 - proof of work costs a lot of electricity
81:45 - because every single node is running as
81:47 - fast as they can to win this race to get
81:49 - the rewards this leads to obviously an
81:52 - environmental impact now since proof of
81:54 - work and nakamoto consensus a lot of
81:56 - other protocols have taken this idea and
81:58 - gone in a different direction with a
81:59 - different civil resistance protocol a
82:01 - lot of them with the intention to be a
82:03 - lot more environmentally friendly and
82:05 - the most popular one right now is proof
82:07 - of stake there are some chains that are
82:09 - already using this proof-of-stake
82:10 - protocol and that are live and thriving
82:13 - some of them are like avalanche solana
82:15 - polygon polkadot and terra and
82:17 - additionally ethereum has decided to
82:20 - upgrade to eth2 which will have this of
82:23 - stake algorithm as well it'll also have
82:25 - some other features which we'll talk
82:27 - about in a bit now as a quick aside all
82:29 - the tools that we're going to learn here
82:30 - are still going to work in eth2 so
82:33 - depending on when you watch this
82:34 - everything here is still valid so let's
82:36 - talk about proof of stake now again this
82:38 - is a different civil resistance
82:39 - mechanism instead of solving this
82:41 - difficult problem proof of stake nodes
82:43 - put up some collateral that they're
82:45 - going to behave honestly aka they stake
82:48 - in the example of ethereum 2 nodes put
82:51 - up some ethereum as a stake that they're
82:53 - going to behave honestly in the network
82:55 - if they misbehave to the network they
82:57 - are going to be slashed or removed some
82:59 - of their stake
83:00 - obviously this is a very good civil
83:02 - resistance mechanism because if you try
83:04 - to create a whole bunch of anonymous
83:05 - accounts
83:06 - then each one of those accounts you have
83:08 - to put up some stake and if you
83:10 - misbehave you're going to run the risk
83:11 - of losing all the money that you put up
83:13 - as collateral in this system miners are
83:16 - actually called validators because
83:18 - they're no longer binding anything
83:20 - they're actually just validating other
83:21 - nodes now unlike proof of work which
83:23 - every node is racing to be the first one
83:25 - to find the block in proof of stake
83:27 - nodes are actually randomly chosen to
83:29 - propose the new block and then the rest
83:31 - of the validators will validate if that
83:34 - node has proposed the block honestly as
83:36 - we saw with our cryptography lesson it's
83:38 - usually very easy for other nodes to
83:40 - verify if a proposal or a transaction is
83:43 - honest now randomness is a really
83:45 - important topic when we're talking about
83:47 - blockchains because keep in mind these
83:49 - blockchains are deterministic systems
83:51 - they're walled gardens from the rest of
83:52 - the world and as you know a determinic
83:55 - system by definition can't have random
83:58 - numbers so how do we choose the random
84:00 - validators in the system well it changes
84:02 - from blockchain to blockchain and
84:04 - actually choosing the node will change
84:06 - blocks you to blockchain but in eth2
84:08 - they're using what's called randow at
84:10 - least for the original implementation
84:11 - this is a decentralized autonomous
84:13 - organization that collectively chooses
84:15 - the random number and collectively
84:17 - chooses which node is going to run next
84:19 - we aren't going to dive too deep into
84:20 - this because there's a good chance that
84:22 - this might change in the future but we
84:24 - will go into randomness solutions in
84:25 - blockchain later on in this course now
84:27 - proof of stake obviously has some pros
84:29 - and cons as well pros are that again it
84:30 - is a great civil resistance mechanism
84:33 - and a great way to figure out who the
84:34 - author of a block should be the other
84:36 - pros are that it's way less
84:38 - computationally expensive to figure out
84:40 - the new block because instead of every
84:42 - single node on the network trying to do
84:44 - this only one node needs to do this and
84:47 - then the rest of the nodes just need to
84:48 - validate it the cons are that it's
84:50 - usually considered a slightly less
84:52 - decentralized network due to the upfront
84:54 - staking costs it costs to participate
84:56 - now this gets into a little bit of a
84:57 - philosophical battle on how
84:59 - decentralized is decentralized enough
85:01 - and i think that's up to the community
85:03 - to decide and as we progress i think
85:05 - we'll learn more and more about how
85:06 - decentralized is decentralized enough
85:08 - the general consensus amongst blockchain
85:10 - engineers though is that proof of stake
85:12 - is very very decentralized and very
85:14 - secure this massive environmental impact
85:17 - improvement is one of the two main
85:18 - reasons why eath is shifting to eth2 it
85:21 - reduces the environmental impact by up
85:23 - to 99 percent now these are the main
85:25 - pieces of proof of work and proof of
85:27 - stake but i did want to talk about
85:28 - another concept that's really important
85:30 - in these ecosystems and that is
85:32 - scalability when we were talking about
85:34 - gas prices we were saying that the gas
85:36 - prices can get really high if a lot of
85:38 - people want to send a transaction
85:40 - because a block only has so much block
85:42 - space and the nodes can only add so many
85:44 - nodes so when a lot of people want to
85:46 - use a blockchain the gas price
85:49 - skyrockets
85:50 - this is not very scalable because if we
85:53 - want to add more and more people to
85:54 - these blockchains it's going to cost
85:56 - more and more to use the blockchains
85:58 - because more people are going to want to
86:00 - get into these blocks this means that
86:01 - there's kind of a ceiling to how many
86:02 - people can use the system because of the
86:04 - financial constraints that will get
86:06 - imposed as gas prices keep rising
86:08 - ethereum 2 is not only attacking the
86:10 - environmental impact of proof of work by
86:12 - switching to proof of stake but they are
86:14 - also implementing this new methodology
86:16 - called sharding and sharding is a
86:18 - solution to this scalability problem a
86:21 - sharded blockchain really just means
86:23 - that it's going to be a blockchain of
86:25 - blockchains there is a main chain that's
86:27 - going to coordinate everything amongst
86:29 - several chains that hook into this main
86:32 - chain this means that there's more
86:34 - chains for people to make transactions
86:36 - on effectively increasing the amount of
86:38 - block space that there is sharding can
86:40 - greatly increase the number of
86:42 - transactions on a blockchain layer 1.
86:44 - now there's another term that might be
86:46 - the first time you heard it a layer 1.
86:48 - we're going to talk about layer ones and
86:50 - layer twos in terms of scalability
86:51 - really quickly as well a layer one
86:54 - refers to any base layer blockchain
86:56 - implementation bitcoin's a layer one
86:58 - ethereum's a layer one avalanche is a
87:01 - layer one these are the base layer block
87:03 - chain solutions a layer two is any
87:06 - application that is added on top of a
87:09 - layer one added on top of a block chain
87:11 - some examples of layer twos are going to
87:13 - be chain link arbitrarily or optimism
87:16 - arbitrary and optimism are very
87:18 - interesting because they are layer twos
87:19 - that also look to solve this scalability
87:22 - issue arbitrary and optimism are what's
87:24 - known as roll-ups and they
87:26 - roll up their transactions into a layer
87:29 - one like ethereum we're not going to go
87:30 - too deep into rollups and how they
87:32 - actually work but all you really need to
87:34 - know is that a rollup is kind of like a
87:37 - sharded chain they derive their security
87:39 - from the base layer from the layer one
87:41 - like ethereum and they bulk send their
87:43 - transactions onto the layer one they
87:45 - solve some of the scalability issues by
87:46 - being another blockchain that people can
87:48 - make transactions on still on kind of
87:50 - this base ethereum layer
87:53 - now they're different from side chains
87:55 - because side chains derive their
87:56 - security from their own protocols roll
87:59 - ups derive their security from the base
88:01 - layers so arbitrary optimism for example
88:03 - is going to be just about as secure as
88:05 - ethereum there's some fantastic guys in
88:07 - there that go a little bit deeper into
88:08 - rollups and i've left a link in the
88:10 - description for you all right so we just
88:12 - talked about a lot of stuff so let's do
88:15 - a quick recap before moving on ethereum
88:17 - and bitcoin are currently both
88:18 - proof-of-work blockchains that follow
88:21 - nakamoto consensus however ethereum is
88:23 - moving to ethereum two which will be a
88:25 - proof-of-stake sharded blockchain civil
88:27 - attacks are prevented due to protocols
88:29 - like proof of work and proof of stake 51
88:32 - attacks grow increasingly harder with
88:34 - the size of blockchain so you should run
88:36 - a node consensus is the mechanism that
88:39 - allows a blockchain to agree upon what
88:41 - the state of the blockchain is sharding
88:43 - and rollups are solutions to scalability
88:46 - issues on layer ones
88:48 - a layer one is any base blockchain
88:50 - implementation like bitcoin or ethereum
88:52 - a blockchain scalability problem is that
88:54 - there's not always enough block space
88:56 - for the amount of transactions that want
88:57 - to get in them this leads to very high
89:00 - gas prices and again gas prices are how
89:02 - much it costs to interact with a
89:04 - blockchain
89:05 - so we've learned a ton in this video so
89:08 - far
89:08 - everything that you went over is going
89:10 - to make you 10 times better as a
89:13 - developer because yes being a good
89:15 - developer means you understand the code
89:17 - at a very technical level
89:18 - but if you can understand the overall
89:20 - architecture as well you can make the
89:22 - informed decisions about how to
89:24 - architect your design or how to build
89:26 - your software in however you want to do
89:28 - so so with all that being said it's
89:30 - finally time to jump into some solidity
89:32 - and jump into some code so let's do this
89:38 - now again
89:39 - in the description of this video there
89:41 - is a link to this github repository
89:43 - that's going to be the home base for all
89:46 - the code that we work with in this
89:48 - tutorial we scroll down to this main
89:50 - section this readme there's a table of
89:52 - contents in here
89:54 - we can go to lesson one simple storage
89:57 - and we'll have links helpful tips the
89:59 - itinerary of what we're going to learn
90:01 - and everything else that you need to
90:02 - work with here all the code that we're
90:04 - going to be working with is located in
90:07 - this simple storage link that we can go
90:09 - ahead and click it's in its own
90:11 - different repository we can go ahead and
90:13 - click the file to see all the code that
90:16 - we're going to be working with so let's
90:17 - jump into it additionally back in our
90:20 - full blockchain solidity course right at
90:22 - the top
90:23 - there's this resources for this course
90:25 - section if you have questions engaging
90:28 - in github discussions stack exchange
90:30 - ethereum and stack overflow are going to
90:33 - be great places to get help and get
90:35 - support i highly recommend making a
90:37 - stack overflow
90:39 - stack exchange ethereum
90:42 - and a github account so you can
90:44 - participate and engage with the
90:46 - community
90:49 - welcome to the remix ide or the remix
90:52 - integrated development environment this
90:55 - is going to be where we're starting to
90:57 - teach you how to work with solidity and
90:58 - work with smart contracts and deploy to
91:00 - blockchains we're going to use remix to
91:02 - get us up to speed as it has a lot of
91:04 - nice features that allow us to really
91:06 - see and interact with blockchains and
91:07 - really see what's going on but
91:09 - eventually we're actually going to move
91:10 - off of remix to another platform
91:13 - but all the solidity that we're going to
91:14 - learn here obviously is going to apply
91:16 - everywhere as well when you come to
91:17 - remix there's a whole lot of different
91:19 - plugins like solidity learn eth soul
91:21 - hint linter and a whole bunch of other
91:23 - plugins as well i'm going to go ahead
91:25 - and start by clicking the solidity
91:26 - plugin but we're not going to use any of
91:28 - these plugins for now but later on you
91:30 - can kind of go back and learn a little
91:32 - bit more about what these plugins do so
91:33 - let's start perusing let's start coding
91:36 - some things on the left hand side over
91:38 - here is where we're going to interact
91:40 - with everything so let's go ahead and
91:42 - click the files up here now you can
91:44 - always go back and peruse this a little
91:46 - bit more and in fact i highly encourage
91:48 - you to because that's how you're going
91:49 - to learn the most the quickest but for
91:51 - us we're actually just going to go ahead
91:52 - and start with our own brand new file
91:55 - we're going to create a little
91:56 - application that can store information
91:58 - on the blockchain for us and this is our
92:00 - first project that we're going to do in
92:02 - solidity so we're actually going to
92:04 - create a new file
92:05 - and we're going to call it
92:08 - simple
92:09 - storage dot soul all solidity has an
92:11 - extension of dot soul at the end stands
92:14 - for solidity now let's take inventory of
92:16 - what we're going to be working with here
92:18 - this is the solidity compiler tab
92:20 - it compiles all the solidity code down
92:23 - to machine understandable code or
92:25 - machine language here there's a whole
92:27 - bunch of different parameters we can
92:28 - choose when working with sliding we
92:30 - choose the compiler version we can
92:32 - choose the language which we're only
92:34 - going to be working with solidity the
92:35 - evm version don't worry about this for
92:38 - now so let's code our first solidity
92:41 - contract here
92:42 - now we are going to use something a
92:44 - little bit special here when we actually
92:46 - deploy these we're going to use a
92:48 - javascript virtual machine
92:50 - so we're going to use a virtual machine
92:52 - that's going to simulate actually
92:54 - deploying to a test net or a real
92:56 - network we're not actually going to
92:58 - deploy on a real network we will
93:01 - in a little bit but just to get started
93:03 - we're going to work with a javascript vm
93:05 - which is kind of a fake environment for
93:07 - now okay
93:08 - testing locally and understanding how to
93:10 - test locally will make your
93:12 - coding experience a lot faster as you
93:15 - saw when we sent some transactions some
93:17 - of them actually took some a lot of time
93:19 - to actually deploy we don't want to have
93:21 - to spend that much time waiting around
93:23 - for our tests to actually finish so
93:25 - we're going to use a javascript vm to
93:27 - kind of dummy it for now but let's just
93:29 - start coding and go from there
93:31 - so the first thing that you're going to
93:33 - need in any solidity program is the
93:36 - solidity version so that's always going
93:38 - to be at the top of your solidity code
93:41 - it's defined by doing pragma solidity
93:44 - and the version
93:45 - we're going to be using some version
93:47 - between
93:50 - 0.6.0
93:53 - and 0.9.0
93:56 - so we're saying we want to use anything
93:58 - between 0.6
94:00 - and 0.9 and and as a force of habit i
94:02 - just automatically hit command s
94:04 - whenever i write anything so that's why
94:06 - you saw some of this pop up here we can
94:08 - hitting command s or control s depending
94:10 - on if your windows or not we'll hit this
94:12 - compile button and we'll compile
94:14 - everything for us
94:15 - now if we want a specific version of
94:17 - solidity we can also do 0.6.0
94:20 - and if i go ahead and hit command s or
94:22 - compile
94:27 - our compiler will automatically convert
94:29 - to 0.6.0
94:31 - however if i try to do 0.8.0 with my
94:34 - solidity at 0.6.0 it's going to give us
94:36 - an error it's going to say the source
94:38 - file requires a different compiler
94:39 - version
94:40 - we're using 0.8.0 and this is 0.6.0 so
94:45 - we're going to go ahead and hit compile
94:46 - and it's going to automatically move
94:47 - down to 0.6.0
94:49 - we can also
94:51 - do carrot 0.6.0
94:53 - and this will allow us to work with
94:55 - really any version of 0.6
94:58 - it'll work all the way up to 0.7 where
95:01 - if we hit command s or control s there
95:03 - it'll give us an error so this only
95:05 - works with any version below 0.7 and
95:08 - above 0.6 we're going to be using
95:11 - version
95:12 - 0.6.6 however in future contracts that
95:14 - we work with we're actually going to
95:15 - work with different versions of solidity
95:18 - the reason we're going to be changing
95:19 - versions throughout this course is that
95:21 - solidity is a constantly updating
95:22 - language being good at switching between
95:25 - versions is going to make you an
95:26 - incredibly powerful smart contract
95:28 - engineer the next thing that we're going
95:30 - to do is we're going to define our
95:31 - contract
95:33 - so contract is a keyword in solidity
95:36 - which stands for our smart contract that
95:38 - we're going to create you can think of a
95:39 - contract similar to a class in java or
95:42 - any other object-oriented programming
95:44 - language so we're going to give our
95:45 - contract a name here we're going to call
95:47 - it simple storage
95:52 - and we're going to add this little curly
95:53 - bracket to say this
95:55 - is the contents of our contract simple
95:57 - storage
95:58 - and i went ahead and hit command s and
96:00 - we can see it is compiling successfully
96:03 - you could hypothetically deploy this
96:04 - right now and this would be a valid
96:06 - contract so great job for making it this
96:08 - far now in solidity there are many
96:10 - different types that we can work with
96:12 - let's go into some of the types of
96:13 - solidity we can have integers aka whole
96:17 - numbers they can be uint as in an
96:20 - unsigned integer meaning they're not
96:22 - positive or negative we can also have an
96:24 - int
96:25 - and we would define a variable by doing
96:28 - you in 256 favorite number
96:32 - equals 5.
96:34 - so we have
96:35 - an unsigned integer you went 256 means
96:38 - this is an integer of size 256 bits
96:43 - so we can have this be upped this number
96:45 - be up to 256. you can also do uint
96:48 - favorite number equals 5 but if you want
96:51 - to be a little bit more precise a lot of
96:53 - protocols and a lot of smart contracts
96:54 - will do the whole name like you and 256.
96:58 - we can also have
96:59 - booleans booleans are true false so we
97:02 - can have boolean
97:04 - favorite bool
97:07 - equals
97:08 - true so this favorite bool would be true
97:11 - it could also be
97:12 - false
97:14 - we can have strings
97:16 - string
97:18 - favorite
97:20 - string
97:21 - equals
97:24 - string
97:25 - a string is a string of text here right
97:28 - it's going to be some word or phrase or
97:30 - really any of these keystrokes here
97:32 - similar to the unsigned integer we can
97:34 - have an int
97:36 - 256
97:38 - favorite
97:39 - int
97:40 - equals negative 5
97:42 - so it could be positive or negative we
97:44 - can have an address
97:47 - which is going to be some type of
97:50 - ethereum address
97:52 - so we could do address
97:54 - favorite address
97:57 - equals
97:59 - and then we can even copy right from our
98:00 - metamask
98:02 - and just paste it right in here
98:05 - this is going to be a valid address here
98:07 - you'll also notice that we end all of
98:10 - our statements with a semicolon
98:12 - we can have a bytes object
98:14 - size 32 bits
98:16 - favorite bytes
98:18 - for our example
98:19 - we're just going to use the word cat
98:21 - because cat is a string which can be
98:24 - converted down into a bytes object by 32
98:27 - means that there's 32 bytes in this
98:29 - variable favored bytes we can also do
98:31 - bytes 2 bytes 3 bytes 5 etc with the
98:35 - maximum size of bytes 32
98:37 - for example we can't do bytes 64. we're
98:41 - going to be talking about some other
98:42 - variables as well like arrays and
98:43 - mappings but let's just stick here for
98:45 - now if you want to learn more about the
98:47 - different types and the different
98:48 - variables that you can use head over to
98:50 - the solidity documentation and there's a
98:52 - link in the github and the description
98:54 - to show you this section for now for our
98:57 - simple storage let's say we only want to
98:59 - store numbers we don't want to store
99:00 - anything else
99:02 - so we're just going to go ahead and
99:03 - delete everything and just have uint256
99:06 - favorite number
99:07 - at the top now in solidity if i do this
99:11 - favorite number actually does get
99:13 - initialized even though i didn't have it
99:15 - initialized to 5. if i leave it blank it
99:18 - gets initialized to the null value in
99:20 - this case it would be initialized to 0.
99:23 - so for now let's just not initialize it
99:25 - to anything that way it'll get
99:26 - automatically initialized to zero this
99:29 - means that when we deploy this contract
99:30 - as of right now favorite number will
99:33 - start off as zero if you get confused
99:36 - you can also make a comment on this you
99:38 - could say
99:39 - this will get initialized to zero
99:43 - this double slash here is the way to
99:45 - make comments in solidity and it won't
99:48 - get executed as code so we can write
99:50 - whatever we want as long as it's
99:52 - preceded by two backslashes
99:55 - now let's go ahead and create our first
99:58 - function
99:58 - functions or methods are self-contained
100:01 - modules that will execute some task for
100:04 - us and in solidity it's the exact same
100:06 - thing they're defined
100:08 - by the keyword function
100:10 - let's make a function called store
100:13 - that will change the value of this
100:16 - favorite number here
100:18 - so we're going to call store and we're
100:20 - going to allow it to be past a variable
100:22 - so we're going to allow it to be passed
100:24 - a variable of type unsigned integer 256
100:28 - and we're going to call it underscore
100:30 - fave
100:31 - or it
100:34 - number we're going to make this a public
100:37 - function which we'll get to in a minute
100:39 - and all we're going to do
100:41 - is we're going to set
100:42 - favorite number
100:44 - equals to whatever variable we passed in
100:47 - favorite number so this in its simplest
100:50 - form is how you can define a function
100:53 - now just to visualize what we're working
100:54 - on so far let's go ahead and deploy this
100:57 - contract so we can actually start to
100:59 - interact with it so if we hit this
101:01 - button this will bring us to the deploy
101:03 - tab and will allow us to deploy our
101:05 - smart contract here
101:07 - using our javascript vm it's given us a
101:10 - fake account with some ethereum in it it
101:12 - has 100 ethereum in it to start and same
101:15 - as before anytime we want to interact
101:17 - with the blockchain we have to pay a
101:19 - little bit of gas even in our fake
101:21 - virtual machine here and we want to
101:22 - simulate that so you'll see it has some
101:24 - of the same parameters here as making a
101:27 - transaction like gas limit for example
101:29 - when we deploy a contract it's going to
101:32 - cost a little bit of ethereum or a
101:33 - little bit of gas to do so
101:35 - so let's go ahead and hit this deploy
101:37 - button and see what happens so once we
101:40 - deployed with this virtual machine a few
101:42 - things happened
101:44 - we have
101:45 - remix kicking out this section down here
101:47 - saying great job you've deployed
101:48 - something and if we scroll down it says
101:51 - transactionsrecorded1 we can look at all
101:53 - the transactions we've recorded
101:55 - and we can see it says deployed
101:57 - contracts and we have a contract here
102:00 - that we've deployed now let's zoom out
102:02 - just a hair here so we can see
102:03 - everything a little bit better in this
102:05 - simple storage contract we see this big
102:07 - store button because there's one public
102:09 - function that we can actually interact
102:11 - with so we can add
102:13 - this number here and we'll hit store and
102:15 - you'll see again we have a completed
102:17 - transaction
102:18 - and if we look at our contract
102:20 - we'll have paid a little bit more gas
102:22 - right we'll have paid a little bit more
102:24 - to interact with this function because
102:25 - again anytime we want to make a state
102:28 - change in the blockchain we have to pay
102:30 - a little bit of gas the reason metamask
102:32 - isn't popping up is because we're kind
102:34 - of doing it in this simulated
102:35 - environment so this is great however it
102:38 - looks like we can't actually see
102:40 - what our favorite number is we can't
102:42 - actually look at it so how do we
102:44 - actually make sure that we can view this
102:46 - favorite number well let's add another
102:49 - parameter to this as well
102:51 - if we add public
102:53 - to our favorite
102:54 - number we recompile by hitting command s
102:58 - or hit the compile button
103:00 - we delete this contract and we redeploy
103:03 - and scroll down
103:05 - now we'll see two buttons pop up
103:08 - this blue button to show us favorite
103:10 - number which again is initialized to
103:12 - zero
103:13 - and we have the store function
103:15 - so let's talk a little bit about why
103:17 - this public variable allowed us to see
103:19 - this new button this new favorite number
103:21 - button this public keyword defines the
103:25 - visibility of the variable or the
103:27 - function there are currently four
103:28 - different types of what's called
103:30 - visibility in solidity there's external
103:33 - public
103:34 - internal and private we're mostly going
103:37 - to be working with public for now but
103:40 - it's important to know how the rest of
103:41 - these work public functions can be
103:43 - called by anybody including variables
103:47 - so oddly enough variables are a function
103:50 - call to just look at them and return
103:53 - whatever that variable is an external
103:55 - function means it can't be called
103:58 - by the same contract it has to be called
104:01 - by an external contract so if in this
104:03 - contract
104:05 - i had this be external
104:07 - i couldn't call
104:09 - the store function
104:11 - i couldn't call the store function
104:12 - inside this function
104:14 - because the function is external it
104:16 - means somebody outside of the contract
104:18 - has to call this function internal
104:20 - functions however can only be called by
104:23 - other functions inside of this contract
104:26 - or in its derived contract
104:28 - and then private is the most restrictive
104:30 - as private functions and state variables
104:33 - are only visible for the contract they
104:34 - are defined in and not derived contracts
104:37 - now the reason that we didn't see
104:39 - favorite numbers show up in our original
104:41 - contract deployment is that if we don't
104:43 - give a state variable a visibility it
104:46 - will automatically get set to internal
104:49 - so if we want other people to be able to
104:51 - read it we have to change it to public
104:54 - now let's see how this interaction
104:55 - actually works
104:56 - if we hit the favorite number button
104:58 - right now we'll get this call thing that
105:00 - shows up and it'll show us right here
105:02 - that
105:03 - the value of
105:05 - favorite number is zero
105:07 - now this function however is set so that
105:10 - whatever value we pass it is going to
105:12 - change the favorite number to whatever
105:14 - we pass it as so if we pass one two
105:16 - three hit store
105:18 - that transaction goes through
105:20 - and then hit favorite number we can see
105:23 - the value is now one two three
105:25 - now i will also be using transactions
105:27 - and smart contract interactions and
105:29 - function calls a little bit
105:31 - interchangeably that's because on a
105:33 - blockchain whenever you call a function
105:35 - or whenever you make some state change
105:37 - to the blockchain you're actually also
105:39 - making a transaction that's what makes
105:42 - this whole thing so powerful and again
105:44 - that's why making a function call or
105:46 - deploying a contract costs a little bit
105:48 - of gas now the reason we can access this
105:51 - favorite number variable inside this
105:53 - function
105:54 - is because favorite number has this
105:56 - global or contract scope so even if we
105:59 - made union 256 tests equals 4 or
106:03 - equals equals 4 we wouldn't be able to
106:06 - use this variable outside of this
106:07 - function
106:09 - right because it's self-contained it's
106:10 - self-contained inside this bracket
106:13 - and
106:14 - if i were to make another function
106:18 - store two perhaps
106:20 - public
106:26 - 2 doesn't know that this test variable
106:28 - exists
106:29 - functions only know about the variables
106:31 - that are in the same scope as them so
106:33 - favorite number is in this global scope
106:35 - because the only bracket that's above
106:37 - them is simple storage and test is in
106:39 - this store scope because it has two
106:41 - brackets above it it has it's inside of
106:43 - the store function and inside of this
106:45 - contract simple storage
106:47 - store two isn't inside of this store
106:50 - function or this store scope so it can't
106:53 - access this test variable
106:56 - so let's go ahead and make this back to
106:57 - public
106:59 - and we'll compile again i'm hitting
107:00 - command s to compile but you can go
107:02 - ahead and click the button if you like
107:03 - and let's get rid of this now as you saw
107:05 - when we deploy this
107:07 - there's this button here that we can
107:08 - click called favorite number we can also
107:11 - make a function called
107:13 - retrieve and make it a public function
107:16 - that is of type view
107:19 - and returns
107:20 - uint256
107:23 - and all this is going to do
107:24 - is return
107:27 - favorite number so we're going to talk
107:29 - about views and returns here
107:32 - so i'm going to go ahead and compile
107:34 - i'm going to go ahead and delete delete
107:36 - this contract i'm gonna go ahead and
107:38 - deploy it now
107:40 - and we can see
107:41 - now we have
107:43 - two functions or two blue buttons here
107:45 - we have retrieve and we have favorite
107:47 - number
107:48 - if i change favorite number by calling
107:50 - the store function favorite number and
107:53 - retrieve will both now say it's one two
107:55 - three
107:57 - so then the question might be well why
107:59 - is this one orange and these two are
108:01 - blue
108:03 - and the key relies in this view function
108:06 - or this view keyword there's two special
108:08 - keywords that define functions that you
108:10 - actually don't have to make a
108:12 - transaction on
108:13 - and those keywords are view
108:15 - and pure
108:17 - a view function
108:18 - means that we want to read some state
108:20 - off the blockchain so we're just reading
108:22 - off the blockchain if we're reading off
108:24 - the blockchain and we're not actually
108:26 - making a state change then we don't need
108:28 - to make a transaction
108:29 - these blue buttons are blue because they
108:32 - are view functions public variables also
108:35 - have view functions that's why both of
108:37 - these are blue
108:39 - this technically is a view function and
108:41 - when i click it i get to view and i get
108:43 - to read the state off the blockchain
108:46 - retrieve is the same way we could have
108:49 - this without a return but it wouldn't do
108:51 - anything pure functions are functions
108:53 - that purely do some type of math we'd
108:56 - have you in 256 favorite number public
108:59 - pure and just have favorite number plus
109:01 - favorite number
109:02 - so we're doing some type of math here
109:05 - but we're not actually saving state
109:07 - anywhere
109:08 - we're going to do this math but we're
109:10 - not going to save this favorite number
109:12 - anywhere we're not going to save
109:13 - anything deploy this now this pure
109:16 - function
109:18 - we would have this retrieve function one
109:20 - two three it's blue as well because it's
109:24 - again not going to change the state of
109:26 - the blockchain so view functions and
109:28 - pure functions are both can have this
109:29 - blue color
109:32 - now the reason that nothing shows up at
109:34 - the bottom is because we didn't return
109:36 - anything
109:37 - all we're doing is we're saying add
109:39 - these two numbers together and that's it
109:42 - in order for this function to give us
109:44 - something back we need to have it return
109:46 - something so if we go back
109:51 - to this retrieve
109:54 - to this retrieve function we have to
109:56 - define what we're going to return when
109:58 - we're defining this function so we're
110:00 - going to say this is a public function
110:01 - it's a view function because we're going
110:03 - to read some state and it's going to
110:05 - return a unit 256.
110:08 - so favorite number is of u 256 so that's
110:11 - what we're going to return
110:12 - our public variable favorite name is
110:15 - also a view function that returns a
110:16 - un256
110:18 - for now let's just remove that so we can
110:20 - work with this retrieve function
110:22 - so let's go ahead and deploy
110:24 - so now we see we don't have this
110:25 - favorite number button anymore because
110:27 - it is no longer a public function
110:30 - because again it gets initialized to
110:32 - internal so we can't actually view it
110:34 - now keep in mind later on we're going to
110:36 - talk about how everything on chain you
110:38 - actually can see
110:39 - and we'll talk about that a little bit
110:41 - later though so retrieve is going to do
110:43 - 0
110:44 - we can call store
110:46 - and now retrieve is going to be 1 2 3.
110:48 - now this application is great so far it
110:50 - allows a single person to store a
110:52 - favorite number and then go ahead and
110:54 - retrieve it
110:55 - later which is fantastic but what if we
110:57 - want a list of people or a group of
111:00 - people
111:01 - and store their favorite numbers or what
111:03 - if we want to associate a favorite
111:05 - number with a single person well what
111:07 - can we actually do now we have a whole
111:09 - number of different choices but the one
111:10 - that we're going to talk about is using
111:12 - a struct structs are ways to define new
111:15 - types and solidity they're almost like
111:17 - creating new objects as well
111:20 - so we can create a struct
111:22 - called type people
111:24 - and allow it to start storing a favorite
111:27 - number associated with a certain people
111:29 - so inside of our struct we can have
111:32 - different types as well
111:33 - so we have a uin256
111:36 - favorite number
111:37 - and we could also have a string
111:40 - name
111:41 - now we have a new type of type people
111:44 - that has a favorite number and a name
111:47 - inside of it now what we could do
111:49 - with destruct is we could say
111:53 - people
111:54 - public
111:56 - person
111:57 - equals
111:59 - equals people
112:01 - and then inside we add the variables so
112:04 - we could say
112:06 - favorite number
112:07 - favorite number is
112:09 - 2
112:11 - and name
112:12 - is
112:14 - patrick
112:16 - and of course the semicolon at the end
112:19 - and again i'm hitting command s to save
112:21 - but you can also go ahead and compile
112:24 - in the compile tab
112:25 - so let's go ahead and delete this
112:27 - contract and see what this looks like
112:28 - now
112:30 - so now we've deployed this new contract
112:32 - and we have this person struct which at
112:35 - the zero index
112:37 - is the favorite number and the variable
112:39 - stored in the first index is going to be
112:42 - the name storing variables and solidity
112:44 - always works in this numeric index
112:46 - fashion in fact in contract simple
112:49 - storage uint 256 favorite number is at
112:52 - index 0. if we were to add another
112:55 - object here like
112:56 - boolean favorite bool
112:59 - this would be at index one
113:01 - if we were to add bool
113:03 - favorite
113:04 - bool2 this would be at index
113:07 - two zero
113:09 - one
113:10 - two
113:11 - and it works the same in structs this is
113:13 - at index zero inside the struct this is
113:15 - at index one inside the struct
113:18 - so we can see the variables associated
113:20 - with this person we're gonna go ahead
113:21 - and delete this for now because
113:23 - instead of just creating one person we
113:25 - actually want to create a whole list of
113:27 - people so how do we create a list of
113:29 - people let's delete that contract
113:31 - and what we can do is we can make what's
113:33 - called an array an array is a way of
113:36 - storing a list or a group of some object
113:40 - so as you're starting to see the way the
113:41 - syntax works for defining any type of
113:44 - variable is going to be the type of the
113:46 - variable
113:48 - the visibility of the variable like
113:50 - public or if you don't declare it it
113:51 - gets initialized to internal
113:55 - and then the name of the variable
113:57 - it works the same with arrays so we'll
113:59 - make a people array the people array
114:02 - is the type
114:05 - we'll make it public
114:06 - and we'll call it people
114:09 - now if we deploy this contract
114:11 - we go and see we now have a people array
114:15 - but if we click this button
114:17 - you'll see that
114:18 - nothing shows up
114:19 - the reason is because it's an empty
114:21 - array to start with right we don't have
114:23 - anything inside of it
114:25 - now this type of array that we've
114:26 - created is what's known as a dynamic
114:28 - array it's a dynamic array because it
114:31 - can change its size right now it's a
114:33 - size 0 and if we added something to it
114:35 - it's of size one you can also create
114:38 - arrays of a fixed size so if i were to
114:40 - do people one public people this array
114:44 - could only have a maximum of one person
114:47 - inside of it
114:48 - so we're going to work with a dynamic
114:49 - array though because we want to add an
114:52 - arbitrary number of people into here so
114:54 - let's go ahead and create a new function
114:55 - called add person where we can add a
114:57 - person to this array
114:59 - so we'll do function
115:01 - add person
115:04 - string
115:06 - memory name i'll talk about this memory
115:08 - keyword in a minute
115:10 - uin256
115:12 - favorite
115:13 - number
115:18 - and then we'll make this a
115:20 - public function
115:25 - and inside we'll do we'll add this
115:27 - person to our array the way to add a
115:29 - person to your arrays is using the push
115:33 - method
115:34 - so we're going to push
115:36 - a new people or a new person
115:39 - and we're going to give it
115:40 - those variables again
115:42 - so we're going to give it so we're going
115:43 - to give it favorite number
115:46 - is this variable that we passed in here
115:49 - oops this needs a bracket
115:52 - and then we're going to give
115:55 - the name
115:57 - going to be this underscore name
116:00 - and then end bracket
116:03 - oops
116:05 - zoom out again here just so i can see
116:07 - stuff
116:09 - this needs a semicolon
116:11 - and perfect
116:13 - now in that last clip we saw this little
116:15 - red box pop up whenever a little red box
116:17 - like this pops up after you compile it
116:19 - means you have a compile error this
116:22 - means that there's something wrong with
116:23 - your solidity code or your salinity
116:25 - syntax and it won't compile and deploy
116:27 - properly red is going to be this compile
116:29 - error now we're going to see a bunch of
116:31 - yellow warnings in the future if you get
116:34 - a little yellow pop-up these are okay to
116:36 - ignore but they usually have some
116:38 - helpful tips about something that might
116:40 - be going wrong in your code so to
116:41 - summarize if it's red if it's red it's
116:44 - broken if it's yellow you might want to
116:46 - check it out but it could be okay so we
116:47 - can see we have our new function add
116:49 - person
116:50 - where we pass a string memory name and a
116:53 - unit 256 favorite number and then we
116:56 - create
116:57 - this people person
116:59 - this people object here and then we push
117:01 - it
117:02 - onto our people array
117:04 - and i'm going to show you another way we
117:06 - can actually create a people person
117:08 - is just by passing
117:10 - favorite number and name
117:13 - and getting rid of this other bracket by
117:16 - passing favorite number and name
117:18 - because we know
117:19 - that
117:20 - the zeroth index of people is favorite
117:21 - number and the first index of people is
117:24 - name so we can also create a new person
117:26 - by adding it like this now let's talk
117:28 - about this memory keyword here now in
117:30 - solidity there's more or less two ways
117:33 - to store information you can store it in
117:35 - memory
117:36 - or in storage
117:38 - when you store an object in memory it
117:41 - actually means that it'll only be stored
117:43 - during execution of the function or of
117:46 - the contract call
117:47 - if we hold it in storage
117:50 - that means that that data will persist
117:52 - even after the function executes a
117:54 - string in solidity is actually
117:56 - technically not a value type a string is
117:59 - actually an array of bytes a variable of
118:01 - type string is actually a special type
118:03 - of array that we can append text to so
118:07 - because it's technically an object we
118:08 - have to decide where we want to store in
118:10 - memory or in storage and since we only
118:13 - need this name during the execution we
118:15 - can have it be string memory name and
118:17 - then when we create this new people
118:18 - object we will create a new copy of this
118:22 - name variable into storage memory means
118:24 - that after execution delete this
118:26 - variable and storage means keep it
118:28 - forever if this is a little bit
118:30 - confusing for you just know that for now
118:32 - when you use a parameter that's going to
118:34 - be a string for one of your functions
118:36 - you need to call it string memory so
118:38 - let's go ahead and deploy this contract
118:40 - and see what happens now
118:42 - now we have this new function add person
118:46 - and since we are making a state change
118:48 - here we can see that this indeed
118:50 - is a orange button instead of being a
118:53 - blue button so we can add in here a
118:55 - string name we'll add
118:57 - patrick and we'll say his favorite
118:59 - number is 2.
119:01 - again right now if we look at people
119:03 - we see people 0 there's nothing in here
119:05 - if we retrieve there's nothing in here
119:07 - so we're going to add person patrick and
119:10 - now if we hit people of 0 we can see
119:13 - that the person at the zerowith index in
119:15 - this people array
119:16 - is going to be
119:18 - string patrick
119:19 - if we try at one there's nothing in here
119:22 - let's add another person
119:24 - we'll add
119:25 - becca and her favorite number will be
119:27 - 24.
119:28 - let's add her now if we hit one we see
119:31 - favorite number 24 string name is becca
119:34 - and retrieve is so showing up blank
119:36 - because we haven't touched favorite
119:38 - number awesome this is great we can just
119:41 - keep adding people
119:43 - however there is kind of an issue here
119:45 - what if i'm looking for a person what if
119:47 - i'm looking to find
119:48 - becca and find her favorite number in
119:50 - this array
119:52 - what if i know her name but i don't know
119:53 - her favorite number is there an easy way
119:55 - for me to find that favorite number
119:56 - without having to triage the entire
119:59 - array there's another data structure
120:00 - called a mapping so let's create this
120:03 - new data structure
120:04 - so this data structure is going to be of
120:06 - type
120:07 - mapping a mapping takes some type of key
120:09 - and spits out whatever variable it's
120:10 - mapped to so in this case if we're
120:13 - saying we want to use the name becca to
120:15 - find her favorite number we would say
120:17 - the string becca
120:20 - is going to be mapped
120:21 - to the uint 256 favorite number and
120:25 - similar to
120:26 - all the other variable declarations the
120:29 - first part is going to be the typing so
120:31 - this is going to be a type mapping of
120:34 - string
120:35 - mapped to un256
120:37 - we're going to give this public
120:38 - visibility and we'll call it
120:40 - name
120:41 - to favorite number and without adding
120:44 - any other functions that work with it if
120:46 - we deploy this we can see we have this
120:49 - blue button because we're not making a
120:50 - state change name to favorite number and
120:53 - if we type in becca in here
120:56 - obviously nothing's going to happen
120:58 - because we haven't added this
121:00 - mapping in yet
121:01 - so in our ad person down here let's even
121:04 - have this ad person also add to the
121:07 - mapping so we can do name
121:09 - to favorite number
121:13 - and then the key is going to be this
121:15 - name so of becca we're going to say
121:17 - we're going to map the name becca
121:20 - to
121:21 - the favorite number
121:23 - now we're going to go ahead and compile
121:25 - again i'm hitting command s
121:27 - deploy
121:28 - we can scroll down here
121:30 - if we look up backhand here
121:32 - we're going to get nothing
121:34 - however
121:35 - if we add
121:37 - becca
121:40 - and her favorite number being 24
121:44 - this add person is going to add it both
121:46 - to the array
121:47 - and to this mapping now if we look up
121:50 - name to favorite number we see that
121:52 - becca returns 24. now one other thing i
121:54 - want to show you guys just because
121:56 - compilers are going to yell you if you
121:58 - don't have them is typically at the top
122:00 - of these contracts you want to add an
122:02 - spx license identifier basically
122:05 - solidity and the ethereum community
122:07 - found out that
122:08 - trust in a smart contract can be better
122:09 - established if source code is available
122:12 - and
122:12 - in terms of legality and copyright it
122:15 - just makes life a lot easier if you add
122:17 - that license identifier right at the top
122:19 - of your solidity we're going to use the
122:21 - mit license identifier because it's the
122:24 - most open license out there it means hey
122:26 - anybody can use this code and we don't
122:28 - care so you'll see a majority of
122:30 - salinity contracts have this spx license
122:32 - identifier mit at the top and compilers
122:36 - will yell you a lot less awesome we now
122:38 - have a contract that we've decided that
122:40 - we liked it's got mappings it enables us
122:43 - to actually store people and their
122:44 - favorite numbers this is fantastic we've
122:46 - done all of our testing in this
122:48 - javascript vm and we've decided you know
122:51 - what we want to deploy this to an actual
122:53 - test net or an actual mainnet how do we
122:56 - actually deploy this so that other
122:58 - people can interact with this contract
123:00 - we are again going to use rink b because
123:02 - that's what we use to make our first
123:03 - transaction
123:04 - now again you will need some type of
123:07 - test ethereum in your test and wallet so
123:10 - again if you get lost
123:12 - you can always just google rink b
123:15 - faucet
123:16 - or ring b test net faucet
123:18 - and find a faucet or a better
123:20 - alternative would be to come to the link
123:22 - token contracts in the chain link
123:24 - documentation at
123:26 - docs.chain.link and
123:28 - scroll down or just look up rink b this
123:31 - linked token contracts page has the most
123:33 - up-to-date faucets for any test net that
123:36 - it supports so for example we get a test
123:39 - and eth faucet right here which also
123:41 - just happens to be that exact faucet
123:43 - that we used earlier the only thing you
123:45 - need to change
123:46 - in remix is we need to change from
123:49 - javascript vm to injected web3
123:53 - and metamask will actually pop up and
123:54 - say hey would you like to connect to
123:57 - this application
123:58 - anytime you're working with a web3
124:00 - application or a web application that
124:02 - wants to access your funds or work with
124:04 - your metamask metamask will pop up and
124:07 - ask for authorization first this is
124:09 - really good so that we know which
124:10 - applications we're actually connected to
124:13 - so we're going to go ahead and say next
124:15 - connect and we can see here
124:17 - that we've even connected here and that
124:20 - our account on the main network
124:22 - has zero eth
124:24 - and remix even tells us hey you're on
124:26 - the main network so let's go ahead and
124:28 - switch
124:30 - to the rink b network
124:31 - and we can now see
124:33 - we're on the rink b network and we have
124:35 - 17.74 eth on this ring b test network
124:39 - injected web 3 means we're taking our
124:42 - meta mask and injecting it into the
124:45 - source code of the browser here and
124:48 - that's the difference between injected
124:49 - web 3 and javascript vm web web3
124:51 - provider is if we want to use our own
124:53 - blockchain node or our own web3 provider
124:57 - when we do injected web3 we're saying
124:58 - our web3 provider is our metamask which
125:01 - will work perfectly for what we're
125:02 - trying to do so since we already have
125:04 - some tests on ethereum let's go ahead
125:06 - and deploy this and see what this would
125:07 - actually look like if we deployed to a
125:09 - mainnet the process is going to be
125:11 - exactly the same right the only
125:13 - difference was we would be on the main
125:15 - net instead of rank b so let's go ahead
125:17 - hit deploy we'll uncheck publish
125:18 - published ipfs
125:20 - hit deploy metamask will pop up asking
125:22 - if we want to do this transaction
125:24 - because remember
125:25 - we are deploying a contract we are
125:28 - changing the state of the blockchain so
125:30 - we have to pay a little bit of gas fee
125:31 - for it so we're going to go ahead and
125:33 - hit confirm
125:35 - and we get
125:36 - a link to ring the ether scan similar
125:39 - exactly as we saw before when we made a
125:41 - transaction the difference here
125:44 - is that instead of sending ethereum to
125:46 - somebody we're actually making a
125:48 - transaction on the blockchain to create
125:50 - a contract after a short while it will
125:52 - show up here on etherscan with a success
125:55 - the number of block confirmations which
125:57 - again is the number of blocks appended
126:00 - to the block that included our
126:01 - transaction
126:02 - we see from which is our account here
126:05 - and we see two is this new contract that
126:07 - we just created and we can even click it
126:09 - and we see
126:10 - that
126:11 - there's this unique transaction hash
126:13 - that created a new smart contract and
126:16 - same as working with the vm we have all
126:18 - the exact same functions in here and you
126:20 - can see if i hit retrieve
126:22 - these three functions since they're not
126:24 - making a state change you can just click
126:26 - them and no transactions will be made
126:29 - however what do you think is going to
126:30 - happen if i hit store
126:34 - if you guessed metamask will pop up you
126:35 - guess correctly
126:36 - again we see the familiar pieces here we
126:38 - have a gas price gas limit
126:41 - go ahead and hit confirm
126:43 - we get another transaction here and once
126:46 - this transaction goes through
126:48 - we should be able to call our retrieve
126:49 - function and see a new number
126:52 - if we call it now
126:53 - nothing shows up because our original
126:55 - transaction hasn't succeeded but i bet
126:58 - if we look at it now
127:01 - okay it's still indexing but it looks
127:02 - like it's been included if we hit it now
127:05 - we do indeed see this value here
127:07 - and we can do the same thing with adding
127:09 - a person we'll add becca we'll say her
127:12 - favorite number is 24.
127:14 - metamask will pop up we'll go ahead and
127:16 - confirm the transaction and if i look up
127:19 - becca and the name to favorite string
127:21 - right now it's going to show nothing
127:23 - because our transaction hasn't gone
127:24 - through yet
127:26 - but if we wait a little bit i should
127:28 - probably spell her name right we do see
127:30 - 24.
127:31 - and if we look at the zeroth index we
127:33 - also see becca's been added here as well
127:35 - now all the solidity code that we wrote
127:37 - and when we interacted with this
127:38 - blockchain here
127:40 - all this solidity was compiled down to
127:42 - the evm also known as the ethereum
127:45 - virtual machine
127:46 - a lot of the blockchains out there today
127:48 - are what's called evm compatible
127:51 - and that means that all this solidity
127:53 - and all these functions that we're
127:54 - creating
127:56 - can still compile down to evm and
127:58 - deployed on their blockchain you'll find
128:00 - out a little later when we look to work
128:02 - on a non-ethereum based chain that we
128:04 - can still deploy our solidity smart
128:06 - contracts to these other chains as well
128:08 - but that's a term you'll hear more and
128:10 - more the ethereum virtual machine or ebm
128:13 - now take a break give yourself a high
128:15 - five because you just deployed your
128:17 - first smart contract and you learned the
128:19 - basics the fundamentals of solidity so
128:22 - huge congratulations on how far you've
128:24 - gotten now in our second projects we're
128:26 - going to take the fundamentals a step
128:27 - further and start going into the more of
128:29 - the intricacies of solidity but just as
128:32 - a quick recap the first thing you always
128:34 - got to do in your smart contracts is
128:36 - name the solidity version
128:38 - then you'll have to name your contract a
128:40 - contract in solidity is like a class and
128:42 - defines all the functions and parameters
128:44 - of your contract
128:46 - there's many different types in solidity
128:48 - like unsigned integer 256 boolean and
128:51 - bytes
128:52 - we can create structs in solidity we can
128:55 - create arrays in solidity we can create
128:57 - mappings in solidity we can create
128:59 - functions in solidity
129:01 - view functions don't make a state change
129:03 - memory and storage are two different
129:05 - ways to initialize where a variable is
129:08 - going to be saved
129:09 - all the solidity code that we're working
129:10 - with gets compiled down to the ethereum
129:12 - virtual machine and last but not least
129:14 - congratulations on taking your first
129:16 - step in learning solidity let's move on
129:18 - to the next project
129:22 - all the code tips and links that we're
129:25 - going to be working with can be found in
129:27 - our course repository
129:28 - we can scroll down to lesson two
129:31 - storage factory
129:33 - click it here and we can see all the
129:36 - code we're going to be working with good
129:37 - luck all right so we've done it we've
129:39 - got our first contract out of the way
129:41 - we're understanding some of the basics
129:43 - of solidity now let's move onward let's
129:46 - get a little bit more advanced with what
129:48 - we're going to do
129:49 - with our smart contracts and let's build
129:51 - what's called the factory pattern of
129:53 - smart contracts so we have our simple
129:56 - storage contract here which is great it
129:58 - allows us to store
130:00 - numbers and store favorite numbers
130:02 - associated with different people and
130:04 - this is great what if though i want to
130:06 - have a lot of these simple storage
130:08 - contracts deployed i want to give people
130:10 - the ability to generate and deploy their
130:13 - own lists based off of this contract
130:16 - this is where the factory pattern comes
130:18 - into play so let's go ahead and create a
130:21 - new contract so in this contracts folder
130:24 - i'm going to do new file
130:27 - we're going to call this
130:29 - storage
130:30 - factory
130:31 - dot sol
130:33 - and now we'll have a storage factory.sol
130:37 - now the way that we're going to do this
130:38 - is that you need simple storage and
130:40 - storage factory in the same folder
130:43 - i have both of them in this contracts
130:45 - folder but if you have them outside or
130:47 - in a different folder that's okay just
130:49 - make sure wherever they are they're in
130:51 - the exact same folder so let's figure
130:53 - out how to get a contract to actually
130:55 - deploy another contract we're going to
130:58 - add those basic pieces that we added in
131:00 - that simple storage.sol we'll add the
131:02 - spdx
131:05 - license
131:07 - identifier
131:08 - which will be mit
131:11 - we'll choose our solidity version which
131:13 - will be pragma
131:16 - solidity
131:17 - and we'll say anything in the six range
131:21 - and then we'll create our contract we'll
131:24 - say contract
131:26 - storage
131:27 - factory
131:28 - and we'll create our brackets here and
131:31 - i'm going to do command s or compile
131:33 - whatever you want to do things are
131:35 - looking good here great so how can this
131:38 - contract
131:39 - deploy a simple storage contract well
131:42 - the first thing that we're going to need
131:43 - to do is actually import this simple
131:46 - storage into our storage factory
131:48 - contract
131:49 - we need to import it so that
131:51 - our storage factory contract knows
131:54 - what a simple storage contract even
131:56 - looks like
131:57 - the way that we can import it is by
131:59 - doing the command import and then the
132:01 - file path that the simple storage is
132:03 - located so the file path for this is
132:05 - going to be at dot slash
132:08 - simple
132:09 - storage dot soul
132:12 - this means that simple storage is in the
132:14 - exact same directory as storage factory
132:17 - doing this line is equivalent to copying
132:20 - everything in this contract bit
132:22 - coming over to storage factory and
132:25 - pasting it above
132:28 - you can even save and compile and have
132:30 - two contracts in the same file now
132:32 - what's interesting about having two
132:34 - contracts in the same file is that when
132:36 - you go to deploy
132:37 - you'll actually have a choice of which
132:39 - one you want to deploy and it's the same
132:41 - thing if i do that import statement so
132:44 - if i delete all this
132:46 - and i go back to import dot slash
132:49 - simple storage dot sol in our deploy tab
132:52 - still
132:53 - you'll see that we still have our choice
132:56 - of which contract we actually want to
132:57 - deploy
132:59 - so this is how we actually import a
133:01 - contract or import any type of file that
133:03 - we want so that our contract knows what
133:07 - that contract looks like and can do so
133:09 - if we want this contract to then be able
133:11 - to deploy a simple storage contract
133:14 - we're of course going to have to create
133:15 - a function that can do that
133:18 - so we'll do function
133:20 - we'll call it create
133:22 - simple
133:23 - storage contract
133:25 - we'll make this a public function
133:28 - we'll do our little open and close
133:29 - bracket in here the way we can generate
133:32 - a contract of simple storage type is by
133:35 - using a new keyword so let's create a
133:37 - simple storage variable
133:38 - we'll say a variable of type
133:41 - simple storage contract we'll name this
133:44 - variable
133:45 - simple storage
133:47 - with a lowercase s
133:49 - equals
133:50 - new
133:52 - simple
133:54 - storage
133:58 - what this line is saying is we're saying
134:00 - we're going to create an object
134:02 - of type simple storage contract
134:05 - we're going to name it simple storage
134:07 - with a lowercase s
134:09 - and we're going to say this is going to
134:10 - be a new simple storage contract and
134:13 - we're saying this simple storage
134:14 - contract takes no input parameters of
134:17 - course if we deploy this contract as is
134:20 - by going to our deploy tab
134:22 - choosing the storage factory
134:25 - staying on a javascript vm
134:28 - deploying
134:29 - scrolling down
134:31 - we have this function that doesn't
134:33 - return anything
134:35 - so we're creating new contracts but we
134:37 - can't really read where those contracts
134:39 - are being created we'd have to look on a
134:41 - block explorer like etherscan or
134:43 - something
134:44 - so let's make a way for us to keep track
134:47 - of all the different simple storage
134:48 - contracts that we deploy
134:50 - let's put them in a list or in an array
134:54 - so what we can do
134:55 - is we can say
134:57 - simple storage
135:00 - array
135:01 - of visibility public and we'll call it
135:05 - simple storage
135:07 - array
135:10 - we'll initialize this symbol storage
135:12 - array
135:13 - and every time we deploy we create one
135:16 - of these new simple storage contracts
135:18 - we'll add it to our simple storage array
135:21 - so we'll do simple storage array dot
135:24 - push
135:25 - and we'll push
135:26 - this simple storage variable
135:30 - so again i'm compiling or hitting
135:32 - command s
135:34 - delete that most recent contract
135:37 - we'll choose the storage factory and not
135:39 - the simple storage
135:41 - and we'll hit deploy
135:44 - now if we scroll down to our storage
135:46 - factory
135:47 - we have this blue button which stands
135:49 - for our simple storage array
135:51 - if we try to see what's at index 0 we
135:54 - get an error of course because we
135:56 - haven't added anything to it yet
135:58 - if i click this create simple storage
136:01 - contract
136:02 - orange button here
136:04 - now i've created a transaction that's
136:06 - going to create a new simple storage
136:08 - contract and push it onto our simple
136:11 - storage array
136:13 - now if i try to access the zerowith
136:15 - index or the first index of this array
136:18 - i'm going to get this address here
136:21 - this is the address that this simple
136:23 - storage contract was deployed to so
136:26 - we've successfully deployed
136:28 - a contract
136:29 - to the blockchain from another contract
136:32 - and this of course is really exciting
136:34 - now we can actually do more than just
136:36 - deploy the contracts we can actually
136:38 - deploy contracts from another contract
136:40 - and then call those functions as well
136:43 - so let's create a new function where we
136:45 - call
136:46 - this store
136:49 - function and we'll also create a
136:51 - function where we call the retrieve
136:52 - function from our storage factory so
136:55 - we'll do function
136:57 - storage factory store
136:59 - we're going to shorthand it by saying sf
137:01 - store we'll have it take unit 256
137:05 - simple
137:08 - storage
137:11 - index
137:12 - and a uint256
137:14 - underscore simple
137:17 - storage
137:19 - number
137:20 - we'll make this a public variable as
137:22 - well in our little brackets here
137:24 - and the reason i'm choosing a simple
137:26 - storage index is because we're going to
137:28 - choose which simple storage contract in
137:31 - our list that we want to interact with
137:33 - and then we're also going to pass a
137:35 - simple storage number
137:37 - to call
137:39 - on the store function which of course we
137:41 - need to pass a favorite number to any
137:43 - time that you interact with a contract
137:45 - you need two things
137:47 - you need the address of the contract you
137:49 - want to interact with and you also need
137:52 - the abi for us we figured out that
137:56 - we're going to push and get this address
137:58 - from this simple storage array
138:01 - we can get the abi or the application
138:03 - binary interface from this import
138:06 - we'll explain the application binary
138:08 - interface a little bit more later
138:11 - for now just know that in order for us
138:13 - to interact with this simple storage
138:15 - contract we can just do
138:18 - simple storage
138:21 - and then
138:23 - we'll pass this simple storage the
138:26 - address of that simple storage
138:28 - contract
138:29 - to get the address of that simple
138:30 - storage contract
138:32 - we'll say
138:33 - grab the address
138:36 - inside the simple storage array
138:39 - at index simple storage index this will
138:42 - return that contract that we want to
138:44 - interact with
138:45 - so we could even say
138:49 - simple storage
138:52 - simple
138:54 - storage
138:55 - equals simple storage
138:57 - at that address in the array
139:01 - once we get this contract we can then
139:03 - call
139:04 - any and all of its functions
139:06 - so we could call
139:08 - simple storage
139:10 - dot store
139:14 - this simple storage number
139:16 - now if we compile this
139:18 - we go to our deploy tab deploy the
139:20 - factory
139:22 - hit deploy
139:24 - open this up we can see we have a couple
139:26 - different functions here we of course
139:28 - have our create simple storage function
139:30 - which creates the contract and adds it
139:31 - to our array
139:33 - we now have this sf store
139:35 - which stores
139:37 - a number
139:38 - to one of those contracts on this array
139:42 - and then we have
139:43 - a lens
139:45 - into that simple storage contract
139:47 - so if i create a simple storage contract
139:50 - i can now store
139:53 - on that zerowith contract on that first
139:56 - contract any number that i want like 55.
140:00 - of course i can't really see that 55
140:03 - because we didn't add a retrieve
140:05 - functionality we didn't add a way to
140:08 - actually listen or read or retrieve that
140:10 - favor number that we got
140:12 - so let's add that now so
140:14 - we'll create a new function
140:17 - called
140:18 - sfget and this will take a uint 256
140:23 - simple storage
140:24 - index
140:26 - and as a parameter and we'll choose one
140:30 - of these contracts on this array and
140:33 - return
140:36 - its favorite number
140:37 - calling the retrieve function on that
140:39 - contract
140:42 - so since we're just going to be reading
140:44 - state
140:45 - this can be a public
140:47 - view function
140:48 - that will return
140:50 - a uint256
140:54 - to do this
140:55 - we need to access that contract once
140:57 - again
140:58 - so we'll say simple
141:00 - storage
141:02 - simple storage
141:04 - equals
141:05 - simple storage
141:09 - at that address
141:11 - of
141:12 - simple
141:15 - storage array
141:17 - at index
141:18 - underscore simple
141:21 - storage index
141:25 - and we can return
141:27 - return
141:30 - simple storage
141:33 - dot
141:35 - we call this retrieve function
141:39 - i'm just going to copy paste it so i
141:41 - don't spell it wrong
141:42 - simple storage we'll put the semicolon
141:45 - here too
141:46 - and here
141:49 - now if we compile this go to our deploy
141:52 - tab delete the most recent
141:56 - choose the storage factory and hit
141:58 - deploy
142:00 - we can see we now has have an sfget
142:03 - function
142:05 - so let's go ahead
142:06 - create a simple storage contract we'll
142:08 - store a function on the zeroth contract
142:12 - we'll store 55 as its favorite number
142:15 - and we'll hit that
142:16 - and then for s of get we'll see if we
142:19 - can get
142:21 - the favorite number of the zero with
142:23 - contract
142:24 - and we do indeed get 55.
142:26 - awesome we can actually even refactor
142:29 - this code to be a little bit simpler
142:30 - here
142:31 - we don't need to save
142:34 - this simple storage contract is a
142:36 - variable here we can actually just call
142:38 - retrieve
142:40 - on this whole section here
142:42 - paste retrieve at the end
142:44 - and just
142:46 - return
142:47 - like this
142:50 - the same goes for our sf store
142:54 - we can delete saving it as a variable
142:57 - we can copy this dot store
143:00 - paste it at the end here
143:02 - and delete this as well
143:06 - now we'll compile
143:10 - delete the most recent
143:11 - we'll deploy the storage factory
143:16 - and if we go into it create a simple
143:19 - storage
143:23 - store the number 55
143:26 - see what's at the zeroth index and we do
143:29 - indeed see 55.
143:31 - so
143:32 - this is really cool this is a way for us
143:34 - to actually deploy contracts and
143:36 - interact with contracts from another
143:39 - contract now to deploy a contract we do
143:41 - need all the functionality of that
143:43 - contract
143:44 - imported however to interact with the
143:46 - contract we don't need all of the
143:49 - functionality we'll learn about
143:50 - interfaces in the next lesson which will
143:53 - allow us to actually interact with the
143:54 - contract without having all the
143:57 - functions defined and now i'm going to
143:59 - show you something really cool now i'm
144:01 - going to show you something really cool
144:03 - simple storage has got a lot of really
144:05 - cool functions and maybe i want all
144:07 - these functions inside my storage
144:10 - factory i want my storage factory to be
144:12 - able to create simple storage contracts
144:15 - and i want it to be a simple storage
144:17 - contract itself
144:19 - well what i can do
144:21 - is my storage factory can actually
144:23 - inherit
144:24 - all the functions of simple storage
144:27 - without me having to copy paste all
144:30 - these functions and all these variables
144:32 - over to storage factory what i can do
144:35 - is i can do solidity's version of
144:36 - inheritance
144:38 - i can say contract storage factory
144:41 - is of type
144:44 - simple storage or is of contract simple
144:47 - storage
144:48 - and just by doing this line right here
144:51 - my storage factory contract now will
144:53 - have all of the functions and variables
144:56 - of simple storage so it'll have
144:59 - a store function a retrieve function an
145:03 - add person function
145:05 - a people array a name to favorite number
145:07 - mapping it'll have everything because i
145:10 - will inherit it with this is syntax
145:14 - so if i go to my deploy tab now
145:16 - [Music]
145:17 - let's look at what our last storage
145:19 - factory was
145:21 - all we did to change this was add is
145:23 - simple storage and we can see just the
145:26 - four functions that we originally added
145:28 - if i delete this now
145:34 - if i save and compile the storage
145:36 - factory let's go ahead and deploy
145:39 - storage factory
145:41 - if we open this up now
145:43 - we can see
145:44 - not only do we have all the functions
145:47 - originally defined in our storage
145:49 - factory but we additionally have all the
145:51 - functions from our simple storage and
145:54 - awesome you've completed the second
145:55 - lesson we've learned about some
145:57 - incredibly powerful tools here we've
145:59 - learned how to import entire chunks of
146:02 - code from other files into our files
146:05 - we've learned how to do inheritance
146:07 - we've learned how to deploy contracts
146:09 - from our contract
146:12 - and then we've learned how to interact
146:14 - with different contracts from outside of
146:17 - our contract well done now is a great
146:19 - time to take a breath take a breather
146:21 - and review what you've learned
146:26 - the github repository associated with
146:28 - this course also has all the code for
146:30 - this lesson so let's jump into it so
146:33 - we're back in remix now and we're going
146:34 - to go to contracts and same as before
146:36 - we're going to create a new file we're
146:39 - going to call this fundme.sol
146:41 - now same as last time we're actually
146:43 - going to add this spdx license
146:45 - identifier mit right at the top and then
146:47 - we're going to choose our solidity
146:49 - version
146:51 - so we're going to go pragma solidity
146:55 - and for this we're just going to do
146:57 - greater than equals to
146:58 - 0.6.6
147:00 - and less than 0.9.0
147:04 - and great
147:06 - this should look pretty familiar
147:08 - now we're going to do contract fund me
147:12 - and we're going to start working so what
147:14 - again do we want this contract to do we
147:17 - want this contract to be able to accept
147:19 - some type of payment so let's create a
147:22 - new function that can accept payment
147:25 - we'll call it fund
147:27 - so we'll do function
147:29 - fund
147:31 - public and we'll add a new keyword in
147:33 - here called payable when we define a
147:35 - function as payable we're saying hey
147:38 - this function can be used to pay for
147:40 - things when you call a function
147:42 - every single function call has an
147:44 - associated
147:45 - value with it whenever you make a
147:47 - transaction you can always append a
147:50 - value
147:51 - this value
147:52 - is how much whey or gray or fini or
147:55 - ether you're going to send with your
147:57 - function call or your transaction
147:59 - as we mentioned before
148:01 - whey way and ether are just different
148:04 - ways to talk about how much ether you're
148:06 - going to send
148:07 - so if we look at a way to ethereum
148:10 - converter one each is
148:13 - this much way
148:15 - one way is the smallest denomination of
148:19 - ether you can't break up ethereum into
148:21 - anything smaller than one way this is
148:24 - why when you're talking about how much
148:25 - something costs everything always
148:27 - defaults to whey or the smallest unit of
148:30 - measure in ethereum so again for us to
148:33 - test we're going to stick with the
148:34 - javascript vm for now if we hit deploy
148:37 - we get a new contract and this button is
148:39 - now red it's red because it is a payable
148:43 - function so now if i hit this fun button
148:45 - [Music]
148:46 - i can add
148:48 - a value associated with it so what do we
148:50 - want to do with this funding what do we
148:52 - want to do when people send us something
148:54 - well let's keep track of who sent us
148:56 - some funding so what we can do is we can
148:59 - create a new mapping between addresses
149:02 - and value
149:03 - so let's do a mapping
149:06 - of address
149:09 - to
149:10 - uin256 which will represent the value
149:13 - we'll make this a public mapping
149:15 - and we'll call it
149:16 - address to amount
149:19 - funded
149:20 - now in this fun function let's keep
149:22 - track of all the people who sent us
149:24 - money or all the addresses that sent us
149:26 - some value
149:28 - to do this we can use some keywords that
149:31 - go along with every transaction so we'll
149:33 - say address
149:35 - to amount funded
149:38 - of message.sender
149:43 - equals
149:44 - or
149:45 - plus equals
149:47 - message.value message.sender and
149:50 - message.value are keywords in every
149:53 - contract call and every transaction
149:55 - message.sender is the sender of the
149:58 - function call and message.value is how
150:01 - much they sent
150:03 - so whenever we call fund now somebody
150:05 - can send some value because it's payable
150:08 - and we're going to save everything in
150:10 - this address to amount funded mapping
150:13 - so if we deploy this now
150:14 - in our javascript vm
150:16 - we now have again a new view function
150:18 - called address to amount funded and we
150:20 - can even hit the drop down to see the
150:22 - full name
150:23 - now if i hit fund nothing's going to
150:25 - happen right because my address is going
150:28 - to be sending zero
150:30 - in order for me to send something i have
150:32 - to add some value along with my
150:34 - transaction
150:35 - so let's send for example one way
150:38 - which is going to be equal to
150:40 - 1
150:41 - 1 2 3 4 5 6 7 8 9 this much way so
150:46 - before i hit fund here if i copy this
150:48 - fake account which is up here
150:51 - and i put it in this address to amount
150:53 - funded
150:54 - it's going to return zero
150:57 - but now if i add
151:00 - 1 1 2 3 4 5 6 7 8 9 in here
151:05 - and we go ahead and hit fund now we've
151:07 - now just called this fun function with a
151:09 - value of one gray associated with it
151:13 - so if i call
151:15 - this address to amount funded now with
151:17 - the same address i can now see
151:19 - how much we've funded this smart
151:21 - contract and we can even add more gray
151:25 - we'll add
151:27 - we'll add 11gway for example we'll call
151:29 - fund and if we call this now we can see
151:32 - that even more has been added when we
151:34 - send our funds to a contract this
151:36 - actually means that this contract
151:38 - wherever this is deployed now is the
151:40 - owner of this
151:42 - amount of ether
151:44 - so this is fantastic we now have a way
151:46 - to fund our smart contracts now here's
151:48 - the thing
151:50 - in this smart contract in this funding
151:51 - that we're doing we want to create a
151:54 - minimum value for people to be able to
151:56 - fund our endeavors which whatever they
151:58 - may be we want to set some minimum value
152:00 - here
152:01 - and ether is great but for whatever
152:03 - reason we want to work in usd or maybe
152:06 - we want to work in some other token so
152:08 - how are we going to get the conversion
152:09 - rate from that currency to a currency
152:11 - that we can use in this smart contract
152:14 - well the first thing that we're going to
152:15 - need to do to set this value is we're
152:17 - going to need to know
152:19 - what the eth
152:21 - to usd
152:22 - conversion rate is
152:24 - because if i want to
152:26 - accept ethereum as the token but i want
152:29 - it in its usd currency well then i'm
152:31 - going to need to know what that
152:32 - conversion rate is so how are we going
152:34 - to get this data into our smart contract
152:37 - where are we going to get this data from
152:39 - now remember how we talked about
152:40 - blockchains being deterministic systems
152:42 - and and oracles being the bridge between
152:44 - blockchains and the real world well this
152:46 - is exactly where oracle's come in when
152:49 - we're talking about these systems you
152:50 - know these blockchains they can't
152:52 - connect to real-world events they can't
152:53 - connect to external systems they can't
152:55 - do external computation they're
152:57 - intentionally these deterministic
152:59 - systems these walled gardens so in order
153:02 - for us to make this connection we need a
153:04 - blockchain oracle we need some type of
153:07 - network here now just to get a little
153:09 - bit more technical for you if we look at
153:12 - a blockchain a blockchain can easily say
153:15 - one plus one
153:16 - equals two and every other node can
153:18 - easily verify this
153:20 - however a blockchain can't easily say
153:23 - okay let's all grab the same random
153:25 - number because each node is going to get
153:27 - a different random number they also
153:29 - can't say hey let's make an api call
153:32 - because if one node calls the api at a
153:35 - different time another node calls it or
153:37 - specifically an http get there could
153:40 - potentially get very very different
153:43 - results
153:44 - and if another node tries to replay
153:46 - these transactions by calling these apis
153:48 - again
153:49 - maybe 10 years in the future there's a
153:51 - good chance that that api is going to be
153:53 - depreciated
153:55 - and they could be hacked they could be
153:56 - malicious et cetera et cetera
153:59 - the other reason that blockchains
154:01 - intentionally can't make api calls is
154:03 - because then they would be making
154:05 - assumptions about the real world and
154:07 - layer ones typically don't want to have
154:09 - an opinion on any political or
154:11 - geopolitical issue whereas an oracle
154:13 - network on the other hand can make those
154:14 - assumptions the other main thing we need
154:16 - to talk about here is centralized
154:18 - oracles being main points of failures if
154:20 - you or i say hey i'm just going to be
154:22 - the oracle i'm going to be the one to
154:24 - put this data on chain we now have this
154:26 - massive centralized point of failure
154:29 - we've done all this work to make our
154:31 - decentralized computation decentralized
154:33 - and on chain but we ruin all the
154:35 - decentrality by having a single point of
154:37 - failure remember one of the whole
154:39 - purposes of blockchain is so that not a
154:41 - single entity can flip a switch and
154:43 - restrict our freedom to interact with a
154:46 - centralized oracle a single entity can
154:48 - flip a switch and restrict our freedom
154:51 - to interact with each other we also need
154:53 - to get data from many different
154:54 - decentralized sources or do any type of
154:57 - computation in a decentralized manner
155:01 - this is where chain link really shines
155:03 - chain link is a modular decentralized
155:06 - oracle infrastructure and oracle network
155:08 - that allows us to get data and do
155:10 - external computation in a highly civil
155:13 - resistant decentralized manner it can be
155:16 - as customizable as you want as you can
155:18 - run with one node or many nodes or do as
155:20 - many nodes as you like
155:23 - now currently one of the most popular
155:25 - features of chain link is their data
155:27 - feeds or their price feeds we can even
155:29 - go check them out
155:31 - over at data
155:34 - dot chain dot link
155:37 - we can see a number of different price
155:39 - feeds and the networks that are
155:41 - providing the prices for these specific
155:43 - pricing powers
155:44 - we can see here by looking at the ui
155:46 - there is a whole number of decentralized
155:49 - different oracles returning data for
155:51 - different price feeds this one for
155:53 - example is fusd and it's also exactly
155:56 - the price view that we're looking for
155:57 - having a decentralized network bring
156:00 - this data on chain and have it as a
156:02 - reference point of definitive truth
156:04 - allows users to all collaborate and use
156:07 - this common good and it will be cheaper
156:10 - more secure more efficient than anybody
156:12 - even running their own centralized
156:14 - oracle so these price feeds are
156:16 - incredibly powerful additionally they're
156:18 - being used by some of the top protocols
156:21 - in the defy system right now
156:23 - like synthetics which at the time of
156:25 - recording is securing around 2 billion
156:28 - sushi swap for leveraging trades set
156:31 - protocol commodity money ave for
156:33 - understanding the price of an underlying
156:36 - collateral now this is an example of an
156:38 - out of the box decentralized solution
156:40 - that's already been packaged in the
156:42 - decentralized manner for you to consume
156:44 - and for you to use this makes going to
156:46 - production a thousand times easier than
156:49 - building everything yourself
156:50 - however if you want to make api calls
156:53 - and build your own decentralized network
156:55 - you absolutely can with the chainlink
156:57 - api calls
156:59 - we're not going to go into that here
157:00 - because using the chainlink price feeds
157:02 - chainlink vrf keeper network and all
157:04 - these other pre-box decentralized
157:06 - services are going to make going live
157:08 - and going mainnet a lot easier you can
157:10 - always make a chain link http get call
157:12 - as well we're not going to go over this
157:14 - though because putting this into
157:16 - production is a little bit trickier and
157:17 - working with chainlink vrx if you ever
157:19 - want to try them out by themselves you
157:21 - can always head over to docs.chain.link
157:24 - and head over to get the latest price
157:26 - feed there's usually a remix button
157:28 - actually that we can click and it will
157:30 - kick us out to a remix edition with all
157:33 - the code already ready to go for us if
157:35 - we just hit this just right here this
157:37 - will include all of our code which we'll
157:38 - go into in a second
157:40 - but let's go ahead and compile it
157:42 - we're going to deploy it
157:44 - to a real network here
157:46 - this one looks like it's actually for
157:49 - covin so we're going to go ahead and
157:50 - switch to coven looks like i don't have
157:52 - any covent ethereum so we're going to
157:54 - grab
157:55 - a covent faucet we can usually find
157:57 - different faucets in the chain link
157:59 - documentation
158:00 - let's look up kovin here
158:03 - there is a coven faucet here
158:05 - it looks like in order for us to get
158:06 - some covent ethereum here we have to log
158:08 - in with github then we can add our
158:10 - address in here and get the ethereum in
158:12 - the interest of time i'm going to skip
158:13 - ahead for me doing that
158:16 - great it looks like i've got some covent
158:18 - test that now being able to switch
158:20 - between test nets is going to make you a
158:22 - lot more effective as an engineer as
158:24 - well because you're going to be able to
158:25 - understand how each network actually
158:26 - works so now we've compiled this
158:29 - let's deploy this
158:33 - again metamask is going to pop up
158:36 - and let's go ahead and click to get the
158:38 - latest price and we can see that this
158:40 - function does indeed return the latest
158:42 - price of ethereum
158:44 - now you might be asking
158:45 - why does this number look so big
158:47 - well remember how we talked about whey
158:49 - and gray and ether
158:51 - well the reason that those exist is
158:53 - because decimals don't work in solidity
158:55 - so we actually have to return a value
158:57 - that's multiplied by 10 to some number
159:00 - so this value is actually 2614
159:03 - times
159:05 - 10
159:06 - raised to the eighth now the next
159:07 - question you might ask is well why did
159:09 - we work with this on a test net why
159:11 - can't we do this on a local network and
159:13 - the answer to this is because there is a
159:14 - network of nodes looking at this test
159:17 - net and delivering data onto this test
159:19 - stem when you spin up a local network or
159:21 - do a simulated vm there are no nodes
159:24 - actually doing that we'll learn later
159:26 - how to actually mock these interactions
159:28 - and mock a chain link node returning
159:30 - data onto our blockchain but for now
159:32 - let's head back over to the contract
159:33 - that we're working on so we can learn
159:35 - how to implement this in any contract
159:38 - that we ever want to another contract
159:40 - called in this case called price feed
159:43 - has a function called latest round data
159:45 - which returns a lot of data it returns a
159:48 - round id which defines how many times
159:51 - this price feed has been updated it
159:53 - returns a price which is the actual
159:55 - conversion rate between the two assets
159:58 - it returns a started at which defines
160:00 - when this was last updated
160:02 - it returns a time stamp and it returns
160:05 - an answer in round don't worry about
160:07 - answered in round for now if you want to
160:09 - dive a little bit deeper into what these
160:11 - rounds mean and what answered in round
160:13 - means you can definitely check out the
160:14 - chain link documentation and some of the
160:16 - faqs to learn more now how do we
160:18 - implement this data feed into our fundme
160:21 - application well the first thing we're
160:22 - actually going to need to do is we're
160:24 - going to need to import the chain link
160:26 - code
160:26 - so we're going to do import
160:28 - at chain link
160:30 - contracts
160:33 - source
160:34 - v 0.6
160:37 - interfaces
160:39 - slash aggregator
160:42 - v3
160:44 - interface
160:45 - dot soul
160:48 - now let's talk about what this is
160:50 - actually doing
160:51 - oops looks like i spelt aggregator v3
160:53 - interface wrong
160:55 - all right great now it's actually
160:56 - compiling
160:57 - so let's talk about what imports
160:59 - actually do
161:00 - as we know an import will take whatever
161:03 - code you're importing and stick it at
161:05 - the top of your project so when we
161:07 - import from at chainlink contracts we're
161:10 - actually importing from the at chainlink
161:12 - contracts npm package
161:14 - we can look up at chain links contracts
161:19 - in npm
161:22 - and we can see and read more about this
161:24 - repository
161:27 - this links us back to the github which
161:29 - will tell us a little bit more about
161:30 - what's really going on if we follow that
161:32 - import path that we got from the
161:34 - documentation we'll end up on this file
161:36 - in front of me now we have what's called
161:38 - an interface you can see these contracts
161:41 - don't start with the contract keyword
161:43 - but they start with the interface
161:45 - keyword they have the exact same pragma
161:47 - solidity at the top but the main
161:49 - difference is that you can see that
161:51 - their functions aren't completed they
161:54 - just have the function name
161:56 - and its return type
161:58 - now just to be a little bit more
161:59 - explicit here i'm actually going to go
162:01 - ahead and delete this import statement
162:03 - on the top and replace it with that
162:05 - interface code from github just to show
162:07 - you exactly what's going on however if
162:09 - you've already typed that at import
162:10 - syntax feel free to leave it in there
162:12 - and just remember that it's going to be
162:14 - the exact same as me copy pasting the
162:17 - interface code in our code here solidity
162:19 - doesn't natively understand how to
162:22 - interact with another contract we have
162:24 - to tell solidity what functions can be
162:27 - called on another contract this is where
162:30 - interfaces are actually going to come in
162:32 - similar to structs what we can do with
162:33 - interfaces to find a new type so if we
162:36 - copy all this code
162:39 - from this section and place it at the
162:41 - top of our code here
162:43 - above where we're declaring a contract
162:46 - we can actually then
162:47 - interact with contracts that have these
162:50 - functions
162:51 - if we go ahead and even compile this we
162:53 - can see this does indeed compile
162:55 - correctly remember how we said before we
162:57 - talked a little bit about abis well
163:00 - interfaces actually compile down to
163:02 - what's called the abi or the application
163:04 - binary interface the application binary
163:07 - interface
163:08 - tells solidity what functions can be
163:11 - called on another contract
163:17 - we need solidity to know what functions
163:19 - it can use and what functions it can
163:21 - call other contracts with and if that
163:23 - was a little bit confusing just know any
163:26 - time you're going to interact with
163:28 - another contract in solidity or smart
163:30 - contract programming in general you're
163:32 - going to need that contracts abi we'll
163:34 - go into what these apis look like a
163:36 - little bit later anyways to simplify it
163:38 - interface compiles down to an api we
163:41 - always need an api to interact with the
163:42 - contract so how do we actually work with
163:44 - this contract here to interact with an
163:46 - interface contract it's going to work
163:48 - the exact same way is interacting with a
163:50 - struct or a variable let's define a new
163:52 - function called getversion and we're
163:55 - going to call this version function on
163:58 - this other contract
164:00 - so we'll start out doing function
164:03 - get version
164:05 - public
164:06 - remember it needs to be a view since
164:08 - we're just going to be reading this
164:10 - state and even in the interface it even
164:14 - defines it as a view returns
164:17 - so we'll even grab
164:19 - this whole bit right here
164:22 - view returns unit 256. now the exact
164:25 - same way we define variables and structs
164:28 - we define working with other contracts
164:30 - and interfaces so the first thing is we
164:33 - name the type which in this case is
164:35 - aggregator v3 interface
164:37 - then we'd name the visibility but since
164:40 - again we're inside of this contract
164:42 - we're going to skip it then let's give
164:44 - it a name
164:45 - we'll call it
164:46 - price feed since this aggregator v3
164:48 - interface is going to be giving us a
164:50 - price fee then we can do equals and this
164:53 - is where we're going to initialize the
164:54 - contract so how do we actually choose
164:56 - where to interact with this contract
164:58 - well we just type aggregator v3
165:01 - interface and then we put in here the
165:03 - address of where this contract is
165:05 - located in order to find
165:07 - where this fusd price feed contract is
165:10 - located on the rink b chain we can look
165:13 - at the ethereum price feeds chain link
165:15 - documentation
165:16 - it has a ton of different price feeds
165:19 - and even more not price related data
165:23 - let's scroll down to rink b
165:26 - because again
165:27 - on each different chain
165:29 - the contract address that has all this
165:31 - price feed information is going to be
165:33 - different
165:34 - let's scroll down and find fusd which is
165:37 - right here
165:39 - and we'll copy it
165:41 - and we'll paste it into here
165:44 - now what is this line saying
165:46 - it's saying that we have a contract that
165:49 - has
165:50 - these functions defined in the interface
165:53 - located at this address if that's true
165:56 - then we should be able to call
165:58 - price feed
165:59 - dot
166:00 - version
166:05 - and we should be able to return it
166:07 - whoops looks like we forgot to add
166:10 - those here
166:11 - and we need a semicolon here
166:13 - i hit ctrl s or command s compiled it
166:16 - looks like we're compiling successfully
166:18 - and we do need to deploy this on a test
166:21 - n
166:22 - remember this address here is located on
166:26 - an actual test tent it's located on an
166:28 - actual network it's not going to be
166:30 - located on our simulated chain here so
166:32 - we do need to deploy this to injected
166:34 - web 3. we do need to deploy our contract
166:37 - to rink b because the rink b chain has
166:39 - this address
166:41 - we'll learn later on how we actually can
166:43 - work with a simulated chain and work
166:45 - with these price feeds but that's much
166:47 - later in this course so let's go ahead
166:49 - and save
166:51 - we'll deploy
166:52 - make sure we're on injected web 3.
166:55 - now we can go ahead and hit deploy
166:57 - metamask is going to pop up per usual
167:00 - confirm
167:01 - we're going to get a transaction link to
167:04 - etherscan showing us our contract
167:08 - and once it actually is confirmed we can
167:10 - see we have our contract right here now
167:12 - we have our familiar functions with one
167:15 - additional function
167:16 - we have our fund button which is red
167:18 - because it's payable we have our address
167:21 - to amount funded mapping which is blue
167:23 - because it's a view
167:24 - and we also have this get version button
167:27 - that's also blue if we go ahead and
167:29 - click it we can see that the version of
167:32 - our aggregator v3 interface is version
167:34 - 3. this is the third version of the
167:37 - aggregator interfaces hence the name
167:40 - aggregator v3 interface so we just made
167:43 - a contract call to another contract from
167:46 - our contract using an interface this is
167:49 - why interfaces are so powerful because
167:52 - they're a minimalistic view into another
167:54 - contract so this is great we have a get
167:56 - version function but this still isn't
167:59 - the function that we want we want to
168:00 - call the get price function which if we
168:04 - look at our interface we can see there's
168:06 - a latest round data function that
168:08 - returns
168:09 - an answer this is the function that
168:11 - we're going to want to call on this
168:13 - contract so let's go ahead and make a
168:15 - function that calls that instead
168:17 - so we're going to do
168:19 - function
168:20 - get price
168:22 - public
168:23 - view
168:24 - returns
168:26 - uint 256.
168:29 - uh oh
168:30 - this latest round data function though
168:32 - returns
168:33 - five variables so how do we actually
168:35 - work with that well let's find out to
168:38 - work with this contract we're gonna do
168:39 - the exact same thing
168:41 - we're gonna do aggregator v3 interface
168:43 - because this is the type of the contract
168:46 - price feed
168:47 - equals
168:50 - aggregator v3 interface
168:52 - we'll do this same address in here
168:54 - because this is the fusd address
168:57 - then we'll do price feed
169:00 - dot
169:01 - latest round data
169:04 - now since this is going to return
169:06 - five different values
169:08 - we can actually have our contract also
169:11 - return these five different values
169:14 - we can copy paste like this
169:16 - and literally do
169:18 - this
169:19 - these five values equal price feed that
169:21 - latest round data
169:23 - and you can see
169:24 - that even compiles correctly let's
169:26 - adjust the formatting a little bit here
169:28 - so it looks a little bit nicer a tuple
169:30 - is a list of objects of potentially
169:32 - different types this is the syntax for
169:34 - getting a tuple we can define several
169:36 - variables inside one of these tuples
169:38 - although our compiler is going to give
169:40 - us some warnings it's saying unused
169:42 - local variable because we're not
169:43 - actually using these for anything we'll
169:45 - come back to this
169:47 - now we can go ahead and do return
169:49 - and we can pick one of these variables
169:51 - that we want to return answer is going
169:53 - to be the price so we're going to do
169:55 - return
169:56 - answer but uh-oh we're going to run into
169:58 - an error return type argument in 256 is
170:02 - not implicitly convertible to expected
170:04 - type answer is an int 256 and we want to
170:08 - return a uint 256 so how do we rectify
170:11 - this we can fix this by using what's
170:13 - called typecasting if we just return
170:15 - answer we're going to be returning the
170:17 - wrong type however integers and solidity
170:20 - are really easy to cast into each other
170:22 - so we can just do uint 256
170:25 - and wrap it around this answer
170:27 - and then compile and save that instead
170:30 - as you can see now our compiler is happy
170:33 - because we've changed this answer into a
170:36 - unit 256
170:38 - awesome so now this get price should
170:41 - return the latest price of ethereum in
170:43 - terms of usd let's go ahead and deploy
170:46 - this new contract with this new function
170:50 - so same thing we're going to come to our
170:52 - deploy section
170:53 - hit the deploy button up remember we got
170:56 - to go to the fundbean.sol
170:58 - let's deploy it
171:00 - confirm with metamask here
171:04 - and let's scroll down to our newly
171:05 - deployed contract
171:07 - as you can see we have our get version
171:09 - function which still works exactly the
171:11 - same but we have a new function too
171:14 - called get price and this should return
171:17 - a uint 256 answer let's go ahead and
171:19 - click it
171:20 - amazing we've actually returned an
171:22 - answer now again if you're a little
171:25 - confused on why this number looks so big
171:27 - you have to remember that this actually
171:29 - has eight decimals we could call this
171:32 - decimal's function on the contract to
171:34 - learn that one two three four five six
171:36 - seven eight and we know that the current
171:38 - price of ethereum in terms of usd
171:40 - is two thousand four hundred and
171:42 - eighty-two awesome so now that we have
171:44 - the price we can actually get the
171:45 - conversion rate but let's clean up this
171:47 - function a little bit before we go on up
171:49 - there as you can see one thing that the
171:51 - compiler is complaining about is we have
171:53 - a lot of unused local variables
171:56 - but latest round data returns
172:00 - five different variables
172:01 - so how do we actually return the five
172:03 - variables but make our compiler happy
172:06 - with us well we can actually just return
172:08 - blanks for each one of these sections
172:10 - with commas in between each other to say
172:12 - hey there is a variable here but we're
172:14 - not going to use it
172:16 - this will also make our code look a lot
172:18 - cleaner
172:20 - because now this function's a lot
172:22 - smaller
172:23 - we say
172:24 - something's here we're ignoring it
172:27 - in 256 answer we're going to use some
172:29 - things here ignore it something here
172:31 - ignore it and ignore this too and we can
172:34 - even test this out by compiling it
172:37 - deploying it
172:39 - checking on rank b
172:42 - scrolling down
172:44 - hitting this
172:45 - and hitting get price and you can see
172:47 - indeed it's the exact same as before
172:51 - awesome so now we're all done cleaning
172:52 - things up right not quite yet
172:55 - see the other thing that's really
172:56 - annoying here we have this massive chunk
172:58 - of code at the top
173:00 - that is probably a little redundant
173:02 - there's a good chance that a lot of our
173:04 - contracts are going to want to use this
173:06 - aggregator v3 interface so let's just go
173:08 - ahead and add that at chain link
173:10 - contract syntax back in because it's
173:12 - going to look a lot cleaner here and do
173:14 - at chain link
173:16 - contracts if you ever get a little bit
173:18 - confused with what you should be
173:19 - importing to work with their contracts
173:21 - we can see right in the documentation at
173:24 - the top this at syntax is what this is
173:27 - going to use
173:28 - now you can also go ahead and browse
173:30 - that npm package of at chainlink
173:32 - contracts see what other applications
173:34 - are in there and what other files are in
173:36 - there
173:37 - or you can just peruse around the github
173:39 - now the third way we can actually do
173:41 - imports is we can import from contracts
173:43 - that are in the same file system as our
173:46 - contracts well awesome our contract is
173:48 - starting to look more and more put
173:50 - together now one other thing that i
173:51 - usually like to do with these is i
173:53 - usually like to put everything into the
173:55 - gray
173:56 - way standard so as we saw
173:59 - this get price had eight decimal places
174:02 - however
174:04 - the smallest unit of measure aka whey
174:08 - if we look at it has 18. one two three
174:11 - four five six seven eight nine ten one
174:13 - two three four five six seven eight
174:16 - so typically in these i like to try to
174:19 - make everything have 18 decimals as well
174:21 - you don't have to do this and it'll save
174:23 - some gas if you don't but i usually like
174:26 - to multiply everything so that
174:27 - everything has 18 decimal places so
174:30 - since i know this has 8 i can just do 1
174:32 - 2 three four five six seven eight nine
174:34 - ten
174:35 - and now this will return
174:37 - the price with eighteen decimal places
174:40 - instead of ten now we have the price of
174:42 - ethereum in us dollar which is fantastic
174:45 - so we could set the price of our funding
174:48 - function to anything that we want here
174:51 - for example let's say 50
174:53 - we could convert whatever value that
174:55 - they send us to its us dollar equivalent
174:59 - and see if it's greater than or less
175:01 - than fifty dollars
175:03 - all we have to do is make a new function
175:07 - that converts that value that they send
175:10 - to its us dollar equivalent so we could
175:12 - do function
175:15 - get conver
175:16 - generate
175:18 - and it will take a u 256
175:20 - f amount let's get this out of the way
175:23 - for the rest of this
175:24 - it'll be a public view function since
175:27 - again we're not actually going to have
175:29 - it make any state change
175:31 - we'll do returns you want 256
175:35 - and then in this function
175:36 - we can do uint 256
175:38 - f price
175:40 - equals
175:41 - get price
175:43 - and we can call
175:44 - this get price function up here
175:47 - now we have the price in here
175:49 - what we want to do is we want to convert
175:51 - whatever value that they send
175:53 - as f amount let's say they send one way
175:57 - or again that's going to be this much
175:59 - way
176:02 - what how do we convert this
176:04 - to fusd
176:05 - well
176:06 - we can now do unit 256
176:09 - s
176:10 - amount
176:11 - in usd
176:13 - equals
176:14 - this f price
176:16 - times
176:19 - the f amount that they sent
176:21 - this is actually going to
176:24 - result in a much bigger number than
176:26 - we're looking for and then of course
176:27 - we're going to return it
176:29 - let's test this out and see why we have
176:32 - to do one more thing here
176:34 - so let's again
176:35 - fund me we'll deploy
176:37 - rank
176:38 - b we'll scroll down and we have this new
176:42 - function called get conversion rate
176:44 - let's grab this one gray and put it in
176:46 - here whoa
176:47 - this seems like it's a really big number
176:50 - we're saying that
176:52 - one gray
176:53 - is equal to one two three four five six
176:55 - seven eight one two three four five six
176:57 - seven eight nine ten
177:00 - this many dollars
177:02 - now i don't know about you but i don't
177:05 - think the price of even one ethereum is
177:07 - that many dollars maybe in the distant
177:09 - future but definitely not right now the
177:11 - reason that it's off is we have to then
177:13 - actually divide by
177:15 - this number the reason that we have to
177:16 - do this is because both f price and f
177:19 - amount
177:20 - have an additional
177:23 - 10 raised to the 18th tacked on to them
177:25 - so now we have to divide it out in order
177:27 - to get the right number
177:29 - so we're going to compile
177:31 - compile
177:33 - deploy
177:34 - confirm
177:37 - we can scroll down
177:39 - and now let's try this one way
177:41 - we'll get the conversion right here
177:43 - and we can see we get a number that
177:46 - makes a little bit more sense now
177:47 - remember this has 18 decimals as well so
177:50 - the real number is 1 2 3 4 5 6 7 8 1 2 3
177:55 - 4 5
177:56 - 6 7 8 9 10.
178:00 - and we know that this number is actually
178:02 - accurate because we can go ahead and
178:03 - pull up a calculator
178:05 - pop that into here
178:07 - and we know that this is one way in us
178:10 - dollar
178:11 - if we get the conversion rate
178:13 - we're saying that this many gray equals
178:16 - one each
178:17 - so we can check it back by multiplying
178:19 - this number by that and we see that we
178:21 - do actually get the price of one
178:24 - ethereum in us dollar
178:26 - so our math here checks out
178:29 - awesome now since we're on the topic of
178:31 - math i do want to talk briefly about
178:33 - some of the pitfalls of solidity
178:35 - especially when it comes to math prior
178:37 - to solidity 0.8 if you added to the
178:40 - maximum size a uint number could be it
178:43 - would actually wrap around to the lowest
178:46 - number that it would be and in fact you
178:48 - can even demo this with a contract here
178:50 - now you don't have to follow along with
178:51 - this contract but just watch to see the
178:53 - example we're going to call this
178:56 - overflow
178:57 - dot sol
178:59 - now in here we're going to add all kind
179:00 - of the normal stuff
179:02 - contract
179:03 - overflow
179:05 - and we're going to add a function
179:08 - called
179:09 - overflow we'll make a public
179:11 - view and we'll have it return a uint 8.
179:14 - i'll show you why in just a minute a
179:16 - union 256 is a really really big number
179:19 - and it's hard to kind of imagine going
179:21 - over the maximum cap of a u and 256
179:24 - but a uint 8 is a lot smaller with the
179:28 - maximum number actually being 255. so if
179:31 - we create a uint 8 and we call it
179:34 - big
179:35 - equals 255 and then we just do return
179:39 - big
179:40 - what do we think we're going to get here
179:42 - for this we can go ahead and use
179:43 - javascript vm because we're not
179:45 - interacting with any other contracts
179:48 - let's deploy this
179:50 - and we'll see in our contract if we call
179:51 - overflow now we're just going to get
179:54 - 255.
179:55 - however what happens if we add 1 to this
179:57 - number or try to add 1 to this number if
180:00 - we do it just like this solidity
180:01 - actually knows that there's an issue
180:03 - here and says hey
180:04 - try not to do this
180:06 - but if we typecast this as a uint eight
180:10 - solidity gets a little bit more confused
180:11 - and goes ahead and lets us do this
180:14 - now what do we think big is going to be
180:16 - it should be 256 right
180:19 - but big is the uint 8 and this is the
180:22 - maximum size that it could be so what
180:24 - happens when we deploy this
180:26 - we look down
180:27 - we actually get zero
180:30 - what happens if we do 100 and we deploy
180:33 - that
180:37 - we actually get 99
180:39 - and this is because integers can
180:41 - actually wrap around once you reach
180:43 - their maximum cap they basically reset
180:46 - this is something we need to watch out
180:48 - for when working with solidity if we're
180:50 - doing multiplication on really big
180:52 - numbers we can accidentally pass this
180:54 - cap luckily as a version 0.8 of solidity
180:58 - it actually checks for overflow and it
181:00 - defaults to check for overflow to
181:02 - increase readability of code even if
181:04 - that comes a slight increase of gas
181:07 - costs you can use this unchecked if you
181:09 - want to have it keep that wrapping
181:11 - functionality so just be aware if you're
181:14 - using a lower version than 0.8 you're
181:17 - going to have to do something to make up
181:19 - for this and we could write a whole
181:20 - bunch of code here basically to check
181:22 - all of our math
181:24 - or we could just import something called
181:26 - safe math from another package
181:29 - similar to how we imported chain link we
181:31 - can go ahead and
181:32 - import a package called
181:35 - safe math
181:36 - from a tool called open zeppelin
181:41 - now open zeppelin is an open source tool
181:43 - that allows us to use a lot of already
181:45 - pre-built contracts
181:47 - we can go ahead to the documentation and
181:49 - go to their utilities and see safe math
181:52 - and they even have a little sticker here
181:54 - saying safe math is no longer needed
181:56 - started with solidity 0.8 safe math is a
181:59 - tool and a way for us to avoid some of
182:00 - these problems with doing math and
182:02 - solidity now i'm not going to spend too
182:03 - much time on the contracts that actually
182:05 - fix this but we can actually import
182:07 - right from the chain link directory as
182:09 - well
182:10 - a solidity file called safe math chain
182:13 - link and what we can do is right after
182:15 - our contract
182:16 - we can do using
182:19 - safe math chain link
182:21 - for
182:23 - uint256
182:25 - and what this will do
182:26 - is it will use safe math chain link for
182:29 - all of our unit 256
182:31 - and safe math chain link doesn't allow
182:33 - for that overflow to occur libraries are
182:36 - really similar to contracts except that
182:38 - they're isolated code that can be run in
182:40 - a reusable context
182:46 - in this case we're attaching the safe
182:48 - math chain link library to uint256 so
182:52 - that these overflows are automatically
182:54 - checked for just keep in mind if you're
182:55 - using anything less than 0.8 you're
182:58 - going to want to use some type of safe
183:00 - math just to check for your overflows
183:02 - now this is for those of you who are
183:04 - familiar with safe math and integer
183:05 - overflows and underflows we are not
183:08 - going to be calling the functions that
183:09 - safe math provides us like div add mole
183:12 - you know all those functions simply
183:14 - because in 0.8 moving forward we no
183:16 - longer have to use those and we can just
183:17 - use our regular operators like plus and
183:19 - minus so this is great our contract is
183:21 - coming along really well we now have a
183:24 - way to get the conversion rate of
183:26 - whatever f is sent and turn it into us
183:29 - dollar
183:30 - now we can set a threshold in terms of
183:32 - us dollar but how do we guarantee that
183:36 - whatever amount that the users send when
183:38 - they call fund is going to be at least
183:40 - fifty dollars well first we might want
183:42 - to set a minimum value so we can do unit
183:45 - 256
183:46 - minimum usd
183:49 - equals
183:50 - let's say 50
183:52 - and again since we're using everything
183:54 - in way terms we want to then multiply
183:57 - this by 10
183:59 - raised to the 18th
184:01 - and just want to take a pause for a
184:02 - second because this line is actually
184:03 - wrong this should be raised to the 18th
184:06 - so this line should really look like
184:08 - this where it has the double star so
184:10 - apologies the rest of this has that
184:12 - single star but it should be the double
184:14 - star here if you do have the single star
184:16 - though the rest of the contract will
184:17 - still work fine so this will be the
184:19 - minimum value it'll be 50
184:22 - times 10
184:23 - raised to the 18th so that everything
184:25 - has 18 decimals now that we have a
184:27 - minimum amount how do we actually make
184:30 - sure that this minimum amount is met in
184:33 - the value that they send us well if
184:34 - you're familiar with if statements we
184:36 - could do something like if message.value
184:40 - is less than minimum usd
184:44 - then
184:45 - revert
184:48 - or
184:49 - we could do something a lot easier and
184:51 - better practice and much cleaner we do
184:53 - what's called a require statement when a
184:55 - function call reaches a require
184:57 - statement it'll check the truthiness of
185:00 - whatever require you've asked so in our
185:02 - case the converted rate of message.value
185:07 - needs to be greater than or equal to
185:10 - our minimum usd
185:12 - this line
185:13 - says that if the conversion rate of
185:16 - message on value to usd if they didn't
185:18 - send us enough ether
185:20 - then we are going to stop executing
185:23 - we're going to kick it out we're going
185:24 - to say hey this doesn't count and we're
185:26 - going to do what's called a revert we're
185:28 - going to revert the transaction this
185:30 - means that the user is going to get
185:31 - their money back as well as any unspent
185:33 - gas and this is highly recommended we
185:36 - can also then additionally add a
185:40 - revert error message something like
185:43 - you need to spend more eath
185:48 - so now let's try this out as we saw one
185:50 - way
185:51 - is going to be way less than fifty
185:53 - dollars so if we send one way along with
185:56 - this fund contract call it should kick
185:59 - out and say you need to spend more eth
186:02 - so let's actually try this let's go to
186:04 - the deploy tab
186:06 - we'll get rid of our overflow
186:08 - we use injected web 3 because again we
186:10 - are working with the chain link
186:11 - aggregated contracts that are on chain
186:13 - we're going to move to
186:15 - fund me
186:16 - and we're going to hit deploy
186:18 - metamath's going to pop up and we're
186:19 - going to hit confirm
186:22 - now if i try to hit fund
186:25 - let's see what happens we're getting a
186:27 - gas estimation
186:28 - failed since gas estimation error failed
186:31 - with the following message
186:34 - execution reverted you need to spend
186:36 - more eth
186:37 - so
186:38 - the contract isn't even letting us make
186:40 - the transaction we can go ahead and try
186:42 - to send the transaction but here's
186:44 - what's going to happen
186:45 - on ether scan
186:47 - once this goes through
186:51 - you can see that once this transaction
186:52 - finished we got this status fail with
186:55 - error you need to spend more eth we
186:58 - don't want to force these transactions
186:59 - to go through if we look at our metamask
187:01 - we can even see this failed bit here
187:04 - so whenever you see these gas estimation
187:06 - failed errors usually that means
187:08 - something reverted or you didn't do
187:10 - something that was required however if
187:12 - we go to value here and we spend a lot
187:15 - more
187:16 - let's say
187:17 - 0.1 ether
187:20 - which if we take out our calculator 2500
187:25 - times point one it's going to be 250
187:27 - dollars this should easily be well and
187:30 - beyond past our 50 threshold
187:33 - so let's add 0.1 ether remember we got
187:36 - 0.1 by adding it in the converter and
187:38 - grabbing the way again the way is the
187:41 - smallest denomination now if we change
187:43 - this to way and hit fund this should go
187:45 - through we're gonna hit fun now you'll
187:47 - see men and mass pops up because
187:49 - metamask goes oh yeah this transaction
187:52 - isn't going to revert and that's what we
187:54 - want so we can go ahead and hit confirm
187:57 - and now we'll finally have sent some
188:01 - funding to our contract
188:04 - now that this is confirmed we go ahead
188:07 - and grab our address here
188:09 - pop it into our address to amount and we
188:12 - can see that indeed our funding has gone
188:15 - through
188:16 - now we can be part of this crowdsourcing
188:19 - application with our minimum value which
188:21 - is fantastic awesome great job
188:25 - awesome so now we can fund this contract
188:28 - with a certain minimum usd value in this
188:31 - case it's going to be 50
188:33 - now you'll notice though that right now
188:35 - we don't do anything with this money so
188:37 - we're going to fund this contract
188:38 - however that's it and we don't have a
188:40 - function in here to actually withdraw
188:43 - the money so there's no way that even
188:45 - though we just sent this contract some
188:46 - money there's no way for us to get it
188:48 - back so how do we fix this well we can
188:50 - add a withdraw function in here so let's
188:53 - go ahead and add that
188:55 - function
188:57 - withdraw
188:58 - and this is also going to be a payable
189:00 - function because we're going to be
189:02 - transferring eth
189:04 - we'll make this public
189:06 - and we can do
189:08 - message
189:09 - dot sender dot transfer transfer is a
189:12 - function that we can call on any address
189:14 - to send eth from one address to another
189:18 - this transfer function sends some amount
189:21 - of ethereum to whoever it's being called
189:23 - on in this case we're transferring
189:25 - ethereum to message.sender so all we
189:27 - need to do now is define how much we
189:28 - want to send well we're going to send
189:30 - all the money that's been funded so to
189:32 - get all the money that's been funded in
189:34 - this contract
189:35 - we can do address
189:37 - this
189:39 - dot balance
189:41 - now there's a couple of special things
189:43 - going on with this line
189:45 - first we're saying address of this
189:48 - this is a key word in solidity whenever
189:50 - you refer to this you're talking about
189:53 - the contract that you're currently in
189:56 - and
189:57 - when we add address of this we're saying
189:59 - we want the address of the contract that
190:01 - we're currently in whenever you call an
190:03 - address and then the balance attribute
190:05 - you can see the balance in ether of a
190:08 - contract so with this line we're saying
190:10 - whoever called the withdraw function
190:12 - because whoever calls the function is
190:14 - going to be the message.sender
190:16 - transfer them
190:18 - all of our money so let's go ahead and
190:19 - try this let's deploy fundme
190:24 - and now let's fund this with a lot of
190:26 - ether so that we can see it we'll fund
190:29 - it with one whole ether
190:31 - so that we can see it go into the
190:33 - contract and get pulled out of the
190:35 - contract
190:36 - we'll hit the fun
190:38 - button and you'll see we're sending one
190:41 - whole ether into this contract
190:45 - now if we look at our balance it's gone
190:48 - down from 17 to 16. or if you're still
190:51 - at 18 it went down from 18. so let's try
190:53 - to get it back
190:54 - if we call this withdraw function now
190:57 - confirm
190:59 - once this transaction goes through we
191:01 - should get all of our ether back
191:05 - let's look at our metamask and boom
191:07 - indeed we have got all of our eth back
191:10 - however looking at this contract we can
191:13 - see that hmm well maybe we don't want
191:16 - anybody to be able to withdraw all the
191:17 - funds in this contract that seems like
191:19 - it might be a really bad idea maybe we
191:21 - only want the funding admin to be able
191:23 - to withdraw funds so how do we set this
191:25 - up in a way that only the contract owner
191:28 - can actually withdraw funds well we
191:30 - learned before
191:31 - that the require function can actually
191:34 - stop contracts from executing unless
191:36 - some certain parameters are met we can
191:38 - do the same thing here with require
191:41 - message.sender
191:43 - equals
191:45 - the owner
191:46 - but we don't have an owner to this
191:48 - contract yet so how do we get an owner
191:50 - to this contract the instant that we
191:52 - deploy it well we could have a function
191:56 - called create owner but what happens if
191:58 - somebody calls this function right after
192:00 - we deploy it
192:02 - well then we wouldn't be the owner
192:03 - anymore
192:04 - so we actually need a function to get
192:06 - called the instant we deploy this smart
192:08 - contract and that's actually exactly
192:10 - what the constructor does so typically
192:13 - at the top of your smart contracts
192:14 - you'll see a constructor
192:16 - and this is a function that gets called
192:18 - the instant your contract gets deployed
192:21 - you don't even need to do add function
192:23 - here we can literally just call it
192:27 - constructor
192:28 - because it's what constructs the smart
192:30 - contract so we'll make constructor
192:33 - public and whatever we add in here will
192:35 - be immediately executed whenever we
192:38 - deploy this contract so one thing that
192:40 - we could do
192:41 - is we could have an owner be set the
192:44 - instant we deploy the smart contract so
192:45 - in the top we could add address
192:49 - owner
192:50 - and in our constructor
192:52 - we could say owner equals message.sender
192:56 - because the sender of this message is
192:58 - going to be us it's going to be whoever
193:00 - deploys this smart contract we can even
193:02 - test this out in the javascript vm to be
193:05 - a little bit quicker because we're not
193:06 - actually going to be calling the fund
193:09 - or the getprice function for now oops
193:11 - let's also make this public so that we
193:13 - can interact and see this owner variable
193:15 - so now if we go to fund me we deploy
193:18 - this in the javascript vm we should be
193:20 - able to see who the owner of this
193:22 - contract is and it should be our address
193:25 - because this constructor function should
193:27 - have been immediately called the instant
193:29 - that we deployed the smart contract
193:31 - awesome we can see the owner of this
193:33 - smart contract is indeed our wallet
193:36 - because remember we're working with the
193:37 - javascript vm our wallet is these fake
193:39 - wallets that they kind of give us
193:41 - we can even try this with an injected
193:43 - web 3
193:44 - with deploying this
193:47 - and the owner
193:48 - should be this
193:49 - ox 757 etc address
193:54 - let's go ahead and look at fundme see
193:55 - the owner and we do indeed see the owner
193:58 - is us okay great
194:00 - now we have an owner
194:02 - we can go down to our withdraw function
194:04 - and use that same require
194:08 - so we can call
194:10 - acquire
194:13 - message.sender
194:14 - equals equals
194:16 - owner equals equals is the way that
194:19 - solidity understands true false we're
194:22 - saying that message.sender has to equal
194:24 - owner now let's go ahead and try this
194:26 - and we'll try with the javascript vm
194:28 - again for speed reasons
194:31 - let's deploy this funding
194:34 - and if we go down here
194:36 - we try to call the withdraw function and
194:38 - it looks like it is successful because
194:40 - currently
194:41 - this is the address that deployed the
194:43 - contract and it's also the address that
194:45 - is calling withdraw
194:46 - however
194:48 - if we switch to a different account
194:50 - and call withdraw you'll see
194:53 - that remix actually freaks out down here
194:55 - it says uh oh something wrong happened
194:58 - and this is essentially the require
195:00 - statement kicking out if you want to try
195:02 - it with injected web 3 as
195:04 - well can absolutely do that too and
195:07 - remember the way to switch accounts in
195:09 - metamask is to either create a count
195:11 - right here or just switch like this
195:14 - and then we'll connect with account two
195:18 - so if i try to withdraw
195:20 - from this
195:21 - second account
195:23 - that didn't call the contract and i hit
195:26 - withdraw now
195:27 - it's going to give us gas estimation
195:29 - failed because the required statement is
195:31 - going to kick out but again if we switch
195:34 - back to account 1
195:36 - and we call withdraw
195:37 - metamask is going to pop up and it's
195:39 - going to allow us to withdraw now
195:41 - obviously there's nothing in this
195:42 - contract right now so we're going to
195:44 - withdraw nothing but we can still call
195:46 - it it's going to do message.transfer
195:48 - 0.
195:50 - so this is great
195:51 - we can now require this withdraw
195:54 - function is only callable by the owner
195:57 - now what if we have a ton of contracts
195:59 - that want to use something like this
196:01 - they require the message.sender to be
196:03 - some owner or maybe it's more
196:05 - complicated than this is there an easier
196:07 - way to wrap our functions and some
196:09 - require or some other executable well
196:12 - this is where modifiers come in we can
196:14 - use a modifier to write in the
196:16 - definition of our function
196:18 - add some parameter that allows it to
196:20 - only be called by our admin contract
196:23 - modifiers are used to change the
196:25 - behavior of functions in a declarative
196:27 - way let's create our first modifier
196:30 - we'll call it modifier
196:33 - which is a keyword
196:35 - only owner
196:40 - and we'll add this require statement in
196:42 - here
196:43 - require message.sender equals owner
196:46 - then after this we just add an
196:48 - underscore and a semicolon
196:51 - what a modifier is going to do
196:53 - is it's going to say hey before you run
196:55 - this function do this require statement
196:58 - first and then wherever your underscore
197:00 - is in the modifier run the rest of the
197:02 - code
197:03 - so we could also do a modifier where the
197:05 - underscore is up here and then this is
197:07 - afterwards but but we want to run the
197:09 - require first
197:10 - so now what we can do
197:12 - is we can make this function withdraw
197:15 - payable
197:16 - only owner public
197:19 - and what's going to happen
197:21 - is before we do this transfer we're
197:23 - actually going to check
197:24 - this modifier we're actually going to
197:26 - run this require message.sender equals
197:28 - owner and then again where this
197:30 - underscore is that's where we'll add the
197:32 - rest of the function
197:34 - so again
197:35 - for speed reasons and since we're not
197:37 - actually going to be interacting with
197:39 - the chain link data contract we can go
197:41 - to javascript vm
197:42 - switch to funding
197:45 - deploy
197:48 - and we can call withdraw
197:50 - obviously we can call withdraw from our
197:52 - account but if we switch accounts and
197:54 - try to call withdraw
197:56 - we're going to get an error which is
197:58 - perfect because that means our modifier
198:00 - is working correctly
198:02 - awesome now we have a fantastically
198:03 - succinct fund me contract here
198:06 - the only thing that we're really missing
198:07 - is that when we withdraw from this
198:09 - contract we're actually not updating our
198:12 - balances of people who funded this
198:14 - so even after with we withdraw this is
198:17 - always going to be the same so we need
198:18 - to go through all the funders in this
198:20 - mapping and reset their balances to zero
198:23 - but how do we actually do that we can't
198:25 - actually loop through
198:27 - all the keys in a mapping when a mapping
198:29 - is initialized every single key is
198:32 - essentially initialized now we obviously
198:34 - can't go through every single possible
198:36 - key on the planet
198:38 - however what we can do is create another
198:39 - data structure an array something we're
198:42 - already familiar with so let's go ahead
198:43 - and create a new funders array that way
198:45 - we can loop through them and reset
198:48 - everyone's balance to zero we'll do an
198:50 - address array
198:51 - because it's going to be an array of all
198:53 - the funders addresses
198:55 - we'll make it public
198:57 - and we'll call it
198:58 - funders
199:00 - now when somebody funds a contract
199:03 - what we're going to do is we're going to
199:05 - do funders
199:06 - now whenever a funder funds this
199:07 - contract we can go ahead and push them
199:10 - onto our funders array
199:12 - so we can do funders
199:13 - dot push message dot sender
199:18 - now if somebody funds multiple times the
199:21 - funders array is going to be a little
199:22 - bit redundant but we're going to ignore
199:24 - that for now now that we have an array
199:26 - of funders when we withdraw everything
199:28 - we're going to want to reset this to 0.
199:31 - when we withdraw everything we want to
199:33 - reset everyone's balance in that mapping
199:35 - to 0. so we're going to do what's called
199:38 - a for loop a for loop is a way to loop
199:40 - through a range of numbers to do
199:42 - something so we're going to say
199:44 - 4
199:47 - you and 256
199:50 - funder index
199:52 - equals zero because we want to start
199:54 - with the zeroth index
199:58 - we're going to give it a max size to go
200:00 - to we're going to say the funder index
200:02 - has to be less
200:03 - than funders dot length
200:07 - dot length is how we get the length of
200:09 - our array
200:11 - and then we're going to say funders
200:13 - index
200:14 - plus plus this means that we have an
200:16 - index variable called funder index
200:19 - and it's going to start from zero
200:21 - this loop is going to finish whenever
200:23 - funder index is greater than the length
200:25 - of the funders
200:26 - every time we finish a loop we're going
200:28 - to add one to the funder index that's
200:30 - what that funder index plus plus does it
200:34 - adds one to the funder index and every
200:36 - time whatever code is in this for loop
200:38 - executes we're going to restart at the
200:40 - top and all we're going to do in here is
200:42 - we're going to grab
200:44 - the address of the funder
200:47 - from
200:48 - our funders array
200:51 - funders
200:53 - so the funder
200:55 - at the index in our funders array
200:58 - we're going to use this
201:00 - as the key in our mapping
201:03 - so we're going to take
201:05 - address to amount funded
201:08 - of funder
201:10 - and we're going to set it equal to zero
201:13 - so now our mapping is going to be all
201:14 - updated to people having xero funded in
201:17 - there
201:18 - we do have to do one more thing as well
201:20 - we have to reset our funder array as
201:22 - well
201:23 - now there's a couple ways to do this but
201:24 - a really easy way is just to
201:27 - set funders equal to a new array so we
201:30 - could do funders
201:32 - equals a new
201:34 - blank
201:35 - address array
201:39 - so all right it looks like we've got
201:41 - everything in here we need right away
201:43 - when we deploy this we are set as the
201:45 - owner
201:46 - we can allow anybody to fund whatever
201:48 - public good that we're doing
201:50 - and they have to fund it with the
201:52 - minimum usd value that we actually set
201:55 - whenever they fund we'll keep track of
201:57 - how much they're funding and who's been
201:59 - funding us we can get the price of the
202:02 - ethereum that they send in the terms of
202:04 - usd
202:05 - and we can convert it to check to see if
202:07 - they're sending us the right amount
202:10 - we have our only owner modifier so that
202:12 - we're the only ones who can withdraw
202:14 - from the contract and when we do
202:16 - withdraw everything from the contract we
202:18 - reset all the funders who have currently
202:20 - participated in our crowdsourcing
202:22 - application
202:23 - awesome let's see if everything works
202:26 - end to end
202:27 - so we're going to go to fundme
202:29 - we're going to deploy it
202:31 - we're going to confirm from metamask and
202:33 - remember if you're ever confused about
202:35 - what's going on or or something weird is
202:37 - happening in your transactions or your
202:39 - deployments you can always go into
202:42 - etherscan and read more about your
202:44 - transaction and what's going on
202:47 - now that our transaction has been
202:49 - deployed let's go ahead and just take
202:51 - inventory as what's going on
202:53 - we have our owner
202:56 - which is our address right here
202:58 - we have the aggregator v3 interface
203:01 - version which is version 3 which we can
203:03 - kind of ignore
203:04 - we have the price of ethereum in terms
203:07 - of usd
203:08 - with 18 decimals instead of 8. we have a
203:12 - function that allows us to get the
203:13 - conversion rate of any ethereum amount
203:15 - to its us dollar equivalent
203:18 - we have an array of funders which right
203:20 - now starts out as empty
203:22 - we have a mapping of addresses which
203:24 - also right now starts out as empty let's
203:27 - go ahead and try to fund this contract
203:30 - we'll use way just that we're always on
203:32 - the same page
203:33 - and we'll fund it with 0.1 away
203:37 - remember everything has 18 decimal
203:39 - places so if we want to do 0.1 we just
203:42 - do 17. so we can do one one two three
203:44 - four five six seven eight one two three
203:47 - four five six seven eight nine and
203:49 - that'll be 0.1 ethereum now we can go
203:52 - ahead and hit fund
203:54 - and we're going to send 0.1 eth to this
203:57 - contract
204:00 - great so if we look at the zeroth index
204:03 - of funders we can see that indeed
204:06 - we have funded this contract
204:08 - let's even have
204:10 - our second account fund this contract
204:13 - so all we got to do is switch
204:15 - to this contract in metamask
204:17 - we can go ahead
204:19 - and put point one eth back in here
204:22 - for value
204:24 - and hit fund
204:26 - now as you can see we're deploying this
204:28 - from account two
204:29 - let's go ahead and hit confirm
204:33 - funder at index zero is going to be our
204:35 - admin and the funder at index one is
204:38 - going to be our second account
204:41 - and if we go ahead
204:43 - and we add
204:45 - this funder in here we can see we've
204:47 - indeed sent point one ether with this
204:50 - account if we go back to our count one
204:53 - and put this in here
204:54 - we can see that that address also has
204:57 - 0.1 ether
204:58 - fantastic
205:00 - so let's try to be malicious let's try
205:02 - to have account number 2 actually
205:04 - withdraw all the funds in here
205:06 - let's hit this withdraw function
205:08 - uh-oh
205:09 - the transaction has failed we're
205:11 - relentlessly malicious we want to send
205:13 - this transaction regardless so even
205:15 - though i'm not the admin of this
205:17 - contract i've gone ahead and still tried
205:19 - to send those withdrawal so what happens
205:21 - now
205:23 - we can see that remix is saying hey
205:26 - something went wrong
205:27 - and again if we look at ether scan we
205:29 - can see that there is a fail here since
205:31 - in our modifier we didn't give a reason
205:33 - here
205:34 - nothing shows up but we could have
205:35 - always put a reason in there and
205:36 - something would show up
205:38 - so all right let's go ahead back to the
205:40 - actual admin
205:42 - and now let's try to withdraw everything
205:45 - so if we hit withdraw now
205:48 - we can go ahead and confirm what should
205:50 - happen is everything in here should be
205:52 - back to zero and this array should be
205:54 - back to zero as well and if we watch our
205:57 - address we can see it literally just
205:59 - went from point four to point six
206:01 - because it got point one from the
206:03 - original funding that this account put
206:05 - in
206:06 - and the 0.1 that our second account put
206:08 - in
206:09 - so now if we look at funder 0 we can see
206:12 - it actually errored because it is now a
206:14 - brand new array and there is nothing at
206:16 - index zero if we try to see how much
206:19 - this address now is funded it's back
206:21 - down to zero awesome you've now learned
206:24 - how to deploy a relatively simple yet
206:26 - effective crowdsourcing application
206:29 - where users can fund and an admin can
206:32 - withdraw those funds to go spend them on
206:34 - things
206:39 - now we've been working with remix so far
206:41 - to start our smart contract in our
206:43 - solidity development journey remix is an
206:45 - incredibly powerful what's known as a
206:47 - web ide or an integrated development
206:50 - environment and in my opinion remix
206:52 - should always be the starting ground for
206:54 - anybody looking to start their smart
206:55 - contract journey because it is a
206:57 - wonderfully friendly way to really show
206:59 - what's going on behind the scenes and
207:01 - it's really easy to see everything we're
207:03 - doing with ethereum with chain link and
207:05 - with our smart contracts now it does
207:06 - have some limitations though it's really
207:09 - hard to integrate other parts of
207:10 - different projects it has some limited
207:12 - support for testing or custom
207:14 - deployments it's a little tricky to save
207:17 - files locally you need an internet
207:19 - connection to actually interact with it
207:20 - and it doesn't have python so in order
207:23 - for us to deploy test and automate
207:26 - everything about our smart contract
207:27 - development cycle we want to connect our
207:29 - solidity and our smart contracts with a
207:31 - more traditional programming language
207:33 - like python this way we can customize
207:35 - our entire development environment in
207:37 - any way that we like we're first going
207:39 - to teach you all how to work with what's
207:41 - known as web3.pi which is an incredibly
207:43 - powerful python package for doing
207:46 - everything that we want to do with smart
207:48 - contracts then once we learn some of the
207:50 - basics of web3.pi then we'll move on to
207:53 - browning which is a smart contract
207:55 - development framework built on top of
207:57 - web3.pi which makes our lives even
208:00 - easier however it's still really
208:02 - important to learn web3.pi first because
208:04 - this will teach you what's going on
208:05 - behind the scenes of brownie
208:11 - now for the rest of this course i'm
208:12 - going to be working with visual studio
208:14 - code which is an incredibly powerful
208:17 - text editor that will give us a lot of
208:18 - formatting and a lot of really nice
208:20 - tools to work with deploying and
208:22 - interacting with our smart contracts if
208:24 - you've already got vs code and python
208:25 - and your entire coding setup set up the
208:27 - way that you like it feel free to use
208:28 - the timestamps in the description to
208:30 - skip ahead to the next section you'll
208:32 - often hear people referring to this as
208:34 - vs code or visual studio code but just
208:36 - to point out this is not what you're
208:38 - looking for right in front of you here
208:39 - visual studio is a different application
208:41 - make sure you're on visual studio code
208:44 - if you want to be a total hardo and just
208:46 - work with vim or emacs or whatever else
208:48 - you want to do you absolutely can but
208:50 - i'm going to go through setting up
208:51 - visual studio code the way that i like
208:54 - it and if you guys want to follow along
208:55 - i highly recommend it because it's going
208:57 - to make your life a lot easier there's a
208:58 - link to download visual studio code in
209:01 - the github repository basically all you
209:02 - have to do is come to the site right
209:04 - here and you can hit this big download
209:05 - button it should recognize what
209:07 - operating system that you're on be it
209:09 - windows be it mac or some other
209:11 - operating system and if it doesn't you
209:13 - can go ahead and hit this little drop
209:14 - down and pick one there so let's go
209:16 - ahead and download visual studio code
209:18 - and open it up
209:21 - awesome once you've downloaded visual
209:23 - studio code this is approximately what
209:25 - you should be seeing
209:26 - there's a fantastic getting started
209:29 - section here where if you're brand new
209:30 - to vs code and you want to learn a
209:32 - little bit more quickly you absolutely
209:34 - can and we have some links as well in
209:36 - our github repository giving you a crash
209:38 - course in vs code if you want to learn
209:40 - more let's set this up though so it's
209:42 - going to be really friendly for us to be
209:43 - doing our smart contract development
209:45 - here so first we want to go to this
209:46 - extensions tab it looks like these
209:48 - little blocks thing right here
209:51 - and first we're going to look up python
209:53 - and you want to install this python
209:55 - extension right here this is going to
209:57 - make our lives a lot easier for
209:59 - interacting with python and doing a lot
210:01 - of things with python
210:04 - then you're going to want to go ahead
210:05 - and download this and install this
210:07 - solidity extension this is going to make
210:09 - formatting our solidity a lot easier now
210:11 - we want to download python if you
210:13 - haven't already so go ahead to
210:15 - python.org
210:16 - let's go to downloads and it should
210:18 - recognize what operating system that
210:20 - you're on and you can just go ahead and
210:21 - hit the download button and then follow
210:23 - the steps to download this i've already
210:25 - got it download so i'm not going to walk
210:26 - through this
210:29 - okay great now that we have python
210:31 - installed one of the other amazing
210:32 - things about vs code is you can actually
210:34 - open a terminal up inside a visual
210:37 - studio code the way you can open your
210:38 - own terminal if this is your vs code
210:41 - you can go over on this top bar to
210:43 - terminal
210:44 - and select new terminal
210:46 - and you'll see something that looks like
210:48 - this
210:49 - it might be a bash it might be a zch it
210:52 - might be a powershell there's a lot of
210:53 - different types of terminals that you'll
210:55 - be able to see by looking right here we
210:57 - can now test to see if python is
210:59 - installed correctly if we type in python
211:02 - space
211:03 - dash dash
211:05 - version
211:06 - we should get something that looks like
211:07 - this the exact version of python doesn't
211:10 - really matter here but ideally you're at
211:12 - least on python 3.8 if python dash
211:15 - version doesn't work you can also try
211:17 - python
211:19 - 3-version now if neither one of those
211:22 - works we actually have a number of
211:24 - troubleshooting tips in the github
211:26 - repository for this course and
211:27 - oftentimes a quick google search on
211:29 - whatever error that you have you'll get
211:31 - a link which will lead you to the answer
211:33 - but if that google search doesn't lead
211:35 - to the answer then just go ahead and
211:37 - drop an issue or conversation associated
211:39 - with your issue on the github repo
211:41 - associated with this course in
211:42 - particular there are a couple of common
211:44 - errors that i've definitely seen a
211:46 - number of times so if you see an issue
211:48 - on your instance that matches something
211:49 - on the screen here definitely 100 be
211:51 - sure to check out those troubleshooting
211:53 - tips sometimes just installing some of
211:54 - these applications is really the hardest
211:56 - part of doing the entire coding journey
211:58 - here so please make sure you have python
212:00 - and vs code installed correctly before
212:02 - moving on and don't be discouraged if
212:03 - this doesn't work exactly the way that
212:05 - it should right away now if you're on a
212:06 - mac you can actually hit control back
212:08 - tick and it will toggle back and forth
212:10 - between having the terminal open and
212:12 - closing it i find this really helpful
212:14 - and i use it all the time instead of
212:16 - hitting
212:17 - the buttons a key tip for productivity
212:19 - is going to be using keyboard shortcuts
212:20 - instead of clicking around all the time
212:22 - you'll be much faster okay great we have
212:24 - python installed we have python and
212:26 - solidity extensions of visual studio
212:28 - code installed let's start working on a
212:31 - new project so in our terminal so in our
212:33 - terminal we can create some folder i've
212:35 - already created a demos folder here
212:38 - you can create one as well if you'd like
212:40 - by doing mkdir
212:42 - demos
212:43 - since i've already done it the file
212:44 - already already exists
212:46 - and then cd into demos
212:51 - you can type clear or if you're on a mac
212:54 - command k to clear the terminal now
212:56 - here's what we're going to be doing
212:58 - we're going to be working with
212:59 - simple storage again the exact same
213:01 - contracts but instead we're going to be
213:03 - using web3.pi
213:05 - so we're going to make a new directory
213:07 - inside of our demos folder slash
213:09 - directory called web3
213:12 - pi
213:13 - simple storage
213:15 - and we're going to cd
213:16 - into this new
213:19 - folder right here now again all the
213:21 - completed code is going to be in our
213:23 - github and there's going to be a link to
213:25 - everything that we do in this folder in
213:28 - this github so you can always refer to
213:30 - that if you get lost and the next thing
213:32 - that we want to do is we want to have
213:34 - our visual studio code know that we're
213:36 - in this folder so we can go ahead and
213:39 - click this files icon and hit open
213:42 - folder
213:45 - and i'm just going to go to this web 3
213:47 - pi simple storage and hit open and
213:49 - another vs code will actually pop up we
213:52 - can see on the left hand side here
213:54 - we have a folder this will show all the
213:56 - different files and folders in our web 3
213:59 - pi simple storage directory let's go
214:01 - ahead and create a file
214:04 - dot sol we can right click on this area
214:07 - and select new file and do
214:10 - simple
214:12 - storage
214:13 - dot soul and then we can go back to our
214:15 - simple storage dot soul in remix copy
214:18 - everything and then paste it into here
214:20 - if you don't have it up remember you can
214:21 - always refer back to the github
214:22 - repository which will have it in there
214:24 - for you awesome now we have our solidity
214:27 - in its own file called
214:29 - simplestorage.soul you'll notice that
214:31 - some of the words are actually
214:32 - highlighted different colors this is
214:34 - known as syntax highlighting and it's
214:36 - due to the fact that we added the
214:37 - solidity extension in it makes reading
214:39 - this code a lot easier now this file is
214:42 - in here we'll see that we have this
214:44 - little dot here
214:46 - whenever you see this little dot this
214:48 - means that your vs code file isn't saved
214:51 - so we want to always save it otherwise
214:53 - when we compile or we go to write a
214:55 - script things might not work correctly
214:57 - so we can save it by going up to file
215:00 - and then selecting save or again you're
215:02 - going to want to learn how to do the
215:03 - keyboard shortcuts because you're going
215:04 - to want to hit save often for mac it's
215:07 - command s and for windows it's ctrl s
215:10 - now the other thing that you'll see is
215:12 - you get this red line here this is vs
215:14 - code's way of telling us it thinks that
215:16 - there's an error at this position so
215:18 - this is really just the extension being
215:19 - a little bit confused here and we can
215:22 - safely ignore this and normally when i'm
215:23 - coding i do just ignore it we're often
215:25 - going to be flipping back and forth
215:27 - between compiler versions so oftentimes
215:30 - this isn't really a helpful warning here
215:31 - but if it is really bothersome you could
215:33 - right click it and do something like
215:35 - solidity change global compiler version
215:37 - or we can go to code
215:39 - preferences
215:41 - settings
215:42 - let's close this so we can see some more
215:43 - things in here we'll look up solidity
215:46 - and we'll come to this solidity
215:48 - extension config what we can do then is
215:51 - scroll down
215:52 - and we can see solidity compile using
215:54 - remote version this will allow us to
215:56 - choose what version we want to compile
215:58 - with if we do 0.6.0
216:01 - and hit save
216:03 - and go back to simple storage you'll see
216:06 - the red line is now gone while we have
216:07 - this up another really helpful piece
216:09 - that we can do here is we can add what's
216:12 - called a formatter so if we scroll down
216:14 - to solidity formatter you'll see that
216:16 - this enable slash disables the solidity
216:18 - formatter we can go from none to
216:21 - prettier then we'll also look up format
216:24 - on save and we want to make sure we have
216:27 - this editor format on save check marked
216:30 - what we can do then is we can come over
216:32 - to simplestorage.sol
216:34 - and
216:35 - maybe i've got some bad formatting in
216:36 - here we'll move over favorite number
216:38 - string name and put a whole bunch of new
216:41 - spaces in here or something
216:43 - now if i hit save it automatically
216:45 - reformats our file to look a lot nicer
216:48 - so to recap we want to turn on format on
216:51 - save and if you get issues with a red
216:52 - line under pragma solidity you can just
216:54 - change the compiler version in your
216:56 - settings here now while we're in here
216:58 - we're also going to go ahead and set up
217:00 - our python formatting as well
217:02 - so the first thing that we're going to
217:03 - do is we're going to install the black
217:06 - python formatter so we're going to open
217:07 - up our terminal here
217:09 - and whenever you install python it comes
217:12 - pre-installed with this package called
217:14 - pip to check to see if you have pip
217:16 - installed correctly run pip dash dash
217:18 - version
217:20 - now we can install the black formatter
217:22 - by running pip
217:24 - install
217:25 - black
217:27 - i already have it installed so it's
217:28 - going to be pretty quick for me
217:30 - then we'll come to our settings
217:33 - and we'll look up
217:34 - python
217:36 - formatting
217:38 - and we'll scroll down
217:42 - to python formatting provider you might
217:44 - have autopet bait or none in here you're
217:47 - going to want to change it to black
217:49 - this way whenever we save our python
217:51 - files now they will also get
217:53 - automatically formatted to be very
217:54 - readable and really nice and just to
217:56 - note for my demos in solidity i don't
217:59 - always have format on save for solidity
218:01 - i do have format on save for my python
218:03 - but i'm still going to highly recommend
218:05 - you have format on save for both your
218:06 - python and for your solidity anyways so
218:09 - how are we going to actually deploy this
218:11 - well this is where our python is going
218:13 - to come into play
218:15 - let's go ahead and create a new file on
218:17 - the left here
218:18 - and we'll call it
218:20 - deploy dot pi now let's go into this
218:23 - deploy.pi file and let's start actually
218:26 - figuring how we can deploy this in
218:28 - python and this is the part of the
218:30 - course where we start using python here
218:32 - if you're unfamiliar with python or a
218:34 - little bit weaker on python there is a
218:36 - fantastic free code camp course that
218:38 - goes through all the basics of python if
218:40 - you want to learn more i definitely
218:41 - recommend checking it out however we are
218:43 - going to walk you through all the
218:45 - scripts that we write anyways so don't
218:46 - be afraid to just jump in and follow
218:48 - along with what we're doing here even if
218:50 - you have no experience so the first
218:52 - thing that we're going to want to
218:52 - actually do is read this simple storage
218:55 - solidity file we need to get this into
218:58 - this deploy script so that our python
219:00 - file knows what it's going to deploy so
219:02 - how do we do this well we're going to
219:04 - type with
219:05 - open
219:08 - quote dot slash
219:11 - simple storage dot sol
219:14 - comma r
219:16 - as file
219:19 - simple
219:20 - storage file equals file dot read now
219:23 - what is this actually doing
219:26 - well it's saying that we're going to
219:28 - execute some code
219:29 - inside this indented area
219:32 - after the colon and then once this code
219:34 - is finished we're actually going to
219:36 - close this file because right now we're
219:37 - opening it we're going to close it once
219:39 - it's done
219:40 - the file that we're going to open is
219:42 - going to be this simple storage.sol
219:43 - which is located right here in this same
219:46 - directory that we're in we're going to
219:48 - only read from it and we're going to
219:50 - call it file and then we're going to
219:51 - read all the contents of this file and
219:53 - place it in a variable simple storage
219:55 - file
219:56 - so then we can go ahead and write a
219:58 - print statement print simple storage
220:00 - file and if you hit save here you'll see
220:01 - that it automatically gets formatted
220:03 - which is really nice if you want to run
220:05 - black yourself you can just type black
220:07 - dot and it'll automatically format all
220:10 - the python files in your folder here
220:12 - you'll know that you're doing it right
220:14 - if you add a whole bunch of new lines
220:16 - and then save it anyways enough on
220:18 - formatting let's head on down to the
220:20 - terminal and let's call python deploy.pi
220:25 - and we can see
220:26 - our terminal printed everything in
220:29 - simple storage file
220:31 - which is perfect now our python script
220:34 - has what it needs to actually get
220:35 - started working with our solidity now
220:38 - something you'll see i do a lot is i
220:40 - save a lot and if you're looking for
220:41 - some keyboard shortcuts you can always
220:43 - do command p add a little bracket here
220:46 - and look
220:47 - up keyboard shortcuts reference
220:50 - and click this
220:51 - it'll bring you to this keyboard's
220:53 - reference page based off of what
220:54 - operating system that you have all right
220:56 - great so now that we can actually read
220:58 - from our simple storage.soul file we
221:01 - actually have to compile it because
221:02 - remember back in remix every single time
221:05 - we did anything with our files we had to
221:07 - compile them first
221:09 - so we need some compiler in python
221:12 - luckily there is a fantastic python
221:13 - package called pi silk x that does
221:16 - exactly this now i also want to point
221:18 - out though that pi silk x is actually a
221:20 - fork of this package called pi silk now
221:23 - you can still use pysol however i'm
221:24 - going to highly highly recommend that
221:26 - you use pi silk x instead as pike sulk x
221:29 - is a lot more actively maintained than
221:31 - ethereum pixel we can install it with
221:33 - pip install pi sulk x we could even hit
221:36 - this little copy button move back on
221:38 - over here paste it in and hit enter
221:41 - again i've already installed it so it's
221:42 - pretty quick for me the way that we can
221:43 - use it now is by importing it into our
221:45 - python here so we'll say from
221:48 - sulk x
221:49 - import
221:51 - compile
221:53 - standard compile standard is going to be
221:54 - this main function that we actually use
221:56 - to compile this code so let's go ahead
221:58 - and compile
222:00 - our solidity
222:01 - we're going to save our compiled code to
222:03 - a variable called
222:05 - compiled soul
222:08 - this is going to be equal to
222:11 - us calling this compile standard
222:12 - function
222:13 - but we're going to add a lot of
222:15 - variables and a lot of parameters into
222:17 - this function here first we have to add
222:18 - is a language
222:21 - which in this case is
222:23 - solidity we're going to add in some
222:25 - sources
222:27 - which we're going to say our sources are
222:29 - going to be simple
222:32 - storage.soul
222:34 - and it's going to have some
222:36 - content which is equal to this simple
222:39 - storage file variable that we made
222:42 - oh excuse me this all has to be in a
222:45 - bracket piece as well
222:47 - and see if i hit save here it auto
222:49 - formats which is really nice and another
222:51 - quick tip you can see how even my
222:52 - brackets are highlighted in these fun
222:54 - colors if we go down to extensions and
222:56 - look up
222:58 - bracket
222:59 - you can add this bracket pair colorizer
223:01 - which will help make the brackets look a
223:03 - little bit nicer kind of as you see here
223:05 - you can go ahead and install that as
223:06 - well anyways then we'll add some
223:08 - settings
223:12 - and a lot of this is a little bit lower
223:13 - level stuff than what you're really
223:14 - going to have to know or use so i'm not
223:16 - going to go too deep into everything
223:18 - that's actually going on here for now
223:19 - but in our settings
223:20 - we're going to choose an output
223:22 - selection
223:25 - which is going to choose what we output
223:27 - when we compile this
223:29 - we do a little star here
223:35 - and in the star we're going to do
223:36 - another star
223:40 - we're going to choose our output list
223:41 - we're going to get an abi out that's
223:43 - incredibly important which we've talked
223:45 - about before
223:46 - we're going to get some metadata
223:48 - we're gonna get an evm dot byte code
223:51 - we're gonna get an evm dot
223:54 - source map
223:55 - that's pretty much it again i'm not
223:56 - gonna go too deep into what this output
223:58 - selection and what these settings are
224:00 - actually doing but if you want to learn
224:01 - more you can go to the home page of pi
224:03 - sulk x
224:04 - scroll down to the documentation section
224:07 - and read more in the docs on what you
224:08 - can actually put and all the different
224:10 - features that this actually has the last
224:11 - thing we're going to do is we're going
224:12 - to add a sulk version or solidity
224:14 - version we're going to say
224:16 - sulk
224:18 - version
224:20 - equals and then we'll choose the version
224:21 - that we want to use so we'll put in
224:23 - 0.6.0
224:26 - and then what we should be able to do is
224:28 - print out
224:29 - this compiled soul
224:32 - and we'll see just a whole bunch of
224:34 - really really low level stuff
224:36 - so let's go ahead and run this we'll run
224:38 - python
224:39 - deploy.pi
224:41 - and you'll see we get this
224:42 - massive object here which has a whole
224:45 - bunch of basically unreadable pieces but
224:47 - this is a lot of the low-level code that
224:49 - actually gets compiled whenever we use
224:51 - the compiler in remix or now in python
224:53 - remix actually does the exact same thing
224:56 - once we compile something on remix you
224:58 - can actually copy the bytecode if you
225:00 - hit this little
225:01 - copy button and copy the bytecode and
225:03 - come back to your vs code and create a
225:05 - new file a keyboard shortcut to create a
225:07 - new file is command n and we paste
225:10 - everything
225:11 - we can see there's a whole bunch of
225:12 - stuff in here these op codes are the low
225:15 - level code that our contract is actually
225:18 - doing that actually governs how this
225:20 - code works this is what our written code
225:21 - is getting compiled down to so solidity
225:24 - can actually read it and understand
225:25 - what's going on you'll also see this
225:26 - thing called abi which is in remix and
225:30 - we're even going to output it right here
225:32 - we have this abi thing now in remix if
225:34 - you hit copy the button on the api
225:37 - come back
225:38 - create new file paste it you can see we
225:40 - have this long json object this is that
225:43 - application binary interface that we've
225:45 - talked about so much you can see that
225:46 - it's actually describing all the
225:48 - functions and variables
225:50 - so for example
225:52 - we have a function
225:53 - called add person
225:55 - and it takes two parameters a name
225:58 - and a favorite number
225:59 - so we have this input section for the
226:01 - function and we have this section that
226:03 - describes what the function can is
226:05 - actually doing so the name is ad person
226:08 - it doesn't have a return type it's
226:10 - non-payable and it's a function and we
226:12 - can see that for pretty much everything
226:14 - in here this is the lowest digestible
226:16 - way to say hey here's where all the
226:18 - functions are here's what the parameter
226:20 - types are here's what the return types
226:22 - are going to be and everything like that
226:23 - so we're going to close it out for now
226:24 - though so this is fantastic we've now
226:27 - compiled our solidity typically i
226:29 - usually also like to output it and print
226:32 - it out to a file as well so to do that
226:35 - we'll do with
226:37 - open
226:39 - compiledcode.json
226:42 - and this time instead of reading we're
226:44 - going to write
226:45 - and we'll call this as file as well
226:48 - instead of doing file.write we're going
226:50 - to do what's called a json.dump
226:54 - compiled soul file
226:57 - we do need of course to import
227:00 - json also just a note i know it says
227:02 - we're using sulk here but please use
227:04 - sulk x still i ended up filming a little
227:06 - bit of both versions so i did a little
227:08 - bit of a mix and match but please use
227:10 - sulk x even if you see seoul what this
227:12 - line is going to do
227:13 - is it's going to take our compiled soul
227:15 - jason variable and just dump it into
227:18 - this file here
227:19 - but it's going to keep it in the json
227:21 - syntax so it's still going to be json e
227:24 - so now if we run python deploy.pi we'll
227:26 - see we have a new file in here called
227:28 - compilecode.json
227:30 - the other reason that i wanted to do
227:32 - this was because
227:33 - if i hit control s
227:35 - it actually formats this into a readable
227:38 - way now again we can go into these
227:40 - settings here
227:41 - we can look up
227:44 - json and we can do enable json formatter
227:48 - and this will automatically make it so
227:50 - that we format this json so it's a lot
227:51 - more readable again the reason i like to
227:54 - output this is because this abi is so
227:56 - important and we're going to use it so
227:57 - much that i like to kind of be able to
227:59 - see it and and read through it really
228:01 - quickly the rest of this lower level
228:03 - stuff like evm and byte codes and op
228:05 - codes we don't really work with so much
228:08 - however as you learn more and more about
228:09 - solidity you'll probably see more and
228:11 - more of opcode so if you really want to
228:13 - learn a lot of really low-level stuff
228:16 - look into opcodes but for the purpose of
228:17 - this tutorial we're not going to be
228:18 - going too deep into it okay awesome so
228:21 - we've compiled our solidity we've even
228:23 - stored our solidity code to this
228:26 - compiledcode.json file
228:28 - now what do we do we probably want to
228:30 - deploy it and test it out
228:32 - so how do we actually do that well first
228:34 - we actually have to get the bytecode we
228:36 - need the bytecode of the file so that we
228:38 - can actually deploy it so we're going to
228:39 - do
228:40 - bytecode
228:42 - equals
228:44 - compiled soul
228:47 - contracts
228:52 - simple storage dot sol
228:57 - simple storage
229:00 - evm
229:03 - white code
229:06 - object
229:08 - all right great there we go so now we
229:09 - have our byte code we also need to get
229:12 - our abi so we need to get the api so
229:15 - what we're doing here when we're typing
229:17 - in all these words like contract simple
229:19 - storage simple storage
229:21 - is we're walking down the json here so
229:23 - when we say we want to get the byte code
229:25 - in this compiled solidity json we want
229:27 - to go to contracts
229:29 - simple storage symbol storage evm byte
229:31 - code
229:32 - so contracts inside this contracts json
229:35 - you got to go to simple storage inside
229:37 - this simple storage dot soul there's
229:39 - another simple storage
229:41 - inside that there's an avi but that's
229:43 - not what we want we want the evm so
229:45 - we're going to scroll down
229:47 - we're going to get the evm then what do
229:49 - we want then we want the bytecode great
229:52 - and then we want the object so this
229:54 - is the bytecode of our contract
229:57 - it's the really low level stuff that
229:59 - the ethereum virtual machine or the evm
230:02 - is going to understand now we also need
230:04 - the avi when we deploy this to a chain
230:07 - this is what we're going to need we need
230:08 - the byte code and the abi the abi we can
230:12 - of course get from this kind of same
230:14 - method here so to get this we can do abi
230:18 - equals
230:19 - compiled soul
230:21 - same thing
230:22 - contracts
230:27 - simple storage dot soul
230:33 - simple storage
230:34 - and as you can see
230:35 - we're right here and then we can just
230:37 - grab this api object
230:40 - avi
230:41 - and we can even do print api we'll do
230:44 - python develop.pi
230:46 - and indeed our abi is printed here
230:49 - awesome so now that we have our two main
230:51 - pieces to deploy this now all we have to
230:52 - do is deploy it but the question then
230:54 - becomes is where are we going to deploy
230:56 - it to which blockchain are we going to
230:58 - deploy to in remix
231:00 - when we were first playing around
231:02 - we were using a javascript vm
231:05 - or a fake or a simulated environment we
231:08 - absolutely could and we absolutely will
231:10 - learn to deploy this to a test in
231:13 - because that's going to be the same way
231:14 - that we're going to deploy to a mainnet
231:16 - but before we do that we should learn
231:18 - how to deploy this on a simulated
231:20 - environment or something similar to that
231:22 - javascript vm so it's much faster and
231:24 - easier to test things and this is where
231:26 - ganache is going to come to the rescue
231:28 - ganache is a simulated or a fake
231:31 - blockchain that we can actually use to
231:33 - deploy our smart contracts to and have
231:35 - it interact like it's a real blockchain
231:37 - ganache is going to allow us to spin up
231:39 - our own local blockchain
231:45 - and it'll look something like this now
231:46 - the user interface is really nice
231:48 - because it allows us to kind of do this
231:50 - one-click blockchain to create our own
231:52 - local blockchain
231:54 - that means that this blockchain isn't
231:56 - connected to any other blockchain out
231:58 - there but it'll act like a blockchain
232:01 - but it'll be a lot faster than us having
232:03 - to interact with a testnet and we
232:05 - control the entire blockchain because
232:07 - it's only one node we're the only node
232:10 - so ganache great way to test things
232:11 - quickly now we're going to mainly we're
232:13 - working with the user
232:14 - but i'm also going to show you how to
232:15 - work with the ganache command line you
232:17 - can really use either one depending on
232:19 - what you want to do but a lot of the
232:20 - tools actually have built-in ganache
232:22 - command lines so it's definitely really
232:24 - useful to learn that as well so again
232:25 - ganache is going to be our simulated
232:27 - environment here so what we're going to
232:29 - do
232:29 - once we get into ganache we can just go
232:31 - ahead and hit quick start this will
232:34 - automatically upload and get started
232:36 - with our own local fake blockchain you
232:40 - can even see it gives us some accounts
232:42 - this should look pretty familiar it
232:44 - should look very meta-masky right we
232:46 - have an address here
232:48 - and each one of these addresses has a
232:50 - private key in your ganache you can go
232:52 - ahead and just click the key and hit
232:54 - show keys and it'll show you the account
232:56 - address and the private key but of
232:58 - course these are for development
233:00 - purposes only each one of these accounts
233:03 - has a balance associated with it we can
233:04 - see a mnemonic or your secret phrase you
233:07 - can see blocks transactions and a whole
233:10 - lot of other really useful features here
233:12 - and it even tells us
233:14 - how to connect to this blockchain
233:17 - and these are the connecting features
233:19 - that we're going to want to use let's
233:20 - learn how to connect to this ganache
233:22 - blockchain from this user interface
233:24 - first and then we'll learn how to do the
233:26 - command line version this is when we
233:28 - finally start working with web3.pi you
233:31 - can just do pip
233:33 - install
233:34 - web3
233:36 - and now we can start working with
233:38 - web3.pi right at the top a little
233:40 - confusingly
233:41 - we're going to do import
233:43 - web3
233:44 - from
233:45 - web3 whoops and this should be
233:48 - from web3 import web3 sorry about that
233:51 - now to connect to this blockchain we
233:53 - choose what's called an http provider if
233:56 - we look at this ganache instance we have
233:58 - this rpc server which has this url http
234:02 - 0.0.0
234:05 - this is the url that we're going to use
234:07 - to connect to this blockchain in remix
234:10 - we're actually using our metamasks
234:12 - directly to connect to the blockchain
234:14 - however we want to connect directly to
234:16 - our simulated our fake blockchain right
234:19 - here so what we're going to do is we're
234:21 - going to do
234:22 - w3
234:24 - for
234:25 - connecting to ganache
234:28 - w3 equals
234:30 - web3 web3.http
234:35 - provider
234:37 - of http
234:40 - 0.0.0.0
234:42 - and it was on port
234:44 - 845.
234:47 - port 845. now with everything that we
234:50 - show you you're probably going to want
234:51 - to get really familiar with the
234:52 - documentation because even after being a
234:54 - pro you're going to want to use it more
234:56 - and more if you want to learn more about
234:57 - other providers you can go to the
234:59 - providers page of the documentation the
235:01 - next thing that we're always going to
235:02 - need as well is we're going to need the
235:04 - chain id or the network id what is the
235:08 - id of this blockchain
235:10 - and for ganache it's one three three
235:12 - seven
235:13 - supposed to be a funny leat reference so
235:16 - we'll do chain id
235:20 - equals
235:22 - one three three seven
235:24 - now
235:27 - we're also going to need an address
235:30 - and address to deploy from
235:32 - we can go ahead and grab one of these
235:34 - fake addresses in here to work with
235:38 - similar to how in remix when we were
235:40 - working with the javascript vm we were
235:42 - given a bunch of fake addresses we're
235:44 - doing the same thing but with ganache
235:46 - and then we're also of course going to
235:48 - want a private key
235:50 - we need the private key of course to
235:51 - sign our transactions
235:54 - so we'll do private key equals
235:57 - this
235:59 - now just note whenever you import a
236:00 - private key in python you need to add an
236:03 - ox to the front python is always going
236:05 - to look for the hexadecimal version of
236:07 - the private key awesome now we have all
236:09 - the parameters that we need for
236:11 - interacting with and connecting to our
236:13 - ganache local chain it's time to finally
236:15 - deploy our simple storage.soul contract
236:18 - let's do it so the credit contract that
236:19 - we're going to deploy with web3.pi we're
236:21 - going to do simple storage
236:23 - we're going to call this variable
236:25 - w3
236:26 - dot f
236:28 - dot contract
236:30 - and we're going to give it abi equals
236:32 - abi
236:33 - and byte code equals byte code great
236:36 - does this mean we've deployed it well no
236:38 - this just means we have a contract down
236:41 - so we can do print simple storage and
236:43 - you'll see if we run python
236:45 - deploy.pi
236:48 - we'll see we have a new type here
236:50 - class web3.utils.datatype.contract
236:54 - this is another type that if you want to
236:56 - learn more you should definitely check
236:58 - out the web3.pi documentation so we have
237:00 - a contract object
237:02 - awesome how do we actually deploy this
237:05 - well we need to actually build our
237:07 - transaction
237:08 - because again whenever we interact with
237:10 - the blockchain whenever we make a state
237:12 - change and in this case we'd be
237:13 - deploying a contract we're going to make
237:15 - a state change so we first need to build
237:17 - a transaction sign a transaction
237:20 - and then send a transaction and to do
237:22 - that we need to talk about that nuns
237:24 - thing again remember way back in our
237:25 - blockchain demo when we used a nuns to
237:28 - solve the answer to that really
237:29 - difficult mining problem well the
237:31 - definition of nuns is just a word coined
237:34 - or used for just one occasion and in
237:36 - cryptography it's an arbitrary number
237:38 - that can be used just once in a
237:40 - cryptographic communication so this nuns
237:43 - that's used to find the answer is going
237:44 - to be different from another nuns that
237:46 - we're actually going to need to make our
237:48 - transaction see if we look at our meta
237:50 - mask and we look at our activity
237:52 - and we look at one of the transactions
237:54 - we've made recently on etherscan
237:56 - if we scroll down we'll see nuns
237:59 - here as well this nunce is the number of
238:01 - transactions that our account has
238:03 - actually made every time we make another
238:05 - transaction our transaction is hashed
238:07 - with a new nuns this is what's going on
238:09 - behind the scenes with our transaction
238:12 - and we need this to send our transaction
238:14 - we can actually get our nuns by just
238:16 - grabbing our latest transaction count
238:18 - get
238:19 - the latest
238:21 - transaction we can do
238:23 - nonce equals w3
238:26 - dot eth dot
238:28 - get transaction count and we'll put in
238:32 - my address
238:34 - this will give us the number of
238:35 - transactions and it'll effectively give
238:37 - us our nuns
238:39 - we can even test it out with a print
238:41 - python
238:42 - deploy
238:45 - we can see we can see that the answer is
238:47 - zero because on our local blockchain
238:50 - this address that we're using hasn't
238:51 - been used before we can even go to the
238:53 - transactions tab we can see that there
238:55 - are no transactions that have ever
238:57 - occurred on our local blockchain now to
238:59 - deploy this contract we need to make a
239:01 - transaction remember everything that we
239:03 - do every time we change the state of a
239:05 - blockchain we're going to do it in a
239:06 - transaction let's create a transaction
239:08 - object to do this we can do
239:11 - transaction
239:12 - equals
239:14 - symbol storage which again is this
239:16 - contract object
239:18 - dot
239:19 - constructor
239:22 - dot build transaction
239:24 - now as you might have pointed out our
239:26 - simple storage.sol doesn't actually have
239:28 - a constructor every contract technically
239:30 - has a constructor this one's is just
239:33 - blank we're not telling our simple
239:35 - storage.soul to do anything
239:37 - we saw back in our fund me
239:39 - example that the fund me example does
239:41 - have a constructor so now we want to put
239:43 - in some parameters for the transaction
239:45 - in web3.pi we always have to give at
239:47 - least a couple of parameters
239:49 - we always have to give the chain id
239:52 - which we already got from above which is
239:54 - one three three seven
239:56 - so we can just do chain id
239:59 - we need a from
240:00 - address in this case
240:03 - my address
240:08 - and then
240:09 - we need a nuns
240:11 - which in our case is just nuts
240:13 - great now we have a transaction object
240:16 - let's even print this out and see what
240:17 - it looks like
240:20 - whoa what's this we can see there's even
240:24 - more parameters in here than just what
240:25 - we made
240:27 - so we have value which is the ether or
240:30 - the ethereum that we're going to send we
240:31 - have gas we have our gas price which we
240:33 - could arbitrarily set if we'd like
240:36 - we have the chain id we have from
240:38 - address we have the nuns
240:40 - and then we have this giant data object
240:43 - and then two is just empty because it's
240:46 - sending it to the blockchain this giant
240:47 - data object here is encompassing
240:49 - everything that's happening in this
240:51 - simple storage dot sol now that's just a
240:53 - transaction and anybody could actually
240:55 - send this transaction as long as it's
240:57 - signed by them so we have this
240:58 - transaction but we need to sign it from
241:00 - somebody since we're sending it from our
241:02 - address
241:03 - our private key is going to be the only
241:05 - key that's going to work to sign this
241:07 - remember back when we were talking about
241:08 - public and private keys we right now
241:10 - have a message that is defining how to
241:12 - deploy simple storage but it's not
241:14 - signed yet so we're going to need to use
241:16 - our private key to sign it to create
241:19 - this unique message signature that we're
241:21 - the only ones that can create the
241:23 - private key but anybody else can verify
241:25 - that it was us who signed it so now
241:28 - signed
241:29 - transaction
241:30 - equals web3
241:33 - dot eth
241:34 - dot account
241:36 - dot sign transaction
241:39 - and the parameters it takes are going to
241:40 - be transaction
241:42 - and then private key
241:45 - we're gonna say the private key equals
241:47 - private key because above we've actually
241:49 - gone ahead and added our private key in
241:51 - here now guys a really really important
241:54 - note about putting a private key in your
241:56 - code this is really bad practice if you
241:58 - push this to source or you push this to
242:00 - github somebody else can see your
242:02 - private key and steal all your funds so
242:05 - we don't want to hard code our private
242:07 - keys in our code like we're doing here
242:09 - so let's take this time to talk about
242:10 - environment variables and how to set
242:12 - them environment variables are variables
242:14 - that you can set and that we set in our
242:16 - terminal and in our command lines the
242:19 - following is a way to set an environment
242:20 - variable in macos and linux only don't
242:23 - worry we'll show a way to make an
242:24 - environment variable in windows as well
242:26 - you can set an environment variable by
242:28 - running something like export
242:30 - private key
242:32 - equals
242:34 - and then adding whatever variable that
242:35 - you want
242:38 - now if you type echo
242:40 - dollar sign private key
242:43 - this variable actually shows up to set
242:45 - environment variables with windows the
242:47 - process that we're going to do is
242:48 - actually a little bit different
242:50 - i've left a link in our github to
242:52 - actually set environment variables in a
242:54 - windows setting
242:55 - and we've left a couple of really
242:57 - helpful links for working more with
242:58 - environment variables you should
242:59 - definitely check them out it's important
243:00 - to note that this export method that
243:02 - we're doing here for creating
243:04 - environment variables only works for the
243:06 - duration that our shell is live so if we
243:08 - were to close out of our shell and then
243:10 - reopen it our environment variable that
243:12 - we set would be gone so we'd have to
243:14 - re-run that export command we're gonna
243:16 - show you a way to set environment
243:17 - variables so that you don't have to keep
243:19 - doing that now it's also not great to
243:20 - have in plain text on your computer
243:22 - however it's a lot better than hard
243:24 - coding it into our script here now
243:26 - remember if you're using an account that
243:28 - has real money in it which i highly
243:29 - recommend you do not do don't send this
243:32 - environment variable or this private key
243:34 - or any of this code anywhere because
243:35 - then people can steal all your funds
243:37 - once we move to brownie we'll show you a
243:38 - more effective way for private key
243:40 - management but for now be cautious here
243:42 - but if you followed along and set up a
243:44 - brand new account that has no real money
243:45 - and only test that money in it then
243:47 - great who cares because it's test and
243:48 - it's fake money anyways
243:51 - i think i've talked about it enough
243:52 - anyways let's get back to it we can
243:53 - actually access this environment
243:55 - variable in python using os.get env
244:02 - we just need to import os
244:04 - and now we can access our private key in
244:08 - our script without actually hard coding
244:10 - it in
244:11 - let's see what happens if we do print
244:13 - private key python deploy to pi
244:16 - you can see our python script was able
244:18 - to pull our private key from our
244:19 - environment variable the other thing
244:21 - that we can do is create a dot env file
244:23 - a dot emv file is typically where people
244:26 - store environment variables it's
244:27 - important to not push these to source if
244:29 - this is what you're going to do in this
244:31 - dot envy file in python we can just do
244:34 - export
244:35 - private key and then same as what we did
244:37 - before
244:38 - add the 0x at the start and then private
244:40 - key so we could put 100 environment
244:42 - variables in here
244:44 - export
244:45 - some
244:46 - other var equals
244:48 - seven
244:50 - if you're going to do it in this way
244:52 - please please please
244:53 - always set a dot git ignore
244:57 - and make sure dot env is in here this
245:00 - will help make it harder for you to
245:02 - accidentally push your env folder or
245:04 - your emp file to github python actually
245:06 - has a way of loading directly from a env
245:09 - file without having to export our
245:11 - environment variables or run source.env
245:13 - or export or really anything and we can
245:15 - do it with this python.env package
245:19 - if we close our shell and then reopen it
245:21 - if we run echo
245:23 - some other var
245:26 - we're going to get none here and in fact
245:28 - if we run
245:30 - python develop.pi when we print this
245:32 - environment variable we're going to get
245:34 - none
245:35 - however we can use this.env to have it
245:38 - pulled directly from our.emv so we just
245:40 - do pip
245:42 - install
245:43 - python.env
245:45 - i've already downloaded it so it just
245:47 - says requirement already satisfied and
245:49 - then
245:50 - what we can do at the top of this we can
245:52 - do from
245:53 - dot env
245:55 - import
245:56 - load.enb and we can run
245:59 - a load.enb function right at the top
246:02 - this load.env looks for this.env file
246:05 - and automatically imports it into our
246:07 - script so if we run this now you'll see
246:09 - that the environment variable was
246:10 - successfully imported into our script
246:12 - and now we can use it so let's let's use
246:14 - it for example with our private key
246:16 - private key
246:17 - equals os that get
246:24 - private key now we can even print it out
246:29 - just a test
246:32 - we'll run our script
246:34 - and awesome
246:35 - we can see our private key is being
246:36 - successfully pulled in and we didn't
246:38 - hard code it into our application
246:40 - all right let's get back down to our
246:41 - signed transaction here now let's go
246:43 - ahead and print this out and take a look
246:44 - at what this looks like now we can run a
246:46 - script and great what we see here is an
246:49 - example of a signed transaction remember
246:52 - this is exactly what's happening when we
246:54 - were looking back at public private keys
246:56 - we are signing a transaction that is
246:58 - actually deploying a contract to the
247:01 - blockchain that anybody can easily
247:03 - verify all right so we finally have our
247:05 - signed transaction now we want to send
247:07 - this to the blockchain so it actually
247:08 - can deploy let's send
247:11 - the signed transaction
247:13 - we can do transaction hash
247:16 - equals
247:19 - web3.eth
247:22 - here's a little helpful tip if you see
247:23 - this little box underneath with
247:25 - suggestions show up and you just hit tab
247:27 - it'll auto complete the rest of your
247:29 - text here that's send raw transaction
247:33 - and we'll give it
247:34 - our sign transaction
247:36 - dot
247:38 - broad transaction this will send our
247:41 - transaction to the blockchain now if we
247:42 - look at our local ganache and we look at
247:44 - transactions right now it'll be empty
247:47 - but let's see what happens when we run
247:49 - this script
247:52 - okay so we didn't print anything out but
247:53 - if we go to our ganache we can see that
247:56 - a transaction actually did go through
247:58 - it was from the address that we put in
248:00 - here we created a contract at this
248:03 - address
248:06 - this is how much gas it used
248:08 - and this is how much value was sent with
248:10 - it we can even click on it to see more
248:12 - information about this now this is the
248:14 - other advantage of doing this locally is
248:16 - that the transaction automatically went
248:19 - through we've sent our first transaction
248:21 - to a local blockchain and this
248:24 - transaction is deploying a contract
248:26 - great work you can already see how much
248:28 - faster this is than working with a test
248:30 - net one other thing that's really good
248:32 - practice whenever sending a transaction
248:34 - is we wait for some block confirmations
248:36 - to happen
248:37 - so we can do
248:39 - transaction
248:41 - receipt
248:42 - equals web3 dot eth
248:45 - wait
248:46 - for transaction receipt
248:49 - txhash
248:50 - this will have our code stop and wait
248:52 - for this transaction hash to go through
248:54 - awesome so i just ran it again and if we
248:56 - go to transactions
248:58 - we can now see that there are two
248:59 - transactions here
249:01 - and our code waited a little bit longer
249:03 - for this one to complete so of course
249:05 - we've deployed a contract but how do we
249:07 - actually interact and work with the
249:08 - contract let's start doing that so when
249:10 - working with contracts and we're working
249:12 - with on chain whenever we work with a
249:14 - contract we always need two things
249:17 - we need the contract address and the
249:20 - contract abi often times if you're
249:22 - looking for a specific abi of a type of
249:24 - contract you can usually just google it
249:27 - so we need to make a new contract object
249:29 - to work with contracts let's go ahead
249:31 - and create this simple storage contract
249:33 - so we can actually interact with it
249:35 - so we'll do simple storage
249:38 - equals
249:41 - dot w3.eth.com now we need our address
249:45 - which we can get from ganache
249:48 - but that might be a little bit hard to
249:49 - always be checking the blockchain for a
249:51 - transaction
249:52 - it's actually also in this transaction
249:54 - receipt address
249:56 - equals transaction receipt dot contract
250:00 - address
250:01 - and then since we've compiled this we
250:04 - also have our abi already
250:08 - abi
250:09 - equals abi
250:11 - sometimes you'll see people have a file
250:14 - called
250:15 - abis.pi or abis.json or something like
250:18 - that and they'll load apis in directly
250:20 - from there and great now that we have
250:22 - the address and the api we can start
250:25 - interacting with this contract exactly
250:27 - as we did in remix so let's do a print
250:29 - statement to get that initial value that
250:31 - is returned from our retrieve function
250:36 - remember it should be initialized to
250:38 - zero
250:40 - so if we do print
250:42 - simple storage dot functions
250:45 - dot retrieve
250:50 - let's see what happens here
250:53 - huh what's this
250:55 - we get this function retrieve bound to
250:58 - in these parentheses here
251:00 - so what's going on when making
251:01 - transactions in the blockchain there's
251:03 - actually two different ways that we can
251:04 - interact with them we can interact with
251:07 - a call
251:09 - or we can interact with a transact when
251:11 - we use a call
251:13 - this is just to simulate
251:16 - making the call
251:19 - and getting a return value
251:22 - calls don't make a state change to the
251:24 - blockchain and it's similar to how in
251:26 - remix we would call these blue buttons
251:28 - and nothing on the blockchain would
251:30 - actually change we can actually also
251:32 - call these orange buttons or these
251:34 - non-view functions and just not actually
251:37 - make a state change remix defaults these
251:39 - blue buttons to be calls and these
251:41 - orange buttons to be transacts in python
251:44 - we can actually pick which one we want
251:46 - to do a transact a transact call is when
251:49 - we actually
251:50 - make a state change
251:54 - and this is when we actually have to
251:55 - build a transaction and send a
251:56 - transaction you can always just call a
251:59 - function no matter what that function is
252:01 - but just keep in mind you won't make a
252:03 - state change you can also always
252:05 - transact on a function even if it's just
252:07 - a view and this will attempt to make a
252:09 - state change
252:11 - something like retrieve even if we
252:13 - transact on it it won't make a state
252:14 - change so for something like retrieve
252:17 - where we don't actually want to make a
252:19 - state change
252:20 - we just use the call function so we'll
252:23 - just do dot call
252:25 - now
252:26 - if we try to run this
252:28 - you'll see we do get the zero because
252:30 - now we're actually calling this
252:31 - transaction awesome so now we have our
252:34 - initial value for our retrieve function
252:37 - let's keep going let's try to update
252:39 - this favorite number using this store
252:41 - function this we'll just keep in mind is
252:43 - our initial
252:46 - value of
252:47 - favorite number we know that this store
252:50 - function is orange and we'll actually
252:51 - make a transaction
252:53 - but if we wanted to we can even just use
252:55 - call on it
252:56 - we'll do simple storage
252:58 - dot functions
253:00 - that's store
253:02 - we'll put that 15 in here
253:04 - call
253:06 - let's see what happens when we send this
253:10 - you can see it returned a blank that's
253:12 - because this store
253:15 - function has no return type if we give
253:17 - this returns
253:19 - unit 256
253:22 - and then we say return
253:26 - favorite number
253:28 - and now we go back here
253:32 - and we run this again
253:34 - you'll see now that we get a 15 back if
253:37 - we go to ganache you'll see that we keep
253:39 - making a whole bunch of different
253:40 - contracts but none of these are contract
253:42 - interactions that's because when we call
253:44 - a function we just simulate working with
253:47 - it if we call retrieve again right
253:48 - afterwards you'll see that it's still
253:50 - zero
253:54 - it's because calling is just a
253:56 - simulation now let's delete all that so
253:58 - let's actually build a new transaction
254:00 - to actually store some value
254:03 - into this contract since we want to make
254:04 - a transaction we got to go through the
254:06 - same process as when we deployed this
254:08 - contract
254:11 - let's first create a transaction
254:14 - called store transaction
254:16 - equals
254:17 - simple storage
254:19 - dot
254:20 - functions
254:22 - about store
254:24 - and we'll give it some number in this
254:26 - case 15
254:27 - and then we have to do dot
254:30 - build transaction
254:32 - and we'll put those same pieces in here
254:34 - from before we're going to have
254:37 - chain id
254:39 - be the chain id
254:42 - we're going to need from
254:44 - give me my address
254:47 - nunce
254:48 - is going to be the nuns
254:52 - plus 1.
254:55 - we're going to need to do nuns plus 1
254:57 - because we actually use this nuns
254:59 - already
255:00 - when we create our initial transaction
255:03 - remember a nuns can only be used once
255:05 - for each transaction
255:07 - so this transaction is going to have to
255:09 - have a different nuance than the nuns we
255:11 - use to deploy the contract now that we
255:14 - have the transaction let's go ahead and
255:15 - sign it
255:16 - we'll do signed
255:19 - store
255:21 - tx
255:22 - and
255:23 - we'll do web3
255:25 - that eath
255:27 - dot account
255:29 - dot sign transaction
255:33 - store transaction
255:36 - and then private key equals
255:39 - private key and we'll go ahead and save
255:42 - then of course we need to send it so
255:44 - we'll do
255:46 - transaction hash
255:48 - equals w3.eth
255:51 - dot send raw transaction
255:55 - signed
255:56 - store transaction
255:58 - dot raw
256:00 - transaction
256:02 - and let's grab that transaction receipt
256:04 - again
256:04 - by doing transaction receipt
256:07 - equals w3
256:08 - dot eth
256:11 - dot wait for transaction receipt and
256:14 - actually let's call this
256:16 - send
256:18 - store
256:19 - tx
256:22 - that way for receipt
256:23 - send store tx awesome it looks like
256:26 - we're following the same steps here as
256:28 - we did above
256:31 - we created the transaction
256:33 - we signed the transaction
256:35 - and then we send the transaction
256:37 - down here
256:38 - we create a transaction
256:40 - we sign the transaction we sent the
256:42 - transaction and then we waited for the
256:44 - transaction to finish
256:47 - so let's run this
256:52 - all right great we still have this print
256:54 - function printing out the current value
256:56 - of retrieve let's go over to ganache and
256:58 - see if there's anything different here
257:00 - there is instead of all these contract
257:02 - creations here we now have a contract
257:04 - call
257:05 - we can see there's some transaction data
257:07 - that was sent
257:08 - a different amount of gas same gas
257:10 - prices
257:12 - however
257:13 - this
257:14 - actually updated and sent the
257:16 - transaction to our blockchain
257:19 - now if we call this retrieve function
257:21 - again
257:22 - this should print out our newly updated
257:25 - value which in this case was 15.
257:28 - let's go ahead and run
257:30 - python deployed up high
257:32 - and we can see it started at zero
257:34 - and then it turned to 15. awesome we've
257:37 - made our first state change to a
257:39 - contract that we've deployed on our
257:41 - local blockchain great work sometimes
257:43 - it's nice to put some lines in here to
257:45 - tell you what's going on to make it a
257:47 - little bit more clear so i'll put
257:48 - something like
257:50 - deploying
257:52 - contract dot dot
257:54 - right before we deploy our contract
257:57 - after we do it i might do
258:02 - deployed
258:07 - then
258:08 - right before we update our contract
258:10 - we'll print out something
258:13 - like updating contract
258:18 - and then right after it's done
258:20 - maybe something like
258:22 - updated
258:26 - now if we run this now
258:28 - you'll see as this goes along we'll get
258:31 - these things printed out saying
258:33 - deploying contract contract deployed
258:36 - updating contract updated this will make
258:38 - those moments when waiting for these
258:40 - contracts to actually finish a lot
258:41 - easier you're doing fantastic so ganache
258:44 - user interface is really nice because we
258:46 - can see a lot of things that are going
258:48 - on here however it's a little tricky to
258:50 - do a lot of programmatic stuff
258:51 - oftentimes engineer will use what's
258:53 - called a command line interface of
258:56 - ganache instead of the ui so we're going
258:58 - to go ahead and close this out and we're
259:00 - going to use the ganache cli instead of
259:02 - that user interface that we just saw and
259:04 - this is what and this is what brown is
259:06 - going to use on the back end when we
259:08 - move to brownie let's learn how to
259:09 - actually do that so in order to use the
259:11 - ganache cli or command line interface
259:13 - the first thing that we need to do is
259:14 - download node.js yes i know this is a
259:17 - python video however we do need to
259:19 - install node.js to work with the ganache
259:21 - cli you can come to this download page
259:23 - and choose your operating system and
259:26 - download it accordingly we will link to
259:28 - a video showing you how to do this in
259:29 - the github you'll know you've done it
259:31 - right if you can run node
259:33 - dash version in your command line and
259:35 - you get a version it might be 12 might
259:36 - be 14 might be something else depending
259:38 - on what version you downloaded next
259:40 - we're actually going to install yarn
259:42 - yarn is a package manager similar to pip
259:45 - and will allow us to actually download
259:48 - pieces and packages like the ganache cli
259:50 - from the package repository we can
259:52 - install it with npm install dash dash
259:55 - global yarn and you'll know you've done
259:57 - it right
259:58 - if you can run yarn
260:00 - dash dash version in your command line
260:02 - and you get the version outputted here
260:04 - then we want to install the actual
260:06 - ganache cli we're gonna be installing it
260:08 - with yarn so to install this we're gonna
260:10 - yarn global
260:13 - add
260:14 - ganache cli
260:18 - this will install our ganache cli as a
260:20 - global command in our terminal we can
260:22 - test to see if we've done it right if we
260:24 - can run
260:25 - ganache
260:26 - cli
260:28 - dash dash version perfect we now have
260:30 - the ganache cli let's spin up a ganache
260:32 - chain with the cli
260:34 - if you have your ganache ui open right
260:36 - now please close it otherwise it'll
260:38 - conflict so to run a local blockchain
260:41 - from the command line all you need to do
260:42 - is run
260:43 - ganache
260:45 - cli
260:48 - and the node will start running directly
260:50 - in your terminal
260:51 - if you scroll up you can see a lot of
260:53 - familiar pieces
260:55 - we see the available accounts just like
260:58 - on the ui
260:59 - these are the different addresses
261:01 - and then we see a whole bunch of
261:02 - different private keys this ganache
261:05 - spins up with a bunch of random
261:06 - addresses and random private keys if we
261:08 - wanted to always spin up with the exact
261:10 - same private keys so we don't have to
261:12 - update our private key every time
261:14 - we can do ganache
261:16 - cli
261:18 - dash dash
261:19 - deterministic
261:24 - this way we'll always get the exact same
261:26 - private keys
261:27 - and the exact same addresses you can
261:29 - check out the documentation to see a
261:30 - bunch of other flags that you can use to
261:32 - run this and you can see it's listening
261:34 - on 127.2
261:39 - 127.0.0.1 is also known as the loopback
261:42 - address or localhost now to work with
261:44 - ganache in the command line
261:46 - all we need to do now is update our
261:48 - private keys and our addresses let's
261:50 - also update the http provider since now
261:53 - we're going to be looking at the
261:54 - loopback address for my address
261:56 - we'll scroll up
261:58 - to this top address here
262:00 - and we'll place it in
262:02 - for our private key
262:04 - we're going to copy this
262:06 - and put it into our dot emv file
262:10 - it already has the ox at the top here
262:12 - great now let's open up a new terminal
262:14 - you can open up a new terminal by
262:16 - hitting this plus button here
262:18 - and you can flip back and forth by
262:20 - hitting this drop down and flipping back
262:23 - to the ganache terminal now let's go
262:25 - ahead and run
262:26 - python
262:27 - deploy.pi
262:29 - we can see
262:30 - the exact same output as we got when
262:32 - working with the ui and if we flip over
262:36 - to the command line we can see we've
262:38 - made a whole bunch of different calls to
262:40 - our blockchain each one of these calls
262:42 - is a specific json rpc call to our
262:44 - blockchain that we're making to interact
262:47 - with it we can see information about the
262:48 - transactions that we send this one
262:50 - creates our simple storage contract
262:53 - this one updates our simple storage
262:55 - contract and great you now know how to
262:57 - work with the ganache cli and the
262:58 - ganache ui fantastic so how do we
263:01 - actually deploy this to a test net or a
263:03 - real network we were working with remix
263:05 - all we had to do was switch to injected
263:08 - web 3 and we used our meta mask as our
263:10 - blockchain connection well in our script
263:12 - here we don't have metamask natively
263:14 - with our script so we need some way to
263:17 - connect to the blockchain we can see
263:20 - that when we're connecting to our own
263:22 - local blockchain we just use an rpc url
263:25 - that connects to our local blockchain to
263:27 - connect to a test net or to a mainnet we
263:29 - can actually do the exact same thing all
263:31 - we have to do is swap this out with the
263:33 - url that connects us to a mainnet or a
263:36 - test app we can also run our own
263:37 - blockchain node similar to how we're
263:39 - running our own local blockchain node we
263:42 - can run a node that actually connects to
263:43 - a real blockchain however it's not
263:45 - always practical or really easy to do
263:47 - this so sometimes we want to use an
263:50 - external or a third-party client that
263:52 - actually will run a blockchain for us
263:54 - let's learn a little about inferior
263:56 - inferior.io is an application that will
263:58 - give you a blockchain url for you to
264:00 - connect with for you to run whatever you
264:02 - want to run and you can get started for
264:04 - free let's go ahead and register
264:09 - then we just check our email
264:11 - confirm email address and awesome now
264:13 - we're inside of infira there's a couple
264:16 - other services out there that you can
264:17 - also check out like alchemy which is
264:19 - another fantastic blockchain as a
264:20 - service platform fura is a freemium
264:22 - service it starts out as free if you
264:23 - make too many api calls or too many
264:25 - calls to the url they'll start charging
264:28 - you
264:29 - but we can create a project for free for
264:31 - now let's go ahead
264:32 - hit the ethereum tab
264:34 - hit create project we'll call
264:36 - this free code camp
264:41 - brownie
264:42 - hit create now we'll have a whole bunch
264:44 - of project keys and project secrets we
264:48 - also have this endpoint section as well
264:50 - this is how we're going to be deploying
264:52 - to the different networks we can see we
264:54 - have an ethereum mainnet connection as
264:56 - well as robson coven rink b and gorilla
265:00 - testnets there's also polygon in here as
265:02 - well since we want to test and deploy to
265:04 - a ring b chain we can go ahead and move
265:06 - to ring b and then
265:08 - we can copy this url back in our
265:10 - application all we have to do is swap
265:13 - this out
265:14 - for the new url we also have to change
265:17 - the chain id
265:19 - our address and the private key if you
265:21 - ever are confused as to what is the
265:23 - chain id of the chain that you're
265:24 - working on you can always check this
265:25 - chain id dot network or you can usually
265:27 - ask somebody let's look up ring b we see
265:30 - the chain id is four so we'll grab four
265:32 - and we'll place that in our script now
265:34 - this address and the private key that we
265:36 - gave it now this address and the private
265:38 - key that we gave it aren't going to have
265:40 - any testnet ring be in them so we need
265:42 - to go in our metamask and grab the
265:44 - address place it in for address and then
265:47 - account details
265:49 - export private key
265:52 - type in our password
265:53 - and grab the private key go into our dot
265:55 - emb file
265:57 - leave the 0x and replace the rest with
265:59 - our private key since i have my private
266:01 - key stored as an environment variable i
266:03 - need to then run source.env so that my
266:06 - private key is now updated the reason
266:08 - we're using this is because again since
266:10 - we're making transactions to a testnet
266:12 - we need some test and eth alright so now
266:14 - we have everything updated for deploying
266:17 - to rinkeby let's go ahead and run this
266:19 - now
266:22 - as you can see it's going a lot slower
266:25 - this is because we actually have to wait
266:27 - for the contracts to get mined and for
266:29 - everything to happen
266:30 - on the test net deploying to a tesla
266:32 - will result in nearly the exact same
266:35 - experience that you'll get when
266:37 - deploying to an actual main net so it'll
266:39 - take a lot longer but you can see we got
266:41 - the exact same responses here now if we
266:44 - take this address
266:46 - and we go to the rink be ether scan
266:50 - we can verify what just happened
266:53 - we can see that 38 seconds ago
266:56 - we made this transaction
266:58 - and then 23 seconds ago we made this
267:01 - transaction
267:03 - we can look at all the different details
267:05 - of this transaction that we just made
267:07 - from our python script
267:08 - we can see it even tells us we created a
267:10 - smart contract
267:12 - and then
267:13 - we made this call
267:15 - which called this store function on this
267:17 - contract
267:18 - we've learned a lot so far this is
267:20 - fantastic now is a perfect time to take
267:23 - a break and take a quick breather and
267:25 - reflect back on what we've just learned
267:27 - we've learned a lot about python
267:28 - deploying to our own local blockchain
267:30 - deploying to a test net and deploying to
267:33 - a mainnet working more with private keys
267:36 - creating transactions
267:37 - signing transactions and then sending
267:39 - transactions
267:44 - now as you can see there's going to be a
267:45 - lot to actually managing all the
267:47 - contracts that we work with having to
267:48 - write our own compile code our own
267:50 - storage code is going to take a lot of
267:52 - work and what if we wanted to interact
267:54 - with one of the contracts that we
267:56 - deployed in the past well we'd have to
267:58 - keep track of all those addresses and
268:00 - manually update our address features
268:02 - here with an address maybe we didn't
268:04 - want to deploy a new contract every
268:06 - single time maybe we want to work with a
268:08 - contract that we've already deployed
268:09 - what if we want to work with a whole
268:11 - bunch of different chains what if we
268:13 - want to work with rink b and mainnet and
268:16 - our own local network there seems to be
268:18 - a lot to manage here and we still
268:19 - haven't even talked about writing tests
268:21 - this is where brownie is going to come
268:23 - into play brownie is currently the most
268:25 - popular smart contract development
268:27 - platform built based on python it's used
268:30 - by d5 giants like yearn.finance
268:33 - curve.phi and out each having billions
268:36 - of dollars currently locked in value and
268:38 - the reason that we learned a little bit
268:40 - about web3.pi first is because brownie
268:42 - heavily relies on web3.pi so let's do
268:45 - all this again but in brownie and we'll
268:47 - see how much easier it is to actually
268:49 - interact with in our shell
268:51 - let's go back one directory and let's
268:53 - make a new one we'll call it
268:56 - brownie
268:58 - simple
268:59 - storage
269:01 - now another really cool trick that vs
269:03 - code has is instead of us having to go
269:05 - to file and open up this folder in this
269:09 - explorer here
269:10 - what we can do is we can type code
269:12 - and then type the directory that we want
269:14 - to work with in our case
269:16 - this directory so we can just type code
269:18 - dot
269:19 - and we'll get a new vs code pop-up
269:22 - inside of this brownie simple storage
269:24 - folder let's get learning about brownie
269:26 - and this is where you're going to spend
269:28 - the majority of your time move forward
269:30 - brownie is incredibly powerful and makes
269:32 - our lives fantastically easier so get
269:34 - ready to learn one of the most powerful
269:36 - tools in the smart contract developing
269:38 - ecosystem let's go ahead and open up our
269:40 - terminal and let's get started
269:42 - installing brownie it's recommended to
269:43 - install brownie via pipex pepex installs
269:46 - brownie into a virtual environment and
269:48 - makes it available directly from the
269:50 - command line once installed you'll never
269:51 - have to activate a virtual environment
269:53 - prior to using browning which is really
269:55 - good to install it with pipex we can go
269:57 - ahead and run python dash m
270:01 - pip install dash dash user pipex
270:04 - once we've run that we can then run
270:07 - python3-m pick at pipex in surepath
270:11 - then we'll want to close the terminal by
270:13 - hitting the little trashcan and then
270:14 - reopen it and then we just need to run
270:17 - pipex install f brownie i've already got
270:20 - it installed so that's why we see this
270:21 - here and then just one more time we're
270:23 - going to close and reopen the terminal
270:26 - you can tell you have brownie installed
270:27 - correctly if you run brownie dash dash
270:30 - version
270:32 - and you get some output that looks
270:33 - something like this
270:36 - or you just run straight up brownie
270:39 - and it'll output a bunch of commands
270:40 - that we can run let's create our first
270:43 - brownie project
270:44 - we're going to be using the exact same
270:46 - simple storage code that we just went
270:48 - through except for we're going to use it
270:50 - in brownie this is going to make our
270:51 - lives a lot easier when working with
270:53 - simple storage to create a sample folder
270:55 - with everything we need with brownie we
270:57 - can just run brownie
270:59 - init
271:00 - and we will get a new brownie project
271:02 - initialized in the directory that we're
271:04 - currently in
271:05 - if you type ls you'll be able to see all
271:07 - the folders that are created or you can
271:09 - just see them on your side panel in vs
271:11 - code let's talk really quickly about
271:12 - what each of these folders is going to
271:14 - do the build folder tracks a lot of
271:16 - really important low-level information
271:19 - it's going to track any interfaces that
271:21 - we're working with or deploying it's
271:23 - going to keep track of all of our
271:24 - deployments across all of the different
271:26 - chains so we no longer have to manage
271:28 - that ourselves
271:30 - and it's going to store all the compiled
271:32 - code remember how in our simple storage
271:33 - code we actually saved everything to
271:35 - this compile code.json well brownie is
271:37 - actually going to do all of that for us
271:39 - into this contracts directory so we can
271:40 - always reference it later this contracts
271:43 - directory outside the build folder is
271:45 - where we're going to put all of our
271:46 - contracts brownie knows to look inside
271:48 - of this folder when looking for new
271:50 - contracts to compile deploy or anything
271:52 - else interfaces is where we can save and
271:54 - store different interfaces remember how
271:56 - when we were working with chain link
271:58 - working with interfaces makes it really
272:00 - easy to interact with a blockchain
272:02 - application reports are to save any type
272:04 - of report you run scripts or we can
272:07 - automate tasks like deploying calling
272:09 - different functions or really anything
272:10 - we want and then we have a test folder
272:12 - which is incredibly powerful and we're
272:14 - going to be using a lot we also have git
272:16 - attributes and get ignore which are
272:17 - helpful when working with version
272:19 - control like git so let's go ahead and
272:22 - start working with brownie and really
272:23 - understand what's going on here so let's
272:26 - go ahead and add our simple storage
272:28 - contracts to the contracts folder so in
272:30 - here we're just going to make a new file
272:32 - we'll call it simple
272:34 - storage.soul and i'm just going to copy
272:36 - and paste the code i have
272:38 - from the simple storage that we've been
272:40 - using this whole time let's go ahead and
272:42 - save that with command s okay great now
272:45 - that we have our contract in here we can
272:46 - already start working with brownie and
272:48 - even compile this code without even
272:50 - having to write or work with our own
272:51 - compiler all we need to do
272:54 - is run brownie
272:55 - compile
272:57 - brownie will automatically read the
272:58 - version of solidity and then store all
273:01 - of the compile information in this build
273:04 - folder so if we go to contracts we can
273:06 - see we have a simple storage.json and
273:09 - there's a lot of familiar pieces in here
273:11 - for example we see the abi opcodes
273:13 - section which is the low level language
273:16 - we'll see a pc map and we'll see a lot
273:18 - of useful information and great
273:20 - obviously deployments and interfaces are
273:21 - still empty so great we've already
273:23 - compiled our smart contract so why don't
273:25 - we actually deploy this to a blockchain
273:27 - to do this we do have to write a script
273:29 - which will allow us to do whatever we
273:31 - want so we're going to create a new file
273:33 - and we're just going to call this
273:34 - similar to last time deploy dot pi this
273:37 - is where we're going to define working
273:39 - with and deploying our code brownie can
273:41 - run scripts by running brownie run in
273:44 - fact if you want to take a quick minute
273:45 - to familiarize yourself with all the
273:47 - different commands that brownie has just
273:49 - run brownie and you'll see we can do a
273:50 - lot of different things we do brownie
273:53 - init which will create a new brownie
273:54 - project we will do brownie bake which
273:56 - allows us to pull from the brownie mix
273:58 - which we'll talk about later we can
274:00 - compile we can go into a console test
274:02 - run we do a lot of wonderful things in
274:04 - here if we do brownie run it'll run a
274:06 - script for us and we can define that we
274:08 - want to run this deploy all we have to
274:10 - do is add a def
274:12 - main
274:13 - so def in python is the way to define a
274:16 - function we're going to call this
274:17 - function main and for now let's just say
274:19 - print
274:21 - hello
274:22 - and we can run
274:23 - brownie
274:24 - run
274:25 - scripts deploy
274:28 - and as you can see it automatically does
274:31 - this launching thing
274:33 - so brownie defaults to always working
274:35 - with a local ganache cli blockchain it's
274:38 - running the exact same command that we
274:40 - ran earlier and it has a bunch of
274:41 - different flags like accounts 10 a
274:43 - certain hard fork a certain gas limit
274:45 - etc so at the beginning of all of our
274:47 - scripts if we don't give brownie a
274:50 - network to use it'll spin up a local
274:52 - ganache and at the end of the script
274:54 - it'll tear it back down typically what i
274:56 - like to do is actually put all the logic
274:58 - of our deployment in its own function
275:00 - def
275:01 - deploy
275:03 - simple storage
275:05 - and we'll do pass for now and then our
275:07 - main function we can just call
275:09 - deploy symbol storage now in order to
275:11 - deploy our contract let's look back at
275:13 - our web 3 pi version of deploying this
275:15 - and see what we did so first we compiled
275:18 - it great brownie does that automatically
275:20 - then we jumped into a file great brian
275:23 - does that automatically
275:25 - we got a byte code and an abi
275:28 - great brand does that automatically we
275:30 - added a local blockchain to use great
275:32 - brownie automatically spins up a local
275:34 - ganache we'll learn how to do test nets
275:37 - in a little bit aha we do need an
275:39 - address though and a private key so how
275:41 - do we actually get our private key get
275:43 - our account into brownie brownie has an
275:45 - account package that actually natively
275:47 - understands how to work with accounts
275:49 - and we can import it into our script
275:51 - here so we can do from
275:53 - brownie import accounts
275:57 - and with this accounts keyword
275:59 - we can add an account a number of
276:01 - different ways if we're going to work
276:03 - with our local chain as you see here the
276:06 - ganache cli will spin up 10 fake
276:09 - accounts for us and brownie
276:11 - automatically knows that we can work
276:12 - with that account so we can do something
276:14 - like account equals account zero and
276:17 - then just do something like print
276:20 - account so we're going to take the
276:21 - account that's spun up at the zerowith
276:24 - index because this accounts object is
276:26 - just an array so if we run this now
276:29 - brownie
276:30 - runs scripts
276:32 - deploy
276:33 - it's going to spin up us an address and
276:36 - a private key that we can just work with
276:38 - without having to define a private key
276:40 - or do anything it does all of that for
276:42 - us which is fantastic we do of course
276:44 - still want to know how to add our own
276:46 - private keys so that we can work with
276:48 - the test net so this is great and works
276:50 - when we're working with a development
276:51 - network or working with brownie's
276:53 - automatic ganache cli if we want to work
276:55 - with a test net though we have to do
276:57 - something else another way to add your
276:59 - accounts in brownie is to use the
277:01 - command line and actually add them
277:03 - natively into brownie we can do brownie
277:05 - accounts
277:07 - new and we'll give it a name free code
277:10 - camp account
277:13 - this will then prompt us and say enter
277:15 - the private key that you wish to add
277:17 - let's go ahead and grab our private key
277:19 - from metamask account details export
277:21 - private key
277:23 - put your password in
277:24 - grab the private key and then we just
277:26 - add ox and paste it in
277:29 - brownie will actually password encrypt
277:32 - your private key in this way
277:34 - so we'll give it a password and now we
277:36 - have a new account natively integrated
277:39 - into brownie to see it we can do brownie
277:43 - accounts list and you'll see that we
277:45 - have a free code camp account with this
277:47 - address and also a testing account i
277:50 - made this a little bit earlier we can
277:51 - get rid of it
277:52 - by running brownie
277:54 - accounts delete
277:57 - testing helpful terminal tip time so if
278:00 - you hit up or down on your keyboard you
278:02 - can actually toggle through the history
278:04 - of the commands that you've written so
278:06 - if you hit up it'll actually bring you
278:08 - to the most recently run command which
278:10 - can allow you to run previous commands a
278:12 - little bit faster and if we run browning
278:13 - accounts list again
278:15 - we'll see it's now just free code camp
278:17 - if we want to work with this free
278:18 - codecamp account that we've added to
278:21 - brownie via the command line
278:23 - we can get it with account
278:25 - equals accounts dot load
278:29 - free code camp account
278:31 - and then we can do print account let's
278:33 - run this script again
278:36 - this time when we on the script it's
278:37 - going to ask us for the password we need
278:40 - to enter the password to decrypt the
278:42 - account because right now it's password
278:44 - encrypted so we're going to type in the
278:46 - password and it's going to go ahead and
278:48 - execute with our unlocked private key we
278:50 - can see the address it printed out was
278:52 - right here
278:53 - and if we copy the address and we go
278:56 - back we can see that that is correct
278:58 - now if we're going to talk about safety
279:00 - and you want to safely secure your keys
279:02 - this is one of the safer ways to do it
279:04 - because it's not going to store it in
279:05 - git
279:06 - you're not going to accidentally push it
279:08 - up to github or show it to anybody and
279:10 - it's going to be password encrypted this
279:12 - is going to be one of the ways that i
279:13 - highly recommend you store your keys
279:15 - oftentimes you're going to want to do a
279:16 - mix of working with the local ganache
279:18 - ones and your own keys and we'll learn
279:21 - how to flip back and forth between them
279:23 - in a little bit now the third way that i
279:24 - like to use is still again using an
279:26 - environment variable script oftentimes
279:28 - it's really easy just to have your
279:30 - private key be an environment variable
279:32 - this way you won't have to keep putting
279:33 - the password in every single time you
279:35 - run a script so it's a little bit less
279:36 - secure and just another tip for myself i
279:38 - never put my private keys associated
279:40 - with wallets that have real money in
279:42 - them as environment variables or in a
279:44 - env file just in case i accidentally do
279:47 - something really stupid i don't trust
279:49 - myself enough so i'm gonna highly
279:50 - recommend that whatever private key that
279:52 - you use and you store it as an
279:53 - environment variable here always have it
279:54 - be just kind of a test account that
279:56 - you're gonna use to test things and then
279:57 - for some of your more serious accounts
279:59 - that's what you'll use the encryption
280:00 - for so let's go ahead and create an
280:02 - environment variable file
280:03 - so we'll do a new file call it env
280:06 - and we'll do export
280:08 - private key
280:10 - ox this
280:11 - now we have a private key set as an
280:13 - environment barrel so brownie has an
280:15 - additional feature that allows us to
280:17 - easily work with environment variables
280:19 - in an environment variable folder we can
280:21 - tell brownie to always pull from our env
280:24 - file in a brownie config
280:28 - yaml
280:30 - this is a special file that brownie
280:32 - always looks for to grab information
280:34 - about where you're going to build where
280:36 - you're going to deploy and where you're
280:37 - going to grab things in this config all
280:39 - we need to do is add env
280:43 - and set dot env this is telling brownie
280:46 - hey when you run scripts grab the
280:48 - environment variables from the dot env
280:50 - file and what we can do is after we
280:53 - import os we'll do account equals
280:55 - accounts dot add os dot get env this is
280:58 - how we get that environment variable a
281:00 - private key then let's just print out
281:02 - that account see if we did it right
281:04 - brownie run
281:06 - scripts deploy.pi
281:10 - and great
281:14 - all right great so this seems to work
281:16 - perfectly but i like to make this method
281:18 - even more explicit so we're going to
281:19 - take this version that we just learned
281:21 - and improve it in our brownie config we
281:23 - can actually add more information about
281:25 - what wallets we want to use and when we
281:27 - want to use them
281:29 - what we can do
281:30 - is we can add a wallets section
281:33 - and add in here a from
281:36 - key section
281:37 - and then add that environment variable
281:39 - private key in your yaml file if you
281:42 - surround a string with dollar sign and
281:45 - some curly brackets it will
281:47 - automatically get transformed into the
281:49 - environment variable so if we go back to
281:51 - deploy we can actually change this we
281:54 - can grab right from our config file so
281:56 - we'll do from brownie import accounts
281:59 - config
282:01 - instead of using os
282:04 - we can do accounts
282:05 - dot add
282:07 - config
282:08 - and then we'll do wallets
282:10 - since that's what we're defining right
282:12 - here
282:13 - and then from key
282:14 - wallets
282:18 - from
282:19 - key
282:20 - and this will do the exact same thing as
282:22 - our os dot get emv
282:24 - the reason that this is better is
282:26 - because now we have one canonical place
282:29 - where we're always going to pull our
282:31 - private key from instead of having to go
282:33 - through all of our scripts and update it
282:35 - based on whatever we change an
282:36 - environment variable now let's try this
282:38 - out
282:39 - brownie run
282:40 - scripts deploy
282:44 - and great we see our address printed
282:47 - here
282:48 - for now let's just stick with using
282:50 - accounts zero since we want to just use
282:52 - the account that brownie makes for us
282:54 - with ganache now brownie is really
282:56 - intelligent and we can actually go ahead
282:59 - and import
283:00 - a contract directly into our script and
283:02 - a web3.pi version we opened a contract
283:05 - and read from it and that's how we were
283:06 - able to interact with it after we
283:08 - deployed it in brownie what we can do is
283:11 - from brownie
283:12 - import
283:14 - and then just the name
283:16 - of the contract simple storage then
283:20 - we can do simple storage
283:22 - dot deploy and this is how we're going
283:24 - to deploy it to a chain anytime you
283:26 - deploy to a chain or you make a
283:28 - transaction you always need to do a from
283:31 - and then say who you're going to be
283:32 - deploying from what's the account that's
283:34 - going to be deploying this as you can
283:36 - see
283:37 - this step of just deploying is
283:40 - much quicker
283:41 - than what we did in web3.pi in web3.pi
283:45 - we had to
283:46 - get the byte code and the abi then we
283:48 - had to get the nuns
283:50 - we had to create the contract we had to
283:52 - create the transaction
283:53 - sign the transaction and then send the
283:56 - transaction remember how i said before
283:58 - you could either make a transaction
284:01 - or a call brownie is smart enough to
284:03 - know whether or not what you're doing is
284:05 - going to be a transaction or a call
284:07 - in this case since we're deploying a
284:08 - smart contract brownie's smart enough to
284:10 - know that ah we want to make a state
284:12 - change so let's make a state change
284:15 - it'll return a contract object
284:18 - so we can just add print
284:21 - simple storage and we'll see what prints
284:24 - so let's run this brownie run scripts
284:27 - deploy.pi
284:28 - awesome so what happened was brownie
284:31 - again per usual it launched a local
284:33 - ganache chain
284:35 - and then it sent a transaction to deploy
284:38 - simple storage
284:39 - and it says simple storage deployed at
284:41 - and then the address it was deployed at
284:43 - and we can see how much quicker this is
284:45 - to actually deploy now let's go ahead
284:47 - and do exactly what we did with web3.pi
284:49 - let's call this initial retrieve
284:51 - function and then we'll update it with a
284:53 - new value of 15. but we'll do it in
284:56 - brownie now
284:57 - remember here's how we did it back in
284:59 - web3.pie in brownie what we're going to
285:01 - do is first we're going to do
285:04 - stored value
285:06 - equals
285:07 - simple storage
285:08 - dot retrieve now since this is a view
285:11 - function we don't have to add from
285:13 - account in here again brownie is
285:15 - intelligent enough to know if this is a
285:18 - call or transaction and we know that
285:20 - retrieve is
285:21 - a view function so we know we don't
285:23 - actually have to make a transaction here
285:25 - then we can print out the value of
285:27 - stored value
285:28 - print
285:29 - stored value
285:30 - let's go ahead and try this
285:34 - great we get 0 right here perfect
285:37 - now let's try updating this so we can do
285:39 - transaction
285:41 - equals
285:42 - simple storage
285:44 - dot store
285:45 - and in here we'd want to do 15. but
285:47 - remember since we're doing a transaction
285:49 - in brownie we always have to add who
285:51 - we're going to transact from
285:53 - in this case we're going to do from
285:55 - account similar to web3.pi we can do
285:58 - transaction.wait
285:59 - for how many blocks we want to wait and
286:01 - then let's call that retrieve function
286:04 - again to see if it's been updated
286:06 - so we can do updated
286:09 - stored value equals
286:12 - symbol storage dot retrieve and then we
286:14 - can print
286:16 - the updated stored value
286:20 - and if we run this
286:22 - we now see we have two transactions here
286:25 - one that deployed our original simple
286:27 - storage contract and we called the
286:29 - retrieve function and we returned zero
286:31 - here
286:32 - then we updated with our store function
286:34 - and then we called retrieve again and we
286:36 - see we did indeed update it to 15. you
286:38 - see how much smaller and easier and more
286:41 - intuitive this is in brownie and how
286:43 - much our lives are going to be much
286:44 - better awesome now you've learned how to
286:46 - deploy to a local chain now running
286:48 - these scripts is fantastic but we need a
286:51 - way to actually automate that our
286:53 - contracts are doing what we want them to
286:55 - do we don't want to always have to
286:56 - manually check that all of our stuff is
286:59 - doing what we want to do right we don't
287:00 - want to have to manually check that 15
287:02 - is actually updating appropriately this
287:04 - is why running tests are so important
287:07 - and automating your tests is going to be
287:08 - crucial to becoming a successful smart
287:11 - contract developer now i do want to
287:12 - point out that you actually can write
287:14 - tests directly in solidity and this is a
287:17 - great way to actually test your smart
287:18 - contracts is to learn how to do it right
287:20 - in solidity however a lot of the
287:22 - professional developers code their tests
287:24 - in the smart contract development
287:26 - framework language like python or
287:28 - javascript doing it in this way allows
287:30 - you to get a lot more flexibility and
287:32 - customization with what you're doing
287:33 - with your smart contracts and not being
287:35 - confined to whatever only solidity has
287:37 - so let's go ahead and learn how to
287:39 - actually write our smart contract tests
287:41 - in python this is what this test folder
287:44 - is for so we're going to create a new
287:45 - file called test
287:50 - simple storage
287:52 - dot pi
287:53 - make sure you do add tests to the front
287:55 - of these because this is the syntax that
287:57 - pi test is going to be looking for and
287:58 - then in our test we can actually set it
288:00 - up the exact same way we set up our
288:01 - deploy function we can do from
288:04 - browning
288:05 - import
288:06 - simple storage
288:08 - and accounts
288:10 - then we can start defining our tests we
288:13 - want to test to see that when we deploy
288:15 - our smart contract that it gets started
288:17 - off with zero in that retrieve function
288:20 - so we'll create our first test we'll do
288:22 - def
288:24 - test
288:24 - deploy and typically
288:28 - testing in smart contracts or testing
288:30 - really in anything is going to be
288:31 - separated into three categories
288:33 - arranging
288:35 - acting
288:37 - and asserting we're going to bounce
288:39 - around and be a little bit loose with
288:41 - this definition for the duration of our
288:44 - tutorials here however keep in mind that
288:46 - typically this is the setup that you
288:48 - want to use later on in one of our later
288:50 - smart contract examples we're going to
288:52 - go through a much better testing setup
288:54 - so in our arrange stage we're going to
288:56 - set up all the pieces that we need to
288:57 - get set up
288:58 - so first
289:00 - we're going to grab an account
289:01 - we're going to say accounts equals
289:03 - account zero and this is really all we
289:05 - need to do to start getting set up now
289:07 - for our acting stage we're going to
289:09 - deploy
289:10 - a simple storage contract
289:12 - exactly as we did with deploy
289:14 - so we do simple storage
289:16 - equals simple storage dot deploy
289:21 - from
289:22 - account then we're going to get our
289:24 - starting value
289:26 - starting value
289:28 - is going to be equal to
289:30 - simple storage dot
289:33 - retrieve and we're expecting
289:35 - [Music]
289:39 - this to be zero
289:41 - so then all we have to do in our search
289:43 - sage is we have to run assert
289:45 - starting value
289:47 - equals
289:48 - expected so let's recap this in our
289:51 - arrange stage we're just getting our
289:54 - account so that we can actually make
289:55 - contracts then in our x stage we're
289:57 - going to deploy this simple storage
289:58 - smart contract we're going to call the
290:00 - retrieve function to see what its
290:02 - starting value is and we're going to
290:04 - compare to see if that starting value is
290:06 - what we expect and we expect it to be
290:07 - zero we can then test this with brownie
290:11 - test
290:11 - and per usual brownie is going to kick
290:13 - off a ganache lie
290:15 - and then it's going to test this
290:17 - for every test you have you're going to
290:18 - get a little green dot and we're going
290:20 - to say one pass in 1.86 seconds which is
290:23 - perfect if we had expected to be 15 and
290:25 - we ran brownie test we should get a fail
290:28 - here
290:30 - awesome and that's exactly what we got
290:32 - now let's go ahead and test updating
290:34 - this with 15 and see if it works as we
290:37 - want it to so we can do a new test in
290:40 - here
290:41 - we'll do def
290:42 - test
290:44 - update thing
290:47 - storage
290:49 - and we'll do those three phases
290:51 - arrange
290:53 - act
290:54 - and assert in our range all we need to
290:56 - do is get our account
290:59 - from account zero and in this one
291:01 - arranging is also going to be deploying
291:04 - our smart contract
291:07 - since this is really just part of the
291:09 - setup and not the act that we're really
291:10 - testing now in our act we're going to
291:12 - add expected
291:15 - to be equal to 15 and we're going to run
291:18 - simple storage
291:19 - dot store
291:21 - expected
291:23 - and then from account
291:27 - you'll notice this is nearly exactly the
291:28 - same as this deploy function here
291:31 - now same as last time all we have to do
291:34 - is assert
291:37 - expected
291:39 - equals equals
291:41 - simple storage dot
291:44 - retrieve we're saying we want to store
291:47 - 15 in our smart contract and then when
291:49 - we call our retrieve function it is
291:51 - stored correctly so let's go ahead and
291:54 - run
291:55 - brownie test
291:59 - awesome we can see two dots here this
292:01 - means two have actually passed correctly
292:04 - that's great now i do want to quickly
292:06 - show you a couple of useful tips that i
292:08 - pretty much always do when i'm running
292:09 - my tests if you want to test just one
292:12 - function you can do dash k
292:14 - brownie test k
292:16 - test updating storage and we will only
292:19 - test this test updating storage we can
292:21 - run brownie test dash dash pdb
292:25 - and add something wrong in here like
292:27 - five equals simple storage dot retrieve
292:32 - and what will happen is once this kicks
292:34 - out and is wrong will actually get put
292:36 - into a python shell and now we can check
292:39 - to see some variables in here like if i
292:41 - see what expected is expected is 15.
292:44 - if i try to run
292:45 - simple storage.retrieve expected is 15.
292:49 - if i run simple storage
292:53 - i'll see this is the simple storage
292:54 - contract
292:56 - pdb is a really useful way to mess
292:58 - around and see okay well what did i
293:00 - really go wrong why is my test failing
293:02 - another important flag is going to be
293:04 - dash s
293:05 - so you'll notice that no print lines
293:07 - actually get sent out when you're
293:09 - working with these tests
293:10 - if you do dash s
293:13 - it'll be a little bit more robust and
293:14 - telling you exactly what's going on and
293:16 - if we had any print lines it would print
293:18 - the lines out as well everything that
293:19 - you can do with brownie test actually
293:21 - comes directly from pi test so if
293:23 - there's some flag you want to use or
293:25 - some awesome debugger you want to use
293:27 - you can use it with brownie just by
293:29 - looking at the pi test documentation all
293:31 - the tools are exactly the same all right
293:34 - we're coming along fantastically we have
293:36 - a script to deploy we have some tests we
293:38 - have our contract this is great but now
293:41 - we actually want to deploy to a test net
293:43 - how are we going to do this let's look
293:45 - at back how we did it with web3.pi back
293:47 - in web3.pi to deploy this to a test net
293:50 - we just needed to add our http web3
293:52 - provider which was our infira account
293:54 - and that was pretty much it and add our
293:56 - address and our private key brownie our
293:58 - lives are even easier brownie comes
294:00 - pre-packaged with a list of networks
294:02 - that it's already compatible with you
294:04 - can see all the networks by running
294:06 - brownie
294:07 - networks
294:09 - list
294:11 - now mine has a couple more actually
294:13 - because i've been playing around with
294:14 - this for a long time but if you want to
294:16 - see all the different networks you can
294:18 - look at this list here something
294:19 - important to note is that there's a
294:21 - difference between the development
294:22 - networks
294:23 - and the ethereum networks whenever we
294:25 - deploy to a network we default to this
294:28 - development network any network that you
294:30 - see under this development section is
294:32 - going to be a network that is temporary
294:34 - these are networks such as the temporary
294:36 - ganache network that brownie
294:38 - automatically spins up when we've run
294:40 - any of the scripts we've written so far
294:41 - so this is really important to know
294:43 - remember anything in this development
294:44 - section is going to get torn down
294:47 - after it's deployed however the ethereum
294:49 - ones are going to be our persistent
294:51 - networks anything under this ethereum
294:53 - tab brownie is actually going to keep
294:55 - track of our deployments and keep track
294:57 - of everything in there these networks
294:58 - under here represent persistent networks
295:01 - like mainnet rink b coven etc now in our
295:04 - web3.pi we used an rpc url or an http
295:08 - provider from infira to connect to a
295:10 - testnet we're going to use that exact
295:12 - same methodology here so how do we
295:14 - actually get this rpc url this
295:16 - blockchain url into our brownie smart
295:19 - contract package well one of the easiest
295:21 - ways is with an environment variable so
295:24 - brownie actually already knows that
295:26 - infuria is thing and can look natively
295:29 - right away for inferior web 3
295:32 - infuria
295:34 - project id
295:37 - and use our project id from infira if we
295:40 - go to our project back in inferior
295:43 - and we go to settings
295:45 - you'll see the project id is a little
295:47 - bit different than the whole url it's
295:50 - just going to be this id right here
295:52 - we can then copy this and paste this
295:55 - right into our emv now that we have our
295:57 - web3 inferior product id directly in our
296:00 - project
296:01 - if we do
296:02 - brownie
296:04 - networks list any network that infuria
296:07 - has access to you'll see a little
296:09 - inferior in colons here these are
296:11 - networks that brownie will automatically
296:13 - know about if we're working with
296:14 - inferior so we can see here that ring b
296:17 - is one of these inferior keys if we
296:19 - wanted to deploy to ring b we could then
296:21 - just run
296:23 - brownie run
296:25 - scripts deploy.pi
296:27 - and then select the network with dash
296:30 - network
296:31 - rink b
296:34 - now we're going to get an issue here
296:36 - because remember account zero only works
296:39 - when brownie works with a ganache cli we
296:42 - have to use our actual private key here
296:44 - and that's where some of those other
296:45 - versions of working with private keys is
296:47 - gonna come into play sometimes i'll even
296:49 - add a get account function
296:52 - so down here we'll do def
296:54 - get account
296:56 - and then in here i'll just natively
296:58 - check if we're working on a development
297:00 - chain we'll use account zero
297:03 - and if not we'll use the method that
297:05 - pulls from our config so we can check by
297:08 - saying if
297:10 - network
297:11 - does show active
297:15 - equals equals
297:17 - development
297:21 - then
297:22 - return
297:25 - accounts 0. network is another keyword
297:27 - that brownie actually has
297:29 - this network keyword allows us to
297:32 - interact with different networks
297:37 - now if it's not on the development
297:39 - network we're going to pull directly
297:41 - from our config
297:43 - so we'll return
297:48 - config
297:52 - wallets
297:55 - from key
297:56 - and instead of doing account equals
297:58 - account zero we can just do account
298:01 - equals get account
298:04 - now if we run brownie run scripts deploy
298:06 - to pi network ringby it should pull
298:09 - directly from our
298:11 - config
298:12 - file and great we can actually see
298:15 - transactions being sent directly on the
298:17 - rinkby chain
298:19 - if we pull up ether scan
298:21 - the ring be ether scan and we take this
298:23 - transaction has and post it into the
298:24 - bring to ether scan we can see this
298:26 - transaction actually going through we've
298:28 - deployed our simple storage contract and
298:31 - it's initialized to zero
298:33 - then we're going to go ahead and update
298:35 - it and it gets updated to 15. now once
298:37 - we've deployed to a blockchain
298:40 - you'll see our build contract will
298:42 - actually change
298:43 - our deployments folder will have a new
298:46 - deployment every time you deploy to a
298:48 - blockchain brownie will actually save
298:50 - that deployment so you can always go
298:52 - back and say hmm where did i deploy that
298:54 - or what happened with that deployment
298:56 - you'll notice that it's separated by
298:58 - chain id remember the chain id ring b is
299:01 - four you'll also notice that none of our
299:03 - development deployments are in here
299:05 - again anything that's in this
299:07 - development section isn't going to get
299:08 - saved to the deployments area however
299:12 - anything up here
299:13 - and these ones will get saved and that's
299:16 - going to be really powerful because we
299:17 - can actually interact with contracts
299:19 - we've already deployed onto a chain so
299:21 - let's go ahead and even add
299:23 - a new file in here
299:25 - called
299:26 - read value this function is going to
299:28 - read directly from the ring blockchain
299:30 - and it's going to read from a contract
299:32 - that we've already deployed remember we
299:34 - did something similar in web3.pi
299:36 - by using the address
299:38 - and the abi
299:40 - we're going to do the exact same thing
299:41 - but in brownie so in brownie again we're
299:43 - going to do from brownie
299:46 - import
299:48 - simple storage
299:51 - accounts
299:54 - and config
299:58 - we'll do def
300:02 - read contract
300:05 - and we'll just do pass for now
300:07 - and then def main
300:11 - is going to be read contract oops didn't
300:13 - mean to do that down here and if we run
300:15 - brownie run scripts
300:18 - read value to pi
300:20 - network rank v obviously right now
300:22 - nothing's going to happen so how do we
300:24 - actually interact with this simple
300:25 - storage contract that we've already
300:26 - deployed well this simple storage object
300:29 - is actually just an array
300:31 - if we were to print simple storage
300:34 - let's see what we get
300:37 - see we get this
300:39 - brownie.network.contract.contractcontainer
300:41 - object at here this object works the
300:43 - same as an array we can access the
300:45 - different indexes inside of it so what
300:46 - if we do print simple storage at
300:48 - position zero
300:53 - you'll see we get this address here
300:55 - and if we check on ether scan
300:57 - we can see that this is indeed the
300:59 - contract that we just deployed
301:02 - ronnie knows that we just deployed it
301:04 - because again
301:05 - in our build section in the deployments
301:07 - on the rink b chain which has the chain
301:09 - id of four
301:10 - we have this contract that we've
301:12 - deployed now we can actually just
301:14 - directly interact with this contract
301:16 - we can do simple
301:18 - storage
301:20 - equals
301:21 - simple storage of xero or if you're
301:24 - always looking to get the most recent
301:26 - deployment
301:27 - minus one is a little bit easier if we
301:29 - always do zero we're just going to get
301:31 - the first deployment that we made and if
301:33 - we make deployments later we're never
301:35 - going to get past it
301:37 - i want to always work with the most
301:39 - recent deployment so i can just do minus
301:41 - one remember how i said whenever we work
301:43 - with a smart contract we need to know
301:45 - its abi
301:47 - and its address
301:50 - well brownie already knows what the
301:52 - address of this contract is it's got it
301:54 - saved in this deployments folder
301:57 - it also knows what the abi is because
301:59 - when we compile it we get this big json
302:02 - file and one of the first inputs that it
302:04 - has is the abi so brownie automatically
302:07 - knows what the abi is and what the
302:09 - address is already
302:11 - so then we can just go ahead and run
302:13 - simple storage
302:15 - dot retrieve
302:17 - and print it out
302:18 - and we should see 15 since we already
302:21 - updated it
302:23 - brownie run scripts
302:26 - read value to pi dash dash network rink
302:29 - b
302:32 - and great we do indeed see 15. now that
302:34 - we know how to write some scripts and
302:36 - actually deploy things with brownie and
302:38 - work with brownie i'm going to show you
302:39 - one of the most powerful features to
302:41 - also work with brownie typically we
302:43 - write our scripts when we want something
302:45 - to be reproducible and we want to do
302:47 - something over and over again
302:48 - deploying simple storage or reading of
302:51 - value is something that we're probably
302:52 - going to want to do over and over again
302:54 - however maybe we want to work with some
302:56 - of these contracts a little bit ad hoc
302:57 - and get into a shell where we can
302:59 - actually interact with these contracts
303:01 - this is where the brownie console is
303:03 - actually going to come into play and
303:04 - make our lives a lot easier
303:06 - so what we can do
303:08 - is we're going to brownie
303:10 - console
303:12 - and what will happen
303:13 - is brownie will actually kick us off
303:16 - into a console it has all of our
303:18 - contracts and everything already
303:19 - imported
303:20 - so if i run simple storage it gives me
303:23 - back an array it's saying
303:25 - great that's your simple storage
303:26 - contract since we're working on a brand
303:29 - new local test environment there are no
303:31 - simple storage contracts deployed so
303:33 - what i can do
303:34 - is i can say account
303:36 - equals
303:38 - account zero
303:40 - and we now
303:42 - have
303:42 - our account that we can work with
303:44 - accounts is one of these keywords that's
303:46 - automatically imported into our brownie
303:48 - console
303:49 - everything that is imported via brownie
303:51 - in our script is automatically already
303:54 - imported into this little shell here so
303:56 - with that being said we can go ahead and
303:58 - even deploy our simple storage contract
304:00 - so we can literally take this line
304:03 - copy it paste it in here
304:05 - and you'll see exactly the same thing
304:07 - that happens as if we ran our script we
304:09 - get a little transaction hash here and
304:11 - we get a simple storage
304:13 - now
304:15 - if i type simple storage the simple
304:18 - storage variable now has a storage
304:20 - contract here
304:22 - if i type simple storage
304:24 - you'll see i now have a contract in here
304:28 - the length
304:29 - a simple storage is now one because i've
304:33 - deployed one simple storage contract
304:36 - if i were to deploy it again
304:39 - the length is now two
304:41 - browning now knows i'm holding on to two
304:44 - simple storage contracts and i've
304:45 - deployed two simple storage contracts
304:48 - i can then even do things like simple
304:51 - storage
304:53 - dot retrieve
304:55 - and we can see
304:56 - we start with zero i can go ahead and
304:59 - even run
305:01 - simplestorage.store
305:05 - 15
305:08 - from
305:09 - account
305:12 - and we'll see we'll get a transaction
305:15 - now if i rerun simplestorage.retrieve a
305:17 - nice little hack here is in these shells
305:19 - if you just hit the up key you'll
305:21 - actually be able to go back in the
305:22 - history of the shell so if i just hit up
305:24 - twice here i can go back to this command
305:26 - and i hit enter now we see the 15 is
305:28 - here so the brownie console is a great
305:31 - way to interact with these scripts in a
305:33 - more ad hoc manner maybe we want to test
305:36 - some weird functionality or maybe we
305:38 - have some experiment that we want to try
305:40 - it's a great way to really interact with
305:42 - anything that we have in browning and
305:44 - the other thing is we can do everything
305:45 - that we normally do in python in here so
305:47 - for example i could write print
305:50 - hello
305:51 - and it'll print out hello i could do
305:54 - cat equals 1 plus 2
305:57 - and i type cat and i get 3. so this
305:59 - brownie shell is a python shell with all
306:02 - of our smart contract features already
306:04 - natively integrated and it's incredibly
306:06 - powerful here
306:07 - we go and quit it by doing quit so i
306:09 - know we've learned a lot so far i'm sure
306:11 - you're starting to see why working with
306:13 - brownie is so much easier and makes our
306:16 - lives as smart contract developers a lot
306:17 - easier for testing them deploying them
306:20 - and working with them
306:26 - all right let's move on to our next
306:29 - project is we're going to take the fund
306:31 - me contract that we made recently in
306:32 - remix and actually import that one into
306:35 - brownie with this we're going to go over
306:36 - a lot more of the advanced features that
306:38 - brownie has to offer us and we're going
306:40 - to get into some more sophisticated
306:42 - testing and deployment mechanisms for
306:44 - this so i'm going to make a new
306:45 - directory
306:47 - brownie
306:49 - fund me
306:51 - we're going to cd
306:52 - into brownie fund me
306:55 - and remember if you hit tab it will auto
306:57 - complete i'm going to open this up in a
306:59 - folder
307:01 - again if code period doesn't work you
307:03 - can always go up to file open folder and
307:06 - do it like that we're in our brownie
307:07 - fund me project and we're going to
307:09 - initialize a new project
307:10 - by running brownie
307:13 - init
307:14 - we're going to create a new contract
307:17 - called
307:18 - fundme.soul
307:19 - this is going to be exactly what we had
307:21 - before for our fund me contract so if
307:23 - you have remix up great you can go ahead
307:25 - and grab it or you can check the github
307:27 - repository associated with this course
307:29 - and just copy paste the code
307:34 - now typically this is where in our last
307:36 - project we just ran brownie compile
307:40 - what happens if we run brown and compile
307:41 - here brownie is going to give us this
307:43 - error it's going to say hey this source
307:45 - wasn't found so what's going on here
307:47 - well remix understands that at chain
307:50 - links slash contracts is an npm package
307:52 - that it can import from however
307:54 - brownie isn't aware of npm packages and
307:57 - brownie can't actually download directly
307:59 - from npm however brownie can download
308:02 - directly from github so we have to tell
308:05 - brownie where it should be downloading
308:07 - these external these third-party
308:08 - packages from so that we can use them in
308:10 - our contracts here and while i'm in here
308:12 - i might as well change the global
308:13 - compiler version to 0.6.6
308:20 - and we'll just change the compiler
308:21 - version to carrot 0.6.6 so that our
308:24 - linter is happy so we need to tell
308:25 - brownie where to import these contracts
308:27 - from from github instead of from npm
308:31 - luckily there is a package out there
308:32 - specifically created for downloading
308:34 - chain link contracts the way that we can
308:36 - tell brownie where to get these from
308:38 - is in our browning config
308:40 - so let's create our browning config
308:43 - in here we're going to create a the pen
308:46 - then sees section and this is where we
308:48 - tell brownie the organization
308:52 - slash repo name
308:54 - at
308:55 - version
308:57 - that we want to download from
308:59 - so so to get these chain link contracts
309:02 - we can look up
309:03 - chain link
309:04 - brownie contracts
309:06 - and we can use this repository to get it
309:08 - so instead of downloading from npm we're
309:09 - just going to download directly from
309:11 - this github repo so we need to tell
309:13 - brownie the organization which is going
309:15 - to be smart contract kit
309:19 - the repository name which is going to be
309:21 - chain link brownie contracts
309:26 - and then the version you don't always
309:28 - have to use the latest version here in
309:30 - fact we can go to the past nine versions
309:32 - by clicking on the version history we're
309:34 - actually going to be using 1.1.1
309:36 - and yes it does look like the latest
309:38 - version went backwards but as of a
309:40 - recent release as a 1.2.0 version of
309:43 - this package all the releases of
309:45 - chainley brownie contracts is going to
309:46 - match exactly the at chainlink contracts
309:49 - npm tag so that's why it looks like this
309:51 - is an earlier version so we'll say 1.1.1
309:54 - so great so now brownie knows to
309:55 - download this repository from github
309:57 - once we do that everything everything in
309:59 - this contract section will be available
310:02 - for our solidity code to import and use
310:04 - however that's not the final story here
310:06 - we also need to tell brownie
310:08 - what this at chain link thing means
310:10 - because we're downloading from smart
310:11 - contract kit slash chain link brownie
310:13 - contracts ronnie's going okay cool well
310:16 - what's the sat chain link thing so we
310:18 - need to tell brownie whenever we're
310:19 - using at chain link we're actually
310:21 - referring to this import so we need to
310:24 - tell the compiler this
310:26 - so let's add a new section we'll say
310:27 - compiler
310:29 - when it compiles sulk
310:31 - we need to remap
310:35 - at chain link
310:40 - say whenever you see at chain link here
310:44 - it means
310:46 - we're referring to this package
310:48 - so compiler soccer mappings at chain
310:51 - link
310:52 - is equal to this package up here now
310:55 - let's go ahead and try to compile
311:01 - perfect we see here that it compiles
311:04 - successfully and if we look at our build
311:06 - folder
311:07 - in the contract section we now have this
311:09 - new folder called dependencies
311:12 - and if we even expand this a little bit
311:14 - we can see
311:15 - it says dependencies smart contra kit
311:17 - chain link browning contracts at 1.1.1
311:20 - and this is what it downloaded from that
311:22 - github repository it downloaded
311:24 - aggregator v3 interface and smart math
311:27 - chain link because we're using both of
311:29 - those files in our solidity code all
311:32 - right great so let's write our first
311:33 - script to deploy this to a development
311:36 - ganache chain to brownie's built-in
311:38 - chain
311:39 - let's do this
311:40 - so in scripts let's go ahead we'll
311:42 - create a new file let's go ahead and
311:44 - build a simple deploy script to work
311:46 - with rink b and then we'll actually
311:48 - learn how to deploy this to our own
311:50 - local ganache development chain so let's
311:53 - build our deploy script so in scripts
311:55 - we'll do new file
311:58 - deploy.pi and we'll start by doing def
312:02 - deploy
312:03 - fund me
312:06 - then we'll do pass for now
312:08 - and then we'll do our entry point of
312:09 - deaf main and then we'll call
312:12 - deploy fund me in this file of course
312:15 - we're going to do from
312:17 - brownie
312:18 - import
312:19 - fund me
312:21 - so we can actually use this and let's go
312:24 - ahead and build this deploy fund me
312:25 - function so first we're going to need to
312:27 - get an account
312:30 - and same as last time we used a function
312:33 - called get account which would know to
312:35 - switch back and forth between if we were
312:36 - on development or if we were with an
312:39 - actual testnet that we could pull from
312:40 - our config we can actually once again
312:43 - copy that function
312:45 - and use that and use that in our script
312:47 - here so once again we can use that get
312:49 - account function that we had before what
312:51 - i like to do with this get account is
312:53 - add it into its own file called helpful
312:56 - scripts
312:57 - so what i'll do is create a new file
312:59 - called helpful
313:01 - scripts.pi
313:04 - and in here i'll add that getaccount
313:06 - function right so literally just pasted
313:08 - it from our last project and just a
313:10 - quick recap on what this is doing
313:12 - is we're saying if the network is in
313:14 - development we're going to use the
313:16 - accounts 0 syntax otherwise we're going
313:18 - to pull from our config
313:20 - and of course we're going to have to
313:22 - from brownie
313:24 - import network
313:27 - config
313:28 - and accounts
313:30 - and then of course in our browning
313:31 - config we're going to have to add
313:32 - wallets and from key so let's go to our
313:34 - config
313:36 - we'll do wallets
313:39 - from key
313:41 - and we'll add
313:42 - our private key environment variable
313:44 - setup
313:46 - which of course means that we're going
313:48 - to have to set dot env
313:51 - to dot e and v and we're going to create
313:53 - new file dot amv
313:56 - and we'll paste
313:57 - the exact same values from our last dot
314:00 - emv so it's going to be our private key
314:02 - and our project id kind of just a lot of
314:04 - the basics of the setup here
314:06 - but now that we've added this get
314:08 - account to its own script how do we
314:10 - actually use that in our deploy script
314:12 - depending on the version of python that
314:14 - you're in you might actually have to
314:15 - create a new file first named underscore
314:18 - underscore init underscore underscore
314:20 - dot pi
314:21 - you might not but just in case let's
314:23 - make it here because it doesn't hurt and
314:25 - with this now python knows that it can
314:28 - import from other scripts and other
314:30 - packages
314:31 - in this project so now we can do from
314:34 - scripts
314:36 - dot helpful scripts
314:39 - import get account so we're importing
314:43 - that get account function
314:44 - from our helpful script here and we're
314:47 - gonna make this get account function a
314:48 - little bit more robust a little bit
314:49 - later but for now it'll work perfectly
314:51 - for what we're looking to do now we can
314:53 - just run our typical deploy function
314:55 - funny we'll do the fundme contract
314:57 - equals fund me
314:59 - dot deploy
315:03 - and of course we'll do from
315:06 - account
315:12 - because again since this deploy is going
315:14 - to make a state change to the blockchain
315:16 - we always need to do a from account
315:18 - section here then we can even do a
315:20 - little print
315:21 - we'll do a print f here
315:23 - so we'll say
315:24 - contract
315:25 - deployed to
315:29 - fund me
315:30 - dot address
315:32 - this is how we'll get the address of our
315:34 - fund me and great we can even go ahead
315:36 - and try this out right now remember
315:38 - you'll need some testing
315:39 - ethereum in your metamask
315:42 - brownie run scripts deploy.pi
315:45 - dash dash network
315:49 - rank b
315:51 - and
315:53 - perfect contract deployed here it is
315:56 - we can even go to
315:58 - bring the ether
316:00 - scan again
316:05 - and we'd see the contract right here now
316:07 - this is great and all but if we look at
316:08 - our contract
316:09 - it's kind of this blank jarble of
316:12 - bytes here right nobody can actually see
316:14 - this contract and and easily interact
316:16 - with it and we want to make our
316:17 - contracts easy to interact with what we
316:19 - can do on etherscan is verify and
316:22 - publish our smart contracts to verify
316:24 - our smart contract all we have to do is
316:26 - hit that verify button
316:28 - we'll choose our solidity compiler type
316:31 - which we know is going to be
316:33 - 0.6.6
316:36 - and we know we're working with the mit
316:37 - license here
316:41 - now to continue we would then have to
316:43 - add in all of the
316:45 - rest of these pieces we'd have to do
316:47 - optimization which is going to be yes
316:49 - we'd enter our solidity contract code
316:51 - below which importing fund me like this
316:55 - wouldn't actually work
316:56 - because etherscan doesn't know what at
316:58 - chainlink contracts is
317:01 - so we would have to
317:02 - copy paste the code
317:04 - from these imports to the top of our
317:06 - contract here removing these imports and
317:08 - copy pasting the code associated with
317:10 - those files is known as flattening and
317:13 - this is an important concept for
317:14 - verifying our smart contracts on
317:17 - platforms like etherscan
317:19 - however brownie has a really nice way to
317:21 - get around this actually what you can do
317:24 - is go to their main site etherscan.io
317:27 - you can sign in and sign up and get an
317:29 - api key i've already signed up so i'm
317:32 - going to go ahead and sign in here
317:34 - log in and what we can do is we can go
317:36 - to my profile
317:38 - and scroll down to api keys
317:40 - and this is where we can create an api
317:43 - key for us to interact with and
317:45 - programmatically verify our smart
317:47 - contracts on etherscan i've already got
317:49 - one here but all we need to do is hit
317:51 - add
317:52 - we'll give it a name i'll call it verify
317:56 - browning continue and we've created this
317:59 - new api token that will allow us to
318:01 - verify our smart contracts what we'll do
318:04 - to use this in brownie
318:06 - is we'll copy this api key
318:09 - and we'll move back to our scripts here
318:11 - we'll set this api key as an environment
318:14 - variable so we'll do export
318:16 - the name of this is etherscan
318:19 - token
318:20 - and we'll set it equal to that key that
318:22 - we just got now to verify this all we
318:25 - have to do then is once we deploy this
318:27 - contract we'll tell brownie whether or
318:28 - not we want to verify the contract
318:31 - so after
318:32 - our dictionary here
318:34 - we'll do comma
318:36 - publish
318:37 - source equals
318:39 - true we're saying yes we would like to
318:41 - publish our source code
318:44 - now if we rerun this script
318:46 - let's see what happens again remember
318:48 - we'll do browning
318:50 - run
318:51 - scripts
318:53 - deployed up high dash dash
318:55 - network space
318:58 - rinkaby
319:00 - and says fund me has been deployed to
319:02 - here
319:03 - now we're going to say waiting
319:06 - for api
319:07 - rink b dot etherscan.io to process
319:10 - contract
319:11 - and we're submitting our code for
319:13 - verification here and it'll say
319:15 - verification pending verification
319:17 - complete pass verified it'll say where
319:20 - the contract has been deployed and
319:22 - what's been done with it
319:24 - now if we go back to ether scan again
319:26 - we're going to have to go back to rink
319:27 - be ether scan because we deployed this
319:29 - to rank b and we paste this in
319:32 - we now have this little check mark
319:34 - associated with our contract
319:36 - and if we click contract we can see all
319:39 - of the code in here
319:41 - for our contract
319:44 - we have contract fund me
319:45 - payable you need to get more everything
319:48 - that we defined in here and if we scroll
319:50 - up we can see that they did indeed
319:52 - flatten this contract right they
319:55 - pasted that aggregator v3 interface
319:57 - import
319:58 - and they also pasted that library safe
320:01 - math chain link now that's verified we
320:03 - can even read the contract see the
320:05 - different public variables in here such
320:07 - as the owner get version get price and
320:10 - all the exact same buttons that we saw
320:12 - in remix this read contract section is
320:15 - for all these view functions right the
320:16 - ones that aren't going to be making a
320:17 - state change
320:19 - right contract
320:20 - is going to be for when we want to call
320:22 - something like fund or withdraw and we
320:24 - could even go ahead and interact with
320:25 - this so for example we could connect to
320:27 - web3
320:28 - metamask
320:30 - okay and it would automatically get
320:32 - connected to our metamask here then we
320:34 - could call fund and withdraw just like
320:36 - we did in remix if you want to give it a
320:38 - shot go for it all right we're back in
320:40 - our code editor after successfully
320:42 - verifying one of our smart contracts on
320:43 - etherscan now just a quick note
320:45 - sometimes the verification process can
320:47 - be a little bit touchy and for version
320:49 - of solidity 0.8.4 there's currently a
320:51 - bug that makes it verifying a little bit
320:53 - tricky but it's being worked on so don't
320:55 - be discouraged if it gets a little bit
320:56 - funky so this is great that we've
320:58 - written a deploy script for deploying
320:59 - directly to ring b however as you know
321:01 - we're always going to want to be able to
321:02 - deploy to our own local blockchains or
321:06 - or brownies built-in development chain
321:07 - so we can test a lot quicker and that
321:11 - yes so that we can write some tests but
321:13 - we have a little bit of an issue here
321:14 - the first issue being that our fundme
321:16 - contract currently has an address
321:19 - hard-coded to work with the rink be
321:21 - chain so in fact the way it's written
321:23 - right now it's going to be hard to work
321:24 - with any other chain other than ring b
321:26 - the second bit is that these price feed
321:28 - contracts don't exist on a local ganache
321:31 - chain or a gnost chain that brownie
321:33 - spins up there's two ways we can get
321:34 - around this we can do what's called
321:36 - forking and work on a forked simulated
321:38 - chain
321:39 - or we can deploy a mock or deploy a fake
321:42 - price feed contract on our ganache local
321:44 - development chain deploying mocks is a
321:46 - common design pattern used
321:48 - across all software engineering
321:49 - industries and what it applies doing is
321:51 - deploying a fake version of something
321:54 - and interacting with it as if it's real
321:57 - so again right now if i run brownie
322:01 - run
322:03 - scripts deploy.pi and i don't set this
322:06 - network flag we're going to actually
322:07 - have a default spinning up a ganache
322:09 - chain it's even going to try to verify
322:12 - which it's going to run into an issue
322:13 - because we can't verify on a ganache
322:15 - chain so we have a couple issues that we
322:17 - need to address here in order for us to
322:19 - get this to work on a ganache chain
322:21 - similar to how in this get account
322:23 - function in our helpful scripts
322:26 - we do a little bit checking we say hey
322:28 - if we're on a development network
322:30 - use this development accounts version
322:33 - otherwise
322:34 - pull from our config
322:36 - we can do that exact same mentality but
322:39 - with working with these marks so the
322:40 - first thing that we need to do is we
322:42 - need to parameterize our fund me
322:45 - solidity smart contract
322:47 - so that we don't have this hard-coded in
322:49 - here anymore so what we can do
322:51 - is right when we deploy this contract
322:54 - we'll tell it what price feed address it
322:56 - should use right when we call our deploy
322:59 - function here instead of having it hard
323:01 - coded
323:02 - and we can add this parameter to our
323:04 - constructor we'll say
323:06 - address
323:08 - price feed
323:10 - as an input parameter and whatever input
323:13 - parameter we use here is going to be our
323:15 - global price feed address so instead of
323:18 - us creating
323:19 - these aggregator v3 interface contracts
323:21 - right in the functions here we're just
323:23 - going to create a global one so we'll
323:25 - say
323:27 - aggregator
323:28 - v3 interface public
323:31 - price feed
323:33 - and right in our constructor
323:35 - right when we create this we'll set
323:38 - price feed
323:40 - equals
323:42 - aggregator v3 interface
323:46 - price feed
323:48 - and now what we can do is we can just
323:50 - delete this part because as you can see
323:52 - this is doing the exact same thing
323:54 - is up here this is doing aggregator v3
323:56 - interface price feed equals aggregator
323:58 - v3 interface and then the address here
324:00 - and we're going to do the exact same
324:02 - thing but in our constructor meaning
324:04 - right when we deploy this contract so we
324:06 - can delete this
324:08 - and we can delete it here as well in our
324:10 - get price function we can even verify
324:12 - this with brownie
324:14 - compile
324:17 - great looks like it's compiling
324:19 - perfectly
324:20 - now
324:20 - our deploy function is going to need to
324:22 - look a little bit different we're going
324:24 - to need to pass
324:26 - the price feed address
324:29 - to our fund me contract to do this all
324:32 - we'd have to do is paste
324:36 - that address before we have our from
324:39 - account variable here
324:40 - so this is how you can actually pass
324:42 - variables to constructors anything
324:44 - inside this constructor function you can
324:46 - pass through brownie in our deploy
324:48 - script here so great so we could 100
324:51 - always just pass this rink b address
324:53 - here but that's not really going to
324:54 - solve our problem obviously right the
324:56 - problem is that the problem right now is
324:57 - that we always have this ring b address
324:59 - when we say if we are on
325:02 - a persistent network like rink b
325:06 - use the associated
325:09 - address
325:11 - otherwise
325:12 - deploy mocks and i know we've been
325:14 - talking about mocks we'll get into them
325:15 - in a second but let's first set this one
325:17 - up here so we can check what network
325:19 - that we're on again by importing from
325:21 - browning this network bit and we can say
325:23 - if
325:24 - network dot show
325:26 - active
325:27 - does not equal
325:30 - development then
325:33 - we'll say price feed
325:36 - address
325:38 - equals
325:41 - this address here and we'll just pass
325:43 - this price feed address now this still
325:46 - doesn't solve our issue because we're
325:47 - just always passing this the rink be
325:49 - hard-coded piece here so what we want to
325:50 - do is parameterize where we get these
325:52 - addresses from so instead what we can do
325:55 - is in our browning config we can add
325:58 - different addresses for different
325:59 - networks so right underneath our dnv
326:02 - we'll add a new section called networks
326:04 - and we'll do one called rink b and we'll
326:06 - say the fusd
326:11 - price feed
326:12 - address is going to be
326:14 - this price feed address now what we can
326:17 - do in our deploy script
326:20 - is we can say
326:21 - if we're not on a development network
326:23 - let's grab the address from our networks
326:26 - section this way we can define
326:29 - different addresses for this price feed
326:31 - across different networks so we can add
326:34 - we could add a coven section
326:37 - we could add a mainnet section any other
326:39 - networks that we want to work with all
326:40 - we need to do is add add these flags for
326:42 - those contracts so back in our deploy
326:44 - now we can see the price feed address is
326:46 - going to get pulled from the config
326:48 - instead so we'll say config and
326:51 - this means we're going to import config
326:55 - or brownie
326:57 - say config of networks
327:01 - based off of the network dot show
327:05 - active
327:08 - and then we'll use the fusd price feed
327:11 - flag here
327:13 - perfect
327:14 - so this little if statement is going to
327:16 - say hey if we're not on a development
327:18 - network
327:19 - pull the address right from the config
327:21 - and this will make it so that we can
327:22 - deploy to really anywhere that we want
327:24 - to deploy to but what if we are on a
327:26 - development chain well what do we do
327:27 - then we can say else if we're not on a
327:30 - development chain we're going to have to
327:31 - deploy a mock so right now
327:33 - on all these live networks that we're
327:35 - working with there is a version of this
327:37 - price feed contract this price feed
327:39 - address our development chain obviously
327:41 - there won't be one because it's going to
327:43 - start off as blank so what we can do is
327:45 - we can deploy our own version of the
327:47 - price food contract this is known as
327:49 - mocking and we can interact with it
327:51 - accordingly in order for us to deploy a
327:53 - price feed contract ourselves we're
327:55 - obviously going to need to have the
327:56 - solidity code associated with it so what
327:58 - we can do
328:00 - is in our contract section we'll create
328:02 - a new folder called test
328:07 - when you create a test folder in your
328:09 - contracts folder this is typically where
328:11 - mock contracts are going to go and we'll
328:13 - create a new file
328:15 - called mock
328:16 - v3
328:18 - aggregateor dot sol
328:21 - and this is where we'll add the code for
328:23 - us to deploy our own price feed now i'm
328:25 - going to show you another repository
328:27 - pretty soon called the chain link mix
328:29 - that we're going to work with
328:31 - for now if you're looking for one of
328:32 - these mocks i highly recommend just
328:34 - pulling it from this chain link mix
328:36 - repository so we can grab it by going to
328:39 - contracts
328:40 - test
328:42 - and grabbing my aggregator dot soul we
328:44 - can just copy this whole code
328:47 - and paste it into our mockv3
328:49 - aggregator.sol this has all the same
328:52 - exact functions as a real price feed
328:53 - contract such as decimals and latest
328:56 - answer which are going to be two of the
328:57 - ones we use the most we can also see its
328:59 - constructor here
329:01 - these are the variables that it takes
329:03 - whenever this contract is deployed
329:05 - it takes a decimals and an initial
329:08 - answer decimals is of course going to be
329:10 - how many decimals that this contract
329:12 - should have an initial answer is going
329:14 - to be its starting value like 2000 for
329:16 - example once we have this contract in
329:19 - our test section we can of course run
329:21 - brownie compile and brownie will go
329:23 - ahead and compile this mock v3
329:25 - aggregator as well because remember
329:27 - brownie compiles any contract in this
329:30 - contracts folder let's go back to our
329:32 - deploy script now that we have this mock
329:34 - v3 aggregator in here now we can do is
329:37 - we can do a little else here
329:38 - saying okay well if we are on a
329:40 - development chain let's do something
329:42 - let's deploy these mocks so let's do a
329:45 - little print statement here a little
329:46 - printf saying
329:48 - the active network
329:50 - is
329:51 - we'll do network
329:53 - dot show active
329:58 - another print statement print f saying
330:01 - deploying
330:02 - mocks dot dot dot oops i need a little
330:05 - closing there
330:07 - and this doesn't need to be print f
330:09 - it can just be a regular print and then
330:11 - now the same way we import fund me we
330:14 - can import mach v3 aggregateor
330:19 - we can just deploy this contract the
330:21 - same way we deploy all of our other
330:23 - contracts so we'll do mach v3 aggregator
330:26 - dot deploy and as we just learned we
330:28 - have to add the parameters the
330:30 - constructor takes which is going to be
330:32 - decimals and initial answer
330:34 - so maybe we'll set decimals to 18 and
330:36 - then maybe we want to set the initial to
330:38 - answer to 2000 so two one two three one
330:41 - two three four five six seven eight nine
330:42 - ten one two three four five six seven
330:44 - eight comma and of course since we're
330:46 - deploying we've got to do a from
330:50 - and we'll use our account here
330:52 - we'll do another print
330:54 - saying
330:57 - mox
330:58 - deployed and of course we're going to
331:00 - need to get this mock v3 aggregator's
331:02 - address so we'll do
331:04 - mock aggregator
331:06 - equals this and we'll set
331:09 - price
331:11 - feed address
331:12 - to equal
331:14 - our mock aggregator dot address
331:18 - and now we're development or live
331:20 - network agnostic if we deploy this on a
331:23 - live network we'll use the address from
331:25 - our config otherwise we'll use a fake
331:27 - aggregator contract that we've deployed
331:29 - let's go ahead and even try this on a
331:31 - development network
331:33 - so we can do brownie
331:35 - run scripts deploy.pi we don't need a
331:38 - network flag here we'll hit enter it'll
331:40 - spin up the ganache
331:42 - and we even will deploy a mock
331:45 - aggregator contract first
331:47 - and then we'll do our fund me part of
331:50 - course we are running to an issue
331:51 - because we're trying to verify a
331:54 - contract on a chain that doesn't exist
331:56 - etherscan doesn't know about our local
331:57 - gnost chain so to fix this
332:00 - instead of doing publish source equals
332:02 - true we can have this published source
332:04 - be again based on what chain that we're
332:06 - on so we'll go back to our browning
332:07 - config and for rank b
332:09 - we'll say verify
332:11 - will be true but for development
332:15 - we'll say verify will be false and back
332:18 - in our deploy script we now say publish
332:20 - source
332:21 - is going to be pulled from our config so
332:23 - again we'll do config
332:28 - networks
332:30 - network dot show active
332:33 - and then we'll do dot get
332:35 - verify
332:37 - this dot get verify
332:39 - will make our lives a little bit easier
332:41 - if we forget to add verify in here you
332:43 - could still do like this
332:45 - like verify but you run into some index
332:47 - errors if you forget to actually put the
332:48 - verify so sometimes i get lazy and uh
332:51 - it's just a little bit nicer like this
332:52 - now if we run this again
332:54 - deploy.pi
332:56 - we'll spin up our local ganache we'll
332:58 - deploy a mock price feed contract
333:01 - and then we'll deploy our fund me
333:02 - contract
333:04 - and it completes successfully so this is
333:06 - awesome we have a way
333:09 - our fund me contract that uses a price
333:11 - feed contract to our own local
333:13 - development environment with a mock aka
333:15 - a fake price feed contract this is
333:18 - awesome now this is great but our deploy
333:20 - script is starting to look a little big
333:21 - and a little clunky so let's actually
333:23 - clean this up to make it look a lot
333:25 - nicer the first thing that we want to do
333:27 - is we want to fix this this big 2000
333:30 - number just looking at right away i'm
333:32 - not exactly sure how many zeros it has
333:34 - so to make this look a little bit nicer
333:36 - and more readable we can once again call
333:38 - on our friend web3.pi from
333:41 - web3
333:42 - import
333:43 - web3
333:45 - and down here we'll do web3.2
333:48 - way
333:49 - 2000
333:51 - comma
333:52 - ether this two-way function will just
333:55 - add 18 decimals to this 2000 so now this
333:58 - is much more readable that the initial
334:00 - value for this is going to be 2 000. the
334:02 - next bit is that we're always deploying
334:04 - this mock v3 aggregator here and if we
334:07 - already have a mock deployed to whatever
334:09 - network that we're working on we don't
334:10 - need two marks here so what we can do
334:13 - then is right before
334:15 - we deploy this mock is we can do a
334:17 - little if statement
334:18 - we can say if
334:20 - the length
334:22 - of our
334:23 - mock v3
334:26 - aggregator
334:30 - is less than or equal to zero
334:32 - only then will we deploy
334:35 - this mock v3 aggregator remember we can
334:37 - check the length of our v3 aggregator
334:39 - because this v3 aggregator is just going
334:41 - to be a list of all the different v3
334:43 - aggregators that we've deployed now
334:46 - instead of using mock
334:48 - aggregator.address we can just
334:50 - use mach v3 aggregator
334:54 - minus one dot address so we're just
334:56 - saying okay great just use the most
334:58 - recently deployed mock v3 aggregator
335:01 - and then of course we don't we no longer
335:03 - need to set this as a variable and that
335:05 - looks a little bit cleaner and we'll
335:06 - make this a little bit more efficient so
335:08 - this deploying mox bit though is going
335:10 - to be something that so this deploying
335:11 - mox bit though is going to be something
335:13 - that we're actually going to do
335:14 - relatively frequently let's even move
335:16 - this print statement up here so instead
335:19 - what i like to do is put this whole mock
335:20 - deploying bit in its own function in our
335:22 - helpful scripts so let's open back up
335:24 - our helpful scripts we'll do a new
335:27 - function called def
335:29 - deploy mocks
335:32 - and we'll just paste that code in here
335:33 - of course this means that in our helpful
335:35 - scripts we're gonna have to import
335:37 - mock v3 aggregator we'll also have to do
335:39 - from web3
335:42 - import
335:43 - web3 instead of account we'll just use
335:46 - this get account function now back in
335:48 - our deploy script
335:49 - we just delete this whole part
335:51 - replace with
335:52 - deploymox
335:55 - and then import deploymox from our
335:57 - helpful scripts
335:59 - and then we can also delete this import
336:01 - now let's remove some of these comments
336:03 - if you'd like this is starting to look a
336:05 - lot more sophisticated and this is great
336:07 - because now we have a way to deploy base
336:09 - off if we're on a live chain or a
336:11 - development chain and then one more
336:13 - thing i like to
336:14 - do so that everything is parameterized
336:18 - i like to set these as static variables
336:21 - in the top of our helpful scripts
336:23 - so i'll set decimals
336:25 - equals 18
336:27 - and then i'll set starting
336:31 - price
336:32 - equals 2000 and then i'll have
336:35 - mock v3 aggregator to deploy to decimals
336:38 - web 3.2 way
336:40 - to
336:41 - starting price here
336:43 - so no so let's say now that i wanted to
336:44 - deploy this to my own ganache instance
336:47 - well what we could do is we can open up
336:49 - our ganache here we'll do quick start
336:51 - and we'll just quickly create our own
336:53 - ganache blockchain in our script let's
336:56 - go ahead and just run this deploy script
336:58 - again
336:59 - let's see what happens instead of
337:01 - brownie spinning up its own ganache here
337:04 - it says attached to local rpc client
337:06 - listening ad and then this address here
337:09 - brownie is smart enough to detect if
337:11 - you're running your own ganache instance
337:13 - here and will automatically
337:15 - attach itself to it knowing that that is
337:18 - going to be a development environment if
337:20 - we go to our ganache we'll see
337:22 - we have two transactions which are going
337:24 - to be
337:25 - contract creations we're going to create
337:27 - a price feed contract and then also our
337:29 - fund b contract so this is great this is
337:32 - great for testing quickly and locally
337:33 - but there is an issue with this for
337:35 - development networks again brownie
337:37 - doesn't keep track of those so in our
337:39 - build folders if we go to deployments we
337:41 - only are saving stuff from the rink b
337:44 - chain here so we would need to tell
337:45 - brownie hey there's another network that
337:47 - we want you to work with and we want you
337:49 - to remember the deployments to that
337:52 - chain so what we can do is we can add a
337:54 - new network to our browning networks
337:56 - list remember
337:58 - in brownie
338:00 - networks list we have all these
338:02 - different pieces in here these are the
338:03 - ones that brownie is going to not
338:05 - remember and these are going to be the
338:07 - ones that brownie remembers so let's say
338:09 - we want to deploy to a grenache chain
338:11 - and we want brownie to remember those
338:12 - deployments well we can add a network
338:15 - here and this is going to be how we add
338:17 - any blockchain that we want any evm
338:20 - blockchain like avalanche like polygon
338:22 - etc to add a new network to the brown
338:24 - networks is we'll run
338:27 - brownie
338:28 - networks add
338:30 - we'll choose development or ethereum
338:34 - we're going to choose ethereum because
338:35 - we want this to be a persistent network
338:37 - we'll do ethereum
338:39 - we'll give it a name i'm going to call
338:40 - this ganache
338:43 - local
338:45 - we need to give it a host
338:47 - aka an http address which
338:50 - we know
338:52 - is right here
338:57 - and then i'm just gonna
338:59 - make this lower case
339:05 - and then a chain id
339:08 - which for this we know is one three
339:10 - three seven
339:13 - hit enter
339:14 - now if i do brownie networks list i see
339:17 - a new blockchain called ganache local
339:20 - and this is going to reach out to our
339:23 - ganache ui or our ganache command line
339:26 - depending on what we're running now just
339:27 - a note we are going to be deploying to
339:29 - this ganache ui or ganache cli
339:32 - a lot for the rest of this lesson so
339:34 - please keep your ganache instance
339:35 - running now what i can do
339:37 - is i can run brownie
339:39 - run scripts deploy.pi
339:42 - network
339:43 - ganache
339:44 - local let's see what happens of course
339:47 - we run into our first issue ganache
339:49 - local isn't development so it's going to
339:52 - go ahead and try to pull from our config
339:55 - file we don't want this we want to
339:57 - actually deploy mock for our local
339:59 - ganache if a mock hasn't been deployed
340:01 - so what we can do
340:02 - is we can extend our definition of what
340:05 - a development environment is in our
340:06 - helpful scripts we can add a flag in
340:08 - here we'll say local
340:12 - blockchain and vi romance
340:16 - equals and this will be a list we'll say
340:19 - development
340:20 - of course will be one but we can also
340:22 - say
340:23 - ganache
340:25 - local
340:26 - will be another and now we can import
340:28 - this local blockchain environments into
340:31 - our deploy so from at the top from
340:33 - scripts.helpful scripts
340:35 - do a comma here
340:36 - paste that and save
340:38 - mine gets reformatted which is really
340:39 - nice and instead we'll say if
340:42 - network.showactive
340:45 - not in
340:47 - local blockchain environments
340:49 - then go ahead and pull from the config
340:50 - what this is saying is it's saying if
340:53 - whatever network that we're on if it
340:55 - isn't development
340:56 - or ganache local
340:59 - then go ahead and use a config
341:01 - if it is one of these two
341:03 - we're gonna go ahead and deploy a mock
341:05 - here now that we have that let's try
341:07 - this again ronnie run scripts
341:10 - deploy.pi dash dash network
341:14 - ganache
341:16 - local and we run into a different issue
341:18 - we're saying hey you don't actually have
341:20 - enough gas well
341:22 - why is this let's look at our get
341:24 - account function aha this one is also
341:27 - looking directly for this development
341:29 - chain this one will say if
341:30 - network.showactive
341:32 - is in
341:35 - local blockchain environments then
341:37 - return accounts zero so we're saying if
341:39 - the network we're working on is
341:40 - development
341:41 - or our ganache local then just return
341:44 - accounts zero so let's try this okay
341:46 - we're getting closer now we're running
341:48 - to this key error of ganache local
341:50 - well we do know how to fix that as well
341:52 - in our config we'll add this new network
341:55 - we'll say ganache local
341:57 - and we'll set verify
341:58 - to false so let's try this one more time
342:01 - perfect now mocks have been deployed and
342:04 - our fundme has been deployed
342:06 - and if we look in our build folder in
342:08 - deployments we now have a new chain id
342:10 - for one three three seven for saving
342:12 - these deployments and it looks like in
342:15 - our ganache chain we have these actually
342:17 - saved in here which is great now an
342:19 - important thing to note if you were to
342:20 - close this or delete this ganache chain
342:23 - all of your contracts will be lost so
342:25 - you won't be able to interact with them
342:26 - again to account for this you can always
342:29 - delete 1337 and delete the entries in
342:33 - one three three seven from your map.json
342:36 - or if you're fine deleting the whole
342:37 - build folder you can delete the whole
342:39 - build folder so now that we've deployed
342:40 - this let's actually write a script to
342:42 - interact with this so let's create a new
342:44 - file we'll call it fund and
342:47 - withdraw
342:48 - dot pi
342:49 - and this will be the script we use to
342:51 - fund and withdraw so let's create a
342:53 - function called
342:54 - fund we can say fund me
342:57 - equals
342:58 - the most recently deployed
343:00 - fund me we have to do from
343:02 - brownie
343:04 - import fund me we're gonna have to get
343:05 - an account since we are gonna be making
343:07 - some state changes and we just have this
343:09 - equal to get account
343:11 - and we can do from
343:13 - scripts dot helpful scripts
343:17 - import
343:18 - get account
343:20 - let's get the entrance fee so we can
343:21 - figure out how much we want to fund
343:24 - actually sorry since this is going to
343:26 - resemble that fusd price feed it
343:28 - actually only has eight decimals two one
343:31 - two three four two thousand and one two
343:32 - three four five six seven eight
343:34 - the reason we want to do it like this
343:36 - too
343:36 - is because
343:38 - in our get price function we know that
343:40 - it only has eight decimal places so
343:42 - we're multiplying it by an additional 10
343:44 - here
343:45 - we want to resemble that as well so
343:47 - we'll do eight decimals starting price
343:49 - of 2000 with eight decimals here and for
343:51 - our mock v3 aggregator we're just going
343:52 - to use those exact values and we're not
343:55 - going to do the web 3 converting we're
343:56 - just going to make it exactly those
343:57 - hard-coded values now we're going to
343:59 - want to get the entrance fee so i've
344:01 - gone ahead and actually added a function
344:03 - called get entrance fee to our contract
344:05 - to make our lives a little bit easier
344:07 - here i'm going to recommend that you
344:08 - take a look at this and then
344:10 - type it in yourself or you just copy
344:12 - paste it from the github repository so
344:14 - that we can use this get entrance fee
344:16 - because it's just a whole bunch of math
344:17 - here so back in our fund and withdraw
344:19 - what we can do then is we can do
344:21 - entrance fee
344:24 - equals
344:25 - fund me dot get
344:27 - entrance fee
344:29 - excuse me get interested
344:32 - and we can even print out this entrance
344:34 - fee just to see if we're doing it right
344:36 - but first we're going to want to run
344:38 - brownie
344:39 - run scripts
344:41 - deploy
344:42 - network ganache local because we changed
344:45 - our fundry.soul
344:48 - all right great
344:50 - and now we can run brownie
344:52 - run scripts
344:54 - find and withdraw
344:56 - network
344:57 - local
345:00 - and whoops i need a main function so
345:02 - we'll do def main
345:04 - fund in here
345:06 - and let's rerun this
345:09 - and great we can see this is the
345:10 - entrance fee do a little print statement
345:12 - here printf saying the current
345:16 - entry fee
345:17 - is
345:20 - entrance fee
345:22 - we'll do a little print saying
345:26 - funding
345:28 - and then we'll call fundme.fund
345:33 - and of course we're going to do a from
345:36 - account
345:37 - and we're also going to send a value
345:40 - of
345:41 - entrance fee
345:45 - any low level transaction data that we
345:47 - want to send with our transactions and
345:50 - function calls we'll add in this little
345:51 - bracket piece here let's set up let's do
345:54 - brownie run scripts funder withdraw
345:56 - again
345:57 - and great it looks like it's going
345:58 - through perfectly
346:00 - awesome let's also do a withdraw
346:02 - function for the owner to withdraw
346:05 - we'll say fund me equals fund me
346:08 - minus one
346:10 - do account
346:12 - equals get account
346:15 - and then we'll just call fund me
346:17 - dot withdraw
346:22 - from
346:24 - account
346:27 - and then right after fund is called
346:29 - we'll have withdraw be called and our
346:30 - main function here
346:33 - let's go ahead and try this
346:35 - brownie run scripts
346:38 - find and withdraw
346:39 - network
346:42 - ganache local
346:47 - this is our funding script
346:49 - our funding transaction going through
346:51 - and then our withdrawal transaction
346:53 - going through perfect so it looks like
346:55 - our approximate functionality here works
346:57 - great and this is a script that we can
346:58 - run on a main network if we'd like
347:01 - now again it's still much better for us
347:03 - to run so now we're going to move into
347:06 - actually
347:07 - writing those tests and for these tests
347:10 - we're going to want to quit our ganache
347:12 - ui let's go ahead and write some of
347:14 - these tests create a new file
347:15 - called test
347:17 - fund me
347:18 - dot pi we'll quickly speed through this
347:20 - test because we're not going to learn
347:21 - too much new here keep in mind when
347:23 - we're on this test we're going to want
347:24 - it to be able to work independent of the
347:26 - network that we're working on so let's
347:28 - just keep that in mind let's do a test
347:30 - just to see if we can fund a withdrawal
347:31 - so we'll do def test
347:33 - can fund
347:34 - and
347:35 - withdraw
347:37 - and we'll do basically exactly what
347:38 - we've done before
347:40 - do account equals get account
347:42 - of course
347:46 - we'll do from scripts
347:47 - that helpful scripts
347:50 - import get account then we'll want to
347:52 - deploy fund me and we can even just use
347:56 - our deploy fund me script in our
347:57 - deploy.pi so we can do from
348:00 - scripts
348:01 - dot deploy
348:03 - import
348:04 - deploy
348:05 - fund me in our deploy fund me at the
348:08 - bottom we'll just say return
348:11 - fund me so that our test can now have
348:13 - this fundme contract for it to work with
348:15 - so now we'll say fund me
348:18 - equals
348:19 - deploy
348:20 - fund me
348:22 - grab the entrance fee
348:24 - which will be equal to
348:26 - fund me dot get
348:28 - entrance fee
348:31 - and then let's go ahead and fund it so
348:33 - do transaction equals fund me
348:36 - dot fund
348:38 - and we'll call from
348:40 - account
348:41 - we'll do value
348:43 - entrance fee
348:47 - we'll do tx.weight one
348:49 - we'll do an assert here we'll do assert
348:53 - fund me dot address
348:56 - to amount
348:58 - funded
349:00 - it's going to be account dot address
349:03 - it's going to be equal to the entrance
349:04 - fee
349:05 - so we want to check
349:07 - that our address
349:09 - and the amount that we funded is being
349:11 - adequately recorded and then we'll do
349:13 - transaction two will be fund me
349:16 - dot withdraw
349:20 - from
349:21 - account
349:24 - tx2.weight
349:26 - one
349:28 - and then we'll assert
349:29 - fund me dot address
349:32 - to amount funded
349:35 - account dot address
349:38 - equals zero
349:40 - and let's go ahead and run this test so
349:42 - we'll do brownie
349:44 - test
349:48 - and perfect looks like it's doing well
349:50 - now you may be wondering why sometimes
349:51 - we use the dash dash network flag and
349:54 - sometimes we don't in our network
349:56 - section brownie automatically picks a
349:58 - default network to use and the default
350:02 - is always set
350:04 - to development
350:05 - however we could set this to be anything
350:08 - that we wanted we could set the default
350:09 - to be ganache
350:11 - local we could set it to be rink b
350:13 - whatever we want it here whatever you
350:14 - set for the default in your brownie
350:16 - config is what the network will be
350:18 - defaulted to so right now when we run
350:20 - brownie test this is equivalent to
350:22 - running brand test dash dash
350:25 - network
350:26 - development we can even go ahead and run
350:28 - that too now we could also run this test
350:31 - on rink b and we will in a second but
350:32 - oftentimes we don't want to test all of
350:35 - our functionality on rink beat and on
350:38 - live networks because it's going to take
350:39 - a long time for them to run so sometimes
350:42 - we only want to run tests
350:44 - on our local chains well how do we do
350:46 - that we can use pi tests skip
350:49 - functionality to do so to work with pi
350:50 - test we're going to first need to
350:52 - install it so go ahead and run pip
350:54 - install pi test to demonstrate this
350:56 - let's create a test that makes sure only
350:59 - the owner can withdraw and nobody else
351:01 - can so we'll call this def test only
351:05 - owner
351:07 - can
351:08 - withdraw
351:09 - to skip this test if we're not on a
351:11 - local network we'll first check the
351:13 - network we'll say if
351:15 - network.showactive is not in
351:18 - and yep probably would have guessed it
351:20 - we're going to pull this local
351:21 - blockchain environments in from our
351:23 - helpful scripts so we'll do comma local
351:25 - blockchain environments
351:27 - and we're going to say if the network
351:29 - dot showactive
351:31 - is not in this list of local blockchain
351:34 - environments we're going to do pi
351:35 - test.skip
351:37 - and say only for local testing
351:42 - of course we're going to import network
351:48 - and we're also going to import pi test
351:51 - now if i try to run
351:52 - this test here
351:55 - with brownie
351:57 - test
351:58 - dash k
351:59 - dash dash network rinkeby it should skip
352:04 - perfect and we do see with this s here
352:06 - meaning that it's skipped this function
352:08 - if we run this
352:10 - with dash network
352:12 - development
352:13 - it should go ahead and run this and it
352:14 - will pass because nothing happens in
352:16 - this function and it does perfect let's
352:18 - keep going so now we'll say account
352:21 - equals get account
352:23 - we'll say fund me
352:25 - equals
352:27 - deploy
352:28 - fund me
352:29 - and now let's get a different account
352:32 - to try to call the withdraw function
352:34 - so we'll say bad actor
352:37 - equal and this will just give us a blank
352:40 - random account
352:41 - but we do have to import accounts
352:44 - from about here
352:45 - now we want to test to see that them
352:48 - calling this withdraw function actually
352:50 - reverts them and causes an exception
352:53 - because if i try to do
352:54 - fund me
352:55 - dot withdraw
352:58 - from
352:58 - [Music]
353:02 - bad actor right now
353:04 - what do you think will happen well that
353:06 - well we know in our fundme.soul our
353:09 - withdrawal function has the only owner
353:11 - modifier so technically only the owner
353:14 - should be able to call this function
353:16 - so what happens actually we don't even
353:18 - need this account get account bit let's
353:19 - just go ahead delete that so what
353:21 - happens if somebody else tries to call
353:24 - this withdraw function well let's go
353:26 - ahead and test this we'll do browning
353:29 - test
353:31 - dash k
353:33 - test only owner can withdraw
353:36 - hmm and you can see we're getting this
353:38 - error here writing
353:39 - browning.exceptions.virtualmachineerror
353:42 - revert from this fundme.withdraw well we
353:45 - want this to happen we were expecting
353:47 - this to happen so how do we test that we
353:49 - want this to happen well we just need to
353:51 - tell our test that we want this to
353:52 - happen
353:53 - so first we're going to import from
353:55 - brownie this exceptions
353:58 - package this way we can tell our test
354:01 - exactly what exception we're expecting
354:02 - to see then we'll say with
354:05 - pi test
354:06 - dot
354:07 - raises
354:08 - exceptions dot
354:10 - virtual machine error
354:14 - fund me
354:15 - dot withdraw
354:17 - and then we'll just actually we'll just
354:19 - copy this line down here
354:20 - now what this is telling our test is
354:23 - that if this reverts with this virtual
354:26 - machine error that's good we're saying
354:28 - we want you to revert when you try to
354:30 - call this line so if we delete this line
354:33 - and hit up and try to run this again
354:36 - we can see that it now passes and this
354:39 - is exactly what we're expecting so this
354:41 - is awesome all right we've learned a lot
354:43 - of fantastic tools for working with
354:45 - brownie here now the last version of
354:47 - testing that i want to show you how to
354:48 - use is mainnet forking maintenance
354:50 - forking is incredibly powerful when
354:52 - we're working with smart contracts on
354:54 - mainnet that we want to test locally so
354:56 - let's talk about forking for a minute so
354:59 - on the left here i have a blockchain
355:00 - right an example of a blockchain this is
355:04 - going to be like a test net
355:06 - like rinkaby
355:08 - or something like mainnet right this is
355:10 - going to be a blockchain that we
355:11 - actually deploy to
355:13 - now there are a whole bunch of blocks in
355:14 - here right and there's a huge chain that
355:17 - we can actually work with all this
355:19 - information is public information right
355:21 - this block is going to have like
355:24 - transaction
355:25 - transaction
355:28 - transaction
355:30 - it's going to have you know each one of
355:32 - these blocks is going to have a whole
355:33 - bunch of transactions and all this
355:35 - information is here in addition to all
355:37 - these transactions it's going to have
355:41 - price feed contracts
355:44 - ave contracts
355:46 - you know et cetera it's going to have
355:47 - all these different contracts in it so
355:50 - hypothetically if it's already there we
355:52 - should be able to basically copy this
355:55 - all this whole blockchain and do some
355:57 - simulations ourselves
355:59 - and that's exactly what forking does
356:02 - a forked blockchain literally takes a
356:05 - copy of an existing blockchain on the
356:08 - left here and brings it into our local
356:10 - computer for us to work with we actually
356:13 - have control of this blockchain since
356:15 - it's going to run on our local computer
356:17 - similar to ganache now all the
356:19 - interactions that we do on this local
356:21 - blockchain are not going to affect the
356:23 - real blockchain because it's our local
356:25 - chain right it's a simulated blockchain
356:27 - but because it's simulated we can go
356:29 - ahead and interact with price feeds we
356:30 - can interact with avid we can interact
356:32 - with all these different contracts that
356:33 - are already going to be on chain
356:35 - maintenance fork is a built-in part of
356:37 - brownie and also pulls from inferior the
356:39 - same way it works with rink b and coven
356:41 - and everything else we can start to
356:43 - interact with the mainnet fork contracts
356:45 - the exact same way therefore so we can
356:47 - take this whole ring big section
356:50 - copy it
356:51 - paste it
356:52 - and we'll just change this fusd price
356:55 - feed address
356:57 - to its mainnet address so we'll go to
356:59 - docs.chain.link
357:00 - ethereum price feeds
357:04 - get fusd here
357:06 - copy that
357:08 - and we'll paste it into here and we'll
357:10 - change this to mainnet fork and since
357:12 - this is going to be a fork of course for
357:14 - verify we're going to do false
357:17 - now if we try to run one of our scripts
357:19 - like brownie run scripts deploy.pi
357:22 - network
357:23 - mainnet fork
357:24 - you'll see we'll actually run into an
357:26 - issue here it's saying insufficient
357:28 - funds for transfer in our deploy script
357:32 - when we do our get account and our
357:34 - helpful scripts
357:36 - right now we're using accounts.ag config
357:39 - while it's from key yes it's going to be
357:41 - our account which right now has zero
357:43 - money in it on mainnet so brownies right
357:45 - away gonna say hey you don't have any
357:47 - money on mainnet what's the deal so we
357:49 - need to tell brownie that when we're
357:51 - working with mainnet fork it should
357:53 - create us a fake account with a hundred
357:55 - ethernet however
357:57 - we don't want it to deploy a mock
358:00 - because the price feed contracts already
358:02 - exist so we don't want it to deploy a
358:04 - mock but we do want it to get us an
358:07 - account here so typically what i like to
358:09 - do
358:10 - is i'll add another variable here and
358:12 - i'll call it
358:14 - forked
358:15 - local environments
358:19 - and i'll add
358:21 - maintenant fork in here and i'll use
358:23 - this now as part of my if statements
358:26 - so i'll say if network does show active
358:28 - in local blockchain environments or
358:32 - network dot show active
358:35 - in forked local environments then we're
358:38 - going to go ahead and return account 0.
358:40 - however
358:41 - in our deploy.pi mainnet fork is not
358:44 - going to be in this local blockchain
358:45 - environment so we will just get our
358:47 - price feed from our config so now if i
358:50 - run this maintenance fork again now if
358:52 - we run this you'll see we'll still get
358:54 - an error we'll get list index out of
358:56 - range so brownie's built-in forking
358:58 - mechanism doesn't actually come with its
359:01 - own accounts here however it has these
359:03 - issues so what normally i like to do is
359:05 - i like to create my own custom
359:07 - maintenance fork right in browning the
359:08 - way we can create our own development
359:10 - custom network is by using the brownie
359:12 - network's add key so
359:15 - we do brownie
359:17 - networks
359:18 - add
359:19 - we'll make this a development network
359:21 - instead of a persistent network
359:23 - and we'll call this
359:25 - mainnet fork
359:27 - dev
359:30 - to set this up we'll do a ganache cli
359:34 - so we'll say the command to run this
359:36 - fork is going to be ganache cli
359:39 - the host is going to be the same as
359:40 - always http
359:42 - dot
359:43 - colon slash 127.0.0.1
359:48 - fork is going to be equal to and this is
359:51 - where we just put https
359:54 - mainnet
359:56 - dot infira dot io
359:58 - v3
360:00 - slash
360:01 - web 3
360:03 - infira
360:05 - project
360:06 - id
360:08 - now don't hit enter quite yet i'm going
360:09 - to explain a couple things
360:11 - so this single quote means
360:14 - run this as is if we run this without
360:16 - the single quote our environment
360:17 - variable would get actualized here and
360:19 - we'd always have to use whatever our
360:21 - current environment variable is so we
360:23 - want to have this little semicolon here
360:25 - then we would do accounts equal 10
360:29 - this tells brownie for us to set up 10
360:31 - fake accounts for us we'll give it a
360:33 - mnemonic
360:34 - of brownie so we'll say great make those
360:36 - accounts just have a new monica brownie
360:39 - and we'll do a port equals eight five
360:41 - four five now once again don't hit enter
360:43 - quite yet i do wanna explain one other
360:45 - thing so this is great for working with
360:46 - inferior and forking from inferior
360:49 - however i have to note that performance
360:51 - wise forking forming fura has pretty
360:54 - much always given me an issue
360:56 - so i prefer actually to fork from this
360:59 - application called alchemy and in fact
361:01 - if you'd like you could set up all of
361:03 - your networks to work with alchemy by
361:05 - modifying them i'm going to go ahead and
361:08 - sign in here and we're going to give it
361:09 - an alchemy url instead of an inferior
361:12 - url so i'm going to go ahead and create
361:14 - an app
361:15 - i'm going to call this fund me
361:17 - demo
361:18 - description will also be a fund me demo
361:21 - via development environment on the
361:22 - ethereum mainnet let's create this we
361:25 - can now view the details of this we'll
361:27 - go to view key and we'll copy
361:30 - this http address
361:32 - and we'll move back over here and for
361:34 - forking
361:36 - we can just
361:37 - delete
361:38 - everything next to this fork
361:42 - and we'll just paste that in here
361:43 - instead and let's go ahead and hit enter
361:46 - you'll know you've done this right if
361:48 - you can see something like this mainnet
361:50 - fork dev has been added oftentimes in my
361:52 - example i will actually just delete
361:54 - maintenance fork
361:55 - and have mainnet fork dev be my default
361:57 - for maintenance for but for us we're
361:59 - going to go ahead and do mainnet fork
362:01 - dev
362:02 - so in our config
362:04 - we're going to change mainnet fork to
362:05 - mainnet fork dev
362:08 - so since we're giving this a different
362:09 - name
362:10 - that means in our helpful scripts
362:12 - we're gonna have to have do a comma here
362:14 - and say mainnet fork
362:17 - dev all right great now our get account
362:21 - should return accounts 0 for maintenance
362:24 - fork dev and it should actually work so
362:25 - let's run our script again brownie run
362:27 - scripts
362:29 - deploy dash dash
362:31 - network
362:31 - mainnet
362:32 - fork dev
362:35 - and perfect we're running our
362:37 - maintenance fork dev
362:38 - and it is running successfully
362:41 - now we should also be able to test
362:43 - exactly the same way let's look at our
362:45 - test real quick
362:46 - test fund me and see okay cool we're
362:48 - going to be skipping this one since main
362:50 - at fork forkdev isn't in the local
362:52 - blockchain networks but this should work
362:55 - perfectly and then oftentimes in my
362:57 - tests here i'll actually do like a
362:58 - little plus
362:59 - 100 or something for entrance fee just
363:02 - in case i need like a little bit more
363:04 - money for whatever reason so now if we
363:06 - run founding test dash dash network
363:08 - mainnet fork dev
363:10 - we'll see that this does indeed pass and
363:12 - this is awesome so this is fantastic
363:15 - incredibly powerful project here now
363:17 - we're going to teach you how to actually
363:19 - share your code and enter the world of
363:21 - open source and decentralized code the
363:23 - way the world works when sharing code
363:25 - and sharing ideas and collaborating
363:27 - together is they use what's called open
363:29 - source git repositories github is an
363:31 - example of one of these git repositories
363:33 - that we can use to share our code and
363:35 - it's one of the dominant ways that smart
363:37 - contract engineers share ideas and share
363:40 - code we are now going to learn how to
363:42 - add our code to github and then we can
363:45 - even share the code and show the world
363:47 - what we've built and what we've done
363:48 - this isn't going to be a full end-to-end
363:50 - git course however there are some links
363:52 - in the course repository that will show
363:54 - you how to work with git work with
363:56 - github and work with version control so
363:58 - the first thing that we're going to do
363:59 - is we're going to come to github and
364:01 - we're going to sign up for
364:03 - a service
364:04 - add our email
364:06 - create a password
364:09 - enter your username no now we'll go to
364:11 - our email to verify it
364:14 - continue we're going to be working with
364:16 - some collaborative coding we're going to
364:18 - choose the free edition and perfect we
364:20 - are now in github now that we're in
364:22 - github we're going to create our own
364:24 - first open sourced repository so we're
364:27 - either going to hit this plus button
364:28 - here or create repository let's choose a
364:32 - repository name for this we'll give it
364:33 - the same name as our main folder so call
364:37 - this brownie fund me give it a
364:39 - description maybe smart contract
364:43 - application
364:45 - and we'll hit create repository this is
364:47 - where we're going to upload our code to
364:49 - share with the world back in our vs code
364:51 - now we're going to send this folder to
364:53 - that repository first thing we need to
364:55 - do is installing git there are a couple
364:58 - different ways to install git depending
365:00 - on the version that you're on we'll put
365:01 - this link in the description to our
365:03 - course to actually install git once you
365:05 - have it installed you should be able to
365:06 - run git dash dash version
365:09 - and see a git version here now we're
365:11 - going to initialize our repository in
365:13 - here by doing git init
365:16 - we're going to choose a branch name
365:17 - we're going to call it main
365:19 - we'll go ahead and add our username and
365:22 - email to our git config user dot
365:25 - name
365:26 - quotes
365:27 - free
365:28 - code camp
365:30 - video
365:31 - git config
365:33 - user dot email
365:36 - free code
365:37 - camp
365:38 - video gmail.com
365:40 - now we're going to do a couple things to
365:42 - push all of our code to github here
365:44 - however remember we do not want to push
365:48 - our dot env pieces up here so we can do
365:50 - a couple of things we can a we can go
365:53 - ahead and delete this of course but we
365:55 - can also add in our dot git ignore file
365:58 - a dot env this will help us so that we
366:01 - don't accidentally push our dot env file
366:04 - to github we can choose what files we
366:06 - want to push by doing git
366:09 - add and then a period and if we do get
366:11 - status
366:12 - it will now show us all the different
366:14 - files that we have staged to push to
366:17 - github if we look in here we see we have
366:20 - git attributes git ignore browning
366:22 - config
366:23 - fund me some contracts some scripts but
366:25 - we do not have that dot emv file
366:29 - if you were to remove dot emv from dot
366:31 - git ignore and you ran git add dot again
366:34 - and then we did get status
366:37 - we now see the dot env in here
366:39 - we do not want this in here so we can do
366:42 - git
366:43 - remove dash dash cached
366:46 - dot e b
366:47 - we'll add
366:48 - dot env
366:50 - back to our dot get ignore file
366:53 - and then we'll run git status again and
366:55 - then we'll run git add period
366:57 - and then get status
367:00 - and great we do not see that dot env in
367:02 - here so that's very good now we'll
367:04 - commit this by git
367:06 - commit
367:07 - minus m
367:09 - first commit
367:13 - and now we can add
367:16 - this folder to our github back in our
367:18 - github there's a little line here which
367:20 - even tells us how to do it we're going
367:22 - to copy this line right here
367:24 - git remote add origin https free code
367:27 - camp brownie fund me i'm going to copy
367:29 - that
367:30 - paste it in here
367:32 - hit enter and now we can just do this
367:35 - second line
367:36 - git push dash u origin main we'll do git
367:40 - push dash u
367:42 - origin main we get an output like this
367:44 - and if we go back we'll now see all of
367:47 - our files and folders in here now i've
367:49 - already added my email and password in
367:51 - here but instead of this you'll probably
367:53 - get github asking you for authorization
367:56 - you can just go ahead and put your
367:57 - github username in and your password in
367:59 - there if your username and password
368:00 - doesn't work you can come into github go
368:03 - down to settings
368:05 - scroll down to developer settings
368:08 - personal access tokens and generate new
368:10 - token we'll call this f
368:12 - brownie and we'll want to give it at
368:14 - least repo authorization here and we'll
368:17 - hit generate token
368:19 - and instead of using your password you
368:21 - can go ahead and use this github token
368:24 - amazing and you now have your first
368:26 - github repository
368:29 - we could even come in here add some
368:30 - topics
368:32 - like solidity
368:33 - chain link
368:35 - python
368:36 - brownie
368:38 - etc so that we know what our file is
368:40 - about and this is incredibly exciting
368:44 - now i'm gonna even encourage you
368:46 - to pop onto twitter and share your
368:48 - excitement
368:50 - i just made
368:52 - my first first
368:54 - at
368:59 - thanks to at free code camp
369:03 - at
369:04 - solidity
369:08 - brownie s
369:11 - at chain link if you want to tag me you
369:12 - can also tag at patrick alpha c
369:16 - and pop your repo in there go ahead and
369:18 - hit tweet the community absolutely loves
369:21 - hearing about all the fantastic things
369:23 - people are doing in this ecosystem so be
369:25 - sure to reach out have fun and engage i
369:27 - know we've gone over a lot here but
369:29 - let's talk a little bit about some
369:31 - testing pieces here
369:33 - now a big question you might have is
369:35 - well okay so i learned a ton of stuff we
369:37 - learned about maintenance forking i
369:38 - could do stuff on ganache i can use
369:40 - brownies ganache i can use brownies main
369:42 - net fork there's
369:43 - i can do a test there's all these places
369:45 - to do stuff where do i need to run my
369:48 - tests the default for every single one
369:50 - of your contracts is as follows you
369:53 - always 100
369:55 - need to have tests that pass on a local
369:59 - brownie spun up ganache instance that
370:02 - should be priority number one to get all
370:04 - your tests to pass on this this means
370:06 - that you will need to deploy mocks after
370:09 - that the other place you absolutely need
370:11 - to have tests or do some type of
370:13 - development is on a test knob these are
370:16 - going to be what's known as your
370:17 - integration test and we'll talk more
370:18 - about those later so those are the two
370:20 - places you always need to have tests
370:22 - development and a test net
370:24 - i think testing on main net fork and
370:26 - your own local ganache are optional
370:29 - testing on mainnet fork can be done and
370:32 - probably should be done whenever all of
370:34 - your contracts and all of your
370:35 - interactions are going to be on chain on
370:37 - one chain without any external off-chain
370:39 - components testing on your own local
370:41 - ganache is really more meant for
370:43 - tinkering and kind of exploring and
370:44 - seeing things yourself so that's going
370:47 - to be the setup here so great now let's
370:49 - move into our most challenging example
370:51 - once you pass and once you complete this
370:53 - example you basically will have all the
370:56 - tools to be an incredibly powerful smart
370:59 - contract developer then after that we're
371:01 - going to show you the chain link mix
371:03 - package and how to do what's called a
371:04 - brownie bake to automatically open up
371:07 - this package with all these scripts and
371:09 - all these contracts pre-built in this is
371:11 - going to make our lives substantially
371:13 - easier and faster for deploying our
371:14 - smart contracts however let's go through
371:17 - the process of understanding all the
371:18 - pieces that are going to be inside of
371:20 - this brownie mix
371:21 - are you ready you should be let's get
371:24 - excited and jump in
371:29 - okay so let's get into our most advanced
371:31 - smart contract project that we've made
371:33 - so far this is going to be the best
371:35 - example of a full scale application and
371:37 - by full scale i really mean end-to-end
371:40 - full suite of our brownie all of our
371:41 - smart contracts are really solid here
371:43 - what we're going to want to do is create
371:45 - a lottery application where anybody can
371:48 - enter the lottery and a random winner is
371:51 - selected so let's get to it and let's
371:53 - get started so first of course
371:56 - we're going to make new directory
371:59 - we'll call it smart contract lottery
372:03 - cd and a smart contract lottery and then
372:05 - open that folder
372:10 - great we are now in our lottery
372:11 - application
372:13 - so let's go ahead and start a new
372:14 - project
372:17 - brownie init we've got our project here
372:19 - now let's create a quick readme.md
372:22 - to explain what we're going to be trying
372:23 - to do here so number one we're gonna say
372:25 - users can enter the lottery with f
372:29 - based on a usd fee
372:31 - so for example let's set the price to be
372:33 - like fifty dollars and the users
372:35 - actually pay with ethereum so we're
372:36 - gonna have to get that conversion rate
372:38 - number two an admin
372:41 - will choose
372:43 - when the lottery is over and then three
372:47 - lottery will select
372:50 - a random winner now something important
372:52 - to note here
372:53 - is since we have an admin here this
372:55 - means that our application isn't
372:57 - necessarily going to be truly
372:59 - decentralized because we have a single
373:01 - person chooses when the lottery is over
373:04 - we could scale this out to have maybe a
373:06 - dow being the admin or something like
373:07 - that
373:08 - or we could have the lottery
373:09 - automatically open and close based off
373:11 - some time parameters but for the moment
373:13 - this is the setup that we're going to
373:15 - have keep in mind even though this is
373:16 - much less decentralized it's still going
373:18 - to be a great use of smart contract
373:20 - technology so first thing that we're
373:22 - going to get started with of course is
373:23 - our lottery contract so create a new
373:26 - file
373:27 - called lottery
373:29 - dot sol and let's begin with our initial
373:31 - setup here so let's choose our version
373:34 - pragma
373:37 - solidity
373:38 - carrot 0.6.6
373:43 - and this will be the version that we
373:44 - want to work with here
373:46 - we'll do contract
373:49 - lottery
373:51 - bracket here now let's think for a
373:53 - second on what some of the functions
373:54 - that are going to be what our main
373:56 - functions are going to be here we'll
373:57 - probably have a function enter
374:01 - that'll be public
374:04 - we'll probably have a function
374:05 - get
374:07 - entrance fee
374:11 - to get the entrance fee of the
374:14 - lottery we'll probably have a function
374:17 - start lottery that only the admin can
374:19 - call this will be public as well which
374:21 - means we'll also probably have an end
374:23 - lottery function
374:27 - and those are really going to be the
374:28 - main functions
374:30 - the user can enter
374:31 - based off the entrance fee we can start
374:34 - the lottery and then of course we can
374:35 - end the lottery so let's get started
374:37 - with this enter function just because
374:38 - this is most likely going to be the
374:40 - entry point as we know since we're going
374:42 - to want them to pay
374:44 - using this entry function in ethereum
374:47 - we're going to need to make this
374:48 - function payable
374:50 - and in here we're going to need to keep
374:51 - track of all the different players
374:53 - everybody who signs up for this lottery
374:56 - to keep track of all the players we're
374:57 - going to make
374:58 - an address
375:00 - payable
375:02 - array
375:03 - we'll make it public call players
375:06 - and anytime somebody enters we'll just
375:08 - do player
375:10 - dot push
375:12 - message dot sender
375:14 - however right now we're not checking to
375:16 - see how much value that they're actually
375:17 - sending we want to set the price of this
375:19 - to be at least 50
375:21 - so we'll say 50 minimum so here we're
375:23 - gonna have to do a require statement
375:26 - requiring them to do at least 50
375:29 - in order to do that we're probably going
375:30 - to need to have some function to get the
375:31 - entrance fee to check whether or not how
375:34 - much they're sending is actually 50
375:37 - so let's go ahead and make that get
375:38 - entrance fee function now since we're
375:39 - just going to be returning a number for
375:41 - get entrance fee we can probably go
375:42 - ahead and make this a public view and
375:44 - have this return
375:47 - a u and 256.
375:49 - to get this entrancy we're first going
375:51 - to have to have stored somewhere what
375:53 - the entrance fee is we're going to store
375:55 - this 50 minimum somewhere this is
375:56 - something we'd probably want to set
375:58 - right when our contract is deployed so
376:00 - where can we put stuff like that
376:02 - well in our constructor we'll do
376:04 - constructor
376:07 - public
376:08 - we'll create a new variable
376:10 - outside here we'll call it un256
376:14 - public usd entry fee
376:20 - in our constructor we'll set usd entry
376:22 - fee equals
376:24 - 50. now because i like to have units of
376:26 - measure always in way we'll also do
376:28 - times
376:29 - 10
376:30 - raised to the 18th
376:32 - now we have some usd entry fee let's go
376:34 - ahead and get this entrance fee as we
376:36 - know since we're going to try to get a
376:37 - conversion rate here we're going to want
376:39 - to use a chain link price feed
376:41 - so
376:42 - we can head on over to docs.chain.link
376:44 - we'll scroll down to get the latest
376:46 - price
376:47 - and we can even just go ahead and copy
376:49 - paste this again
376:50 - but for the sake of robustness let's
376:52 - just walk through again how to actually
376:54 - set this up we're going to need to pull
376:56 - from the price feed to convert fifty
376:58 - dollars to fifty dollars in each
377:02 - so let's go ahead and create an agra
377:04 - gator v3 interface
377:09 - internal
377:10 - f usd
377:12 - price feed
377:13 - and in our constructor
377:15 - we'll go ahead and set this we'll say
377:17 - fusd price feed
377:19 - equals
377:22 - ag redgate tor v3 interface
377:25 - and we're going to want to grab an
377:27 - address
377:28 - from our contract addresses but of
377:30 - course as you know as we've learned from
377:32 - last time we're going to want to
377:33 - parameterize this so we're going to want
377:35 - to pass the address of our price feed as
377:38 - a constructor parameter
377:40 - so we'll do address
377:43 - price
377:44 - feed
377:45 - address
377:47 - and we'll have our aggregator v3
377:49 - interface
377:50 - we passed that price feed address then
377:52 - of course since we're using an
377:54 - aggregator v3 interface we're gonna have
377:55 - to import this
377:57 - from chain link
377:58 - so we can just go ahead and copy this
378:00 - from the documentation
378:02 - and paste it right at the top
378:05 - or if you want to rewrite it out
378:07 - yourself feel free to do so
378:09 - and of course since we're doing this
378:10 - import here
378:12 - new file
378:14 - browning config.
378:17 - we're going to want to add this as a
378:19 - dependency so we'll do d
378:21 - pendancies
378:25 - smart contract kit
378:27 - chain link
378:29 - browning contracts
378:30 - and we'll do add 1.1.1 again
378:34 - and then compiler
378:37 - sulk
378:38 - remappings
378:43 - we'll say at chain link
378:45 - equals
378:48 - this right here
378:50 - we'll pull up our terminal
378:53 - and we'll try this out do brownie
378:55 - compile see if we're doing everything
378:57 - right we forgot an spdx license
378:59 - identifier
379:00 - which is just a warning but let's add it
379:02 - in anyways
379:05 - spdx
379:09 - license
379:10 - identifier
379:12 - mit i should probably spell me
379:14 - remappings right
379:17 - mappings
379:18 - and let's try to compile again
379:20 - all right lovely so we at least know
379:22 - that
379:23 - we are compiling correctly here awesome
379:26 - so now that we have a price feed let's
379:27 - go ahead and set up this entrance fee so
379:30 - we're of course going to need to get a
379:31 - price from this price feed so we can
379:33 - even check the documentation how to do
379:35 - that
379:36 - we can call this latest round data
379:38 - function
379:38 - so we could copy paste it i'm just going
379:40 - to go ahead and rewrite it but again we
379:43 - don't need round id started at timestamp
379:46 - or answered in round we only need price
379:48 - so we can go ahead and ignore these
379:49 - variables on our call
379:51 - so what we'll do is we'll do blank comma
379:56 - into price
379:59 - and then
380:00 - comma comma comma
380:04 - equals
380:08 - fusd price feed dot latest
380:11 - round data
380:14 - and this means we're just going to get
380:15 - the price here now we're going to want
380:17 - to do a little bit of quick math
380:18 - typically if we're setting the price at
380:19 - 50
380:21 - and we have
380:22 - a price feed of two thousand dollars per
380:24 - eth
380:26 - we would just wanna do
380:28 - fifty divided by two thousand
380:31 - but of course since solidity doesn't
380:33 - work with decimals we can't actually
380:34 - just do this
380:36 - so we'll have to do
380:38 - 50
380:39 - times
380:40 - some big number divided by the 2000 so
380:43 - we're going to go ahead and do it like
380:44 - that but first let's go ahead and
380:47 - convert this price from into 256 to uint
380:50 - 256.
380:52 - so we'll say
380:54 - you went 256
380:56 - adjusted price
380:58 - equals
381:00 - you went 256.
381:04 - you in 256 price
381:08 - and then
381:10 - since we know
381:12 - we're going to be using an ethereum usd
381:14 - price feed that has eight decimals
381:16 - let's also just convert it to having 18
381:18 - decimals as well
381:20 - so we can also do times 10
381:22 - raised to the 10th
381:25 - so now we can have 18
381:27 - decimals
381:29 - now that we have this adjusted price
381:32 - we'll do um 256
381:34 - cost to enter
381:36 - it's going to equal
381:38 - usd
381:40 - entry fee
381:41 - times
381:42 - again we're going to want to times it by
381:44 - some big number here so we'll just times
381:45 - it by 10 raised to the 18th
381:49 - this way usd entry fee
381:51 - has 18 decimals but it has an additional
381:53 - 18 decimals here that'll be canceled out
381:56 - with our price feeds and the math will
381:57 - work divided by price
382:01 - and then we'll return
382:03 - cost to enter
382:06 - now of course since we're doing some
382:07 - interesting math here it's recommended
382:10 - to use safe math and use safe math
382:11 - functions we're going to skip over the
382:13 - safe map functions here again because in
382:15 - the newer versions of solidity you don't
382:17 - really have to use them but i think it's
382:19 - important to note here that sending this
382:21 - code this exact code to production would
382:23 - be a bad idea for at least the reason of
382:26 - the safe math functions but in any case
382:28 - we have a function here we think our
382:30 - math is pretty good but i know for a
382:32 - fact that my math is usually not very
382:34 - good so let's go ahead and do some
382:36 - testing as we code just to make sure our
382:39 - get entrancy function is working
382:41 - properly so based off of our last lesson
382:43 - let's talk about
382:45 - how do we want to test
382:48 - this
382:50 - well we could do a main net fork here
382:54 - because we're only working with some
382:56 - on-chain contracts and some math we will
382:58 - at some point have to do our develop
383:00 - mint
383:02 - with marks
383:05 - and of course our test net
383:07 - i kind of want to just do a quick and
383:09 - dirty way so let's try our maintenance
383:11 - fork just for now just to see if
383:13 - if this is really making any sense if
383:15 - the current price of ethereum is 2 500
383:19 - or this much here
383:21 - and we want the price of this to be
383:23 - fifty dollars we do 50 divided by this
383:26 - and we get
383:28 - .019 so this should be approximately
383:32 - what we get for our eat value so if we
383:34 - were to write a test
383:36 - test
383:38 - lottery dot pi
383:40 - if we were to test this function we
383:42 - would expect to get 0.019
383:47 - or in way it'll be 1 9
383:50 - 1 2 3 4 5 six seven eight nine ten one
383:52 - two three four five six
383:54 - we expect to get approximately this so
383:57 - let's go ahead and create a function
383:58 - that tests us so we'll do test get
384:02 - entrance fee
384:05 - and here we'll deploy lottery
384:07 - and in here the first thing we need to
384:09 - do is deploy this lottery function of
384:11 - course so we'll do from
384:13 - brownie
384:14 - import
384:16 - lottery
384:17 - in order to deploy this we're going to
384:19 - need to get an account
384:23 - we are going to import our helpful
384:24 - scripts from the last project to this
384:26 - one too so we can get our get accounts
384:28 - but for the time being
384:30 - we can actually just use accounts 0 from
384:32 - brownie so we'll say count zero
384:35 - let's start with def then we'll do
384:37 - lottery equals
384:39 - lottery dot deploy
384:42 - from
384:44 - account
384:46 - and ah of course we have a parameter
384:49 - here of our price feed address
384:52 - so we're gonna have to add
384:54 - some type of parameter here for now
384:56 - let's just hard code it from our config
384:59 - and we'll go into our config and we'll
385:00 - start our networks flag
385:03 - we're going to be working like i said on
385:04 - the maintenance fork for this quick and
385:06 - dirty here
385:07 - we'll call f
385:09 - usd price feed
385:12 - grab the fusd price feed
385:15 - from mainnet since we're going to be
385:16 - doing a main net fork here
385:19 - pop that in here
385:24 - now we can just say
385:27 - from config
385:33 - networks
385:37 - network dot show active
385:44 - usd
385:46 - price feed
385:54 - of course we're going to need to import
385:55 - network here
385:57 - and now we can do our kind of quick and
385:59 - dirty test we can do lottery
386:01 - dot
386:02 - get entrance fee
386:05 - am i spelling that right get entrance
386:07 - fee
386:09 - yes
386:12 - assert
386:14 - lottery.get entrance fee should be
386:16 - greater than
386:18 - let's just say let's just go down 18
386:23 - or if we wanted to make sure we're
386:24 - actually doing this right we'll do from
386:27 - three import
386:28 - web three
386:31 - we'll do web3.2 way
386:34 - 0.019
386:38 - comma ether
386:42 - should be greater than
386:43 - and then we'll
386:44 - even do
386:46 - 0.018 just to make sure
386:48 - and it should be less than
386:52 - 0.01
386:56 - now these numbers are of course going to
386:57 - be a little bit different for you
386:59 - and if you want you can go ahead and
387:00 - skip this part so that you don't have to
387:02 - do the math but it is kind of nice to do
387:04 - a quick sanity check saying okay like
387:06 - based off what things are right now what
387:07 - would this price end up to be now in our
387:09 - last section we made a mainnet fork dev
387:13 - network
387:14 - i'm going to just go ahead and customize
387:16 - our mainnet fork the way that we showed
387:18 - you guys how to do maintenance fork dev
387:19 - this way you can use accounts and we can
387:21 - be a little bit more robust here
387:23 - to do this we're first going to have to
387:24 - delete brownie's internal built-in
387:26 - mainnet fork
387:28 - so we'll do brownie
387:30 - networks
387:31 - delete
387:33 - mainnet fork
387:35 - maintenance fork has been deleted
387:37 - and now let's go ahead and add our own
387:40 - maintenance fork using alchemy
387:45 - as our ethereum connection
387:49 - so you'll want to create a new app i've
387:51 - already created one here called smart
387:52 - contract lottery
387:54 - we'll view the key
387:55 - and this is the http endpoint that we'll
387:58 - use
387:58 - so to do this we'll do brownie
388:01 - networks
388:02 - add this will be a development chain
388:04 - we'll call this
388:06 - maintenant fork
388:08 - it'll be a ganache cli
388:12 - the host is going to be our local host
388:14 - so 127.0.0.1
388:18 - and the fork is going to be equal to
388:23 - our alchemy http here
388:27 - we'll do accounts equal 10 that way we
388:29 - can use the accounts
388:31 - do the new monarch
388:34 - equals brownie
388:37 - import is going to be eight five four
388:39 - five
388:42 - and great maintenance fork has been
388:44 - added now that we have this here we can
388:46 - go ahead and run our test
388:48 - brownie
388:50 - test dash dash network
388:53 - mainnet fork
388:57 - whoops looks like we got a little
388:59 - compile error on our math here
389:01 - oops it looks like we're divided by
389:02 - price when we need to be divided by
389:05 - adjusted price and we forgot the
389:07 - parentheses on latest round data
389:10 - let's try this again
389:14 - and i put an extra comment in here
389:16 - let's try this one more time
389:20 - lovely and it looks like we're forking
389:22 - correctly
389:24 - and awesome it looks like our test
389:25 - indeed passes here
389:27 - of course we know that we're going to
389:28 - want to change this because this isn't a
389:29 - great way to actually test our contracts
389:31 - here but it can be a nice sanity check
389:34 - and we know we're going to have to
389:35 - refactor this as well
389:37 - for mocks and for accounts
389:39 - but we'll get to that in a little bit
389:41 - awesome sanity check complete let's get
389:43 - back to our contract here
389:45 - so we are getting the cost to enter
389:47 - correctly perfect we're getting this
389:49 - entrance fee what that means we can do
389:52 - in our enter function we can do require
389:56 - message.value
389:57 - it's got to be greater than or equal to
390:01 - our get entrance fee function
390:07 - and if it's not
390:09 - give them an error of not
390:11 - enough
390:12 - eath
390:15 - we have a way for them to enter and we
390:16 - have a way to get the entrance fee but
390:18 - we want to make sure that we're not
390:20 - ending the lottery before the lottery
390:22 - even starts right or we're not entering
390:24 - a lottery when a lottery hasn't even
390:26 - begun so we're going to want a way to
390:28 - iterate through the different phases of
390:30 - this lottery and we can do that with
390:31 - what's called an enum or an enum
390:33 - according to the solidity documentation
390:35 - enums are another way to create
390:37 - user-defined types in solidity
390:40 - we saw an earlier version of doing this
390:43 - with a struct enums are a little bit
390:45 - different in that they're explicitly
390:47 - convertible to and from all integer
390:50 - types so what does that actually mean
390:52 - well
390:53 - we can have an enum
390:54 - like this action choices go left go
390:57 - right go straight and sit still they're
391:00 - just more readable ways to say
391:02 - go left is going to be represented as
391:04 - state 0 go right it's going to be state
391:06 - 1 go straight state 2 sit still state 3.
391:10 - so for our lottery contract we're going
391:12 - to want to create
391:14 - this new type that represents the
391:15 - lottery state so to do this we'll do
391:18 - enum
391:20 - lottery state open
391:23 - closed
391:26 - and calculating winner
391:28 - this means that we have a new type
391:31 - called lottery state with three
391:33 - positions open closed and calculating
391:36 - winner these different states are
391:37 - actually represented by numbers so open
391:40 - is actually a zero
391:41 - closed is actually one and calculating
391:43 - winner is actually a two now that we
391:46 - have this new type we can create a
391:48 - variable of type lottery state so we'll
391:50 - say
391:51 - lottery state
391:54 - public
391:55 - lottery state
391:57 - and right when we initialize our
391:59 - contract here we're going to want to set
392:00 - our lottery state to being closed
392:03 - so in our constructor we'll do lottery
392:05 - state
392:06 - equals
392:09 - lottery state
392:10 - dot closed
392:12 - now since these are represented by
392:14 - numbers as well we could also just do
392:16 - lottery state equals
392:18 - 1
392:19 - because 1 stands for closed however it's
392:22 - much more readable to do
392:23 - lotterystate.closed
392:25 - now that we have a lottery state
392:28 - in our enter function we can require
392:32 - that the lottery state
392:35 - is going to be
392:36 - equal to
392:38 - lottery state
392:39 - dot open
392:41 - so we can only enter if somebody's
392:43 - started this lottery and that's exactly
392:46 - what we're going to do in our start
392:47 - lottery function
392:49 - we're going to do a require in here
392:52 - that the lottery state
392:54 - is going to be equal to
392:56 - lottery state dot closed
393:00 - we can even add
393:02 - a failure function here
393:04 - saying
393:07 - can't start
393:08 - a new
393:10 - lottery yet
393:11 - and when we do start this lottery we'll
393:13 - say lottery
393:14 - state
393:16 - equals
393:17 - lottery state dot open
393:20 - now when somebody starts the lottery
393:23 - they'll be able to
393:24 - enter of course this
393:27 - start lottery bid here needs to be
393:29 - called only by our admin so this is
393:32 - where our
393:33 - only owner modifier is once again going
393:36 - to come into place we could write our
393:38 - own only owner modifier or we can once
393:41 - again use open zeppelin's access control
393:44 - and open zeppelin's ownable function
393:46 - instead which is what i'm going to use
393:47 - here so we're going to go ahead and grab
393:49 - this
393:50 - copy this
393:51 - paste it in
393:54 - import at open zeppelin contracts slash
393:57 - access ownable
393:59 - and of course since we're doing this
394:02 - we're gonna have to add this dependency
394:04 - into our config
394:06 - we're gonna be using
394:07 - open
394:10 - zeppelin
394:11 - open
394:13 - zeppelin
394:14 - contracts at 3.4.0
394:19 - we're going to remap
394:22 - at
394:23 - open
394:24 - zeppelin equals
394:27 - this
394:29 - oops
394:33 - and then we'll say our lottery is
394:36 - ownable
394:39 - perfect
394:40 - now we'll try to compile this
394:44 - awesome looks like brownie grabbed
394:46 - everything correctly and we're good to
394:48 - go great
394:49 - now we can finally move into our end
394:51 - lottery function
394:53 - this is where we're actually going to
394:54 - choose a random winner here
394:56 - we only want the admin to be the one to
394:58 - actually end the lottery so let's add
395:00 - the only owner modifier here
395:02 - and let's talk a little bit about
395:04 - randomness because this is what we're
395:05 - looking to do now we're looking to get a
395:07 - random winner here now as you know the
395:09 - blockchain is a deterministic system
395:12 - right and this is super ambitious
395:13 - because that allows us to do all these
395:15 - smart contracts and have this system
395:18 - that can actually reach consensus very
395:19 - easily random numbers are much harder if
395:22 - let's say you had a blockchain with a
395:23 - whole bunch of different nodes and each
395:24 - node responds and gives their own random
395:27 - value well each node is never going to
395:29 - be able to sync up and say hey you know
395:31 - we all agree on a random number what you
395:32 - could do is you could base the random
395:34 - number on some other attributes in the
395:36 - system
395:37 - but then it's not really random it's
395:39 - actually going to be pseudorandom so
395:41 - getting truly random numbers in a
395:43 - deterministic system is actually
395:45 - impossible and if you know a lot about
395:47 - computer science you actually know that
395:49 - even when you call like math.random in
395:51 - your javascript what your computer is
395:53 - really doing is it's looking at some
395:54 - place in memory grabbing some value and
395:56 - saying hey this is probably random
395:59 - enough here go ahead and use this now in
396:01 - smart contracts especially when working
396:03 - with any type of financial application
396:05 - such as a lottery having an exploitable
396:07 - randomness function means that your
396:09 - lottery is at risk of being hacked or
396:12 - destroyed and this isn't even a fairy
396:14 - tale at the time of recording about two
396:16 - weeks ago i did a rundown on an exploit
396:18 - where a protocol used insecure
396:20 - randomness and got hacked for seven
396:22 - hundred thousand dollars so i am going
396:24 - to show you this insecure way first and
396:26 - the reason that i'm going to show you is
396:27 - that it is a quick and dirty way to get
396:29 - a pseudo random number but please do not
396:32 - use this in any production use cases i'm
396:35 - going to show you a method that's often
396:36 - used to teach people how to get random
396:38 - numbers and then we're going to explain
396:40 - why it's so vulnerable and not a good
396:42 - method of randomness and what some
396:44 - insecure protocols will do is they'll
396:46 - use a globally available variable and
396:50 - hash it so in your smart contracts
396:52 - there's actually a number of globally
396:53 - available variables one of those as we
396:56 - saw above
396:58 - is going to be message.value right it's
397:00 - going to be the value that's sent with
397:01 - the transaction another globally
397:03 - available variable is going to be
397:05 - message.sender
397:07 - you can actually see a whole list of
397:08 - these different globally available
397:10 - variables in the solidity documentation
397:13 - here so since there are these globally
397:15 - available variables a lot of times some
397:17 - will see something like block.difficulty
397:20 - which returns the current block
397:22 - difficulty
397:23 - now one of these globally available now
397:25 - one of these globally available
397:27 - variables is going to be block
397:28 - difficulty or block dot difficulty it's
397:30 - the current block difficulty remember
397:32 - how i said that the time between
397:34 - different block generation is called the
397:36 - block time
397:37 - well you can always keep that block time
397:39 - as is by changing the block difficulty
397:42 - over time the harder the problem or the
397:45 - harder the proof of work algorithm
397:47 - the longer it's going to take or the
397:49 - more nodes you're going to need to solve
397:51 - that problem there's this constantly
397:53 - recalculating metric called ethereum
397:55 - difficulty or block difficulty depending
397:57 - on the chain that you're working on that
397:59 - constantly changes
398:01 - so you might think this would be a great
398:03 - use of randomness right because it's a
398:06 - somewhat hard to predict number so what
398:09 - a lot of people do is they think that
398:11 - hey those sound pretty random let's use
398:14 - them as a unit of randomness and what
398:16 - you'll see is you'll see like something
398:17 - like uint
398:24 - 256 which is
398:26 - again this hashing algorithm
398:29 - let's do something like abi dot encode
398:31 - pact
398:50 - so i know there's a whole lot going into
398:52 - this line and let's talk about it
398:54 - so first as we can see
398:56 - is that we're casting or we're
398:58 - converting everything in here to being a
399:00 - uni-256 the reason that we're doing this
399:03 - of course is because we're going to want
399:04 - to pick
399:05 - a random winner based off of an index
399:08 - right we're going to want to pick
399:09 - somebody some random winner in our
399:11 - players array or our players list
399:14 - so we say okay whatever number that
399:16 - we're going to use that's going to be
399:17 - the index of the winner that we're going
399:19 - to randomly pick
399:20 - then they use cache 256 which is again
399:22 - our hashing algorithm so they hash a
399:24 - whole bunch of variables together
399:27 - and they do this abi dot encode packed
399:29 - api is another keyword
399:31 - for some low-level work
399:33 - and they'll add maybe a nunsen they'll
399:35 - add the message on sender
399:37 - block that difficulty and block the
399:39 - timestamp basically what they're trying
399:40 - to do here is take a bunch of seemingly
399:43 - random numbers
399:44 - mash them all together in a hashing
399:46 - function and then say yeah this this is
399:48 - pretty random but the issue here is that
399:50 - the hashing function itself isn't random
399:52 - the hashing function is always going to
399:54 - be exactly the same could check 256 it's
399:56 - always going to hash everything exactly
399:58 - the same way so we're not actually
400:00 - making it more random by hashing it all
400:02 - these numbers inside are the pieces that
400:05 - actually determine how random it is so
400:07 - if the block to difficulty is random
400:09 - then this will be a random method if the
400:11 - blocked out difficulty isn't random then
400:12 - this won't be a random method and the
400:15 - blocked difficulty is not random
400:17 - difficulty
400:19 - can actually
400:20 - be manipulated by the miners
400:25 - in time stamp
400:27 - timestamp is predictable
400:29 - nuns is predictable
400:31 - aka
400:33 - transaction number because in this
400:34 - regard they're using the nuns as some
400:36 - transaction number
400:38 - and message.sender
400:41 - is predictable
400:44 - when using a random number in this way
400:47 - the hashing algorithm is always going to
400:48 - be the same union 256 is always going to
400:51 - be the same we have a predictable number
400:53 - a predictable address
400:56 - a predictable timestamp
400:59 - and then a manipulatable value
401:01 - so all this is really doing is giving
401:04 - the miners the ability to win the
401:06 - lottery or win whatever lottery that
401:08 - you're working on
401:09 - so this isn't going to be an effective
401:11 - way to get a random number this is an
401:13 - unacceptable way to get a random number
401:15 - in our applications yes we do have this
401:17 - only owner modifier here which means
401:19 - that we are the ones who are going to
401:21 - choose when to call this so it is still
401:22 - centralized in that regard
401:24 - but let's just teach you the best
401:26 - practices for working with random
401:27 - numbers right from the get-go so you
401:29 - don't run into any issues
401:31 - i'll explain what this part is doing in
401:32 - a little bit in order to get a true
401:34 - random number we are going to have to
401:35 - look outside the blockchain the
401:37 - blockchain itself like i said is a
401:39 - deterministic system so we need a number
401:41 - outside the blockchain but what we can't
401:43 - do is we can't use just an api that
401:46 - gives a random number right if that api
401:48 - becomes corrupted if they're malicious
401:50 - if they go down if something happens
401:52 - etcetera what we need is a provable way
401:55 - to get a random number and chain-link
401:57 - vrf is actually that solution chain-link
401:59 - vrf it stands for chain-link verifiably
402:01 - randomized function and it's a way to
402:03 - get a provably random number into your
402:06 - smart contract it has an on-chain
402:07 - contract that checks the response of a
402:10 - chain-link node to make sure the number
402:12 - is truly random using some cryptography
402:15 - magic it's able to check a number of the
402:17 - parameters that the chainlink vrf
402:19 - started and ended with to make sure that
402:21 - it's truly random it's already used for
402:23 - protocols like avagochi
402:25 - ethercards pool together and a whole
402:28 - bunch of other protocols as well because
402:29 - it is a secure reliable truly provable
402:32 - way to get a random number which is
402:34 - incredibly powerful in a decentralized
402:35 - system so that's how we're actually
402:37 - going to get our random number here so
402:39 - let's work on getting that
402:41 - what we can do is we can go ahead and
402:43 - head right over to the chain link
402:44 - documentation to actually learn how to
402:46 - work with one of these let's go over the
402:48 - chain link documentation just to make
402:50 - sure that we get it right so if we go to
402:52 - the get a random number here
402:54 - we have all the documentation you could
402:56 - ever want so if you ever get lost or
402:57 - confused you can always come right back
402:59 - here to work with it what we're going to
403:01 - do is we're going to deploy their simple
403:03 - version in remix version of working with
403:06 - the chainleaf vrf and we're going to
403:08 - walk through a minimalistic contract to
403:10 - see how it actually works in a contract
403:14 - so once again we hit this remix button
403:16 - remix pops up and we immediately get
403:18 - this random number consumer.soul
403:21 - in our files that we can check out so
403:23 - awesome so here is our files right here
403:26 - we can see that this is actually using a
403:28 - different chain than what we've been
403:30 - using we've been mostly working with
403:32 - rink b
403:33 - but for this demo it's actually on coven
403:36 - so we can do some work with kovin here
403:38 - and remember if you do want to stay with
403:40 - rink b you can always go to this
403:42 - contract addresses section of the vrf
403:46 - and grab these addresses to use so
403:49 - what's going on in this contract how do
403:52 - we actually use this well as you can see
403:54 - the first thing that happens is we're
403:56 - importing some code from the chain link
403:58 - package and our contract is inheriting
404:01 - the abilities of this vrf consumer base
404:03 - contract so we're going to see what
404:05 - functions we're actually going to use
404:06 - that are inherited from this contract
404:08 - and the first thing that we notice is we
404:10 - can see that our constructor in here
404:12 - does some weird stuff
404:15 - it looks like it almost has two
404:16 - constructors
404:18 - so what's actually going on here well
404:20 - let's look at this vrf consumer
404:21 - base.cell contract in the chain link
404:23 - github
404:26 - so we can come to the chain link github
404:28 - here
404:30 - we'll go to evm contracts or depending
404:32 - on when you're watching in this it's
404:33 - migrating to contracts at some point
404:35 - we go to evm contracts we'll go to src
404:38 - so once we're using v0.6 we'll go there
404:42 - and we'll look at this vrf
404:43 - consumerbase.sol
404:45 - as we can see this vrf consumer base
404:47 - that we're importing has its own
404:49 - constructor and it takes an address for
404:52 - the vrf coordinator this is the on chain
404:54 - contract that actually checks to make
404:55 - sure our numbers are random and the
404:57 - address of the chain link token which
404:59 - we'll talk about erc20s in a little bit
405:01 - what we're doing is we're also
405:02 - inheriting the constructor into our
405:04 - contract
405:05 - so this is our constructor for our
405:08 - random number consumer but we can also
405:10 - use the constructor of the vrf consumer
405:12 - base
405:13 - and this is actually how we go ahead and
405:15 - do that we grab the constructor of the
405:17 - vrf consumer base and pop it in here
405:20 - now it's taking two addresses it's
405:22 - taking the vrf coordinator
405:24 - and the link token like i said the vrf
405:27 - coordinator is a contract that's been
405:29 - deployed on chain that's going to verify
405:31 - that the return of the chain link node
405:33 - is truly random and we're going to use
405:35 - the link token as a payment to the chain
405:38 - link node for its services and then we
405:40 - also have a key hash and a fee defined
405:43 - inside of this constructor as well the
405:45 - key hash uniquely identifies the chain
405:48 - link node that we're going to use and
405:49 - then the fee is how much link we're
405:51 - actually going to pay to the chain link
405:52 - node for delivering us this random
405:54 - number now let's talk about a couple
405:56 - things here
405:57 - in ethereum whenever you make a
405:58 - transaction you have to
406:00 - pay some eath gas
406:03 - right or transaction gas
406:07 - this is to pay the smart contract
406:08 - platform a little bit of eth for
406:10 - performing our transaction with a smart
406:12 - contract with a smart contract that
406:14 - operates with an oracle we have to pay
406:16 - some link gas or oracle gas
406:19 - this is to pay the oracles a fee for
406:22 - their services for providing data or
406:24 - doing some type of external computation
406:26 - for a smart contract the question that
406:29 - might then follow up is oh okay well how
406:32 - come i didn't have to pay
406:33 - when we did this price feeds thing
406:36 - well for price feeds
406:39 - somebody had actually already paid
406:41 - for the data to be returned and if we go
406:44 - to data.chain.link and we scroll down we
406:46 - can actually see a list of sponsors here
406:48 - that are paying to get this data
406:50 - delivered so they're already paying the
406:52 - oracle gas to bring this data on chain
406:54 - for us since no other protocol is
406:57 - getting a random number for us we're
406:59 - actually going to have to pay the oracle
407:00 - gas here now in this contract we have a
407:03 - function called get random number which
407:05 - is going to return a bytes 32
407:08 - and what it's going to do it's going to
407:09 - call this request randomness function
407:11 - which is inherited from this vrf
407:14 - consumer base if we look in here
407:16 - we look for request
407:19 - request randomness we can see there's a
407:21 - function right here
407:23 - called request randomness this function
407:25 - is going to send our oracle fee or the
407:28 - link token
407:29 - and it's going to call this
407:31 - specific to the link token function
407:33 - called transfer and call
407:35 - this function is going to call a chain
407:36 - link node now i'm not going to talk now
407:38 - i'm not going to go into exactly how
407:40 - it's doing that right now but we will
407:42 - talk about it in a little bit so we call
407:44 - this request randomness function
407:46 - and we send the key hash and the fee
407:49 - remember the key hash uniquely
407:51 - identifies the chain link node
407:53 - and the fee is going to be how much
407:55 - oracle gas we're going to pay if you
407:57 - ever get lost on how much to pay or what
407:59 - the contract addresses are you can
408:01 - always head over to this vrf contract
408:03 - section and see where the most recently
408:05 - deployed
408:06 - vrfs are how much the fee is etcetera
408:10 - now here's where it gets a little bit
408:11 - interesting
408:12 - getting a random number actually follows
408:14 - what's called the request and receive
408:16 - style of working with data let's go
408:18 - ahead and just try this out and i'll
408:20 - explain what this means once we see it
408:23 - now we're going to save the answer to
408:24 - this random result variable here and
408:27 - let's just go ahead and try this and see
408:29 - what happens
408:30 - so we're going to switch to our injected
408:32 - web 3 and since we're now swapping to a
408:34 - new test network this means that we have
408:36 - to get tested eth and test that link
408:38 - again
408:40 - we can always look for the link token
408:41 - contracts page to find the most
408:43 - up-to-date faucets so we'll scroll down
408:46 - we'll find coven
408:47 - looks like this is the at link faucet
408:50 - and the test and eat faucet
408:52 - so here's our kovin faucet we'll just
408:54 - want to switch from rink b to coven
408:58 - grab our address
409:00 - paste it in
409:02 - send me a hundred test link
409:07 - here's our transaction
409:08 - we can see we're transferring
409:11 - some erc20
409:14 - we'll take this contract address we'll
409:15 - add it to our metamask by copying the
409:17 - address
409:19 - scrolling down to add token
409:21 - pasting it in here i already have the
409:23 - address in here so i'm just going to go
409:24 - ahead and hit cancel for now
409:27 - and we'll also want some testnet coven
409:29 - ethereum which looks like this faucet
409:31 - has it
409:32 - so we'll paste the address in here
409:34 - i'm not a robot and we'll do send me 0.1
409:37 - test eth and perfect now that we have
409:40 - some tests on ethereum
409:42 - and some test that link we can proceed
409:44 - we're going to make sure we're on the
409:46 - coven test network
409:48 - and we're going to deploy
409:49 - our random number consumer gist here
409:51 - let's go ahead and hit deploy
409:54 - metamask pops up we're going to go ahead
409:55 - and confirm
409:56 - i didn't explain this fulfill randomness
409:58 - function intentionally you'll see why in
410:01 - a second
410:02 - and great a random number consumer comes
410:04 - up
410:05 - let's check what our random result is
410:06 - right now it's obviously zero because we
410:08 - haven't got a random number so i'm going
410:10 - to do something intentionally wrong
410:12 - because there's a good chance that
410:13 - you'll run into this at some point
410:14 - if i hit get random number right now we
410:17 - see this air gas estimation failed
410:19 - we have plenty of eath why would this
410:21 - fail the reason that it's failing is
410:23 - because the contract doesn't have any
410:25 - oracle gas so we got that gas estimation
410:27 - failed because we need to fund this
410:29 - contract address with some link to
410:31 - actually get a random number so we're
410:32 - going to hit this copy button and this
410:34 - is going to copy the address
410:36 - and we're going to come into our meta
410:37 - mask here
410:38 - and we're going to send
410:40 - this address we're going to paste it
410:41 - there
410:42 - swap to link and we'll send it one link
410:46 - this is probably overkill
410:48 - because as you saw
410:50 - the fee is only 0.1
410:52 - but we're just going to be overkill for
410:54 - now
410:56 - and great now that this contract has
410:58 - some test net link now we can call this
411:00 - get random number button because we can
411:03 - actually pay the chain link node to
411:05 - actually return our random number so
411:07 - we're going to go ahead and do confirm
411:09 - and this is fantastic so we're paying a
411:11 - little bit of transaction gas to make
411:13 - this transaction to make this request
411:15 - and then we're paying a little bit of
411:17 - oracle gas to make this transaction now
411:19 - so the transaction
411:22 - now so the transaction confirmed but if
411:24 - i hit random result now it's still going
411:26 - to be zero
411:27 - so why is that what's going on well
411:29 - getting a random number like this
411:31 - actually follows what's known as the
411:32 - request and receive cycle of getting
411:35 - data you can read more about it here in
411:37 - this basic request model in the
411:39 - documentation so in one transaction we
411:42 - actually request some data or in this
411:45 - case a random number and then in a
411:46 - second transaction the chain link node
411:48 - itself
411:49 - will make a function call and return the
411:52 - data back to the smart contract in this
411:55 - case the function that we're calling is
411:57 - fulfill randomness it calls this fulfill
411:59 - randomness
412:00 - with byte32 request id which is going to
412:03 - be the request number of when we call
412:05 - this
412:06 - and it's going to return with this
412:07 - random number called randomness
412:10 - so after we wait a little bit
412:12 - if we hit random result now we can see
412:14 - indeed our random number is in here
412:16 - again the reason that it's in here is
412:17 - because we actually had two transaction
412:20 - occur
412:21 - one paid by us
412:22 - when we called get random number and one
412:25 - paid by the chain link node when it
412:26 - called fulfill randomness now i lied to
412:29 - you a little bit technically that vrf
412:31 - coordinator contract calls this function
412:33 - and then the chain link node calls the
412:35 - vrf coordinator function but for
412:37 - simplicity's sake you can kind of just
412:38 - think of it as the chain link node
412:40 - itself is calling this fulfill
412:41 - randomness function so now that we know
412:43 - how to do this from remix let's go ahead
412:44 - and add this to our brownie project
412:47 - so actually before we even do that we
412:49 - need to require so before we even get a
412:51 - random number let's change the state of
412:53 - our lottery so now we'll do lottery
412:56 - state
412:57 - equals
412:59 - lottery state
413:00 - dot calculating winner
413:03 - and while this is happening no other
413:04 - functions can be called right this will
413:06 - lock out
413:07 - nobody can start a lottery and nobody
413:09 - can enter a lottery while we're
413:11 - calculating the winner
413:12 - awesome so now that we know a little bit
413:14 - more about random numbers and everything
413:16 - that we're doing here let's go ahead and
413:17 - try implementing this now
413:19 - so in our chain link smart contract docs
413:21 - of course we're going to scroll down
413:23 - we're going to go to our get a random
413:25 - number bit here
413:27 - we can copy and paste all this code as
413:28 - well
413:29 - into our smart contracts so the first
413:31 - thing that we're going to need to do of
413:32 - course is
413:34 - import the vrf consumer base code
413:37 - let's move back over
413:39 - scroll to the top and we'll just paste
413:41 - this in at chain link slash contracts
413:43 - src
413:44 - v0.6 vrf consumer base and we'll inherit
413:48 - this into our lottery contract so we'll
413:50 - say the lottery is vrf
413:52 - consumer base
413:55 - and it's ownable let's take a look at
413:58 - this vrf consumer base in the chainlink
414:00 - github here
414:01 - if we scroll down
414:03 - to the constructor of our vrf consumer
414:05 - base we can see it takes these two
414:07 - parameters the address of the vrf
414:09 - coordinator and the address of the chain
414:11 - link token
414:12 - we can use a constructor we can use a
414:15 - constructor of a contract inherited in
414:18 - our contract inside our constructor
414:22 - so what we'll want to do is we want to
414:24 - come down to our constructor and right
414:26 - after this public keyword we can add any
414:28 - additional constructors from inherited
414:30 - smart contracts
414:32 - so we'll say constructor and this is our
414:34 - normal constructor and then we'll put
414:37 - vrf
414:38 - consumer base
414:41 - and we'll add the vrf consumer base
414:43 - addresses in here
414:45 - we know that it's going to be a vrf
414:47 - coordinator address and a link token
414:49 - address
414:50 - similar to the price feed these two
414:52 - addresses are going to change based on
414:54 - the blockchain that we're on
414:56 - so it'll probably make sense for us to
414:58 - parameterize them the same way we
415:00 - parameterize the price feed address
415:03 - so in our top level
415:06 - constructor parameters we'll add
415:09 - an address
415:10 - for the vrf
415:12 - coordinator
415:13 - and we'll pass this to the constructor
415:16 - of our vrf consumer base
415:18 - then we'll also grab an address for the
415:20 - link token so we'll do address
415:24 - link
415:25 - and we'll pass this
415:27 - to the vrf consumer based constructor as
415:29 - well
415:30 - great what else do we need to make this
415:32 - work well back in the documentation we
415:34 - can see we need a fee
415:36 - and a key hash the fee is associated
415:38 - with the link token needed to pay for
415:40 - this request
415:42 - so we'll make a public variable
415:45 - uint 256
415:47 - public
415:48 - fee since this might change blockchain
415:51 - to blockchain we'll have this as an
415:54 - input parameter as well
415:56 - so we'll do uni-256
415:58 - underscore fee
415:59 - and in our constructor
416:02 - we'll do fee
416:04 - equals underscore fee
416:06 - we'll set our global variable
416:08 - to fee
416:09 - and i need a comma here and no semicolon
416:12 - here what else do we need
416:14 - well we need a key hash
416:16 - the key hash is a way to uniquely
416:18 - identify the chain link vrf node
416:22 - so create another one we'll do
416:25 - bytes 32 public key hash
416:30 - we'll add this as a parameter in here
416:33 - bytes32
416:35 - keyhash
416:37 - and then we'll say
416:39 - keyhash equals
416:41 - underscore keyhash
416:43 - perfect our contract is coming along
416:45 - great here
416:46 - now that we have the main pieces that we
416:48 - need how do we then request this random
416:50 - number
416:51 - well if we scroll down in the
416:52 - documentation
416:54 - we can see we have this request
416:56 - randomness function that we need to call
416:58 - if we scroll back to our vrf
416:59 - consumer-based contract this request
417:02 - randomness function is a built-in
417:04 - function from the vr of consumer base so
417:06 - our contract can natively call this
417:07 - request randomness function right in our
417:10 - contract and you can see it takes a key
417:12 - hash and a fee as its parameters
417:16 - so right in our end lottery function
417:20 - we can add this function and we can see
417:22 - this also returns a bytes32 called
417:26 - request id this return syntax is pretty
417:28 - powerful
417:29 - you can actually identify the name of
417:32 - the variable you want to return right in
417:34 - your write in your function declaration
417:36 - so by saying bytes32 request id we're
417:38 - saying we're going to return a bytes32
417:41 - variable named request id so right in
417:43 - our function here
417:44 - we can do request
417:46 - randomness
417:48 - because again that's this function that
417:50 - we're importing
417:52 - passing it the key hash
417:54 - and the fee
417:55 - this will return
417:57 - a bytes 32 called request id
418:01 - so this is actually doing this
418:03 - and having our function
418:05 - having our function declaration tell us
418:08 - that there's going to be a variable name
418:09 - request id
418:10 - is going to be exactly the same as if we
418:12 - did bytes 32
418:14 - request id equals request randomness now
418:17 - this function call follows again what
418:19 - we've talked about as the request and
418:20 - receive mentality the request and
418:23 - receive architecture
418:25 - this means that in this first
418:27 - transaction we're going to request the
418:29 - data from the chain link oracle in a
418:32 - second callback
418:33 - transaction the chain link node is going
418:35 - to return
418:37 - the data to this contract
418:39 - into another function called fulfill
418:42 - randomness so again if we look back in
418:45 - our vrf consumer base we can see it has
418:47 - this function raw fulfill randomness we
418:49 - can read some of the comments in here
418:51 - saying raw fulfill randomness is called
418:53 - by a vrf coordinator when it receives a
418:55 - valid vrf proof raw fulfill randomness
418:59 - will then call fulfill randomness so
419:01 - there's a little bit of contract tag
419:03 - going on but it's going to eventually
419:04 - call this fulfill randomness function
419:07 - which is going to be what we define in
419:09 - here
419:10 - and that's how our contract is going to
419:12 - know what to do once it gets the random
419:14 - number back so in our first transaction
419:17 - we're going to end the lottery request a
419:19 - random number
419:20 - and then a second transaction later on
419:22 - once the chain link node has created a
419:24 - provably random number it's going to
419:26 - call a second transaction itself
419:29 - based off of what we define
419:31 - we just have to call it
419:33 - fulfill
419:34 - randomness
419:36 - and as you can see it takes a byte 32
419:38 - request id and a random number so
419:41 - in here we'll do fulfill randomness it
419:43 - takes a byte 32
419:45 - request id
419:47 - and then a uin256
419:50 - randomness
419:52 - we don't want anyone else to be able to
419:54 - call this function we only want our
419:56 - chain link node to call this function so
419:57 - we can return a truly random number
420:00 - so we're going to make this an internal
420:01 - function
420:02 - it's internal because actually the
420:04 - chain-link node is calling the vrf
420:07 - coordinator
420:08 - and then the vrf coordinator is calling
420:10 - our fulfill randomness
420:12 - so we'll make this internal so that only
420:14 - the vrf coordinator can be the one to
420:15 - call and return this function
420:17 - and then we're going to give it a
420:19 - keyword of override this override
420:21 - keyword means that we're overriding the
420:23 - original declaration of the fulfill
420:25 - randomness function our vrf consumer
420:27 - base has a function fulfill randomness
420:30 - defined but it doesn't have any
420:33 - parameters or anything about this
420:35 - function actually laid out this function
420:37 - is meant to be overridden by us and
420:40 - that's exactly what we're doing right
420:41 - here so in this fulfill randomness
420:43 - function let's go ahead and define
420:45 - what's going to happen once we get this
420:47 - random number back so before we can
420:49 - process this random number let's just
420:51 - check to make sure we're even in the
420:52 - right state so we'll do require
420:56 - our lottery state is going to be equal
420:58 - to
421:00 - lottery state dot
421:02 - calculating winner
421:04 - and if we're not in that state
421:06 - we'll just say
421:08 - you
421:10 - aren't there yet
421:14 - my auto format is is on for this one so
421:17 - it's uh it's jumping in then let's just
421:19 - do another check to make sure we
421:21 - actually get a response so we'll do
421:22 - require
421:24 - underscore randomness
421:27 - is greater than
421:29 - zero
421:30 - and if it's not we'll just say random
421:34 - not found
421:37 - now we need to pick a random winner
421:40 - well we need to pick a random winner
421:42 - specifically
421:43 - out of our list of players our list of
421:47 - payable public players so our players
421:49 - array is just a list of players so it's
421:52 - like one player one player two player
421:54 - three player four
421:56 - and they're each at a different index
421:58 - what we can do then to pick a random
422:00 - winner is to do what's called a modulo
422:02 - function in fact let's even open remix
422:05 - to do an example of this remix let's pop
422:08 - open a new contract we'll call it
422:10 - mod.sol
422:12 - do pragma
422:14 - solidity
422:15 - carrot 0.6.6
422:17 - we'll do contract
422:21 - mod
422:22 - and in here we'll do a constructor
422:27 - blank constructor
422:28 - and we'll get a global variable you went
422:31 - 256
422:32 - number and we'll set it equal to 5. and
422:36 - we'll go down to 0.6.6
422:39 - save compile
422:42 - and you know let's even just get rid of
422:43 - the constructor
422:45 - let's now create a function
422:47 - called do mod
422:48 - we'll take a un256
422:54 - mod value
422:55 - make this a public function
422:59 - public
422:59 - view returns
423:02 - ui 256
423:03 - and we'll just return
423:06 - 5
423:07 - modulo
423:09 - mod value
423:11 - now let's go to javascript vm we'll
423:13 - deploy this
423:15 - we'll go in here
423:16 - so our number is right now five and
423:18 - let's learn about how the modulo works
423:20 - if we have this do mod function
423:23 - what we're doing
423:25 - is
423:25 - the module divides
423:28 - by
423:29 - the number
423:31 - and returns the remainder
423:34 - for example if we did 5 mod 5 what do
423:38 - you think we're going to get
423:39 - so we're going to do 5 divided by 5 and
423:42 - then return the remainder
423:44 - well 5 divided by five is one and
423:46 - there's no remainder there's no decimal
423:48 - there so five mod five should be what
423:51 - zero exactly well what's five mod four
423:53 - then
423:54 - well four can go into five evenly once
423:57 - but there's one number left over so five
424:00 - mod four is going to be
424:02 - one
424:03 - five mod three is going to be two five
424:06 - mod one is going to be zero right since
424:09 - one goes with everything this is how the
424:11 - mod function works and it's this little
424:12 - percent here we can use that mod
424:15 - function
424:16 - in our fulfill randomness
424:18 - with the length of our players so we can
424:20 - say uint 256
424:23 - index of winner
424:26 - is going gonna be equal to
424:28 - the random number that we got
424:31 - modded
424:32 - by the players dot length so let's say
424:35 - for example we had seven players
424:38 - sign up and our random number was 22
424:41 - well we want to get one of these random
424:43 - seven players so
424:45 - we would do 22
424:47 - mod 7.
424:49 - 7 divides evenly into 22 three times
424:52 - with one left over seven
424:55 - times 3
424:56 - equals
424:57 - 21.
424:59 - difference between 21 and 22
425:01 - is 1
425:02 - 7 times
425:04 - 4
425:04 - is 28 so we know this is how we know
425:08 - we've reached our upper limit so this is
425:10 - how we can get a random number
425:13 - based off of the index
425:15 - now that we have this index what we can
425:16 - do
425:18 - is we can say the winner
425:19 - equals
425:21 - players
425:24 - of the index of winner
425:27 - and just to keep track let's make a new
425:30 - variable called recent winner at the top
425:33 - we'll do address
425:35 - public
425:36 - recent winner
425:39 - we'll grab this recent winner instead of
425:41 - winner we'll say recent winner equals
425:43 - players and this index of winner here
425:46 - now that we've got a winner wallet we
425:48 - want to pay them all the money
425:50 - gathered from our enters here
425:52 - so what we can do
425:54 - is we'll do
425:55 - this recent winner
425:58 - dot transfer
426:01 - the entire balance of this address
426:04 - so we'll say address of this
426:08 - that balance
426:10 - and perfect
426:11 - we'll transfer them everything that we
426:13 - have
426:15 - then of course
426:16 - we're going to want to reset the lottery
426:18 - so that we can start from scratch we can
426:20 - start blank again
426:22 - so we'll do players
426:25 - equals new
426:28 - address payable
426:31 - array of size 0.
426:33 - so
426:34 - we're just resetting players to just be
426:36 - a brand new array then we're going to
426:38 - change our lottery state
426:41 - to being
426:42 - lotterystate.closed
426:44 - because the lottery is now complete and
426:46 - i often also like to keep track of the
426:48 - most recent random number
426:50 - so at the top
426:53 - i'll do a uint 256 public
426:56 - randomness
426:58 - variable
427:00 - and in our fulfill randomness i'll say
427:02 - randomness now equals
427:05 - underscore randomness
427:08 - and perfect we now have a contract here
427:10 - of course we haven't actually tried it
427:12 - out but we're assuming that it works
427:14 - great so you know what this means it's
427:17 - time to go into testing mode testing and
427:19 - development mode but let's even just try
427:21 - to do a brownie
427:23 - compile first
427:25 - looks like we have
427:27 - an issue here
427:28 - send and transfer are only available for
427:31 - objects of type address payable
427:33 - not address oops looks like we made our
427:36 - recent winner just an address but it
427:38 - needs to be an address
427:40 - payable
427:44 - so let's try browning compile again
427:46 - and beautiful we at least know it's
427:48 - compiling so that's a great sign let's
427:50 - now move into our testing and
427:52 - development phase as you are starting to
427:54 - figure out we can ignore these file
427:57 - import callback not supported bugs and
428:00 - vs code for now i'm sure the solidity
428:02 - linter will get better as time
428:04 - progresses but great so now let's go
428:06 - ahead and move into actually testing and
428:08 - working with everything here
428:10 - so let's go ahead into our scripts
428:12 - and we'll make a little deploy script
428:14 - first
428:16 - let's do a new file
428:19 - call it deploy lottery that pi
428:22 - and let's go ahead and deploy our
428:24 - lottery
428:25 - so same as always we'll do def main
428:29 - we'll come with a new function called
428:31 - deploy
428:33 - lottery
428:35 - and then we'll do def
428:36 - deploy
428:38 - lottery
428:40 - and then we'll just have a pass for now
428:42 - and if we run this
428:44 - brownie run scripts
428:46 - deploy lottery.pi
428:49 - our default network is not defined which
428:51 - means the default is going to be
428:53 - development
428:54 - and we can even
428:56 - verbose here develop
428:58 - meant write that in our brownie config
429:02 - run this
429:03 - gnosh will get spun up
429:05 - and nothing will happen because our
429:07 - deploy lottery function doesn't do
429:08 - anything right now
429:10 - awesome the first thing we need always
429:12 - to deploy a contract is we need an
429:14 - account
429:15 - so we'll do account
429:17 - equals and we've been using this
429:19 - getcount function for some time that
429:22 - we've been adding in a helpful script
429:24 - section so that can pull from a real
429:26 - test net or from a local development
429:28 - environment if we like so to do this of
429:30 - course let's create our new
429:32 - helpful scripts
429:33 - dot
429:34 - pi we'll create our underscore
429:36 - underscore init underscore underscore
429:38 - dot pi
429:40 - so that python recognizes it as a
429:41 - package
429:43 - and in here we'll create a new function
429:45 - f get
429:46 - account
429:48 - for now we'll just have it pass
429:50 - we'll copy this
429:53 - into our deploy lottery we'll do from
429:58 - scripts.helpful
429:59 - scripts
430:01 - import get account
430:03 - now this
430:06 - now this
430:07 - is what our get account looked like
430:09 - in our last project
430:12 - along with that we had
430:14 - these forked local environments
430:17 - we also had from
430:18 - brownie imports accounts
430:21 - and network and config
430:24 - to make this look really nice right
430:26 - let's flush this out just a little bit
430:27 - more so it's even more robust
430:29 - right now as we know
430:32 - we have a way to use
430:34 - brownies ganache accounts
430:36 - and we have a way
430:38 - to use
430:40 - our environment variables
430:42 - however there was a third method that we
430:44 - learned that isn't identified here
430:47 - accounts.load
430:49 - and this is with our id
430:51 - if you still have your account and you
430:52 - still have all your brownies set up if
430:54 - we do brownie
430:55 - accounts
430:57 - list
430:59 - you'll see we have a couple accounts
431:00 - here
431:01 - we want our get account to be
431:04 - even more liberal so that if we wanted
431:06 - to use one of these as well we could so
431:08 - let's modify our get account script here
431:09 - a little bit let's first get rid of this
431:11 - else
431:13 - and rid of this indent
431:14 - what this will do is this will be our
431:17 - default
431:18 - if nothing that we define prior to this
431:20 - is defined we'll just default to grab
431:23 - right from our config which since we are
431:25 - doing that
431:26 - let's create our dot env
431:28 - we'll paste our different variables in
431:30 - here our private key web 3 and fura and
431:33 - etherscan token
431:35 - and in our brownie config of course
431:37 - we'll do wallets
431:39 - from key
431:44 - private key
431:45 - and now let's flesh this out a little
431:47 - bit let's add an index
431:50 - and an id
431:53 - index equals none
431:55 - and id
431:57 - this way if we pass an index to our get
431:59 - account function we'll just use
432:02 - an index from this accounts variable
432:04 - if we pass an id
432:06 - we'll have
432:07 - trying to do this accounts.load here so
432:10 - now let's change this up a little bit
432:12 - we'll say if an index was passed
432:15 - we'll just return
432:17 - accounts
432:18 - on that index
432:21 - otherwise if we're doing a local
432:23 - blockchain we'll just return account to
432:25 - zero
432:27 - but if there's an id
432:29 - we'll return
432:32 - accounts.load
432:34 - id
432:35 - whoops we need to actually move this up
432:37 - a little bit
432:41 - so that it's before
432:43 - our local blockchain checking
432:45 - so now in our deploy lottery
432:47 - we could do something like get account
432:49 - id equals
432:51 - free code camp
432:53 - oops and this is actually free code
432:55 - account
432:57 - precode camp account let's try one more
432:59 - time
433:01 - it's going to ask for our password here
433:03 - now we have a much more liberal get
433:05 - account function
433:07 - so now that we have a count we can
433:08 - actually deploy our lottery
433:11 - so we'll say lottery
433:12 - equals
433:13 - lottery.deploy
433:16 - and this is where we're going to import
433:18 - from brownie
433:20 - import our contract lottery
433:22 - and we're gonna have to add in
433:25 - all these different variables so if we
433:27 - go back over to our lottery contract
433:30 - we need to give it a price feed address
433:32 - a vrf coordinator
433:34 - a chain link token
433:36 - a fee and a key hash
433:38 - now the way we did that in fund me is
433:40 - that we did it in a way where we checked
433:42 - to see if we were on a local chain or
433:45 - not if we weren't on a local chain then
433:47 - we would just pull our addresses
433:48 - directly from our config if we weren't
433:51 - on a local chain though we'd deploy some
433:52 - mocks and use the address of those mocks
433:55 - we're going to want to do the same thing
433:58 - here but let's make our lives a little
433:59 - bit easier
434:01 - we can take this whole process and put
434:03 - it into its own function
434:04 - so let's make this a little bit easier
434:06 - mentally the first thing we're going to
434:07 - need is this price feed address
434:09 - if we're on a real test net of course we
434:11 - would just go into our brownie config
434:13 - and add the address which we will do
434:15 - we'll add our rink b
434:18 - network here in a little bit but for now
434:20 - don't worry about that
434:22 - but if we're not on a wrinky chain what
434:24 - we're going to need to do is deploy our
434:25 - mock
434:26 - we're going to wrap
434:28 - all of this mocking and checking into a
434:30 - single function called
434:32 - get contract
434:35 - and we're going to add this function in
434:37 - our helpful scripts
434:39 - so let's create this function called get
434:41 - contract
434:42 - do def get contract
434:45 - pass
434:48 - let's talk a little bit about what we
434:49 - want this function to do
434:51 - let's add one two three
434:54 - three double quotes here and three
434:56 - double quotes here to start what's
434:57 - called a doc string this will define
435:00 - everything about this contract so we're
435:02 - just going to say
435:04 - this function
435:06 - will
435:08 - grab the contract addresses
435:11 - from the brownie config
435:16 - if defined
435:18 - otherwise
435:20 - it will deploy
435:21 - a mock version
435:24 - of that contract
435:26 - and return
435:28 - that mock contract
435:31 - for the arguments of this chain
435:33 - we're going to take a contract name
435:37 - this is going to be a string
435:39 - and it'll return
435:41 - a contract
435:42 - or in particular it's going to return a
435:44 - brownie
435:45 - dot network
435:47 - dot contract dot project
435:50 - contract
435:51 - the most
435:53 - deployed
435:55 - version of this contract
435:58 - so for example if we have a mock v3
436:01 - aggregator contract
436:03 - it'll do the most recently deployed
436:05 - version of that with this -1 syntax
436:09 - now this get contract function if this
436:10 - is a little confusing to you
436:12 - again we're going to go over this chain
436:14 - link mix in a little bit and inside of
436:16 - this it has a more robust
436:19 - description of what's going on in this
436:21 - get contract bit
436:22 - so you can check that out if you want to
436:23 - learn more but let's go ahead and
436:25 - actually define this
436:27 - so we obviously want a contract name
436:29 - as an input parameter so let's go ahead
436:31 - and add contract name in here
436:33 - meaning that this getcontract function
436:36 - we'll get something like f
436:37 - usd
436:39 - price feed
436:41 - right
436:41 - that's gonna be the same as what's
436:43 - defined in our browning config and from
436:45 - this name we're gonna get the type of
436:47 - contract that it is
436:48 - contract type
436:50 - and to do that we're gonna have to
436:51 - create some mapping that'll map the
436:54 - contract names to their type
436:57 - so right above we're gonna do contract
436:59 - to mock
437:02 - and we're to create a mapping in here
437:04 - which will map everything out
437:06 - so
437:08 - an fusd price feed
437:10 - is going to be of type
437:12 - mock v3
437:14 - aggregator
437:15 - so
437:16 - we have to import mock v3 aggregator
437:18 - from rounding
437:19 - so now we're saying anytime you see fusd
437:21 - price feed you know that that's going to
437:23 - be a mock v3 aggregator if we need to
437:25 - deploy a mock
437:27 - so we'll say contract type
437:29 - is going to equal
437:30 - contract to mock
437:33 - of the contract name
437:37 - now we need to check okay do we actually
437:39 - even need to deploy a mock
437:42 - so sure let's check if we're on a local
437:43 - blockchain
437:45 - so we'll say if
437:46 - network.showactive
437:49 - is in
437:52 - our local blockchain environments
437:54 - and we'll skip the forked local
437:56 - environments because again
437:59 - we don't need to deploy a mock price
438:01 - feed address on a fourth local
438:03 - environment
438:04 - which say if network.showactive is in
438:06 - the local blockchain environments
438:09 - then we'll check
438:11 - to see if one of these contracts has
438:13 - already been deployed we'll say if the
438:14 - length
438:16 - of contract type
438:18 - is less than or equal to zero
438:21 - then we're going to go ahead and deploy
438:22 - mox
438:23 - so this is equivalent to doing
438:26 - something like mach v3
438:30 - aggregate or
438:32 - length
438:34 - we're checking how many mach v3
438:36 - aggregators have actually been deployed
438:38 - if none have been deployed we're going
438:40 - to go ahead and deploy them so
438:43 - we're gonna have to create this deploy
438:44 - mox function so we'll do def deploy
438:47 - mox
438:48 - and this is gonna be the same as what we
438:50 - did
438:52 - in our brownie fund me right it's gonna
438:54 - be the exact same
438:56 - so we'll say
438:58 - account equals
439:00 - get account
439:01 - i'm not going to put the prints in here
439:03 - but you absolutely can we'll say mock
439:06 - price feed
439:07 - equals
439:09 - mock v3 aggregator
439:11 - [Music]
439:13 - dot deploy
439:15 - we'll need to give this some decimals
439:17 - and an initial value so right above
439:19 - we'll do
439:20 - decimals
439:22 - equals eight initial
439:25 - value equals two thousand one
439:29 - two thousand one two three four five six
439:31 - seven eight
439:33 - and in our deploy max we'll say decimals
439:35 - equals
439:36 - decimals
439:41 - initial value equals initial value
439:46 - to deploy decimals and
439:49 - initial value
439:51 - of course this is going to be from
439:53 - account
439:55 - and for now that's it i'll say print
439:58 - deployed
440:00 - all right great so now we have a way to
440:02 - actually deploy the mock price feed here
440:05 - so let's go back up to our get contract
440:06 - function
440:07 - so we have a way to deploy the mock
440:10 - if one already isn't deployed
440:12 - now what we're going to want to do is we
440:14 - want to get that contract right we're
440:16 - going to want to get that mock so we'll
440:18 - say contract
440:19 - equals
440:21 - contract type
440:22 - minus one
440:24 - right so this is going to be equal to
440:25 - doing
440:27 - mock v3r gregator
440:30 - minus one
440:31 - this is saying hey let's grab the most
440:34 - recent deployment of the mock v3
440:35 - aggregator which is exactly what we want
440:38 - perfect so this will work
440:40 - perfectly
440:41 - for our
440:42 - development context however we're not
440:45 - always going to just want to deploy to a
440:47 - development network we're also going to
440:50 - want to deploy to testnets
440:52 - so then we'll say else and this is where
440:55 - we'll just grab that contract from the
440:58 - running config for example fusd price
441:01 - feed so we'll say
441:03 - contract address
441:05 - equals config
441:08 - networks
441:11 - network.show active
441:14 - and that contract name
441:18 - for example again if it's fusd price
441:20 - feed it'll be fused price feed here
441:23 - and the way we're setting it up it's got
441:24 - to be the same as what's in our contract
441:26 - to mock dictionary here so up here the
441:29 - way that we did it was we actually got
441:30 - the contract because we had its contract
441:33 - type
441:34 - based off of browning for here we're
441:36 - gonna have to interact with the contract
441:38 - getting those two pieces that we always
441:39 - need which are gonna be the address we
441:42 - actually have the api from our mock v3
441:45 - aggregator type right here and we just
441:47 - got the address so we can create this
441:49 - new contract type by saying contract
441:51 - equals contract
441:53 - dot from abi
441:55 - and this contract package can be
441:58 - imported right from brownie
442:00 - and it has this function from abi
442:03 - that allows us to
442:04 - get a contract from its abi and its
442:06 - address
442:07 - so we'll just give it a name
442:09 - we can say contract
442:11 - type dot underscore name
442:14 - we do the contract address
442:18 - and then
442:20 - the contract type dot abi
442:24 - so these mock v3 aggregators and all
442:26 - these contracts
442:27 - have a dot avi
442:29 - attribute that returns the api
442:32 - they also have a dot underscore name
442:34 - which returns their name so this is
442:36 - perfect this is how we'll get the
442:37 - contract otherwise and then at the end
442:39 - of all this we'll just do return
442:42 - contract awesome so this is an
442:44 - incredibly powerful function for us
442:46 - to get a contract based off of if it's
442:49 - already deployed as a mock or it's a
442:51 - real true contract i know there's kind
442:53 - of a lot here but definitely check the
442:55 - github repository if you're a little bit
442:56 - confused on what's going on with this
442:58 - function and let's
443:00 - and let's also just deploy this to make
443:02 - our linter happy why not
443:04 - yeah vs code's happy now but now that we
443:06 - have this function let's go back to our
443:08 - deploy lottery
443:09 - now we can do a comma get account
443:12 - and now we have a get account function
443:14 - so let's go through this again
443:16 - this lottery.deploy getaccount is going
443:20 - to get an fusd price feed
443:22 - if we don't have a mock deployed it's
443:24 - going to deploy a mock price feed for us
443:27 - and we're going to return that mock
443:29 - price feed
443:30 - however if we're on a test net if we're
443:33 - on a real network we're going to grab
443:35 - its actual address and return
443:38 - a mock contract of it our mock contract
443:40 - here has all the same functions of a
443:41 - regular contract so we can just use it
443:44 - as the same this way we don't have to
443:46 - adjust this function for whether or not
443:48 - we're deploying to a test net or to an
443:50 - actual address the only additional piece
443:52 - we should put in here just for clarity
443:54 - is we should add dot address here
443:57 - because this is going to return the
443:59 - actual contract and we really only want
444:01 - the address this is going to make our
444:03 - coding a lot more robust for
444:05 - moving between development environments
444:07 - and test environments and working with
444:09 - scripts in a really effective manner so
444:11 - now that we have this incredibly
444:12 - powerful function let's go back to the
444:14 - lottery and figure out what are the
444:15 - different pieces we need in here okay
444:18 - great we also need a vrf coordinator
444:21 - so
444:22 - to do this we're going to go back to our
444:24 - docs.chain.link
444:26 - we'll go to contract addresses
444:28 - and we could do mainnet here but let's
444:30 - also just set this up to work with rank
444:32 - b so we'll do ctrl f for rink b
444:35 - vrf coordinator is going to be this
444:37 - address right here so we'll copy it
444:40 - we'll go back
444:41 - and we're going to have to do
444:43 - in our config
444:44 - is we're going to have to add a new
444:46 - network here for rank b
444:48 - we'll do vrf core data nato
444:52 - will be that address right there
444:53 - and then while we're doing this let's
444:55 - also get the rink b address for our
444:57 - price feed so ethereum price feeds
444:59 - rink b
445:00 - let's scroll down for fusd
445:03 - fusd here we go
445:05 - grab that
445:07 - enter this will be f usd
445:09 - price feed
445:11 - face adder sit here perfect
445:14 - so now we can do get contract
445:17 - vrf coordinator dot address of course
445:21 - we are gonna have to go back to our
445:22 - helpful scripts
445:24 - because there's currently no mapping
445:26 - between what a vrf coordinator is and
445:30 - what its mock needs to be so we'll add a
445:32 - comma here
445:34 - and we'll do vrf coordinator
445:38 - and we need to get
445:40 - a mock vrf coordinator well first of all
445:42 - we don't even have our mach v3
445:44 - aggregator so let's go grab that as well
445:46 - so we can grab both of these again i'm
445:48 - going to highly recommend going to the
445:49 - chain link mix
445:51 - going into the contracts here going to
445:53 - the test folder for these different
445:54 - mocks because these are already set up
445:56 - to work with the chain link mix however
445:58 - you can definitely go into the chain
445:59 - link github as well
446:01 - go to contracts
446:03 - src
446:04 - 0.6
446:06 - tests
446:08 - and then look for the different mocks in
446:09 - here so mock oracle vf coordinator mock
446:12 - et cetera so we're just gonna i'm just
446:14 - gonna grab it though from this chain
446:15 - link mix so let's go to vrf coordinator
446:17 - mock
446:18 - and i'm just gonna grab this whole thing
446:20 - here
446:21 - so i'll do contracts new folder
446:23 - test
446:25 - new file vrf
446:27 - core
446:28 - core
446:29 - [Music]
446:32 - moc.sol
446:34 - paste it in here
446:38 - and then while we're in here we want to
446:39 - do new file
446:40 - mock v3 ah
446:42 - greg
446:44 - sol
446:47 - we'll grab this as well
446:50 - from our chain link mix
446:55 - again it's got all the functions of a
446:56 - price feed update answer
446:59 - latest round etc
447:02 - vrf coordinator walk has different
447:04 - functions for actually working with the
447:05 - vrf coordinator
447:07 - one of the specific ones in particular
447:08 - is this callback with randomness that
447:10 - we're going to use
447:11 - in our tests so our vrf coordinator is
447:14 - going to get mapped to
447:15 - our vrf core
447:18 - nator mock
447:21 - which will also import this
447:24 - from brownie
447:26 - great and just to double check
447:27 - everything's working we'll want to run
447:28 - just a quick brownie compile
447:30 - make sure we are importing our mocs
447:32 - correctly and everything is compiling so
447:34 - it looks like we're good there
447:36 - all right
447:37 - so now we have
447:39 - git contract vrf coordinator dot address
447:42 - perfect what else do we need in here
447:45 - we need a link token the chain link
447:47 - token is of course just another smart
447:49 - contract so we're going to do the exact
447:51 - same thing here
447:53 - get contract
447:56 - link token
447:57 - dot address
448:01 - of course this means
448:04 - in our config
448:06 - for rink b
448:07 - let's add a link token address
448:10 - we'll go to the chain link documentation
448:13 - go to
448:15 - link token contracts
448:18 - look for rink b
448:20 - we'll grab this address
448:25 - we'll drop it in here
448:27 - perfect now we have it in our brownie
448:28 - config
448:29 - we'll also need to add it to our
448:32 - helpful scripts
448:35 - so we'll need
448:39 - a mock link token
448:40 - which again
448:42 - we can just go ahead and grab
448:44 - from our chain like mix here
448:46 - so we can go to test and as you can
448:48 - probably see what i often normally do is
448:50 - literally just copy this entire test
448:52 - folder project to project
448:54 - so i'm going to copy this whole thing
448:58 - create a new file
449:00 - we're just going to call this one
449:04 - link token.sol
449:08 - contract link token perfect
449:10 - and then in our helpful scripts we're
449:12 - going to have this be linked token
449:15 - and of course we're going to import this
449:17 - from brownie
449:19 - great git contract link token.address
449:22 - perfect
449:23 - what else do we need we need a fee and a
449:25 - key hash so the fee and the key hush are
449:28 - both just numbers right these aren't
449:30 - actually contracts so we don't need to
449:31 - put this through that get contract bit
449:34 - what we can do
449:35 - is just in our config
449:38 - and our development network
449:40 - we just add a default for the key hash
449:43 - and for the fee
449:46 - i'm just going to set my development key
449:47 - hash and fee equal to the rink b ones
449:51 - so to grab
449:52 - those go to the chain link docs once
449:55 - again we'll scroll down to using
449:58 - randomness
449:59 - contract addresses
450:01 - we'll look up rink b
450:04 - we'll grab the
450:05 - key hash
450:06 - here which we'll paste in for both
450:13 - are development
450:15 - and rink b
450:18 - and then the fee it says 0.1 link so
450:22 - we'll just do
450:23 - that in way here which will be one
450:26 - one two three four five six seven eight
450:27 - nine ten
450:29 - one two three four five six seven
450:32 - and we'll do this
450:33 - line for ring p as well
450:36 - now in our deploy lottery we can just
450:38 - grab this directly from a browning
450:40 - config because we're always going to
450:42 - have this default key hash and this
450:44 - default fee here for our development
450:46 - network
450:47 - so we'll do config
450:50 - networks
450:53 - network dot show active
451:00 - which one's first the fee
451:03 - fee
451:05 - of course this means we're going to
451:07 - grab network from brownie
451:10 - and also config
451:14 - then we'll do config
451:16 - networks
451:19 - network dot show active
451:30 - and then of course
451:31 - our last bit here
451:34 - from
451:35 - account
451:39 - and then additionally as we learned last
451:41 - time if we want to publish this
451:43 - we'll do publish
451:45 - source
451:47 - equals config
451:50 - networks
451:56 - network dot show active
452:00 - we'll say dot get
452:02 - verify
452:04 - and then we'll add this false bit here
452:06 - what this is saying is get that verify
452:09 - key
452:10 - but if there's no verify key there just
452:12 - default to false this way if we don't
452:14 - set a verify key in development that's
452:16 - fine it just won't get verified for ring
452:18 - b let's go ahead and set verify
452:20 - to true
452:21 - so we can actually verify this on the
452:23 - rigby chain
452:24 - and then we'll even do a print statement
452:26 - here
452:28 - deployed
452:29 - lottery
452:32 - all right lovely let's try this out
452:36 - we'll do brownie
452:37 - run scripts
452:40 - deploy lottery.pie we won't set a
452:42 - network flag so it will go to the
452:44 - default development network let's try
452:46 - this out
452:48 - things are compiling ganache is spinning
452:50 - up
452:51 - it looks like we did run into a little
452:53 - issue here with our our get contract
452:55 - function
452:57 - ah of course we forgot to add deploying
453:00 - these mocks in our deploy mock script
453:02 - whoops let's go ahead and add that as
453:04 - well
453:05 - right now our deploymox only deploys the
453:07 - mach v3 aggregator
453:09 - so let's add the rest of our mocks in
453:10 - here
453:12 - we're going to need to deploy a vrf
453:14 - coordinator mock and a chain link token
453:16 - mark so let's open up those contracts
453:18 - see what they need
453:20 - a link token
453:21 - for a constructor
453:24 - doesn't have a constructor so we can
453:26 - just have it be blank
453:27 - so we'll do
453:29 - link token
453:32 - dot deploy
453:34 - and all we need is a from
453:36 - account here
453:38 - and then let's see what that vrf
453:40 - coordinator mock takes
453:41 - prf coordinator mock
453:46 - it takes the link token as an address
453:49 - perfect
453:51 - so then when we deploy the link token
453:52 - here
453:53 - we'll say link token
453:54 - equals link token.deploy and then we'll
453:56 - do vrf
453:59 - core
454:00 - donator mock
454:03 - dot deploy
454:04 - ploy
454:07 - and then we'll use the link
454:08 - token.address
454:11 - as an input parameter
454:13 - and then of course from
454:15 - account
454:16 - all right so now we're deploying all
454:19 - three of those mocks right away
454:22 - let's try this again
454:23 - brownie run scripts
454:25 - deploy lottery.pi
454:28 - ganache is spinning up
454:30 - perfect
454:32 - so we can see here that our mach v3
454:35 - aggregator was deployed
454:37 - then our mock link token was deployed
454:39 - then our mock vrf coordinator was
454:41 - deployed and then our lottery was
454:43 - deployed with those mocks defined
454:45 - and we deployed the lottery awesome
454:48 - now we could 100 percent
454:51 - go ahead and then run this script on an
454:53 - actual test net right because our config
454:56 - is set up well let's write some more
454:58 - functionality for actually interacting
455:00 - with this lottery
455:02 - before we actually do that and then we
455:04 - can actually just run a script which
455:05 - will do all this functionality end to
455:07 - end because again deploying to testnet
455:10 - takes a long time and we really only
455:11 - want to do that when we're done and
455:12 - we're fairly confident that everything's
455:14 - working well let's even just delete this
455:16 - here
455:17 - so now what's the next thing that we'd
455:18 - want to do here what's the next thing we
455:20 - want to do in a script here well we'd
455:21 - probably want to go ahead and start the
455:23 - lottery so let's write a script that can
455:25 - actually do that
455:26 - we'll do def
455:28 - start lottery
455:30 - and then here we get our account
455:33 - equals get account
455:36 - we'll say the lottery is going to be the
455:38 - most recent deployment
455:40 - of the lottery
455:42 - and we're going to call this start
455:44 - lottery function here this is indeed
455:46 - changing state so we do have to make a
455:48 - transaction
455:50 - we'll do lottery
455:51 - let's start
455:53 - lottery
455:55 - we'll say from
455:57 - account
456:00 - then we'll do a little print and just
456:02 - say
456:03 - the lottery is started
456:07 - and then in our main function down here
456:08 - we can even call this start lottery
456:10 - function
456:12 - so if we run this
456:13 - again on our development chain
456:16 - we'll see if everything works smoothly
456:17 - here okay we did run into an issue and
456:19 - this is something that you'll see from
456:20 - time to time
456:21 - typically the workaround is you want to
456:23 - wait for that last transaction to
456:24 - actually go through so we'll say
456:26 - starting
456:27 - transaction
456:29 - equals lottery.start lottery it will do
456:31 - starting
456:32 - transaction.weight
456:34 - 1.
456:35 - brownie sometimes gets a little confused
456:36 - if you don't wait for the last
456:37 - transaction to go through
456:39 - so let's try it again and perfect we do
456:41 - get this working as intended so that is
456:44 - really helpful helpful tip if you run
456:45 - into those weird issues you'll notice
456:47 - that even when we didn't have this it's
456:48 - still completed successfully i just got
456:51 - a little confused at the end
456:52 - all right cool so what do we want to do
456:55 - next well we probably want to enter the
456:57 - lottery let's do def
457:01 - enter
457:02 - lottery so how do we enter the lottery
457:05 - say account equals get account
457:09 - lottery is going to be
457:11 - lottery
457:14 - minus one
457:15 - we need to pick some value to send when
457:18 - we call the enter function
457:20 - right because we need to send that
457:22 - entrance fee with it
457:24 - so we'll say value equals lottery dot
457:27 - get
457:28 - entrance fee
457:31 - and just to be safe i usually will tack
457:33 - on a little bit of whey as well because
457:36 - sometimes it might be off by like one or
457:38 - two or something like that so we'll do
457:39 - lottery. get entrance fee plus you know
457:41 - maybe something like this which is like
457:43 - barely anything then we'll do
457:46 - transaction equals lottery.enter
457:49 - do from account
457:52 - send a value which will be value
458:02 - we'll do tx.weight
458:04 - and then we'll do print
458:08 - you entered the lottery
458:12 - and we'll do this enter lottery bit down
458:14 - here too enter lottery
458:17 - we'll run this see if our enter script
458:19 - is working appropriately
458:21 - you entered the lottery looks great and
458:24 - let's do our last function here we'll do
458:26 - def
458:27 - end lottery
458:30 - count equals get account
458:34 - lottery equals
458:36 - lottery minus one we'll make a
458:38 - transaction which will be lottery dot
458:40 - end lottery
458:44 - now before we actually end this lottery
458:47 - we're going to need some link token in
458:49 - this contract
458:50 - because remember our end lottery
458:52 - function
458:53 - calls this request randomness function
458:56 - and we can only request some randomness
458:58 - if
458:59 - our contract has some chain link token
459:01 - associated with it so we're going to
459:03 - need to first
459:04 - fund the contract
459:07 - and then
459:08 - end the lottery since funding our
459:10 - contracts with the link token is going
459:11 - to be a pretty common function that we
459:13 - use let's go ahead and turn this also
459:15 - into a helpful script
459:17 - so let's go to our helpful scripts we'll
459:19 - make a new function
459:20 - called fund with
459:23 - link
459:25 - and let's have this take a couple of
459:27 - parameters so first we'll want to have a
459:29 - contract address of course
459:31 - we'll want to know who we're going to
459:32 - fund with link we'll set a default
459:35 - account to being none
459:36 - so if you want you can send an account
459:38 - but you don't have to if you don't want
459:40 - to we'll also do the same thing with a
459:42 - link token we'll say if you want to use
459:45 - a specific link token you can otherwise
459:48 - we'll just grab it ourselves
459:50 - and then we'll also do a default amount
459:52 - which we'll set to
459:54 - 1
459:54 - one two three four five six seven eight
459:56 - nine ten one two three four five six
459:58 - seven
459:59 - which is going to be
460:01 - 0.1 link
460:03 - so first let's get an account we'll say
460:05 - account
460:06 - equals
460:07 - we're going to do a little clever python
460:09 - stuff here
460:10 - we'll say account equals the account
460:12 - if somebody sent it
460:14 - if account
460:16 - so we're saying
460:17 - the account that we use
460:19 - is going to be
460:20 - this account thing if this account thing
460:23 - even exists otherwise we'll call our get
460:26 - account otherwise we'll just do our
460:27 - regular get account function
460:29 - then we'll do the same thing with the
460:31 - link token
460:32 - say the link token
460:34 - is going to be equal to
460:35 - the link token
460:37 - that somebody supplies as a parameter
460:40 - if
460:41 - they applied something as a parameter
460:43 - otherwise we'll just do that get
460:44 - contract stuff that we did before
460:47 - of the link token
460:50 - now that we have this link token
460:52 - contract from our get contract function
460:55 - which again is basically the equivalent
460:56 - of doing which again is doing this
460:58 - contract up from abi on our link token
461:02 - pulling from
461:04 - our config or from our mock now we can
461:07 - just call the functions on this link
461:09 - token so we can say our transaction
461:11 - equals
461:12 - link token
461:14 - dot transfer
461:16 - we're going to transfer token to
461:19 - the contract address
461:21 - with a certain amount
461:23 - and of course we'll do from
461:26 - account
461:28 - we'll do tx.weight
461:30 - and then we'll do print
461:33 - funded contract
461:35 - and then we'll even return that
461:36 - transaction
461:37 - i do however want to show you another
461:39 - way to work with this using the
461:41 - interfaces instead of doing this
461:43 - linktoken.transfer directly on the
461:45 - contract we can use this interfaces
461:47 - section
461:49 - to actually interact with some contracts
461:51 - so right now we have our mock link token
461:53 - in here which is great because it has
461:55 - all the definitions and all the
461:56 - functionalities defined in here
461:58 - sometimes you're going to have contracts
461:59 - that you don't have everything you don't
462:01 - have all the functionality and maybe you
462:03 - only have the interface maybe you only
462:05 - have some of the function definitions so
462:07 - we can still interact with contracts
462:09 - with just an interface because again
462:11 - that interface will compile down to our
462:13 - api
462:14 - so as another way of teaching us how to
462:17 - actually work
462:18 - with some of these contracts
462:20 - what we can do
462:22 - is we can use we can use the link token
462:24 - interface basically the same way as we
462:27 - used the link token contract here so
462:28 - again i'm in my chain link mix because
462:30 - there's already a link token interface
462:32 - in here and this will compile down to a
462:35 - way that our brownie package knows how
462:37 - to interact with these contracts
462:39 - so if you wanted to we could just grab
462:40 - this
462:41 - go to our brownie section
462:43 - we'll do a new file in interfaces
462:47 - we'll call it link
462:49 - token interface
462:51 - dot soul
462:53 - we'll paste it in here
462:55 - save my auto format auto formatted here
462:58 - and what we can do in our helpful
462:59 - scripts instead
463:01 - is transaction
463:02 - equals interface
463:05 - and we can also just import interfaces
463:08 - right from brownie
463:10 - interface dot
463:13 - link
463:14 - token interface
463:16 - and we just need to give it
463:18 - a contract address so we can say link
463:22 - token dot address
463:25 - excuse me we could say
463:27 - link token
463:31 - contract equals interface dot link token
463:34 - interface link token dot address
463:36 - so this is another way we can actually
463:38 - create contracts to actually interact
463:40 - with them
463:41 - so we saw up here
463:42 - this contract.from abi which is great
463:45 - this is another way we can do that exact
463:47 - same thing so then we can just do
463:49 - linktokencontract.transfer
463:51 - contract address
463:53 - amount
463:55 - from
463:57 - account
464:01 - so this is tx equals
464:03 - so this is another way to actually
464:05 - interact with contracts that already
464:07 - exist you're probably starting to see
464:08 - that brownie has a lot of built-in tools
464:10 - that make it really easy for us to
464:12 - interact with contracts if we have the
464:14 - api we can just pop it into
464:16 - contract.from avi and again with the
464:18 - address and the api and then just give
464:20 - it some name if we have the interface we
464:22 - don't even need to compile down to the
464:24 - api ourselves because brownie is smart
464:26 - enough to know that it can compile down
464:28 - to the api itself and we can just work
464:30 - directly with that interface which is
464:32 - incredibly powerful for now
464:34 - i'm going to comment these two lines
464:36 - though and we'll just use the
464:38 - linktoken.transfer for now now that we
464:39 - have a funding script or a funding
464:41 - function we can import this from our
464:43 - helpful scripts
464:45 - from scripts.helpful scripts import get
464:47 - account get contract
464:49 - fund with link
464:51 - and we can just call in our end lottery
464:54 - function
464:55 - we'll do fund with link
464:57 - and parameters we just we only really
464:59 - need a contract address because the way
465:01 - we set this up we'll just automatically
465:03 - grab a default otherwise so we can say
465:07 - lottery dot address
465:10 - and that's it that's all we need and
465:12 - then i know we're doing tx.weight right
465:14 - in the fund with link but just for to be
465:16 - verbose here
465:18 - we'll get the transaction from the fund
465:20 - with link and we'll do tx.weight here as
465:23 - well
465:25 - and then once we're funded with link
465:27 - then we can go ahead and call our end
465:29 - lottery function because again this is
465:31 - going to call that request randomness
465:33 - function from the vrf we'll do
465:37 - end
465:38 - ending transaction
465:40 - equals
465:42 - lottery dot end
465:44 - lottery and all we have to do is from
465:49 - count
465:52 - to ending
465:54 - transaction.weight
465:56 - one
465:57 - so from our end this is really all that
465:59 - we need to do
466:01 - right but remember
466:03 - when we call this end lottery function
466:05 - we're going to make a request to a chain
466:07 - link node and that chain link node is
466:09 - going to respond by calling this fulfill
466:11 - randomness function
466:12 - so we actually have to wait for that
466:14 - chain link node to finish
466:16 - now typically it's within a few blocks
466:18 - so normally what we can do is we can
466:20 - just do a time dot sleep
466:23 - for something like 60 seconds
466:25 - and typically in that time the chain
466:26 - link node will have responded
466:28 - so we'll just do import time
466:30 - at the top
466:32 - time dot sleep
466:33 - and then
466:34 - we can see
466:36 - who that recent winner is if that chain
466:38 - link node responded with a recent winner
466:40 - so we can say print
466:43 - f
466:45 - lottery dot resent
466:47 - winner
466:50 - is the new winner
466:53 - all right now of course for those of you
466:56 - who are thinking ahead a little bit you
466:57 - might be thinking hey well there's no
466:59 - chain-link nodes watching our local
467:01 - ganache
467:02 - and you're exactly correct so what
467:03 - happens when
467:05 - we add
467:06 - our end lottery function
467:08 - to our main function here
467:10 - do you think that we're going to
467:11 - actually get a recent winner back why
467:14 - are we not what do you actually think
467:16 - well let's give it a shot
467:18 - do brownie run scripts deploy
467:20 - lottery.pie
467:24 - so we're doing a lot of transactions
467:25 - here we've started the lottery we're
467:28 - entering the lottery you entered the
467:30 - lottery we're sending some link token
467:33 - now we just called the end lottery
467:35 - function
467:36 - while we're waiting here
467:38 - this is when the chain-link node would
467:40 - go ahead and start responding with our
467:43 - randomness however as you're probably
467:45 - astutely telling however as you probably
467:47 - astutely guessed
467:49 - there's no chain-link node that's going
467:50 - to call this fulfill randomness function
467:52 - right now so for our grenache chain this
467:54 - will hypothetically end
467:57 - with nothing right because there's no
467:59 - chain-link node actually responding here
468:00 - zero is the new winner of course this
468:02 - means that the chain-link node actually
468:04 - didn't respond because there is no chain
468:06 - link node on our local ganache for our
468:08 - testing purposes we're going to figure
468:09 - out how to actually get around that and
468:11 - deal with that
468:12 - awesome it looks like we have everything
468:14 - set up to be successful in our lottery
468:16 - here
468:17 - but we want to do our due diligence we
468:19 - want to make sure that our tests are
468:22 - really solid on a development chain
468:24 - before we actually test this on an
468:26 - actual test then so let's jump into some
468:28 - of these tests we've already started
468:30 - with this testlottery.pi bit here but
468:32 - we're going to iterate on this and make
468:34 - this even better
468:36 - now before we get into these tests
468:37 - there's a couple of things we want to
468:38 - talk about here and that's going to be
468:40 - integration tests and unit tests unit
468:43 - test is a way of testing the smallest
468:45 - pieces of code in an isolated system
468:48 - and we're going to use it to loosely
468:49 - define testing independent functions in
468:51 - our lottery contract
468:53 - we also want to do what's called
468:55 - integration testing which is going to be
468:57 - testing across multiple complex pieces
469:00 - typically i like to run my unit tests
469:01 - exclusively on a development environment
469:04 - and my integration tests on a test net
469:06 - this is really helpful because we can
469:07 - test the majority of our application
469:09 - like we said on a development network
469:11 - and then still be able to see what
469:13 - actually happens on a real test net and
469:15 - see what happens on etherscan and
469:16 - everything like that
469:18 - typically
469:19 - what people do is in their side their
469:21 - tests folder they'll create two
469:23 - different folders one for unit
469:26 - and another folder for intergration
469:30 - since for this demo we're only going to
469:31 - have one file for both i'm just going to
469:34 - go ahead and not create these folders
469:35 - but
469:37 - but it's a pretty common practice
469:41 - instead what i'm going to do is i'm
469:42 - going to rename this i'm going to hit
469:43 - enter to rename it
469:45 - i'm going to do underscore type unit
469:49 - for unit tests and we're going to create
469:50 - a new file
469:52 - called test
469:53 - lottery
469:55 - integration
469:56 - dot pi so this one we'll do our
469:59 - integration test and in this one we'll
470:02 - do our unit tests now when writing unit
470:04 - tests we really want to test
470:06 - hypothetically every single line of code
470:09 - in our smart contract this is incredibly
470:11 - important of course because smart
470:12 - contracts are open to everybody to see
470:15 - and interact with so we really want to
470:17 - test every single line of code we have
470:19 - in here
470:20 - so let's go ahead and let's go ahead and
470:21 - finish writing a get entrance fee test
470:24 - that will work on a local development
470:25 - network as you can see we're already
470:27 - going to have to refactor this from what
470:29 - we originally had let's go ahead and
470:31 - just delete everything under here for
470:32 - now
470:33 - we already learned so much more from
470:34 - there all right so how are we going to
470:36 - test this get entrance view function now
470:38 - so first we're going to want to deploy
470:39 - our lottery again
470:41 - since we have
470:43 - a deploy lottery script already
470:47 - we can just use this deployed audio
470:48 - script as well
470:50 - if we wanted to we could just copy paste
470:52 - this hold part into our test but
470:54 - we're just going to go ahead and work
470:55 - from this deploy lottery script so
470:58 - we're going to import this and then we
470:59 - can actually even
471:01 - get rid of this from web3 line for now
471:03 - we can get rid of these two comments too
471:05 - and we'll say from
471:06 - scripts that deploy lottery
471:10 - import
471:12 - deploy
471:14 - lottery and on this deploy lottery
471:16 - function would say lottery
471:18 - equals deploy lottery
471:20 - and we will return our lottery
471:23 - now our unit test we'll say lottery
471:26 - equals deploy
471:28 - lottery
471:30 - and this will give us our lottery
471:31 - contract once we have our lottery
471:33 - contract
471:34 - we can just call this get entrance fee
471:37 - so we can say entrance fee
471:40 - equals lottery dot get
471:42 - entrance fee
471:44 - and oops let's just make sure we're
471:46 - doing the arrange
471:49 - act
471:52 - assert mentality here
471:54 - and we're going to want to make sure
471:55 - this entrance fee is what we expect it
471:58 - to be so what do we expect it to be
472:01 - well
472:02 - again our helpful scripts is going to
472:04 - deploy these mocks right
472:06 - it's going to deploy this mock and the
472:07 - initial value is this 2000 number so if
472:10 - the price
472:12 - of eth here is 2 000
472:15 - 2 000 f usd feed and the usd
472:20 - entry fee
472:22 - is 50.
472:23 - we'd say 2 000
472:25 - over 1
472:26 - is equal to 50 over x
472:30 - which is going to be equal to 0.025
472:34 - so we can go ahead and even do this math
472:35 - here
472:37 - we can say expected
472:42 - expected
472:44 - entrance fee
472:46 - is going to be equal
472:48 - to
472:48 - it's going to be equal to 50 divided by
472:50 - 2000.
472:51 - we'll just do 0.025
472:54 - but we'll do this in
472:56 - way so do from web3
472:59 - import web3
473:01 - we'll say this is web
473:03 - 3.2
473:05 - way
473:06 - 0.25 ether
473:09 - and now we'll assert
473:11 - our expected entrance fee
473:13 - equals
473:15 - the entrance fee now to test this we'll
473:18 - do brownie test k
473:22 - and perfect this is working
473:24 - exactly as we anticipated so that's
473:26 - awesome now as we mentioned since this
473:28 - is a unit test we really only want to
473:30 - run this when we're working on a local
473:32 - environment a local blockchain
473:34 - environment or a local development
473:35 - network so we'll go ahead and do this
473:37 - with pythons again
473:38 - so if network dot showactive
473:41 - is not
473:42 - in
473:43 - local blockchain environments
473:46 - pi test dot skip of course we're gonna
473:48 - have to import pi test
473:51 - we're gonna have to import this local
473:53 - blockchain environments from our
473:54 - scripts.helpful scripts my vs code
473:56 - automatically added that bit here now if
473:58 - we try to run this
473:59 - brownie run
474:01 - excuse me brownie test
474:03 - dash k
474:05 - get entrance fee dash dash network rank
474:09 - rink eb it should go ahead and skip this
474:13 - perfect that's what it does
474:14 - what's the next piece that makes sense
474:16 - here enter is going to be one of the
474:18 - first things that these developers do so
474:20 - let's do test def
474:22 - test enter but let's even be more
474:24 - specific than that we don't want people
474:26 - to be able to enter our lotteries unless
474:28 - the lottery is actually started so let's
474:30 - make sure that this line actually works
474:32 - so we'll call
474:34 - def test
474:36 - can't enter unless
474:39 - started and again we're only going to
474:41 - run this on a local development chain so
474:44 - we'll just copy paste this section down
474:46 - here we'll say lottery
474:48 - equals
474:50 - deploy
474:51 - lottery because we're going to want to
474:53 - work with the lottery and now we're
474:55 - going to want to that when people try to
474:57 - enter a lottery that hasn't started yet
474:59 - it's going to revert so we can use what
475:01 - we've used before we'll say with pi
475:03 - tests dot
475:04 - raises exceptions dot virtual machine
475:09 - error
475:11 - lottery dot enter
475:15 - from
475:16 - get account
475:20 - value
475:22 - lottery dot get entrance fee
475:26 - of course we're going to import both get
475:28 - account
475:30 - from our helpful scripts
475:32 - and exceptions from ronnie
475:37 - perfect and this as well is following
475:39 - the arrange
475:42 - and this is actually act slash
475:46 - assert so let's go ahead and test this
475:52 - brownie test k
475:54 - test can't enter unless starter
475:57 - oops let's do start ed
475:59 - and great that's passing as well let's
476:02 - go ahead and keep going down this list
476:04 - what else now we've tested whether or
476:05 - not they can't enter let's test whether
476:07 - or not they can enter so we'll do def
476:10 - test
476:11 - can
476:12 - start
476:14 - and
476:14 - enter lottery
476:17 - so we're going to copy this again
476:20 - paste it down here since we're going to
476:21 - work on a local blockchain
476:23 - we'll do lottery
476:24 - equals
476:25 - deploy
476:27 - lottery
476:29 - account equals get account
476:32 - we'll start the lottery
476:34 - lottery.start
476:38 - lottery
476:40 - we'll do from
476:42 - account
476:44 - we'll do lottery.enter
476:48 - from
476:49 - account
476:51 - save value is
476:53 - lottery
476:54 - dot get
476:56 - entrance fee
477:00 - and then we'll assert
477:03 - that
477:03 - we've correctly added a player to this
477:05 - lottery so we'll assert
477:07 - lottery.players
477:10 - of zero is going to be this account
477:14 - right because we have our players array
477:17 - and we're going to assert
477:18 - that we're pushing them onto our array
477:20 - correctly
477:22 - lottery.players 0 equals
477:24 - account so here's our act
477:28 - here's our assert
477:30 - so let's try this now
477:32 - brownie test dash k test can
477:35 - start and enter lottery
477:37 - and once again awesome things are
477:39 - looking great
477:40 - now let's test to see if we can actually
477:43 - end a lottery so we've tested we can
477:45 - start a lottery so we'll do def
477:48 - test can and
477:50 - lottery we're going to copy this again
477:53 - paste it down here
477:55 - do lottery equals deploy
477:58 - lottery
478:01 - account equals get account
478:05 - we'll start the lottery with
478:06 - lottery.start
478:08 - lottery
478:09 - now we could 100
478:11 - just import the rest of these functions
478:12 - in here like n lottery enter lottery and
478:15 - start lottery and similar to how we're
478:17 - just doing lottery equals deploy lottery
478:19 - we could absolutely do that for being
478:21 - very verbose here i'm just going to go
478:23 - ahead and write all the functions and
478:25 - transactions myself and this way we'll
478:28 - actually be able to test a little bit
478:30 - more granularly anyways
478:33 - we'll do lottery dot
478:35 - start lottery
478:37 - from
478:39 - account
478:42 - do lottery dots enter
478:45 - from
478:47 - account we'll give it a value
478:50 - lottery dot get entrance fee
478:56 - so i'm gonna have to do account
478:58 - course equals get account
479:02 - now
479:03 - to actually end the lottery we do need
479:05 - to send this some link because we're
479:07 - calling request randomness we use our
479:09 - fund with link script
479:11 - that we have in our helpful scripts
479:14 - we'll import this from our helpful
479:16 - scripts
479:18 - we'll call
479:19 - fund with link
479:21 - on our
479:22 - lottery contract
479:25 - once we fund with link we'll then call
479:27 - lottery dot
479:29 - end lottery
479:33 - from
479:34 - account
479:37 - and then how do we actually know
479:39 - that this is being called correctly well
479:42 - if we look back in our lottery contract
479:45 - here when we call end lottery we don't
479:47 - we're not really doing a whole lot all
479:48 - we're doing is changing our state so
479:50 - let's go ahead and check to see if our
479:53 - calculating winner state is different so
479:55 - we'll say assert
479:57 - lottery
479:59 - dot
480:01 - lottery state
480:03 - is equal to what
480:05 - so calculating winner if we scroll up to
480:07 - our enum
480:09 - is in position two open is zero close is
480:12 - one calculating winner is two
480:14 - so we can say
480:16 - assert lottery.lotterystate equals two
480:19 - two
480:21 - we can go ahead and test this as well
480:23 - we'll do brownie
480:25 - test k test can end lottery
480:29 - we'll see if this works
480:32 - and it does
480:33 - now let's test the most interesting
480:35 - piece of this entire lottery contract
480:37 - we're going to test whether or not our
480:39 - fulfill function actually works
480:41 - correctly
480:42 - does this correctly choose a winner does
480:45 - it correctly pay the winner
480:47 - and does it correctly reset so let's go
480:50 - ahead and build our most
480:52 - complicated and most important test of
480:54 - this whole contract choosing the winner
480:57 - we'll do def
481:00 - test
481:02 - can pick
481:03 - winner
481:05 - correctly
481:07 - let's copy paste this bit
481:10 - about getting started
481:12 - we'll do lottery equals
481:15 - deploy lottery
481:17 - account equals get account
481:20 - we'll do lottery dot start
481:23 - lottery
481:25 - from
481:27 - account
481:31 - and then we'll enter with a couple
481:32 - different players we'll do lottery dot
481:34 - enter
481:37 - let's say from
481:40 - account
481:42 - value
481:44 - lottery dot get
481:46 - entrance fee
481:51 - enter
481:53 - and we'll copy this two more times
481:55 - but instead
481:58 - we use some different ids we'll do index
482:01 - equals one
482:03 - and we'll do index equals 2.
482:06 - these are going to be different accounts
482:07 - here because we're going to use a
482:09 - different index
482:10 - because we want to just test for
482:11 - multiple different people here
482:14 - this unit test is getting drastically
482:16 - close to being an integration test but
482:17 - as i said we're being a little bit loose
482:19 - with the definitions here now we're
482:21 - going to want to fund it with link so we
482:23 - can just go ahead and copy this line
482:25 - here
482:26 - fund with link lottery
482:28 - and now we're going to want to choose a
482:29 - winner here
482:31 - and this is where we actually have to
482:32 - modify one more thing
482:34 - in our lottery contract so in order to
482:36 - test actually calling this fulfill
482:38 - randomness function
482:40 - and testing everything in here
482:42 - we're going to need to call this fulfill
482:45 - randomness function
482:47 - now if we look at our vrf coordinator
482:49 - moc
482:50 - we have this function called callback
482:52 - with randomness
482:53 - and this is the function
482:55 - that actually calls this raw fulfill
482:58 - randomness.selector which eventually
483:00 - will call that fulfill randomness
483:02 - function but this is the entry point
483:04 - that the that the node actually calls
483:07 - we have to pretend to be a chain-link
483:08 - node and call this function
483:11 - we're going to return
483:12 - a random number of course we're going to
483:14 - choose the contract we want to return to
483:17 - but we also have to pass the original
483:20 - request id
483:21 - associated with the original call now in
483:25 - our lottery contract
483:27 - our end lottery function
483:29 - isn't going to return anything
483:31 - and even if it did it would be really
483:33 - difficult for us to get that return type
483:35 - in our python so what we want to do
483:38 - to keep track of when this contract
483:40 - actually entered the calculating winner
483:42 - state is we want to do what's called
483:45 - emitting an event events are pieces of
483:47 - data executed in the blockchain and
483:49 - stored in the blockchain but are not
483:51 - accessible by any smart contracts you
483:54 - can kind of think of them as the print
483:56 - lines of a blockchain or the print
483:58 - statements of a blockchain
484:12 - we can go to this logs section which
484:14 - also includes all the different events
484:16 - now there's a lot of information here so
484:18 - we're actually going to do an event
484:20 - ourself just so that we can see what
484:22 - this really looks like you can see here
484:24 - that when we call this end lottery
484:25 - function
484:27 - in the logs if we scroll to the bottom
484:30 - there's an event here called
484:32 - randomnessrequest
484:33 - this was spit out by the vrf coordinator
484:36 - this was spit out by the vrf consumer
484:39 - base that we inherited and it even has
484:41 - some data that's already been decoded
484:43 - one of those pieces of data is the
484:45 - request id now to add an event we first
484:48 - need to create our event type
484:50 - so at the top we'll go ahead and do
484:53 - event
484:54 - requested
484:57 - randomness
484:59 - we'll say bytes 32
485:02 - request id
485:04 - so now we've identified
485:06 - a new type of event called requested
485:08 - randomness
485:10 - it's really similar to the enum in this
485:12 - regard
485:14 - to omit one of these events
485:16 - all we have to do in our end lottery bid
485:18 - is we'll do omit
485:20 - requested randomness and then request id
485:24 - because requested randomness takes a
485:26 - bytes32
485:28 - as an input parameter
485:30 - and we're going to pass it that request
485:31 - id as an input parameter now that we
485:34 - have this event being omitted back in
485:36 - our test when we call
485:38 - end lottery it will actually omit one of
485:40 - these events to our transaction
485:43 - so what we can say then
485:45 - is transaction
485:49 - equals lottery.nd lottery
485:53 - same way we've always done it
485:56 - but now we can look inside of this
485:57 - transaction object
485:59 - inside of this transaction object is
486:01 - actually an attribute called events
486:04 - which stores all of our events we can
486:07 - then look for
486:08 - a certain event name which we know is
486:10 - requested randomness so we'll say out of
486:13 - all the events look for the requested
486:14 - randomness event
486:18 - and in there
486:19 - in that request randomness event
486:22 - find the request id
486:26 - request id
486:29 - now we can say request id
486:33 - request
486:34 - id
486:36 - is going to get grabbed from this
486:38 - event that we omit so these events are
486:40 - going to be really helpful for writing
486:41 - tests these events are also really
486:43 - helpful for a number of other reasons
486:46 - one of the big ones is is upgrading our
486:48 - smart contracts or understanding when a
486:50 - mapping is updated but for now we're
486:52 - going to be using them for testing now
486:54 - that we have this request id what we can
486:56 - do is pretend to be the chain link node
486:59 - and use this callback with randomness
487:01 - function to dummy getting a random
487:03 - number back from the chainlike node so
487:05 - what we're going to do
487:07 - is we're going to call our getcontract
487:08 - function
487:13 - and get that vrf coordinator
487:16 - of course we're going to import it
487:18 - from our helpful scripts
487:20 - and we're going to call that callback
487:22 - with randomness function
487:23 - so we're going to do dot callback
487:27 - with
487:28 - randomness
487:31 - and we need to pass it
487:33 - this request id
487:35 - a random number
487:37 - and then the contract to return to
487:39 - so we'll do request id we'll do some
487:41 - random number
487:44 - like we'll say static
487:47 - rng
487:48 - equals 777.
487:51 - so we'll say the random number that
487:52 - we're going to return is going to be 777
487:55 - and then we'll do lottery dot address
487:57 - because we're going to return it to the
487:58 - lottery
488:00 - once again we're going to say from
488:02 - account because this is making a state
488:04 - change and now that we've got a call
488:06 - back what we can do is do our asserts
488:08 - now so this
488:10 - is us dummying getting a response from a
488:13 - chain-link node and this is how we mock
488:14 - responses in our tests to make our lives
488:17 - way way easier
488:19 - so now we can do we can figure out who
488:22 - the winner of this lottery actually is
488:24 - if these are our three enter entries
488:28 - that means it's 777
488:30 - mod 3 since our random number is going
488:32 - to be 777
488:34 - if we pull out a calculator
488:36 - 777 divided by three
488:39 - it divides evenly so we know that this
488:42 - means the answer to this is going to be
488:45 - zero
488:46 - aka our account is going to be the
488:48 - winner
488:49 - so let's assert
488:51 - the lottery dot
488:53 - recent winner
488:55 - is going to be equal to our account
488:57 - right because
488:59 - we set a recent winner
489:02 - in here
489:03 - we transfer them some money
489:07 - we'll assert
489:08 - lottery.balance
489:11 - is now zero because we're transferring
489:14 - this account all the money
489:17 - and let's even make sure that the
489:19 - account gets more money right so we'll
489:21 - do
489:22 - starting balance
489:23 - of our account
489:25 - starting balance of account
489:28 - equals
489:30 - account.balance
489:32 - count balance and we'll do balance
489:36 - of
489:37 - lottery
489:38 - equals lottery dot balance and then
489:41 - we'll assert
489:43 - account dot balance
489:44 - is now going to be
489:46 - these two added together
489:48 - started balance of account plus
489:51 - the balance of the lottery
489:54 - because we should get all of the lottery
489:56 - winnings here okay so this is a long
489:59 - test but this is probably the most
490:00 - important test let's make sure
490:03 - this is doing what we wanted to do so
490:05 - we'll do brownie test k
490:07 - test can pick winner correctly let's see
490:09 - if this works
490:10 - oops i forgot to put a
490:14 - put some parentheses here let's
490:16 - parentheses here
490:18 - let's try this again
490:19 - and perfect
490:21 - we are actually updating paying out and
490:25 - running our lottery correctly and fairly
490:27 - with true randomness this is incredibly
490:30 - exciting and we've emitted events in our
490:33 - lottery contract to use in the off chain
490:35 - event logging of ethereum i know we're
490:37 - getting antsy
490:39 - to actually run this on a real chain
490:42 - so let's go ahead and do our last bit
490:44 - here create our integration test which
490:47 - we will run on an actual chain and then
490:50 - if we wanted to we go ahead and try our
490:52 - deploy lottery function on a real chain
490:54 - as well all right so let's do our
490:57 - integration test here this is where
490:59 - we're going to actually test on a real
491:02 - live chain we're going to use ring
491:04 - because that's the network that we've
491:06 - been using this whole time which is
491:07 - great now i'm being a little bit liberal
491:09 - in the way that we're doing our tests
491:11 - here and we're just going to do one test
491:13 - for this integration test but keep in
491:15 - mind you're going to want to test every
491:16 - piece of your code so let's just create
491:18 - a test called def
491:20 - test
491:21 - can pick
491:22 - winner
491:24 - now this is going to be
491:27 - the opposite of our unit test
491:29 - our unit tests are only going to be on
491:31 - our local blockchains right we're going
491:33 - to skip if it's not on our local
491:34 - blockchains
491:36 - we're going to do the opposite of this
491:37 - one
491:38 - so we can even just copy this or we can
491:40 - type it out we'll say if
491:42 - our network
491:44 - dot show active
491:47 - is in those local
491:50 - blockchain environments
491:55 - then we're gonna do pi test
491:57 - dot skip
492:00 - of course since we're grabbing these
492:01 - pieces we're gonna do from
492:04 - brownie import
492:06 - network
492:08 - we're going to import pi test
492:11 - and we're going to do from scripts
492:13 - dot
492:14 - helpful scripts
492:16 - import
492:18 - local
492:20 - blockchain and by enronments
492:24 - we're going to deploy our lottery so
492:25 - lottery equals deploy
492:29 - lottery
492:31 - which we're just going to grab from
492:34 - scripts deploy lottery
492:38 - import deploy
492:41 - lottery
492:43 - we'll do account equals get account
492:46 - of course we're going to grab that from
492:48 - our helpful scripts as well
492:52 - so we'll do lottery
492:55 - let's start lottery
492:59 - this will be from
493:01 - account
493:04 - do lottery.enter
493:08 - say this will be from
493:10 - account
493:13 - we'll do some value which is going to be
493:17 - dot lottery.get entrance fee
493:20 - and if we run into an issue here
493:21 - sometimes again we can do lottery dot
493:23 - get interest fee plus like 100 or a
493:25 - thousand or something like that this is
493:26 - going to be barely any way but
493:28 - for now let's keep it like this
493:30 - then let's just copy this line
493:33 - right again we'll have two people enter
493:35 - the lottery
493:36 - of course it's going to be us both times
493:39 - and great
493:40 - now we're going to want to actually end
493:41 - the lottery so first we're going to want
493:43 - to fund it so let's import that funding
493:45 - script so we'll get fund with link or
493:48 - that function
493:51 - so we'll call our fund with link
493:53 - function on our
493:55 - lottery contract here and then we'll go
493:58 - ahead and end the lottery so we'll say
494:00 - lottery
494:02 - dot
494:04 - and lottery
494:06 - we have to do this
494:07 - from our main account we have to do this
494:09 - from the admin account
494:11 - now this is where it's going to be a
494:12 - little bit different from our
494:14 - integration tests
494:16 - or from our unit tests
494:18 - in our unit tests
494:20 - we pretended that we were the vrf
494:22 - coordinator and we called the callback
494:23 - with randomness we pretended that we
494:25 - were a chain-link node
494:27 - here we're not a chain link node because
494:29 - we're on an actual network so we're
494:31 - actually just going to wait for that
494:32 - chain link node to respond so for
494:34 - simplicity we'll just do time dot sleep
494:37 - and we'll wait like a minute for it to
494:38 - respond
494:40 - of course since we're using time
494:43 - we're going to want to import time right
494:45 - at the top
494:46 - and then since account was the only one
494:48 - to actually be in this
494:50 - we'll do assert
494:52 - lottery
494:53 - recent winner
494:56 - equals equals account
494:58 - and we'll also assert
495:00 - lottery.balance
495:02 - 0. all right great so we have an
495:05 - integration test that we can run which
495:07 - is going to run through pretty much the
495:08 - vast majority of our functionality here
495:11 - so we can go ahead and test this with
495:13 - brownie
495:16 - test
495:17 - will be a little bit verbose here we'll
495:19 - say dash k
495:21 - test can pick winner
495:22 - and then of course we'll do dash dash
495:24 - network
495:25 - rink b now before we run this
495:28 - per usual we got to make sure do we have
495:31 - any test that ring the ethereum we do
495:33 - great do we have any test net chain link
495:36 - we do perfect we have a dot env
495:41 - we do it's got all of our pieces let's
495:43 - check our brownie config
495:45 - dot env dot env awesome and again if you
495:48 - don't want to use the dot envy
495:50 - you can use that other method that we
495:52 - showed you guys how to encrypt with a
495:54 - password that you can actually use
495:56 - oops before we run this
495:58 - let's set this to start lottery because
496:00 - that's the
496:01 - actual function here and we'll also need
496:03 - to be lottery.balance with parentheses
496:05 - here sorry about that and now we can run
496:07 - brownie test dash k
496:10 - fast can pick winner dash network
496:13 - rink b
496:14 - we'll also add this dash s flag which
496:17 - will print out whatever brownie is going
496:18 - to be printing out make everything a
496:20 - little bit more verbose here and if you
496:22 - want to you absolutely should because
496:24 - this is something that we'll have to do
496:25 - at some point anyways however if for
496:27 - this tutorial you want to skip it go
496:29 - ahead because we're actually going to
496:31 - run through this whole process of
496:33 - deploying and waiting again anyways so
496:35 - now we've added all of our tests what we
496:37 - can do is run our entire test suite
496:40 - so we'll do brownie
496:41 - test
496:42 - and this is going to run through all of
496:44 - our development tests here you'll see
496:46 - it'll go really quickly
496:48 - and you see how much faster it is for us
496:50 - to run our test on a local chain as
496:53 - opposed to doing everything on a test
496:54 - map so it's going to make your life way
496:56 - easier and we have everything passed
496:57 - here so we know that our contract code
497:01 - is doing approximately what we wanted to
497:02 - do
497:04 - so
497:05 - it's time for the moment of truth let's
497:07 - deploy this to an actual test net so we
497:10 - have our deploy lottery script which
497:12 - oftentimes
497:13 - i'll have it be just this deploy lottery
497:15 - bit and then i'll have some other
497:17 - scripts for these other pieces or maybe
497:18 - i'll do it in the brownie console
497:20 - but
497:21 - just to demonstrate everything end to
497:23 - end we'll have deploy lottery start
497:25 - lottery enter lottery and end lottery
497:27 - all in this one script
497:29 - so that we can see everything end to end
497:31 - and see what it looks like on etherscan
497:33 - so let's go ahead
497:35 - and run this script on a ringbeat
497:37 - network and then we'll go jump onto
497:38 - etherscan and see everything
497:41 - so let's do it brownie run scripts
497:44 - deploy lottery
497:46 - network ring can be
497:51 - so first we went ahead and we deployed
497:53 - our lottery we got our addresses with
497:55 - our get contract method
497:57 - we got our fee we got our key hash
497:59 - we got our published source and
498:00 - everything here then we went ahead and
498:02 - verified it because of this published
498:04 - source
498:05 - so if we grab this address lottery
498:07 - deployed here
498:09 - we jump over to
498:11 - rank the ether scan
498:13 - paste this address in here
498:15 - we'll see
498:16 - this contract with a little check mark
498:18 - is verified
498:19 - again we'll go to the read contract we
498:21 - can see all the public variables and all
498:23 - the public functions we can go to write
498:24 - contract and we'll see all the
498:26 - transacting functions that we can
498:27 - interact with after we get verified
498:30 - and things get deployed we went ahead
498:32 - and called our start lottery function to
498:34 - actually start the lottery we got our
498:36 - little print line saying the lottery
498:38 - started then we entered you entered the
498:40 - lottery we then funded the contract with
498:43 - link so we could get our random winner
498:44 - back
498:45 - and then right now our end lottery is
498:48 - confirmed and we're just waiting this 60
498:51 - seconds right because we did this
498:52 - time.sleep and if we sit on this
498:54 - contract if we go to transactions
498:56 - and we refresh we can actually see some
498:59 - of these different method calls over
499:00 - here we can see we did a contract
499:02 - creation
499:03 - we started the lottery we entered the
499:05 - lottery and then we recently ended the
499:07 - lottery and you'll see
499:09 - in our script here it says
499:11 - zero x blah blah is the new winner which
499:15 - is perfect right that means that the
499:16 - chain link node actually responded we
499:18 - can actually verify that by looking in
499:22 - the contract
499:23 - we'll go to read contract
499:25 - we can go to the recent winner and see
499:27 - somebody did indeed recently win we can
499:30 - also go to events
499:31 - and we can see some of the events that
499:33 - we created
499:34 - we can see this first event right here
499:37 - is this requested randomness event this
499:39 - is the event that we called we have this
499:41 - end lottery here we can also see an
499:43 - ownership transferred function that got
499:45 - called this was called when we actually
499:46 - deployed this in the first place
499:48 - now a little bit more on these events
499:50 - aka these logs right
499:52 - so topic zero this hash represents this
499:56 - entire event right here
499:58 - and this
499:59 - bit is going to be our topic one our
500:01 - first topic which represents that
500:03 - request id
500:04 - so this is going to be the request id
500:07 - awesome we have successfully created a
500:09 - working smart contract lottery with true
500:11 - provable randomness this is absolutely
500:14 - insane incredible job here now one
500:16 - additional piece that i want to talk
500:18 - about before we jump off here
500:20 - is again in our testing
500:22 - a file that you're often going to see
500:24 - is what's called conf test dot pi python
500:28 - automatically knows to look for this
500:29 - comp test file and we'll grab different
500:31 - functions from it we can also add
500:33 - external plugins
500:34 - fixtures hooks testing root path it adds
500:37 - a lot of really fantastic features and
500:39 - is a common thing that you'll see we
500:41 - skipped over in here for simplicity but
500:43 - in future projects you'll probably see
500:44 - this comp test file which has a lot of
500:46 - really nice testing configuration pieces
500:49 - in it
500:54 - now that was a lot of stuff to code and
500:57 - quite frankly i don't think any of us
500:59 - want to have to do that every single
501:00 - time have to code everything from
501:02 - scratch now you can absolutely get clone
501:04 - all these repositories right from their
501:06 - github but there's actually an even
501:08 - easier way first to start with a blank
501:11 - project here and this is with brownie
501:13 - mixes so if we google brownie mixes
501:16 - github we'll get this mixes organization
501:19 - which just has a ton of boilerplate code
501:22 - for us to go ahead and get started and
501:25 - start developing the one we're going to
501:27 - be working with is this chain link mix
501:29 - piece which is forked from this official
501:31 - one here this gives us some wonderful
501:33 - contracts some tests a browning config
501:36 - and really everything that we need to do
501:38 - to get started so if you have brownie
501:40 - installed
501:41 - we can just bake this mix so we'll do
501:43 - brownie
501:44 - bake
501:45 - chain lick mix and in our new empty
501:47 - directory here
501:48 - we'll get this new chain link folder
501:51 - with everything inside of it so then we
501:53 - can see the chain link
501:55 - and we can see it has all these pieces
501:57 - in here here already
501:59 - in the contracts we have a whole bunch
502:01 - of different samples of working with the
502:03 - vrf working with the price feed
502:06 - working with this thing called keepers
502:08 - to automate our smart contracts and
502:10 - making api calls and delivering any api
502:12 - call that we want to the blockchain it
502:14 - also has a brownie config which already
502:16 - has a number of wonderful pieces in each
502:20 - one of these networks so that we don't
502:21 - have to go copy paste and add it in here
502:23 - it's even got support for test nets like
502:25 - avalanche polygon
502:27 - finance and more it has a number of
502:30 - really powerful tests including testing
502:32 - some price feeds it has a whole bunch of
502:34 - deployment scripts some mocking scripts
502:37 - some helpful scripts and really
502:38 - everything that we need to get started
502:39 - and get going for starters we can run
502:41 - brownie test
502:45 - and it's going to compile everything
502:47 - and then on a development chain run all
502:49 - these
502:50 - unit tests and if we wanted to test this
502:52 - on a real test net we could do brownie
502:54 - test dash dash
502:55 - network ring b or any network that we
502:57 - wanted if you're looking for a good
502:59 - starter place that has a lot of really
503:01 - powerful smart contracts for you to get
503:03 - started i highly recommend using this
503:05 - mix as a boilerplate starting point for
503:08 - any of your contracts or any of your
503:10 - projects here
503:16 - now we are cooking so we've learned a
503:18 - ton of the fundamentals of working with
503:20 - brownie and working with smart contracts
503:23 - now that we have kind of all the
503:24 - building blocks though we can actually
503:26 - code a lot of these much faster and much
503:28 - more efficiently than before one of the
503:30 - things that we've seen over and over and
503:32 - over again is working with tokens and
503:35 - the erc20 token standard
503:38 - we're going to learn how to build our
503:40 - own token before we do that let's
503:42 - understand why we'd even want to do this
503:44 - now first let's define even what are
503:46 - erc20s so erc20s are tokens that are
503:49 - deployed on a chain using what's called
503:51 - the erc20 token standard you can read
503:54 - more about it in the erc20 token
503:55 - standard here link in the description as
503:57 - well but basically it's a smart contract
503:59 - that actually represents a token so it's
504:01 - token with a smart contract it's both
504:03 - it's really cool tether chain link uni
504:05 - token and die are all examples of erc20s
504:09 - technically chain link is in the rc677
504:12 - as there are upgrades to the erc20 that
504:14 - some tokens take that are still
504:16 - backwards compatible with erc20s and so
504:19 - basically you can think of them as
504:20 - erc20s with a little additional
504:22 - functionality now why would i even care
504:24 - to want to make an erc20 well you can do
504:25 - a lot of really cool stuff with it you
504:27 - make governance token you can secure an
504:29 - underlying network you can create some
504:31 - type of synthetic asset or really
504:33 - anything else in any case how do we
504:35 - build one of these erc20s how do we
504:37 - build one of these tokens well all we
504:39 - have to do is build a smart contract
504:41 - that follows the token standard all we
504:43 - have to do is build a smart contract
504:45 - that has these functions it has a name
504:47 - function a symbol function decimals
504:49 - function etc all these functions we need
504:51 - to be able to transfer it we need to be
504:53 - able to get the balance of it etc and
504:55 - again if you want to check out some of
504:56 - the improvements that are still erc20
504:58 - compatible like the erc677 or the erc777
505:03 - you definitely go check those out and
505:04 - build one of those instead so let's
505:06 - create a new folder and get started
505:08 - we're going to create our new browning
505:09 - file of course with brownie init it's
505:11 - going to start up our repository and
505:14 - start up everything that we are going to
505:15 - work with here we can kind of actually
505:17 - just jump in and start right with our
505:19 - contracts so let's create a new file and
505:21 - we'll call it our token
505:24 - dot sol
505:26 - and this is where we're going to add all
505:28 - of our token code
505:30 - now since this is an eip right this all
505:33 - this is is a smart contract so what we
505:35 - could do is we could grab all these
505:37 - functions
505:38 - copy and paste them in here one at a
505:40 - time
505:41 - grab the name
505:43 - grab the symbol
505:44 - grab the decimals and then you know code
505:47 - all these up be like this does some
505:49 - stuff blah blah blah or
505:52 - we could do it the much easier way right
505:54 - since we're engineers we don't always
505:55 - want to reinvent the wheel so once again
505:59 - our friends at open zeppelin
506:02 - have some amazing contract packages for
506:04 - actually building our own erc20 token so
506:07 - we can go right to the opens up and
506:08 - documentation i'm working on the 4x
506:10 - version but again it doesn't matter the
506:12 - version that you use so long as in our
506:15 - config file we add the version that
506:17 - we're going to use which again we've
506:19 - already gone over so let's go over to
506:20 - their erc20 documentation and this is
506:23 - the entirety of the code that is needed
506:26 - to make an error c20 so we can just go
506:28 - ahead and even copy this
506:30 - paste it in here and boom
506:32 - we have some erc20 code in here let's
506:34 - actually just change the name of
506:36 - everything in here though so we're going
506:37 - to call this our token
506:41 - dot sol
506:42 - we have
506:43 - this spdx license identifier mit great
506:47 - we're going to be using solidity version
506:48 - 0.8 which i know i've done a lot of this
506:51 - code actually in point in 0.6 but i
506:54 - highly recommend working with 0.8
506:56 - because it has a lot of really fantastic
506:59 - improvements to solidity you'll notice
507:01 - this is our first dive into using a
507:03 - different version of solidity here
507:05 - you'll notice that most of the syntax is
507:07 - exactly the same there are like i said a
507:09 - couple of nice improvements with 0.8 the
507:11 - main one being you no longer have to use
507:13 - those safe math functions that we talked
507:14 - about before but then we're going to go
507:16 - ahead and import opens up when contracts
507:18 - token erc20.sol now of course since
507:21 - we're importing open zappone we're
507:22 - importing this package we've got to add
507:24 - this to our browning config
507:28 - diamo
507:30 - and before we even get started you
507:32 - technically have all the tools that you
507:34 - need to code and deploy your own erc20
507:36 - token now i'm actually going to
507:38 - challenge you to go ahead and try to
507:41 - start a browning project create your own
507:43 - token using opensupplement packages and
507:45 - then deploy it on a test net i'm going
507:47 - to show you how to do all of it here
507:48 - anyways but challenging yourself and
507:51 - trying to do things your own and
507:52 - exploring is really one of the fastest
507:54 - ways to learn and grow in this space
508:00 - did you give it a shot no really pause
508:02 - it now and give it a try
508:04 - all right welcome back now we'll go
508:06 - through it and we'll do it together
508:08 - of course we need to add these
508:09 - dependencies
508:13 - open zeppelin
508:15 - open
508:17 - zeppelin contracts
508:19 - let's do their version four
508:23 - so let's even go to github
508:26 - open zeppelin
508:31 - and we'll do
508:32 - 4.2.0 which was released yesterday at
508:34 - this time which is great 4.2.0
508:38 - and of course again compiler
508:41 - we'll have silk
508:47 - remappings
508:54 - we'll add
508:55 - at open zeppelin
508:58 - equals
509:00 - this
509:03 - and then we're going to go ahead and
509:04 - save
509:05 - now we can use this at opens up line and
509:07 - it will refer to the opens up and
509:09 - contracts here so great now we can go
509:11 - ahead and import these
509:12 - let's change the contract name to our
509:14 - token we're going to inherit this
509:17 - erc20.sol from open zeppelin we can even
509:20 - go ahead to opens up on contracts github
509:22 - and we can even see what this erc20
509:24 - looks like so we can go to
509:26 - their contracts down to token
509:29 - erc20
509:31 - erc20.sol
509:33 - and this is their initiation of an erc20
509:36 - which has all these functions like name
509:39 - symbol
509:41 - decimals total supply etc in our
509:43 - constructor we're going to add an
509:45 - initial supply which is going to be in
509:47 - way of course so the initial supply of
509:49 - that token and we're going to use the
509:50 - constructor of the erc20.sol which again
509:54 - we can go ahead and check in the code
509:56 - here and we can see the constructor uses
509:58 - a name
509:59 - and a symbol
510:00 - so we have a name we'll call it r token
510:04 - and the symbol will do ot and boom that
510:07 - is literally all we need for our token
510:09 - here i told you this is going to be a
510:10 - much faster project now for scripts all
510:13 - we have to do is create a new file
510:15 - we'll add a 1
510:17 - deploy token dot sol and we'll also add
510:21 - a helpful
510:23 - scripts apply
510:25 - excuse me this deploy token dot pi
510:27 - excuse me
510:29 - we'll just quickly add a account
510:31 - function we'll say def get account and
510:34 - you can go ahead and just copy paste
510:35 - from the last one and if you want you
510:37 - can actually just copy paste from our
510:38 - last helpful scripts because it's pretty
510:39 - much going to be exactly the same so we
510:41 - have all these wonderful
510:43 - ifs statements so that we can deploy
510:46 - from really anything that we want now in
510:48 - our deployment token script we'll do
510:50 - from
510:51 - brownie
510:53 - import
510:55 - our token
510:59 - and then from
511:00 - scripts that's
511:03 - helpful scripts
511:05 - import
511:06 - get account and just to make sure let's
511:08 - add an init
511:11 - dot pi in here
511:13 - just to make sure that our scripts can
511:14 - actually import so since we know
511:17 - since we know that we need an initial
511:19 - supply here let's go ahead and do
511:21 - initial
511:22 - supply
511:24 - equals and then we can do you know
511:26 - whatever we want here
511:27 - if we want to make it a little bit more
511:28 - readable we'll also
511:30 - do
511:32 - from web3
511:33 - import web3
511:35 - and we can do
511:36 - web3.2
511:38 - way and we'll say
511:41 - 1000 as the initial supply and this is
511:44 - in ether
511:45 - so our initial supply is going to be
511:46 - 1000 ether
511:49 - then we just add our main function
511:52 - we do account
511:54 - equals get account
511:55 - we do our token
511:57 - equals
512:00 - our token
512:01 - dot deploy
512:03 - we just add as a parameter
512:05 - this is initial supply
512:08 - do from
512:10 - account and then we'll do print
512:14 - our token dot
512:16 - name
512:17 - and that's the whole function now of
512:19 - course if you don't have your
512:20 - environment variable set we're going to
512:22 - add our dot enb file
512:23 - this is where we can add our private key
512:26 - our web3
512:28 - infiera
512:30 - project id and then if we want our ether
512:32 - scan token i'm going to skip doing this
512:34 - for now because my environment variables
512:36 - are already set
512:37 - and then last but not least we'll add
512:39 - dot env
512:40 - dot env
512:42 - so private key equals ox blah blah blah
512:45 - when three inferior priority equals blah
512:47 - blah blah ether scan token equals blah
512:49 - blah blah
512:51 - and perfect now if we want to actually
512:53 - deploy this to a testnet all we have to
512:55 - do
512:56 - go into our config
512:58 - we'll add wallets
513:01 - from key
513:03 - we'll add our environment variable
513:04 - private key
513:07 - now brownie knows where to grab this
513:09 - from because we've defined it in our
513:10 - helpful scripts what i can do now
513:13 - so brownie runs scripts deploy token.pi
513:18 - and we can go ahead and see that our
513:19 - token is printed out
513:21 - we can see that we have this token
513:22 - deployed on our local ganache
513:24 - we can see our token here and this is
513:26 - great now i can go ahead and run
513:28 - this again
513:31 - network ring b
513:35 - now if i grab this address go to the
513:37 - ringby ether scan
513:39 - pop it in after a quick refresh i can
513:41 - now see that
513:42 - my contract has indeed been added and
513:45 - etherscan even picks up that it's a
513:47 - token
513:48 - now we could do we can grab this and
513:50 - grab this contract address
513:52 - go to assets
513:55 - add it in our metamask here
513:58 - next
513:59 - add tokens and you'll see we are the
514:01 - proud owners of 1000 hour tokens now
514:05 - something else that you might want to do
514:06 - is add this to a liquidity pool or add
514:08 - this to a place where you can actually
514:10 - go ahead and sell it and put it on the
514:11 - market you can do something like that as
514:13 - easily as just popping onto uniswap
514:16 - going to pool hitting more
514:19 - create a pool
514:20 - and then adding our token in here we'd
514:22 - have to manage the token list and be
514:24 - sure to add the token in here but we
514:26 - could go ahead and add a token
514:28 - create our own pool and automatically
514:30 - put it on your swap and that's how easy
514:32 - it is to actually sell it on one of
514:33 - these pools but alright so this was
514:35 - probably our easiest project of the
514:37 - course but it really shows how far
514:38 - you've come along everything here
514:45 - i thought we know a little bit more
514:46 - about d5 and why it's such an amazing
514:49 - amazing technology that only works in
514:51 - the blockchain world let's look at this
514:53 - site d5 pulse or if you want to look at
514:56 - another one uh there's another fantastic
514:58 - one out there called defined llama which
515:00 - also shows a lot of these different
515:02 - protocols in here so defy pulse is an
515:04 - application that shows some of the top
515:06 - d5 projects based on how much
515:09 - total asset is locked into each protocol
515:12 - ave which currently is the number one
515:14 - ranked d5 application with 9.32
515:18 - billion in assets under management in
515:20 - terms of usd then we have some fantastic
515:22 - ones like curve compound maker instadap
515:25 - etc now we're going to be looking at two
515:27 - of these protocols in particular the
515:29 - first one of course
515:31 - being ave and the second one is going to
515:33 - be a type of what's called a
515:34 - decentralized exchange you start with
515:36 - ave we're going to go to testnet.ave.com
515:41 - dashboard and it'll bring us to a screen
515:42 - that looks something like this with
515:44 - please connect your wallet and
515:45 - everything will be pretty empty parasop
515:47 - is what's known as a dex or a
515:49 - decentralized exchange it allows us to
515:51 - trade tokens incredibly easy on the
515:53 - blockchain now there's not a whole lot
515:55 - of test net indexes that actually work
515:58 - so we're just going to look at them and
515:59 - simulate as if we were working on them
516:02 - for example if i wanted to trade one eth
516:05 - for some usdt or maybe some wrapped
516:08 - bitcoin or some dye or some ave
516:11 - or link or really any token that we
516:13 - wanted
516:14 - all we would need to do is connect our
516:16 - wallet here
516:17 - and
516:18 - a swap button would show up and we would
516:20 - go ahead and hit swap some other really
516:22 - powerful these dexes and really popular
516:24 - ones are going to be curve finance
516:26 - uniswap and it's a really really easy
516:28 - way to go ahead and swap your tokens for
516:30 - one another depending on what you're
516:31 - looking to do ave is incredibly powerful
516:35 - and it's going to be one that we're
516:36 - going to be working a lot with because
516:37 - it has pretty much all the fundamentals
516:39 - of working with the d5 protocol that
516:41 - we're looking for and it has a test
516:43 - stand that we can go ahead and test and
516:45 - simulate actually working with some of
516:47 - these protocols so we're going to first
516:49 - work with the ui or the user interface
516:51 - and then we're going to do everything
516:53 - here programmatically first things first
516:55 - if you don't already have it make sure
516:56 - you have some test net ethereum at least
516:59 - and again you can get some test and
517:00 - ethereum from looking at the link token
517:02 - contracts
517:03 - and going to coven
517:05 - this one indeed uh the test net of ave
517:08 - right now is only on coven so we're
517:10 - going to go ahead here
517:12 - we're going to add our copy our address
517:14 - paste it in
517:16 - i'm not a robot
517:19 - 70.1 test eth remember we use this
517:21 - linked token contracts page because this
517:23 - is going to have the most up-to-date
517:24 - faucets here once we see some eath in
517:27 - our coventestnet here we can go back to
517:29 - ave
517:30 - so whereas paraswap allows you to simply
517:32 - swap between assets and do a lot of
517:34 - buying and selling of tokens
517:36 - ave is a lending and borrowing
517:38 - application so we can actually put down
517:40 - a token as collateral and we can borrow
517:42 - and we can generate some yield from
517:44 - interacting with this protocol borrowing
517:46 - and lending is a critical piece to doing
517:48 - any type of really interesting financial
517:50 - applications or financial instruments
517:52 - such as short selling being exposed to
517:54 - more assets etc
517:56 - you can also gain some percentage back
517:59 - if you look at apy
518:00 - it'll tell you how much percentage over
518:02 - a year you'll actually get in returns
518:05 - from staking or depositing an asset
518:08 - so here's what we're going to go ahead
518:09 - and do we're going to connect to the
518:10 - application
518:11 - using metamask and you'll see on the
518:13 - deposit tab here we'll see our balance
518:16 - be 0.1 each because that's how much i
518:18 - currently have in my wallet right now
518:21 - what we can now do
518:22 - is click on ethereum click this max
518:24 - button to deposit some ethereum
518:26 - we'll hit continue
518:28 - and a little dashboard will pop up
518:30 - asking us okay would you like to deposit
518:32 - clicking this deposit button will
518:34 - actually have us deposit right onto the
518:37 - ave contract on the coventest net make
518:39 - sure once you hit deposit here that
518:41 - you're actually on a test net here it
518:42 - looks like i actually have some
518:43 - insufficient funds so i'm actually going
518:45 - to go
518:46 - borrow a little bit more
518:48 - or from the faucet here
518:50 - grab a little bit more from the faucet
518:51 - here
518:52 - we're going to come back
518:54 - we're actually going to go back
518:57 - refresh and now it says i have
519:00 - 0.1
519:02 - we're going to deposit 0.1
519:05 - continue
519:06 - deposit and metamask is going to pop up
519:09 - saying hey are you sure you want to do
519:10 - this right we can check our data
519:13 - we can grab this address even if we want
519:16 - pop it on to
519:18 - coven.etherscan
519:23 - paste it in here
519:25 - we can even double check to make sure
519:27 - that this is indeed the right contract
519:29 - that we want funnily enough you'll see
519:31 - that this is the west gateway when we
519:33 - deposit our covent eath it actually gets
519:35 - transferred into an erc20 version of our
519:38 - ethereum and then it'll go ahead and
519:41 - deposit it into the ave contract so
519:43 - we're going to hit confirm
519:45 - now we're going to get this pending here
519:48 - we have a link to the explorer
519:50 - which shows us this transaction that's
519:51 - going through and then we'll see that
519:53 - we've indeed successfully deposited our
519:56 - ethereum now down here you'll see a
519:58 - little button add a eth to your browser
520:00 - wallet and we're going to go ahead and
520:01 - click this
520:02 - and this will automatically add this
520:04 - token
520:05 - to our wallet so we're going to hit add
520:07 - token
520:08 - and we see now in assets we have this ae
520:11 - down here
520:13 - we could also have manually hit added
520:15 - token got the contract address but avi
520:17 - was nice enough to just go ahead and add
520:19 - us a little button that does it for us
520:21 - ae is what's called an interest-bearing
520:24 - token and it goes up in real time you'll
520:26 - see if i sit here long enough you'll see
520:29 - this number actually continually going
520:30 - up this is the profit given to us from
520:33 - other people borrowing the eath that
520:35 - we've deposited into ave if we go to our
520:37 - dashboard now
520:39 - we can see we have 0.1 each deposited
520:42 - and if we roll over it you'll constantly
520:44 - see the amount go up and up and up we
520:47 - can go ahead and withdraw our eath
520:51 - which will convert our a
520:54 - back into eath with the additional
520:56 - interest that we got from depositing so
520:58 - depositing into ave will give us
521:00 - interest back as a payment for other
521:02 - people borrowing the eath that we've
521:04 - deposited we can also use this eath as
521:07 - what's called collateral so if i go to
521:09 - this borrow tab
521:10 - i can actually use the eath to borrow
521:13 - some other acid maybe i want to borrow
521:15 - dye which is a stable coin meant to
521:17 - always equal one dollar usdc and usdt
521:20 - also are meant to always reflect a
521:22 - dollar we can borrow what's called
521:24 - wrapped bitcoin which represents the
521:26 - bitcoin price we could borrow some
521:28 - ave token some bat token some link token
521:32 - we can borrow all these different tokens
521:34 - now borrowing an asset is incredibly
521:36 - incredibly powerful by borrowing you're
521:38 - allowed to obtain liquidity without
521:40 - selling your assets and borrowing is one
521:42 - of the first pieces in order to actually
521:44 - short sell borrowing in default
521:46 - protocols is absolutely massive because
521:48 - it allows you to frictionlessly short
521:50 - sell obtain liquidity without closing
521:52 - your position
521:53 - gain yield on some deposited collateral
521:55 - you can do a massive number of new
521:58 - things only in the default world such as
522:00 - flash loans
522:02 - now an important note on borrowing
522:04 - assets on mainnet since we're just
522:07 - borrowing it on test net and this isn't
522:08 - real money this is 100 okay to
522:10 - experiment with and work with however if
522:13 - you borrow an asset and you do not pay
522:15 - attention to how much you have for an
522:17 - underlying collateral you could get
522:19 - liquidated and lose some of your funds
522:21 - so be very careful and pay a lot of
522:23 - attention if you're going to do this on
522:25 - an actual network now let's say we want
522:27 - to borrow the ave token for example we
522:30 - click here and we can choose the amount
522:32 - that we want to borrow now here's the
522:33 - thing
522:34 - since we've placed down some collateral
522:37 - right 0.1 if the amount that we borrow
522:40 - ends up being too high
522:42 - we'll actually get what's called
522:43 - liquidated every time we borrow an asset
522:46 - we get some type of health factor the
522:48 - health factor represents how close to
522:50 - being liquidated you are once your
522:52 - health factor reaches one
522:54 - the collateral that you've actually
522:55 - deposited will get liquidated and
522:58 - somebody else will get paid to take some
522:59 - of your collateral this is so that the
523:01 - the ave application is always solvent
523:04 - being solvent means it's never in debt
523:06 - so when i want to borrow i want to
523:08 - choose some amount that might be a
523:10 - little bit safe here and so that i'm not
523:12 - going to get liquidated so
523:15 - zoom in a little bit
523:17 - i'm going to choose some number where i
523:19 - see a health factor maybe like 5.6 we're
523:22 - going to continue now we'll have to
523:23 - choose our interest rate when we borrow
523:26 - an asset we actually have to pay some
523:28 - interest this payment is actually going
523:30 - to go to the people who are depositing
523:32 - die or depositing the asset the interest
523:35 - rate that we're going to pay is actually
523:36 - going to be paid to those who are
523:38 - depositing the asset that we're
523:40 - borrowing so like how we're getting
523:42 - interest on our deposited collateral
523:44 - others are getting interest on their
523:45 - deposited collateral based off of how
523:47 - often people are borrowing it we choose
523:50 - a stable apy which will always be four
523:52 - percent
523:53 - or a variable apy which will change
523:56 - based off of how volatile and how in
523:58 - demand this asset is for now i'm going
524:00 - to choose variable but you can pick
524:02 - whatever you want especially for this
524:03 - demo we're going to hit continue i'm
524:06 - gonna zoom out just a little bit
524:08 - and the same interface is gonna show up
524:11 - we're gonna go ahead and hit borrow
524:14 - metamask is gonna pop up and ask us if
524:16 - we really want to borrow we're gonna go
524:18 - ahead and hit confirm
524:20 - and now we've successfully borrowed die
524:23 - into our application we can even hit
524:25 - this little add die to your browser
524:27 - wallet
524:28 - to add the token to our wallet
524:31 - now if we hit the button we go to assets
524:33 - we can now see die is indeed in our
524:37 - token assets here now if we go back to
524:39 - our dashboard you'll see we have a
524:40 - health factor score here this is a
524:43 - really important score if you click on
524:45 - this little i thing it says the health
524:47 - factor represents the safety of your
524:48 - loan derived from the proportion of
524:50 - collateral versus amount borrowed keep
524:53 - it above one to avoid liquidation
524:56 - and we'll see all of our deposits here
524:58 - so we still have 0.1 in each deposited
525:00 - we also have 28 die deposited you can
525:04 - see a whole lot of different stats here
525:05 - for working with our application we can
525:08 - withdraw our die we can withdraw our eth
525:11 - we can borrow more die or we can go
525:13 - ahead and repay we can either repay from
525:15 - our wallet balance or from our current
525:17 - collateral yes we could repay with our
525:20 - collateral
525:21 - let's go ahead and do from our wallet
525:22 - balance
525:24 - we'll hit max
525:25 - continue
525:26 - and we even get this little thing that
525:27 - says you don't have enough funds to
525:29 - repay the full amount well why is this
525:31 - the case we just borrowed this amount
525:33 - it's because already since depositing
525:35 - we've accrued a little bit of we've
525:38 - accrued a little bit of extra debt
525:40 - remember we hit that variable apy
525:42 - and every second it's going to tick up
525:44 - just a little bit so let's go ahead and
525:46 - pay back what we can with our wallet
525:48 - we're going to confirm
525:49 - we're going to approve our data to be
525:51 - spent
525:52 - and then we're going to go ahead and hit
525:53 - the repay button and gray now if we go
525:56 - back to our dashboard you can see we've
525:58 - repaid almost everything here but we
526:00 - have a little bit left so let's just go
526:02 - ahead and hit repay with our current
526:04 - collateral we'll hit max
526:06 - continue
526:07 - and this will use our eth to pay back
526:10 - the collateral instead of the die
526:12 - and then we'll hit repay this way we'll
526:14 - have no more debt
526:16 - great now if we go back to our dashboard
526:18 - we can see we have no more debt which is
526:19 - fantastic ave is one of these
526:21 - applications that relies on the
526:23 - chainlink price feeds in order to
526:24 - understand the ratio between how much
526:27 - you have deposited as collateral and
526:29 - then how much you can borrow and take
526:30 - out if we look in our wallet now we can
526:32 - see we still have some aethe
526:35 - we also have some eath and now we have
526:37 - zero die because everything's paid back
526:39 - but we're still gaining interest on the
526:41 - eth we have deposited
526:43 - let's go ahead just reconnect
526:45 - let's go ahead back to testnet.aver.com
526:49 - and let's just withdraw all of our eth
526:56 - now keep in mind when working with some
526:57 - of this this is a test net right and
527:00 - working the way we're working right now
527:02 - is just on a test head so sometimes the
527:04 - test net doesn't work quite as well as a
527:06 - main net because it's just for testing
527:08 - and doesn't have the exact same support
527:09 - we were just working on the test net
527:11 - but if you want to go to ave for real
527:15 - you can go to
527:17 - app.avefork.com connect your wallet on
527:19 - the ethereum mainnet
527:21 - connect your wallet
527:23 - move to the ethereum maintenance and
527:25 - interact with it exactly the way we just
527:27 - saw now if we're on the maintenance here
527:28 - we can see some additional pieces when
527:30 - you deposit something like die
527:33 - yes you get 2.3
527:34 - back as interest paid to you for
527:36 - depositing the die
527:38 - you also get a little bit of what's
527:39 - called a governance token you also get a
527:42 - little bit of ave token i know it's
527:43 - really small here but
527:45 - this is an additional incentive that ave
527:47 - has given the users for working with
527:48 - their protocol since ave is a
527:50 - decentralized protocol in order for
527:52 - anything to be improved or anything to
527:54 - be updated on the protocol it actually
527:56 - has to go through a decentralized vote
527:59 - so these governance tokens actually
528:00 - dictate and decide how the protocol
528:03 - improves moving forward now that we
528:05 - understand how to work with all of that
528:06 - through the ui
528:07 - let's actually learn how to interact
528:09 - with ave and interact with defy all from
528:12 - our scripts learning how to do it this
528:14 - way will get us one step closer to being
528:16 - a quantitative defy engineer or d5
528:19 - researcher this is someone who
528:20 - programmatically does algorithmic trades
528:22 - algorithmic modeling and just does
528:24 - everything in a programmatic sense
528:26 - making them much more efficient and
528:28 - powerful interacting with d5 now all the
528:30 - code that we're going to be working with
528:31 - here is in this avi brownie pie
528:33 - application and you can always refer
528:35 - back to it in the link in the
528:36 - description or in the link in the github
528:38 - repository and see all the code written
528:40 - yourself so with that create a new
528:43 - folder and open up your vs code to that
528:44 - folder and let's get into it and ave has
528:46 - some fantastic documentation that we're
528:48 - going to use as well link here is also
528:50 - in the description let's go ahead and
528:52 - start
528:54 - with our our basic brownie setup just
528:57 - with brownie init and we got a new
528:59 - brownie project we got all of our
529:00 - folders in here and we are good to go
529:03 - now for working with browning we're
529:04 - actually not going to really be
529:06 - deploying any contracts because all the
529:08 - contracts that we're going to work with
529:09 - are already deployed on chain all of
529:11 - them are just going to be working right
529:13 - with ave here create a quick readme.md
529:16 - so we can know what we're doing here
529:18 - number one we're going to try to deposit
529:21 - some eath into ave
529:24 - then we're going to borrow
529:27 - some acid
529:29 - with the eth collateral
529:32 - and then if you wanted to i challenge
529:34 - you to actually sell
529:36 - that borrowed acid
529:39 - this is what's known as
529:41 - short selling but we're not going to do
529:43 - that here and then we're just going to
529:44 - repay everything back
529:49 - great and this will be the full
529:50 - functionality of working with ave in
529:52 - this deployed contract everything that
529:54 - we're going to learn here will teach you
529:55 - how to work with other
529:56 - contracts as well such as paraswap or
529:59 - unit swap
530:00 - or any other type of swapping contract
530:02 - that will allow us to buy and sell
530:04 - so let's just go ahead and create a
530:06 - script we'll call it ave
530:08 - borrow that pie let's go ahead and
530:10 - create a function called def main and
530:13 - we'll just do
530:14 - pass for now the first thing that we
530:15 - need to figure out how to do is deposit
530:17 - some f into ave
530:19 - when we actually deposited our f via the
530:21 - ui
530:23 - you can actually see
530:24 - when we call this deposit function if i
530:26 - hit this deposit button here
530:29 - oddly enough
530:31 - if we go to this contract address
530:33 - on the coven ether scan
530:35 - we'll see
530:37 - that this address is actually what's
530:39 - called a west gateway
530:42 - what ave is doing like i was saying
530:43 - before and let's go ahead and actually
530:45 - cancel this for now reject what ave is
530:47 - actually doing here is swapping our
530:50 - ethereum for west
530:52 - again west is an erc20 version
530:55 - of ethereum and this allows it to easily
530:58 - work with all the other erc20s on the
531:00 - obvi protocol like die usd coin
531:03 - you know ample fourth link et cetera
531:06 - so we actually have to do the that as
531:08 - well
531:09 - so the first thing we're going to need
531:10 - to do
531:12 - actually isn't deposit some of our eth
531:14 - the first thing we're going to need to
531:15 - do is going to swap our
531:17 - eth for
531:19 - west so let's even just put this in its
531:21 - own little script we'll call it get
531:24 - weth.pi so we're going to have a
531:26 - function
531:27 - def main
531:30 - i'm just going to do pass for now but
531:31 - we're actually going to want to use this
531:32 - get wet function in our ave borrowed a
531:34 - pi
531:35 - so we're going to actually have a main
531:37 - and we're going to have a def
531:39 - get weth
531:42 - and our main function is just going to
531:43 - call
531:44 - getwef so how do we actually
531:47 - convert our ethereum to wef or wrapped
531:50 - ether we'll even do a little dock string
531:52 - here
531:54 - mint's weth by depositing eth
531:56 - now to save gas we could actually
531:58 - interact with this weft gateway for ave
532:00 - but i'm going to teach you guys how to
532:02 - just get west in general so we can look
532:04 - up the west contract
532:06 - ether scan
532:08 - the west coven contract ether scan
532:11 - and we'll see here
532:13 - we have this wrapped ether page
532:15 - and we can go to the contract and we can
532:16 - see that this is indeed verified
532:19 - the way ath works is there's
532:22 - a withdrawal and deposit
532:24 - we deposit eth into this contract and it
532:27 - transfers us some wealth
532:31 - so this is the first contract that we
532:33 - actually want to interact with so we
532:35 - need our script to be able to call this
532:37 - deposit contract
532:39 - so
532:40 - per usual the two things that we need to
532:42 - do this are going to be an api
532:44 - and an address
532:46 - for this web contract i really like just
532:49 - doing everything directly from the
532:50 - interfaces i've already copy pasted the
532:52 - interface
532:55 - into this here so we're going to go to
532:57 - interface dot sol and we're just going
532:59 - to copy all this right here
533:02 - so in our interfaces
533:04 - we create a new file we're going to call
533:06 - it iweth
533:08 - dot soul
533:09 - we're going to paste it in
533:11 - you can see this has all the exact same
533:13 - functions as our deposit contract
533:16 - symbol name
533:18 - transfer pretty much everything you'd
533:20 - expect from erc20 plus this extra
533:22 - deposit piece
533:25 - we'll call this iweb it's a common
533:27 - naming standard to just have i in the
533:29 - name of what your contract is when
533:31 - you're talking about an interface so we
533:33 - have an interface now
533:35 - and we also have
533:37 - an address
533:38 - but again this is our address on the
533:40 - coven network since we know ahead of
533:42 - time that we're probably going to be
533:43 - using this on different networks like
533:45 - mainnet and coven and etc we're actually
533:47 - going to create a new file we're going
533:49 - to add our brownie config
533:51 - hopefully this is starting to look a
533:52 - little familiar to you now
533:54 - we're going to go ahead and add our
533:55 - networks in here
533:57 - in here we're going to go ahead and add
533:58 - coven and in here we're going to write
534:01 - west
534:02 - token
534:04 - and we're going to add
534:06 - this address of the web token
534:09 - paste it in here
534:10 - while we're in here
534:11 - we're going to add the rest of our
534:12 - pieces we're going to add wallets
534:16 - from key
534:20 - private key
534:21 - and that's all we really need for now
534:23 - speaking of which we probably are still
534:24 - going to want to test this locally
534:27 - now since we've done some work with
534:28 - testing we know that for testing
534:32 - we can do our
534:33 - integration test into
534:37 - integration tests
534:39 - on kovan because there's an integration
534:42 - test there
534:43 - what about our local tests
534:46 - well this is something good that we're
534:47 - thinking about right now we know that
534:49 - ave actually has
534:51 - all these same contracts on the main net
534:54 - as well
534:55 - and we also know that we're not going to
534:56 - be working with any oracles because that
534:58 - we don't actually have to deploy any
535:00 - mocks ourselves we can if we want to but
535:02 - we don't have to what we can do is for
535:04 - our unit tests
535:07 - we can actually just use
535:09 - the mainnet fork network and just fork
535:11 - everything that's on the mainnet into
535:13 - our own local network so instead of
535:15 - actually using mocs we'll basically just
535:17 - mock the entire mainnet and one more
535:19 - time just so that we absolutely have it
535:21 - here if you're not working with oracle's
535:23 - and you don't need to mock responses we
535:25 - can just go ahead and use a mainnet fork
535:27 - to run our unit tests if you are using
535:29 - oracle then it makes a lot more sense to
535:32 - do the development network where you can
535:34 - mock oracles and mock oracle responses
535:36 - with this in mind we know that we're
535:38 - going to be doing a lot of our tests on
535:39 - mainnet fork
535:41 - we can go ahead and add a mainnet fork
535:44 - network here and then we can just add
535:47 - the mainnet web token
535:49 - for mainnet fork so we'll look up web
535:51 - token
535:53 - etherscan
535:55 - web token etherscan
535:57 - and we'll grab this contract address
536:00 - remember absolutely positively if you
536:02 - want to double check that the contract
536:04 - address that you're working with is
536:05 - correct i highly recommend you do so
536:08 - because if you get it wrong you could
536:10 - accidentally add some money to a
536:12 - contract address that you don't want
536:15 - so we're going to have the mainnet fork
536:17 - address b the web token address
536:19 - and in our terminal
536:21 - we can do brownie
536:23 - networks list
536:26 - and see that indeed we have a mainnet
536:28 - fork here that's going to use the
536:29 - ganache cli to fork mainnet for us
536:32 - there's there's a link in the
536:33 - description to refer back to the section
536:34 - where we actually set this up so now
536:36 - that we have the interface we know that
536:38 - we can actually compile it down to the
536:40 - abi so back in our get wet here
536:42 - first thing we need to do to make any
536:44 - transaction obviously is get an account
536:48 - well
536:49 - this is where we can go back and make
536:50 - our helpful scripts
536:54 - so we can go ahead
536:56 - do def
536:58 - get account
537:00 - index equals none
537:02 - id equals none
537:03 - same as before
537:04 - and if you have your get account
537:06 - function from our last demo you can just
537:08 - go ahead and copy paste it in here all
537:09 - right great now we have our get account
537:11 - function so we can do account now equals
537:14 - get account
537:15 - oh but we have to import it in here so
537:18 - we'll do
537:19 - from
537:20 - scripts dot
537:22 - helpful scripts
537:24 - import
537:25 - get account
537:27 - and depending on your python version
537:29 - we'll add in it that pi just so that
537:32 - python recognizes that scripts is indeed
537:33 - a module all right cool so we have our
537:36 - account where we can make some
537:37 - transactions with
537:38 - now let's go ahead and get our wef
537:40 - contract
537:42 - to do this we can import interfaces from
537:44 - routing
537:45 - browning
537:47 - import interface
537:49 - same as we did before
537:51 - and we can do with
537:53 - equals interface
537:55 - dot i with
537:58 - and the address here is going to be from
538:00 - our config
538:01 - config
538:03 - networks
538:05 - dot show active
538:09 - and then
538:11 - web token
538:14 - we also have to import config from
538:16 - browning
538:19 - and network as well
538:23 - now you might be asking why aren't we
538:24 - using the get contract function here
538:27 - well you can absolutely 100 go ahead and
538:29 - use that get contract function but since
538:31 - we're going to be testing on mainnet
538:32 - fork here i know that we're always going
538:34 - to refer back to the config so i'm
538:36 - confident that i'm not going to be
538:37 - deploying any mocks
538:38 - it's better practice to go ahead and use
538:40 - that getcontract function but for this
538:42 - one we'll just make it a little simpler
538:44 - and use the config
538:46 - and now in a fig if we're on the coven
538:48 - network we're going to use this one
538:50 - if we're on mainnet or maintenance fork
538:52 - we're going to use this one
538:54 - for going to mainnet or for to real
538:56 - production you could also have a mainnet
538:58 - network and it'll just be an exact copy
539:00 - of the maintenance fork
539:02 - and remember we're going to want our dot
539:04 - env our env file
539:06 - our environment variables to get pulled
539:08 - from that dot env file so we can just
539:10 - set it like this now everything in our
539:12 - env file will get pulled in
539:14 - automatically
539:15 - great so we have an address and we have
539:17 - an abi which comes from the interface
539:20 - now we can just call we can just call
539:22 - this deposit function where we deposit
539:24 - ethereum and we get wef so now we'll
539:28 - just do transaction equals wealth
539:32 - dot deposit
539:36 - and we'll do from
539:38 - account
539:41 - value
539:43 - is going to be let's just say 0.1 so 0.1
539:47 - times 10
539:48 - raised to the 18.
539:50 - so we'll deposit 0.1
539:52 - and we should get 0.1 wef in return do a
539:56 - printf string
540:00 - received 0.1 weft
540:04 - this doesn't even need to be printf
540:06 - and then we'll just return tx
540:08 - now per usual
540:10 - if your environment variables aren't set
540:12 - such as private key we're going to want
540:14 - to do that so in our emb we do export
540:17 - private key
540:19 - equals 0x at the beginning right here
540:22 - we're going to export web 3
540:24 - infero
540:26 - project id we'll want our ad our web3
540:29 - inferior project id which we've got
540:31 - before
540:32 - if we want to use our etherscan token we
540:35 - absolutely can
540:36 - and since we're putting a whole bunch of
540:38 - stuff into dot and v we want to make
540:39 - sure in our git ignore we have
540:42 - dot and v so we don't actually push this
540:44 - up to github again if you're nervous
540:47 - about having all these ambs in here you
540:49 - can absolutely do the accounts.add or
540:51 - whatever other methodology you like to
540:53 - set your environment variables anyway
540:55 - let's go ahead and run this script now
540:57 - so we can do brownie run scripts
541:00 - get wet pie
541:02 - network
541:03 - coven
541:04 - generating the apis from our interface
541:07 - we have a little transaction hash that
541:09 - we can use
541:11 - pop into the coven etherscan
541:13 - and we can see
541:15 - the transaction going through in our
541:17 - wallets
541:18 - we'll get minus 0.18 and we'll get plus
541:22 - 0.1 weth
541:24 - so we can see it's actually been
541:25 - successful
541:27 - to add this and see this on our metamask
541:29 - we're going to grab the contract address
541:30 - here we're going to go back to metamask
541:33 - add token paste it in here
541:35 - add tokens and you can see we now have
541:37 - 0.1 with if you want to switch back your
541:40 - weft to ethereum you would just hit this
541:43 - withdraw function or
541:45 - we could programmatically add a
541:46 - withdrawal function in here this
541:48 - withdrawal function will run for
541:51 - ethereum withdrawal and take our
541:53 - ethereum out of the contract and burn
541:55 - the weapons replace it with weft so you
541:57 - need to swap your weft back to get your
541:59 - eth out awesome we have some weft and
542:02 - now we have an erc20 token we have an
542:05 - erc20 token that we can use to interact
542:07 - with the ave application now that we've
542:10 - got this get weth function let's go
542:12 - ahead and start borrowing so let's go
542:14 - ahead and start with our account
542:17 - it's going to equal to get account
542:19 - which now we're going to want to import
542:21 - right at the top
542:22 - like so
542:23 - then we're going to get our west address
542:26 - or we can even just do our erc20 address
542:28 - because the web token is in erc20 and
542:30 - maybe we want to deposit some other
542:32 - erc20
542:33 - we'll do config
542:37 - networks
542:39 - network dot show active
542:43 - left token
542:45 - and of course
542:46 - we're going to have to now add from
542:48 - brownie
542:51 - import
542:52 - network
542:53 - and now we want to call this get weth
542:55 - contract
542:57 - just in case we don't already have wef
542:59 - we would just add another from scripts
543:02 - dot get weft
543:04 - import
543:06 - get west but we don't actually need to
543:08 - call it right now because we already
543:10 - have some wrapped ethereum in our
543:12 - covenant address now if we want to test
543:14 - this though on our local mainnet fork we
543:16 - probably will want to call this getweft
543:19 - so i'm just going to add a little if
543:21 - if
543:23 - network.showactive
543:25 - is going to be our
543:27 - mainnet fork
543:33 - we should go ahead and call this get wet
543:35 - function and for brownie we're also
543:37 - going to want to import this config
543:38 - we'll also have to add
543:40 - mainnet fork
543:42 - to our local blockchain environments
543:47 - like so
543:49 - so that when we call git account in our
543:51 - scripts it actually knows that it's a
543:53 - local environment that we're working
543:55 - with and it will just return accounts
543:56 - zero instead of us having to actually
543:58 - load a private key in every single time
544:01 - and we want to actually wait for our
544:03 - transaction to complete here so we'll go
544:05 - ahead and add this weight and then do
544:06 - tx.weight
544:08 - and wait for this transaction to
544:09 - actually finish otherwise brownie will
544:11 - get a little bit mad
544:12 - so now that we have that we can run
544:15 - brownie
544:16 - run scripts
544:18 - ave bar to pie
544:20 - network
544:21 - maintenance fork
544:23 - so you can see that actually in this
544:24 - case testing everything on mainnet fork
544:27 - is going to give us a really really
544:29 - accurate view of what doing this on
544:30 - mainnet actually is going to give us we
544:32 - don't have to do any mocking we can
544:33 - literally just fork all of mainnet and
544:36 - go from there we are still going to test
544:38 - on kovan though in a little bit just so
544:39 - we can see all the transactions that go
544:42 - through how long it takes for stuff to
544:43 - happen
544:44 - so
544:45 - now that we've gotten some wealth here
544:48 - we actually need to go into our second
544:50 - bit we're going to deposit some f or in
544:53 - our case
544:54 - some
544:55 - wealth into ave so how do we actually do
544:58 - that
544:58 - well everything that we need is going to
545:00 - be in this ave
545:03 - documentation here
545:04 - where we deposit and borrow from in ave
545:07 - is in their contract this lending pool
545:09 - you can see here the lending pool
545:11 - contract is the main contract for the
545:12 - protocol it exposes the user-oriented
545:14 - actions that can be invoked in solidity
545:16 - and web-three libraries and these have
545:18 - all of the functions that we need it has
545:19 - deposit where we deposit our asset as a
545:21 - collateral withdraw where we take it
545:23 - back we have borrow we have repay
545:27 - and we can have we have swap borrow
545:29 - rates
545:30 - and a couple other interesting ones
545:31 - which we'll go into later but for now we
545:33 - just really need to focus on repaying
545:36 - borrowing
545:37 - withdrawing and depositing
545:40 - so as you probably guessed deposit is
545:41 - the function that we're going to work on
545:42 - right now
545:43 - and since this is the contract that
545:45 - we're going to work with as always the
545:47 - two things you need when working with a
545:48 - contract are going to be the abi and the
545:50 - address so we're going to get this
545:52 - lending pool contract we're going to say
545:54 - lending pool
545:56 - equals and we're actually going to even
545:58 - make a function called get
546:01 - lending pool
546:04 - so down below we're going to do def
546:06 - get lending pool
546:10 - lending pool not poll
546:12 - and we're going to get the lending pool
546:14 - address and the lending pool contract so
546:16 - we can interact with it down here now
546:17 - something about this lending pool is
546:19 - that the lending pool address can
546:21 - actually change a little bit depending
546:23 - on a lot of different pieces
546:25 - so there's actually this address
546:27 - provider which gives us the address of a
546:29 - specific or particular market if we go
546:32 - back to this ave ui there's actually
546:33 - different markets so there's different
546:35 - types of ways we can interact with ave
546:37 - we're just going to work with the basic
546:39 - ave v2 because it's easily the most used
546:42 - on mainnet as well the address provider
546:44 - registry will give us so this address
546:46 - provider will give us the address of the
546:49 - lending pool for our market if we want
546:51 - to go across different markets we'll
546:53 - have to go to the address provider
546:54 - registry to find it but the addresses in
546:56 - here don't change and the addresses in
546:58 - here don't change it's just the lending
546:59 - pool address itself might change so we
547:01 - just have to go to
547:02 - this address provider here and there's
547:04 - just one function that we need to work
547:06 - with it's this get lending pool which
547:09 - will give us the address of the actual
547:11 - lending pool so don't let this confuse
547:13 - you too much basically all we're trying
547:14 - to do is we're saying hey where is ave
547:16 - located right now and ave has a contract
547:19 - that will always tell us where the main
547:21 - ave contracts are and that's this
547:23 - addresses provider right here so this is
547:26 - another contract that we have to work
547:27 - with and again when we have a contract
547:29 - what do we need we need an api
547:32 - and we need an address so we can
547:35 - absolutely once again we could go ahead
547:37 - and
547:38 - you know copy paste like abi equals
547:40 - whatever the abi is but we're just going
547:42 - to use an interface because because life
547:44 - is great with an interface
547:46 - so a couple of great things about
547:47 - interfaces too if we know we're only
547:50 - going to work with one or two functions
547:52 - we can actually just make the interfaces
547:53 - ourself
547:54 - so an interface we could do a new file
547:57 - we could do i
547:59 - lending pool
548:00 - address provider that's sol
548:03 - and we can just add it in here ourselves
548:06 - so we'll first do sp dx
548:10 - license
548:12 - identifier
548:13 - and we'll do like mit or something
548:16 - we'll do pragma
548:17 - solidity
548:19 - 0.6.6 or whatever we want to do
548:22 - and then we'll do interface
548:25 - i
548:27 - landing pool
548:28 - addresses pro
548:30 - divider
548:31 - excuse me this should be a lending pool
548:34 - address says
548:37 - provider
548:39 - and we know that there's only one
548:40 - function
548:42 - called get
548:43 - lending pool
548:45 - and we're not exactly sure what
548:48 - getlendingpool is defined as but what we
548:50 - can do
548:52 - is we can go to
548:54 - ether scan eat the scan ave
548:57 - lending pool addresses
548:59 - you can see here this is actually the
549:00 - lending pool
549:01 - but what we can look at is the ave
549:03 - protocol we can go right to the github
549:05 - we can go to contracts
549:08 - we can see they have an interfaces
549:10 - section
549:12 - and they have
549:13 - this lending pool addresses provider
549:16 - get lending pool and kind of as we
549:18 - expected it's an external view and it
549:20 - returns an address so we can literally
549:21 - just copy paste this
549:23 - into here
549:24 - and we could run with this and this
549:25 - would work perfectly fine
549:27 - but this leads us to the next point we
549:29 - might as well just grab the whole thing
549:31 - this way we know for a fact we're not
549:32 - getting anything wrong but yes if we
549:35 - wanted to
549:36 - our interface could be this
549:38 - right because this is going to compile
549:40 - it could be this
549:41 - because this interface is going to
549:42 - compile down to an abi and the abi is
549:45 - going to say hey there's a function here
549:47 - and that's all the abi is really doing
549:49 - it's just telling us how we can interact
549:50 - with a contract but let's just go ahead
549:53 - and add everything so that if we want to
549:55 - interact with more things we can so now
549:58 - we have the api we also now need an
550:00 - address which we can definitely find
550:03 - from the ave documentation we can go to
550:05 - their deployed contract section we find
550:08 - lending pool
550:09 - addresses provider which is going to be
550:11 - right here
550:12 - we're going to copy that
550:15 - and where are we going to put this well
550:17 - as you know we're going to put this in
550:18 - our brownie config we're going to do
550:20 - lending
550:21 - pool
550:22 - addresses
550:24 - provider
550:26 - i'm going to paste that right there and
550:28 - since we know we're also going to do
550:29 - coven
550:31 - we can also grab from kovin here
550:33 - so lending pool addresses provider
550:37 - we're going to copy this here
550:40 - and do
550:42 - and we're going to add this addresses
550:44 - provider for coven as well
550:47 - boom now we have it for both coven and
550:50 - for maintenance fork
550:52 - awesome
550:53 - so we can keep going now now that we
550:54 - have an avi and we have an address for
550:56 - both coven and for our mainnet
550:58 - maintenance fork
551:00 - what we can do now
551:01 - is we first get the lending pool
551:06 - addresses provider
551:09 - it's going to be
551:10 - from our interface which again
551:13 - we're going to grab from brownie
551:18 - interface dot i
551:20 - lending pool
551:22 - addresses provider
551:25 - which the address of that is going to be
551:27 - config
551:29 - networks
551:31 - network.showactive
551:37 - lending
551:39 - pool
551:41 - addresses provider
551:43 - and then we're just going to say
551:46 - lending pool
551:47 - address
551:48 - it's going to be equal to
551:50 - blending pool
551:52 - i'm just going to copy and paste instead
551:54 - of typing the whole thing address
551:56 - divider provider dot get
551:59 - lending pool
552:02 - right because again
552:04 - this address provider has this get
552:07 - lending pool which returns this address
552:09 - which is the address of the lending pool
552:11 - then now that we have this address we
552:13 - can actually return the lending pool
552:15 - contract
552:16 - by once again getting the api
552:20 - and the address
552:22 - of the actual landing pool so we have
552:25 - the address
552:26 - check
552:27 - we just now need the api which once
552:30 - again we can work with our wonderful
552:32 - interfaces here do new file
552:34 - i
552:35 - lending pool
552:37 - and there's only going to be a couple of
552:39 - functions we're going to work with here
552:40 - but ave actually gives us the interface
552:42 - right here
552:43 - and
552:44 - ave actually even gives us the interface
552:46 - of the lending pool address provider for
552:48 - us so we can go ahead and copy this pop
552:50 - it over into here now we do need to
552:52 - actually change one thing in here as
552:54 - well this interface imports locally with
552:57 - this dot slash so we actually just need
552:59 - to change these imports to actually
553:01 - import directly from github instead of
553:03 - importing locally
553:05 - luckily this is something we already
553:07 - know how to do so let's go to our
553:08 - brownie config
553:10 - and up at the top we're going to add
553:12 - this dependencies bit in pen
553:14 - then c's
553:17 - so we're just going to work with ave's
553:20 - protocol right from github
553:22 - so
553:24 - we're going to work with ave slash pro
553:26 - tow call
553:29 - v2
553:31 - and let's see what their latest version
553:33 - is
553:34 - looks like they got a couple different
553:35 - versions here
553:36 - 1.0.1
553:38 - so let's go ahead and work with this one
553:40 - at
553:41 - 1.0.1
553:43 - and then with compiler
553:46 - sulk
553:48 - remappings
553:50 - per usual
553:52 - we're going to say at
553:53 - ave
553:55 - is going to be equal to this dependency
553:58 - this way brownie will download this
554:00 - right from github and now we can just
554:01 - use this at ave
554:03 - instead
554:04 - so back in our eye lending pool.sol we
554:07 - can just change this
554:09 - to poll right from github and if we look
554:12 - in github
554:15 - we go to their contracts section
554:17 - we go to their interfaces section
554:20 - by lending pool
554:22 - we know that we can pull this from
554:25 - at ave
554:26 - slash contracts
554:28 - slash interfaces
554:32 - because we see this eye lending pool
554:33 - addresses provider
554:35 - right in here
554:36 - and then this data types bit
554:38 - you can actually look in contracts
554:40 - and this i know because i've i've been
554:42 - through already it's in protocol
554:45 - libraries
554:48 - types
554:50 - and here it is datatype.sol so we can
554:52 - just take this exact path again
554:54 - and do at ave
554:56 - contracts
554:58 - slash protocol
555:00 - slash libraries slash types
555:04 - data type dot sol okay great so now that
555:06 - we've actually imported this interface
555:08 - for us to use we can go ahead and
555:10 - compile just to make sure that
555:11 - everything is working correctly brownie
555:14 - compile
555:18 - and perfect if these interfaces had an
555:20 - issue they actually wouldn't compile
555:22 - through brownie here so we know that
555:23 - they're compiling correctly but great so
555:25 - now that we have an interface we know
555:27 - that these interfaces compile down to
555:29 - the abi
555:30 - and we already have the address here so
555:33 - to actually interact with the lending
555:35 - pool now we can just do
555:37 - lending pool
555:39 - equals
555:40 - interface
555:42 - dot i
555:44 - lending pool
555:46 - and we'll add this lending pool address
555:48 - blending pool and then we can return
555:53 - lending pool so now we have a function
555:56 - that goes through the lending pool
555:57 - addresses provider from the ave
555:59 - documentation and returns this lending
556:01 - pool contract that we can now interact
556:03 - with and we can even test this out by
556:05 - just printing this landing pal address
556:07 - in our script
556:08 - so we'll do brownie
556:10 - run
556:11 - scripts
556:13 - ave borrow network
556:16 - mainnet fork
556:20 - and perfect we we can see the address
556:22 - here is printed out and there are no
556:23 - errors so we know we're doing it right
556:25 - so now that we have the actual address
556:27 - what we're going to do now is we're
556:28 - going to take this wrapped aetherium
556:30 - that we've got this erc20 version of
556:32 - ethereum and we're going to deposit it
556:35 - into this contract just like what we did
556:37 - in the user interface in order to
556:40 - actually first deposit it we need to
556:41 - approve this erc20 token erc20 tokens
556:45 - have an approved function that makes
556:46 - sure that whenever we send a token to
556:49 - somebody or whenever a token calls a
556:51 - function that uses our tokens we
556:54 - actually have given them permission to
556:55 - do so so that's the first thing that
556:57 - we're going to actually have to do
556:59 - is we're going to have to approve
557:00 - [Music]
557:01 - sending our erc20 tokens
557:04 - and this resembles so since i know that
557:06 - we're going to have to approve a lot i'm
557:08 - actually just going to go ahead and make
557:10 - an approve
557:12 - erc20 token function similar as to what
557:16 - we did with the get lending pool
557:18 - so we're going to need to approve this
557:20 - erc 20 so we're going to need to approve
557:22 - this erc20 so let's go ahead and make a
557:24 - function we'll call it def
557:26 - approve
557:27 - erc20 so how do we actually call this a
557:30 - prove function on a token contract
557:32 - well
557:33 - as always we're going to need the abi
557:36 - and the address of the token contract
557:39 - same as always i told you i was going to
557:40 - be saying this a lot now we could create
557:43 - our interface ourself looking at all the
557:45 - functionalities of the erc20 tokens so
557:48 - we could go to eip20 look at the token
557:51 - standard find all the different
557:54 - functions and put them into our
557:55 - interface
557:56 - or we can go ahead and just cheat and
557:58 - just grab it from my github repository
558:01 - here
558:02 - so i already have an ierc20.soul right
558:04 - here
558:05 - and we're just going to copy everything
558:07 - in here and
558:08 - add it in a new file called i yourc20
558:11 - that's sold
558:13 - and paste it in here so you can see
558:14 - there are a number of different
558:16 - functions in here
558:17 - we can check the allowance we can check
558:19 - the balance of different addresses
558:22 - how many decimals a token has the name
558:24 - the symbol we can do some transfers and
558:26 - transfer from and then the function that
558:29 - we're going to be using is this approve
558:30 - function so right here we can already
558:33 - see
558:33 - the parameters this approved function
558:35 - takes
558:36 - we're going to need to have a spender of
558:39 - who to approve can spend our tokens and
558:42 - then how much they can actually spend so
558:44 - if we come back over to approve erc20
558:47 - we know that for input parameters we're
558:49 - probably going to need an amount
558:51 - a spender
558:53 - address
558:54 - the erc20 token address
558:58 - so which token we're actually allowing
558:59 - to spend
559:01 - and then an account right or this is
559:03 - going to be that from
559:07 - account bit so we'll just have this be
559:09 - passed as part of the function
559:11 - parameters so let's go ahead and code
559:12 - this let's first just do a quick print
559:14 - line
559:15 - so that people know what this
559:17 - transaction is doing we'll say approving
559:21 - prc20
559:22 - token
559:24 - and then we'll get the erc20 token by
559:26 - saying e or c equals interface
559:29 - same as always dot i e or c 20
559:33 - and then we'll give it
559:34 - whatever erc20 address that we pass to
559:36 - this function
559:38 - and now we can actually interact with
559:39 - this contract and we can call that
559:41 - approve function
559:43 - so we'll say transaction
559:45 - tx or again tx usually stands for
559:47 - transaction
559:48 - equals erc20
559:50 - dot approve and we're going to approve
559:53 - this spender
559:54 - for
559:56 - an amount
559:57 - and then we'll say from
560:00 - account we'll do tx.wait we'll wait one
560:03 - block confirmation for it to finish
560:05 - and then once it's done
560:07 - we'll do print
560:09 - approved and we'll return the
560:12 - transaction
560:13 - awesome so now we have an approved erc20
560:15 - function that we can use to approve any
560:18 - erc20 token so back up in our main
560:20 - function we can run approve vrc20 for
560:23 - some amount which right now we don't
560:25 - have defined
560:27 - the spender is going to be this lending
560:29 - pool but the address of the lending pool
560:32 - because remember lending pool is the
560:33 - entire contract we just want the address
560:36 - the erc20 address of course is going to
560:38 - be the erc20 address and the account of
560:40 - course is going to be our account
560:43 - the only thing we don't have to find
560:44 - right now is some amount which we can
560:47 - make it really whatever we want to be to
560:48 - keep things standard let's just go ahead
560:50 - and do 0.1 so i'm going to make this a
560:53 - global variable i'm going to say amount
560:56 - equals
560:58 - one
560:59 - one two three four five six seven eight
561:00 - nine ten one two three four five six
561:02 - seven and we can go ahead and do
561:05 - amount
561:06 - we're gonna of course doing all these
561:07 - zeros is from incredibly disgusting so
561:10 - we're just gonna refactor to do from web
561:11 - 33 import web and then instead of always
561:14 - and we'll just do web three three
561:16 - two two
561:17 - 0.1 0.1 which is the amount that we
561:20 - actually want and we'll say either
561:22 - now we can run browning
561:24 - run scripts ave borrowed a pie
561:27 - network main net fork
561:30 - and we can go ahead and see that our
561:32 - approval function is working as intended
561:34 - network that will always be doing this
561:35 - fine
561:36 - any type of
561:38 - we can do so let's go foreign and change
561:40 - our default network to mainnet for
561:42 - mainnet so we don't have any network in
561:44 - our browning let's go back to our ave
561:45 - borrowing section now so we have
561:47 - everything approved
561:48 - now we just need to go ahead and deposit
561:51 - it into ave
561:53 - since we know we're probably going to
561:54 - use this a lot too let's go ahead and
561:56 - create a
561:57 - deposit function since we have
561:58 - everything approved we can now go ahead
562:01 - and use the lending pool deposit method
562:04 - and we can check the documentation here
562:06 - or look on github or etherscan to see
562:08 - what the parameters that it takes are so
562:10 - i'm even just going to go ahead
562:12 - and copy all this
562:14 - bring it over here
562:16 - so what we can do now
562:17 - is we do lending pool
562:21 - dot deposit
562:24 - and then all these parameters let's go
562:26 - ahead and walk through them one by one
562:28 - so first thing is going to be the
562:29 - address of the asset which we know
562:32 - is going to be your erc20 address
562:34 - boom
562:35 - the amount
562:37 - of the token which we can go ahead with
562:39 - our amount variable
562:41 - address on behalf of is just going to be
562:44 - our account.address we're depositing
562:47 - this collateral for ourselves
562:50 - and then referral code so referral code
562:52 - is so the referral code is actually
562:54 - deprecated and workloads don't actually
562:57 - work anymore so we're just always going
562:58 - to pass 0 here and just to make sure we
563:00 - know that this is what we're doing we're
563:02 - going to go ahead and print
563:04 - depositing
563:06 - one two three
563:07 - and then after we're done we're gonna do
563:09 - print
563:11 - the ted
563:12 - and whoops looks like we forgot to add
563:14 - that final dictionary here
563:16 - of from
563:18 - accounts
563:21 - ah one more thing here let's go ahead
563:23 - and do tx for transaction
563:25 - equals lendingpool.deposit and we're
563:27 - going to go ahead and once again we're
563:29 - going to wait for one block confirmation
563:31 - wait
563:32 - one
563:33 - transactions still being processed so
563:35 - now if we run brownie run scripts ave
563:37 - borrowed up high
563:41 - we can see that this actually went
563:42 - through fine
563:43 - all right now that we have some
563:45 - collateral deposited we can go ahead and
563:48 - actually take out a borrow we can go
563:50 - ahead and borrow some other asset the
563:52 - question is going to be how much how
563:54 - much can we actually borrow how much
563:57 - should we borrow
563:58 - what would result in a positive health
564:00 - factor well maybe we should actually
564:03 - pull off chain some of our stats how
564:05 - much do we actually have deposited
564:07 - how much collateral we have how much
564:09 - debt we have and so on and so forth that
564:12 - way in the future when we don't start
564:13 - clean we can take some inventory of
564:15 - where we stand with our collateral in
564:17 - our debts at the ave documentation
564:20 - we can go ahead and see this this
564:22 - function called get user account data
564:25 - this is going to return the user account
564:27 - data across all reserves so it's going
564:29 - to get the total collateral that we've
564:31 - deposited in terms of ethereum it's
564:34 - going to get our total debt in terms of
564:36 - ethereum how much we can borrow the
564:37 - borrowing power that we have the
564:39 - liquidation threshold or how close to
564:41 - that liquidation threshold will be the
564:44 - loan to value ratio and again this
564:46 - health factor this health factor is
564:48 - obviously incredibly important because
564:50 - if it drops below one or reaches one
564:52 - users can call this liquidation call now
564:55 - this function returns all these
564:57 - variables but for now we really only
564:59 - care about how much collateral we have
565:01 - how much debt we have and how much we're
565:03 - available to borrow so let's go ahead
565:05 - and write a function that will actually
565:06 - sort that out for us we'll call it get
565:10 - borrowable
565:11 - data
565:14 - borrow a bull
565:16 - data so let's go ahead and create this
565:18 - def
565:20 - get borrowable
565:22 - data
565:23 - and we're going to pass in the lending
565:25 - pool as a first parameter and then the
565:27 - account as the second parameter because
565:29 - we're looking to call this function on
565:31 - the lending pool from an account so
565:33 - let's go ahead and just call that
565:34 - function so we'll do lending pool
565:37 - dot get user account
565:39 - data
565:40 - and we'll pass in account that address
565:43 - because we look at the api again
565:45 - all that it needs is a user's address to
565:47 - get started here
565:49 - and it returns one two three four five
565:52 - six
565:54 - variables so we can go ahead
565:57 - and get all of them
565:59 - with this tuple syntax here so we'll say
566:01 - total
566:05 - collateral eath
566:08 - total debt eath
566:11 - available
566:12 - borrow eth
566:15 - current
566:17 - liquidation
566:20 - loan to value
566:22 - and then the health factor
566:26 - so it's with this syntax here that we
566:27 - can actually get all of these variables
566:29 - with this one call and again this get
566:31 - user account data is a view function so
566:33 - we don't need to spend any gas all of
566:35 - these variables are going to return in
566:37 - terms of way so let's just go ahead and
566:39 - convert these from whey to something
566:42 - that makes a little bit more sense to us
566:44 - so we want to get this available borrow
566:46 - each so we can figure out how much we
566:47 - can borrow let's get that
566:49 - in terms
566:51 - that we can actually understand so we'll
566:53 - do fromway
566:54 - available borrow eth in terms of ether
566:58 - we'll do total
567:00 - collateral eth equals web3
567:02 - that from way
567:05 - and we'll do total collateral eth
567:07 - ether
567:09 - ether
567:10 - and then we'll do total
567:12 - debt eth
567:14 - equals same thing web3 dot from way
567:18 - total debt eth
567:20 - terms of ether
567:22 - and let's even do a little printf
567:23 - statement for each one of these so we'll
567:24 - do print
567:26 - f
567:28 - this f allows us to put variables inside
567:30 - the print function and we'll say
567:33 - you have
567:36 - total collateral eath
567:39 - worth
567:41 - of eath deposit 10.
567:44 - we'll even copy paste that a couple
567:46 - times and we'll change this one to
567:49 - total debt eath
567:51 - and we'll change this one to
567:53 - available borrow eth
567:55 - so we'll say you have
567:57 - worth of ease deposited
567:59 - you have total death eat worth of
568:02 - f borrowed
568:04 - and you can borrow
568:07 - available borreeth worth of eath
568:11 - and then we're going to go ahead and
568:12 - return
568:14 - again we're going to use this tuple
568:15 - syntax so we can return two variables
568:18 - and we're going to say a float
568:21 - of this available borrow eth
568:24 - and a float
568:26 - of the total debt eth
568:28 - the reason that we have to add this
568:29 - float variable here is that without it
568:31 - some of the math that we're going to try
568:32 - to do later won't pan out as well so now
568:34 - we have this function get borrowable
568:36 - data we're going to pass the lending
568:38 - pool
568:39 - and we're going to pass our account here
568:41 - since we're returning
568:43 - the borrowable eth and the total debt we
568:46 - can say borrowable
568:50 - eath and then total
568:52 - debt
568:53 - equals that function right there so
568:56 - let's go ahead and try this out
568:59 - with
569:00 - running run scripts ave borrowed a phi
569:02 - pi
569:03 - again
569:05 - because in our config
569:07 - we have a default network of mainnet
569:08 - fork
569:10 - things seem to be approving things seem
569:12 - to be depositing and awesome
569:14 - we have we have our output here we
569:16 - deposited 0.1 worth of f we have 0 f
569:21 - borrowed and we can borrow 0.8 worth of
569:24 - f yes this is correct even though
569:27 - we have 0.1 f deposited
569:30 - we can only borrow
569:32 - 0.08 this is because the liquidation
569:35 - thresholds of different assets are
569:37 - different in this risk parameters
569:39 - documentation here we can see
569:41 - the different liquidation thresholds on
569:42 - the different assets we can see that
569:44 - ethereum has an 80
569:46 - loan to value so with ethereum we can
569:48 - only borrow up to 80 percent of the
569:51 - deposit assets that we have
569:53 - and
569:54 - if we have more than 82.5 percent
569:57 - borrowed will actually get liquidated it
569:59 - also tells about the liquidation bonus
570:01 - reserve factor and some other helpful
570:02 - pieces in here as well but now that we
570:04 - have this borrowable ether mount we can
570:06 - go ahead and actually borrow some dye so
570:09 - let's do a quick print saying
570:11 - let's borrow now in order for us to
570:13 - borrow some dye we also need to get the
570:15 - conversion rate
570:16 - we need to get die in terms of f so
570:20 - we're going to have to use some price
570:22 - feed here luckily we already know how to
570:24 - work with chain link and how to get
570:25 - price feeds ave uses the chain-link
570:27 - price feeds as well so we're using the
570:29 - exact same conversion rate tools that
570:31 - avi is going to use so let's go ahead
570:33 - and create a function to get us this
570:35 - conversion rate we'll say the die to f
570:37 - price
570:38 - is equal to get
570:41 - asset price and then here we'll pass the
570:44 - die
570:44 - f
570:45 - price feed
570:47 - this will be the address of the die
570:48 - ethereum conversion rate let's go ahead
570:50 - and create this function call it def
570:52 - get
570:54 - asset price
570:56 - and the parameter needs is going to be
570:58 - price feed address so the first thing
571:00 - that we're going to need is we're going
571:01 - to need to get this die f price feed
571:03 - where can we get this
571:05 - well as we know per usual we'll head
571:08 - over to the chain link documentation
571:10 - we'll go to ethereum price feeds we'll
571:12 - find done
571:15 - and we'll paste it into our config for
571:18 - mainnet so we can go ahead and add the
571:20 - die
571:21 - f
571:22 - price feed
571:23 - in here and paste it into our config
571:25 - again if we want to test the coven we
571:28 - can obviously just scroll down
571:30 - look for coven
571:32 - find the dieth right here
571:34 - grab that address
571:35 - pop it in for coven
571:40 - and then we can get this the same way
571:42 - that we got the address of the web token
571:44 - so i'm just going to go ahead and copy
571:45 - this
571:47 - paste it here but instead of having weft
571:49 - token in here
571:51 - we'll do die
571:52 - f
571:53 - price feed
571:55 - and now we have a way to change the
571:57 - price feed address depending on what
571:59 - network we're on so in our get asset
572:01 - price function we're going to do the
572:02 - same exact thing that we always do we're
572:04 - going to grab an api
572:06 - and an address
572:08 - to work with the contract so again we
572:10 - can get the abi by just working directly
572:13 - with the interface
572:14 - so we'll say die
572:15 - f
572:17 - price feed
572:19 - equals interface
572:22 - dot
572:24 - aggregator
572:25 - v3 interface because this is the name of
572:28 - the price feed interface
572:30 - which again if we look in our interfaces
572:32 - it looks like we don't actually have so
572:34 - what we can do
572:35 - is we can go to the chain like github or
572:38 - as you guys are already starting to
572:39 - figure out all my example code has all
572:42 - these interfaces as well but we can go
572:43 - right to the source too
572:45 - what we can do we go here we go to
572:46 - contracts
572:48 - we're going to add source
572:50 - we'll do
572:51 - 0.6 we'll do interfaces and right here
572:54 - is the aggregator v3 interface so if we
572:57 - want we can just copy this whole thing
572:59 - move back over to our interfaces
573:01 - new file and this file is actually named
573:04 - aggregator v3 interface you could call
573:06 - it eye aggregator v3 or aggregator v3
573:08 - interface you could keep it with i
573:10 - aggregate or v3 outsole to keep with the
573:14 - convention that we have
573:15 - or you can just call it aggregator
573:19 - v3 interface dot sol
573:22 - to keep in line with what the chain link
573:24 - code is actually called them i'm going
573:25 - to call mine aggravated v3 interface
573:27 - you'll notice a couple different
573:28 - projects have a couple different
573:29 - conventions but now that we have it
573:31 - saved we can do interface the aggregator
573:34 - v3 interface and we'll pass it this
573:36 - price feed address now this diet price
573:39 - feed is going to be a contract that we
573:41 - can call a function on again we can
573:43 - always refer back to the get the latest
573:45 - price documentation to see how to
573:47 - actually work with it there's even some
573:49 - python code here for working with it in
573:51 - web 3. we're going to go ahead and call
573:53 - this latest round data function which we
573:56 - can also find in our aggregator v3
573:58 - interface this latest round data
574:00 - which returns a round id
574:02 - answer started at ended at and answered
574:04 - it around
574:05 - all we're really concerned with is this
574:07 - answer bit here so the way we can do
574:08 - this is we can say latest price equals
574:11 - die dieth price feed the latest
574:15 - round data and instead of grabbing
574:18 - all five of these one two three four
574:20 - five
574:21 - what we can do is we can actually just
574:23 - grab
574:24 - the price which is at the one index so
574:27 - round id is at zero price is at one
574:30 - started it's two et cetera
574:32 - so we can just say
574:34 - at the first index and then we can
574:36 - return
574:38 - a float
574:40 - of
574:41 - this latest price
574:43 - we can even print
574:45 - another printf statement
574:46 - the die
574:48 - f
574:49 - price is
574:51 - latest price
574:53 - so let's go ahead and run this
574:57 - and great we have the die f price video
575:00 - which of course we know that looking at
575:02 - this right now this isn't in the right
575:05 - units we know the diet price feed has 18
575:08 - decimal places so what we can do then is
575:10 - we know that this number would be one
575:12 - two three four five six seven eight nine
575:14 - ten one two three four five
575:16 - six seven eight
575:19 - this number is really zero point zero
575:21 - zero zero four blah blah blah blah blah
575:24 - so maybe we don't want to return it like
575:26 - so maybe we want to say the diet price
575:29 - feed is and we add
575:31 - a little bit of web3.pi to make this
575:33 - make a little bit more sense so we'll
575:34 - say web3
575:36 - dot from
575:37 - way
575:38 - and we'll add this latest price bit in
575:41 - here comma
575:42 - ether
575:44 - maybe we'll even do a converted
575:47 - latest price which is going to be equal
575:49 - to
575:50 - web3 dot from way
575:53 - latest price
575:55 - ether
575:56 - and we'll print that out instead
575:58 - so let's go ahead and run this again
576:02 - all right that looks a little bit more
576:04 - accurate perfect
576:06 - okay great now we have the die eat price
576:08 - we're getting really close to being able
576:10 - to borrow this actual asset and let's
576:11 - even return this converted lated price
576:14 - here just so that we're always working
576:15 - in units that we understand
576:17 - okay now we're getting somewhere now we
576:19 - can calculate the amount of dye that we
576:22 - want to borrow we can find this by doing
576:24 - a little bit of math we're going to do
576:26 - the reciprocal of the die eat price
576:29 - times
576:31 - our borrowable eath and just to be safe
576:34 - we're going to times it by 0.95
576:36 - so this line we're converting our
576:38 - borrowable each
576:40 - to
576:42 - borrowable
576:43 - die and then we're timing it by
576:45 - 95 percent we're timing it by 95 because
576:48 - we don't want to get liquidated so we're
576:50 - going to be a little bit more cautious
576:51 - remember how we slid that sliding scale
576:53 - around to make it safer and less safe
576:56 - well the lower percentage that we
576:57 - actually borrow maybe we even borrow 50
577:00 - of our collateral the safer that we're
577:02 - going to be so keep that in mind when
577:04 - you're deciding how much to actually
577:05 - borrow if you want to run this in a
577:07 - production environment so now that we
577:09 - have this amount data borrow let's even
577:11 - print it out let's say print
577:13 - f
577:14 - we
577:14 - are going to borrow
577:18 - amount down to borrow
577:20 - die and then
577:22 - we're finally going to do it
577:24 - now we will borrow
577:28 - looking at the ave documentation we can
577:30 - look at their borrow function and we can
577:32 - see the api here let's go ahead let's go
577:34 - ahead and call this function so we'll do
577:36 - borrow transaction it's going to be
577:38 - equal to
577:39 - lendingpool.borrow
577:41 - let's look at those parameters so the
577:43 - asset that we want to borrow die address
577:45 - so first we should get a die address
577:48 - which we can once again we'll want to
577:49 - put in our config
577:51 - so we'll go over to our config
577:53 - and we'll add
577:54 - a die address or a die token here which
577:57 - we can find on etherscan
577:59 - token it looks like this is the token
578:01 - right here so we'll copy this address
578:03 - for mainnet remember if you want to run
578:06 - this on coven you're also going to need
578:07 - to have a die token for coven now on
578:10 - test nets avi actually changes up where
578:12 - the tokens for its test nets are
578:14 - actually going to be so if we go to
578:15 - their documentation we go to deployed
578:17 - contracts
578:19 - and we go to coven here you'll always
578:21 - see this little flag thing pop up say
578:23 - always ensure using the latest lending
578:25 - pool address since coven is updated from
578:27 - time to time it's going to be the same
578:29 - thing if we scroll down for tokens they
578:32 - have an up-to-date list of coven
578:34 - addresses in a json file here so it
578:37 - looks kind of gross but if we look up
578:39 - die
578:40 - we can see symbol die and the address of
578:43 - die on the coven test net so sometimes
578:45 - this does change so if you run into an
578:47 - issue maybe it's because the die token
578:49 - that you were working with on their
578:50 - coventestnet has actually changed then
578:53 - we're going to do config networks
578:57 - network dot show active
579:02 - diet token great now let's move on to
579:04 - the next parameter
579:05 - the amount which we just figured out
579:07 - here
579:08 - amount diet to borrow
579:10 - which we do need to change back to whey
579:12 - so we're going to do web3.2a
579:15 - mount dye to borrow
579:17 - ether
579:18 - because right now amount down to borrow
579:20 - is in our human readable version which
579:21 - we need it in way
579:24 - then our interest rate mode which is
579:26 - going to be stable or variable stable is
579:29 - where the interest rate will always be
579:30 - exactly the same
579:32 - variable will change depending on a lot
579:34 - of different things going on with ave
579:36 - for safety we're just going to go ahead
579:38 - and add one here
579:39 - then we're going to do a referral code
579:41 - and on behalf of so referral codes no
579:44 - longer exist so we'll leave zero it's
579:46 - going to be on behalf of our self
579:49 - so we'll do a countdown address
579:51 - and then of course we have to do a from
579:55 - account
579:56 - then we'll wait for this transaction to
579:58 - complete
580:00 - and if we've done this right we should
580:02 - have borrowed some dye programmatically
580:05 - from the ave protocol so let's even
580:06 - print
580:09 - borrowed some die
580:12 - and we can once again call our get
580:15 - borrowable data function
580:17 - since this get borrowable data function
580:19 - will print out our new account
580:22 - information for how much we borrowed so
580:24 - let's go ahead and run this on mainnet
580:25 - fork again
580:29 - awesome so if we've done this correctly
580:32 - we now see that we've borrowed some die
580:35 - so we can see here we now have 0.1 worth
580:37 - of f deposited
580:41 - 0.059999 worth of f borrowed
580:44 - and we can borrow a little bit more
580:46 - worth of f
580:47 - this
580:48 - 0.75999 is actually
580:51 - the die that we've borrowed so we've
580:53 - deposited some eath and we've borrowed
580:55 - some dye and obvious telling us how much
580:57 - that dye converted to eat is there so we
581:00 - actually borrowed 160 die
581:02 - which is great all right we've now
581:05 - learned how to borrow everything which
581:06 - is fantastic let's go ahead and actually
581:09 - repay that back so we're going to call
581:11 - their repay function and let's just put
581:14 - this into its own function called repay
581:17 - all and we'll give it the amount that we
581:20 - want to repay
581:21 - the lending pool address and our account
581:23 - so let's call
581:25 - let's define
581:26 - repay all or we're just going to repay
581:28 - everything that we have
581:30 - again we're going to add an amount
581:33 - lending pool
581:36 - and account
581:37 - for parameters
581:38 - so if we're going to pay back this
581:40 - network first thing that we need to do
581:41 - is actually call the approve function
581:43 - i'm going to prove that we're going to
581:45 - pay back so the first thing we're going
581:47 - to have to do per usual is we're going
581:48 - to actually have to approve that erc20
581:51 - so
581:52 - let's say how much
581:53 - we're going to approve
581:54 - web 3.2 way
581:57 - amount
581:58 - ether to the lending pool
582:02 - and we'll grab it from the config
582:07 - networks
582:11 - network dot show active
582:16 - and this is going to be the
582:18 - die token again
582:21 - and of course
582:22 - with our account i believe our proof
582:25 - erc20 already calls weight so we don't
582:27 - have to call it here so once we approve
582:29 - we're going to be using this die that we
582:31 - borrowed to pay most of what we have
582:33 - borrowed back now we're going to call
582:36 - the repay function so we'll say repay tx
582:40 - equals
582:41 - lendingpool.repay
582:44 - first we need the asset
582:46 - that we're going to use to repay which
582:48 - we're going to use config
582:55 - networks
582:58 - network dot show active
583:04 - diet token the amount which is going to
583:07 - be passed in here amount
583:10 - the rate mode
583:11 - which
583:12 - we've hard coded to one
583:14 - and the address on behalf of which is
583:16 - going to be account
583:17 - dot address
583:19 - and then of course we always have to do
583:20 - from account
583:23 - then we're going to do repay tx
583:26 - dot wait
583:27 - we're going to wait one block
583:28 - confirmation
583:29 - and then we'll print
583:31 - repaid
583:33 - and if we've done all this right we'll
583:35 - do one more print line saying
583:37 - you just deposited
583:39 - borrowed
583:42 - and repaid
583:43 - with ave
583:46 - brownie
583:47 - and chain link
583:50 - all right moment of truth
583:52 - let's see if this works
584:01 - we did it repaid you just deposited
584:04 - borrowed and repaid with ave brownie and
584:06 - chain link awesome work now if you want
584:08 - to what we can also do is we can see if
584:11 - this will work
584:12 - with our wallet address here so what i
584:15 - can do is i can copy my address
584:18 - go to coven ether scan
584:20 - and paste it in here
584:22 - and right now we can see
584:24 - that i have a whole bunch of link and
584:26 - some ether
584:27 - what i can do
584:29 - is actually test everything that we just
584:31 - ran through on the cove intestine and
584:33 - see
584:34 - everything happen
584:36 - right on this ether scan address so if
584:39 - we've been following along correctly and
584:41 - we've added contract addresses
584:43 - appropriately
584:44 - we should be able to run the exact same
584:46 - script on the coven test net i'm going
584:49 - to do one additional thing here though
584:51 - i'm going to have us not repay so we can
584:54 - see
584:54 - us with a little bit of debt
584:57 - so let's go ahead and run brownie
584:59 - run scripts
585:01 - ave bar to pie and we'll change to
585:02 - network coven
585:04 - and now it's going to take a lot longer
585:06 - as we've seen before because we're
585:08 - actually
585:09 - making these transactions on a real
585:11 - network whoops it looks like i got one
585:13 - of the die f price feeds wrong for coven
585:17 - so i can once again just go over to the
585:18 - documentation
585:20 - die
585:22 - s
585:23 - it looks like this is the real address
585:26 - for coven
585:27 - so we'll copy that
585:29 - paste it in here whoops we should also
585:32 - probably have some wet token so first
585:34 - let's go ahead and run
585:36 - our get wet script for coven
585:38 - and we're going to change this account
585:40 - to get account brownie
585:43 - run scripts
585:47 - from our helpful scripts that way we can
585:50 - actually
585:51 - that way we can actually use our wallets
585:53 - correctly all right great so now we have
585:55 - 0.1 weft
585:57 - and actually
585:59 - again what we can do
586:01 - is grab
586:02 - this address here
586:04 - add token paste it in
586:07 - add tokens for the web token and now we
586:09 - can see we have 0.1 with which is
586:12 - perfect
586:13 - so now that we have some width we can
586:15 - run the borrow script ave
586:18 - brownie run
586:20 - scripts ave borrow
586:23 - network coven
586:30 - and wow we can see that everything went
586:32 - through correctly and successfully
586:35 - so since i actually commented out this
586:37 - repay function we still should have die
586:40 - in our address here in our wallet here
586:43 - and again we can see that
586:44 - by going to our brownie config
586:47 - grabbing this dye token address
586:49 - add token custom tokens next
586:52 - ad tokens and we can see we do indeed
586:54 - have 160 die in our wallet
586:57 - we have no weft since it'll be in ave
586:59 - now and we have borrowed die instead you
587:02 - can also see that we now have this a
587:04 - weft if we added it from when we were
587:06 - working with the ui
587:08 - we have this interest bearing with
587:10 - instead of regular wrapped ethereum
587:13 - let's look at one of these transactions
587:15 - we can see
587:17 - that our borrowed transaction
587:19 - gave us some stable debt bearing dye and
587:22 - also some dye so we owe ave some die
587:26 - from this debt we got some debt we got
587:28 - some dye and we gave out some ave
587:30 - interest bearing dye to the rest of the
587:32 - albe protocol you'll notice now if we go
587:35 - to test.ava.com dash dashboard we'll see
587:38 - exactly what our script just did we have
587:40 - 160 borrowed
587:42 - and we have 0.1 eth deposited if we want
587:45 - to repay
587:47 - our funds we can do it
587:49 - with our current collateral or from our
587:51 - wallet balance
587:52 - and you'll notice something if i try to
587:54 - repay
587:55 - everything from my wallet all the diet
587:57 - that i've actually borrowed you'll
587:59 - notice we don't have enough funds to
588:01 - repay the full amount
588:02 - this is because since we actually
588:04 - borrowed a little bit we've include some
588:07 - of that interest so we actually owe more
588:09 - back than we originally borrowed that's
588:12 - how the loans work so when you're
588:13 - designing this repay functions be sure
588:16 - to have that in mind you can also have
588:17 - your repay be -1 to repay the entire
588:21 - debt it's recommended to send an amount
588:23 - slightly higher than the current amount
588:25 - borrowed but in any case maybe we say we
588:27 - want to do from our
588:28 - current wallet we'll hit max but maybe
588:31 - we want to actually just repay with our
588:32 - current collateral we can go ahead and
588:34 - repay the maximum amount again we could
588:36 - do this all from the ui
588:38 - we'll approve and this is exactly what
588:40 - our repay function actually did and now
588:42 - we're all repaid up if we go back to our
588:44 - dashboard and we hit refresh we'll see
588:46 - we just have a tiny bit of ethereum and
588:49 - no more borrowed assets awesome you've
588:51 - essentially learned everything that we
588:53 - need to go through for here
588:54 - this is a massive step forward in
588:56 - teaching you how to become
588:58 - quantitative defy wizards and build
589:00 - really robust applications and really
589:03 - robust financial applications in the
589:05 - default world now something i want to
589:06 - point out even though this isn't a
589:08 - python course and we're teaching more
589:10 - about solidity and smart contracts it's
589:12 - still in your best interest to test
589:14 - these functions
589:15 - yes i know they're python functions but
589:17 - it's still going to be in your best
589:18 - interest to test them to make sure your
589:20 - application always works as you expect
589:22 - it to now i'm not going to go through
589:25 - this testing suite that i put here but
589:27 - it's a really simple testing suite to
589:29 - test some of the different functions
589:30 - that we created
589:31 - it can be really helpful especially for
589:33 - something like get asset price where the
589:36 - math might be a little bit off and you
589:38 - want to make sure it's correctly again
589:39 - link in the description to seeing some
589:41 - of these tests
589:42 - this is actually going to be even easier
589:43 - than that lottery contract that we did
589:45 - since we're just testing python
589:46 - functions
589:47 - and again you can test these all with
589:49 - brownie test
589:51 - all right you are all doing
589:53 - fantastically now is another fantastic
589:56 - time to take a break go for a walk get
589:58 - some food because our next session our
590:00 - next lesson we're going to be learning
590:02 - about nfts how to build them use them
590:05 - and deploy them
590:12 - look nfts are hot right now nfts also
590:14 - known as
590:15 - erc721s are a token standard that was
590:18 - created on the ethereum platform nft
590:20 - stands for non-fungible token and is a
590:22 - token standard similar to the erc20
590:25 - again erc20s like link ave maker all
590:29 - those goodies that are found on the
590:30 - ethereum chain an nft or a non-fungible
590:33 - token is a token that is
590:36 - non-fungible this means that they are
590:38 - starkly unique from each other and one
590:40 - token isn't interchangeable with any
590:42 - other token of its class a good way to
590:44 - think about it is one dollar is
590:45 - interchangeable with any other dollar
590:47 - one dollar is going to have the same
590:49 - value of another dollar those are
590:51 - fungible tokens that's like erc 20s one
590:53 - link is always going to be equivalent to
590:55 - one other link by contrast is going to
590:57 - be nfts those you nerds out there would
591:00 - know like a pokemon would be a good
591:02 - example of an nft your one pokemon is
591:04 - going to have different stats different
591:06 - move sets and isn't interchangeable with
591:08 - any other pokemon or maybe a more
591:10 - relatable one is like a trading card a
591:12 - unique piece of art or the like so
591:14 - that's what these nfts are they are
591:16 - non-fungible non-interchangeable tokens
591:19 - that for the moment are best represented
591:22 - or thought about as digital pieces of
591:24 - art that are incorruptable and have a
591:26 - permanent history of who's owned them
591:28 - who's deployed them etc now like i said
591:31 - nfts are just a token standard so you
591:33 - can actually make them do much more than
591:35 - just be art you can give them stats you
591:37 - can make them battle you can do really
591:38 - unique things with them you can do
591:40 - pretty much whatever you want with them
591:41 - but right now the easiest way to think
591:43 - about it and the most popular way to
591:44 - think about it is by calling them art
591:52 - it's odd or some type of collectible or
591:55 - just anything that's unique now they've
591:57 - been getting a ton of buzz recently
591:58 - because we've been seeing more and more
592:00 - of these being sold at insane prices
592:02 - like we saw axe infiniti sell nine plots
592:05 - of their land nine plots of their unique
592:07 - land for 1.5 million dollars we also saw
592:11 - the original creator of the neon cat you
592:13 - know this cap
592:17 - sold for like 300 eth so like i said
592:20 - they're just tokens that are deployed on
592:21 - a smart contract platform and you can
592:23 - view them on different nft platforms
592:25 - like openc or wearable and these are the
592:28 - nft marketplaces that let people buy and
592:30 - sell them you obviously can do that
592:31 - without these marketplaces because it's
592:33 - a decentralized but they help and give a
592:35 - good user interface so that's the basic
592:37 - gist of it let's talk some more about
592:39 - the standards the erc721 standard or the
592:42 - nft standard this is the basis of it all
592:45 - there is another standard that's
592:46 - semi-fungible tokens the 1155 we're not
592:50 - going to talk about that here but you
592:51 - can check it out the main differences
592:53 - between a 721 and an erc20 on erc20s
592:56 - they have a really simple mapping
592:57 - between an address and how much that
592:59 - address holds 721s have unique token ids
593:03 - each token id has a unique owner and in
593:05 - addition they have what's called a token
593:07 - uri which we'll talk about in a minute
593:09 - each token is unique each token id
593:12 - represents a unique asset so since these
593:14 - assets are unique and we want to be able
593:16 - to visualize them and show what they
593:17 - actually look like we need to define
593:19 - those attributes of the object if it's a
593:21 - piece of r we need a way to define what
593:22 - that art looks like if it's some type of
593:25 - character in game we need a way to
593:26 - define that character's stats in the nft
593:29 - this is where metadata and token uris
593:31 - come in so if you know anything about
593:33 - ethereum you know that sometimes gas
593:34 - prices get pretty high especially when
593:36 - it comes to storing a lot of space it
593:38 - can get really really expensive so one
593:40 - of your first questions might be well
593:41 - are they storing these images and and
593:43 - these are pieces on chain and the answer
593:46 - is sometimes back when they were coming
593:48 - up with nfts and artists were deploying
593:49 - stuff the eth devs and the artists were
593:51 - like yeah art let's do that art i'm just
593:53 - going to deploy this one megabyte image
593:55 - onto the ethereum chain and oh god it's
593:58 - so much a gas expensive how do i
594:01 - totally find it
594:03 - i don't know why it's not um it's not
594:06 - delivered and they realize that if they
594:08 - put all this art on chain it's gonna be
594:09 - incredibly expensive so to get around
594:11 - this what they did is they put in the
594:13 - standard what's called the token uri
594:15 - this is a universally unique indicator
594:17 - of what that asset or what that token
594:20 - looks like and what the attributes of
594:21 - that token are and you can use something
594:23 - like a centralized api or ipfs to
594:26 - actually get that token uri typical
594:28 - token uri has to return something in
594:30 - this format like this it has the name
594:32 - the image location the description and
594:34 - then any attributes below now if you're
594:36 - like me your first question would
594:37 - probably be we paul from a single
594:41 - source
594:42 - seems pretty
594:44 - centralized
594:46 - this is a current limitation of the end
594:47 - of the ecosystem there is often this
594:49 - talk of on-chain metadata versus
594:51 - off-chain metadata because it is so much
594:53 - easier and cheaper to store all your
594:55 - metadata off-chain a lot of people will
594:56 - use something like ipfs that is
594:58 - decentralized but does take a little bit
595:01 - of centrality to keep persisting but
595:02 - they can also use their own centralized
595:04 - api however obviously if that goes down
595:06 - then you lose your image you lose
595:08 - everything associated with your nft
595:09 - because of this most nft marketplaces
595:11 - actually can't and won't read off
595:13 - on-chain attributes or on-chain metadata
595:15 - because they're so used to looking for
595:17 - the token uri obviously if you do
595:19 - off-chain metadata you can't do anything
595:21 - really cool or really interesting or
595:23 - have any games with your nfts for
595:24 - example if you wanted to create an
595:26 - on-chain pokemon game all your
595:27 - attributes would need to be on chain in
595:29 - order for your pokemon to interact with
595:31 - each other because if it was off chain
595:33 - then that becomes a lot harder to
595:34 - cryptographically prove so if you're new
595:36 - with nfts and you're like wait this is
595:38 - kind of a lot of information i'll make
595:39 - it easy for you if you're looking to
595:41 - render an image of an nft add your image
595:43 - to ipfs add a metadata file pointing to
595:46 - that image file on ipfs and then grab
595:48 - that token uri and put it and set it as
595:50 - your nft the chain link dnd article does
595:52 - a great job of walking you through this
595:54 - and showing you how to do this so be
595:55 - sure to read that if you're looking to
595:56 - learn how to do that so all the code
595:58 - that we're going to be working with is
595:59 - actually available for you in this
596:02 - nft mix brownie mix it's an official
596:04 - brownie mix and it allows us to deploy
596:06 - these three adorably cute dogs
596:10 - and there are two different types of
596:11 - contracts that we're going to be working
596:12 - with we're going to be first working
596:14 - with a simple collectible and then we're
596:16 - going to work with an advanced collect
596:18 - the simple collectible is going to be a
596:19 - very simple erc721 standard we're not
596:21 - going to really add any bells and
596:23 - whistles other than give it like a name
596:25 - and then our advanced collectible is
596:26 - going to take advantage of some of those
596:28 - more advanced true scarcity features
596:30 - that we were talking about so protocols
596:32 - like avagochi and ethercards use
596:34 - chainlink vrf to get verifiably random
596:36 - numbers to create verifiably scarce nfts
596:39 - something that's important to keep in
596:40 - mind is that in the real world when
596:43 - companies create trading cards there's
596:44 - no way to prove how scarce or how
596:47 - valuable these trading cards actually
596:49 - are if we use a verifiable random number
596:51 - then whoever is deploying these nfts
596:54 - can't even control how rare these nfts
596:56 - really are so we get this verifiable
596:58 - scarcity and this verifiable rarity
597:00 - which adds some value to the tokens if
597:03 - you want to just go ahead and work right
597:05 - from the brownie mix you can actually
597:06 - just run brownie bake nft mix
597:11 - and then cd into nft
597:14 - and all of our code
597:16 - is gonna be right in here we're gonna go
597:17 - through and deploy and develop
597:19 - everything from scratch because we're
597:20 - going to actually take some previous
597:22 - concepts that we've learned improve on
597:24 - them and we're going to learn a lot of
597:26 - nitty gritty interesting pieces about
597:28 - making this hybrid smart contract
597:30 - because these nfts really are a perfect
597:32 - example of a hybrid smart contract they
597:35 - have some off-chain component
597:36 - interaction with a random number and
597:38 - restoring their metadata with ipfs and
597:41 - i'll explain ipfs a little bit more in
597:43 - depth as we go on here
597:45 - so let's go ahead and get to it i'm
597:47 - going to go ahead and make a new
597:48 - directory
597:50 - called nft demo
597:51 - i'm gonna cd into it
597:54 - code
597:55 - period
597:56 - and perfect i have a blank project here
597:59 - and you already know what the first step
598:00 - we're gonna do is
598:02 - is do brownie init to create our blank
598:04 - brownie repository now let's go ahead
598:07 - and create our first
598:08 - contract we'll call this
598:11 - simple
598:12 - collectible
598:14 - dot soul since this is going to be it
598:15 - since this is going to be a simple
598:17 - collectible a simple nft that we're
598:19 - going to get started with now similar to
598:21 - the erc20 this erc 721 standard
598:25 - has a number of functions that we can
598:26 - actually work with we can go ahead and
598:28 - even look at the 721 the erc721
598:31 - non-fungible token standard on the
598:34 - eips.ethereum.org website and we can see
598:36 - a sample interface and some sample
598:38 - events and some functions and kind of
598:40 - everything that we've grown to know and
598:42 - love and once again instead of us kind
598:44 - of recoding copy pasting all this from
598:46 - scratch we're going to be using we're
598:48 - going to be using open zeppelin's erc721
598:51 - documentation for this
598:53 - now we're going to be working with
598:54 - version 3.x there is a version 4.x that
598:58 - has come out using version 3.x of their
599:00 - open zeppelin contracts is also i think
599:02 - a little bit easier to explain but again
599:04 - those who want to challenge yourself
599:06 - definitely try their 4.x version so
599:08 - let's go ahead and jump right into it
599:10 - first we'll do our srspdx
599:14 - license identifier
599:17 - mit
599:18 - then we'll choose our solidity version
599:21 - we're going to use pragma solidity 0.6.6
599:24 - but again most of this should work for
599:27 - 0.8 moving forward
599:29 - and then we're going to go ahead and
599:30 - look at the open zeppelin erc721
599:33 - documentation
599:35 - and we're going to go ahead and
599:37 - grab this line right here
599:39 - import open zeppelin slash contracts
599:41 - token
599:42 - erc721
599:43 - erc21.soul you can even see
599:46 - a sample erc721 that they give you and
599:49 - this is actually going to be similar to
599:50 - the erc721 that we're going to make so
599:52 - we're going to go ahead and paste that
599:54 - and of course since we're doing this at
599:56 - opensupplement contracts we're going to
599:58 - need to
599:59 - create our brownie config
600:04 - and same as always the pen
600:06 - [Music]
600:08 - then sees
600:10 - it's going to be
600:13 - open zeppelin slash open
600:16 - zeppelin contracts
600:18 - and again like i said we're versing
600:20 - we're using version three
600:21 - so
600:22 - 3.4.0 again and then we'll do compiler
600:27 - sulk
600:31 - remappings
600:34 - and we'll say
600:35 - at open
600:37 - zeppelin
600:39 - equals
600:41 - this
600:43 - and great let's even try to just compile
600:45 - this right now browning compile
600:50 - and perfect it has been compiled now
600:52 - similarly to our erc 20 that we did with
600:54 - open zeppelin we're going to do the same
600:56 - startup here so we're going to say
600:58 - contract
601:02 - simple collectible is erc erc721
601:07 - and this is how we're going to inherit
601:09 - all of those functions
601:12 - in the erc721 token standard here and we
601:16 - can start adding r
601:18 - and we can start coding our simple erc
601:20 - 721 now for our erc 721 we're going to
601:24 - make it be a couple of these cute
601:26 - adorable dogs so it's going to be one of
601:28 - these three dogs for our simple
601:30 - collectible we're just going to go ahead
601:31 - and use the pug here so so you can use
601:34 - any image that you want for this demo um
601:37 - however if you want to just follow along
601:38 - with us
601:39 - we can just download this
601:41 - dog and we'll call it pug create a new
601:44 - folder
601:45 - here called img and then i'm just going
601:48 - to add pug.png to this img folder so
601:51 - this is going to be the mft that we're
601:53 - going to deploy we're going to deploy
601:55 - this very simple pug for our smart
601:57 - contract so we're going to be deploying
601:59 - this pug this is the image that we're
602:01 - going to use for our nft it's going to
602:03 - be this adorable pug so let's go ahead
602:05 - and create the rest of the contract for
602:07 - this pug so the first thing we're going
602:09 - to make is our constructor
602:12 - it's going to take no input parameters
602:14 - it's going to be a public constructor
602:16 - and then we're going to go ahead and use
602:18 - the erc721 constructor
602:21 - which if we look at the documentation
602:23 - we give it a name
602:25 - and then a symbol
602:27 - we're going to use the erc721
602:29 - their parameters
602:31 - which is going to be a name which we're
602:33 - going to say is doggy and a symbol
602:35 - which we're going to say is dog and
602:38 - perfect
602:40 - that's all i really need to do for the
602:41 - first part this nft contract is actually
602:44 - what's known as a factory contract
602:46 - there's a main contract and in it it has
602:48 - a list of all the nfts and the owners
602:51 - that are of this type of nft so in this
602:54 - example all the type of nft is just
602:56 - going to be this pug and it's just going
602:58 - to be this dog and we actually need a
603:00 - function to mint new nfts based off of
603:04 - this pug now we can absolutely have an
603:06 - nft factory contract that only creates
603:09 - one single nft but we're going to use
603:11 - this factory implementation to create
603:13 - multiple nfts we're going to do it with
603:16 - a function called create collectable
603:18 - this will create a new nft and assign it
603:21 - to whoever called this function so
603:24 - anybody can come here and create a new
603:25 - puppy for themselves or in other words
603:28 - adopt a puppy so we're going to say
603:29 - function
603:31 - crate collectible
603:34 - public
603:35 - and we're going to say returns
603:38 - you went 256.
603:40 - you'll see why we need to do this in a
603:41 - minute now when we create this
603:43 - collectible all we're doing is we're
603:45 - assigning a new token id to a new owner
603:49 - and if we look at the open zeppelin
603:51 - erc721
603:53 - github
603:55 - we can see they have this safe mint
603:57 - function this is the function that they
603:59 - use to
604:00 - mint or create a new nft
604:03 - this function it's it takes a new
604:05 - address 2 which is going to be the new
604:07 - owner of the nft and a token id every
604:10 - nft in this factory contract has a
604:12 - unique token id we're going to have our
604:15 - token ids start from 0 and and just
604:18 - increment every time we have a new token
604:19 - minted this safe mint function calls
604:21 - this safement function which calls this
604:23 - minting function so
604:25 - if you're looking at the code here
604:27 - this mint function is really the the
604:29 - function that calls and creates this nft
604:32 - you'll see actually that they just have
604:34 - two mappings that they update
604:36 - they update this owner's mapping
604:39 - which is just a mapping of token ids to
604:42 - the owners of the token ids
604:44 - and then they update this balances
604:47 - mapping
604:48 - which is a mapping of owner address to
604:50 - the token count so the number of tokens
604:53 - that an owner actually has and that's
604:55 - all that's happening when we call this
604:57 - mint or in our case safement function
604:59 - the difference between safe mint and
605:01 - mint
605:02 - is safement checks to see if a token id
605:04 - has already been used or not and this
605:06 - way we don't actually override who owns
605:09 - tokens and who owns tokenids so we're
605:11 - going to use the safement function so
605:13 - first we need to think okay well we're
605:15 - going to need to a way to count these
605:17 - token ids so that every single person
605:19 - has a unique token id
605:21 - so let's create a global variable un256
605:24 - public
605:26 - token counter
605:27 - and we'll initialize it tokencounter to
605:30 - zero of course
605:32 - this is the same as initializing token
605:34 - counter to zero
605:36 - but let's just make it very explicit so
605:39 - when we create a new collectible
605:41 - we're going to say uwen256
605:44 - new token id is going to be equal to
605:47 - this
605:48 - token counter and we're going to iterate
605:50 - this every time we mint a new token so
605:52 - for example we're going to iterate that
605:54 - in this create collectable here so new
605:56 - token id equals token counter we're
605:59 - going to call
606:01 - this safement function since we're
606:03 - inheriting it from open zeppelin's
606:05 - erc721 we need to give it this new nft
606:08 - and owner which is going to be
606:10 - message.sender so whoever calls this
606:12 - function
606:13 - and then we need to give it
606:15 - a unique token id which is going to be
606:17 - this new token id now whenever we mint
606:19 - one we're going to want to
606:21 - increment this token counter so then we
606:23 - can say token counter
606:24 - equals token counter plus one
606:27 - and we can then return
606:29 - this new token id so we'll return the
606:31 - token id of the token that we just
606:33 - created and boom if you're looking for
606:36 - an incredibly minimalistic contract to
606:38 - deploy nfts this is all that you need so
606:41 - we can run brownie compile
606:44 - to make sure we did everything right
606:46 - and project has been compiled we can see
606:48 - it in the build so great job obviously
606:50 - this might be a little dissatisfying to
606:53 - you after the breakdown that we just
606:55 - gave how do we view this token what does
606:57 - this token look like i thought we wanted
606:59 - this to be a doggy how do we know that
607:01 - this looks like a dog how do we get this
607:03 - image on the blockchain this is where
607:06 - metadata is going to come into play now
607:08 - if we look at the original erc 721 there
607:11 - is this part called the metadata
607:13 - extension is optional for erc 721 smart
607:16 - contracts as we've talked about anytime
607:18 - you make a transaction on chain it costs
607:21 - some gas even very tiny amounts of data
607:24 - can cost more and more gas images are
607:27 - much bigger than these little bits of
607:29 - data here and they can cost a lot more
607:31 - gas
607:32 - so when this standard was being created
607:34 - the developers kept this in mind and
607:36 - knew that storing entire images and
607:39 - entire gifs and entire videos on chain
607:41 - was going to be incredibly costly so
607:44 - they added this piece about metadatas
607:46 - and token uris the token uri is a
607:49 - distinct uniform resource identifier for
607:52 - a given asset this is an example of a
607:54 - uri and the metadata that we're going to
607:56 - be demoing today a uri is just a unique
607:59 - resource identifier so this can be
608:02 - something like https or ipfs or any url
608:05 - string that uniquely points to some
608:08 - metadata your metadata file is going to
608:10 - look like this
608:12 - it's going to have a title
608:14 - for the title of the nft
608:16 - can have a type
608:17 - and it can have all these different
608:18 - properties or stats or attributes for
608:21 - example we're going to have our pug nft
608:24 - which is going to be defined like this
608:26 - it's going to have a name as pug
608:29 - description is going to be an adorable
608:31 - pug pup and it's going to have what's
608:33 - called the image uri which defines what
608:35 - the token actually looks like and if we
608:38 - copy paste this into another browser
608:40 - we get returned this it's this token uri
608:44 - with this metadata json object that's
608:46 - going to enable different nft platforms
608:48 - to actually render our nft so this is an
608:51 - example of what this pug is going to
608:53 - look like on different nft
608:55 - marketplaces like openc
608:58 - platforms like openc understand that
609:00 - they need to show this image they need
609:02 - to use this name they need to use this
609:04 - description and have these traits so if
609:06 - we look back at this
609:08 - nft on openc we can see the name is pug
609:11 - we can see the description here if we go
609:13 - to levels we see its cuteness as 100 out
609:15 - of 100 now this of course leads us to a
609:18 - really interesting point if we're
609:20 - storing the image off chain then how is
609:22 - this image decentralized if we're
609:24 - storing this image off chain how can we
609:27 - guarantee this nft is going to stay
609:29 - forever now this leads us into a little
609:31 - tidbit about storing data on blockchain
609:34 - as of current recording storing a lot of
609:37 - data on chain can get incredibly
609:39 - expensive the more data that you store
609:41 - the more transactions that you have to
609:43 - make to store that data on chain and the
609:46 - more gas that you're going to have to
609:47 - spend at the time of recording ethereum
609:49 - is about little less than 900 gigabytes
609:52 - in size if a ton of people were to put
609:54 - full videos or movies or
609:57 - massive images ethereum would grow
609:59 - exponentially out of proportion and this
610:01 - would become unsustainable for the
610:03 - blockchain network as a whole so
610:05 - ethereum isn't great for actually
610:06 - storing a ton of data it can store a lot
610:08 - of data but it's a lot better for doing
610:11 - the logic and the smart contracts so
610:13 - there are a lot of different platforms
610:14 - that are actually working on this
610:15 - problem of storage these platforms allow
610:18 - people to store data in a decentralized
610:20 - way that isn't going to exponentially
610:22 - explode the size of ethereum or
610:24 - different smart contract platforms the
610:25 - decentralized storage methodology we're
610:27 - going to work with is going to be ipfs
610:30 - or interplanetary file system and this
610:33 - is where we're actually going to store
610:34 - our image and this is actually where
610:36 - we're going to store our image so that
610:37 - nft marketplaces know what our nft looks
610:40 - like now here's what some protocols do
610:43 - some protocols just set up a server and
610:46 - set this token uri to instead be from a
610:49 - decentralized service like ipfs and use
610:52 - just maybe their own centralized server
610:55 - this is obviously a massive issue
610:57 - because if their server goes down or if
610:59 - they want to change the
611:00 - image or they want to change the stats
611:03 - all they have to do is change it in
611:04 - their server and this is why a protocol
611:06 - like ipfs is going to be a lot easier
611:08 - quicker and more decentralized version
611:10 - of doing this the full solution is going
611:12 - to be using something with ipfs and
611:14 - filecoin but easy solutions to do that
611:16 - are still being built out so for now
611:18 - we're just going to use ipfs because
611:20 - it's free it's quick and it's easy and
611:22 - it can be expanded to combine with file
611:24 - coin to be even easier to work with now
611:26 - something else that i want to touch on
611:28 - too when it comes to this metadata right
611:30 - now all these nft marketplaces only know
611:32 - how to pull attributes
611:34 - from this token uri now if we want to
611:37 - build really cool nfts that can interact
611:39 - with each other having some attributes
611:41 - or maybe some like like attack stats or
611:43 - attack moves like in pokemon for example
611:45 - or trading cards we can't just store
611:48 - these in this token uri
611:50 - because the blockchain doesn't know
611:51 - anything about this token uri so we
611:54 - actually need to store these attributes
611:56 - on chain i'm really hoping in the future
611:58 - a lot of these nft marketplaces are
612:00 - going to get better at
612:02 - and pulling metadata from on chain but
612:05 - now right now any attribute that we give
612:07 - our nfts we actually have to reproduce
612:09 - in the token metadata and the token uri
612:12 - as well so we've just learned a lot
612:14 - about metadata ipfs token uris and
612:18 - everything like that let's update this
612:20 - simple nft to be able to render on openc
612:23 - and render on these nft platforms
612:26 - because right now if we were to deploy
612:27 - this nobody would know what this doggie
612:29 - looks like so let's give it a token uri
612:33 - so in this crate collectible let's do
612:35 - string
612:36 - memory
612:38 - token uri
612:40 - and after we call this safemint function
612:43 - there's another function that we're
612:44 - importing
612:45 - called set
612:47 - token uri
612:49 - and we're going to set the token uri
612:51 - for the token id
612:54 - and we're going to give it this token
612:56 - uri
612:59 - this will allow our nft to actually have
613:01 - an image associated with it that we can
613:03 - actually see
613:04 - so let's go ahead and so let's go ahead
613:06 - and create a script that's going to
613:08 - deploy this nft factory contract and
613:11 - then create us a collectible
613:13 - so we're going to do new file we'll call
613:15 - it deploy
613:17 - and create
613:19 - dot pi and let's jump into our script
613:21 - so we'll do def main
613:24 - first we need to start with an account
613:26 - and
613:28 - once again we can go ahead and create
613:32 - helpful scripts
613:34 - dot pi
613:35 - we can go ahead and copy paste this get
613:37 - account function in here if you want
613:53 - but of course since we added this config
613:55 - wallet from key we're going to go to our
613:57 - browning config we'll add wallets
614:01 - from key
614:02 - and we're going to grab our private key
614:06 - environment variable
614:07 - since we're using a private key
614:09 - again
614:10 - we're going to create a dot env
614:13 - and we need our to export private key
614:16 - and we're also going to need to export
614:17 - our web3
614:18 - infuro
614:20 - project id
614:22 - so we can just copy paste for my last
614:25 - project the private key web3 inferior
614:27 - project id and our etherscan token so
614:30 - that we can actually verify this on
614:31 - chain and we'll add a new file
614:34 - init
614:35 - dot pi
614:36 - so that older versions of python know
614:38 - that this is indeed a package
614:40 - so we'll go ahead and do from
614:43 - scripts
614:45 - dot helpful scripts
614:46 - import
614:48 - get account now all we have to do
614:50 - is import our simple
614:53 - collectible
614:55 - and run
614:58 - simple
614:59 - collectible
615:01 - equals
615:03 - simple collectible
615:05 - dot deploy and if we look ours and if we
615:08 - look at our simple collectible we have
615:09 - no constructor parameters here so we can
615:12 - just do from
615:15 - account
615:16 - and now this will have our simple
615:18 - collectable deployed now we need to
615:20 - actually call this now we actually need
615:22 - to call this create collectable function
615:24 - and we're going to pass it a string
615:25 - which is going to be this token uri
615:29 - i'm going to go ahead and use this
615:31 - sample token uri that is included in our
615:34 - nft mix so if you're looking to get this
615:37 - token uri
615:38 - look up nft mix patrick collins
615:41 - hopefully the github will show right up
615:43 - and we can just go right to the scripts
615:45 - in here
615:47 - it's in the simple collectible folder
615:49 - create collectable
615:52 - that's the bigfoot we're going to grab
615:53 - this and in our script we're going to do
615:55 - sample
615:57 - token uri
615:58 - equals
616:00 - this
616:01 - now when you paste this token uri in
616:03 - your browser if you can't see it you
616:05 - might have to add something like ipfs
616:07 - companion to your browser like this
616:10 - some browsers don't natively have it so
616:12 - so there is a link to ipfs companion for
616:15 - this project in the github repo but now
616:17 - that we have a token uri we can call
616:19 - this create collectable function so
616:21 - we'll do
616:23 - transaction
616:25 - equals
616:26 - simple collectable
616:28 - dot create
616:30 - collectible
616:32 - and we'll pass in this sample token uri
616:35 - and then of course we'll do from
616:39 - account
616:41 - we'll do tx.weight we'll wait for one
616:43 - block and then if we've done this
616:45 - correctly we'll actually be able to see
616:47 - this nft
616:49 - on an nft marketplace like open c
616:52 - so let's do a quick print line here
616:53 - we'll do print
616:55 - awesome
616:56 - you can now
616:58 - you can view your nft
617:03 - at
617:04 - and we'll do this in fstring
617:06 - and this is where we're going to put the
617:07 - openc url for this ring b
617:10 - so we're going to say open c url
617:13 - which is going to be equal to if we pop
617:15 - over to open c if we pop over to this
617:17 - open c pug here on the ring p test net
617:20 - we can go ahead and grab
617:22 - this first start of the string so it's
617:24 - going to be https testnets.openc.io
617:28 - assets and then this is the address of
617:30 - the contract
617:32 - so we can say openc url is going to be
617:34 - this slash
617:36 - and we'll put this little brackets here
617:38 - slash and then another one of these and
617:40 - this is because the url for here
617:43 - testness.openc.io assets
617:46 - it's the contract address and then the
617:48 - token id on the end here so this is what
617:51 - it's going to look like
617:52 - so in our print line awesome you can
617:54 - view your nft openc.format
617:57 - simplecollectable.address
617:59 - comma
618:00 - and we do simplecollectable dot
618:08 - token counter
618:09 - minus one
618:11 - for the most recently deployed one and
618:13 - then we'll run this now
618:15 - brownie run scripts
618:17 - deploy and create
618:19 - network
618:20 - rink b
618:25 - and awesome we get this print line here
618:27 - saying
618:28 - awesome you can view your nft at https
618:31 - testness.openc.io just keep in mind
618:33 - obviously for mainnet we can't use this
618:35 - testnet.openc.io
618:36 - but
618:37 - assets the address of the nft contract
618:40 - and then the token id as well
618:42 - so if we go ahead
618:44 - and click this and it looks like it's
618:46 - already actually been rendered here in
618:48 - openc we could even go ahead and hit
618:50 - refresh metadata just in case it doesn't
618:51 - show up right away but it looks like for
618:53 - us it did show up right away which is
618:55 - awesome some other kind of fun parts
618:57 - about openc is if we go to our profile
618:59 - here
619:00 - we'll actually be able to see all the
619:01 - nfts that we own on this testnet i've
619:04 - actually deployed this this doggie twice
619:06 - here once to test and then once i
619:07 - actually do it great we've created our
619:10 - simple collectable of course no project
619:12 - is complete without some tests so let's
619:14 - create some tests since we're also going
619:17 - to be doing an advanced collectible i'm
619:18 - going to skip the integration test and
619:20 - i'm just going to write a really simple
619:22 - unit test so we'll create a new folder
619:24 - we'll call it unit
619:25 - and in here we'll do a new file
619:27 - test
619:29 - simple collec
619:33 - so let's create our first test we'll do
619:35 - def test can
619:37 - create
619:38 - simple collectible
619:40 - we'll just make sure that we can
619:42 - actually create a simple collectible now
619:44 - we'll make sure that this is our unit
619:46 - tests so we'll do from scripts dot
619:49 - helpful scripts
619:50 - import local blockchain environments
619:54 - and then we'll do if
619:56 - network.showactive
619:59 - not in
620:00 - local blockchain environments
620:02 - pi test.skip
620:05 - so of course we need to do from
620:08 - brownie
620:10 - import
620:11 - network
620:13 - and then also import pi test
620:16 - now something that we could do here is
620:18 - actually in our test we could go ahead
620:19 - and even test our scripts by importing
620:22 - uh deploy and create here and testing
620:24 - this we do something like return
620:28 - simple collectible
620:30 - and in our test then we could do
620:33 - from scripts
620:36 - dot deploy and create import deploy and
620:39 - create
620:41 - and then back in our deploy and create
620:42 - script we can modify this a little bit
620:44 - instead of main here we'll call this
620:46 - deploy and create and then we'll have
620:49 - our main function
620:51 - just call
620:52 - deploy and create
620:54 - and you'll see ronnie runs scripts
620:58 - deploying create to pi if we go ahead
620:59 - and run this again we can just run this
621:01 - on the development network real quick
621:03 - instead of on ring p you'll see that
621:04 - this does also work obviously we won't
621:06 - actually be able to see our nft on openc
621:09 - because this is deployed to the brownie
621:11 - temporary ganache chain as opposed to a
621:13 - persistent wrinkly chain in our test
621:15 - here
621:16 - we could then just do we just run
621:19 - simple
621:20 - collectible
621:22 - equals deploy and create
621:25 - and then we'll do an assert here we'll
621:27 - assert
621:29 - simple collectible
621:34 - that owner of zero
621:37 - is going to be equal to get account
621:39 - and then we'll also import
621:42 - get account
621:45 - so we can run brownie test
621:49 - make sure this works and perfect now
621:51 - this was all fun and dandy but there's a
621:53 - couple of things that we didn't go over
621:55 - and that we didn't do so let's create a
621:57 - quick readme.md for a couple of notes
622:00 - so number one
622:02 - we didn't upload an image
622:05 - to ipfs ourselves so we just used a
622:08 - token uri that was already existing
622:10 - right we didn't actually upload
622:11 - something to ipfs we didn't go over why
622:14 - is ipfs
622:16 - decentralized we didn't really talk too
622:18 - much about what ipfs is number three
622:21 - anyone can mint an
622:24 - nft here
622:26 - with any type of stats right it's not
622:28 - going to be it's not verifiably scarce
622:32 - or random right this isn't that cool so
622:35 - we want to actually build an nft project
622:38 - that has all these pieces where we
622:41 - upload the image to ipfs ourselves we're
622:43 - going to talk a little bit more about
622:44 - why ipfs is decentralized and it's the
622:47 - preferred solution for storing nft
622:49 - metadata and we're going to make our nft
622:52 - more verifiably random and verifiably
622:54 - scarce like for things like ethercards
622:57 - and avagoji let's go ahead and do this
622:59 - project again but we'll integrate the
623:01 - chain link vrf
623:02 - to make this nft verifiably scarce and
623:05 - verifiably random and then we'll also
623:07 - teach you guys how to upload to ipfs and
623:10 - work with ipfs ourselves so let's go
623:12 - ahead and do this so let's create a new
623:15 - file in our contracts and we'll call it
623:18 - advanced
623:20 - collectible dot sol and what we're going
623:22 - to do here is we're going to make again
623:25 - an nfc contract
623:28 - where the token uri
623:31 - can be one of three different dogs so if
623:35 - we look at this nft mix in the images
623:37 - section there's a pug a shibba in you
623:39 - and a saint bernard or one of these
623:42 - three dogs
623:43 - we're gonna make it so that when you
623:44 - mint one of these nfts you're gonna get
623:46 - you're gonna get a random one of these
623:48 - three dogs now i'm not gonna go over
623:50 - stat generation
623:52 - and like creating battle battling nfts
623:54 - or really games out of these nfts if you
623:56 - guys wanna see a version of those
623:58 - contracts check out this dungeons and
624:00 - dragons nft there's a link in the github
624:02 - to see this and it actually creates
624:04 - characters that can do battle and have
624:06 - like stats and attributes like
624:08 - um like attack
624:11 - and different things you'd find in
624:13 - dungeons and dragons this one's done
624:15 - actually with truffle as opposed to
624:17 - being done with brownie but all the
624:20 - contracts are going to be the same other
624:21 - than this migrations.soul so if you're
624:23 - looking to check this out you absolutely
624:25 - can it is a ton of fun and they have
624:27 - some really cool images as well so be
624:29 - sure to check that out if you're looking
624:30 - for more anyways here's what we're going
624:31 - to be looking to do we're going to make
624:32 - an nft contract where the token uri can
624:35 - be one of three different types of dogs
624:36 - and it's going to be randomly selected
624:38 - so let's go ahead and do it so first
624:41 - again we're going to do this spx license
624:43 - identifier right at the top so we can go
624:45 - ahead and put that there
624:47 - and we're going to even use
624:49 - same solidity version and we're going to
624:51 - use open zipline again so
624:53 - we can literally just copy and paste
624:54 - that from our last project now we're
624:57 - going to create our contract
624:58 - advanced
625:00 - collectible
625:02 - we're going to say is erc
625:04 - 721
625:07 - great
625:09 - and then since we're going to want to
625:10 - work with chain link vrf to get a
625:12 - provably random nft we're also going to
625:14 - want to import
625:16 - at chain link
625:18 - contracts
625:19 - slash src
625:21 - v0.6 vrf con
625:24 - consumer
625:26 - base dot sol
625:28 - and of course that means we're going to
625:29 - go back to here and we're going to add
625:31 - smart contract kit
625:33 - slash chain link
625:37 - brownie
625:39 - contracts
625:40 - at 1.1.1 and then we're going to go
625:43 - ahead
625:44 - and add the remapping in
625:46 - we'll say
625:48 - at chain link equals
625:51 - boom
625:53 - awesome so we've imported the chain link
625:55 - bit
625:56 - our advanced collectible is erc 721 and
626:00 - it's going to be vrf
626:02 - consumer base so same as always let's go
626:05 - ahead and start with the constructor we
626:07 - know from our lottery smart contract
626:08 - that we're actually going to want to
626:09 - parameterize a lot of these pieces for
626:11 - working with the vrf coordinator for
626:13 - working on different chains and
626:15 - different test nets
626:16 - so we're going to do address
626:19 - vrf
626:20 - coordinator we're going to do address
626:23 - link token
626:25 - bytes32
626:27 - keyhash
626:28 - and we can always head back over to
626:30 - docs.chain.link go to get a random
626:32 - number just in case we forget what some
626:34 - of the parameters are vrf coordinator
626:37 - link token keyhash and fee
626:39 - great you went 256 feet
626:42 - i will make this
626:44 - public as well
626:46 - add a little curly bracket there
626:49 - and we can go ahead and start doing the
626:51 - rest of this of course we need to do the
626:53 - vrf consumer based constructor and the
626:55 - erc721 constructor
626:57 - so
626:58 - vrf consumer base
627:02 - is going to be this vrf coordinator
627:06 - and this link token
627:08 - and the erc 721
627:11 - we could paramore ties these as well but
627:13 - we know it's going to be a dog so we'll
627:14 - do doggy and the symbol of dog
627:17 - which is the same
627:19 - as our simple collectible here we know
627:22 - we're also going to need to do this
627:23 - token counter bit
627:25 - so we'll do
627:26 - you want 256
627:28 - token counter
627:32 - and right in here
627:33 - we're going to do
627:35 - token counter
627:36 - equals zero of course we're going to
627:38 - need a key hash
627:40 - so let's make this unit 56 public token
627:43 - counter
627:44 - excuse me
627:45 - we're going to do a bytes32
627:48 - public key hash
627:53 - and we're going to do
627:54 - a uint256
627:56 - public fee
627:58 - and we'll set
628:00 - key hash
628:01 - equals
628:03 - key hash
628:04 - and fee equals
628:06 - fee
628:07 - great so this is a combination of a lot
628:09 - of the stuff we did in our lottery smart
628:11 - contract and some of the pieces that
628:14 - from our erc 721 we need the key hash
628:17 - the fee vrf coordinator link token all
628:20 - for the vrf consumer base
628:23 - oops i should put a extra quote here and
628:25 - then we need dog doggy and a token
628:28 - counter for erc 721 so now
628:31 - we're going to create
628:33 - our function create collectable
628:36 - so we're going to do function
628:39 - create collectible
628:41 - and again we're going to do a string
628:43 - memory token uri
628:45 - but this time in our python scripts
628:47 - we're actually going to define where
628:49 - we're getting this token uri from and
628:51 - we're going to create it ourselves but
628:52 - we're going to make this public
628:54 - and it's going to return
628:58 - a bytes32 remember way back in our
629:00 - lottery when we did this event requested
629:02 - lottery winner when we called the
629:04 - chainlink vrf we're going to do a
629:06 - similar thing here where we're going to
629:08 - make an event for whenever we request
629:10 - one of these new dogs and that is also
629:13 - what we're going to return we're going
629:14 - to return that request id here so since
629:17 - we're using the chainlink vrf here we
629:19 - can go ahead and call that request
629:21 - randomness function which again
629:23 - over the docs.chain.link this is
629:25 - imported from the erc721
629:28 - and then in that request and receive
629:30 - model it's going to call back with our
629:32 - fulfill randomness function we're going
629:33 - to need to do a couple of different
629:35 - things here because we want the user who
629:37 - called create collectable to be the same
629:39 - user who gets assigned the token id
629:43 - so first we'll do bytes 32
629:46 - request id equals request
629:50 - randomness
629:52 - and we're going to pass obviously the
629:53 - key hash
629:55 - and the fee
629:56 - this is going to create our randomness
629:58 - request to get a random breed for our
630:00 - dogs so let's go ahead and just define a
630:03 - little bit of the fulfill randomness
630:04 - function so we can figure out how we're
630:06 - actually going to pick a random dog well
630:08 - the first thing that we're going to need
630:09 - is we're going to need some definition
630:11 - of what the different breeds that the
630:13 - dog can actually be and again similar to
630:15 - the lottery we're going to create a new
630:17 - type called breed using the enum
630:19 - so we're going to do enum breed
630:23 - and then we're going to give it three
630:24 - types
630:25 - pug which is going to be state 0
630:28 - shiba inu which is going to be state 1
630:31 - and say bernard which is going to be
630:34 - state 3. so our breed is going to be one
630:37 - of these three breeds here so then in
630:41 - our function
630:41 - [Music]
630:42 - fulfill randomness
630:46 - when we get that random number back we
630:48 - can use that random number to pick one
630:50 - of these three breeds
630:52 - so of course we need to have a byte32
630:56 - request id and uint256
631:00 - random number
631:02 - and we're going to make this internal
631:04 - override so that only the vrf
631:07 - coordinator can call this and what we're
631:09 - going to do now is we're going to select
631:11 - a breed based off of this random number
631:13 - so we're going to say breed
631:15 - breed which we're saying
631:18 - this breed variable is of type breed
631:21 - it's going to be equal to
631:23 - breed generated from that random number
631:27 - mod 3.
631:29 - since we have one two
631:32 - three different breeds awesome so this
631:34 - is how we're going to get our random
631:35 - breed however we do need to assign this
631:38 - breed to its token id so now that we
631:42 - have a random breedback how do we
631:43 - actually go ahead and assign this well
631:46 - we're going to have to create a mapping
631:47 - to do this it'll look something like
631:49 - token id
631:51 - 2
631:53 - breed we're going to have to get our
631:54 - token id somehow
631:56 - and we're going to have to equal it to
631:58 - the breed
632:00 - so then our first question is okay well
632:02 - in order for us to assign this breed to
632:04 - the token id
632:05 - how do we actually get the token id well
632:07 - we're going to grab the token id by
632:09 - doing
632:10 - uin256
632:13 - new token id
632:15 - equals
632:17 - token counter
632:19 - and then
632:21 - we'll just set the token id to breed
632:23 - using this new token id equal to the
632:25 - breed so we're going to want to make
632:27 - this token id to breed
632:30 - mapping up here
632:31 - so which we can do
632:33 - mapping
632:35 - uint256
632:37 - map2
632:38 - breed
632:39 - and we'll call it
632:40 - tokenid to breed this way each token id
632:43 - is going to have
632:45 - a very specific breed based off of this
632:47 - mapping's results perfect okay what else
632:49 - do we need in this fulfillment we need
632:51 - to mint the nft and we need to set a
632:54 - token uri well when we minted it before
632:57 - we call this safement function however
632:59 - message.sender here is always going to
633:01 - be the vrf coordinator since the vrf
633:03 - coordinator is actually the one calling
633:05 - this fulfill randomness so we can't
633:07 - actually have this just be
633:08 - message.sender we need to figure out how
633:11 - we can get the original caller of create
633:14 - collectable here how do we get
633:16 - the original message.sender of create
633:18 - collectable
633:19 - well the answer there is actually going
633:21 - to be in another mapping when we call
633:22 - create collectable we can create a
633:25 - mapping of request
633:27 - id
633:28 - to
633:28 - [Music]
633:29 - sender and this is going to take the
633:31 - request id as a key
633:34 - and then whoever sent it as the value
633:38 - so we're going to create this new
633:39 - mapping at the top
633:43 - and then actually let's make this other
633:45 - mapping public as well
633:47 - we'll do
633:48 - mapping bytes32
633:50 - to
633:52 - address
633:54 - we'll call this public
633:56 - request id
633:57 - to
633:58 - sender now in our fulfill function the
634:02 - same request id that requested the
634:04 - random breed is returned so what we can
634:07 - do is we can say address
634:10 - owner
634:11 - or sender
634:13 - is going to equal
634:14 - request id to sender
634:20 - of request id
634:22 - and then this address owner is who we're
634:24 - going to safemint the nft to and of
634:26 - course while we're matching up the
634:28 - functions we don't want to forget to
634:29 - always do token counter equals token
634:31 - counter plus one at the end
634:33 - awesome now we still need to set the
634:35 - token uri here
634:37 - so back in our advanced collectable
634:39 - we're gonna have to do this set token
634:41 - uri at some point so let's actually
634:43 - think about this for a second
634:45 - we're only going to know breed of our
634:47 - dog once this random number is returned
634:50 - and we know the breed of the dog is
634:51 - going to be one of these three breeds
634:53 - it's going to be a bug a shiba inu or a
634:55 - saint bernard and let's actually for now
634:57 - let's even just go ahead and add those
634:59 - three images to our project here create
635:02 - a new folder
635:03 - we'll call it image
635:05 - and you can put whatever images you want
635:07 - here i'm actually just going to download
635:09 - i'm actually just going to download the
635:10 - three images right from
635:12 - the nft mix boom and now i have my pug
635:16 - my shiba inu and my saint bernard in
635:18 - here so anyways it's going to be a pug
635:21 - shipping in you or a saint bernard here
635:23 - we're only going to know what the breed
635:24 - is once the random number is returned
635:27 - and the breed is actually going to
635:28 - govern if it's a pug ship in you or a
635:31 - saint bernard so we technically could
635:34 - actually just get rid
635:36 - of the input parameters for crate
635:38 - collectible since there's going to be no
635:40 - token uri initially created what we
635:42 - could do is we could create a new set
635:44 - token uri function that sets the token
635:47 - uri based on
635:50 - the breed of the dog for the simplicity
635:52 - of this project we're actually just
635:53 - going to create our own set token uri
635:55 - function that we're going to update
635:57 - based off the breed of the dog a
635:59 - challenge for you after we finish this
636:01 - project is to make this even more
636:03 - decentralized and have the fulfill
636:04 - randomness function actually
636:06 - be the one to decide what the token uri
636:09 - is but for now in our fulfill randomness
636:11 - function we're going to skip setting the
636:13 - token uri and we're actually going to
636:15 - call it in a separate function we're
636:17 - going to create our own
636:19 - function called set
636:20 - token uri
636:22 - and we're going to pass it a uin256
636:25 - token id
636:27 - a string
636:28 - memory
636:30 - token uri
636:31 - and we're going to make this a public
636:33 - function once this fulfill randomness
636:35 - function is responded the breed of the
636:37 - dog is going to be set right this token
636:39 - id to breed is going to say hey this
636:41 - token id
636:42 - now is associated with this breed which
636:44 - is going to be pug shiba inu or saint
636:46 - bernard all we want to do then is now
636:48 - that we have the on chain metadata we're
636:50 - just going to reciprocate that with the
636:52 - off chain metadata so we're going to
636:54 - need three token uris for those three
636:57 - dogs we're going to need one for pug
636:59 - ship inu and then obviously saint
637:01 - bernard however we want to make it so
637:03 - that only the owner of the token id can
637:06 - actually be the one to update the token
637:08 - uri
637:09 - so we can use a require function for
637:10 - this we can say require and we're going
637:12 - to use an imported open zeppelin
637:14 - function called is approved or owner
637:20 - message sender
637:23 - token id
637:25 - and we're gonna do comma here
637:27 - erc 721
637:30 - caller
637:31 - is not owner nor approved
637:34 - this is approved or own a function if we
637:37 - go into the erc 721 github for open
637:40 - zeppelin
637:41 - we can find this this function is
637:44 - approved or owner which checks the owner
637:47 - of the erc721 of that token id and it
637:49 - makes it so that only the owner or
637:51 - somebody approved to work with this
637:54 - token id can actually change the token
637:56 - uri so then we're just going to call
637:58 - that function called set token uri of
638:02 - the
638:03 - token id
638:04 - and the token uri now we're actually
638:07 - manually going to be the ones to call
638:08 - this set token uri once the breed has
638:10 - been decided we could of course like i
638:12 - said use a mapping at the top that
638:14 - automatically routes it there but so
638:16 - that we can experiment a little bit more
638:18 - and learn a little bit more about ipfs
638:20 - we're gonna leave it a little bit more
638:21 - general like this and perfect this is
638:24 - pretty much the majority of what we're
638:25 - going to need for our erc 721 contract
638:28 - obviously we still need to work with
638:30 - ipfs and getting our token uri but for
638:32 - the most part this is everything that we
638:34 - need now i do i am going to introduce a
638:36 - new best practice here whenever we
638:38 - update a mapping typically a good best
638:40 - practice is going to actually be to omit
638:42 - an event so let's create an event for
638:45 - each one of these mapping updates we'll
638:47 - call it event
638:50 - requested collectible
638:53 - and we'll do a bytes32
638:55 - indexed
638:58 - request id
639:00 - and we'll also do a
639:03 - address
639:05 - requester this requested collectible
639:08 - event is going to be omitted when we
639:10 - request id to sender because we're
639:12 - updating the mapping here this is also
639:14 - going to be really helpful when we run
639:15 - our tests so we can get this request id
639:17 - similar to what we did with the lottery
639:20 - so down here we're going to do omit
639:22 - requested collectible let's collect
639:25 - dibble here
639:26 - let's use an i instead of an a here
639:30 - collectible
639:31 - and we'll pass it
639:33 - this request id
639:35 - and then message.sender
639:38 - we also update a mapping down here with
639:40 - tokenid to breed
639:42 - so we're going to do a new event
639:45 - we're going to call event
639:48 - breed assigned
639:50 - and we'll do uint256
639:53 - indexed
639:55 - token id
639:58 - and then we'll do a breed
640:00 - breed
640:01 - and then when we assign the breed here
640:05 - we're going to omit
640:07 - breed assigned
640:09 - with
640:10 - new token id
640:13 - and breed
640:15 - so let's see if we did everything right
640:16 - let's do brownie compile
640:18 - looks like we have a quick error here
640:21 - did you mean fee or fee
640:23 - let's
640:24 - do a quick underscore there
640:28 - now let's try to compile
640:32 - much nicer all right great let's move on
640:35 - all right so now let's take a little
640:36 - look-see at our scripts here so we have
640:38 - this deploy and create script which is
640:40 - going to work for our simple collectable
640:42 - so let's go ahead and actually give them
640:44 - both their own folder so we're going to
640:46 - do a new folder
640:47 - we'll call one simple
640:50 - collectible
640:53 - and we'll do another new folder
640:55 - called advanced
640:58 - collectible and we'll grab this original
641:01 - deploy and crate and we'll place it into
641:03 - this simple collectable folder here
641:07 - awesome
641:08 - now if we wanted to run this we would do
641:10 - brownie
641:12 - run scripts
641:13 - simple collectible deploy and create and
641:16 - we can go ahead and test this out on our
641:18 - local ganache here
641:20 - and cool looks like it's working
641:22 - correctly great so now let's create our
641:24 - advanced collectable script and a lot of
641:26 - what we're going to do is going to be
641:28 - the same as this simple one deploy and
641:30 - create so i'm actually going to copy
641:31 - this
641:33 - we're going to create a new file called
641:35 - deploy and create
641:37 - dot pi we're going to paste everything
641:39 - in here but we are going to change a
641:40 - couple things up so let's do a little
641:42 - bit of refactoring first so this opencrl
641:46 - we're going to be accessing in a couple
641:47 - different scripts so we're actually
641:49 - going to take this
641:51 - copy it
641:52 - get rid of it in our deploy and create
641:54 - here
641:55 - and we're going to move it to our
641:56 - helpful scripts
641:58 - and place it under here openc url equals
642:01 - this script right here
642:02 - and now what we do in our simple
642:06 - deploy and create
642:07 - is we're going to do from
642:08 - scripts.helpfulscript
642:10 - import
642:11 - openc url
642:13 - we're going to delete that here
642:17 - so now in this script
642:19 - this openc url is going to come from our
642:22 - helpful scripts which is what we want
642:24 - and we're going to do the same thing for
642:26 - our deploying create for advanced
642:29 - okay great so i've now copied and pasted
642:32 - all the code from deploying create into
642:34 - this deploy and create for our advanced
642:35 - collectable so let's go ahead and modify
642:37 - this now
642:38 - so instead of from brownie import simple
642:40 - collectible we're going to import
642:42 - advanced
642:44 - collectible
642:47 - and we're going to do the same thing
642:49 - down here
642:50 - and i'm just going to go ahead and
642:51 - delete everything
642:53 - before this we're going to change this
642:55 - to advanced
642:58 - collectible
643:00 - and awesome okay this is going to be our
643:02 - starting point and we actually we can
643:03 - even get rid of this sample token uri
643:06 - great so this is going to be our new
643:08 - starting point we've done a little bit
643:09 - of refactoring now openc url is going to
643:12 - be in the helpful scripts we're pulling
643:14 - in advanced collectible instead of
643:16 - simple collectable and the rest applies
643:18 - we're still using our get account to get
643:20 - the account and now we have this
643:22 - advanced collectible equals
643:23 - advancedcollectable.deploy
643:25 - of course
643:27 - our advanced collectable has a different
643:29 - constructor
643:30 - it's got a vrf coordinator a link token
643:33 - a key hash and a fee so we're going to
643:35 - have to add those
643:38 - as the parameters in here we want to
643:39 - work with ringpi for this because the
643:41 - openc marketplace right now for test
643:44 - nets only works with rinkby so that's
643:46 - why we're going to work with ringby here
643:47 - so let's get started and just grab those
643:49 - ringpie addresses first
643:50 - so our advanced collectable needs a vrf
643:53 - coordinator and a link token so if we
643:55 - head over to the chainlink documentation
643:58 - we go to contract addresses for the vrf
644:02 - we can scroll down to
644:04 - rank b
644:05 - we'll grab the vrf coordinator here and
644:07 - same as before
644:10 - we'll jump into our browning config
644:12 - we'll do
644:13 - networks
644:15 - rinkaby
644:17 - and we'll do vrf
644:19 - core did nator
644:20 - we're also going to need the
644:22 - link token here
644:24 - so we'll do link token
644:27 - we need the key hash
644:30 - key hash
644:35 - and we need the fee which is going to be
644:37 - 0.1 link which we can do fee as one one
644:42 - two three four five six seven eight nine
644:43 - ten one two three four five six seven
644:45 - which can be 0.1 you can of course just
644:48 - copy and paste brownie configs over to
644:50 - different projects because
644:52 - because these values are always going to
644:54 - be the same now on our advanced
644:56 - collectable deploy and create we can go
644:57 - ahead and add those variables in here
645:00 - since we're going to be interacting with
645:01 - actual contracts that are on chain and
645:03 - we're going to want to be able to flip
645:04 - back and forth between the mock versions
645:06 - of them we're going to bring back that
645:08 - get contract function that we used
645:09 - before this is the function that's going
645:11 - to be smart enough to know if we need to
645:13 - deploy a mock or just grab from an
645:15 - actual contract i'm going to show a
645:17 - little fast forward of me rebuilding
645:19 - this function but feel free to copy and
645:21 - paste it from our last project now
645:23 - something that we do need to talk about
645:24 - though is our deploy mocks function the
645:27 - syntax here is going to be basically
645:28 - exactly the same however we do need to
645:31 - deploy a couple of mocks so make sure
645:33 - you have these in your deploy marks
645:34 - function
645:35 - specifically we're going to need a mock
645:37 - link token and a mock vrf coordinator
645:40 - and again feel free to just grab these
645:42 - from our last projects
645:54 - and then of course be sure to add your
645:56 - contract to mock dictionary where the
645:58 - link token is mapped to the link token
646:01 - and the vrf coordinator is mapped to the
646:03 - vrf coordinator if you guys look in the
646:05 - github repo there's a couple try catches
646:07 - there that just make it a little bit
646:09 - nicer for error handling
646:10 - but this is basically the entire script
646:13 - so now what we can do we can go back to
646:15 - our advanced collectable deploy and
646:17 - create
646:18 - import this get contract from our
646:21 - helpful scripts
646:23 - and we'll just replace this with get
646:25 - contract
646:26 - vrf coordinator
646:30 - get contract
646:32 - link
646:34 - token and then for key hash and fee
646:38 - since these don't really matter these
646:39 - can be whatever we want and these aren't
646:41 - really contracts
646:43 - we can go back to our config
646:45 - we'll add
646:47 - the development network and we'll just
646:49 - add key hash
646:52 - and fee
646:54 - and again since it's just testing we can
646:56 - just go ahead and make them exactly the
646:58 - same as ring b
647:02 - done a lot of work now let's go ahead
647:04 - and run this on the development network
647:06 - again so we'll do brownie
647:08 - run scripts
647:09 - advanced
647:11 - deploy and create
647:13 - no network so it's going to default to
647:14 - development let's see what happens here
647:17 - and awesome so we can see we actually
647:18 - did a couple of things here
647:20 - so first we deployed this mock link
647:23 - token
647:24 - then we deployed our mock vrf
647:25 - coordinator
647:27 - we finished that and then we deployed
647:30 - our advanced collectible all on a local
647:32 - network so let's go ahead and continue
647:34 - here once we deploy this code we're
647:36 - going to want to fund this contract with
647:39 - some link the reason we're going to want
647:41 - to fund it with some link of course
647:43 - is that we can call the random number i
647:45 - like to have my funding with link also
647:47 - in a function so we'll do fund with link
647:50 - and we'll give an address
647:52 - advancedcollectable.address
647:54 - and let's go ahead and create this
647:56 - function in fastforward we're going to
647:57 - fast forward this as well but feel free
647:59 - to copy and paste your fund with link
648:02 - functions from past projects or if you
648:04 - want to slow this down and follow along
648:06 - feel free to do that too
648:07 - let's go back to our deploy and create
648:09 - we now have this fund with link that
648:11 - we're going to do right here and then
648:13 - all we have to do now
648:14 - is call our create collectable function
648:17 - here so we'll just do advanced
648:18 - collectible
648:20 - dot
648:23 - create collectible
648:25 - of course
648:26 - from
648:28 - account
648:30 - and we'll do
648:32 - creating tx
648:35 - we'll wait one block confirmation
648:39 - and then we'll print
648:45 - your token has been created
648:49 - so we are definitely going to want to
648:51 - test this because we have a number of
648:52 - custom scripts here right
648:55 - so let's go ahead and just do a manual
648:57 - test
648:58 - so we'll do brownie
648:59 - run scripts
649:02 - advanced collectible
649:04 - deploy and create and we'll do it on a
649:06 - development network
649:08 - whoops we got to add ether here sorry
649:11 - about that in the web 3.2 way one ether
649:14 - so let's go ahead and run this script
649:15 - again
649:17 - and all right it looks like everything
649:19 - worked everything was deployed new token
649:21 - has been created
649:23 - great this is fantastic now ideally
649:25 - before we do an integration test we
649:27 - would of course write some tests but i
649:30 - want to teach some things that are
649:32 - easier to demonstrate on an actual test
649:34 - net so we're going to go ahead and
649:35 - deploy this to an actual test dent
649:37 - before we write our tests so we're just
649:39 - going to run the script again
649:41 - and do dash dash network
649:44 - rank b
649:48 - and awesome a new token has been created
649:50 - so what we can do
649:53 - is we can grab the contract address once
649:55 - again
649:57 - we'll paste it into the rank b ether
649:59 - scan
650:00 - and we can see everything in here we can
650:02 - see we've given it a little bit of link
650:05 - we can see our two function calls one is
650:08 - going to be the contract creation one is
650:09 - going to be create collectable
650:11 - our contract has already been auto
650:13 - verified actually because i verified
650:16 - this contract on rank b already and
650:19 - etherscan says ah this bytecode is the
650:22 - exact same of another contract that
650:24 - we've already verified and if we go to
650:25 - read contract and we go to token counter
650:28 - we'll see
650:29 - one token has been created
650:31 - we've actually created our first token
650:34 - now what we can do in our advanced
650:36 - collectable scripts we can create a new
650:38 - script and just call it create
650:39 - collectable
650:42 - dot pi
650:44 - and in here we'll just create a
650:46 - collectable
650:47 - so well all we have to do is we'll do
650:49 - def main per usual
650:51 - we'll have to do from
650:53 - brownie
650:55 - import advanced
650:57 - collectible
651:00 - we'll import accounts from our helpful
651:03 - scripts
651:08 - we'll import
651:10 - fund with link
651:12 - in our main function we'll do account
651:14 - equals get account
651:17 - of course we need to import this as well
651:20 - for my helpful scripts
651:23 - then we'll do
651:24 - advanced
651:27 - collectible
651:29 - equals
651:30 - advanced collectible minus one because
651:32 - we just want to get the most recently
651:33 - deployed we'll fund this contract with
651:36 - link so we'll do advanced
651:37 - collectible.address
651:39 - and we'll also choose an amount here
651:41 - we'll just do web3.2
651:44 - way
651:45 - of 0.1
651:47 - with ether
651:48 - that means we also have to do from web3
651:51 - import
651:52 - web3
651:53 - then
651:54 - we'll do transaction
651:56 - then we'll do
651:59 - creation transaction
652:02 - equals
652:03 - advanced collectible
652:05 - dot create
652:06 - collectible
652:11 - from
652:13 - account
652:15 - we'll do creation transaction dot wait
652:18 - we'll wait one block confirmation
652:21 - and then we'll print
652:23 - collectible
652:25 - created
652:28 - oops sorry i actually don't have to
652:29 - import account here or accounts excuse
652:32 - me
652:33 - and sorry this actually needs to be
652:34 - amount equals excuse me
652:37 - now let's go ahead and run this and what
652:39 - we're going to do
652:40 - is we're going to fund our advanced
652:42 - collectible with link which is 0.1 link
652:45 - and then we're going to create a new nft
652:54 - awesome collectible created so if once
652:56 - again
652:58 - we take this address
653:00 - go back over to etherscan
653:02 - do a quick refresh here
653:04 - we go to our contract read contract
653:10 - we'll look at the token counter it may
653:12 - still be one so you might have to give
653:14 - it a second for the chain link vrf to
653:16 - respond
653:19 - once the chain vrf responds we'll see 2
653:22 - in here we can also check the token id
653:24 - to breed
653:25 - if we look at 0 with 1 we'll see the
653:27 - breed
653:29 - is 2.
653:30 - and if we look back at our contract
653:33 - the advanced collectible without soul we
653:35 - know that if the breed is two that means
653:37 - it's a saint bernard
653:39 - see the token id of one
653:42 - it has a breed of one so it got randomly
653:44 - assigned a shiva inu
653:46 - awesome so we have tokens and they're
653:48 - get randomly assigned breeds fantastic
653:51 - as you can see we're doing kind of a lot
653:52 - of manual testing work here right so
653:55 - what we're probably going to want to do
653:56 - instead is you guessed it automate these
654:00 - tests
654:01 - now go ahead and want to deploy dance
654:03 - import that deploy script that we just
654:05 - wrote
654:06 - so we would do
654:08 - from scripts
654:10 - dot advanced collectible
654:12 - dot deploy and create
654:14 - import deploy and create
654:18 - and then all we have to do is call
654:21 - deploy and create
654:24 - in this function we'd probably want to
654:26 - then return the advanced collectible
654:28 - contract so we can make sure that we
654:30 - actually get what we want here
654:32 - so we'll say advanced collectible
654:35 - equals deploy and create
654:38 - and that'll be our acting
654:41 - step
654:42 - beginning we'll do arrange
654:46 - then we'll do an assert
654:47 - of
654:50 - we'll just check to see
654:51 - that the token counter has been
654:53 - increased we'll do assert
654:55 - advanced collectible
654:58 - the token counter
654:59 - is equal to one all right great so this
655:02 - will return our advanced collectable
655:04 - however we know that since we're
655:05 - actually going to be working with a mock
655:07 - vref coordinator if we look at our
655:09 - advanced collectible
655:11 - we know that the bulk of the work
655:13 - actually comes in this fulfill
655:14 - randomness function and we're going to
655:16 - have to tell our mock to actually return
655:18 - and call this function so in order to do
655:21 - that we should probably also return this
655:23 - creating transaction here so that we can
655:25 - get the request id remember how in our
655:27 - lottery we actually just directly called
655:29 - everything
655:30 - and we needed this request id to call
655:32 - this callback with randomness function
655:35 - in our test here we're actually using
655:36 - our scripts a little bit so we could
655:38 - either just go ahead and write out all
655:40 - the steps similar to what we did in the
655:42 - lottery or we could adjust our scripts a
655:44 - little bit for simplicity here we're
655:46 - just going to go ahead and have this
655:48 - deploy and create function also return
655:50 - the creating transaction this way we can
655:52 - go ahead and get the request id so back
655:55 - in our test here that means we have to
655:56 - do deploy and create
655:58 - equals advanced collectible and
656:02 - creation
656:05 - transaction now that we have this
656:07 - creation transaction we can use it to
656:09 - get our events
656:10 - and again if we look back in our
656:12 - advanced collectible we can see here
656:15 - that we're omitting this requested
656:16 - collectible with request id so we can go
656:19 - and do request id
656:22 - equals creation transaction dot events
656:28 - we'll add the name
656:32 - of our event here which is requested
656:33 - collectible and then we'll get
656:36 - that request id once we have this
656:38 - request id we can then go ahead and grab
656:41 - the vrf coordinator so from our scripts
656:44 - we'll grab this get contract
656:46 - and we've coded our get contract in a
656:48 - way that if the mock has already been
656:50 - deployed again if we go back to our
656:52 - helpful scripts if the contract has
656:55 - already been deployed then we're just
656:57 - going to go ahead and grab it so since
656:59 - here our mock will have already been
657:00 - deployed so we don't have to redeploy it
657:02 - so we can just do get contract
657:06 - vrf
657:07 - core did nator
657:10 - dot call back
657:14 - with
657:15 - randomness
657:17 - and we'll use the request id
657:20 - we'll pick some number like 777 we'll
657:23 - give it to
657:26 - the address of our advanced collectible
657:30 - and remember we're going to be calling
657:32 - the callback with randomness this is
657:34 - what a real chain link node is actually
657:35 - going to call back and it just needs a
657:37 - request id a randomness number and a
657:39 - consumer contract
657:41 - so request id random number and then the
657:44 - consumer contract
657:46 - and then of course we have to do a from
657:49 - account
657:51 - from get account
657:55 - and we'll import get account as well
657:59 - now we can move into our cert phase
658:02 - so first if this is correct then our
658:05 - token counter
658:07 - should be at least one so we can assert
658:11 - advanced collectible
658:12 - dot token counter
658:14 - is greater than zero
658:17 - or we could be a little bit more
658:18 - specific here
658:20 - equals equals
658:21 - one we also should technically be able
658:23 - to get the breed and figure out the
658:25 - breed of this first token of this first
658:28 - collectible let's go ahead and
658:30 - parameterize the 777 we'll call it
658:33 - random number
658:34 - equals 777.
658:36 - we'll place that here
658:39 - and then what we can do is we can say
658:41 - certain
658:44 - collectible
658:45 - dot token id
658:47 - to breed
658:49 - of zero
658:50 - right in our fulfill randomness we're
658:52 - going to assign the token id
658:54 - to being the breed and the breed is
658:56 - going to be this random number mod 3.
658:59 - so on our test we can say
659:01 - the token id to breed of dog 0 is going
659:04 - to be equal to
659:06 - random number
659:08 - mod
659:09 - 3 and this is pretty much our full test
659:12 - so let's go ahead and run this
659:17 - we can do that test with dash k
659:19 - whoops it looks like our simple test has
659:21 - actually got an error now we're getting
659:23 - this module not found no module named
659:26 - scripts.deploy.create
659:28 - this now since we actually changed it
659:30 - it's going to be
659:34 - scripts.simplecollectable.deploy and
659:35 - create
659:37 - so now if we rerun our test
659:39 - we'll see brownie isn't going to err out
659:41 - anymore
659:42 - so even though we skipped this test
659:44 - brownie still compiles it to make sure
659:46 - that everything makes sense but what we
659:48 - see here is fantastic our advanced
659:50 - collectible unit test has worked
659:52 - perfectly let's go ahead and make an
659:54 - integration test for our advanced
659:56 - collectible here so now we'll have our
659:58 - test folder here and we'll have unit and
660:00 - we'll have integration
660:02 - our integration test is actually going
660:04 - to look really similar to our advanced
660:06 - collectable here so i'm just going to go
660:07 - ahead and copy everything new file
660:10 - test
660:11 - advanced
660:13 - collectible
660:15 - integration
660:17 - pi
660:19 - and we'll just paste everything in here
660:20 - now the only thing that we're going to
660:21 - have to change is that we're not going
660:23 - to be the ones to call back with
660:24 - randomness here
660:26 - so we can remove this part
660:28 - we also don't need the request id
660:30 - anymore since the chain link node is
660:31 - going to be responding this means that
660:33 - the breed that we're going to get is
660:34 - actually going to be random so we can
660:36 - get rid of that assert as well all we
660:38 - need to do is wait for the transaction
660:41 - to get called back
660:42 - so we're going to import time
660:44 - and instead of us calling back with
660:46 - randomness
660:48 - we're just going to do
660:50 - time dot sleep
660:54 - then we'll wait 60 seconds
660:56 - test can create collectible we should
660:58 - also give this a different name
661:03 - integration
661:04 - now we should be able to test this on a
661:06 - ring b chain and our token counter
661:08 - should indeed increase with the chain
661:10 - link node actually responding so now we
661:12 - can run brownie test dash k
661:16 - just that test dash dash network
661:20 - rink b
661:22 - oh whoops right now we're skipping this
661:24 - because we're saying only for local
661:25 - testing now since this is going to be
661:28 - our integration test we're going to do
661:29 - the opposite
661:30 - if network.showactive is in these local
661:33 - blockchain environments then we're going
661:35 - to skip it and say only for
661:37 - integration testing
661:39 - all right great so now we have a quick
661:41 - and dirty integration test that we can
661:43 - run we're not going to run it for now
661:44 - because we're going to be working a lot
661:46 - with this rigby chain and we're going to
661:47 - be deploying a lot of different things
661:49 - and we don't want to wait so long so
661:51 - this is fantastic we have a way to
661:52 - deploy this we have a way to get these
661:54 - new collectible tokens and create them
661:57 - but if we were to take this address
661:58 - right now and try to view this token on
662:00 - something like openc
662:02 - we would get nothing back we wouldn't
662:03 - get any result right now our token
662:05 - doesn't have a way to be viewed or be
662:08 - visible by everybody else these mt
662:10 - platforms don't know what they look like
662:12 - and again this is where that set token
662:15 - uri is going to come into play
662:17 - so we have to figure out a way to host
662:19 - an image and host all the metadata for
662:22 - our token uri
662:23 - and the way that we're going to do this
662:25 - is by using
662:26 - ipfs and this is a lot better than
662:28 - actually hosting this on our own server
662:31 - because anybody can then go ahead and
662:33 - host this image or this metadata
662:35 - themselves
662:37 - now there's further improvements to this
662:38 - with something like filecoin
662:40 - where you actually pay to have your
662:42 - image hosted forever however ipfs can
662:44 - hook into filecoin in the future and is
662:46 - going to be a good enough solution for
662:48 - what we're looking to do here
662:49 - just keep in mind that what we do not
662:52 - want to do is run this on a centralized
662:54 - server when we spin up our ipfs node we
662:57 - will be the only node that actually runs
663:00 - and actually hosts our image however the
663:02 - image is open for anyone to pin to their
663:05 - nodes as well
663:06 - so it's much easier for us to host our
663:08 - images in a decentralized manner what's
663:11 - bad obviously is if we just had the
663:13 - image stored on our own centralized
663:14 - server because if our server goes down
663:17 - then that url no longer exists if at
663:19 - least one node on the ipfs network is
663:22 - hosting this image it will be available
663:24 - for anybody to see so that's why it's
663:26 - going to be a much better solution than
663:28 - some centralized server as i mentioned
663:30 - decentralized storage is a topic that's
663:32 - getting better and better and we're
663:33 - looking forward to seeing more and more
663:35 - ways to interact with them in any case
663:37 - we need to create an ipfs node that's
663:39 - going to host some data that looks like
663:41 - this or like what we saw with our simple
663:43 - collectable
663:45 - it needs to host metadata that will look
663:47 - like this we both have to host a
663:49 - metadata file and an image uri file
663:52 - which will host the actual image
663:54 - both of these need to be stored on ipfs
663:57 - so let's go ahead and create a new
663:58 - script called
664:00 - create
664:03 - metadata
664:04 - which will read off chain and create our
664:07 - metadata file so we'll start our scripts
664:09 - per usual
664:10 - with def main
664:17 - and we'll get the most recently deployed
664:19 - advanced collectible
664:24 - using this -1 syntax
664:26 - of course we're going to do from
664:29 - browning
664:30 - import
664:33 - advanced
664:34 - collectible once we have this advanced
664:37 - collectible we can then loop through all
664:39 - of the tokens and actually figure out
664:42 - the metadata for each one of them so
664:44 - we'll do
664:45 - number
664:46 - of advanced
664:50 - collect
664:52 - bowls
664:54 - equals
664:55 - advanced collectible.tokencounter
664:58 - because we want this crate metadata to
665:00 - create the metadata for every single
665:02 - token that we've created do a quick
665:04 - print line here just saying print
665:06 - you
665:07 - have created
665:12 - number of collectibles
665:14 - collectibles
665:17 - we even run this really quick brownie
665:19 - run scripts
665:21 - advanced
665:22 - create metadata
665:25 - network rank b since we've already run
665:27 - this on the ringpi chain
665:29 - we'll see you've created one collectible
665:31 - if i were to run our create collectable
665:33 - script again and then our create
665:35 - metadata script would of course get more
665:37 - but right now we only have one
665:38 - collectible
665:39 - now let's loop through all these
665:41 - collectables and create their metadata
665:43 - so we're going to create that that file
665:45 - it looks like this and it's going to
665:46 - have it's going to have the name which
665:48 - is going to be based off of the random
665:49 - breed that i got it's going to have the
665:50 - description which is based off of again
665:53 - the random breed that i got it's going
665:54 - to have an image which will also be
665:56 - based on the random breed that it got
665:58 - and i just put some attributes in here
666:00 - but again these attributes so we're
666:02 - going to say for each token id
666:06 - in the range
666:10 - of number of advanced collectibles
666:14 - for each one of these advanced
666:15 - collectibles
666:17 - first we need to get the breed so we're
666:18 - going to say the breed the breed is
666:20 - going to be equal to advanced
666:21 - collectible dot token id
666:24 - to breed
666:26 - of the token id
666:29 - now advanced collectible that token id
666:31 - to breed this is going to return an
666:33 - integer right because again our advanced
666:35 - collectible
666:36 - this enum breed is going to be 0 one or
666:39 - two so we actually want to create a
666:42 - quick mapping that represents that zero
666:44 - is pug one is shipped in u and two is
666:46 - saint bernard so i actually like to
666:48 - create this in a helpful script
666:51 - called def get breed
666:55 - and then it takes as an input it takes a
666:56 - breed
666:59 - number
667:00 - and it uses a switch statement so up top
667:03 - we'll say
667:07 - breed mapping
667:09 - equals
667:11 - zero is going to be pug
667:16 - one is going to be
667:18 - shiba inu
667:21 - and two
667:22 - is going to be saint bernard
667:26 - so in this get breed function now
667:29 - we can just do return
667:30 - breed mapping
667:33 - of that breed number that we get
667:36 - so
667:37 - instead of doing advanced collectible
667:38 - the token id to breed we can now just do
667:43 - get breed
667:45 - and this will this will return the
667:47 - number and this will return the actual
667:49 - string so we can just do from scripts
667:54 - dot helpful scripts import get
667:57 - read
667:58 - now that we have the breed we can start
668:00 - creating this metadata file now what
668:03 - we're going to want to do is we're going
668:04 - to want to have some type of format for
668:06 - our contract to always pull from so what
668:08 - i like to do here is i'll create a new
668:11 - folder
668:12 - called metadata
668:15 - and in this folder
668:17 - i'll have a new file
668:24 - called samplemetadata.pi
668:26 - and then i just have metadata
668:29 - template
668:30 - equals and i'll just have this this
668:33 - template that we're always going to use
668:35 - now in here we're going to need a name
668:38 - and then
668:39 - we're going to leave the name blank
668:41 - because we're going to want to fix it
668:42 - later
668:43 - we're going to have a
668:44 - description which we're also going to
668:46 - leave blank for now
668:48 - we're going to have that image uri which
668:51 - will also leave blank
668:52 - and then we're going to have some
668:54 - attributes which should be blank for
668:56 - this dog because we don't actually have
668:58 - any on-chain attributes but i'm just
669:00 - going to go ahead and add some to show
669:02 - you what you could do if you wanted to
669:04 - give your dog some stats you know maybe
669:06 - maybe cuteness maybe
669:08 - maybe raw power maybe speed agility you
669:10 - know whatever you want to do so we'll do
669:12 - trait
669:14 - type
669:15 - gonna be cuteness
669:17 - and then
669:18 - value is gonna be 100. this would
669:21 - basically say hey there's a trait type
669:23 - called cuteness and the value of that is
669:25 - a hundred so the cuteness of the dog is
669:27 - 100. so now once we have this sample
669:30 - metadata file we can import this into
669:32 - our script here so we'll say from
669:35 - metadata
669:37 - dot sample metadata
669:39 - import
669:41 - metadata template
669:43 - and another quick note you might have to
669:45 - put a underscore underscore init
669:47 - underscore underscore dot pi file in
669:49 - that metadata folder
669:51 - if you're working on older versions of
669:52 - python and we start creating our new
669:55 - metadata file for this break for this
669:57 - dog we want to save each collectible
670:00 - under their network and with their token
670:02 - id so let's go ahead and create a new
670:03 - folder
670:05 - call it rink b and this is where we'll
670:07 - save all of the rink b metadata for all
670:09 - these collectables for all these token
670:11 - ids now before we actually save it
670:13 - though we should just check to make sure
670:15 - that the file doesn't already exist
670:17 - right because if the file already exists
670:19 - that means we've already created the
670:20 - metadata for that token and we don't
670:22 - need to
670:23 - so we can just go ahead and get the
670:24 - metadata
670:26 - file name
670:28 - which is going to be equal to
670:31 - dot slash metadata
670:35 - slash network dot show active
670:39 - of course this means we need to import
670:42 - network from brownie
670:43 - slash
670:47 - the token id
670:50 - token id with a hyphen
670:53 - with the breed
670:56 - dot json
670:57 - just to make sure we're doing this right
670:58 - we can even just print this out
671:01 - do a quick manual test
671:04 - brownie run scripts
671:07 - advanced
671:09 - create metadata
671:11 - network rink b
671:13 - so this will be the name of the file so
671:15 - metadata rink b
671:17 - token id and then the
671:18 - breed.json okay cool now we can actually
671:21 - check this to see if this already exists
671:23 - and we're going to use a python library
671:25 - called path so we're going to say from
671:28 - pathlib
671:29 - import path
671:31 - and we're going to say if that path
671:34 - this metadata file name
671:36 - dot exists
671:38 - if that path exists
671:40 - we'll do a quick print saying
671:43 - metadata file name
671:45 - already
671:47 - exists
671:50 - delete it to overwrite
671:52 - this way we won't accidentally overwrite
671:54 - metadata that we've already created and
671:55 - do extra work so if it exists we'll
671:58 - print that out great otherwise
672:02 - we can go ahead and print
672:06 - print def
672:08 - creating metadata file
672:13 - metadata file name
672:16 - you can even run this real quick
672:21 - great you have one collectible
672:23 - creating metadata file perfect
672:26 - so let's go ahead and start creating
672:27 - this metadata file so we're have to give
672:29 - it a name description
672:31 - image uri and we're not gonna give it
672:33 - any attributes though so just name
672:35 - description and image uri so name is
672:37 - easy enough since this is a dictionary
672:40 - or a mapping in python we can actually
672:42 - just go ahead and start mapping so up
672:44 - above before this if
672:46 - we'll do
672:47 - collectible
672:49 - metadata it's going to be equal to
672:53 - this template
672:54 - so this is going to be where all we sort
672:56 - all of our metadata and we'll say
672:58 - collectible metadata of name
673:00 - is just going to be the breed so if it's
673:02 - a pug the name will be pog if it's
673:04 - shipped in you name it will be shipped
673:05 - in you if it's st bernard name will be
673:07 - saint bernard and we'll give it
673:10 - collection metadata
673:12 - description
673:16 - is going to be equal to
673:19 - we're going to do an f string here
673:21 - and adorable
673:24 - breed
673:27 - pop
673:30 - now if we print out this collectible
673:31 - metadata we should see
673:37 - at least the start of the metadata which
673:39 - we do great name saint bernard
673:42 - description and adorable saint bernard
673:44 - pup of course you'll have a different
673:45 - random breed but it should look
673:47 - something like this
673:48 - now we're going to need
673:50 - collectible metadata
673:53 - image uri
673:54 - this is where we're going to have to
673:55 - have our image already uploaded to ipfs
673:58 - so we can assign it to our metadata here
674:00 - so how are we going to do this well
674:02 - we're probably going to need some upload
674:04 - to ipfs function it's going to return
674:07 - our image uri and then we can just set
674:10 - that image uri to the collectible
674:12 - metadata
674:14 - of image
674:16 - so let's go ahead and start doing that
674:18 - let's create
674:19 - our upload to ipfs function now in order
674:23 - to upload to ipfs we of course need to
674:25 - have the images ourselves i already have
674:27 - them downloaded here and again you can
674:29 - download them right from the github
674:30 - yourselves if you like to make this a
674:32 - little bit generic we'll have this
674:34 - upload to ipfs take a file path
674:36 - that way we can pass
674:38 - this imagery upload to ipfs we're going
674:41 - to give it some type of file path here
674:43 - we're going to have to grab that image
674:44 - path so we'll grab that image file name
674:48 - by just doing breed
674:53 - dot lower
674:57 - because right now our breeds are all
674:59 - upper case so we're going to want to
675:01 - make a lower case then we're going to
675:02 - replace
675:05 - the underscores with
675:07 - hyphens
675:08 - dot png
675:12 - so we'll say plus
675:15 - dot png
675:16 - and then you know let's just go ahead
675:18 - and add the full path here so we'll say
675:21 - dot slash image
675:23 - slash
675:25 - plus
675:26 - 3. lower perfect
675:29 - so and then we'll even change this
675:30 - to image path and then we can pass this
675:35 - to our upload to ipfs so this file path
675:38 - now is going to be the location of the
675:40 - object that we're going to upload to
675:41 - ipfs we're going to use this path
675:43 - library to actually grab that path to
675:45 - upload it to ipfs so we're going to say
675:47 - with path
675:50 - file path
675:51 - dot open
675:53 - rb
675:54 - as file path
675:56 - now this is a little bit of
675:57 - sophisticated python here what we're
675:59 - doing is we're taking this path here
676:02 - we're opening the file rb means we're
676:05 - going to open it in binary since these
676:07 - are images that's how we're going to
676:08 - actually
676:09 - open it and we're going to upload the
676:10 - binary actually to ipfs and then as fat
676:13 - fp so we're saying this opened file
676:16 - is going to be named fp or file path
676:19 - we're going to do image
676:21 - binary
676:22 - equals fp.read
676:24 - and that's how we actually read the
676:26 - whole binary and now this whole image is
676:28 - stored as binary in this image binary
676:30 - here now here's where we're going to do
676:33 - the upload stuff now to get started here
676:36 - we're actually going to have to download
676:37 - the command line for ipfs download
676:41 - command line ipfs
676:44 - we'll come right to the docs here and
676:46 - again there's going to be a link
676:48 - in that github and in here there are
676:49 - instructions to
676:51 - to download it for whatever system that
676:53 - you're working on right if you're
676:54 - working on windows if you're on linux if
676:56 - you're on mac these are the different
676:58 - ways to actually download this ipfs
677:00 - command line you'll know you've done it
677:01 - right if you can type ipfs
677:04 - version and you see something like ipfs
677:06 - version 0.9.0 it's important to note
677:09 - that we could also do the ipfs download
677:12 - desktop
677:13 - and we could download the desktop
677:14 - version of this and we'd see a user
677:16 - interface which looks something like
677:18 - this we could upload our files manually
677:20 - and then manually go ahead and
677:22 - grab those files and place it into our
677:24 - scripts but we're engineers we want to
677:26 - do this programmatically in any case
677:28 - once we have this api downloaded we can
677:30 - actually follow the documentation here
677:33 - the http api reference for actually
677:35 - uploading our code we're going to be
677:37 - mainly working with this endpoint api v0
677:41 - slash add as this is the endpoint that's
677:42 - actually going to add our file or
677:44 - directory to ipfs now what we're going
677:47 - to want to do is we're going to actually
677:48 - upload our images to our own ipfs node
677:51 - we can run our own ips node by doing
677:53 - ipfs
677:56 - daemon and we'll see an output that
677:58 - looks something like this we can even
678:00 - see a web ui using this web ui url here
678:03 - this will look similar to what the ipfs
678:06 - desktop looks like but again we're going
678:08 - to work just mainly from this damien
678:10 - from our own ips note congratulations
678:12 - you're running your own ipf's node right
678:14 - now as you can see it's currently
678:16 - running on our own localhost right here
678:18 - http 127 0.0.1 at port 5001. so to
678:24 - actually upload this we're we first need
678:26 - to get that ipfs url
678:31 - which is going to be equal to
678:33 - this url right here
678:35 - paste
678:37 - now we want to make an api call or a
678:39 - post request to this
678:42 - endpoint
678:43 - using
678:44 - this
678:45 - api v0 ad and these are all the
678:47 - different parameters that this ad
678:50 - can actually take in
678:51 - so that we can actually post it to ipfs
678:54 - for those of you familiar with curl and
678:55 - you want to test this out using a curl
678:57 - i've added a curl into this create
678:59 - metadata file as a comment so that you
679:02 - can actually go ahead and test this if
679:03 - you want to use this now what we're
679:04 - going to want to do to keep working with
679:06 - our scripts
679:07 - is you should have like a little plus
679:09 - button somewhere on your vs code
679:11 - we're going to hit that plus button
679:13 - and now we're actually going to have two
679:14 - different shells one which is running
679:16 - our ipfs node
679:18 - and one which is running our bash or zch
679:20 - or whatever other shell that your os
679:23 - natively works with now that we have
679:24 - this ipfs url we're going to grab the
679:27 - endpoint
679:28 - which is going to be
679:30 - again this right here
679:34 - dash api dash v0 add
679:37 - and we can make a post request to it so
679:40 - for us to do that we're going to say
679:41 - response equals requests dot post
679:45 - we're gonna do the ipfs url
679:48 - plus the endpoint and we're gonna say
679:50 - the files that we're gonna upload
679:53 - is gonna be equal to
679:54 - file
679:56 - image binary
679:59 - requests is a python package that we're
680:00 - going to import so we're going to say
680:02 - import requests
680:04 - now if we go back to the ipfs
680:06 - documentation we can scroll down to see
680:08 - what the response looks like
680:10 - it's going to return a bytes
680:12 - a hash
680:13 - a name
680:14 - and a size
680:16 - now if we look at this sample
680:18 - token uri we can see the api call here
680:21 - ipfs stores all its data using a hash
680:24 - and if we're looking at this and if
680:26 - we're looking at the simple collectible
680:28 - this hash here
680:30 - is the hash that represents this
680:32 - pug.json file everything in ipfs gets
680:35 - hashed and every single piece of data
680:37 - has a unique hash which is why it's so
680:40 - fantastic if we were to change anything
680:42 - with this image this hash would be
680:44 - drastically different all we need to do
680:47 - is get the hash that ipfs gives the
680:49 - image that we upload we go ahead and
680:51 - plug it into a template url like this
680:53 - one here so what we're going to do then
680:55 - is we're going to say ipfsh
680:57 - it's going to be equal to
680:59 - this response.json
681:02 - since
681:03 - we're just going to jsonify the response
681:05 - to make it look like this response here
681:07 - and we're going to grab
681:10 - that hash
681:11 - right since it's going to return this
681:12 - dictionary
681:14 - we just want the hash here
681:16 - then
681:17 - we're going to give it a file name
681:20 - by saying it's going to be that file
681:22 - path
681:23 - dot split we're going to do some fancy
681:26 - python stuff here we're going to say -1
681:30 - to 0
681:32 - which basically all this line is doing
681:34 - is saying you know if we have dot slash
681:38 - image slash pug
681:40 - dot png
681:42 - we're going to remove
681:45 - we're going to split it up by these
681:46 - slashes
681:48 - into an array and we're going to grab
681:51 - the last part of the array so we're
681:53 - basically just
681:54 - changing this to this with this line
681:56 - right here then with this we can get the
681:58 - image uri which is going to be equal to
682:01 - an f string again
682:03 - https
682:05 - ipfs.io
682:07 - ipfs
682:09 - slash
682:11 - ipfshash
682:12 - question mark file name
682:15 - equals
682:18 - file name
682:19 - and it's this format right here which
682:22 - will give us
682:23 - this
682:26 - so if i go ahead and even just copy
682:28 - paste this under as a comment to show
682:29 - you guys
682:32 - we see this part's exactly the same
682:34 - and then this is that hash here
682:36 - represented here
682:38 - and then we have question mark file name
682:40 - equals
682:41 - and then the file name
682:43 - so excuse me this is actually gonna be
682:44 - like
682:45 - zero hyphen pug
682:47 - zero hyphen pod and that's exactly what
682:49 - we need we need this image uri so we'll
682:52 - do a quick print
682:54 - image
682:56 - image uri
682:58 - and then we'll go ahead and return
683:01 - the image
683:02 - uri
683:04 - now since we're actually going to be
683:06 - testing this with
683:07 - ipfs we can add a new integration test
683:10 - so we'll call this test
683:12 - ipfs
683:14 - upload.pi
683:16 - now you might want to write a test for
683:17 - this and we're not going to do one but i
683:20 - challenge you to later on maybe come
683:22 - back and and write your own test for
683:24 - this upload to ipfs
683:26 - for now we're actually just going to
683:27 - manually test it
683:29 - so we're going to go back up to our
683:30 - script here and we're going to run image
683:32 - uri equals upload to ipfs image path
683:36 - and then we're going to get printed in
683:37 - image url since we're working with the
683:39 - saint bernard here we should get a saint
683:42 - bernard image uri
683:44 - so if i run brownie
683:46 - run scripts
683:48 - advance
683:50 - create metadata
683:56 - network rink b
683:59 - let's see what happens i need to add
684:01 - brackets here sorry about that
684:03 - now let's try it again
684:05 - awesome we were able to create this
684:07 - metadata file
684:08 - now if we go ahead and copy this
684:11 - and paste it
684:13 - perfect we see exactly what we're
684:15 - looking for we see our saint bernard
684:17 - awesome job and this has been uploaded
684:19 - to our own ipfs node now i want to show
684:22 - you guys actually another service and
684:23 - another way we can actually upload these
684:25 - to ipfs some people don't want to run
684:27 - their own ipfs node because they're not
684:29 - actually going to be keeping it running
684:31 - the whole time anytime their node goes
684:33 - down this means that nobody will be able
684:36 - to see your image unless somebody else
684:38 - pins your image or or uses your image so
684:41 - what i also like to do is i like to
684:43 - upload it to some other third-party
684:45 - service as well as uploading it to my
684:48 - own ipfs note so i like to create
684:50 - another script actually called
684:52 - deploy to pinata
684:54 - so let's go to scripts new file
684:58 - upload to
685:00 - pinata.pi
685:02 - so pinata
685:03 - pinata is an ipfs file management
685:06 - service and they actually will pin
685:08 - whatever files that we're working with
685:09 - as well so we'll have it pinned in our
685:11 - node and they will have it pinned as
685:13 - well so we can go ahead and register
685:19 - awesome this is what pinata looks like
685:22 - it's a way to upload and work with ipfs
685:26 - and they'll give us some extra support
685:27 - and they have a free tier which is
685:29 - fantastic as well they have some
685:31 - wonderful documentation as well under
685:32 - this documentation section so let's go
685:35 - ahead and upload this to ipfs so that
685:37 - when our node goes down our images don't
685:39 - go down so we'll do pinata
685:42 - base
685:44 - url
685:45 - is going to be equal to
685:48 - https dash dash api.pinata.cloud
685:53 - you can find all this in the
685:54 - documentation as well if we scroll down
685:57 - the documentation we're going to be
685:58 - using this pin file to ipfs endpoint
686:01 - here and you can see that entire
686:03 - endpoint right here
686:05 - with the base and then the endpoint so
686:07 - we're going to copy that endpoint
686:09 - we're going to say endpoint
686:11 - equals
686:12 - pinning
686:13 - pin file to ipfs we're going to choose
686:16 - some file path
686:19 - and for us we're just going to do dot
686:21 - slash image
686:23 - slash
686:24 - pug.png
686:26 - of course if you want to upload some
686:27 - other image you can you know change this
686:29 - file path or you could even do some type
686:32 - of for loop to pin everything uh in the
686:35 - image section here again we're going to
686:37 - do file name we're going to use that
686:38 - same syntax before that's
686:41 - we're doing file path
686:43 - dot split
686:45 - slash
686:47 - some fancy python stuff
686:50 - just to get
686:51 - this last part and we also need and we
686:54 - need to use some headers in this post
686:56 - request so it's a type post request we
686:59 - need to use some headers here so we're
687:00 - going to say headers
687:02 - equals
687:05 - copy this pinata api key
687:08 - which is going to be some api key and
687:10 - then we also have this pinata secret api
687:13 - key pinata secret api key
687:16 - which is going to be something else
687:18 - we can find these two api keys if we
687:20 - scroll all the way down we hit api keys
687:23 - create a new api key
687:26 - i'm going to call this you can make this
687:28 - an admin key i'm just going to do limit
687:29 - max users
687:31 - limit max uses i'm going to set this to
687:33 - 200
687:34 - because i'm going to make this a public
687:36 - key so i don't want people using this a
687:38 - million times
687:39 - please make sure you select at least one
687:41 - permission
687:43 - pin file to ipvs for those of you guys
687:45 - watching you can absolutely just grab
687:47 - all these if you want you can make this
687:49 - an admin you know do whatever you want
687:51 - to do here since i'm only going to be
687:53 - using this pin file to ipfs that's all
687:54 - i'm going to do
687:56 - hit create key and here are our tokens
687:59 - here so our api key is going to be right
688:01 - here and we're going to copy that
688:03 - we're going to open back up that dot env
688:07 - and add this as one of our environment
688:09 - variables here so we're going to export
688:11 - pinata
688:12 - api key
688:14 - equal to that key there
688:16 - this api secret we're going to copy and
688:19 - we're going to export pinata api secret
688:24 - equals that key there
688:26 - and we actually don't need this
688:28 - jwt but if you guys wanted to you could
688:30 - copy it as well
688:31 - so now that we have them in our dot env
688:33 - file these are now going to be
688:35 - environment variables that we can use
688:37 - and brownie's going to automatically put
688:39 - them into our
688:40 - environment
688:41 - so what we can do then is we can do os
688:45 - dot get env
688:48 - pinata
688:51 - api key
688:53 - and then of course we're going to import
688:58 - import os
689:00 - and then
689:05 - for our secret key we're going to do the
689:07 - same thing os dot get env
689:11 - pinata api secret
689:15 - this is how we get those two headers for
689:17 - uploading to pinata then we're going to
689:19 - do a lot of the same code we did before
689:21 - we're going to say with path
689:23 - a file path dot open
689:26 - rb for the binary as fp
689:29 - of course since we're using path we're
689:30 - going to do from path lib
689:34 - import
689:36 - path
689:38 - we're going to do this same piece image
689:39 - binary
689:41 - equals fp.read
689:44 - response is going to be equal to
689:46 - requests which we have to import
689:48 - requests
689:50 - import requests
689:53 - dot post
689:56 - pin you have a base url
689:57 - plus that endpoint that we have
690:00 - and for files
690:02 - oops
690:04 - it's going to be equal to
690:07 - file
690:09 - and we're going to upload a couple of
690:10 - things here though we're going to give
690:11 - it a file name
690:13 - we're going to do the image binary and
690:15 - that is getting really annoying when it
690:16 - keeps getting in the way
690:18 - file name image binary
690:21 - and then outside of these brackets here
690:22 - we're going to do comma
690:24 - headers equals
690:28 - equals headers
690:30 - and then we're just going to print
690:35 - response.json so to have this run in
690:37 - browning we're just going to do a def
690:38 - main function here
690:40 - a nice little trick we can do is we can
690:42 - select all this text and just hit tab
690:45 - and it'll move it over one
690:47 - and perfect we can now run this inside
690:49 - of brownie
690:51 - so we can do brownie
690:53 - run scripts
690:54 - upload to pinata
690:56 - and perfect we get a little output
690:58 - that's going to look something like this
690:59 - it's going to give our ipfs hash the pin
691:01 - size the timestamp
691:03 - so now if we go back to pinata
691:06 - we go to pin manager
691:09 - do a little refresh here
691:11 - we now see
691:12 - our pug has actually been uploaded to
691:15 - pinata awesome work we're going to keep
691:16 - going using the ipfs daemon to actually
691:19 - upload things but if you want you could
691:20 - totally swap out this upload to ipfs to
691:23 - use that script that we just created to
691:25 - upload it via pinata instead of our own
691:27 - ipfs node anyways this upload to ipfs is
691:31 - going to return this image uri so we can
691:33 - go ahead then
691:35 - and set the image uri it's going to be
691:37 - set on this collectible metadata image
691:40 - and then all we have to do is dump this
691:43 - collectible metadata into its own file
691:45 - and then upload that as well to ipfs
691:48 - we'll dump this to its own file by doing
691:49 - with
691:51 - open
691:52 - metadata file name
691:54 - and we
691:55 - open it with a w which means that we're
691:57 - going to write
691:58 - as file
692:00 - json.dump
692:02 - collectable metadata to the file
692:05 - so we're going to import json to do this
692:08 - and what this is going to do is just
692:10 - going to dump this dictionary as json to
692:13 - this collectable metadata file then we
692:15 - can upload to ipfs also
692:17 - this metadata file name and this upload
692:19 - to ipfs should print out the image uri
692:22 - or in this case the metadata uri so
692:25 - let's go ahead and try this out
692:27 - so remember we do need our ipfs daemon
692:30 - running
692:31 - let's go back to our scripts and we'll
692:33 - do brownie
692:35 - run scripts
692:37 - advanced
692:38 - create metadata
692:40 - network
692:41 - rank b
692:42 - and boom okay so here is our image uri
692:47 - which we click this will be able to see
692:49 - looks just like this
692:51 - and then here is our uploaded
692:54 - saint bernard metadata file which is
692:57 - fantastic so now we have both a metadata
693:00 - file
693:01 - and we have an image uri
693:04 - this is fantastic we've uploaded both of
693:07 - these
693:07 - to our ipfs
693:09 - and if we scroll over
693:11 - go to our metadata file in ring b we'll
693:13 - see
693:15 - we have this new file in here because
693:17 - we've gone ahead and saved it in here
693:20 - it has everything that we need it has st
693:21 - bernard
693:22 - it has the description it has this image
693:25 - uri that we just created and it has some
693:27 - attributes that again we're basically
693:29 - ignoring now to make our lives a little
693:31 - bit easier and since i've already
693:33 - actually uploaded these to ipfs myself a
693:35 - couple times and since the hashes of
693:37 - these are going to be the exact same for
693:40 - all of us when we upload this we're
693:42 - going to go ahead and just quickly
693:43 - refactor this to make it a little bit
693:45 - easier so we don't always have to have
693:46 - ipfs running so in our dot env i'm going
693:49 - to add a new environment variable called
693:51 - upload
693:52 - ipfs
693:54 - and we're going to set it equal to false
693:56 - so now down here i'm just going to say
693:58 - if os dot get env
694:02 - upload
694:04 - ipfs
694:06 - equals equals true
694:08 - anyway since we're going to do os here
694:10 - we're going to do import os
694:12 - and before this i'm going to do
694:18 - image uri equals none
694:20 - and we're going to say
694:22 - image uri
694:24 - equals image uri if image uri which
694:28 - again i know this could be a little
694:29 - confusing but we're saying
694:31 - we're setting image uri to whatever
694:33 - image uri is if image uri isn't none
694:37 - else we're going to create a mapping
694:38 - called breed
694:40 - to
694:41 - image uri
694:43 - of the breed so again
694:45 - since i've already uploaded them i
694:47 - already know what all these image uris
694:49 - for these three dogs are going to be
694:51 - so up at the top we're just going to
694:52 - create a new mapping called breed to
694:55 - image uri
694:56 - equals
694:58 - i'm actually just going to go ahead and
694:59 - copy paste this whole thing
695:00 - now you can skip this you don't have to
695:02 - refactor here
695:04 - and you can just always have your daemon
695:05 - running and always upload to ipfs it's a
695:08 - little bit quicker to not always have to
695:09 - do that again this brief image uri is in
695:12 - the github repo feel free to just copy
695:14 - paste it to use it you can even click
695:15 - the links to check it to check to see
695:17 - that those image uris are really there
695:19 - and this is what we'll use
695:21 - so back down here reach the image uri
695:24 - uri perfect and then we're also going to
695:26 - add if
695:28 - again os.get
695:30 - env
695:32 - upload ipfs
695:35 - equals equals true
695:37 - then we're also going to upload to ipfs
695:39 - down here but this is to go and actually
695:41 - just show you how exactly we could
695:43 - upload all this stuff to ipfs since i've
695:45 - already done it we're going to make it a
695:46 - little bit easier on ourselves another
695:48 - thing that you might do is you might
695:50 - actually save
695:51 - all these urls to their own file to
695:54 - their own json object maybe inside of
695:56 - the metadata folder maybe under wrinkby
695:59 - or something
696:00 - and then you could go ahead and just
696:01 - pull directly from those files same
696:04 - thing with the metadata once we upload
696:06 - to ipfs we're not actually going to save
696:07 - these urls anywhere you could absolutely
696:10 - 100 percent
696:11 - after you run this upload to ipfs script
696:14 - we go ahead and save it to a file and
696:16 - pull directly from there moving forward
696:18 - but awesome okay so
696:20 - we've done a lot of work here we have
696:23 - uploaded to ipfs our metadata
696:26 - and our image uris so we have everything
696:29 - that we need to actually just set the
696:30 - token uri
696:32 - finally for our advanced collectible we
696:35 - finally can call this set token uri
696:38 - function so let's go ahead and do this
696:40 - last bit here this last set token uri
696:43 - function
696:44 - so let's go to scripts advanced scripts
696:46 - create a new file we'll call it set
696:49 - token uri
696:50 - uri dot pi
696:52 - and this is where we're gonna set the
696:54 - token uri so we'll do def main
696:57 - and in here we'll do a quick print print
696:59 - f
697:00 - working on
697:02 - network dot show active
697:06 - of course since we're using network
697:08 - from browning
697:10 - imports network
697:13 - to close that there and let's grab the
697:15 - most recent advanced
697:18 - collectible
697:20 - it's going to be equal to advanced
697:23 - collectible
697:25 - minus one
697:26 - since we're using advanced collectible
697:28 - contract let's import that from brownie
697:30 - let's once again loop through all the
697:33 - tokens that have been deployed
697:34 - so we'll do number
697:36 - of collectibles
697:39 - equals
697:40 - advanced collectible dot token counter
697:44 - do a quick print
697:47 - you have
697:49 - print f excuse me
697:54 - number of collectibles
697:56 - token ids
697:58 - and let's loop through this list of
697:59 - collectibles again so we'll say for each
698:02 - token id
698:05 - in range
698:08 - number of collectibles
698:11 - first we'll get the breed
698:13 - saying breed
698:15 - equals advanced
698:18 - collectible
698:20 - token id to breed
698:23 - of the token id
698:24 - we actually have to call this
698:26 - getbreed function again
698:28 - which luckily we generalize so we can do
698:30 - from
698:31 - scripts.helpfulscripts
698:35 - import
698:38 - get breed
698:41 - and now let's first before we actually
698:43 - set the token uri let's check to see
698:46 - if it already has a token uri set so
698:49 - we're going to say if not advanced
698:52 - collectible dot token uri
698:56 - of token id
699:00 - dot starts
699:03 - with
699:04 - https
699:07 - so what this line is doing i know it's a
699:09 - little bit long is we're grabbing
699:11 - advanced collectible.token uri
699:14 - of the token id so we're grabbing this
699:16 - token ids token uri
699:18 - and we're saying if it doesn't start
699:20 - with https that means we know that it
699:23 - hasn't been set
699:25 - so we can go ahead and print
699:29 - setting
699:30 - token uri
699:33 - let's actually make this a print f
699:35 - of
699:38 - token id
699:39 - and then we can set the token uri so i'm
699:41 - actually going to generalize this out
699:45 - into its own function
699:48 - so let's go ahead
699:50 - and we'll do def
699:51 - set
699:52 - token uri
699:55 - and as inputs this is going to take the
699:56 - token id
699:58 - the nft contract which is going to be
700:00 - our advanced collectible contract
700:03 - and the token uri so the first thing
700:05 - that we're going to do we'll say account
700:06 - equals get account
700:09 - so we're going to grab this
700:11 - get account of course
700:13 - from our helpful scripts
700:15 - because this set token uri is actually
700:17 - going to call that set token uri
700:19 - function we're going to say
700:21 - nft contract
700:22 - dot set
700:24 - token uri
700:27 - of the token
700:28 - [Music]
700:29 - and the token uri
700:31 - remember this is a function that we
700:33 - added to our advanced collectible right
700:35 - here set token uri it takes a token id
700:38 - and a token uri and this is going to be
700:40 - from of course
700:45 - account we just created so we're going
700:47 - to say
700:48 - transaction
700:50 - equals that we'll do transaction.wait
700:53 - wait one second for it or one block for
700:55 - it and then we'll print
700:58 - we'll do printf
701:00 - awesome
701:02 - you can view
701:05 - your nft at
701:08 - we use that openc url
701:13 - dot format
701:16 - nft contract.address comma token id
701:24 - then i'm just going to add another print
701:25 - here saying
701:27 - please wait up to 20 minutes
701:30 - and hit refresh
701:33 - metadata and hit the refresh metadata
701:37 - button
701:38 - so now we have our set token uri
701:40 - function
701:41 - we can add
701:43 - the token id in here
701:45 - the advanced collectible contract and
701:47 - then we just have to add the token uri
701:49 - here so since we've already uploaded and
701:52 - since i've already actually uploaded all
701:53 - three
701:54 - what you could do
701:55 - and what i like to do is just have a
701:57 - dictionary here so we don't always have
701:58 - to be pulling from something
702:00 - so i have a dog
702:03 - metadata
702:04 - dictionary it's going to be equal to and
702:07 - we're going to add those different dogs
702:08 - in here so saint bernard
702:10 - this this saint bernard url
702:13 - we're going to paste it here i've
702:14 - actually gone ahead like i said and
702:16 - uploaded this metadata for all three
702:18 - dogs
702:19 - so i'm just going to go ahead and copy
702:20 - paste all three in here
702:23 - again we're shortcutting a little bit
702:24 - here but what you could do is you could
702:26 - save all these metadatas to their own
702:29 - file and you could just pull from that
702:30 - file instead of doing kind of this dog
702:32 - metadata dictionary so in any case
702:35 - though we're going to do
702:37 - dog metadata dictionary
702:39 - of breed
702:40 - right because dog metadata dictionary of
702:42 - saint bernard is going to be this which
702:45 - again
702:46 - has
702:48 - our image uri has everything about our
702:50 - dog and is perfect what we also might
702:52 - want to do is write some tests around
702:54 - our set token uri function of course but
702:57 - i'm just going to move on so
702:59 - in any case we've done a lot here i'm
703:01 - actually going to even close down my
703:04 - ipfs node
703:06 - and we should be just about ready for
703:09 - everything
703:10 - so of course we'll run our brownie
703:13 - test
703:14 - we want to make sure that all our unit
703:16 - tests are working great
703:18 - which they look like they are working
703:19 - fantastically but we are ready to
703:22 - do a full end-to-end manual test here
703:27 - and you could 100
703:28 - and i actually highly encourage you to
703:30 - 100 we're just gonna run these scripts
703:33 - in order and look to see if our stuff
703:35 - shows up on the openc nft marketplace so
703:38 - are you guys ready let's do this so make
703:41 - sure of course your environment
703:43 - variables are set here make sure that
703:45 - your metamask
703:47 - for rink b
703:49 - has some eth and
703:51 - has some link and then we can go ahead
703:53 - and start running some of these scripts
703:55 - so we'll do brownie
703:57 - run scripts
703:58 - advanced collectible deploy and create
704:01 - network
704:02 - rink b integration test moment of truth
704:08 - and perfect a new token has been created
704:11 - awesome
704:12 - we can even go grab this address
704:15 - let's delete all these tabs that we have
704:17 - opened up
704:19 - and we'll go to ringpi.etherscan.io
704:23 - we'll paste it in here
704:24 - and we can see
704:26 - contract has been verified even though
704:28 - we didn't verify it because it matches
704:30 - some other source code we can see token
704:32 - counter is one and we can even go to
704:35 - tokenid to breed of zero see what breed
704:37 - it is
704:38 - so it's breed two and it looks like
704:40 - we're getting a saint bernard again
704:42 - which is incredibly adorable we can even
704:44 - go to events here and we can see the
704:47 - different events since this is verified
704:49 - we can even see the name of the events
704:51 - so we have our breed assigned event
704:54 - and we have our requested collectible
704:57 - event first is an index topic of token
704:59 - id and then there's the un8 read
705:02 - and then we have the bytes32 request id
705:04 - and the address requester now let's run
705:06 - our create metadata script here
705:09 - so we'll do brownie
705:11 - run scripts
705:12 - advanced
705:14 - create
705:15 - metadata
705:17 - network rink beam we don't have to run
705:19 - create collectible since our deploying
705:21 - crate already does that so now if we run
705:24 - our create metadata
705:27 - i've actually already have i actually
705:30 - since this is the same bernard again i'm
705:31 - going to go ahead and get this already
705:33 - exists delete to overwrite
705:35 - so what i'm going to do is i'm actually
705:37 - going to even create another one so that
705:39 - i get a new nft so i am actually going
705:42 - to run this crate collectible script so
705:43 - we're going to do brownie
705:45 - run scripts advanced collectible
705:48 - create collectible
705:50 - network rank b
705:54 - and what this is going to do all it's
705:55 - going to do is it's going to fund with
705:57 - some link
705:58 - which it's going to be a little bit
706:00 - overkill with the link but that's fine
706:02 - and then we're going to do advanced
706:03 - collectible.create collectable
706:05 - so we're just going to do two
706:06 - transactions here
706:08 - perfect collectible has now been created
706:11 - now i'm going to wait a solid 30 seconds
706:13 - to have that chainlink vrf respond
706:16 - and i'm even going to go to the contract
706:18 - give it a quick refresh look at this
706:20 - token counter once the chain-link vrf
706:22 - responds this token counter will then be
706:24 - 2. now that i see a token counter of 2
706:26 - here that means that it actually has
706:28 - responded so we can now run
706:30 - the create metadata script
706:33 - and we should have
706:36 - a new metadata file now you have two
706:38 - collectibles
706:40 - zero saint bernard already exists
706:41 - deleted to overwrite create a metadata
706:44 - file metadata ring b pug so now if we
706:46 - look in metadata
706:48 - for rink b we have a saint bernard and
706:51 - we now have a pug awesome so we're going
706:54 - to set the token uri of both of these if
706:56 - i grab this contract and i go to
706:58 - testnets.openc
707:03 - open c
707:05 - i can paste this address in
707:07 - and i'll get this doggy and then this
707:10 - random hash here right and we see there
707:12 - are two
707:14 - token uris deployed again if they're not
707:16 - here you might have to refresh but they
707:18 - don't have the images right because we
707:20 - haven't set the token uri so we'll go
707:22 - back look at the advanced collectible
707:23 - we've deployed and created we've created
707:26 - another collectible we've created their
707:28 - metadata now all we have to do is set
707:30 - the token uri
707:32 - so brownie run scripts
707:34 - advanced collectible
707:36 - set token uri
707:38 - network rink b
707:40 - and this script it's going to loop
707:41 - through
707:42 - all
707:44 - of them and actually going to set those
707:46 - token arrives so we have
707:48 - setting token uri of 0
707:50 - so this transaction is doing exactly
707:52 - that
707:54 - and it's going to go ahead and say
707:55 - awesome here's your output and then it's
707:58 - going to say setting token uri of token
708:00 - id one and that's that second
708:02 - transaction and it also gives us an
708:04 - output to that one as well
708:06 - so if we've done this correctly
708:08 - and we hit refresh metadata on this
708:11 - testnet openc.io
708:13 - and we do a little refresh here
708:15 - we can now see our saint bernard which
708:18 - is fantastic and then if we change
708:21 - this from 0 to 1 since i've deployed 2
708:24 - and i refresh this one's metadata and
708:26 - then refresh the page
708:28 - we can now see the pug as well
708:31 - again just keep in mind sometimes the
708:33 - refreshing metadata does take some time
708:35 - and you might have to wait up to 20
708:36 - minutes
708:37 - but for all intents and purposes we have
708:39 - just deployed our nfts given them token
708:43 - uris that aren't around centralized
708:45 - servers we can now see them on an nft
708:48 - marketplace like openc
708:50 - you can let out a big sigh of relief
708:52 - because you just did something fantastic
708:53 - that not a lot of other engineers can do
708:55 - you should be incredibly proud of
708:57 - yourself at this point let's take a
708:58 - minute go back over to some of the new
709:00 - things that we've learned here
709:06 - when deploying your smart contracts on
709:07 - chain we all know that those smart
709:08 - contracts are immutable or unchangeable
709:11 - but what if i told you that they were
709:13 - mutable
709:15 - well technically i wouldn't be correct
709:17 - however smart contracts actually can
709:19 - change all the time when people transfer
709:21 - tokens when people stake in a contract
709:23 - or really do any type of functionality
709:25 - those smart contracts have to update
709:27 - their balances and update their mappings
709:29 - and update their variables to reflect
709:31 - this the reason that they're immutable
709:32 - is that the logic itself never changes
709:34 - and will be on chain like that forever
709:37 - so technically yes once they are
709:38 - deployed they are immutable and this is
709:40 - actually one of the major benefits of
709:41 - smart contracts in the first place that
709:43 - nobody can tamper with or screw with our
709:44 - smart contracts once we deploy them
709:46 - however this can be an issue if for
709:48 - example we want to upgrade our smart
709:49 - contractor protocol to do more things or
709:51 - we want to fix some glaring bug or issue
709:54 - that we have now even though we can't
709:55 - change the specific code that's been
709:57 - deployed to an address we can actually
709:58 - do a lot more than you think we're going
710:00 - to explain the different methodologies
710:02 - behind upgrading your smart contracts
710:04 - and then we're going to show you how to
710:05 - do it now at first glance you might be
710:07 - thinking
710:08 - if you can upgrade your smart contracts
710:10 - then they're not really immutable then
710:14 - in a way you'd be right so when
710:16 - explaining kind of the different
710:17 - philosophies and patterns that we can
710:18 - use here we do need to keep in mind the
710:20 - philosophies and decentralization
710:22 - implications that each one of these
710:23 - patterns have as they do all have
710:25 - different advantages and disadvantages
710:27 - and yes some of the disadvantages here
710:30 - are going to affect decentrality so we
710:32 - need to keep that in mind and this is
710:33 - why it's so important that before you go
710:35 - ahead and jump in and start deploying
710:37 - upgradable smart contracts you
710:38 - understand the trade-offs we're going to
710:40 - look at three different ways to upgrade
710:41 - your smart contracts the not really
710:43 - upgrading method the social aka my
710:46 - grading method and then the method that
710:48 - you're probably here for which is
710:49 - proxies so let's talk about the not
710:51 - really upgrading method or the
710:53 - parameterization method or whatever you
710:54 - want to call it this is the simplest way
710:57 - to think about upgrading your smart
710:58 - contracts and it really isn't upgrading
711:00 - our smart contracts because we can't
711:02 - really change the logic of the smart
711:04 - contract whatever logic that we've
711:05 - written is there we also can't add new
711:07 - storage or state variables so this is
711:09 - really not really upgrading but it is
711:11 - something to think about upgrades is
711:13 - just parameterizing everything whatever
711:15 - logic that we've deployed is there and
711:17 - that's what we're interacting with this
711:18 - function means we just have a whole
711:20 - bunch of setter functions and we can
711:21 - update certain parameters like maybe we
711:23 - have a reward parameter that gives out a
711:25 - token at one percent every year or
711:28 - something like that maybe we have a
711:30 - center function that says hey update
711:31 - that to two percent or update that to
711:33 - four percent it's just a setter function
711:35 - that changes some variable now the
711:37 - advantages here are obviously this is
711:38 - really simple to implement the
711:40 - disadvantage is that if you didn't think
711:42 - of some logic or some functionality the
711:44 - first time you deployed their smart
711:46 - contract that's too bad you're stuck
711:48 - with it you can't update the logic or
711:50 - really update anything uh with the
711:52 - parameterization aka not really method
711:55 - and the other thing you have to think
711:55 - about is who the admins are who has
711:57 - access to these setter functions to
711:59 - these updating functions if it's a
712:02 - single person
712:03 - guess what you have a centralized smart
712:04 - contract now of course you can add a
712:06 - governance contract to be the admin
712:08 - contract of your protocol and that would
712:10 - be a decentralized way of doing this so
712:12 - just keep that in mind you can do this
712:13 - method just need a governance protocol
712:15 - to do so another example of this might
712:17 - be a contract registry and this is
712:18 - something actually that early versions
712:20 - of ave used before you call function you
712:22 - actually check some contract registry
712:24 - that is updated as a parameter by
712:26 - somebody and you get routed to that
712:27 - contract and you do your call there
712:29 - again this really doesn't allow us to
712:30 - have the full functionality of upgrades
712:32 - here you can argue that this registry is
712:34 - a mix of one of the later versions but
712:36 - for all intents and purposes this
712:38 - doesn't really give us that flexibility
712:39 - that we want for our upgrades but some
712:41 - people might even think that upgrading
712:42 - your smart contract is ruining the
712:44 - decentrality and one of the things that
712:46 - makes smart contracts so potent is that
712:47 - they are immutable and that this is one
712:49 - of the benefits that they have so there
712:51 - are some people who think that you
712:52 - shouldn't add any customization or any
712:54 - upgradability you should deploy your
712:56 - contract and then that's it trillabits
712:59 - has actually argued that if you deploy
713:00 - your contract knowing that it can't be
713:02 - changed later you take a little bit
713:04 - extra time making sure you get
713:06 - everything right and there are often
713:08 - less security vulnerabilities because
713:10 - you're just setting it for getting it
713:12 - and not looking at it again now if i
713:13 - were to deploy a smart contract and i
713:15 - wanted to upgrade it with this
713:16 - philosophy in mind that hey we got to
713:18 - keep it immutable we could use the
713:20 - social yate method to actually upgrade
713:22 - to new versions the social yet method or
713:25 - the migration method is just when you
713:27 - deploy your new contract not connected
713:29 - to the old contract in any way and by
713:31 - social convention you tell everybody hey
713:34 - hey this new contract this new one that
713:36 - we just deployed yeah this is the real
713:37 - one now and it's just by convention of
713:39 - people migrating and over into using
713:41 - this new one that the upgrade is done
713:43 - hence my slang name of social yi because
713:45 - you
713:46 - yeet the first one out of the way and
713:48 - move to the second one
713:52 - i think i'm funny
713:53 - this has the advantage of truly always
713:55 - saying hey this is our immutable smart
713:57 - contract and this is our new one this is
713:59 - really the truest definition of
714:00 - immutable because since you give it no
714:03 - way of being upgraded in place then if
714:05 - somebody calls that contract in 50 000
714:08 - years in the future it'll respond
714:10 - exactly the same another huge
714:12 - disadvantage here is that you have to
714:13 - have a totally new contract address
714:16 - so if you're an erc20 token for example
714:18 - you have to go convince all the
714:20 - exchanges to list your new contract
714:22 - address as the actual address keep in
714:24 - mind that when we do this we do have to
714:25 - move the state of the first one over to
714:28 - the second one so for example if you're
714:30 - an erc token moving to a new version of
714:32 - that erc token you do have to have a way
714:35 - to take all those mappings from the
714:36 - first contract and move it to the second
714:38 - one obviously there are ways to do this
714:40 - since everything is on chain but if you
714:42 - have a million transfer calls i don't
714:43 - want to have to write the script that
714:45 - updates everyone's balance and figures
714:46 - out what everyone's balance is just so i
714:48 - can migrate to my new version of the
714:49 - contract so there is a ton of social
714:51 - convention work here to do trailer bits
714:53 - has actually written a fantastic blog on
714:55 - upgrading from a v1 to a v2 or etc with
714:59 - this yeet methodology and they give a
715:01 - lot of steps for moving your storage and
715:02 - your state variables over to the new
715:04 - contract so link in the description if
715:06 - you want to read that now let's get to
715:07 - our big ticket item so in order to have
715:08 - a really robust upgrading mentality or
715:11 - philosophy we need to have some type of
715:12 - methodology or framework that can update
715:14 - our state
715:15 - keep our contract address and allow us
715:17 - to update any type of logic in our smart
715:20 - contracts in an easy way which leads us
715:22 - to our big ticket item the proxies
715:24 - proxies are the truest form of upgrades
715:27 - since a user can keep interacting with
715:29 - the protocols through these proxies and
715:31 - not even notice that anything changed or
715:33 - even got updated now these are also the
715:35 - places where you can screw up the
715:37 - easiest proxies use a lot of low-level
715:39 - functionality and the main one being the
715:41 - delegate call functionality daily gate
715:43 - call is a low-level function where the
715:46 - code in the target contract is executed
715:49 - in the context of the calling contract
715:51 - and message.sender and message.value
715:53 - also don't change so you understand what
715:55 - delegate call means now right great and
715:57 - in english this means if i delegate call
716:00 - a function in contract b from contract a
716:03 - i will do contracts b's logic in
716:06 - contract a so if contract b has a
716:08 - function that says hey store this value
716:11 - in a variable up top i'm going to store
716:13 - that variable in contract a this is the
716:16 - powerhouse and this combined with the
716:18 - fallback function allows us to delegate
716:21 - all calls through a proxy contract
716:23 - address to some other contract this
716:26 - means that i can have one proxy contract
716:28 - that will have the same address forever
716:30 - and i can just point and route people to
716:33 - the correct implementation contract that
716:35 - has the logic whenever i want to upgrade
716:38 - i just deploy a new implementation
716:40 - contract and point my proxy to that new
716:43 - implementation now whenever a user calls
716:45 - a function on the proxy contract i'm
716:47 - going to delegate call it to the new
716:49 - contract i can just call an admin only
716:52 - function on my proxy contract let's call
716:54 - it upgrade or something and i make all
716:55 - the contract calls go to this new
716:57 - contract when we're talking about
716:58 - proxies there are four pieces of
717:00 - terminology that we want to keep in mind
717:01 - first is the implementation contract the
717:03 - implementation contract has all of our
717:05 - logic and all the pieces of our protocol
717:07 - whenever we upgrade we actually launch a
717:09 - brand new implementation contract the
717:11 - proxy contract proxy points to which
717:14 - implementation is the correct one and
717:16 - routes everyone's calls to the correct
717:19 - implementation contract you can think
717:20 - the proxy contract sits on top of the
717:23 - implementations the user the user is
717:25 - going to be making contracting function
717:27 - calls through the proxy contract and
717:29 - then some type of admin the admin is the
717:31 - one who's going to decide when to
717:33 - upgrade and which contract to point to
717:36 - in this scenario the other cool thing
717:38 - about the proxy and delegate call is
717:40 - that all my storage variables are going
717:41 - to be stored in the proxy contract and
717:44 - not in the implementation contract
717:46 - this way when i upgrade to a new logic
717:49 - contract all of my data will stay on the
717:51 - proxy contract so whenever i want to
717:53 - update my logic just point to a new
717:55 - implementation contract if i want to add
717:57 - a new storage variable or a new type of
717:59 - storage i just add it in my logic
718:01 - contract and the proxy contract will
718:03 - pick it up now using proxies has a
718:05 - couple of gotchas and we're going to
718:06 - talk about the gotchas and then we're
718:08 - going to talk about the different proxy
718:09 - contract methodologies because yes there
718:11 - are many proxy contract methodologies as
718:13 - well and this is why trillabits doesn't
718:15 - really recommend using upgradable
718:16 - proxies for your smart contracts because
718:19 - they're fraught with a lot of these
718:20 - potential issues not to mention again
718:23 - you do still have some type of admin
718:25 - who's going to be upgrading your smart
718:26 - contracts now if this is a governance
718:28 - protocol then great you're decentralized
718:30 - but if this is a single group or entity
718:33 - then we have a problem
718:35 - the two biggest gotchas are storage
718:37 - clashes and function selector clashes
718:40 - now
718:41 - what does this mean when we use delegate
718:43 - call remember we do the logic of
718:45 - contract b
718:46 - inside contract a so if contract b says
718:49 - we need to set value to 2 we go ahead
718:52 - and set value to 2. but these smart
718:54 - contracts are actually kind of dumb we
718:56 - actually set the value of whatever is in
718:58 - the same storage location on contract a
719:01 - as contract b so if our contract looks
719:03 - like this and we have two variables in
719:05 - contract a we're still going to set the
719:07 - first storage spot on contract a to the
719:09 - new value this is really important to
719:11 - know because this means we can only
719:13 - append new storage variables in new
719:15 - implementation contracts and we can't
719:17 - reorder or change old ones this is
719:19 - called storage clashing and in the
719:21 - implementations we're going to talk
719:22 - about they all address this issue the
719:25 - next one is called function selector
719:27 - clashes when we tell our proxies to
719:29 - delegate call to one of these
719:30 - implementations it uses what's called a
719:32 - function selector to find a function the
719:35 - function selector is a four byte hash of
719:37 - the function name and the function
719:39 - signature don't worry about the function
719:40 - signature for now now it's possible that
719:43 - a function in the implementation
719:45 - contract has the same function selector
719:48 - as an admin function in the proxy
719:50 - contract which may cause you to do
719:52 - accidentally a whole bunch of weird
719:53 - stuff for example in this sample code in
719:55 - front of you even though these functions
719:57 - are totally different they actually have
719:59 - the same function selector so yes we can
720:01 - run into an issue where some harmless
720:03 - function like
720:05 - get price has the same function selector
720:07 - as upgrade proxy or destroy proxy or
720:10 - something like that this leads to our
720:12 - first out of the three implementations
720:14 - of the proxy contracts this is called
720:16 - the transparent proxy pattern and this
720:18 - is actually going to be the pattern that
720:20 - we're going to be demoing to you today
720:21 - in this methodology admins are only
720:23 - allowed to call it admin functions and
720:25 - they can't call any functions in the
720:27 - implementation contract and users can
720:30 - only call functions in the
720:31 - implementation contract and not any
720:33 - admin contracts this way you can't ever
720:35 - accidentally have one of the two
720:37 - swapping and having a function selector
720:39 - clash and you run into a big issue where
720:41 - you call a function you probably
720:42 - shouldn't have if you're an admin you're
720:43 - calling admin functions if you're a user
720:45 - you're calling implementation functions
720:47 - so if you're an admin and you build some
720:48 - crazy awesome d5 protocol you better
720:50 - come up with a new wallet address
720:51 - because you can't participate the second
720:53 - type of proxy we're going to talk about
720:55 - is the universal upgradable proxy or the
720:57 - ups
721:03 - this version of upgradable contracts
721:04 - actually puts all the logic of upgrading
721:07 - in the implementation itself this way
721:09 - the solidity compiler will actually kick
721:11 - out and say hey we got two functions in
721:14 - here that have the same function
721:15 - selector this is also advantageous
721:17 - because we have one less read that we
721:19 - have to do we no longer have to check in
721:21 - the proxy contract if someone is an
721:23 - admin or not this saves on gas of course
721:26 - and the proxy is also a little bit
721:27 - smaller because of this the issue is
721:29 - that if you deploy an implementation
721:30 - contract without any upgradeable
721:32 - functionality
721:33 - you're stuck and it's back to the yeet
721:35 - method with you and the last pattern or
721:38 - methodology that we're going to talk
721:39 - about is the diamond pattern which does
721:41 - a number of things but one of the
721:43 - biggest things that it does it actually
721:44 - allows for multiple implementation
721:46 - contracts this addresses a couple
721:48 - different issues for example if your
721:50 - contract is so big and it doesn't fit
721:52 - into the one contract maximum size you
721:55 - can just have multiple contracts through
721:56 - this multi-implementation method it also
721:59 - allows you to make more granular
722:00 - upgrades like you don't have to always
722:03 - deploy and upgrade your entire smart
722:04 - contract you can just upgrade little
722:05 - pieces of it if you've chunked them out
722:07 - the disadvantages here really only seem
722:09 - like you have a lot more complicated
722:11 - code all the proxies mentioned here have
722:14 - some type of ethereum improvement
722:15 - proposal and most of them are in the
722:17 - draft phase there isn't really a
722:18 - standard here for the proxy that the
722:19 - whole community has landed on and says
722:21 - yes
722:22 - this is great let's do it so for all
722:24 - these be sure to jump on the discussion
722:25 - and give your thoughts all right so now
722:27 - that we know a lot more about upgrades
722:30 - and how they actually work and some
722:31 - different methodologies behind them
722:33 - let's go ahead and learn how to actually
722:35 - implement some of these strategies and
722:37 - implement our contract so that we can
722:39 - upgrade them now there is a brownie
722:41 - upgrades mix directly in the brownie
722:44 - mixes organization that if you want to
722:46 - use you absolutely can once again to do
722:49 - that it's just brownie
722:50 - bake upgrades mix and this will have all
722:53 - the code that we're going to teach you
722:54 - how to use right now but let's go ahead
722:57 - and build this up from scratch ourselves
722:59 - so
723:00 - we're going to go ahead and run brownie
723:02 - knit
723:03 - this of course we're going to create our
723:05 - new browning project here we're going to
723:07 - be using the open zeppelin proxy
723:09 - contracts to actually work with this and
723:11 - run with this the methodology that we're
723:13 - going to be working with is the
723:14 - transparent upgradable proxy now they've
723:16 - been using the universal upgradable
723:18 - proxies a little bit more however the
723:20 - transparent upgradeable proxy is really
723:22 - fantastic and easy to understand so
723:24 - that's going to be the one that we're
723:25 - going to be working with here and these
723:26 - are the two contracts that we're going
723:28 - to be importing directly from open
723:30 - zeppelin so let's get to it we're going
723:32 - to create a really simple contract that
723:33 - we can easily tell if it's upgraded or
723:36 - not
723:36 - we're going to be using the exact same
723:38 - ones that open zeppelin actually uses so
723:40 - let's create a new file and this is
723:42 - going to be called box.soul we're just
723:44 - going to have it store and retrieve some
723:46 - type of value so let's give the spdx
723:50 - license
723:52 - identifier
723:54 - of mit so let's pick our solidity
723:56 - version
723:57 - and for this we're actually going to use
723:59 - 0.8.0
724:01 - oftentimes you're going to have to
724:02 - quickly pick up new versions of solidity
724:03 - anyways anyways we're going to do
724:05 - contract box and we're going to give it
724:07 - a uint256
724:10 - private value
724:11 - we're going to do an event called
724:14 - value changed
724:18 - i'm going to give it to you in 256 new
724:20 - value
724:21 - give it a function store
724:24 - uin256
724:26 - new value
724:27 - and this is going to be a public
724:28 - function that anybody can call
724:30 - and all we're going to do is we're going
724:32 - to set value
724:34 - to be new value
724:36 - and we're going to omit
724:39 - this value changed
724:42 - event then we're going to have a
724:44 - function
724:46 - retrieve and this will be a public view
724:50 - and it's just going to return
724:52 - the ui 256
724:55 - value return value and this is going to
724:58 - be our whole contract hopefully you can
724:59 - understand everything that's going on in
725:01 - this contract i should spell license
725:03 - right shouldn't i now we're going to
725:04 - copy all of this code
725:07 - and create a new contract called box
725:10 - v2.sol
725:12 - we're going to paste it in
725:14 - and box version 2 is going to be exactly
725:16 - the same
725:17 - except we're going to add
725:19 - one more function called increment
725:24 - this is going to be a public function
725:25 - and we're going to set value equals
725:27 - value plus one
725:29 - and we're also going to omit
725:31 - a value changed event
725:34 - with that new value
725:35 - now this is going to be really easy for
725:37 - us to check to see if a contract has
725:39 - been upgraded or not
725:41 - if we can call increment
725:43 - on the same address that we originally
725:45 - deployed box to then this means that the
725:48 - contract has been upgraded we shouldn't
725:50 - be able to call increment
725:52 - on this box contract but we should be
725:54 - able to call it on box v2 perfect so
725:58 - that's all we need to do to get started
725:59 - now to actually work with the proxies
726:01 - and the transparent proxy that we're
726:02 - going to be working with we do need to
726:04 - add them
726:05 - to our browning project
726:07 - so we're going to create a new folder
726:09 - and we're going to call it transparent
726:12 - proxy
726:13 - and in here we're going to add those two
726:15 - contracts we're going to add one
726:18 - called proxyadmin.sol
726:21 - and all we're going to do is we're going
726:22 - to grab all the code
726:24 - from the opens up and proxy contract and
726:26 - paste it right in here
726:29 - since
726:30 - since this code is pulling directly from
726:32 - it it opens up one package we are going
726:34 - to have to
726:35 - fiddle with the imports a little bit to
726:37 - make a match so brownie can actually
726:38 - compile it
726:39 - and of course since we're going to be
726:40 - working with another package we have to
726:43 - add this dependencies to our browning
726:45 - config
726:53 - so
726:54 - dependancies
726:57 - open
726:59 - zeppelin
727:00 - open
727:01 - zeppelin hyphen contracts
727:04 - and for this one we are going to
727:05 - actually use 4.1.0
727:07 - then we have to do compiler
727:10 - soak
727:13 - remappings
727:15 - at open
727:18 - zeppelin
727:19 - is going to be equal to this dependency
727:22 - now while we're in here we might as well
727:24 - do our dot env
727:26 - so we can get our environment variables
727:28 - and we'll add our wallet in here
727:30 - while it's
727:32 - from key
727:35 - private
727:36 - key
727:38 - we can now just have this be
727:40 - at open zeppelin
727:44 - contracts
727:45 - access
727:46 - ownable.soul and we don't need to change
727:49 - this at all because we're actually going
727:50 - to keep this transparent
727:51 - upgradableproxy.com
727:53 - because this
727:55 - is the second contract that we're
727:56 - actually going to grab from open
727:57 - zeppelin
727:59 - so let's create a new file
728:01 - to be called transparent
728:02 - upgradableproxy.soul this exact
728:05 - text here
728:08 - and we're going to copy paste this whole
728:10 - thing from open zeppelin
728:13 - boom
728:15 - paste it in here
728:18 - awesome and then same thing here we just
728:19 - have to a little reverse engineer this
728:22 - at open
728:23 - zeppelin slash contracts slash proxy
728:27 - erc
728:28 - 1967 erc 1967 proxy and perfect that is
728:32 - exactly where we are
728:33 - so great now if we've done this right we
728:35 - should be able to run a quick
728:38 - brownie compile
728:40 - oops i got to change this to box
728:45 - v2
728:48 - now let's run a brownie compile
728:50 - and perfect
728:52 - looks like we have compiled we've got
728:54 - some stuff in build great everything's
728:56 - working correctly so okay so we have our
728:58 - box here our box v2 and we have our
729:02 - proxy contracts as well that we can use
729:04 - to upgrade this box to a new version we
729:07 - can even look if we go back to proxy of
729:10 - open zeppelin if we look at our proxy
729:12 - admin here
729:13 - we see it has this function upgrade and
729:16 - call and this calls the upgrade to and
729:18 - call on the proxy contract if we look in
729:21 - the transparent proxy this upgrade to
729:23 - and call calls upgrade to and call which
729:26 - has been imported actually so we can
729:28 - actually even go back go back
729:30 - go to erc 1967 proxy upgrade
729:34 - look for that again and this is the
729:35 - function that it's actually going to
729:37 - call
729:38 - and it calls this upgrade to function
729:40 - which calls this set implementation
729:43 - function
729:44 - and all we're doing is we're doing
729:45 - storage slot dot get address slot of
729:48 - this implementation slot
729:50 - that value is going to be this new
729:51 - implementation
729:52 - all it's doing is it's setting the
729:54 - implementation slot to being our the new
729:56 - address that we wanted to use and we can
729:59 - see now if we look in the proxy contract
730:01 - the way that it actually works is it has
730:03 - this fallback function
730:04 - where it's always going to delegate all
730:06 - of our calls to whatever the
730:08 - implementation contract is
730:10 - this delegate function if we look at him
730:13 - there's a little bit of low-level
730:14 - assembly here
730:16 - and he uses this low-level delegate call
730:18 - to send any
730:20 - function call or any call to this
730:22 - contract to the implementation contract
730:25 - so this is exactly the function doing
730:27 - all that delegation all right so now
730:29 - that we've dug deep into the code let's
730:31 - actually script this out and turn this
730:32 - into a script so let's create a new file
730:35 - and we'll call it zero one deploy box
730:38 - dot soul and this is gonna be how we're
730:40 - actually gonna deploy the box so since
730:42 - this is a brand new script
730:43 - we're gonna do def
730:45 - main of course
730:47 - our account
730:49 - going to be equal to get account
730:51 - which
730:53 - we're going to do from scripts dot
730:55 - helpful
730:56 - scripts import
730:59 - get account
731:01 - so let's go ahead create a new file
731:04 - help
731:06 - full scripts
731:08 - oops
731:10 - scripts.pi
731:11 - and again we're just going to paste in
731:13 - that getaccount function from our past
731:16 - helpful scripts
731:21 - all right our get account script again
731:24 - so we can just do account equals get
731:25 - account oh this should be sorry should
731:28 - be dot pi excuse me
731:31 - do a quick print
731:33 - deploying
731:35 - to
731:35 - we'll do
731:37 - network dot show
731:39 - active
731:41 - that means we got to do
731:42 - from
731:43 - brownie import network and then we'll do
731:46 - box equals box
731:50 - dot deploy
731:53 - from
731:55 - account
731:57 - little brackets
731:58 - here of course since we're going to be
732:01 - deploying this contract we also have to
732:03 - import that from brownie and perfect
732:05 - this alone should just deploy the box
732:07 - contract right so this means we could do
732:09 - something like print
732:11 - box dot
732:13 - retrieve
732:14 - and it should be zero right so if we run
732:17 - brownie run scripts
732:19 - o1 deploy
732:21 - it will deploy that
732:22 - whoops we also got to add our env
732:26 - we don't have to put anything in here
732:27 - yet because we're not actually deploying
732:29 - to a real network
732:31 - but let's go ahead and run this
732:33 - i spelt retrieve wrong
732:36 - it's probably good to
732:38 - spell things right let's try it again
732:41 - and great so we get 0 here perfect
732:44 - that's exactly what we'd expect it's
732:45 - cool however though if we run
732:48 - box dot increment this should error out
732:50 - right
732:54 - boom exactly it has no attribute
732:56 - increment so this is what's known as our
732:58 - implementation contract this box is
733:01 - implemented it's the implementation
733:02 - contract
733:04 - now we have to hook it up to a proxy so
733:06 - let's first give it a proxy admin and
733:09 - proxy admins are optional um and it's
733:12 - also recommended that if you do have a
733:14 - proxy admin you're and you're going to
733:16 - use some type of default protocol
733:17 - sometimes it's great to have your proxy
733:19 - admin be something like a multi-sig
733:21 - gnosis safe which is really fantastic
733:24 - there's going to be a link
733:25 - in the github for learning how to
733:27 - actually spin one of those up let's go
733:29 - ahead and do a proxy admin because
733:31 - they're really helpful anyways we could
733:33 - optionally we could just set ourselves
733:35 - to be the proxy admin but let's set it
733:36 - to be this this contract
733:39 - so we'll do proxy admin
733:41 - equals
733:43 - proxyadmin.deploy and again this will be
733:46 - from
733:47 - account
733:49 - and since we're using this proxy admin
733:51 - we're going to import that as well
733:53 - so if we look at the proxy admin we see
733:55 - a couple functions here we see like get
733:56 - proxy implementation which is just going
733:58 - to return the address of the
734:00 - implementation
734:01 - we have get proxy admin
734:03 - it's going to be us
734:05 - change proxy admin we have this upgrade
734:07 - which is just going to call that upgrade
734:09 - function on the proxy and then we have
734:11 - upgrade and call upgrading call
734:14 - changes the implementation to the new
734:16 - implementation and then calls that
734:18 - initializer function since we want these
734:20 - to be proxies you can see here that we
734:23 - don't have a constructor
734:25 - this is intentional instead we could
734:27 - have some type of initializer
734:30 - function for example maybe we want to
734:32 - have this store be our constructor
734:34 - instead of having a constructor what we
734:36 - do is we call what's called our
734:38 - initializer function the instant we
734:40 - deploy this contract for the demo here
734:42 - we're just not going to have an
734:43 - initializer anyways so now we have this
734:46 - proxy admin we have the implementation
734:48 - contract we have the proxy admin let's
734:50 - now hook them up to the actual proxy
734:53 - first thing that we need to do actually
734:54 - is we need to
734:56 - encode the initializer function if we
734:58 - wanted store to be our initializer
735:00 - function like i said we could do
735:02 - something like ini shi al
735:05 - lizer
735:06 - equals
735:07 - box.store comma one and this would be
735:11 - our initializer box.store combined with
735:13 - one
735:14 - what we then have to do is we'd have to
735:17 - encode this for our proxy if we look at
735:20 - our transparent upgradable proxy if we
735:23 - look at the constructor
735:24 - we have address logic address admin and
735:28 - data here
735:29 - the logic is that implementation right
735:31 - this is going to be the address of our
735:32 - box the admin is going to be ourselves
735:35 - or in our case it's going to be that
735:37 - proxy admin contract
735:38 - and then data is going to be
735:41 - that initializer function if we go into
735:43 - the erc
735:45 - 721 proxy
735:47 - contract
735:48 - should go back to proxy erc
735:51 - 1967 upgrade
735:53 - and we look at this as one's constructor
735:56 - we can see that this data bit here
735:58 - once this is built with this constructor
736:00 - it's immediately going to call this
736:01 - upgrade to and call so it's going to
736:04 - call this this initializer if we go to
736:06 - upgrade to and call if we go back to
736:08 - this upgrade contract we can see this
736:10 - upgrade to and call it's going to call
736:12 - this address dot function delegate call
736:15 - new implementation data and this is how
736:17 - it actually
736:19 - calls that initializer function we have
736:21 - to actually encode this
736:23 - into bytes so we have to say box.store
736:26 - is the is the function a call
736:29 - and then one is going to be the first
736:31 - parameter right if this is what we'd
736:33 - want to do
736:34 - so we do box
736:37 - encoded
736:38 - initially
736:40 - function
736:42 - equals encode
736:44 - function data and this is where it gets
736:46 - a little bit tricky
736:48 - but i usually have this encode function
736:49 - data once again in my helpful scripts
736:52 - so we'll do quick def encode function
736:54 - data
736:55 - and it's going to take
736:57 - an init
737:01 - which we're going to start off as none
737:03 - and then any number of arguments after
737:05 - that so again this could be like
737:08 - you know
737:10 - initializer equals box.store
737:13 - and then the arguments could be you know
737:16 - one two three four
737:18 - five etc or whatever right for us we
737:20 - only have one variable that can be put
737:22 - into store but this is how you would do
737:24 - it and to do this brownie actually has a
737:26 - built-in function that can actually do
737:28 - this we just return initializer dot and
737:31 - code
737:32 - input
737:33 - star args
737:35 - and that's all we'd have to do however
737:37 - there is a bit of an issue when the
737:39 - length of the args is zero so i've
737:42 - already hacked away at it for you guys
737:44 - so we're just gonna do if
737:45 - the length of the args
737:48 - is zero or we're not using an
737:51 - initializer
737:53 - then we're going to return
737:55 - s utils dot two bytes
737:59 - x string
738:00 - equals ox
738:03 - and we do have to import f util
738:05 - import
738:07 - at utils and of course we'd have to pip
738:09 - install it with pip
738:11 - install
738:13 - ethertails so i know i kind of rushed
738:15 - through that but basically what we're
738:16 - doing like i said
738:18 - is we're encoding this into bytes so
738:20 - that our smart contracts actually know
738:23 - what function to call
738:24 - so we're just encoding it that's all
738:26 - we're doing and if it's blank or there's
738:28 - no initializer we're going to return an
738:30 - empty hex string and our smart contract
738:32 - will understand ah okay arguments are
738:34 - blank here perfect i've got a nice doc
738:37 - string in the upgrades mix that explains
738:40 - this even better i'm even just going to
738:41 - paste it in here for now if you'd like
738:43 - to pause and read this a little bit more
738:45 - to
738:46 - kind of get the full depth of what this
738:48 - function is really doing feel free to do
738:50 - that this is a little bit lower level
738:52 - solidity and evm stuff that we're
738:53 - getting into here but it can be good to
738:55 - know anyways
738:56 - okay great so now that we have this we
738:59 - could go ahead and run box encoded
739:01 - initializer function equals encode
739:03 - function data
739:04 - which we would import from our helpful
739:06 - scripts and this is what we use when we
739:09 - call the constructor for our transparent
739:11 - upgradable proxy
739:13 - i'm just going to have it be blank for
739:14 - now but feel free to fiddle around and
739:16 - try to actually use an initializer after
739:18 - we run through this demo so this box
739:20 - encoded initializer function is going to
739:22 - be blank we're saying hey
739:23 - don't use an initializer and that's
739:25 - totally fine
739:27 - if we were to add some stuff to here we
739:29 - would say hey use an initializer so now
739:31 - we can actually deploy this transparent
739:33 - upgradable proxy if we open this up with
739:36 - the constructor we can see
739:38 - what we need here
739:40 - so
739:41 - we're going to say proxy
739:42 - equals
739:44 - transparent
739:46 - upgrade able
739:48 - proxy.deploy
739:51 - of course
739:53 - import this from brownie
739:57 - and what are those
739:58 - variables that we need okay we're gonna
740:01 - need the address the logic this is gonna
740:03 - be our implementation contract address
740:05 - so we just say box.address which is our
740:08 - because we've already deployed this
740:09 - which is great
740:11 - then we're going to need our admin which
740:13 - we could just say is us but we're going
740:15 - to use the proxy admin
740:18 - dot address and then last we need that
740:22 - function selector we need that encoded
740:24 - function call which for us is just blank
740:26 - but we still need that
740:28 - so
740:29 - box encoded initializer function and
740:31 - then we have to add from
740:34 - account of course and i've also noticed
740:37 - that sometimes it's helpful to add some
740:39 - type of gas limit
740:41 - so i'll even add a gas limit
740:44 - of one
740:46 - one two three one two three that's six
740:49 - zeros there but sometimes you might be
740:51 - fine but uh
740:52 - with the proxies they they sometimes
740:54 - have a hard time figuring out the gas
740:55 - limit so i've just manually put it in
740:57 - here you can if you want to it might
740:59 - work fine without it and then great
741:00 - let's do a quick print function we'll
741:02 - print
741:04 - f
741:06 - proxy deployed to
741:09 - proxy
741:11 - you can now upgrade to v2
741:15 - now what we can do is on the proxy's
741:18 - address we can call functions so
741:21 - typically right if we wanted to call a
741:22 - function on this box contract we do box
741:24 - dot you know retrieve or however you
741:27 - spell it box.store let's just do box
741:30 - store right you'd call it like this
741:32 - however we want to actually call these
741:33 - on the proxies right because box this
741:36 - box contracts address this box contract
741:39 - is always going to be the same address
741:41 - and can't change
741:42 - the proxy code can change we want to
741:44 - always call these functions to the proxy
741:47 - and not to the box here right so the way
741:50 - we do that is we can do proxy box
741:53 - equals
741:55 - contract dot from
741:57 - abi
741:58 - we'll call it box
742:01 - on the proxy.address
742:03 - box.abi
742:05 - and of course we'll
742:07 - import this from brownie
742:09 - what we're doing here
742:11 - is we're assigning
742:13 - this proxy address the abi
742:17 - of the box contract and this is going to
742:19 - work because the proxy is going to
742:22 - delegate all of its calls to the box
742:24 - contract
742:25 - typically if you put an abi on top of an
742:28 - address that doesn't have those
742:30 - functions that the api defines it would
742:31 - just error
742:32 - right but the proxy is actually going to
742:34 - delegate all those calls to the box
742:37 - so we could actually go ahead and try
742:40 - something like print
742:43 - proxybox dot
742:46 - retrieve hopefully that's about that
742:48 - right and even though
742:50 - we're using the proxy address here we
742:53 - are going to delegate the call
742:55 - to
742:56 - box so let's go ahead and run this so
742:58 - we'll do brownie run scripts
743:01 - deploy box it's going to deploy the box
743:04 - it's going to deploy the admin it's
743:06 - going to encode that initializer
743:08 - function which we've set to nothing then
743:10 - it's going to deploy our transparent
743:12 - upgradable proxy and then it's going to
743:14 - call
743:15 - retrieve
743:16 - on the transparent upgradable proxy
743:19 - instead of our box so let's do this
743:23 - and perfect we did it right it's
743:24 - returning zero here that's awesome what
743:27 - we could also do is we could also do
743:29 - proxybox.store
743:32 - one
743:33 - and then we'll call retrieve we'll see
743:35 - what happens here
743:38 - whoops it's yelling at me because i got
743:39 - to do
743:40 - from
743:43 - account
743:45 - now let's go ahead and run it
743:47 - and perfect see so after we stored on
743:50 - the proxy box on this proxy
743:52 - we're able to retrieve the value there
743:55 - so this is fantastic all right now that
743:57 - we've deployed it let's learn how to
744:00 - upgrade it we're going to change this to
744:02 - deploy
744:03 - and upgrade
744:05 - dot pi and we're just going to do
744:06 - everything in here so now that
744:08 - everything's deployed let's go ahead and
744:10 - now upgrade this so so now we can always
744:14 - point to this proxy box address and it's
744:16 - going to be the most recent upgrade it's
744:18 - always going to have the code that we
744:20 - want it to have so let's go ahead and
744:22 - upgrade from box that doesn't have that
744:25 - increment to box v2 that does indeed
744:28 - have this increment function so let's
744:29 - try this out so first thing we need to
744:32 - do is we actually need to deploy that
744:33 - box v2
744:34 - so we'll do box v2
744:36 - equals box
744:40 - b2
744:41 - dot deploy
744:45 - we'll save from
744:48 - account
744:49 - and we'll leave it like that of course
744:51 - we're going to have to import box v2
744:53 - from brownie
744:55 - and right now actually let's even do
744:57 - proxy box
744:59 - increment
745:02 - if we call boxy proc
745:04 - proxy box that increments from account
745:07 - this should error right it shouldn't be
745:08 - able to call this increment function
745:10 - because that doesn't exist
745:12 - oh and then we also change the name of
745:13 - the script sorry
745:15 - this is actually going to be
745:17 - deploy and upgrade
745:19 - and perfect we see it actually errors
745:21 - out here it says hey box object doesn't
745:23 - have this increment function you're
745:24 - crazy i don't know what you're talking
745:25 - about
745:26 - well good that's what we want to do
745:28 - so let's delete that line
745:30 - box v2 and we'll even do a quick little
745:34 - upgrade here
745:36 - now all we need to do is call
745:40 - an upgrade function now basically all we
745:42 - have to do is call this upgrade to
745:44 - function right but depending on if we've
745:47 - added a proxy admin contract if we're
745:49 - using initializer function there might
745:51 - be a couple of of different ways to go
745:53 - about this so i like to just wrap
745:55 - everything up into its own upgrade
745:57 - function you'll see what i mean in just
745:58 - a second so
746:00 - what i like to do again we're going to
746:01 - pop into our helpful scripts and we're
746:03 - going to create a new one called upgrade
746:06 - now for parameters in here of course
746:08 - we're going to take some type of account
746:09 - so that we have something to account
746:12 - to deploy from
746:14 - we're going to use the proxy which is
746:16 - again going to be that proxy contract
746:19 - which is going to be our proxy contract
746:21 - here we're going to need a new
746:24 - implementation
746:26 - address we're gonna need the proxy admin
746:31 - contract
746:33 - which could be none for us we're gonna
746:35 - have one but it could be none and then
746:37 - we're gonna have an
746:39 - initializer
746:40 - which also could be none
746:42 - and then we're going to have the args
746:43 - for the initializer which also could be
746:45 - known again this star
746:48 - is a special thing in python which says
746:49 - any number of arguments
746:51 - will just get stored into this list
746:53 - called args and perfect this is going to
746:55 - be our function that's just going to
746:56 - take care of everything for us so first
746:58 - thing let's check to see if there is a
747:00 - proxy admin contract
747:01 - so we'll say if
747:03 - there is a proxy admin contract
747:06 - then we want to check to see if there is
747:07 - an initializer
747:11 - what we're going to do is we're first
747:12 - going to want to encode that function
747:14 - data of course so we'll say encoded
747:18 - function call
747:20 - equals and code
747:22 - function data
747:23 - with the initializer
747:26 - and those star args
747:28 - this is going to be the encoded
747:30 - initializer function here
747:32 - then all we have to do and actually
747:34 - let's do start with a blank transaction
747:37 - equals none
747:38 - we'll say
747:40 - transaction
747:42 - equals
747:44 - proxy admin contract since we're using
747:46 - one of these proxy admin contracts since
747:47 - we've detected one
747:49 - dot
747:50 - upgrade and call since we also have an
747:53 - initializer
747:56 - we're going to pass the
747:57 - proxy.address
748:00 - new implementation address
748:03 - and the encoded function call and then
748:05 - of course
748:06 - from
748:08 - account
748:09 - so this upgrade and call if we look in
748:11 - that proxy admin
748:14 - there's this upgrading call function
748:16 - right on the proxy admin and it just
748:18 - calls upgrade to and call of the proxy
748:20 - contract
748:21 - so hopefully don't don't let this bog
748:23 - you down a little bit that there's kind
748:24 - of a lot of mix and matching going on
748:26 - but this is what's going on
748:28 - i'm sorry this is encoded function call
748:29 - not encoded function data
748:31 - great now if they don't have an
748:33 - initializer
748:35 - well what do we do well we don't need to
748:37 - encode any function call here we need to
748:39 - say
748:40 - transaction
748:41 - equals
748:42 - that proxy admin contract
748:44 - dot upgrade
748:46 - so it has an upgrading call it also just
748:49 - has a regular old upgrade so we'll just
748:51 - call upgrade
748:52 - and we'll give it the proxy.address
748:56 - the new implementation address
748:59 - and then
749:00 - from
749:02 - account
749:04 - now if it doesn't have a proxy admin
749:05 - contract this means that the admin is
749:07 - just going to be a regular old wallet
749:09 - well what do we do then well first
749:12 - check to see if it has an initializer
749:14 - still
749:15 - and if it does we need again
749:17 - to encode that function call we can just
749:19 - copy and paste that there and then once
749:21 - that's encoded we can just call directly
749:23 - off the proxy contract we're going to
749:25 - call exactly what the proxy admin
749:27 - contract is calling which can be
749:29 - proxy.upgrade
749:32 - to
749:33 - and call
749:35 - we're going to give it the new
749:36 - implementation address
749:38 - the encoded
749:39 - function call
749:42 - and then from
749:43 - account
749:45 - and let's wrap this all up in a big else
749:48 - so if proxy admin contract do this stuff
749:52 - else do this stuff
749:55 - if initializer do that otherwise we can
749:58 - just do
749:59 - transaction equals
750:01 - proxy dot
750:03 - upgrade 2 and we just add that new
750:05 - implementation address
750:08 - from
750:10 - account
750:12 - and then we'll finally return
750:14 - transaction
750:16 - so i know that there's a lot here but
750:18 - we're really just making this upgrade
750:20 - function really general we could always
750:22 - just know okay if we we we're going to
750:25 - use a proxy admin let's just do it like
750:26 - this okay no we're not going to use a
750:28 - proxy admin we're also not going to use
750:30 - an initializer great it would just look
750:32 - like this but this is essentially all
750:34 - that we have to do so now that we now
750:36 - that we have our upgrade function
750:38 - we can go ahead and use it here
750:41 - so we need to give it an account a proxy
750:43 - a new implementation address
750:45 - so we'll say account so we'll say
750:47 - upgrade
750:49 - transaction equals upgrade account
750:54 - we need a proxy and a new implementation
750:56 - address we're going to give it the proxy
751:01 - and we're going to give it
751:03 - box
751:05 - v2.address for that new address
751:10 - we do have a proxy admin contract
751:13 - so we'll say proxy
751:15 - admin
751:18 - contract equals
751:20 - proxy admin and we don't have an
751:23 - initializer so we can leave that part
751:25 - blank
751:27 - of course we need to import this upgrade
751:29 - function from our helpful scripts
751:32 - and this is all that we need so now we
751:34 - can do print
751:36 - proxy has been upgraded and what we
751:38 - could do now is we can do proxy box
751:41 - equals contract dot
751:44 - from abi
751:46 - we'll call it box v2
751:48 - we'll give it the proxy.address
751:51 - box v2.abi
751:54 - and now we should be able to call
751:55 - proxybox.increment
752:02 - from account and then we can print
752:07 - proxy box
752:08 - dot re
752:10 - retrieve
752:11 - and this should now be one and what
752:13 - we'll actually see is that this will
752:15 - return two
752:17 - why does it return two
752:19 - well in our original proxy box we stored
752:22 - one so it started with one we then
752:24 - upgraded to this new contract and then
752:27 - let's actually just do a
752:29 - wait of course
752:31 - we upgraded to a new contract
752:34 - right here
752:35 - however the storage of that contract
752:37 - stayed in the proxy so that one stayed
752:40 - in the proxy so even though we upgraded
752:42 - the contract
752:43 - there's still one stored at the location
752:46 - in storage so then when we call
752:47 - increment now and then we call retrieve
752:49 - it's gonna go from one to two so let's
752:52 - go ahead and run this
752:54 - brownie run scripts
752:56 - deploy an upgrade enter
752:59 - and boom that is exactly what we see
753:01 - output here this is an incredibly
753:03 - incredibly powerful and advanced feature
753:05 - and if you've gotten to this point you
753:07 - are on the border of being one of the
753:09 - most powerful smart contract engineers
753:11 - on the planet huge congratulations for
753:13 - getting this far but we're not quite
753:14 - done we of course need to write some
753:17 - tests because that is what's going to
753:19 - make sure our project always stays in
753:21 - sync and always stays up to date so
753:23 - let's write a couple of tests here so
753:24 - let's create a new file
753:26 - we'll call test
753:27 - box proxy dot pi
753:30 - and for this we're really just going to
753:31 - test to see that our contracts work
753:33 - we're going to see that this box
753:35 - actually is going to work correctly so
753:36 - let's create a new test
753:38 - def
753:39 - proxy
753:41 - delegates calls
753:44 - so we're going to make sure that we
753:46 - actually can delegate calls to our
753:47 - contract we're going to say account
753:49 - equals
753:51 - get account
753:53 - which means we have to do from
753:57 - scripts.helpfulscripts
754:00 - import get account
754:02 - then we're gonna do
754:03 - box
754:04 - equals
754:07 - box.deploy
754:09 - of course this is going to be from
754:12 - account
754:13 - since we're using box we're going to do
754:15 - from brownie import
754:18 - box
754:19 - we're going to do this proxy admin so
754:21 - we're going to say proxy admin
754:23 - equals proxyadmin.deploy
754:28 - of course from
754:32 - account
754:34 - let's import proxy admin from brownie
754:36 - all right so now we'll do the box
754:38 - encoded
754:40 - initializer function
754:43 - or whatever we call to perform this is
754:44 - going to be that encode
754:47 - function data which
754:49 - my vs code actually automatically
754:51 - imported thanks vs code
754:52 - and again we're leaving it blank
754:55 - because we're not actually going to have
754:56 - a store there and then we're just going
754:58 - to go ahead and run that deployment so
755:00 - we're going to say proxy equals
755:03 - transparent
755:04 - upgrade
755:06 - proxy
755:08 - and we're going to grab this from
755:10 - brownie dot deploy
755:14 - say again the box.address
755:17 - proxyadmin.address
755:21 - box encoded initializer function
755:25 - i'm going to say from
755:27 - account and then we'll give this a gas
755:29 - limit
755:32 - of
755:34 - two three one two three
755:36 - now we're gonna put the abi on top of
755:38 - this proxy so we're gonna say proxy box
755:41 - equals
755:43 - contract dot from abi
755:46 - we're gonna name it box
755:49 - this is going to be with the
755:50 - proxy.address
755:51 - [Music]
755:53 - and the box.api
755:56 - of course we're going to need to
755:58 - import contract from brownie
756:01 - and okay so now we can assert
756:04 - proxybox
756:07 - dot retrieve
756:09 - if i spot that right is equal to zero
756:12 - then we're going to do proxy box
756:15 - that's store
756:17 - we'll do one
756:19 - and this will be from account
756:22 - and then we're going to sir again
756:24 - this proxybox.retrieve
756:26 - should now equal 1.
756:28 - so we're using this proxy contract
756:31 - we've slapped the abi on top of it and
756:34 - this should work
756:36 - so we're just testing to see that our
756:37 - proxy is working correctly
756:39 - so we can go ahead and test this then
756:41 - with
756:42 - rounding test
756:44 - and beautiful it passed
756:46 - now let's go ahead and create a new
756:49 - script for testing the upgrades create a
756:52 - new file called test
756:54 - box v2 upgrades
756:57 - dot pi
756:58 - and let's do it
756:59 - called def
757:01 - test
757:02 - proxy upgrades
757:05 - so account
757:07 - it's gonna be equal to get account
757:09 - hopefully at this point you're getting
757:10 - pretty good at writing these these tests
757:12 - from
757:13 - scripts.helpfulscripts
757:16 - imports
757:17 - and of course we want to add this init
757:20 - dot pi just in case you forgot so now
757:23 - we're going to import get
757:24 - account perfect so we have our account
757:27 - here now as you can see we're doing a
757:28 - lot of this box equals box dot deploy
757:31 - deploy the proxy admin it would probably
757:34 - make sense in one of your scripts to
757:35 - just write a deploy three
757:37 - to write a function called like deploy
757:39 - all or something like that
757:41 - so again if you guys want to learn more
757:42 - if you want to improve upon this i would
757:44 - highly recommend you go back and you
757:46 - make some of those improvements to to
757:47 - really modularize this up but for the
757:49 - time being let's just keep going
757:51 - so box.deploy
757:55 - from
757:56 - account
757:58 - and since we're doing this we're going
757:59 - to do from
758:00 - brownie import box
758:02 - say proxy
758:04 - admin
758:05 - equals
758:07 - proxyadmin.deploy
758:10 - this will also be from
758:11 - [Music]
758:12 - account
758:15 - comma proxy admin
758:17 - we're going to get those initializer
758:19 - functions so we'll say box
758:21 - encoded
758:22 - initializer
758:24 - function
758:26 - equals encode
758:28 - function data which we're going to grab
758:30 - from our helpful scripts as well
758:32 - and then we're going to do the proxy
758:34 - again
758:36 - box equals transparent up
758:41 - gradable proxy
758:43 - that deploy
758:45 - we've got to import this from brownie as
758:47 - well oops not twice though
758:51 - deploy
758:53 - it's going to have the box that address
758:57 - proxy admin dot address
759:00 - box encoded initializer function
759:04 - from account
759:08 - gas limit
759:10 - one two three one two three
759:13 - all right
759:14 - so we have the proxy deployed we've
759:16 - already tested that this proxy works in
759:18 - this test box proxy so we're not going
759:20 - to go ahead and test that again
759:23 - what we're going to do instead now is
759:24 - now we're going to deploy
759:26 - box v2
759:28 - and we're going to update the proxy and
759:30 - make sure that everything still works
759:33 - so we're going to do box v2
759:35 - equals box v2
759:38 - dot deploy
759:40 - it's going to be from
759:41 - [Music]
759:43 - account of course
759:45 - now we're going to say proxy
759:47 - box
759:49 - equals
759:50 - contract.from api
759:54 - box v2
759:56 - proxy.address
760:00 - v2.abi
760:02 - and we're going to grab
760:05 - both this
760:07 - and this from brownie
760:10 - and what we're going to try to do
760:12 - is slapping this abi
760:14 - onto this proxy address we're going to
760:16 - try to call a function only box v2 can
760:18 - call
760:19 - however we know that
760:21 - like what we tested before it actually
760:23 - should revert
760:24 - so we can actually check for reverts by
760:27 - importing
760:30 - pi test
760:32 - and we can say
760:33 - with pi test
760:35 - dot
760:36 - raises
760:37 - and i know that
760:39 - this is a brownie exception i know what
760:40 - type of exception this is it's an
760:42 - exceptions dot virtual machine error
760:47 - you can figure out what type of error
760:48 - this is by
760:50 - just just running it and getting the
760:51 - error so this is actually from brownie
760:53 - this exceptions thing so we're going to
760:55 - actually also import exceptions from
760:57 - brownie we're going to say
761:00 - proxybox.increment
761:06 - from
761:07 - count
761:09 - and i saved and everything sorry got
761:11 - formatted here but calling
761:13 - proxybox.increment should throw this
761:16 - exceptions.virtual machine error so this
761:18 - test will pass if this throws an error
761:22 - and that's how we test that so we want
761:23 - this to throw an error the first time we
761:25 - call it then we're going to upgrade and
761:27 - then we'll call it again and it'll
761:28 - actually work
761:29 - now we're going to call upgrade
761:32 - on account
761:34 - proxy
761:35 - box v2
761:37 - proxyadmin
761:40 - contract equals
761:44 - proxy admin
761:47 - we're going to need to grab upgrade from
761:49 - our helpful scripts and now we should
761:52 - actually be able to
761:54 - call increment with our proxy box
761:56 - so first we'll do a quick assert
761:58 - proxy box dot
762:01 - retrieve equals zero
762:03 - then we'll do proxy proxybox.increment
762:11 - from
762:13 - account
762:14 - and then we'll assert
762:16 - proxybox dot retrieve
762:20 - is
762:21 - one so we're deploying our box we're
762:23 - deploying our proxy and everything
762:25 - around it
762:26 - then we're deploying our v2
762:28 - implementation
762:29 - we're trying to call increment which
762:31 - won't work we then upgrade our proxy to
762:34 - this new address
762:36 - and then we can go ahead
762:38 - and call
762:39 - increment and it should actually
762:41 - increment our box here
762:42 - so let's go ahead and run this test
762:44 - brownie run test
762:47 - excuse me
762:48 - ronnie test dash k
762:51 - grab this paste it in
762:55 - and we've done it our tests are working
762:57 - correctly so we know that our box is
762:59 - working correctly
763:01 - awesome great job like i said this is an
763:04 - incredibly incredibly powerful feature
763:05 - to be able to do these upgrades with
763:08 - these there comes a lot of risk at least
763:10 - in the form of centralization risk if
763:12 - you're the only wallet that controls the
763:15 - proxy that means your application is
763:18 - centralized full stop so if you're going
763:20 - to deploy anything with proxies to
763:22 - mainnet
763:23 - absolutely absolutely be sure to get it
763:25 - audited beforehand
763:27 - now before we close this project up
763:28 - let's actually deploy this to an actual
763:30 - test snap
763:32 - so that we can see everything that goes
763:34 - on when we call this deploy and upgrade
763:36 - let's go ahead and do it
763:38 - so
763:39 - let's pop into our emv file
763:41 - and let's paste the variables that we
763:43 - have in here we need the private key web
763:46 - three inferior project id the ether scan
763:48 - token
763:49 - awesome
763:50 - let's even
763:51 - let's even publish the source of all
763:54 - these contracts so that we can see them
763:55 - on etherscan
763:57 - so for box we'll do a little comma here
763:59 - we'll say publish
764:01 - source equals true
764:03 - i'm just going to copy this comma to
764:05 - publish source equals true
764:06 - and paste it on all of my deployments
764:12 - over source equals true
764:15 - publish source equals true on the
764:17 - on the admin
764:19 - on the initial transparent upgradable
764:21 - proxy
764:23 - on the box v2 deployment
764:25 - and that's it
764:26 - i've got my ether scan token my web 3
764:28 - and fira my private key my brownie
764:30 - config is indeed pulling from the
764:32 - private key my env has env let's check
764:36 - to see my wallet
764:37 - we have some rink being here perfect
764:40 - let's do this
764:42 - brownie run scripts
764:44 - deploy and upgrade
764:46 - network
764:48 - rink
765:03 - all right so it looks like a couple of
765:04 - our contracts weren't able to actually
765:06 - verify there are a couple bugs being
765:08 - worked out with some of the verification
765:09 - so we're going to ignore the ones that
765:11 - weren't able to be verified here but
765:12 - let's go ahead grab these addresses pop
765:14 - them onto the rink etherscan and see
765:17 - what just happened
765:18 - this is our box implementation let's
765:20 - grab this address let's paste it into
765:22 - the rinkby testnet ether scan awesome
765:25 - this is exactly what we have contract
765:27 - has been verified this is exactly the
765:29 - code that we have here
765:30 - and we can see all we have is a contract
765:33 - creation and this is exactly correct
765:35 - because when we call
765:37 - the store function on this it's actually
765:40 - going to get stored we never actually
765:42 - called any functions directly on this
765:44 - contract all we did was deploy it which
765:46 - makes perfect sense let's go check out
765:48 - this proxy admin now
765:50 - this second address
765:53 - the second counter that we deployed
765:55 - sadly this one didn't get
765:57 - verified however we can see we did
765:59 - indeed call this upgrade function at
766:02 - some point
766:03 - which makes a lot of sense
766:05 - if we look at our script
766:06 - proxy admin
766:08 - in our upgrade code since we did have a
766:10 - proxy admin contract we did call that
766:12 - upgrade function
766:13 - perfect makes sense now let's go to this
766:16 - transparent upgradable proxy this is
766:19 - going to be the most interesting one out
766:21 - of all of our
766:23 - applications
766:24 - interestingly enough we look at this
766:26 - contract we can see store in increment
766:28 - both have been called on this contract
766:32 - not on the box because again this is the
766:34 - proxy that we're going to call all the
766:36 - functions on to make our contracts
766:38 - upgradable internal transactions are
766:41 - calls that another smart contract made
766:43 - to this transaction and if we look at a
766:45 - couple of these
766:47 - we can see if we click more
766:49 - we had increment called from another
766:51 - contract which makes sense we had
766:53 - upgrade called from the proxy admin
766:57 - and then we also of course we had store
766:59 - called from another contract and if we
767:01 - verified this we would be able to see
767:03 - etherscan recognize this as a proxy
767:05 - contract as well hopefully when you work
767:07 - with this you'll be able to verify it as
767:09 - well but if not not a big deal you can
767:11 - always just manually do it later
767:12 - yourself so this was an incredibly
767:14 - powerful project that we just did here
767:16 - and that we worked on and all right
767:19 - maybe take a nap maybe go for a walk get
767:21 - some food get a drink because we are on
767:23 - to our last coding project now i do want
767:26 - to say that this project is considered a
767:28 - bonus because we're going to be going
767:30 - very quickly over the front end pieces
767:33 - we're going to take all the building
767:34 - blocks that we've learned and build an
767:36 - amazing full stack application gear up
767:39 - get ready let's jump into this bonus
767:41 - project and then after we finish this up
767:44 - we're going to close everything out with
767:45 - a final quick section about security the
767:49 - future and and thank you for joining
767:51 - this course so let's do this last one
767:57 - all right now we are moving on to our
768:00 - final project this is going to be the
768:03 - most advanced products and combine all
768:06 - the knowledge that we've learned so far
768:08 - into one project
768:09 - then we're additionally going to put a
768:11 - front end or a user interface onto this
768:14 - project when we build our own
768:15 - applications we're going to need a way
768:17 - for non-devs to actually interact with
768:19 - it in a meaningful way so now this isn't
768:22 - a front end or react tutorial course
768:25 - although we will be explaining some of
768:27 - the choices that we've made and how to
768:29 - actually do them you should be able to
768:30 - follow along fine even if you don't have
768:32 - any front end experience here if you're
768:34 - looking for a full front end tutorial
768:36 - free code camp has some amazing videos
768:38 - that you can absolutely try out all
768:40 - right welcome back everybody and now
768:43 - we're going to be embarking on the most
768:45 - exciting the most end to end we're going
768:48 - to take everything that we've learned
768:50 - and wrap it all together in this single
768:53 - last application here and we're also
768:56 - going to be learning about front end
768:58 - development we're going to be building a
769:01 - front end on top of our application on
769:03 - top of our contracts here now this isn't
769:06 - a front end tutorial however free code
769:08 - camp has some wonderful wonderful react
769:10 - tutorials we're going to be teaching you
769:12 - guys just enough so that you can go
769:13 - ahead jump in and build your own simple
769:16 - but also kind of nice looking front ends
769:18 - on top of whatever contracts that you
769:21 - have
769:22 - for those of you who want users to
769:23 - actually interact with your applications
769:25 - and interact with your contracts
769:26 - building a usable front end is a really
769:28 - important piece so let's take a quick
769:31 - walkthrough of what this application is
769:32 - going to look like so here is our our
769:35 - front end here and what this application
769:37 - is going to allow users to do is it's
769:39 - going to allow users to stake or deposit
769:42 - their tokens into what's called our
769:44 - token farm contract once they have some
769:46 - token deposited that's when you can kind
769:48 - of go get creative with what you want
769:49 - those tokens to do
769:51 - you could use it as staking in some
769:52 - governance you could use it to you could
769:54 - go ahead and invest it in something like
769:56 - ave or another d5 protocol to gain
769:58 - interest you could build a yield
770:00 - aggregator there's a ton a ton of
770:02 - different features that you can actually
770:03 - do once you have users stake their
770:05 - tokens and here's how they would do it
770:07 - on their ui side so we have this little
770:09 - button here which we go ahead and click
770:11 - connect on metamask is going to pop up
770:14 - and we're automatically going to sign in
770:17 - that's going to connect our meta mask to
770:20 - this user interface now so if i look at
770:23 - my meta mask i'm on the coven test
770:25 - network we can see that i am indeed
770:26 - connected now what i can do
770:28 - is i can now stake some of my tokens
770:31 - into this contract we currently have
770:34 - three different types of tokens that
770:35 - this platform allows you to stake
770:37 - wrapped ether
770:39 - fiu which is mimicking die on the test
770:41 - network and our dap token this dap token
770:45 - is going to be the reward token that our
770:47 - platform gives users as an incentive for
770:49 - staking on our platform once we stake we
770:52 - can actually then unstake and that's
770:54 - really it
770:55 - so we'll go ahead and stake maybe we'll
770:56 - stake 10 dap we'll hit stake metamask
771:00 - will pop up this is the approve function
771:02 - this first approved function that gets
771:04 - called we get a really nice little
771:07 - waiting
771:08 - bar here and once it's been approved we
771:10 - get a notification saying the transfer's
771:12 - unapproved we then go ahead and we'll
771:15 - confirm staking we'll get this little
771:17 - loading bar while it's being staked and
771:19 - we'll see that pop-up that says tokens
771:21 - staked successfully
771:23 - now if we go to the token farm contract
771:25 - we can see that we have 10 of this dap
771:28 - token state
771:30 - we can also unstake it the other thing
771:32 - that we can do is as admins of this
771:34 - wallet we can actually issue a reward
771:37 - to our users based on how much they've
771:38 - staked so you see right now we have 95
771:40 - dap token
771:42 - we have 10 dap tokens staked on the back
771:45 - end i'm going to run an issue token
771:47 - script it's going to send all users that
771:49 - have some stake a little bit of a dap
771:51 - token reward now you can see it's been
771:54 - updated
771:56 - and we have we've been given a little
771:58 - bit of dap token that resembles the
772:00 - amount of dap token that we have staked
772:03 - the way that we figure out the value of
772:05 - all of our different tokens is using of
772:07 - course chaining price feeds we can then
772:09 - of course unstake everything
772:13 - and we see tokens unstaked successfully
772:16 - and that's it and this is what we're
772:17 - going to build now we aren't going to go
772:19 - over the unstaking portion of the front
772:21 - end application here right here's what
772:23 - it would look like if you were to go
772:24 - ahead and finish building out the front
772:25 - end yourself there is a full repository
772:27 - with the entire front end with this
772:29 - unstaking piece but for simplicity we're
772:31 - just going to skip over this unstaking
772:33 - bit so let's go ahead and get started
772:35 - i'm going to go ahead and make a new
772:36 - directory called defy
772:39 - stake
772:40 - yield
772:42 - brownie
772:44 - and then i'm going to open
772:46 - this up in a new text editor now the
772:48 - first thing of course that we want to
772:50 - work with
772:51 - is going to be our contract so we're in
772:53 - here remember
772:54 - always start with brownie init
772:56 - or you can start with the chain link mix
772:58 - i'm just going to go ahead and start
772:59 - with brownie unit and perfect here is
773:02 - our setup all right first thing we're
773:03 - going to do is we're going to make our
773:07 - app token dot sol
773:09 - this is going to be the token that we're
773:10 - going to give out to users who are
773:13 - staking on our platform this is our
773:14 - reward token you might have heard of
773:16 - yield farming or liquidity mining this
773:18 - is our token that allows users to
773:19 - actually engage and participate in that
773:22 - and this is just a regular old erc20 so
773:25 - you guys already know we've done this
773:26 - before and for this one we're even going
773:28 - to use the latest and greatest in
773:30 - solidity remember i said that you're
773:31 - going to have to get really good at
773:33 - bouncing around between solidity
773:34 - versions so for this one we're going to
773:36 - do everything in 0.8
773:39 - so let's go ahead and do that so we're
773:41 - going to do pragma
773:44 - solidity
773:47 - 0.8.0
773:50 - and we're going to do this the exact
773:51 - same way we made our other erc20 token
773:54 - we're going to go ahead and use open
773:56 - zeppelin again we can even just copy
773:58 - paste the import from their
774:00 - documentation or we can just write it
774:02 - out
774:03 - import
774:04 - at open zeppelin
774:07 - contracts slash token
774:10 - erc20
774:11 - erc20.sol
774:14 - and you guessed it because we're using
774:16 - this at opens up on syntax we're gonna
774:18 - make a new file
774:21 - routing config.yaml
774:23 - we're gonna make some dependencies
774:26 - we'll do open
774:29 - zeppelin slash open
774:31 - [Music]
774:32 - zeppelin
774:34 - contracts
774:35 - this time we're going to actually use
774:37 - version 4 of these
774:39 - at 4.2.0
774:41 - and again you can find out everything
774:42 - about this package by going to opens up
774:44 - when slash opens up on contracts on
774:46 - github and then compiler
774:49 - sulk
774:52 - remappings
774:55 - at open
774:57 - zeppelin
774:58 - equals
775:01 - this part right here
775:03 - paste it in okay
775:05 - great
775:06 - then what we can do
775:08 - we can go back to our dap token and just
775:10 - do some basic erc20 bits here
775:12 - so do contract
775:14 - dap token
775:15 - is erc20
775:17 - and we'll give it our constructor
775:19 - public
775:22 - erc20
775:25 - we'll call it
775:29 - depth token and we'll give it a symbol
775:31 - of dep
775:32 - and we'll give it an initial supply as
775:34 - well
775:35 - so we'll call the mint function
775:38 - and we'll set the
775:40 - meshes.sender as the owner give it an
775:43 - initial supply of one million which will
775:44 - be one one two three one two three plus
775:47 - those eighteen zeros so one two three
775:49 - four five six seven eight nine ten one
775:51 - two three four five six seven eight
775:54 - and now that we have our first contract
775:56 - we can try to compile it
775:57 - ronnie
775:59 - compile
776:01 - and looks like it worked great
776:04 - now we're gonna go on and to create our
776:06 - more interesting contract
776:09 - our token farm
776:11 - we can even take a quick second and
776:13 - figure out what we want this to be able
776:14 - to do
776:15 - well we want to be able to stake tokens
776:19 - tokens
776:21 - issue tokens this is going to be issuing
776:22 - those token rewards
776:25 - we're probably going to want to add
776:27 - allowed
776:28 - tokens to add more tokens to be
776:31 - allowed to be staked on our contract
776:34 - and we're probably going to want some
776:35 - type of
776:36 - get f value function where we can
776:38 - actually get the value of the underlying
776:40 - stake tokens in the platform with that
776:43 - in mind let's move on so
776:46 - you know the drill pragma solidity
776:49 - carrots 0.8.0
776:52 - and we're going to be here for a while
776:53 - so i'm going to close those out
776:56 - and this will be our contract
776:59 - token farm
777:01 - contract token farm oh and let's not
777:03 - forget
777:04 - our s
777:06 - pdx
777:09 - license
777:10 - identifier
777:13 - of mit well let's go ahead and start
777:15 - with the staking of the tokens right
777:16 - because that's going to be the most
777:18 - important piece of our application so
777:21 - we're going to do function
777:24 - state tokens
777:25 - you'll probably want to stake
777:27 - an amount of token
777:30 - and they'll probably want to stake
777:33 - a certain address of the token
777:35 - so
777:36 - some amount of some token
777:39 - now there's a couple things we need to
777:40 - keep in mind here what tokens can they
777:42 - stake
777:48 - how much
777:49 - can they stake
777:51 - so these are our first two questions
777:53 - for our application we're just going to
777:55 - say you can stake any amount greater
777:56 - than zero so we can even add that we'll
777:58 - do require
778:01 - amount
778:02 - is greater than zero
778:04 - and if it's not we'll just say
778:06 - amount
778:07 - must be more
778:09 - than zero
778:12 - since we're using version 8 we don't
778:14 - have to worry about anything to do with
778:16 - safe math which is awesome so we can
778:18 - just go ahead and do stuff like this we
778:20 - now we only want certain specific tokens
778:22 - to be staked on our platform so we could
778:24 - say require token
778:27 - is allowed
778:29 - or something to this effect so we might
778:30 - have to actually create a token is
778:32 - allowed function
778:33 - so let's go ahead and create that
778:35 - function
778:38 - token is
778:40 - allowed
778:42 - it'll take
778:43 - some token address make it a public
778:45 - function and it'll return
778:47 - a boolean it'll return true if that
778:49 - token's allowed or false if it's not
778:51 - allowed so how do we know if a token is
778:53 - actually allowed we probably want some
778:55 - list or some mapping of these tokens and
778:58 - whether or not they're allowed after all
779:00 - we've learned you'll probably learn that
779:01 - there definitely are some trade-offs
779:03 - between lists and mappings here for
779:05 - simplicity's sake we're just going to
779:06 - stick with a list for now
779:08 - so we're going to create an address
779:10 - array
779:12 - we'll make it public
779:14 - called allowed token
779:17 - and this will just be a list of all the
779:19 - different allowed tokens
779:21 - for our token is allowed function we'll
779:23 - just loop through this list and see if
779:25 - that token is in there
779:27 - so we'll do a for loop
779:30 - four
779:32 - uint256
779:34 - allowed tokens index
779:36 - equals zero
779:38 - allowed tokens index
779:40 - is less than
779:41 - [Music]
779:42 - allowed tokens dot length
779:47 - allowed tokens index plus plus
779:51 - so we're going to loop through this list
779:53 - and we're just going to say if
779:56 - allowed tokens
779:59 - of allow token index
780:02 - equals equals
780:05 - this token
780:08 - then we're going to return
780:10 - true
780:12 - otherwise if we get through this whole
780:14 - for loop and we don't find this token in
780:17 - here we're just going to return false
780:20 - now we have a way to check to see if
780:21 - allowed tokens are there let's actually
780:23 - write a function to add aloud tokens
780:26 - so we can do function
780:27 - add aloud tokens
780:30 - address token
780:32 - public function and we'll do allowed
780:35 - tokens and we'll just push
780:38 - it onto that array now adding allowed
780:41 - tokens is probably something we only
780:42 - want the admin wallet or the owner of
780:44 - this contract to do so we'll add only
780:47 - owner
780:48 - as a modifier to this function and we'll
780:51 - make this token farm ownable is
780:54 - ownable and we'll import from open
780:57 - zeppelin here too
780:58 - import at open
781:01 - zeppelin
781:02 - contracts slash access
781:05 - ownable.soul
781:07 - let's do a quick compile
781:12 - great things are being compiled
781:14 - fantastically now that we have a little
781:15 - bit of functionality here now might be a
781:17 - good time to actually go ahead and start
781:19 - writing some tests if you want to since
781:21 - i know that we're going to change the
781:23 - constructor a little bit and we're going
781:24 - to change a little bit of how this is
781:26 - actually formatted i'm just going to
781:27 - keep going but now might be a great time
781:30 - should i start writing some tests for my
781:31 - application
781:32 - you know we're going to do those tests
781:34 - later on anyways though all right great
781:36 - but in any case now that we have these
781:37 - two functions we can go ahead and
781:39 - actually start checking to see if the
781:41 - tokens that these stakers are going to
781:42 - stake is actually allowed
781:44 - so what we can do now is we're going to
781:46 - add this require statement in we can
781:48 - require token
781:50 - is allowed
781:52 - of token
781:54 - otherwise we'll just say token
781:56 - is currently
781:58 - not allowed
782:02 - and perfect now we have two required
782:04 - statements that answer these questions
782:05 - what tokens can they stake
782:08 - and how much can they stake so now all
782:10 - we have to do is we just have to call
782:13 - the
782:14 - transfer from function on the erc20
782:17 - remember erc20 remember erc20s have
782:20 - these two transfer type functions they
782:22 - have transfer and they also have
782:24 - transfer from
782:26 - transfer only works if it's being called
782:28 - from the wallet who owns the tokens if
782:31 - we don't own the token we have to do
782:33 - transfer from and they have to call
782:35 - approve first so we're going to call the
782:37 - transfer from so we're going to call the
782:39 - transfer from function on the erc20
782:42 - since our token farm contract isn't the
782:45 - one that owns the erc20 we also have to
782:48 - we also have to have the avi to actually
782:51 - call this transfer from function so
782:53 - we're going to need
782:54 - the ierc20 interface we could go ahead
782:57 - and pop it in here we could also make it
782:59 - near c20 contract we could also just
783:01 - grab it from openzep1
783:03 - so we'll do import
783:05 - at open
783:06 - zeppelin contracts slash token slash
783:10 - erc20
783:11 - ierc20.sol
783:14 - we're using the interface here because
783:16 - we don't need the whole contract anyways
783:18 - let's now wrap ier c20 let's wrap this
783:21 - token address
783:23 - as an erc20 token so now we have the abi
783:27 - via this interface and the address
783:30 - and we'll call that transfer
783:34 - from
783:36 - from the message.sender
783:39 - and we'll send it
783:44 - to this token farm contract so from
783:47 - whoever calls stake tokens
783:49 - to this token farm contract
783:52 - and we'll send the amount
783:55 - and perfect now we just need to keep
783:57 - track of how much of these tokens
783:59 - they've actually sent us so we're going
784:02 - to want to create
784:03 - some type of mapping here
784:05 - and this mapping is going to map token
784:08 - address
784:10 - to
784:12 - sticker address
784:13 - to
784:14 - the amount this way we can keep track of
784:17 - how much of each token each staker has
784:21 - staked
784:22 - so it's a mapping per token per staker
784:25 - per amount
784:26 - so we'll just call this
784:28 - mapping of that token address
784:32 - which is going to get mapped to
784:35 - another mapping
784:37 - of those
784:39 - user addresses which then gets mapped to
784:42 - a uni-256 so we're mapping the token
784:45 - address to the staker address to the
784:48 - amount we'll make this a public mapping
784:52 - we'll call it
784:55 - staking balance now that we have this
784:57 - mapping
784:58 - in our state token function
785:00 - what we can do is we can say staking
785:02 - balance of this token
785:05 - from message.sender
785:08 - is now going to equal whatever balance
785:10 - that they had before plus
785:14 - the amount
785:15 - all right this is great now we have a
785:16 - way for users to stake different tokens
785:19 - that we've actually allowed them to
785:21 - stake on our platform awesome work so
785:23 - what do we want them to be able to do
785:24 - next we want them to unstate tokens we
785:27 - want to be able to issue some reward we
785:29 - want to be able to get the eth value
785:31 - based on that reward typically you might
785:33 - want to do this unstake tokens bit first
785:35 - however i know that we're actually going
785:37 - to need some additional functionality in
785:40 - our state tokens function for us to
785:42 - actually issue tokens properly so let's
785:44 - just go ahead and do this issue tokens
785:46 - bit remember this issue tokens is a
785:48 - reward we're giving to the users who use
785:50 - our platform so we want to issue some
785:53 - tokens based off the value
785:55 - of the underlying tokens that they've
785:57 - given us
785:58 - so for example
786:00 - maybe
786:01 - they've deposited 100 eth and we want to
786:04 - do
786:06 - a ratio of one to one
786:08 - for every one each
786:12 - we give one depth token
786:14 - that's pretty easy for us to figure out
786:16 - however let's say they have 50 each and
786:18 - 50 die staked and we want to give a
786:22 - reward of
786:24 - one dap
786:27 - one dapp token
786:28 - per one die
786:31 - well then we'd have to convert all of
786:32 - our eath into die so we know that
786:35 - conversion ratio for the dap token so
786:38 - that's the problem that we're going to
786:39 - work on now let's create this function
786:41 - called issue tokens
786:44 - and this
786:46 - is going to be a function only callable
786:48 - again by the owner
786:51 - or the admin of this contract so how do
786:54 - we actually go ahead and issue tokens
786:55 - here well the first thought would be to
786:58 - loop through a list of all the stakers
787:00 - that we have but right now we don't have
787:02 - a list of stakers what do we have we
787:05 - have a mapping of stakers and we have a
787:07 - list of allowed tokens well we're
787:10 - probably going to need to have a list of
787:12 - stakers so we'll do an address array
787:15 - because again we can't loop through a
787:17 - mapping so we'll do an address array
787:19 - we'll make it public
787:21 - called stakers
787:23 - this is just a list of all the different
787:25 - stakers on our platform now when
787:27 - somebody stakes a token
787:29 - we're going to have to update this
787:31 - list
787:32 - we want to make sure they're only added
787:34 - if they're not already on the list
787:36 - so in order for us to do this we should
787:38 - get an idea of how many unique tokens a
787:41 - user actually has
787:43 - so i'm going to create a function called
787:45 - update
787:46 - unique
787:48 - tokens staked
787:50 - with message.sender
787:52 - and the token
787:54 - and what this function is going to do
787:56 - it's going to get a good idea of how
787:58 - many unique tokens a user has
788:00 - and if a user has one unique token we
788:03 - can add them to the list
788:05 - if they have more than one we know that
788:08 - they've already been added to the list
788:09 - so we don't need to add them there
788:11 - so let's create this
788:12 - function update unique token state
788:16 - we'll have it input an address
788:19 - user
788:21 - and an address
788:23 - token
788:24 - and we'll make this
788:27 - an internal function
788:29 - so that only this contract can call this
788:31 - function and what we'll say is if
788:37 - staking balance
788:41 - let's even do a little underscores here
788:46 - of token
788:50 - of user
788:51 - is less than or equal to zero
788:54 - we're going to update some unique tokens
788:56 - staked mapping so we'll say unique token
788:59 - staked
789:01 - of the user
789:03 - it's going to equal
789:04 - the unique token staker of the user
789:06 - plus one and since we have this new
789:08 - mapping called unique token staked we'll
789:11 - make that as well
789:13 - so we'll do a mapping
789:16 - of an address
789:18 - to
789:19 - the un256
789:22 - public called unique tokens state so
789:25 - this way we know how many different
789:26 - tokens each one of these addresses
789:28 - actually has staked now that we have a
789:30 - better idea of the unique tokens each
789:32 - one of these users has staked what we
789:34 - can do
789:35 - is we can figure out whether or not we
789:37 - want to push them onto this stakers list
789:39 - if they're already on there we don't
789:41 - want to push them on there if they're
789:42 - not on there then we do want to push
789:44 - them on there so we can just do is say
789:46 - if unique token staked
789:49 - of
789:50 - message.sender
789:52 - it's equal to one if they have one
789:55 - unique token state if this is their
789:57 - first unique token we're going to add
789:59 - them to that stakers list so we'll say
790:01 - stakers.push
790:04 - message.sender and this is going to be
790:07 - our completed sake tokens function here
790:09 - so we had to add this little extra
790:11 - functionality between the unique tokens
790:14 - to figure out how to actually issue some
790:16 - reward for them but now that we have
790:17 - this list and it's going to get updated
790:19 - here
790:20 - and it will also get updated when we
790:22 - unstake
790:23 - what we can do now is just loop through
790:25 - this list of stakers so we can say 4
790:29 - unit 256
790:31 - staker's index equals zero
790:34 - stakers index is less than stakers dot
790:38 - length
790:39 - stakers index
790:41 - plus plus
790:42 - and now we're going to issue some of
790:44 - these tokens here so we're going to say
790:46 - the address
790:49 - recipient
790:50 - equals stickers
790:54 - stakers index so one at a time we're
790:56 - going to loop through grab these
790:57 - recipients and then we're going to send
790:59 - them
791:02 - a token reward
791:05 - based on their total
791:08 - value locked
791:10 - so we got to do a couple things here we
791:12 - have to send them a token reward we have
791:14 - to figure out how to actually send them
791:16 - this token and then we also have to get
791:18 - their total value locked
791:20 - so let's do this to send them a token
791:22 - reward this is going to be this dap
791:24 - token that we created in the beginning
791:26 - this is going to be our dap token so
791:28 - right when we deploy this contract we
791:30 - need to know what a reward token is
791:33 - actually going to be so we can do
791:35 - right at the top and then i'm actually
791:36 - going to
791:38 - i'm actually just going to move this
791:39 - array
791:41 - up here so that they're all kind of
791:42 - nicely together what we need to do
791:44 - is we need to create a constructor
791:47 - right when we deploy this contract we
791:48 - need to know what is the address of the
791:51 - dap token what's the address of the
791:52 - reward token that we're going to give
791:54 - out
791:54 - so we can say constructor it will be
791:56 - passed an address of the dap token
791:59 - address
792:01 - this will be a public function
792:03 - and
792:04 - we'll store this dap token as a global
792:06 - variable
792:07 - so we can say
792:09 - ierc20 since we're already importing it
792:12 - here
792:13 - public
792:15 - dap token
792:17 - what we can do now is set depth token
792:20 - equals ierc20
792:22 - underscore
792:24 - dap token address so now we have this
792:27 - dap token with its associated address
792:30 - and what we can do now
792:32 - is call functions on it for example we
792:34 - can call
792:36 - dap token
792:37 - dot transfer
792:39 - we can call transfer here because our
792:40 - token farm contract is going to be the
792:42 - contract that actually holds all these
792:44 - dap tokens and we're going to send this
792:46 - token to
792:50 - the recipient of course
792:52 - but how much are we going to send right
792:54 - how much this of this token
792:57 - are we going to send to them well we
792:59 - need some function to get the total
793:00 - value so we're going to say u and 256
793:04 - use your total value
793:06 - equals
793:07 - some function
793:08 - right and we can go ahead and define
793:10 - that right now we'll call this function
793:13 - get user total value right or get
793:15 - recipient total value or whatever you
793:17 - want to say
793:18 - so we'll pop recipient in here and let's
793:20 - go ahead and create this function so
793:22 - we'll call function get user
793:24 - total
793:26 - value
793:27 - address
793:29 - user
793:31 - and this is where we do a lot of looping
793:33 - right we're gonna we gotta find out how
793:35 - much each of these tokens actually has
793:38 - now what a lot of protocols do instead
793:40 - of actually them sending and them
793:42 - issuing the tokens is they actually just
793:43 - have some internal method that allows
793:45 - people to go and claim their tokens
793:47 - right you've probably seen that before
793:49 - people claiming airdrops that's because
793:50 - it's a lot more gas efficient to have
793:52 - users claim the airdropped instead
793:55 - of the application actually issuing the
793:57 - tokens right it's going to be very gas
793:59 - expensive to do looping through all
794:01 - these addresses and checking all these
794:02 - addresses right we're going to do it
794:04 - though because we are a wonderful
794:07 - amazing protocol and we want to give our
794:09 - users the best experience but in any
794:11 - case this is going to be a public view
794:13 - function
794:14 - that will return
794:15 - a uin256 right because we want to return
794:19 - this total value to our issue tokens
794:22 - function up here so how do we actually
794:24 - get started here well let's create
794:27 - a unit 256
794:29 - total value
794:31 - and we'll set it off to start it to be
794:33 - zero here and let's even start it off
794:36 - with a quick require statement right we
794:38 - want to require
794:40 - that the unique
794:41 - token state
794:43 - of this user
794:45 - going to be greater than 0
794:47 - right and if it's not we'll say
794:50 - they don't have any tokens state right
794:51 - so the value is going to be nothing
794:53 - now if this is true
794:55 - if they have some token staked
794:57 - we'll go ahead and find it so we're
794:59 - going to loop through those allowed
795:01 - tokens up here
795:03 - the allowed tokens and we're going to
795:04 - find how much this user has for each one
795:06 - of these allowed tokens
795:08 - so we're going to say 4
795:10 - uint
795:11 - 256
795:12 - allowed tokens index
795:14 - equals zero allowed tokens index is less
795:18 - than allowed tokens dot length
795:21 - allowed tokens index plus plus
795:25 - and let's go ahead and we'll add the
795:28 - total value and now we'll say the total
795:30 - value is going to be equal to
795:33 - the total value plus
795:35 - however much
795:37 - value this person has in these tokens in
795:39 - this single token so get user total
795:41 - value is the total value across all the
795:44 - different tokens we need a way to get
795:45 - the total value across one token so
795:48 - we're going to create a new function
795:49 - called get
795:50 - user single token
795:53 - value
795:54 - and we'll pass it our user
795:57 - and we'll also pass it the single token
796:00 - that we're on right now so we'll pass it
796:02 - allowed tokens
796:04 - allowed token index
796:07 - so we got to create a new function here
796:09 - function get user single token value
796:12 - this is going to take an address of a
796:15 - user and an address of a token
796:18 - it's going to be a public function
796:20 - i'm just going to put this on a new line
796:21 - to make it a little easier to see it's
796:24 - going to be a view function
796:26 - and it's going to return
796:28 - a u in 256. we want to get the value of
796:31 - how much this person staked of this
796:33 - single token
796:34 - so for example if they've staked
796:37 - one each
796:39 - and the price of one eath is two
796:41 - thousand dollars we wanna make sure that
796:43 - this returns two thousand
796:46 - or if they have two hundred die stakes
796:48 - and the price of two hundred die is two
796:50 - hundred dollars we want to make sure
796:52 - this returns 200 right so we're getting
796:56 - that conversion rate we're getting
796:57 - exactly how much value this person has
796:59 - staked in our application now we'll do a
797:02 - quick if we'll say if
797:06 - token staked
797:08 - of the user
797:09 - is less than or equal to zero
797:12 - then we'll just go ahead and return zero
797:14 - right we don't want to do a require here
797:17 - right as we did up here because we want
797:21 - this to actually keep going right if
797:22 - this is zero we don't want the
797:24 - transaction to actually revert okay we
797:27 - want this to keep going so how do we
797:29 - actually get
797:30 - the value of a single token well we're
797:32 - going to need to get the staking balance
797:34 - right but we also need the price of that
797:36 - token so we're going to need to get the
797:38 - price of the token
797:40 - and then multiply that
797:42 - by the staking balance
797:44 - of the token
797:46 - of the user so once again we need to
797:49 - create another function we'll call this
797:51 - one
797:52 - get token value
797:54 - so in another function
797:57 - we're going to call get token value
798:00 - you could pass an address of a token
798:03 - we'll make this a public view function
798:06 - that will return
798:07 - a uin256
798:10 - and this of course is where we need some
798:12 - pricing information and this is where
798:14 - we're going to actually work with the
798:15 - chain link price feeds once again and
798:18 - hopefully this part is going to be a
798:19 - little bit more familiar for you
798:21 - so what we're going to need is a price
798:23 - feed
798:25 - address that's the first thing that
798:27 - we're going to need so we're going to
798:28 - actually have to map each token to their
798:30 - associated price feed addresses so we're
798:33 - going to need some mapping that does
798:34 - that right so we're going to need some
798:35 - mapping
798:36 - that's going to map
798:38 - an address
798:40 - to
798:41 - an address
798:43 - it's going to be a public one and this
798:44 - is going to be token
798:46 - price feed
798:47 - mapping right it's going to map the
798:49 - token to their associated price feeds
798:52 - and with that that means we're going to
798:54 - have to have a function
798:56 - called set
798:57 - price feed contract
798:59 - where we actually set the price feed
799:02 - associated with
799:03 - a token
799:04 - so this will take an address of a token
799:08 - and an address
799:09 - of a price fee
799:11 - this will be a public and this will be
799:13 - only owner
799:15 - we don't want anybody to be able to set
799:18 - what these price feeds should be we just
799:20 - want the owner to be able to do this
799:22 - so we'll do token price feed mapping
799:26 - of the token
799:28 - is going to equal
799:30 - the price fee and that's it so now we
799:32 - have a way to set the price feed
799:34 - contracts we have a way to map the
799:35 - tokens to their price feeds right and
799:37 - again
799:38 - go to docs.chain.link we can go to price
799:40 - feeds ethereum price feeds we can find
799:43 - these different price feeds here and
799:45 - this is where we're going to set those
799:47 - price feeds now back down in our get
799:49 - token value
799:51 - we can grab that price feed address now
799:53 - by saying
799:54 - address
799:56 - price feed address is going to equal
799:59 - that token price feed mapping
800:02 - of
800:04 - that token parameter and now that we
800:06 - have this we can use it on an aggregator
800:09 - v3 interface again we can always go back
800:12 - to the docs here we can grab this bit
800:14 - right here
800:15 - of course we're going to change it
800:19 - to 0.8
800:21 - and for those who would rather i just
800:23 - wrote it out
800:24 - we're going to import
800:27 - at chain link slash contracts slash src
800:31 - slash interfaces
800:34 - slash agreed gate or v3 interface
800:38 - dot sol
800:39 - and since we're doing this import
800:41 - we're gonna go to our browning config
800:44 - smart contract kit
800:46 - chain link
800:48 - brownie contracts
800:50 - and we're going to see what's the latest
800:52 - version of these
800:53 - now i'm going to point something out
800:55 - this package recently changed to mirror
800:57 - the mpm package versions so it does look
801:00 - like it went backwards in versions and
801:02 - there's even a little little update here
801:05 - but this is the the newest version even
801:08 - though it's a 0.2.1 it's literally just
801:10 - to match the mpm contract tags
801:13 - so this is what we're going to use so
801:14 - we're going to at 0.2.1
801:17 - and then in our remappings we'll also do
801:20 - at chain link
801:22 - equals
801:24 - this bit right here
801:26 - now that we've imported that we can now
801:28 - grab that aggregator v3 interface
801:34 - or that price feed
801:38 - and say
801:39 - aggregator v3 interface of price feed
801:42 - address
801:45 - and grab that price feed contract then
801:47 - once we have this price view contract we
801:49 - can call
801:50 - dot latest
801:52 - round data
801:54 - and again you can always check back to
801:56 - the documentation to see what that
801:57 - function actually looks like and this is
801:59 - going to return it's going to return a
802:01 - whole bunch of stuff
802:02 - but we only care about the price so the
802:05 - first thing it returns is round id
802:08 - we don't care about that so we'll just
802:09 - put a comma
802:10 - we do care about the n256 price so we'll
802:13 - put that in there but we don't care
802:15 - about the rest of these
802:16 - so we'll just do
802:18 - comma comma comma
802:19 - because we only care about the price
802:20 - here
802:22 - we also care about the decimals we need
802:24 - to know how many decimals the price feed
802:26 - contract has that way we can match
802:28 - everything up to be using the same units
802:31 - so we'll say u and 256
802:33 - decimals
802:35 - equals price fee dot
802:37 - decimals
802:39 - and what we can do now is we can return
802:41 - both of these so this actually needs to
802:43 - return a un256 and another uint 256.
802:49 - put the decimals here
802:51 - and we do return
802:53 - we can return both of these so we'll do
802:55 - a uint
802:57 - 256 price we'll wrap that price into a u
803:00 - and 256 and then we also need to wrap
803:05 - the decimals in the u and 256 since
803:07 - decimals actually returns a u uint eight
803:10 - so we'll return the price and the
803:12 - decimals all right now we're cooking
803:16 - now
803:17 - we can go ahead and start scrolling back
803:19 - up and adding all this stuff in so we
803:20 - can say you and 256
803:22 - price you went 256 decimals
803:27 - equals
803:28 - this get token value that we just
803:30 - created right here and then we can just
803:32 - have this return
803:33 - staking balance
803:35 - of the token
803:38 - of the user times the price
803:42 - and do some interesting math here
803:44 - divided by those decimals
803:46 - 10
803:47 - raised to
803:49 - decimals
803:51 - and i know there's a little bit of math
803:52 - here right and so you might be going
803:53 - wait wait what are we doing here wrap
803:55 - that up like that just so that we're
803:57 - absolutely certain we're doing correct
803:58 - order of operations here
804:00 - so we're taking the amount
804:02 - of token that the user has staked right
804:05 - let's say for example
804:07 - 10 die
804:09 - and we're taking the price of that die
804:11 - maybe we have
804:12 - all of our contracts all of these tokens
804:15 - get converted back to the usd price so
804:17 - we have die
804:18 - usd actually better yet let's say we
804:21 - have 10 eth
804:22 - right our price feed contract is going
804:24 - to be eth usd
804:27 - let's say the price
804:28 - is is 100 100 dollars per usd
804:32 - so this first bit is we're going to do
804:34 - that 10 eth
804:36 - times 100 so we're going to do 10
804:38 - times 100 which is going to equal to
804:41 - 1 000. 1000 value the only thing is we
804:45 - also have to divide
804:46 - by the decimals so our staking balance
804:50 - is going to be in 18 decimals so it's
804:52 - going to be one two three four five six
804:54 - seven eight one two three four five six
804:55 - seven eight nine ten
804:57 - but let's say our fusd only has eight so
805:01 - one two three four five six seven eight
805:04 - so we need to multiply these first
805:06 - and then divide by the decimals that way
805:09 - we can arrive at a price that actually
805:11 - makes sense is going to be a function
805:13 - that we're definitely definitely
805:14 - definitely going to need to test to make
805:16 - sure that we're doing everything right
805:18 - so that we're doing all the math
805:19 - correctly but okay now that we have this
805:22 - user single token value we go ahead
805:26 - and come back up to our user total value
805:28 - and we can literally finish this
805:30 - function by just calling return
805:32 - total value
805:33 - and then we can pull up to our issue
805:36 - tokens now that we have the total value
805:39 - that this
805:40 - user has actually logged we can just
805:42 - transfer the amount of tokens that they
805:45 - have in total value so we can say dap
805:48 - token
805:50 - dot transfer
805:52 - this recipient we can transfer them
805:55 - the total value right we'll say however
805:57 - much they have in total valued staked on
805:59 - our platform we'll issue them as a
806:01 - reward and that is our issue tokens
806:03 - function we are making great progress
806:06 - all right so we have a way to stake done
806:10 - we have a way to issue
806:12 - done
806:13 - we have a way to get
806:15 - value or just get value
806:18 - done
806:19 - we've added a way
806:20 - [Music]
806:21 - to add allowed tokens and all we have to
806:23 - do now is add some way to unstake the
806:26 - tokens
806:27 - so let's go ahead and create this
806:28 - function
806:30 - i'm going to make it right underneath
806:32 - the state token one
806:34 - we'll do function
806:35 - unstake tokens
806:38 - we'll do we'll pass it the token address
806:41 - we'll make this a public function so
806:43 - anybody can call this the first thing
806:45 - we're going to want to do
806:46 - is fetch the staking balance how much of
806:49 - this token does this user have so we'll
806:51 - see you in 256
806:53 - balance equals
806:56 - staking balance
806:57 - of the token
806:59 - from message.sender
807:02 - and we're going to require
807:05 - the balance
807:07 - is greater than zero
807:09 - otherwise we'll say staking
807:12 - balance
807:13 - cannot be zero
807:17 - and then we're going to do a transfer
807:19 - so we'll do ierc ierc20
807:22 - of the token
807:24 - dot transfer
807:26 - message.sender
807:29 - balance
807:31 - once we actually transfer the token
807:33 - we'll do staking balance
807:37 - of this token
807:39 - of message.sender
807:41 - we're going to update this balance
807:43 - to now be zero right because we're going
807:45 - to transfer the entire balance here and
807:47 - then we're going to update how many of
807:49 - those unique tokens that they have
807:51 - now a quick note here later on we're
807:53 - going to learn about reentrancy attacks
807:55 - so at some point come back here and
807:57 - figure out hey is this vulnerable to
807:59 - re-entrance the attacks so we'll say
808:01 - unique
808:02 - token staked
808:04 - of message.sender
808:06 - it's going to equal
808:08 - unique token state
808:11 - message.sender
808:13 - minus 1.
808:14 - now the last thing that we could do is
808:16 - we probably should actually update our
808:19 - stakers array
808:20 - to remove this person if they no longer
808:23 - have anything staked this is a little
808:25 - bit sloppy but we're just going to skip
808:27 - doing that for the time being however if
808:29 - you want to go back and add the
808:30 - functionality to remove the stakers from
808:33 - the stakers list as they unstag please
808:35 - go for it it's not a big deal if we
808:37 - don't actually do this because our issue
808:39 - tokens function is actually going to
808:41 - check to see how much they actually have
808:42 - staked and if they don't have anything
808:44 - staked then they're not going to get
808:45 - sent any tokens
808:46 - but all right that's basically all of
808:48 - the functionality here
808:50 - let's just try a quick sanity check with
808:52 - a brownie compile
808:54 - whoops i forgot to add v0.8 in here
808:58 - let's try again that little bit
809:00 - this needs to be token
809:02 - and this needs to be user whoops and
809:05 - then it looks like i did the same thing
809:07 - down here this is actually staking
809:09 - balance
809:10 - let's try it again
809:13 - and perfect everything is at least
809:14 - compiling correctly just because it's
809:17 - compiling correctly though doesn't
809:18 - necessarily mean that we're doing
809:20 - everything correctly
809:21 - so this is fantastic typically now we'd
809:24 - want to go ahead and start doing our
809:25 - tests i'm actually going to go ahead and
809:27 - build one of our scripts first the
809:29 - reason i'm going to build one of the
809:30 - scripts first is because i'm going to
809:32 - use my deploy script pretty regularly in
809:34 - my test i'm going to use it as part of
809:36 - my testing this way i can also test some
809:39 - of my scripts as well in addition to the
809:41 - contracts so let's go ahead and make our
809:43 - deploy script
809:45 - so let's create a new file in here
809:47 - we'll call it deploy.pi
809:50 - we'll also create
809:52 - an init.pi for those of you on older
809:54 - versions of python and let's go ahead
809:56 - and do this so we're going to have a
809:58 - main function in here and in our main
810:00 - function we're actually just going to
810:01 - call deploy
810:04 - token farm
810:06 - and
810:08 - dap token
810:10 - and then we're going to have a function
810:12 - def
810:13 - deploy
810:14 - token farm
810:16 - and
810:21 - token
810:23 - right and i should be able to run
810:26 - running run scripts deploy.pi
810:30 - and great everything's compiling right
810:32 - and we're running our scripts here so
810:34 - first thing that we're going to want to
810:35 - do as always is get our account and i am
810:38 - going to copy a couple of those helpful
810:40 - scripts from our past projects so i'm
810:43 - actually going to pull up our nft demo
810:45 - that we did so i'm actually going to go
810:48 - to our chain link mix that we did i'm
810:50 - going to grab our helpful scripts
810:52 - remember we can always jump onto the
810:54 - chain link mix here and we can just grab
810:56 - some of the scripts from here so we
810:57 - could go to scripts helpful scripts and
810:59 - just copy paste this whole thing or just
811:01 - grab it like i did right these are going
811:02 - to be those exact same scripts that we
811:04 - built previously so now we have our
811:06 - helpful scripts in here right we're
811:08 - going to have this contract to mock for
811:10 - running our tests we have get account so
811:13 - we can get our accounts easily we have
811:15 - encode function data which we're not
811:17 - going to have to work with since we're
811:18 - not doing upgradable contracts but we
811:20 - have it here anyways we have upgrade
811:22 - which we're also not going to use but we
811:24 - have it here anyways we have get
811:26 - contract which returns mocks if they're
811:28 - not already deployed or it just returns
811:30 - whatever contract that we're looking for
811:33 - and then of course we have our deploy
811:35 - mox script here so now we can do from
811:38 - scripts dot helpful scripts
811:42 - import
811:43 - get account
811:45 - and perfect we can get our account like
811:48 - that no problem now and now we're going
811:49 - to want to start deploying some
811:51 - contracts so we're going to deploy that
811:53 - dap token first so we'll do from brownie
811:56 - import dap token and we'll do
811:59 - dap token
812:01 - equals
812:03 - gap token
812:04 - dot deploy
812:06 - and this takes no parameters so we can
812:08 - just do from
812:10 - count
812:12 - then we're going to want to deploy our
812:13 - token farm
812:15 - so we could say tokenfarm equals
812:17 - tokenfarm.deploy
812:20 - and this takes one parameter which is
812:22 - the dap token address right because we
812:24 - need that address so we can give it out
812:26 - as a reward so we're going to say
812:28 - dab token dot address we'll do a comma
812:32 - and then we'll say from
812:34 - account
812:37 - and we'll need to import this
812:38 - from
812:40 - brownie as well and while we're here we
812:42 - might as well add some publish source
812:44 - bits on here so we can say publish
812:47 - source equals
812:49 - config we'll grab this from the config
812:53 - networks
812:56 - network dot show active
813:00 - verify
813:03 - grab network from brownie
813:06 - grab config from brownie
813:08 - and in our
813:09 - config here
813:10 - let's do networks
813:13 - lad development
813:15 - we'll set the verify here
813:18 - to be false
813:19 - and then we're going to work with the
813:20 - coven chain
813:22 - so we'll say coven
813:23 - verify will also be false actually kovan
813:26 - sorry covenant will be true
813:28 - and then we'll do a persistent ganache
813:31 - or verify for this will be false
813:35 - and i'm even just going to put this up
813:36 - here so that all these
813:39 - ganache chains are kind of with each
813:40 - other so we'll verify in coven but we
813:42 - won't on development or ganache
813:45 - now once we've deployed this token farm
813:47 - contract we need a couple things right
813:49 - we're going to need to send this some
813:51 - dap tokens right we're going to need to
813:53 - send pretty much all the dap tokens so
813:55 - that i can actually give those tokens
813:56 - out as a reward so we're going to want
813:59 - to do a transaction it's going to equal
814:01 - to
814:02 - dap token
814:03 - dot transfer
814:05 - we'll send it to the token farm
814:07 - address and then we have to choose how
814:09 - much we're going to send and we'll send
814:11 - the total supply
814:12 - but we'll keep a little bit for
814:14 - ourselves so we can do some testing and
814:16 - so just in case so we'll also do minus
814:19 - kept
814:20 - balance some static kept balance which
814:23 - we can say
814:25 - at the top
814:26 - we'll say the kept balance is let's keep
814:28 - like 100
814:29 - so this will be equal to
814:31 - web 3.2 way
814:33 - 100
814:35 - ether
814:37 - so we'll do
814:38 - from web 3
814:40 - import web 3. so in our transfer we'll
814:43 - do
814:44 - dab token dot total supply minus the
814:46 - kept balance and then of course we're
814:48 - gonna have to do a from
814:50 - [Music]
814:52 - account
814:53 - so now we're sending
814:55 - our token farm basically 99.9
814:58 - of the total supply of this dap token so
815:00 - that it has this token to actually give
815:02 - out as a reward we'll do a tx
815:05 - dot wait we'll wait for one block
815:07 - confirmation there now what do we want
815:09 - to do well if we look at our token farm
815:11 - we know at our state tokens function we
815:14 - can only stake tokens that are allowed
815:16 - in each one of these tokens also is
815:18 - going to need to have some price feed
815:21 - associated with it right and our token
815:23 - price feed mapping
815:24 - so we're going to have to add those so
815:26 - what we're going to want to do is we're
815:27 - going to want to create a function
815:28 - called add
815:30 - allowed tokens and what this is going to
815:32 - do it's going to add the tokens that we
815:34 - want to allow and it's going to give
815:36 - them a price feed contract associated
815:38 - with them so let's create this function
815:40 - we'll call it def
815:42 - add allowed tokens and this is going to
815:45 - take a couple things we're going to want
815:46 - to take that token farm because we're
815:48 - going to need to call the add aloud
815:50 - tokens function on it we're going to
815:52 - take a dictionary
815:54 - of
815:55 - allowed tokens and this is going to be
815:57 - the names this is going to be a
815:59 - dictionary of the different token
816:01 - addresses and their associated price
816:04 - feeds so we're just going to price
816:05 - everything in usd so so we can figure
816:07 - out the value of everything in usd and
816:09 - then last of course we're going to need
816:11 - an account
816:12 - for now i'm just going to do pass here
816:14 - let's look at the different inputs that
816:16 - we're going to put into this so
816:17 - obviously we're going to do token farm
816:18 - but then we're going to need to make
816:19 - this dictionary of allowed tokens so
816:21 - we're going to need the address of the
816:23 - different tokens that we want to have
816:25 - now how do we get the addresses of the
816:26 - different tokens that we're going to use
816:27 - and what are the tokens that we're even
816:29 - going to use here
816:30 - for simplicity we're just going to start
816:32 - with three tokens we're going to allow
816:34 - our platform to allow three different
816:36 - tokens to be state we'll use the dap
816:37 - token
816:39 - as one
816:41 - we use weth token or wrapped eth because
816:44 - that's pretty much a standard in most
816:46 - smart contract platforms and then we're
816:47 - also going to use an fau token which
816:50 - stands for faucet token and we're going
816:52 - to pretend that this fafsa token is dye
816:55 - or dai the reason we're going to use
816:57 - this faucet token is because there's
816:59 - this erc20 faucet.com which allows us to
817:01 - get this fake faucet token we can get
817:03 - unlimited amounts of this faucet token
817:05 - on different test nets we're going to
817:07 - pretend that this faucet token is going
817:08 - to be die right so fau token slash die
817:12 - so how do we actually get these
817:13 - addresses well dap token we know with
817:16 - token
817:18 - what we can do in our config so we can
817:20 - actually add those addresses here
817:22 - so for coven
817:24 - the weath token address is going to be
817:27 - this right here which again you can go
817:29 - check this out
817:30 - and you can find it on etherscan you can
817:33 - write your own if you want we're just
817:34 - going to use this already deployed one
817:36 - on coven fau token which is gonna be
817:38 - this token here which i know is gonna be
817:42 - this address right here
817:43 - and if you want you can come here
817:45 - and grab your address
817:47 - paste it into this erc20faucet.com
817:50 - put an amount of 10 in here
817:52 - connect to metamask oh and even tells us
817:55 - the token address right here which we
817:57 - can just copy paste we can do mint free
817:58 - tokens confirm
818:00 - great says success if we don't already
818:02 - have it we can take this token address
818:04 - go to our meta mask
818:06 - assets
818:07 - add token paste it in i've already got
818:09 - it
818:10 - we can see right now i have 5 fau
818:13 - once this confirms i'll have an
818:15 - additional 10 and now you can see 15
818:17 - here this is going to be this fau token
818:19 - that we're going to use we have wes here
818:21 - and then we know
818:23 - what the depth token address is going to
818:24 - be
818:25 - for when we deploy it here
818:26 - now we could do again we could do the
818:28 - config
818:30 - you know networks
818:31 - etc and just always get it from our
818:33 - config
818:34 - or we could use our get contract method
818:37 - that we grab from our helpful scripts
818:39 - which will deploy a mock weath token it
818:42 - doesn't exist in one of these and that's
818:43 - what we want because we're going to want
818:45 - to test this locally so we're going to
818:46 - want to deploy our own fake weath token
818:49 - so we'll say the weath token
818:51 - equals get contract
818:53 - with token
818:55 - and then the fau token
818:57 - is going to be get contract
818:59 - fau token and remember what we put in
819:01 - here our string that we put in here
819:03 - needs to match our string in our config
819:06 - now in order for this get contract to
819:07 - work for weth token and the fau token
819:09 - we're actually going to have to modify
819:11 - our helpful scripts here so if we copied
819:13 - and pasted it directly from our chain
819:16 - link mix this is basically what we're
819:17 - going to have here we're importing all
819:19 - of our mocs which we can go ahead and
819:22 - copy paste these as well from the chain
819:24 - link mix our test our mock contracts
819:27 - here
819:28 - we have some forking implementations we
819:30 - have contracts to mock which tells us
819:32 - based off of the key
819:34 - what token or what contract we use to
819:36 - mock we have get account which we use
819:38 - all the time in order for us to do this
819:40 - contract to mock correctly we're going
819:42 - to have to mock west and fau and
819:45 - actually we don't even need all these in
819:47 - here we don't even need this whole
819:48 - contract to mock in fact we can get rid
819:50 - of
819:51 - mock oracle we can get rid of vrf
819:52 - coordinator and we can even get rid of
819:54 - the link token for this we do need this
819:56 - sdusd price feed later on
819:59 - so i'm just going to leave it in here
820:00 - for now we definitely do need though fau
820:02 - token which is going to be mocked to
820:04 - something and we need weth token which
820:07 - was going to be mocked to something else
820:09 - so what are these tokens going to be
820:11 - mocked to well they're each an erc20
820:14 - mock but we want to give them kind of
820:15 - their own identity so what we're going
820:17 - to do is we're actually going to make a
820:19 - mock erc20 for both fau
820:22 - and for web so we're going to come in
820:24 - here we're going to do new file we'll
820:26 - call it mock die
820:28 - dot sol
820:29 - and this is going to mock that fau token
820:31 - so it could be mock die it could be mock
820:33 - fau whatever we want it to be and we're
820:35 - just going to make this a basic erc20 so
820:37 - we'll do pragma
820:39 - solidity
820:41 - 0.8.0
820:44 - we'll import at open
820:46 - zeppelin
820:47 - contracts token
820:50 - ear c20 your c20.sol obviously this is
820:53 - going to look
820:54 - very familiar this should spell pragma
820:57 - not whatever i just spelled this is
820:59 - going to look really similar to that dap
821:00 - token so now we can call contract
821:04 - mock die
821:05 - is erc20 and we'll do constructor
821:08 - public erc20
821:12 - mock die
821:14 - will be the name of this
821:16 - and the symbol will be die and perfect
821:18 - and that's all we need we'll copy this
821:20 - whole thing and then we'll do the same
821:22 - thing for
821:23 - mockweath.soul we'll paste this whole
821:26 - thing in here
821:27 - and we'll just change the name call this
821:29 - mock west
821:30 - crc20
821:32 - mock weft
821:34 - and this will be
821:35 - what token right so now that we have
821:37 - those mocks in here we can change fau
821:40 - token to
821:41 - mock die
821:42 - and west token to
821:44 - mock weft we can import those from
821:46 - brownie and in fact we can get rid of
821:48 - the mock oracle here and the vrf
821:50 - coordinator
821:51 - instead we'll do mock die
821:54 - and mock west
821:56 - now of course since we have diusd price
821:58 - feed and fusd price feed we're going to
822:00 - make sure we have these in our mocks
822:03 - here and then we're also gonna have to
822:04 - deploy these in our deploy mox script
822:06 - below
822:08 - so if we scroll down to deploy mocks we
822:10 - can see this is what it currently has
822:12 - which is pulling directly
822:15 - from the chain link mix so we just go
822:17 - ahead
822:18 - delete the vrf coordinator mark and the
822:20 - mach oracle and instead
822:22 - we'll deploy
822:24 - those that mock weath and that mock die
822:27 - so we'll do print
822:30 - deploying mock die
822:33 - die token equals
822:36 - mock die dot deploy
822:40 - from
822:41 - account
822:43 - and then we'll do print
822:45 - f statement
822:46 - floyd to
822:48 - die token.address
822:51 - and then we'll do
822:52 - print
822:54 - deploying
822:55 - mock mock web
822:57 - and then we'll do
822:58 - [Music]
822:59 - left token
823:00 - equals
823:02 - mock west dot deploy
823:04 - we'll say from
823:06 - account
823:09 - and then we'll print
823:13 - this deployed
823:13 - be another printf
823:15 - with token.address
823:19 - now additionally
823:21 - we have our fusd price feed left over
823:25 - from the chain link mix we also need
823:27 - this die usd price feed
823:30 - so we can go ahead in here
823:32 - we'll add
823:34 - usd price feed
823:35 - and we'll set this as a mach v3
823:38 - aggregator we could do is we could
823:40 - parameritize this up so that the mock v3
823:42 - aggregator takes maybe some different
823:44 - decimals a different initial value so
823:46 - that these could be different
823:48 - but for the sake of testing we're just
823:49 - going to leave them being the same here
823:51 - so great so we have the address of the
823:53 - wet token we have the addresses of the
823:56 - fau token and if those don't exist on
823:59 - the network we're working on we're going
824:00 - to deploy a mock so now that we have all
824:02 - these addresses we can do a dictionary
824:04 - of allowed tokens
824:06 - is going to be equal
824:07 - to this dictionary that we make so we're
824:10 - just going to route each one of these
824:12 - contracts like the depth token
824:14 - to
824:16 - its equivalent price feed for the dap
824:18 - token we're just going to say that the
824:19 - dap is going to be equal to die
824:22 - we're going to say the fau token
824:24 - is also equal to die
824:26 - and our weath token
824:28 - of course is going to be equal to eth
824:31 - so we're going to want to get a usd
824:33 - price feed another di usd price feed
824:36 - and an f usd price feed so in our config
824:41 - we can add i usd
824:42 - price feed
824:44 - and since we're going to be testing
824:46 - since we're going to be doing our
824:46 - integration test on coven here
824:49 - we'll come to the chain link docs
824:52 - we'll go to ethereum price feeds
824:55 - we're on coven
824:58 - and we'll scroll down to
825:00 - dye usd
825:02 - which is this address right here
825:04 - pop that in and then we'll also want the
825:07 - fusd price feed
825:11 - which we'll also go grab that from here
825:13 - on the coven network and we'll grab that
825:16 - from right here
825:17 - and we'll paste it in
825:19 - so now to complete this deck we can do
825:21 - this get contract again and we'll deploy
825:24 - mock price feeds if they don't exist
825:26 - so now we can just do
825:29 - get contract
825:30 - die usd price feed
825:34 - fau token is also going to be usd price
825:36 - feed
825:37 - and then our weft token is going to be
825:41 - fusd price feed and awesome now we have
825:44 - our dictionary of allowed tokens that we
825:46 - can pass to our ad allowed tokens this
825:48 - will map
825:49 - the tokens and their addresses with
825:51 - their associated price feeds so we can
825:54 - get them all to equal the same value in
825:56 - our contracts so we can go ahead and
825:58 - create this function called add allowed
826:01 - tokens we'll pass it this token farm
826:03 - we'll pass it the dictionary of allowed
826:05 - tokens and then of course we'll pass it
826:08 - the account
826:09 - now in our add allowed tokens function
826:12 - we're going to loop through all these
826:13 - different tokens and call the add allow
826:16 - tokens function on it so we're gonna do
826:17 - four
826:18 - each token in the dictionary of allowed
826:21 - tokens we're gonna do tokenfarm.add
826:25 - allowed tokens
826:26 - and we'll do the token.address and we'll
826:28 - do from
826:30 - account
826:32 - we'll say
826:34 - add tx equals that
826:37 - we'll do add tx dot weight
826:40 - 1
826:41 - then we're going to call this set price
826:44 - feed contract so we're actually going to
826:45 - set the price feed associated with that
826:48 - token
826:49 - so we'll do
826:50 - set tx
826:52 - equals token farm
826:54 - dot set price feed contract
826:58 - and we'll do token.address
827:01 - the dictionary of allowed tokens
827:04 - of
827:05 - that token that we're for looping
827:08 - and then of course
827:09 - from
827:11 - account
827:12 - and we'll do
827:13 - set text.wait one
827:16 - and then we'll just return
827:18 - the token farm but we probably don't
827:19 - have to return anything and great that
827:21 - deploy script looks pretty good and in
827:23 - fact we're going to end our deploy
827:25 - script here with returning token farm
827:28 - and
827:29 - adapt token this way we can actually use
827:31 - this deploy script in our tests so i'm
827:34 - just going to do a quick little zoom out
827:36 - and we can see
827:38 - our wonderful deploy script right here
827:40 - and awesome it looks like we have just
827:42 - about everything here
827:43 - let's give this an initial test
827:47 - on a local ganache chain see if our
827:49 - mocks all work see if everything at
827:51 - least makes sense we can call our
827:52 - functions awesome it looks like we can
827:54 - call all of our functions
827:56 - and we can deploy our mocks and the
827:58 - mocking is working at least somewhat
828:01 - correctly here this is great we'll zoom
828:04 - out a little bit here we've got our
828:05 - deploy scripts we've got our ad allowed
828:07 - token scripts we've got all of our mock
828:10 - contracts added under tests things are
828:13 - looking good now what do we want to do
828:16 - here
828:16 - well of course we want to run some tests
828:20 - we want to make sure our contract is
828:23 - actually going to do
828:24 - what we say it's going to do you guys
828:26 - ready let's jump into it so in our tests
828:29 - let's make a new folder called unit
828:32 - we'll add a new file we'll call it test
828:35 - token farm dot pi let's do some tests
828:39 - now ideally we would also write some
828:41 - tests for our dap token however we're
828:44 - going to skip over those because we're
828:45 - basically just doing open zeppelin's
828:47 - implementation
828:48 - but in a full-scale production here you
828:51 - probably would want to write some tests
828:53 - on your tokens as well so let's get into
828:55 - this let's look at our token farm and
828:58 - see what we need to test remember
829:01 - ideally every piece of code in our smart
829:04 - contract here should be tested in some
829:06 - form or another so with that in mind
829:09 - let's get started so one of the first
829:11 - functions that we see is set price feed
829:14 - contract so let's make a test for that
829:16 - so we'll do def
829:18 - test
829:20 - set
829:21 - price
829:22 - feed contract
829:24 - and we're literally gonna test just this
829:27 - one function so how do we test that well
829:29 - first let's make sure we're on a local
829:32 - network right because we only want to be
829:34 - doing this
829:35 - on our local network since this is one
829:37 - of our unit tests
829:38 - so in our arrange stage
829:40 - we're going to do if
829:42 - network dot show active
829:44 - is not in
829:46 - local
829:47 - blockchain
829:49 - environments
829:51 - then we're going to run pi test.skip
829:54 - and say only
829:55 - for
829:58 - local testing of course we've got a
830:00 - number of pieces here that we need to
830:02 - import we're going to do from browning
830:05 - import network
830:08 - we're going to do from
830:10 - scripts.helpfulscripts
830:13 - import local blockchain environments and
830:16 - then
830:16 - we're going to import
830:18 - pi test all right so now we're going to
830:20 - get an account
830:21 - to make these transactions we'll say
830:23 - account equals get count and let's grab
830:26 - that for my helpful scripts as well so
830:29 - now we have an account we can use let's
830:32 - even grab a non-owner account so we'll
830:35 - say non-owner
830:36 - equals get account
830:38 - and we'll do index equals one this will
830:41 - give us a different account rather than
830:43 - this account and we'll use this to check
830:45 - some only owner functions and then what
830:47 - we're going to do is we're going to get
830:48 - the token farm
830:50 - and the dap token
830:52 - based off of
830:54 - our deploy script so we're going to use
830:56 - this deploy token farm and dap token
830:59 - we're going to import that by saying
831:00 - from
831:01 - scripts.deploy
831:04 - import
831:05 - deploy token farm and dap token and
831:07 - we're just going to call this function
831:09 - in our test right here so we're going to
831:11 - say token farm dap token equals deploy
831:14 - token farm and dap token awesome this is
831:17 - how we're going to do this a lot this
831:18 - arrange step for a lot of these tests
831:21 - here because this is how we're going to
831:22 - set them up we could even hypothetically
831:24 - turn this into a conf test or into a
831:26 - wrapper if we wanted to but we're just
831:28 - going to leave it in here like this for
831:30 - now now we can move on to our act phase
831:32 - so we're going to want to do
831:34 - token farm
831:35 - dot
831:36 - set price feed contract
831:40 - because remember
831:41 - this is what we're testing right now and
831:43 - we're going to use
831:45 - a token and a price feed address so we
831:47 - use the dap token dot address we'll use
831:50 - get contract to actually get an fusd
831:54 - price feed address
831:57 - which we can also grab
831:59 - for my helpful scripts get contract an
832:02 - important note here if you try to set a
832:04 - contract as an address parameter like
832:06 - this ronnie will know okay that you're
832:09 - looking for an address instead of the
832:11 - actual contract in any case then we'll
832:13 - do from
832:14 - account
832:17 - save it and it re-shifts over here now
832:20 - this should work perfectly so we're
832:22 - going to assert this
832:23 - we're going to move into our assert
832:25 - stage right
832:26 - if we check our price feed mapping
832:29 - this should now be updated
832:31 - so we can do
832:33 - assert
832:34 - token farm
832:36 - dot token price feed
832:38 - mapping
832:40 - and remember
832:41 - token price feed mapping is an address
832:43 - to an address so we'll say dap token
832:47 - dot address this should be equal to
832:49 - get contract
832:51 - of fusd
832:53 - price feed
832:54 - this should be updated with exactly what
832:57 - get contract of fuc price feed returns
833:00 - in fact we can even make this a little
833:01 - bit better
833:02 - copy this we'll say
833:05 - price feed address
833:08 - equals get contract and then we'll
833:11 - pop this in here and we'll pop this here
833:16 - that way now we're just using this
833:17 - single variable for both
833:19 - all right that's our first test let's
833:21 - run it brownie
833:23 - test this will run the whole test suite
833:27 - and we're passing awesome now let's also
833:30 - do a test
833:31 - to make sure that
833:33 - non-owners can't call this function we
833:36 - want to make sure that somebody other
833:38 - than the owner who deployed this right
833:40 - because deploy token farm and dap token
833:42 - is going to be run by get account we
833:45 - want to make sure that
833:47 - somebody else can't call this function
833:49 - so we'll do with pi test dot raises
833:53 - exceptions dot virtual machine error
833:58 - excuse me for that
834:00 - getting in the way and then we'll try to
834:02 - call this exact same function here right
834:06 - we can even just copy paste it
834:08 - but instead we'll
834:10 - call it from non-owner
834:12 - right
834:14 - and then we do also have to import
834:15 - exceptions from browning so this should
834:18 - also pass
834:20 - it's expecting this contract call to
834:22 - actually revert so let's try this
834:24 - perfect it passes
834:26 - right we can double check to make sure
834:27 - that this pi test.raises is working
834:29 - because what if we did a count here
834:31 - right
834:32 - this now should fail because this isn't
834:35 - going to revert and that's exactly what
834:36 - happens perfect so we can leave this as
834:38 - non-owner and our first test is looking
834:41 - great let's even zoom out just a hairier
834:44 - we can sleep easy that this function is
834:46 - going to work as we intended isn't that
834:48 - a wonderful feeling yes it is great
834:50 - let's move on so let's look at our token
834:53 - farm what's the next function aha
834:55 - issue tokens all right great let's write
834:57 - some tests for issue tokens so what are
835:00 - we going to do
835:01 - def
835:02 - test
835:03 - issue
835:04 - tokens so how are we actually going to
835:07 - do this well in order to test issuing
835:09 - tokens
835:10 - we actually need to
835:12 - stake some tokens first
835:14 - so for now i'm actually just going to do
835:16 - pass here and before we test issuing the
835:19 - staking tokens we need to write a test
835:22 - for staking those tokens right because
835:24 - in order to issue tokens you need to
835:26 - have some tokens state so let's write a
835:28 - test
835:29 - stake tokens first and then we'll write
835:31 - this test issue tokens so we'll do def
835:34 - test
835:35 - stake
835:37 - tokens
835:39 - now let's set this up
835:40 - so we're going to copy this bit here
835:44 - because we are going to be working on a
835:46 - local network with this we'll do account
835:49 - equals get account and then
835:52 - we'll go ahead
835:53 - and deploy the token farm and the dap
835:56 - token so
835:57 - this initial bit is going to be exactly
836:00 - the same making sure we're on a local
836:02 - network getting the account deploying
836:04 - the token farm and the dap token
836:06 - so now let's move into the act phase
836:09 - let's go ahead and act let's go ahead
836:11 - and actually send some tokens to our
836:14 - token farm so first we obviously need to
836:16 - call approve on the dap token contract
836:20 - so we'll do dap token
836:22 - dot approve
836:24 - to the token farm dot address
836:27 - and again you can see and again we can
836:29 - go to the open zeppelin docs to figure
836:31 - out what the parameters of this are but
836:33 - it's going to be an address and it's
836:34 - going to be some amount and then
836:36 - obviously from
836:38 - account
836:40 - now i put a couple question marks here
836:42 - because we're going to constantly be
836:44 - using an amount right we're going to be
836:47 - using an amount staked for a lot of our
836:50 - tests here
836:51 - so what we're going to do is we're
836:52 - actually going to turn that into a
836:53 - fixture
836:54 - we're going to call it
836:56 - amount
836:57 - state and we're going to define this in
836:59 - our conf test folder so we're going to
837:01 - make our conf test file so in here we're
837:03 - going to do new file
837:04 - conf test dot pi
837:07 - and whoops it's in the wrong directory
837:10 - so we're going to go cd tests
837:12 - units
837:12 - i'm gonna do move
837:14 - confidence.pi
837:16 - down one directory and it should be in
837:18 - here now if that didn't work you should
837:20 - be able to drag and drop it
837:22 - uh into test you just wanna pull it out
837:24 - of unit is what we're doing here right
837:26 - just want to get it so that's just in
837:28 - this test directory here in the case in
837:30 - our conf test.pi we're going to create
837:32 - our first fixture
837:34 - so we're going to do at pi test.fixture
837:37 - we'll do def amount staked
837:40 - and then we're just going to return
837:42 - web3
837:44 - dot 2 way
837:46 - one
837:47 - ether now of course we need to import pi
837:49 - test here
837:50 - then we're going to need to import we're
837:52 - going to do from web3
837:55 - import web3 and now
837:58 - it saves
837:59 - perfectly so now we can use this amount
838:02 - staked fixture as basically a static
838:04 - variable right we could have done at the
838:06 - top we could do something like amount
838:08 - staked equals you know that exact same
838:10 - thing but
838:11 - we're going to get into the habit of
838:12 - working with these fixtures so we have
838:15 - our def test stake tokens and we're
838:17 - going to pass it this amount staked
838:20 - fixture pi test and brownie will
838:23 - grab all this stuff from the conf test
838:27 - folder and put it into here
838:29 - so now we can just use amount staked as
838:32 - a parameter in our test here so once we
838:34 - approve we can then do token farm
838:41 - we now call
838:43 - our stake tokens
838:45 - function right here
838:47 - and it takes an amount
838:49 - and then a token address
838:51 - so of course we're going to do amount
838:52 - staked
838:53 - as the amount and then we'll do depth
838:55 - token
838:57 - address
838:59 - as the address and of course from
839:02 - account
839:04 - and perfect this is going to be our
839:06 - basic action of testing the staking
839:08 - functionality so we can go ahead and
839:09 - down here and move into our assert phase
839:12 - and we can just assert a number of
839:14 - things
839:15 - right
839:16 - and do a little
839:18 - bracket here
839:19 - we're gonna do a couple of things here
839:20 - we're gonna assert the token farm
839:26 - that's staking balance
839:28 - of dap token
839:30 - that address
839:33 - of account dot address
839:36 - equals amount
839:38 - state
839:39 - so let's talk about this really quickly
839:41 - what is this actually doing so if we go
839:43 - to our token farm we know that we have
839:45 - this mapping called staking balance and
839:48 - this is a mapping of a mapping
839:51 - right so we need to actually pass
839:53 - two variables the first address and then
839:55 - the second address to get this amount
839:58 - this is how you do that syntactically
840:00 - with brownie you just pass it as
840:02 - additional parameters in here so we pass
840:05 - the dap token address
840:06 - which is going to be the token address
840:08 - here
840:09 - and then the account address
840:11 - which is going to be the address here
840:14 - and perfect
840:16 - so we can even run this by doing brownie
840:20 - test
840:21 - dash k
840:23 - test stake tokens
840:26 - and great looks like that passed
840:27 - perfectly
840:28 - but we have a couple of other assertions
840:30 - to make right because if we look at our
840:32 - stake tokens function it does a lot of
840:35 - things so let's check all of these and
840:37 - make sure that they all are working
840:39 - correctly so we'll also assert
840:41 - that the
840:43 - dot tokenfarm.unique
840:45 - token staked
840:49 - of account that address
840:51 - is going to be equal to one right this
840:53 - is going to be the first token so
840:56 - it should have a unique token state we
840:58 - should also assert that the token farm
841:02 - dot stakers
841:04 - at the zeroth index is going to be
841:06 - this account that we're using we update
841:09 - our unique token staked
841:11 - we update our staking balance
841:13 - and then we add
841:15 - stakers.push right so we're going to be
841:16 - the first
841:18 - address in this array now and then i'm
841:20 - going to do one other thing here too i'm
841:22 - going to do return
841:23 - token farm
841:25 - and dap token
841:27 - the reason i'm doing this is because now
841:29 - we can actually use this
841:31 - test in some of our other tests now
841:33 - we're getting a little bit integration
841:35 - here we're kind of mixing and matching
841:36 - some stuff we could even probably put
841:38 - this whole thing in a function in our
841:40 - regular scripts directory but for
841:42 - simplicity's sake this is how we're
841:44 - going to architect it but great let's
841:45 - test the rest of those we'll just hit up
841:48 - ground to test k test stake tokens we'll
841:50 - hit enter and perfect
841:52 - this is passing correctly as well
841:55 - awesome let's keep going now we're
841:57 - moving into this test issue tokens phase
842:00 - here and we're going to use our test
842:02 - stake tokens test here
842:04 - so the way that we're going to use this
842:06 - is we're going to grab this amount
842:07 - staked parameter
842:09 - place it in here
842:10 - and we're going to set this up exactly
842:12 - the same way we're going to set this up
842:13 - almost exactly the same way so we can
842:15 - even just copy these few lines here
842:18 - paste it
842:19 - we're going to do an arrange
842:20 - we're going to check to make sure we're
842:22 - on a local network we're going to get
842:24 - our account but instead
842:26 - of doing deploy token farm and dap token
842:30 - we're going to do
842:31 - token farm
842:33 - comma dap token
842:35 - equals test stake tokens and we're going
842:37 - to pass it that amount state so this is
842:40 - why we're returning the token farm in
842:42 - the dap token in our test stake tokens
842:45 - that way we can use that function now
842:47 - in our test issue tokens and perfect now
842:50 - we can test issuing these tokens so to
842:53 - test issuing tokens to issue this reward
842:56 - we want to first take some inventory of
842:58 - the current starting balances of our
843:02 - address we'll say starting balance
843:06 - equals
843:07 - depth token dot balance of
843:11 - account dot address and great this is
843:13 - how we're going to start off in our
843:15 - range phase now let's move to acting
843:17 - open our act phase and we'll just do
843:20 - tokenfarm.issue tokens
843:23 - we'll save from
843:25 - account
843:28 - and this is really the only thing that
843:30 - we're testing here so now we can move
843:32 - into the arrange
843:34 - stage
843:35 - and we'll do assert
843:37 - i'm going to do a little
843:39 - parentheses here because this is going
843:41 - to be a long thing and we're going to
843:42 - assert that the dap token
843:44 - dot balance of
843:48 - the account dot address
843:50 - should equal
843:52 - the starting balance
843:53 - plus
843:54 - some new amount
843:56 - what's that new amount going to be well
843:59 - if we look at our issue tokens function
844:01 - if we're staking in our conf test if
844:04 - we're staking one
844:06 - ether right
844:08 - or one
844:09 - die right because we're staking the dap
844:11 - token we're just taking one our marks
844:15 - are going to be this
844:16 - fusd price feed right our mock v3
844:19 - aggregator when we deploy it the initial
844:21 - value is going to be this 2000 right
844:23 - here and we're saying
844:25 - in our mock in our sample here we're
844:28 - saying
844:29 - we are staking
844:31 - one
844:32 - depth token
844:34 - which is equal
844:36 - in price
844:37 - to one each
844:39 - so we should get 2 000 depth tokens in
844:44 - reward since we're saying
844:46 - since the price
844:48 - of eth is
844:50 - 2000 usd
844:52 - so there's a little bit of math here
844:54 - but the initial value is going to be
844:55 - 2000 right you can almost think of it
844:57 - like this
844:58 - with 18 decimals and our application
845:01 - pays us reward based off of the total
845:03 - usd value that we have locked so we
845:05 - actually can know that this is going to
845:08 - be that 2000 price so what i'm even
845:10 - going to do is i and if this isn't
845:12 - already in the chain link mix shame on
845:14 - me i should add this in here
845:16 - because we're going to add a new
845:17 - variable called initial
845:20 - price feed value
845:24 - it's going to be equal to 2 000. one two
845:26 - three four five six seven eight nine ten
845:28 - one two three four five six seven eight
845:31 - that super big number and we're gonna
845:33 - take that and we're gonna set that here
845:36 - to our initial value is going to be now
845:37 - this initial price food value
845:40 - and what we can do in our test
845:42 - is we can then import that
845:45 - from our helpful scripts
845:47 - and we can just assume that our starting
845:49 - balance is going to be now we are
845:50 - starting balance plus that initial price
845:53 - feed balance and if we've done our math
845:55 - correctly and if we've done our issue
845:57 - tokens and if we've done all of our get
846:00 - value correctly this should work we
846:02 - should have done our testing already
846:04 - on the things like get
846:06 - user total value right because get user
846:08 - total value is a subset of issue tokens
846:11 - but we're jumping the gun a little bit
846:13 - here and we're going to test this later
846:15 - on anyways so
846:17 - with that being said let's run this test
846:21 - brownie
846:22 - test dash k
846:24 - test issue tokens and lovely so our math
846:27 - is correct
846:28 - awesome we are doing wonderfully with
846:31 - her tests here we've even gotten some of
846:33 - the harder ones out of the way early
846:34 - which isn't too bad either now as far as
846:36 - this video goes we're actually going to
846:37 - stop writing the test because we're
846:39 - literally just going to keep going down
846:41 - that solidity file and grabbing
846:43 - functions and adding tests to them we've
846:45 - got all the tests located in the github
846:47 - repository associated with this lesson
846:49 - there is both a unit test file and an
846:51 - integration test file in the github
846:52 - repository if you want to just go ahead
846:54 - and check that feel free to do so we're
846:56 - going to move on to the next section to
846:57 - keep things moving forward but i highly
846:59 - highly recommend you trying to write all
847:02 - these tests yourself so good luck we're
847:04 - gonna have all right now we're going to
847:06 - umv
847:07 - private
847:08 - and our website
847:10 - make sure your integration projects work
847:12 - well make sure that you get started if
847:14 - you run your deployment on copy paste
847:17 - network directly
847:19 - we're going to be testing everything
847:20 - works we'll save dots of course you're
847:22 - going to want to get out.env file you're
847:24 - going to want to add that to your
847:25 - browning config address privacy and add
847:28 - your web3 inferior project id and make
847:30 - sure you have plenty of test dent coven
847:32 - so that you can actually run these
847:33 - deploy scripts we can always find the
847:35 - latest faucets from the link token
847:37 - contracts page under our coven or rink b
847:40 - networks here we're also going to need
847:41 - our wallets section we'll do from key
847:45 - and this is where we'll put the dollar
847:46 - sign
847:47 - private
847:48 - key
847:50 - now
847:51 - now that we've got the contract now that
847:52 - we've done all the contract work we're
847:54 - going to learn something totally new
847:56 - that we haven't covered yet we're going
847:58 - to learn to do some front end
848:00 - development now like i said this isn't a
848:03 - front end course and the focus isn't
848:04 - going to be on front end and i want to
848:06 - point out right away that this is
848:08 - considered a bonus section there are a
848:10 - ton of pieces in this section that we're
848:12 - not going to have the time to go over
848:14 - thoroughly because we're not going to be
848:16 - going into what's going on on the front
848:17 - end side the editing is a little bit
848:19 - choppier and i highly recommend having
848:22 - the documentation having the github
848:24 - associated with this front end with you
848:26 - while you're going through this free
848:28 - code camp has an awesome video on doing
848:30 - front-end work and if you want to learn
848:31 - more about react and typescript and some
848:33 - of the technology that we're going to go
848:34 - over definitely check out those videos
848:36 - after this we're going to make this
848:38 - though so that you should be able to
848:39 - follow along with everything that we're
848:41 - doing if you're not interested in front
848:42 - end feel free to go ahead and skip this
848:44 - part
848:45 - however understanding how these front
848:47 - end applications work is really helpful
848:50 - and it'll give you a
848:51 - massive massive incredible skill to
848:53 - actually build front ends for your smart
848:55 - contracts having a really solid user
848:58 - interface is really important in the
849:00 - web3 in the blockchain world if people
849:02 - can't use your contracts then what good
849:04 - is your application so with that being
849:06 - said let's jump on and let's build our
849:09 - front end
849:10 - and i know we said we didn't like
849:12 - javascript we're gonna be working with
849:14 - typescript here which is a improved
849:16 - version of javascript and catches a ton
849:19 - of the different bugs and allows us to
849:20 - be much more explicit with how we're
849:23 - working with our front end we're also
849:24 - going to be working with react we're
849:26 - going to be working with create react
849:28 - app this is a front-end framework that
849:30 - allows us to quickly spin up a front end
849:33 - to build for our applications here we're
849:35 - also going to be working with this tool
849:36 - called used app it's a framework for
849:38 - rapid dap development
849:40 - and works great with react here so let's
849:43 - get started building this front end the
849:45 - first thing that we're going to want to
849:46 - do to build a front end for our full
849:48 - stack application create react app
849:51 - boilerplate so you should have mpx
849:54 - installed if you run mpx-version
849:56 - it should show up this should be
849:58 - installed from when we installed npm if
850:00 - you don't have mpx installed you can run
850:03 - mpm install
850:04 - g npx additionally we're going to want
850:07 - to install
850:08 - yarn here to install yarn again you just
850:11 - run mpm install dash dash global or dash
850:14 - g yarn you'll know you have yarn
850:16 - installed correctly if you can run yarn
850:18 - dash dash version you see a version of
850:20 - yarn and i have a link to install both
850:22 - npx and yarn in our github repo great
850:27 - once you have those we can actually
850:29 - create a folder with all of our
850:31 - boilerplate code in it we're going to
850:32 - run mpx
850:34 - create
850:35 - react app we're going to call it front
850:38 - end and this is going to create a new
850:40 - folder called frontend
850:42 - and we're going to do dash dash template
850:45 - type script
850:46 - because we're going to want to work like
850:48 - i said with typescript instead of
850:49 - javascript for those of you who've never
850:52 - worked with typescript before and who
850:53 - have worked with javascript don't worry
850:55 - the syntax is nearly identical for those
850:57 - of you who have never worked with either
850:59 - don't worry we're going to walk through
851:00 - everything that we do and then we'll hit
851:03 - enter here what's going to happen is
851:04 - you'll see we're going to create this
851:06 - new react app in this new front end
851:09 - folder in our project here
851:13 - awesome now that we've downloaded our
851:16 - create react app we have this new folder
851:18 - called frontend and it's got a whole
851:20 - bunch of stuff in it now typically what
851:23 - different applications will actually do
851:25 - is they'll have one repository for all
851:28 - their python and for all their contracts
851:30 - but they'll additionally have a
851:31 - different folder
851:33 - or different repository for their
851:35 - front-end application and their
851:36 - front-end work this is really good
851:38 - practice we're just going to bundle
851:39 - everything up into the same repo here
851:41 - just to get started and just to make it
851:43 - easier for us getting started here
851:45 - however what you will see across
851:47 - different projects is they'll have a
851:48 - totally separate repo for their front
851:50 - end so let's take some inventory on
851:52 - what's actually going on inside this
851:54 - folder so the first folder you'll see is
851:56 - node modules these are basically the pip
851:58 - installs these are the different
852:00 - packages pulled in from javascript and
852:02 - typescript we can pretty much ignore
852:04 - this folder for the majority of what
852:06 - we're working with here next we have our
852:08 - public folder we're also not really
852:10 - going to go in here but it's got some
852:12 - nice little images it's got our basic
852:15 - index.html which has the html that we're
852:18 - going to be running with it has a couple
852:20 - logo images and it has a manifest the
852:22 - manifest is something that we want to
852:24 - change this tells our browsers a little
852:27 - bit about what our app is and what our
852:29 - app actually does so this is something
852:31 - that we we would change but everything
852:32 - in here is pretty self-explanatory the
852:34 - short name of our application the long
852:37 - name of our application some icons start
852:40 - url this is something that if you want
852:42 - to fiddle with it later absolutely
852:44 - please go for it and then robots.txt
852:46 - we're not going to talk about this at
852:48 - all this helps web searchers and
852:49 - indexers learn a little bit more about
852:51 - your site we can ignore this one as well
852:53 - so for the most part we're not really
852:55 - going to do anything in the public
852:56 - folder or the node modules folder our
852:58 - source folder however we are going to be
853:00 - spending a lot of time in it has our
853:02 - app.css which includes a whole bunch of
853:06 - formatting for html we have app.test.tsx
853:10 - this is going to be testing our front
853:12 - end
853:13 - yes you can even test your front end
853:15 - we're going to totally skip over testing
853:17 - the front end which yes i know we've
853:18 - spent a lot of time testing our
853:20 - contracts if you want to learn more
853:22 - about testing your front ends there's
853:24 - some fantastic links in the github and
853:26 - in the description to go over this
853:28 - app.tsx which we are going to be
853:30 - spending some time in and it's one of
853:31 - our the main places for us to write some
853:34 - code index.css
853:36 - again a formatting and styling file
853:39 - anything that ends in css
853:41 - is some type of formatting and styling
853:43 - all these tsx are going to be type
853:46 - scripts index.tsx we're going to pretty
853:48 - much ignore we are going to change the
853:50 - logo and we can ignore all these last
853:52 - bits here a package.json this file tells
853:56 - our project what dependencies it needs
853:58 - and node.js packages it actually needs
854:00 - to get started we have a readme which of
854:02 - course is a readme we have a typescript
854:04 - config which gives us some options on
854:07 - how to work with typescript we're going
854:09 - to ignore this and then we have our
854:10 - yarn.lock which is an auto-generated
854:13 - file we're not going to touch it at all
854:15 - because yarn is going to automatically
854:17 - create this if you're not if you're
854:19 - unfamiliar with yarn.lock and unfamiliar
854:21 - with a lot of this stuff don't worry too
854:23 - much about it this isn't going to be a
854:24 - file you're really going to need to pay
854:26 - attention to but okay
854:28 - now that we've created the basic create
854:30 - react app we can actually go ahead and
854:32 - right now we can see what a front end
854:34 - will look like so we'll cd to the front
854:36 - end
854:37 - we'll run yarn just to make sure we have
854:39 - everything installed what yarn does is
854:42 - it actually installs all of our
854:43 - dependencies anything in this
854:45 - package.json
854:47 - yarn is going to go out and download
854:49 - these dependencies and store them into
854:51 - node modules
854:52 - and then yarn.lock is going to tell us
854:54 - exactly what it downloaded once running
854:56 - yarn now it just checks to see it says
854:58 - ah it looks like you already have
855:00 - everything installed because when we run
855:02 - create react app it already goes ahead
855:04 - and downloads everything but now we can
855:06 - just run yarn start
855:09 - if you want to know where this is coming
855:11 - from if you go in your package.json
855:14 - and you look under scripts
855:16 - these are the four different scripts
855:18 - that we actually run
855:20 - running yard start runs this mpx react
855:23 - scripts start which will actually start
855:25 - our front end so we'll do yarn start
855:27 - you'll see react script start you'll see
855:29 - it says starting the development server
855:31 - and after a little bit of time
855:33 - we'll get something that looks like this
855:36 - edit source
855:37 - slash app.tsx and save and reload and
855:40 - this is a super simple front end
855:43 - obviously this isn't at all what we're
855:45 - looking for but we've now started a
855:48 - front end which is fantastic it'll say
855:50 - compiled successfully it'll say you can
855:52 - now view frontend in the browser
855:54 - it'll tell you exactly where it's
855:56 - located on our local host on the network
855:59 - and it'll give you any outputs from the
856:01 - front end down below
856:03 - so we're just going to stop the front
856:04 - end for now by hitting command c or
856:06 - control c and closing it down
856:09 - of course if we reload now on the front
856:11 - end it's going to be blank but great so
856:13 - we have a really basic setup for working
856:16 - with a front end awesome if we look at
856:18 - an application like app.avi.com you'll
856:21 - see they have like this really fun
856:23 - connect button that pops up
856:25 - and they've got some nice user interface
856:27 - tools for actually working with the
856:29 - blockchain we don't want to have to
856:30 - reinvent the wheel and build all these
856:32 - custom tools for doing this so we're
856:34 - going to use this application called
856:36 - used app or this framework called used
856:38 - app which has a whole lot of these
856:40 - already built in to get started
856:41 - installing all we have to do is run this
856:44 - command right here yarn add use dap
856:47 - slash core so here in our front end
856:50 - we'll do yarn
856:51 - add at use dap slash core and this will
856:55 - go ahead and install all the used app
856:57 - pieces into our front end so we can
856:59 - actually work with used app and not
857:02 - reinvent the wheel with working with
857:03 - wallets and working with ethereum and
857:05 - other smart contract applications
857:06 - awesome now we have that installed we
857:09 - can actually go ahead and start building
857:11 - our front end now what we're going to do
857:13 - is we're going to go to
857:15 - app.tsx folder and we're going to start
857:17 - in here we're going to start adjusting
857:19 - some bits in here so what we can do is
857:21 - we can do the yarn start and we'll get
857:23 - our a little react front end here now
857:25 - what we could do is we go ahead and do
857:26 - something like change anything in here
857:28 - right see how this line says edit source
857:30 - that app source slash app and saved
857:32 - reload we could do we change this whole
857:34 - line
857:36 - being something just like
857:38 - hello
857:39 - we'll save it
857:40 - it'll recompile
857:42 - we can go back and now it just says
857:43 - hello right so this is how we can
857:46 - actually upload and update our front end
857:49 - we have these these wonderful return
857:51 - pieces here these return sections here
857:53 - which will return the html to actually
857:56 - render the front end and this is also
857:58 - our starting point for allowing our
858:00 - application to be web 3 compatible
858:03 - so if we go to this use dap
858:05 - documentation right we go to our getting
858:08 - started section we have a little example
858:10 - here that shows kind of what what
858:12 - something should look like right but
858:14 - it's not exactly clear where we put all
858:16 - this code
858:17 - so they do have this wonderful
858:18 - step-by-step bit and this is probably
858:20 - the most helpful bit here it says the
858:21 - first thing you need to do is set up dap
858:23 - provider with optional config and wrap
858:26 - your whole app in it so we're going to
858:28 - use these depth provider tags right this
858:30 - is the open tag and this is the closing
858:32 - tag we just wrap it around our app so we
858:35 - can see here this this whole thing right
858:38 - now
858:38 - is our app so we could take this whole
858:41 - thing
858:42 - delete it right and if we save right now
858:45 - we can go and see
858:46 - our friend is going to have nothing it's
858:47 - going to be blank this function app here
858:50 - that's getting exported export default
858:53 - app
858:53 - and this is getting rendered in this
858:55 - index.tsx we have this cool little
858:58 - app.html tag thing right but any case we
859:02 - want to wrap this whole thing with this
859:04 - tag here right
859:06 - so we can even just copy this paste it
859:08 - in i can do dap provider and then my vs
859:10 - code even auto adds a second dap
859:12 - provider here we can delete this div
859:14 - class name equals app
859:16 - i'll just put put a little divider in
859:18 - here and just say hi and at the top
859:20 - we'll just import this dap provider
859:22 - thing like what is this weird tag we're
859:24 - going to import it so we'll do import
859:27 - depth provider
859:30 - from
859:32 - and use dap
859:34 - core
859:36 - now if we hit save we'll get this weird
859:37 - error saying hey property config is
859:40 - missing in our dap provider and that's
859:42 - because
859:43 - this dat provider needs a config
859:45 - associated with it so we need to add
859:47 - this config bit into this dat provider
859:49 - so we're going to do
859:51 - config
859:52 - equals at this first bracket says we're
859:55 - going to type in typescript and the
859:56 - second bracket is saying we're an object
859:58 - here so in this config we're going to
860:00 - tell our application
860:02 - a couple of different things so we're
860:03 - going to tell it what supported chains
860:05 - there are what are the networks that our
860:07 - application can actually work with the
860:08 - default value for supported change in
860:11 - used app is going to be mainnet
860:13 - reli
860:14 - coven wrinkby robsten and xdi since
860:18 - we're going to be testing only on coven
860:20 - and ring b we could just do chain id dot
860:23 - coven
860:25 - and chain id dot chain id
860:28 - is another term that we can pull right
860:30 - from our used app slash core right and
860:31 - now if we wanted some other chain id we
860:33 - could just go ahead and put it in here
860:35 - right like if we wanted to work with our
860:36 - ganache we could just do one three three
860:38 - seven if we wanted some other random
860:39 - chain we could just put the other number
860:41 - in there right but chain id coven is
860:43 - going to be 42 and chain id that ring b
860:45 - is going to be what is it three yeah
860:47 - three or what or whatever it is and this
860:49 - is all we need to get started working
860:52 - with in a web 3 a blockchain compatible
860:55 - application so let's go back let's save
860:58 - and we'll refresh and now it just says
861:00 - hi
861:01 - how's it going so we're going to spend a
861:03 - lot of time in this source folder and
861:05 - since we're going to be here a lot let's
861:06 - let's do some cleanup just to cut down
861:08 - on the amount of fat that we have with
861:10 - that create react app
861:11 - so app.css we're going to toss this
861:15 - app.test yes tests are great but we're
861:17 - going to toss it we're going to leave
861:19 - index.css we do need index.tsx
861:23 - we don't need this logo bit anymore
861:25 - because we're going to use our own logo
861:27 - we do need this
861:29 - we also need this
861:30 - and since we're not running tests
861:32 - anymore we don't need this but i'm going
861:33 - to leave it in here just in case you
861:34 - guys want to later on go back and add
861:36 - some tests great so now we're looking a
861:39 - little bit lighter and in our app let's
861:41 - just remove
861:42 - amp.css let's remove logo.svb
861:46 - logo.svg goodbye
861:49 - now okay so we're going to create what's
861:51 - called a component we're going to create
861:53 - a header component now in react
861:55 - components are basically where you you
861:57 - put modular parts of your front end and
862:00 - we're going to create one of these
862:01 - components is going to be our header
862:02 - component to do this we're going to
862:04 - create a new folder called components
862:07 - and in here
862:08 - we're going to create a new file called
862:10 - header.ts
862:12 - and this is where we're going to put our
862:14 - header stuff and we're looking to to
862:16 - make a little button up here right we're
862:17 - looking to make a little button in this
862:19 - header so what we're going to do is
862:20 - we're going to import some stuff so
862:22 - we're going to import use ethers
862:25 - at usdap
862:29 - core again if we look at the
862:30 - documentation real quick this use ethers
862:33 - thing has got some cool stuff it's got
862:35 - this activate browser wallet thing got
862:37 - this account thing
862:39 - it's got some it's got some cool stuff
862:40 - so what do those actually do we're going
862:42 - to start by exporting a constant
862:44 - variable
862:45 - called header this is going to be a
862:47 - function and this is some really this is
862:50 - some really fancy typescript syntax what
862:52 - this is meaning is that we're saying
862:54 - header is a function
862:56 - and here's what the function is going to
862:58 - do we're going to use this use easter's
863:01 - thing to get a couple variables so we're
863:03 - going to say constant variable
863:04 - account
863:06 - activate
863:08 - browser wallet
863:11 - deactivate
863:13 - equals use ethers
863:16 - in order for us to actually use these
863:17 - though we need to figure out first if
863:19 - the user is connected
863:21 - so we're going to create another
863:21 - constant variable we'll call it is
863:24 - connected
863:26 - and this is going to equal
863:28 - an account it's going to equal an
863:29 - account it's going to equal account does
863:32 - not equal
863:33 - on d find
863:35 - so we're saying
863:36 - if the account
863:38 - is undefined we're not connected if it's
863:40 - not undefined then great we're connected
863:42 - so we're literally just looking to see
863:44 - if there's an account here and whether
863:45 - or not we're connected we'll decide if
863:47 - we show a connect button or not so to do
863:49 - that we're going to return
863:51 - a div this is where we're going to
863:52 - return
863:53 - some html stuff and we've got to check
863:55 - to see if we're connected so we'll do is
863:57 - connected i'm going to use this question
863:59 - mark which is known as a tertiary
864:01 - operator
864:02 - which means
864:03 - if this is true we're gonna do something
864:05 - and if it's false we're gonna do
864:06 - something else so we're saying okay if
864:08 - we are connected right what do we do if
864:10 - we're connected here well
864:12 - we're gonna create a button
864:15 - we'll have the color
864:17 - equal
864:18 - primary
864:19 - create this button here
864:21 - and then my vs code auto makes these
864:23 - closing tags we'd even leave this button
864:25 - blank if we want or we're actually going
864:28 - to put some fancy stuff in here and then
864:30 - we'll put a little function in it we'll
864:31 - say on click
864:33 - equals
864:35 - deactivate this is this deactivate
864:37 - function pulled in from our use ethers
864:40 - thing i should spell it right though and
864:42 - we're going to call this button
864:45 - oops there's a little
864:47 - parenthesis next to this so this is what
864:49 - this is connect thing does so we're
864:50 - saying if if we are connected
864:53 - right do this
864:54 - now we're going to do a little
864:56 - colon here
864:57 - and this is going to represent what
864:58 - we're going to do if we're not connected
865:00 - okay if we're not connected what we're
865:02 - going to show is a different button
865:04 - color can still be
865:06 - primary
865:08 - and we're going to do on click
865:10 - we're going to do
865:11 - a function
865:14 - activate browser wallet
865:17 - then we close up the button tag with
865:19 - another backslash button
865:21 - and we'll call this one though
865:23 - so if we are connected we're going to
865:24 - show a disconnect button and then if
865:26 - we're not connected we're going to show
865:28 - a connect button and that's it right
865:30 - just make sure all of your divs all your
865:32 - tags are matched up and we can go ahead
865:33 - and save this and if we look at our ui
865:36 - you'll see nothing's changed right okay
865:38 - well why isn't anything changed well
865:39 - this component that we just made it's
865:41 - living inside of this components folder
865:44 - and we've exported this this header
865:45 - variable this header function right
865:47 - however it's actually not in our app
865:50 - here right so if we look at our
865:51 - index.tsx this is what's actually
865:54 - getting rendered so we're just rendering
865:56 - this app variable which is pulled in
865:59 - from you know dot slash app right this
866:01 - app.tsx so index.tsx is really our true
866:05 - ground zero this is where everything
866:06 - really comes from this is kind of our
866:08 - entry point right this is our main
866:10 - function you kind of think of it that
866:11 - way that pulls from this app file that
866:14 - we have here you can see in here we
866:16 - don't have any reference to this header
866:18 - right we have our dat provider we have
866:20 - our div tag saying hi but we don't have
866:22 - the header in here so what we need to do
866:24 - is we need to import this component we
866:26 - just made into our app.tsx so we're
866:29 - going to do is we're going to import
866:30 - header
866:32 - from
866:34 - dot slash
866:35 - components
866:37 - slash
866:38 - header
866:40 - and now we can take this header bit we
866:42 - can place it
866:43 - inside our header tags here we can just
866:45 - do header
866:46 - and we'll close the tag
866:48 - by adding it right here we'll save
866:50 - and we'll head back and now we can see a
866:53 - little connect button here which is
866:54 - great obviously it doesn't look great
866:56 - but we have the functionality here which
866:58 - is what we want if we hit the connect
867:00 - button our meta mask will actually pop
867:02 - up and say hey would you like to connect
867:04 - which account would you like to connect
867:05 - i'm going to go ahead
867:07 - select my first one
867:08 - next connect it's connecting
867:11 - and now i'm actually going to be
867:12 - connected let's go to
867:15 - one of the supported networks like coven
867:17 - and now we can see here we have this on
867:19 - click equals disconnect if i click this
867:21 - now oops i need to actually sorry i need
867:24 - to put this
867:25 - inside the tag here so we just moved on
867:27 - click to be inside of this little button
867:29 - here now we can see it actually says
867:31 - disconnect and if i click it i get
867:32 - disconnected and if i connect i get
867:35 - automatically connected right so if we
867:36 - look at our metamask we can see we're
867:38 - connected right here right that little
867:40 - little green thing we can also manually
867:42 - disconnect by going right into our
867:44 - metamasks click this connected thing
867:46 - here
867:46 - click the account and hit disconnect the
867:48 - account and you'll see our front end
867:50 - does indeed update awesome this is how
867:52 - we can take our meta masks and actually
867:54 - inject it into our front ends so we can
867:56 - actually use the front ends great job
867:58 - this is absolutely massive where we are
868:01 - so far now you might be saying to
868:02 - yourself hey patrick this is cool uh but
868:05 - it doesn't look very good that's kind of
868:06 - a gross button in the top right corner
868:08 - can we can we style this up can we make
868:10 - this look a lot nicer and the answer is
868:12 - absolutely yes so there's a lot of
868:14 - different styling packages out there you
868:16 - can 100 write your own custom ones we're
868:19 - going to be using one called material ui
868:22 - it's a popular react framework for
868:24 - creating components and just doing a lot
868:27 - of styling and doing a lot of really
868:28 - nice work so we're going to be adding
868:30 - this to our project as well so to add it
868:32 - we're just going to use this this line
868:34 - and i'm just going to go ahead and do it
868:36 - myself and come in here we're going to
868:38 - cancel this with control c
868:40 - we do yarn
868:41 - add at material hyphen ui
868:46 - core and this will give us access to
868:49 - some really nice libraries
868:51 - for styling all these buttons installing
868:53 - a lot of the things that we're going to
868:54 - be working with back in our header we
868:56 - can add this styling here so we're gonna
868:58 - do import
868:59 - button
869:01 - make styles
869:05 - from
869:06 - app material
869:07 - hyphen ui
869:09 - core
869:10 - and we're gonna use their button and
869:11 - their make styles if we look in the
869:13 - documentation here you can find there
869:15 - but this is double narration kind of
869:16 - like what their default buttons look
869:18 - like and this looks pretty good looks a
869:19 - lot better than what we currently have
869:21 - we're also going to be taking advantage
869:22 - of their make styles bit here so make
869:25 - styles is a way to actually do styles
869:27 - for based off of different themes that
869:29 - you can actually use with materials ui
869:31 - we're not going to be working with css
869:33 - files because we're going to be working
869:34 - with this make styles instead if you
869:37 - prefer css you can absolutely easily
869:39 - translate these to css files so we are
869:42 - going to add some used styles first of
869:44 - all using make styles so in here we're
869:47 - going to do
869:48 - const
869:50 - use styles
869:52 - equals make styles and this is where we
869:54 - put a theme in here we're just going to
869:56 - set it to be a default theme um there's
869:57 - some documentation if you want to go
870:00 - ahead and add your old themes though so
870:01 - this make styles function it's going to
870:04 - have a container and in this container
870:06 - we're going to add some
870:08 - padding of theme.spacing
870:14 - for we're going to add display
870:17 - flex
870:19 - we're going to add justify content
870:22 - flex end
870:23 - and then we're going to add gap
870:25 - theme.spacing 1.
870:28 - so this is really just some typical css
870:30 - stuff now we're going to take this use
870:31 - styles constant that we just made
870:34 - and down here we're going to do const
870:36 - classes
870:37 - equals
870:38 - use styles so now we have this classes
870:40 - object that we can start working with
870:42 - we're going to take this classes object
870:43 - in our little is connected thing we're
870:45 - going to do div
870:49 - class name
870:50 - equals a little javascript in here
870:53 - classes.container
870:55 - we're going to wrap this whole thing in
870:56 - this div right and this is going to
870:58 - style
870:59 - this whole button div here so now if we
871:01 - go ahead and do yarn start again because
871:04 - we shut it off
871:05 - if we come back here we're going to see
871:07 - it's going to look a little bit
871:08 - different now it's been moved over here
871:11 - we have this like fun little disconnect
871:13 - connect button
871:14 - where there's some padding and it looks
871:16 - a little bit nicer and we're going to
871:17 - change all of our buttons to being kind
871:19 - of this built-in button
871:21 - from the materials ui
871:23 - so we're going to swap out all those
871:24 - buttons with this with our new button
871:26 - here if we go back we can see it's
871:29 - it looks even nicer now now that we've
871:31 - swapped it out with that with that new
871:32 - type of button right it's got a nice
871:35 - little clicky feel to it and then we can
871:37 - also do another line called variant
871:40 - equals contained
871:42 - for each of our buttons
871:44 - so right next to the color primary we'll
871:46 - do
871:47 - variant contained and then now we go
871:49 - back and we have
871:51 - a really nice button now
871:53 - so awesome now we have like a really
871:55 - nice button let's create a component
871:57 - that will contain the meat of our
871:59 - application now though from materials ui
872:01 - we're going to use what's called
872:02 - containers right and these are nice
872:04 - little containers that are going to
872:05 - allow us to style and make these
872:08 - different sections well we can use we
872:10 - can import
872:11 - this container bit from this materials
872:13 - ui
872:14 - by doing import
872:17 - container
872:19 - from at material
872:23 - hyphen ui
872:24 - core
872:25 - in our app.tsx
872:27 - and what we'll do to our header we'll
872:29 - make a little container here
872:31 - container
872:33 - give it a closing tag container
872:35 - and then maybe in here we'll put this
872:37 - little div high right so we'll remove
872:39 - that div we'll paste it in here and now
872:42 - we can see that it's been formatted a
872:43 - little bit right it's been pushed over
872:45 - from the side it still says hi we're
872:47 - going to want to do one more thing we're
872:49 - going to give it a max width of being md
872:52 - oops
872:53 - max width equals md
872:56 - and this max width now if we look in the
872:58 - docs again on materials ui these are the
873:00 - different sizes we have large medium
873:02 - small extra large extra small and then
873:04 - false right these are the different
873:06 - options we can have for max with we're
873:08 - just going to do medium so if we save
873:09 - this now go to wrap we can see it's been
873:11 - pushed over a little bit more it's time
873:13 - to add our main pieces right we're going
873:15 - to need that top piece for staking and
873:17 - the bottom piece for unstaking so we're
873:19 - actually going to create a new component
873:21 - called main and this is going to be our
873:23 - main component so we're going to create
873:24 - a new file in components called
873:26 - main.tsx so let's start by just showing
873:30 - some information about our wallet right
873:32 - showing what we have in our wallet
873:34 - associated with what we have in their
873:37 - smart contracts so we'll say export
873:40 - a constant variable called main and this
873:43 - will be a function here's that syntax
873:45 - for
873:46 - functions in typescript and javascript
873:48 - in order for us to show what amounts
873:50 - that we have in our current wallet we're
873:52 - going to need to know what chain that
873:54 - we're even on because the network that
873:55 - we're on is going to determine where the
873:57 - addresses are right because it's going
873:59 - to be different if you're on coven or
874:00 - mainnet etc now this is where it gets a
874:02 - little bit interesting because obviously
874:03 - with brownie we know where these
874:05 - addresses are right and brownie keeps
874:07 - track of this for us right it does it in
874:09 - our builds folder in our deployments
874:10 - folder if we look there now if you
874:12 - actually deployed something to coven
874:13 - you'll see this 42 you'll see some stuff
874:16 - in here you'll see this map.json which
874:18 - has the most recent deployments
874:20 - of our tokens our tokens and our token
874:23 - farm if you actually deployed it to
874:24 - coven if you haven't deployed it to
874:26 - coven i highly recommend you doing that
874:28 - now as well this way we can test our
874:30 - front ends against a real test net so in
874:32 - order to get these addresses we're going
874:33 - to have to ask brownie hey brownie what
874:35 - are these addresses where are these
874:36 - coming from so we're going to need to
874:38 - grab some information from this brownie
874:40 - config we're basically going to need to
874:42 - get all the information all the
874:44 - information that's in this brownie
874:45 - config right because this has
874:47 - has these addresses already and this is
874:49 - what we want however it's really hard
874:51 - for node.js to work outside of this
874:53 - source folder so what we're going to
874:55 - want to do is we're going to want to
874:56 - send that brownie config to our front
874:59 - end the way we're going to do that is
875:00 - we're going to actually modify
875:02 - by adding a new function
875:04 - called
875:05 - def
875:06 - update
875:07 - front end now the only reason that this
875:09 - works is because we have both our
875:11 - contracts and our frontend in the same
875:13 - repository in the real world once you
875:15 - deploy your contracts those addresses
875:17 - are pretty much set so you can just copy
875:19 - paste them over to your front end
875:20 - repository but for us we don't have set
875:22 - contracts yet so we need a way to update
875:24 - our front end so what we're going to do
875:26 - is we're going to send that brownie
875:28 - config
875:29 - over to the front end right that way our
875:31 - main
875:32 - can know where those addresses are
875:34 - we're also going to need to send
875:36 - so we need to send the brownie config
875:40 - to our
875:41 - source
875:42 - folder we're also going to send
875:46 - the build folder
875:47 - why because this will have access to the
875:49 - dap token address or any other mock
875:52 - addresses that we're using we're going
875:53 - to open up our brownie config and we're
875:55 - going to paste and we're going to dump
875:57 - the config into that source folder now
876:00 - typescript doesn't work with the ammo so
876:02 - well it works with json really well so
876:04 - we're actually going to convert it from
876:06 - yaml to json and dump it to the front
876:08 - end so we're going to open up our
876:09 - brownie config we're going to say with
876:12 - open
876:14 - brownie
876:15 - config
876:17 - yaml
876:18 - we're going to open it in
876:21 - read format
876:23 - we're going to say as
876:24 - brownie config
876:27 - we're going to say config
876:29 - dictionary
876:30 - equals
876:32 - yaml dot load
876:33 - brownie config
876:36 - loader equals yaml dot
876:42 - full loader
876:44 - so we're gonna have to import this yaml
876:46 - from the top we're gonna do
876:48 - import yaml
876:50 - and what this yaml is gonna do
876:52 - is it's going to allow us to
876:54 - load our yaml into a dictionary that's
876:57 - really it so you probably don't have it
876:58 - right now you're going to want to run
877:00 - pip install
877:02 - pi yaml
877:03 - to actually get it now we'll be able to
877:05 - have that now that we've got this in a
877:06 - dictionary we're going to want to send
877:09 - this to the front right we're going to
877:10 - want to write this dictionary as a json
877:12 - object to our front end so we're going
877:14 - to say with
877:15 - open we're going to open that front end
877:19 - source folder
877:20 - and that's just where we're going to
877:21 - dump this file we're going to call it
877:22 - brownie
877:24 - config
877:26 - dot json
877:27 - we're going to open this new file
877:29 - in write mode we'll say it's as
877:33 - brownie
877:34 - config json
877:37 - what we're going to do is just do what's
877:38 - called a json dump we're just going to
877:40 - take this dictionary and dump it as json
877:44 - into this file so we're going to say
877:45 - json.dump
877:48 - config dick
877:50 - brownie
877:52 - config
877:54 - json
877:55 - of course we're gonna have to import
877:56 - json and then at the end we'll even
877:58 - print
878:00 - front and updated so now we have this
878:02 - update front end script what we can do
878:05 - when we run our deploy token in-depth
878:08 - token we can just add this update front
878:10 - end bit now we don't want to always
878:12 - update the front end right we only want
878:13 - to do when we're working with the front
878:15 - end so in our deploy token farm in depth
878:17 - token we're going to set update front
878:20 - end
878:21 - equals false so by default this is false
878:24 - this way when we run our tests
878:26 - the front end won't get updated right
878:28 - and down here we'll just say
878:30 - if update front end
878:32 - and we'll update the front end otherwise
878:34 - we won't
878:36 - and in our main function here we'll just
878:38 - say update
878:39 - frontend equals true now if we deploy
878:42 - this to coven or rink b we'll
878:44 - automatically update and send this
878:47 - browning config and then let's actually
878:48 - change this to front and update instead
878:51 - of update front end so that we don't
878:53 - have the same method name as our boolean
878:54 - here so we'll do front
878:56 - and
878:57 - update instead so now
878:59 - when that we deploy
879:01 - we'll actually go ahead and update our
879:03 - front end here but we're not always
879:05 - going to redeploy so let's also
879:07 - create an up
879:09 - date front end dot pi script
879:12 - and this we'll just call that function
879:13 - that we just made so we'll do def main
879:16 - update
879:17 - front end and then we'll do from
879:20 - scripts
879:21 - dot deploy
879:23 - import update
879:26 - front end semicolon there great
879:30 - let's open up a new shell
879:31 - by hitting a little plus button here now
879:33 - we have two shells and we can just do
879:35 - brownie
879:36 - run scripts
879:38 - update front end doesn't matter the
879:40 - network
879:42 - and what this is just going to do
879:44 - it's just going to run that copy script
879:46 - right it's going to run our
879:48 - our update front-end script which we
879:49 - made right here so if we did this right
879:51 - we should now have a brownie config.json
879:54 - in our end
879:56 - source directory so if we go in here we
879:58 - go into our source directory we can
880:00 - indeed see it's right in here do we need
880:02 - anything else well so that's going to
880:03 - give us those addresses right it's going
880:05 - to give us it's going to give us some of
880:07 - the addresses but it's not going to give
880:08 - us everything what about dap token right
880:12 - the app token isn't going to be
880:13 - something in our brownie config last
880:15 - token and fau token sure they'll be in
880:16 - our config but dap token is going to be
880:18 - something that only is going to be
880:20 - deployed by us so we need to send that
880:22 - to the front end too we need to send
880:24 - basically our whole build folder so
880:26 - we're going to need to update this
880:28 - update frontend script to also send
880:30 - send the build folder i know that we're
880:32 - actually going to be copying a number of
880:34 - different folders so i'm just going to
880:35 - go ahead and make a new function called
880:38 - copy folders
880:40 - to front
880:42 - end
880:43 - and in here so we're going to make this
880:45 - copy folders to front end function here
880:47 - we're going to do a couple of clever
880:49 - python things this is going to take a
880:51 - source and a destination so we want a
880:54 - source folder and then a destination
880:56 - folder so we're going to copy this build
880:58 - folder and move it to you know some
881:00 - folder in the front end first we're
881:02 - going to check that that destination
881:03 - exists and if it exists we're gonna kill
881:06 - it we're gonna we're just gonna remove
881:07 - it so we're gonna say if os.path dot
881:09 - exists destination we're gonna do this
881:12 - shuttle dot rm tree
881:14 - dest
881:15 - and this is gonna kill everything so we
881:18 - need to import both of those we're going
881:19 - to import os
881:21 - we're going to import
881:22 - shuttle or shutil i actually have no
881:25 - idea how to pronounce that but we're
881:26 - going to remove that whole bit and we're
881:28 - just going to copy everything over from
881:31 - our build folder so we're going to do
881:32 - shuttle dot copy tree src
881:36 - dest so we're going to say hey if that
881:38 - build folder exists in the front end
881:40 - just delete it and we're just going to
881:42 - copy everything over from the build
881:44 - folder and we're going to do this copy
881:46 - folders to frontend a few times
881:48 - the first thing of course like i said is
881:50 - going to be with this build folder so
881:52 - we're going to do this copy folders to
881:54 - frontend the source
881:56 - is going to be dot slash build so we're
881:57 - going to take this whole build thing and
881:59 - we're going to move it to
882:01 - dot slash
882:03 - front end
882:05 - src and we're gonna create a new folder
882:07 - in here called chain
882:09 - info right and this is just gonna have
882:12 - all of the build information
882:14 - and all right
882:15 - cool so now we can run that
882:17 - brownie run scripts update frontend
882:20 - we'll go ahead and run that
882:22 - and great front end is now updated so if
882:25 - we look at our front end we're looking
882:26 - source
882:27 - we now have this chain info folder which
882:29 - is literally just the build folder which
882:31 - is awesome now we can actually start
882:33 - working with these pieces in our front
882:35 - end so let's figure out how to get the
882:38 - depth token address
882:40 - well to get this dap token address we're
882:42 - going to need
882:43 - that map that we just got from chain
882:45 - info in our deployments but we're also
882:48 - going to need to know what chain that
882:50 - we're currently on like what we saw
882:51 - before we have this chain id
882:54 - from used app core which will tell us
882:56 - what chain id of the current network
882:59 - that we're on
883:00 - so we can go ahead and import that in
883:01 - here as well so we're going to do is
883:03 - we're going to import
883:05 - use ethers again
883:06 - from
883:08 - at use dap
883:10 - core what we're going to do here
883:12 - is use ethers
883:14 - allows us to get the chain id that we're
883:16 - working on so we can say cons
883:18 - chain id
883:21 - equals
883:22 - use ethers now that we have the chain id
883:25 - we're going to have to map it to the
883:27 - name of the network right because our
883:29 - browning config has this network section
883:31 - but it's mapped by the name of the
883:33 - network not by the id
883:36 - so what we're actually going to do
883:38 - is we're going to create a helper config
883:40 - in our src
883:42 - so we're just going to create a new file
883:43 - helper config
883:46 - dot json and it's literally
883:49 - just going to be a json object that maps
883:51 - numbers to their associated chain names
883:54 - so 42 for example is going to be kovan
883:56 - four is going to be rank b one three
883:59 - three seven gonna be dev
884:01 - or it could also be ganache right one is
884:04 - gonna be mainnet etc now that we have
884:06 - this helper config we can do import
884:08 - helper config
884:10 - from
884:11 - dot dot slash
884:12 - helpworkconfig.json
884:15 - and before we even get the dab token
884:17 - address we can do const network
884:20 - name is going to equal that helper
884:23 - config
884:25 - at the chain id now typescript is
884:28 - actually going to get a little bit mad
884:29 - at us here so we need to add a little
884:32 - bit more to this line actually so we
884:34 - need to say okay only grab from this
884:36 - helper config if chain id exists right
884:39 - because there might be a chance that
884:41 - train chain id is nothing or it's
884:42 - something really weird so we're going to
884:44 - say chain id i'm going to use this
884:46 - tertiary tertiary operator again we're
884:48 - gonna say if this chain id exists
884:51 - then go ahead and use the helper config
884:54 - however if it doesn't exist
884:57 - just use dev i should spell
884:59 - chain id right so it doesn't get really
885:01 - confused to me and whenever we return
885:03 - one of these components or try to use
885:04 - one of these components we're always
885:06 - going to have to return some type of
885:08 - html or div tag like this we head over
885:10 - to our app
885:12 - we add our little main bit here
885:15 - of course we're going to want to import
885:16 - this say import
885:18 - main
885:20 - from
885:21 - dot slash components
885:23 - slash main we save it we'll add our
885:27 - main tag
885:28 - syntax we're basically saying in it now
885:30 - depending on your setup you might
885:32 - actually run into this error here saying
885:34 - element implicitly has an any type
885:37 - because expression blah blah blah you
885:39 - might be saying okay well what's going
885:41 - on here now to make our lives easier
885:43 - we're going to tone down typescripts
885:46 - strictness here so what we're going to
885:47 - do
885:48 - is in our typescript config.json we're
885:52 - actually going to add suppress
885:54 - implicit
885:56 - any index errors
885:58 - so we're basically suppressing when we
886:00 - get this type of error because it's not
886:01 - ever actually going to affect anything i
886:03 - should probably i should probably spell
886:05 - this correctly we'll save it
886:07 - now if we save this file here
886:09 - we're going to actually get this saying
886:12 - everything's compiled everything looks
886:13 - good
886:14 - and if we refresh our front end we're
886:16 - gonna get back to exactly where we are
886:18 - before
886:19 - now what we can also do is we can also
886:20 - console.log these out we can also see in
886:23 - the console
886:24 - exactly what these are gonna look like
886:26 - so if we do console.log chain id and
886:29 - console.log network name
886:31 - we save and we go back we can go hit
886:34 - inspect
886:36 - go to the console
886:37 - and we'll see 42 and coven gets printed
886:41 - out in the console over here so that's
886:43 - 42 is the chain id and coven is the
886:46 - is the network name so we know that
886:48 - we're doing this right okay great
886:50 - so we have
886:51 - our network name and we have a chain id
886:54 - we've got a way for us to update our
886:56 - front end with a new script let's
886:59 - finally get those different addresses
887:00 - that we need say the constant variable
887:04 - gap token address
887:06 - is going to equal
887:08 - something from that build folder or that
887:11 - chain info folder that we created inside
887:13 - here inside deployments we have this
887:15 - map.json
887:17 - and since i've already deployed this to
887:19 - coven
887:20 - we have dap token and token farm on the
887:22 - cova network so we can then use that and
887:25 - say
887:26 - if
887:27 - if we are connected to a chain id and
887:29 - that's again that's what this question
887:30 - mark is doing
887:32 - saying if this chain id exists
887:34 - then
887:35 - look into that mapping else we're just
887:38 - going to use a zero address right so how
887:41 - do we actually get this mapping in here
887:43 - though so i'm going to say import
887:47 - network
887:48 - mapping
887:49 - from
887:50 - this is going to be in that chain info
887:53 - folder
887:55 - inside the deployments
887:56 - deployments
887:58 - and it's just going to be map.json
888:01 - so we're going to take this network
888:02 - mapping object
888:04 - and we're going to say if the chain id
888:05 - exists
888:06 - then inside this network mapping json
888:09 - object we're going to
888:12 - cast
888:13 - that chain id
888:15 - as a string
888:17 - and then we're going to grab
888:19 - the name of the dab token which is going
888:21 - to be dap token and we're going to grab
888:23 - whatever address is at the top right so
888:26 - this is going to be a big list the more
888:28 - times we deploy
888:29 - the more times brown is going to keep
888:31 - track of it and there's going to be all
888:32 - these different addresses and we just
888:33 - want this one right at the top right we
888:35 - want the most recent one here so we're
888:37 - just going to say at position zero
888:39 - otherwise if we're not on a chain id
888:42 - we're just going to use a zero address
888:44 - and ether's js actually has a really
888:46 - nice package to give us what's called
888:49 - constants so we're going to do
888:51 - constants
888:52 - dot
888:54 - address zero
888:56 - and we can import that from ethers
889:00 - so we'll do import
889:02 - cons
889:04 - dance
889:06 - from
889:07 - ethers
889:09 - if you don't already have ethers
889:11 - installed here
889:12 - we're going to do
889:14 - cd front end we're going to do yarn add
889:17 - ethers
889:19 - and now we have the ethers package in
889:21 - here now we're not going to do the same
889:23 - thing for the weft token or the fau
889:25 - token
889:26 - because those tokens are defined in the
889:28 - brownie config as opposed to being
889:31 - defined in our map.json here so to get
889:34 - those ones we're going to say const
889:36 - with token address
889:38 - it's going to equal let's check first if
889:40 - the chain id exists and if it does
889:42 - we're going to grab it from
889:44 - the brownie config so to grab that
889:46 - we're going to do
889:48 - import
889:50 - brownie config
889:52 - from
889:53 - again now that we've imported it
889:56 - brownie config.json
890:00 - now we can work with this brownie config
890:02 - inside of our front end so we'll say
890:04 - browning config
890:08 - of networks
890:09 - of that network name of the
890:12 - left token and if chain id oops chain id
890:17 - does not exist then once again
890:19 - we're gonna do constants dot address
890:22 - zero so we're just gonna leave it blank
890:24 - and then we're going to do the exact
890:26 - same thing for the fau slash the die
890:28 - token so we'll do const fau
890:31 - token address
890:34 - equals chain id question mark
890:37 - so if the chain id does exist it'll be
890:39 - the brownie
890:40 - config
890:43 - networks
890:46 - network name
890:50 - fau token
890:52 - and if chain id doesn't exist it'll be
890:55 - constants
890:56 - dot
890:58 - address
890:59 - zero
891:00 - okay awesome
891:02 - and if we save it
891:03 - oops looks like i put in an extra
891:05 - comment there by accident i'm just gonna
891:07 - get rid of that and resave
891:09 - and then refresh here so i'm getting an
891:12 - issue
891:12 - uh because i'm on the rink beat chain
891:14 - right now and it's saying hey there's no
891:17 - there's nothing for rink there's no dap
891:18 - token for rink b you gotta be on coven
891:20 - so if i go back to coven here
891:23 - and i refresh now it works out fine
891:26 - right this might still break for you if
891:28 - you're on coven and you haven't deployed
891:30 - anything to coven we can fix this in our
891:33 - config for the dap provider by changing
891:35 - the supported chains for this now
891:37 - typically a lot of the times you're
891:38 - going to want to test using a ganache
891:40 - chain or some type of local chain so
891:41 - that your front end testing can be a lot
891:43 - faster for this we're just going to do
891:45 - everything on coven but a nice little
891:47 - challenge for you would be to refactor
891:48 - this so that it also works with
891:50 - something like ganache and we're going
891:51 - to not use ganache so i'm just going to
891:53 - go back to app.tsx
891:55 - we're going to remove ganache
891:57 - even we're going to even remove rink b
891:59 - for now we're just going to work with
892:00 - coven just to make it simple if i go to
892:02 - our react page now
892:04 - refresh i can connect
892:06 - awesome
892:07 - if i go to
892:08 - ring b it's not going to freak out
892:10 - because it says hey ring b is not even
892:12 - supported so i don't care what you're
892:13 - doing
892:14 - however covent is supported
892:17 - so we're connected and we're looking
892:18 - good and the thing is we really don't
892:20 - want to couple our front end with our
892:22 - contracts right we really want to code
892:24 - the contracts independently and the
892:26 - front end independently anyways so let's
892:28 - get back into our
892:30 - main.tsx because we're going to be in
892:32 - here for a while but we've already done
892:34 - some great things we've gotten what
892:36 - network we're on what chain id we're on
892:38 - and we've gotten the different addresses
892:40 - for these different tokens so as you can
892:41 - probably see
892:43 - the place that we're actually going to
892:44 - put stuff on the front end is in this
892:46 - little return statement here right right
892:48 - now we're just returning i'm main and we
892:50 - just see my main right here to do this
892:53 - we're actually going to make another
892:54 - component we're going to make a
892:56 - component called your wallet this
892:58 - component is going to be a part of this
893:00 - main component here it's a component
893:02 - inside of a component that is literally
893:04 - only going to address our wallet needs
893:08 - so in our little components tab here
893:10 - we're going to go ahead and create a new
893:11 - folder
893:12 - and we're going to call it your
893:14 - wallet and this is just going to have
893:16 - everything to do with our wallet in here
893:18 - so let's get in here we'll create a new
893:20 - file because we're going to actually
893:21 - make a couple files and our first one is
893:24 - going to be your wallet.tsx
893:27 - this is going to be our component that
893:28 - is just going to deal with getting our
893:31 - wallet getting the token balances of the
893:33 - different tokens that we have since we
893:35 - know we're going to put this component
893:36 - in main and main is in our
893:39 - our home base our app.tsx you know that
893:42 - we're going to do an export
893:44 - const
893:45 - your wallet
893:47 - in here and we'll make this a function
893:49 - now in order to actually show these
893:51 - tokens we do need to
893:53 - get some information from our other
893:54 - component we need to get some
893:56 - information on what the supported tokens
893:58 - even are
894:00 - so we're going to have our main
894:02 - actually pass a variable
894:05 - to our wallet here
894:07 - we're going to call it the supported
894:10 - tokens
894:11 - and this is going to be of type
894:14 - your wallet props
894:19 - and this is going to be a your wallet
894:21 - props here just to tell typescript what
894:23 - this is what this supported tokens is
894:25 - going to look like we're going to say
894:27 - interface your wallet props it's going
894:30 - to look like this
894:31 - supported tokens
894:33 - and it's going to be an array
894:36 - of tokens and array of some token
894:40 - we're going to grab that token type
894:42 - from main as well so actually we're
894:44 - going to do import
894:45 - token
894:48 - from
894:50 - main
894:51 - and in our main we're going to pass this
894:53 - token and we're going to pass some
894:55 - supported tokens to our wallet
894:57 - so right underneath those three token
895:00 - addresses
895:01 - back in main we're going to do const
895:03 - supported tokens
895:05 - is going to be an array
895:08 - of token this token type
895:11 - so above here
895:13 - we do export
895:15 - type token
895:17 - equals
895:19 - and we're going to say a token type is
895:20 - going to involve an image which is going
895:23 - to be a string
895:24 - an address which is also going to be a
895:26 - string
895:27 - and a name which will also be a string
895:30 - so we're creating a new type called
895:31 - token here in our main function
895:34 - we're creating this supported tokens
895:37 - object which is an array of tokens and
895:40 - this is excuse me and this is going to
895:41 - equal
895:42 - that array syntax
895:45 - so our first token
895:47 - is going to be
895:48 - have an image
895:50 - that we haven't defined yet
895:53 - the address
895:54 - is going to be
895:56 - this dap token address
895:59 - and the
896:00 - name the name of course is going to be
896:04 - gap for dap token
896:06 - now we're going to need a couple images
896:08 - so at this point you should see where
896:10 - we're going with this we create this
896:11 - array of supported tokens
896:13 - first is our dap token and we need an
896:15 - image for this dap token so if you're
896:17 - following along you can just grab this
896:19 - image right off of the github
896:21 - and we're going to grab that dab token
896:23 - and we're going to pop it into src
896:26 - we're going to change this to
896:28 - dap.png
896:30 - now we can import this by doing import
896:33 - dap from dot dot slash dap dot png
896:38 - now i can take this dap image
896:40 - and under image i'll put
896:42 - now let's do the other tokens so we'll
896:44 - do a comma we'll do image
896:47 - we'll be f
896:48 - oops
896:50 - f
896:51 - address will be
896:53 - weath token
896:55 - with token address name will be
896:59 - wef
897:00 - and again we can either oh and let's
897:02 - close this off
897:03 - and again we can either grab right from
897:05 - my github or pop it into my src here
897:08 - we'll change this to f dot png we'll
897:11 - scroll up and we'll import this as well
897:13 - import f from dot dot slash at that png
897:18 - and boom that looks good
897:20 - one more comma image
897:22 - it's going to be
897:23 - fau
897:25 - or
897:26 - it's going to be our die token
897:28 - address is going to be fau
897:32 - token address
897:34 - name
897:36 - it's going to be fau
897:39 - or die
897:40 - this will be our die token
897:42 - we'll pop it into our src
897:45 - change the name to
897:46 - die dot png no import
897:50 - die from dot dot slash die dot png
897:54 - grab die and it looks like we're going
897:56 - to name it die actually instead and if
897:58 - your vs code starts yelling at you about
898:00 - this can't find module it's really
898:02 - confused what we're going to do at the
898:04 - top here so we're just going to add a
898:06 - little comment backslash star eslint
898:10 - disable
898:11 - spaced
898:13 - comment
898:16 - star backslash
898:18 - dash dash dash
898:20 - ref
898:21 - errant
898:23 - types
898:24 - equals react
898:26 - scripts
898:29 - and we'll save and that issue will go
898:31 - away
898:32 - all right well now that we have
898:34 - our supported tokens token array we can
898:37 - actually pass this to
898:39 - that your wallet bit
898:41 - right so now we're going to
898:42 - go to this return bit we're going to
898:44 - remove that div on main and we're going
898:46 - to actually start getting to some meat
898:47 - here so we're going to pass this to our
898:50 - your wallet component that we're going
898:52 - to import in just a second
898:53 - and we're going to send it our
898:55 - supported tokens let's say supported
898:58 - tokens equals
899:00 - supported tokens
899:02 - backslash like this
899:05 - and of course we're gonna have to import
899:06 - your wallet here
899:08 - so we'll scroll to the top we'll do
899:10 - import
899:12 - your wallet
899:14 - from
899:15 - dot slash
899:17 - your
899:18 - wallet
899:19 - we're actually going to make a new file
899:21 - in our your wallet folder called
899:23 - index.ts
899:25 - and we're just going to export
899:28 - your wallet
899:31 - from dot slash your
899:34 - wallet
899:35 - save that
899:37 - i'm getting an issue
899:39 - [Music]
899:40 - saying you wallet it's not defined
899:43 - it's because this should be your wallet
899:46 - okay cool so we're getting another issue
899:48 - but i'm going to fix that in a second
899:49 - great so now we have some supported
899:50 - tokens
899:51 - we have a wallet here
899:54 - we're exporting our wallet with our
899:56 - index.ts and our your wallet
899:58 - folder now let's finish our your wallet
900:01 - implementation
900:03 - and this needs a little equal sign here
900:05 - whoops
900:06 - and we're going to get this little error
900:07 - basically because we don't have a return
900:09 - here
900:10 - so we could just do return
900:12 - just to make it happy div
900:18 - hi
900:20 - and we'll even change this to i'm your
900:23 - wallet and we'll save and now
900:25 - everything's happy we'll go to our front
900:26 - end we'll do a quick refresh and now we
900:28 - see i'm your wallet so let's keep diving
900:31 - into your wallet here right because this
900:32 - is going to be
900:33 - where we're doing all of this stuff
900:35 - about what's in your wallet now we're
900:37 - going to use a couple of these
900:38 - components from the materials ui here to
900:40 - get started
900:42 - to start we're just going to use this
900:44 - box the box component it serves just as
900:46 - a wrapper component for most of the css
900:48 - utility needs it's
900:50 - just a box right it's a box that we can
900:52 - put on our front end so we're going to
900:54 - come over in into our your wallet and
900:57 - we'll start working with this box we're
900:59 - going to put everything
901:00 - inside
901:02 - of this little
901:04 - this little box here
901:05 - i'm going to import this box
901:08 - import
901:09 - box
901:11 - from
901:11 - [Music]
901:13 - at material
901:15 - ui core
901:17 - we'll give this a little header
901:19 - h1 we'll say
901:21 - your wallet
901:25 - h1
901:28 - get a little header your wallet on your
901:30 - wallet great
901:32 - now we'll get rid of this little i'm
901:33 - your wallet and we'll create another box
901:36 - and in here we're going to add
901:38 - all of our functionality for
901:40 - what is in our wallet now we're going to
901:42 - use some tabs here
901:43 - from the materials ui
901:45 - to swap between the tokens right we're
901:47 - going to have one tab for
901:49 - fau token another tab for zap token and
901:53 - for wrapped ether we're going to use
901:54 - this this this tabs thing here so to
901:56 - work with tabs we're going to need to
901:58 - import some
902:00 - tab stuff so we're going to import
902:04 - tab context tab list
902:08 - and tab panel
902:10 - from
902:12 - material ui
902:14 - lab
902:15 - so material ui
902:16 - material i slash lab these are some
902:18 - components that they're not quite ready
902:20 - to move to the core so we do have to add
902:22 - these as well so we'll go to our front
902:24 - end and our other shell and we'll do
902:26 - yarn add
902:27 - and material ui
902:29 - lab these are kind of their testy ones
902:31 - but they have some really nice features
902:32 - that we're going to use but let's get
902:34 - into this box and let's make
902:36 - our first tab context
902:39 - value
902:40 - equal to
902:42 - now in our box here the first tab
902:45 - that we're going to have to use is going
902:46 - to be whatever token that we have
902:47 - selected
902:48 - to select tokens we're going to use
902:50 - what's called a state hook
902:52 - so we're going to create a state hook
902:54 - here inside of this
902:56 - we're going to do
902:58 - const
903:01 - selected token index
903:04 - set selected token index
903:09 - equals
903:10 - use
903:11 - state
903:12 - number
903:14 - zero
903:15 - so use state we're going to grab from
903:17 - react it looks like i've already
903:19 - imported here
903:20 - import react
903:21 - comma
903:23 - brackets use state
903:24 - from react
903:26 - and what this is going to do it's going
903:28 - to create one variable select the token
903:30 - index this is going to be whatever token
903:33 - that we're on and then set selected
903:35 - token index is going to update this
903:37 - selected token index this u state state
903:40 - components thing is a way of saving
903:42 - state
903:43 - between renders of components so in our
903:45 - little box here
903:47 - we're going to start with a tab context
903:50 - we'll start basically with our own tab
903:52 - and the value is going to be equal to
903:55 - whatever
903:56 - token we currently have selected dot to
903:59 - string
904:03 - and we're gonna have to make a list of
904:04 - these tokens in our tab context
904:07 - we're gonna have to add some way to
904:09 - change
904:10 - between the tabs right when we change
904:12 - between the tabs we want a different
904:13 - token to be selected and we're going to
904:15 - make a
904:16 - tab list that's going to change whenever
904:18 - we
904:19 - click the different tab so
904:21 - we're going to add we're going to add
904:22 - some functionality to this but for now
904:24 - we're just going to give it an aria
904:26 - label
904:28 - call this our
904:30 - stake form tabs and based off the
904:33 - supported
904:35 - tokens
904:37 - in a mapping
904:39 - of token to index
904:41 - we're going to call a function in here
904:43 - where we return
904:44 - a tab
904:46 - which will have a label equal to the
904:49 - token.name the value would be equal to
904:52 - the index
904:54 - dot string or excuse me dot 2 string
904:58 - and the key
904:59 - is going to be equal to
905:02 - the index
905:03 - tab is something that is just from the
905:05 - material ui core so we're going to
905:08 - import
905:10 - tab
905:12 - from
905:13 - that material
905:15 - ui core
905:17 - i should probably spell supported tokens
905:19 - correctly
905:20 - supported tokens now
905:23 - if we look at our ui we can now see
905:24 - we've got a couple different buttons
905:26 - here which great we have dap west and
905:28 - die right these are the different
905:29 - supported tokens that we're mapping here
905:33 - now of course if we click the different
905:34 - buttons
905:35 - nothing actually happens so we do need
905:37 - to to handle a change we do need to code
905:39 - some functionality to handle a change
905:41 - whenever we do something different so in
905:43 - our tab list we're going to add on
905:46 - change
905:48 - on
905:49 - change
905:50 - equals
905:52 - handle
905:53 - change
905:54 - i'm going to code a little functionality
905:56 - at the top to actually handle a change
905:58 - so we'll say const
906:00 - handle change
906:03 - equal to
906:04 - an event
906:07 - a react dot
906:08 - change event
906:10 - we'll do a new value
906:11 - it's gonna be a string
906:13 - and this is a function
906:14 - so we're gonna do this little function
906:16 - syntax again
906:17 - and all we're going to do is we're going
906:18 - to use our little state hook here so
906:20 - we're going to do set
906:22 - selected
906:23 - token index
906:25 - and we're going to parse
906:27 - the int
906:28 - of the new value that we get
906:32 - so what's happening here we've added
906:34 - this new functionality where whenever we
906:36 - change
906:37 - one of those tabs we're going to change
906:39 - this the selected token right this
906:42 - selected token number is going to be
906:43 - different and what we do is we map the
906:46 - indexes to a token right so each one of
906:49 - these tokens is going to represent a
906:50 - certain number so now when we save let
906:53 - me go check out our front end you can
906:54 - now see that we do indeed swap between
906:58 - tabs here which is really nice all right
907:00 - let's keep going so that's cool we have
907:02 - a way to swap between the different
907:04 - tokens visually here but we need a big
907:07 - stake button right the reason that we
907:09 - need to swap between the tokens is
907:10 - because we need a way to stake
907:13 - between them
907:14 - so when we're on one of these tabs we're
907:17 - going to add a stake form here we're
907:19 - going to add a big button that allows us
907:21 - to stake so we're going to do some
907:22 - typescript we're going to do supported
907:25 - tokens.map
907:27 - i'm going to map that token and index
907:29 - again
907:30 - function use that and then here we're
907:32 - going to return
907:33 - a different tab panel
907:36 - the value in here is going to be the
907:37 - index
907:40 - dot to string
907:42 - key is gonna be
907:44 - the index
907:45 - we'll make a little div in here
907:48 - and we're gonna need to put two pieces
907:49 - in here we're gonna need to be putting
907:51 - our wallet balance in here and then also
907:53 - a big
907:55 - stake button right
907:57 - of course we're looking at right now
907:59 - it's just going to say our wallet
908:00 - balance and a big stake button but how
908:02 - do we actually do this how do we
908:03 - actually get our wallet balance and one
908:05 - of these big stake buttons
908:07 - well we're probably going to need some
908:09 - type of component to get our actual
908:11 - wallet balance that we're going to stick
908:12 - in here
908:13 - so yup you already know we're going to
908:15 - go in here into our your wallet
908:17 - component we're going to create a new
908:19 - file and this is where we're going to
908:20 - define
908:22 - that wallet balance component and we're
908:25 - going to import our wallet balance
908:27 - into our wallet here so that we can
908:28 - actually see
908:30 - the balance of our wallet right in the
908:31 - front end and right and this is where
908:33 - we're going to actually be reading off
908:35 - chain finally after a lot of typescript
908:38 - and react setup since we're going to be
908:40 - importing this into our your wallet
908:42 - component here of course we're going to
908:43 - start with export const
908:46 - wallet balance
908:48 - we're going to make this a function so
908:50 - we'll do this
908:51 - really weird
908:53 - function syntax and we're probably going
908:55 - to want to pass this
908:56 - the token right the token that we want
908:58 - to get the balance of
909:00 - so we're even going to set that up like
909:02 - this a token in here
909:04 - and we'll define
909:09 - what this looks like uh with the
909:11 - interface called wallet balance props so
909:14 - we'll say export interface
909:17 - wallet balance props
909:22 - and this will be
909:24 - a token right
909:26 - this will be that same
909:28 - token type that we defined before so
909:31 - we're gonna have to import that so we'll
909:32 - say import
909:35 - token
909:36 - from
909:36 - [Music]
909:38 - main
909:39 - all right great that's our initial setup
909:41 - here we'll grab
909:43 - from the token that we passed to this
909:45 - we'll pass we'll get the image
909:48 - address
909:49 - and the name
909:50 - from that token
909:51 - address and name
909:53 - we'll grab the account right because
909:55 - we're going to need the account with
909:56 - along with the token
909:58 - so we'll say const
910:00 - account
910:01 - equals use ethers
910:05 - and of course
910:07 - we're gonna have to import
910:09 - account
910:11 - from
910:12 - excuse me imports not account use
910:17 - ethers
910:18 - from at use dap
910:21 - slash core
910:22 - we're gonna need the account we're gonna
910:24 - need the address and use dab core has a
910:27 - nice little hook
910:29 - called
910:31 - use token balance that we're going to
910:32 - use you look check it out in the
910:34 - documentation provides a way to fetch
910:36 - the balance of erc20 tokens specified by
910:39 - a token address it makes our lives a lot
910:41 - easier so we'll just import that as well
910:43 - use
910:44 - token balance and all we have to do
910:47 - really is do const
910:49 - token balance
910:52 - equals
910:53 - use
910:54 - token balance
910:58 - of the address of the token
911:00 - and our count here we can even do a
911:02 - quick console.log
911:05 - token balance
911:07 - see if we're doing it correctly and we
911:10 - take this wallet balance and import it
911:12 - into our wallet here
911:14 - we should be able to see
911:17 - something so we'll import it into our
911:19 - wallet now let's go into the top we'll
911:21 - do
911:22 - import wallet
911:24 - balance from
911:26 - dot slash
911:29 - wallet balance and down inside our very
911:32 - large return function here we'll add
911:34 - this new
911:36 - tab
911:37 - or this new uh component we'll say
911:40 - wallet balance
911:43 - we still remember we need to send it the
911:45 - token
911:46 - so we'll send it
911:47 - tokens
911:48 - at the index of the selected
911:51 - token index
911:53 - i should spell supported tokens right
911:57 - i should spell wallet balance right
911:59 - capital b we do need to do a return
912:02 - so that it's actually a jsx component
912:04 - we'll do a div
912:06 - we'll just have to say i'm the wallet
912:10 - balance if we go to our front end we do
912:13 - a quick refresh
912:14 - we do indeed see this little print line
912:16 - here uh this is javascript's big number
912:20 - so if we really want to see this token
912:21 - balance we'll do dot to string
912:24 - and we have to put this question mark
912:25 - here to tell typescript hey
912:27 - turn it to a string if it's not
912:29 - undefined and now if we save we go to
912:32 - our front end
912:33 - we do a refresh
912:35 - since we are connected
912:37 - to coven here we can see
912:40 - we get an amount printed out here and if
912:41 - we switch tabs
912:44 - you'll see
912:45 - the different amounts being printed here
912:47 - which is fantastic cool so let's remove
912:50 - this little console.log we want to show
912:52 - this token balance obviously in our ui
912:55 - right we don't want to have people to
912:57 - have to go to the console.log right to
912:59 - actually see it we want it to represent
913:01 - we want to show up where it says i'm the
913:02 - wallet balance so what we're gonna do
913:04 - first we should probably format it
913:06 - right because this is in units of way
913:09 - so we're gonna do const
913:11 - formatted
913:12 - token balance
913:13 - this will be a number which will equal
913:15 - to
913:17 - token balance
913:19 - if token balance does exist
913:22 - again we're using this tertiary operator
913:24 - we're going to parse
913:26 - float
913:28 - format
913:29 - units
913:31 - balance
913:33 - 18
913:34 - otherwise we're just going to use zero
913:36 - format units is a nice little import
913:38 - that we're going to grab from
913:41 - the ethers project so we'll do import
913:44 - format units
913:46 - from at ether's project
913:50 - slash
913:51 - units
913:52 - and of course
913:54 - yarn add at ethers project and of course
913:57 - we're going to do a yarn add on this
913:59 - here we'll do yarn add
914:02 - at ether's project units and now this
914:05 - formatted token balance is going to be
914:07 - this token balance that we just got but
914:09 - formatted formatted much nicer in our
914:11 - little div here what we could just do so
914:14 - we could just add this formatted token
914:16 - balance
914:17 - we'll save and we'll look at the front
914:19 - end now
914:20 - and aha
914:21 - we now see we have 100 dapp zero weft
914:24 - and 15 die right these numbers might be
914:26 - a little bit different depending on how
914:28 - much you actually got but this is
914:29 - perfect this is exactly what we're
914:30 - looking for so let's close out the
914:32 - console and
914:34 - let's let's flesh this out a little bit
914:35 - let's make this look a little bit nicer
914:38 - here so instead of just returning a
914:40 - little div like this let's actually make
914:42 - a new component called
914:45 - balance message
914:47 - and we'll use this instead
914:50 - create a new component called balance
914:52 - message and it'll format up the way we
914:54 - actually show these formatted tokens and
914:57 - here we'll pass
914:59 - we'll pass it
915:01 - a couple variables we'll pass this
915:02 - component an amount we'll pass it a
915:04 - label
915:05 - we'll say the label is going to be
915:07 - your unstaked
915:11 - name
915:13 - balance
915:14 - right we're grabbing name from the token
915:16 - and we'll pass it a token image src
915:20 - which is going to be that image so we're
915:22 - going to pass it a label
915:24 - or excuse me not img it's going to be
915:26 - image we're going to pass it a label
915:29 - token image and an amount right and this
915:31 - component is just going to make us
915:33 - have this balance look a little bit
915:34 - nicer so in our our your wallet section
915:37 - i'm going to do a new file
915:40 - called balance message.tsx oops not tsx
915:46 - tsx and we can kind of rip through this
915:48 - pretty quickly so per usual we're going
915:50 - to export
915:52 - const
915:53 - balance message is gonna equal
915:56 - a function where it's gonna take those
915:58 - parameters a label
916:01 - and a mount
916:03 - and a token image
916:05 - src and this will be
916:08 - an interface of balance message props
916:11 - this will be a function of course so
916:12 - we'll do this weird
916:14 - function syntax of course we need to
916:16 - tell typescript
916:18 - what this looks like so we'll say
916:20 - interface
916:22 - balance message props
916:24 - what are those inputs
916:26 - we'll say the label
916:29 - is going to be a string
916:33 - the amount
916:35 - it's going to be a number
916:37 - and the token image src
916:40 - is going to be a string and in here
916:42 - we're going to use
916:44 - and in here we're going to once again do
916:45 - that use styles bit for materials ui
916:48 - because we want to style this up a
916:50 - little bit so we're going to import make
916:52 - styles
916:53 - from
916:54 - [Music]
916:56 - at material
916:58 - slash ui core
917:01 - we'll do a const use styles
917:04 - it's going to equal make styles
917:06 - theme which we're going to skip doing a
917:08 - theme but let's make some styles for the
917:11 - different pieces let's give it balance
917:13 - message be surrounded mainly by a
917:16 - container
917:18 - which will have a couple of styles in
917:20 - here we'll say the display
917:22 - it's going to be an inline grid the grid
917:25 - template columns
917:27 - are going to be
917:28 - auto auto auto again you can check out
917:31 - all these parameters in the
917:33 - documentation
917:34 - there's going to be a gap which will be
917:36 - theme dot spacing
917:38 - one again we're skipping theme but this
917:41 - will just be a way to add some spacing
917:43 - and then align items
917:45 - in the center we'll also give
917:48 - token image
917:50 - its own
917:51 - styling we give it a width
917:53 - of 32px
917:56 - 32 pixels and then
917:58 - the amount
918:00 - just do
918:02 - we go to font weight
918:03 - of 700. so we'll make that a a little
918:06 - thick
918:07 - so now that we have our use styles we
918:09 - have our styling here we can go into our
918:12 - export below
918:13 - we'll do const classes
918:15 - equals
918:16 - use styles
918:20 - and we're going to return we're going to
918:22 - return a div
918:23 - class name is going to be equal to that
918:26 - main container
918:27 - classes.container
918:31 - we'll do another div just for that label
918:34 - that we're looking for we'll do another
918:36 - div
918:37 - for class name
918:41 - equals
918:43 - classes dot amount
918:46 - so have that that nice font weight and
918:49 - then here we'll just have the
918:51 - amount
918:53 - and then we'll grab that image of the
918:55 - token
918:58 - class name is going to equal to
919:01 - classes dot token image
919:05 - we'll grab the source of that image is
919:07 - just going to be that token image src
919:09 - that we get passed
919:11 - and we'll give it an alt
919:13 - called token logo
919:16 - and we'll close that tab out
919:18 - great so we're going to want to do is in
919:21 - our wallet balance here it's balance
919:23 - message that we just created we'll do
919:26 - import
919:29 - balance message
919:32 - from dot
919:34 - dot com
919:37 - mints slash
919:39 - your wallet
919:42 - capital w and actually i know we're
919:43 - going to use this balance message a
919:45 - little bit later so i'm actually going
919:46 - to grab it
919:48 - and drag it into components move it into
919:50 - components and move it out of your
919:52 - wallet
919:53 - because i know that we're actually going
919:54 - to use it a little bit later so that
919:56 - means in our wallet balance
919:58 - we're just going to pull it right from
920:00 - components
920:01 - slash
920:03 - balance message
920:05 - and whoops we actually need to make this
920:07 - look like
920:08 - this
920:10 - close it out here
920:13 - remove this part
920:16 - like this boom right like that
920:20 - and now let's try out the front end okay
920:23 - we're looking a little bit nicer
920:25 - right we have a really thick number here
920:28 - explaining how much of the token we have
920:31 - we have the images popping up this looks
920:33 - starting to look great let's add this
920:36 - stake button right so that when they see
920:37 - this they can actually stake and
920:39 - interact with our contract here so to do
920:41 - this we do need to create another
920:43 - component called our stake form so in
920:46 - your wallet we're going to create a new
920:47 - file
920:48 - called stake form dot ts x and this is
920:53 - where we're going to add
920:54 - a little button
920:56 - and an amount for the users to actually
920:58 - stake on our contract so you already
920:59 - know we're going to start with export
921:01 - const
921:02 - state form
921:03 - equals
921:06 - and we're going to have
921:09 - our wallet pass
921:10 - the token just like we passed the token
921:13 - to wallet balance
921:14 - so we'll say token and we'll have this
921:16 - be stake form props
921:19 - which is an interface we're going to
921:20 - define in a second this is a function so
921:22 - we'll do this fun function
921:25 - syntax here
921:26 - and then stake form props as you know is
921:30 - just going to be a token so do inter
921:32 - export
921:34 - interface
921:35 - stake form
921:37 - [Music]
921:38 - props
921:42 - this is just going to be a token of type
921:44 - token which again
921:47 - we're going to import token
921:51 - from
921:54 - maine
921:56 - great and that is our starting point for
921:57 - this so we're going to create a stake
922:00 - form
922:01 - with a big button that says stake and
922:03 - the user can actually choose how much
922:05 - they want to stake on our smart contract
922:07 - so we're going to do some similar stuff
922:09 - as we did before we're going to grab
922:11 - some variables we're going to say the
922:13 - address is going to be that token
922:15 - address
922:16 - that we get from the pass token
922:19 - we're also going to get a name
922:20 - of the token
922:22 - from that token
922:24 - we're going to get our account
922:28 - from use ethers again
922:31 - so we can import that we'll say from or
922:33 - oops
922:34 - import
922:40 - use ethers
922:43 - from
922:46 - at use
922:48 - dap slash core we're going to want to
922:50 - grab the token balance so we'll do const
922:53 - token balance
922:54 - once again we can grab that with the use
922:57 - token balance with the token address
923:02 - and the account
923:04 - so we're going to use use token balance
923:08 - this will also grab from used app slash
923:10 - core we're going to want to format this
923:11 - token balance so we'll do const
923:14 - format it token
923:16 - balance it's going to be a number
923:19 - again this is going to be the exact same
923:21 - as we did before say token balance
923:25 - do parse float
923:27 - format units
923:30 - token balance
923:35 - 18
923:36 - or
923:37 - zero
923:38 - in format units once again we're going
923:40 - to import that import
923:44 - format units from
923:46 - at ether's project slash units
923:50 - perfect
923:51 - importing here we've gotten some some
923:53 - starter boilerplate let's just go ahead
923:55 - and grab those buttons right because
923:56 - those are really the things that we're
923:58 - going to care about here let's just
923:59 - return some stuff here so something can
924:01 - show up on our front end right so let's
924:03 - do return
924:05 - i'll start returning something here and
924:07 - whenever we return something it's all
924:08 - gonna be in one
924:10 - tag right so i'm gonna i know i'm gonna
924:12 - be doing a whole bunch of different tags
924:13 - so i'm just gonna go ahead and make an
924:15 - open and close tag here
924:17 - and this is where i'm going to put all
924:18 - my stuff now we know we're going to want
924:19 - to have a big stake button right so
924:21 - let's go ahead and just do
924:23 - let's get a let's get a button tag in
924:25 - here and of course since we're going to
924:26 - have a button
924:28 - we're going to pull this in
924:29 - from that materials eye material ui
924:32 - right so we'll do import
924:33 - button
924:35 - from
924:37 - material
924:38 - ui core just so we can get get started
924:41 - with something here and then back in our
924:42 - your wallet.tsx let's add this button in
924:45 - here inside of our tab panel
924:48 - right below our wallet balance we'll add
924:50 - this
924:51 - stake form thing we'll open and close of
924:54 - course we've got to import it
924:56 - so we'll say import
925:00 - stake form from
925:02 - dot slash
925:04 - stake form and
925:06 - we need to pass this that token object
925:09 - so back in our your wallet we're gonna
925:11 - say okay token
925:12 - equals
925:14 - supported tokens
925:16 - of that
925:17 - selected token
925:19 - index
925:22 - selected
925:24 - token
925:26 - index and let's not have this
925:29 - let's just do a little backslash here to
925:31 - close that out let's be sure to close
925:33 - this bracket here we'll give this button
925:35 - some stuff right we'll do color equals
925:38 - primary say size equals large then we'll
925:42 - give it some text called
925:44 - stake
925:46 - double exclamation point or however many
925:48 - you want to put in there and now if we
925:49 - look at the front we got this big stake
925:50 - button
925:51 - nice okay we're looking a little bit
925:53 - better currently doesn't do anything but
925:55 - we have a stake button great
925:57 - now we can start adding some
926:00 - implementation right we can have it do
926:02 - some stuff now
926:03 - when we hit this stake button what do we
926:05 - want it to do we want to do two things
926:07 - we want to approve
926:09 - whatever token that we have and then we
926:11 - want it to stake that amount we also
926:14 - need to have some type of form here we
926:16 - need to know how much we want to stake
926:17 - right so we're going to need some little
926:19 - input box that we can add a certain
926:21 - amount in well we can do that too with a
926:23 - little input box from materials ui so
926:26 - there's another package we're going to
926:27 - grab which is called input
926:29 - from materials ui core
926:32 - and then we're going to use this little
926:33 - input box before
926:34 - the button so we're gonna do input
926:37 - little slash here now if we save
926:40 - refresh the front end
926:42 - awesome now we can do some typing in
926:44 - here we can click this stake button now
926:46 - to do this though we're gonna need to
926:47 - keep track of how much amount is in here
926:50 - right we're going to need to keep track
926:51 - of how much amount's in here
926:54 - so we're going to inspect on the front
926:55 - end and we're going to go to console and
926:57 - see if we can follow along
927:00 - with how much is in here or what amount
927:02 - is in here and to do this we're going to
927:03 - make another one of those state hooks
927:06 - and we're going to track that amount in
927:07 - there
927:08 - so we're going to say const
927:10 - amount
927:12 - set amount
927:13 - for one of these stakeholders equals use
927:16 - state which is going to be a number
927:20 - or a string or an array number or string
927:26 - zero
927:27 - and we're going to import this use state
927:29 - here
927:30 - from react so we're going to do import
927:33 - import
927:35 - react
927:37 - use state
927:40 - from react
927:41 - and now we have this state hook that we
927:44 - can use to keep track of the amount
927:46 - that's going to be put in there with our
927:48 - input tag here we're going to say on
927:50 - change
927:51 - whenever this changes we're going to
927:53 - have to
927:54 - have some handle function right we're
927:56 - going to call it
927:57 - handle
927:58 - input change and this is going to handle
928:01 - the input change so we're going to
928:02 - create that function we're going to do
928:04 - const
928:05 - handle input change equals and we're
928:08 - going to use some event stuff in here
928:10 - we're going to say this is going to take
928:12 - an event
928:14 - a react
928:16 - dot change
928:18 - event
928:19 - of html input element
928:23 - this is going to be a function
928:25 - that's going to
928:27 - set amount
928:28 - it's going to say
928:30 - const
928:31 - new amount
928:33 - equals
928:34 - event.target.value
928:37 - whenever we change that value in that
928:39 - field if if it's equal to nothing
928:43 - then we're just going to say okay we're
928:45 - going to do nothing
928:46 - otherwise
928:48 - we're going to cast it as a number
928:50 - event.target.value
928:53 - we're going to cast whatever is in there
928:55 - as a number
928:57 - and then
928:59 - we're going to do set amount
929:01 - to this new amount what we could do is
929:03 - we can even do a console.log
929:06 - new amount
929:08 - and now and we can start using it right
929:10 - so if i go back here and do one two
929:12 - three right you can see it's
929:13 - console.logging every time i change
929:15 - something in here so now we have a way
929:17 - to actually get that amount with this
929:19 - input now we're going to need to weigh
929:21 - to send that amount as part of our stake
929:23 - right so we're going to first have to
929:25 - call that approve function with this
929:27 - amount and then we're going to have to
929:28 - call
929:30 - from our token farm then we're going to
929:32 - have to call the stake method so how do
929:34 - we get
929:35 - it to call this approve function here
929:38 - well to do these we're actually going to
929:39 - make some new state hooks that we're
929:42 - going to use in our staking form here
929:44 - we're going to make state hooks for
929:46 - approving and for staking and even for
929:49 - unstaking so
929:51 - back in our folder here we're going to
929:53 - create a new folder
929:55 - called hooks
929:56 - and this is where we're going to add
929:58 - some different hooks
930:00 - first hook that we're going to make is
930:01 - going to be called use
930:02 - use stake
930:04 - tokens dot type script and this is
930:07 - something that we're going to import
930:08 - into our our stake form here so we can
930:11 - actually stake some tokens and the way
930:13 - we want to do it too
930:14 - is that once we hit stake once we hit
930:17 - our stake button
930:18 - it kicks off the approve and then and
930:20 - actually right afterwards it kicks off
930:22 - ascend it kicks off a stake token we
930:24 - want to run these two
930:26 - functions sequentially and we're going
930:28 - to make this use stake token hook clever
930:30 - enough to do it in that order so let's
930:32 - do it hooks are basically just like
930:33 - components except for they're more
930:35 - functionality wise so since we know
930:38 - we're just like components we're going
930:39 - to do export const
930:41 - use stake tokens and this is going to be
930:45 - a function
930:47 - just like our other components and as
930:49 - input we're going to take a token
930:50 - address
930:51 - that's going to be a string and inside
930:53 - of this we're going to have some
930:55 - intelligent scripts to know if it's
930:58 - already been approved if it's not
930:59 - already been approved and what we need
931:00 - to do right we know we're going to need
931:02 - some approved thing and we know we're
931:04 - going to need some stake tokens thing so
931:06 - let's let's at least try to approach
931:08 - this approved thing first before we get
931:09 - too creative right how do we approve
931:11 - this transaction to get an approve we're
931:13 - going to need a couple things we're
931:14 - going to need the address
931:16 - as you guys know
931:18 - we're probably going to need the abi
931:20 - we're probably going to need
931:22 - the chain id so we know which chain it's
931:24 - on
931:24 - so let's go ahead and let's grab those
931:27 - so we'll do const chain id
931:32 - equals use ethers
931:35 - and since we're using use ethers here
931:38 - we're going to import this so we'll do
931:40 - import
931:42 - use ethers
931:44 - from at use dep
931:46 - slash core
931:49 - we're also going to want the abi of the
931:51 - token farm so we'll do const
931:54 - abi
931:55 - equals well where do we get this api
931:58 - from ha that's right we've imported it
932:01 - in our little chain info piece and
932:04 - should be right in here we could should
932:06 - be able to do
932:07 - import
932:08 - token farm
932:10 - from down to directory it'll be in
932:13 - chain info slash contracts
932:16 - slash
932:18 - tokenfarm.json and now we can say
932:21 - avi is going to be equal to this this
932:23 - token farm right because in token farm
932:26 - we have an abi key so we can just
932:28 - abstract that away and just pull out the
932:30 - api perfect we're going to need the
932:32 - token address of course we're also going
932:34 - to need our token farm address and we
932:36 - can find that the exact same way we
932:38 - found it before
932:39 - with const token farm
932:41 - address
932:43 - it's going to be equal to
932:44 - depending on if the chain id exists
932:47 - once again we're going to want to use
932:49 - that network mapping so we can even go
932:51 - back to main.tsx
932:53 - let's see how we did it here for the
932:55 - depth token address
932:57 - you can copy this as like a frame of
932:58 - reference
933:01 - we'll say if this chain id exists we'll
933:04 - pull
933:05 - right from that network mapping
933:07 - right we'll pull right from the network
933:08 - mapping so we got to import that too
933:10 - which we can grab from
933:13 - import
933:15 - network mapping
933:18 - from
933:20 - chain
933:20 - info chain info slash
933:24 - deployments
933:25 - slash
933:26 - map.json so once again we're going to
933:29 - say if that chain id exists
933:31 - in the network mapping
933:33 - we're going to use
933:35 - that string chain id
933:37 - so we'll do string
933:39 - chain id
933:43 - of
933:44 - the token farm
933:47 - at position 0 right because we obviously
933:49 - want the most recent one otherwise again
933:51 - we'll do constants dot
933:54 - address
933:55 - zero
933:57 - and since we're going to do that of
933:58 - course we're gonna have to do import
934:01 - constants
934:04 - from
934:04 - [Music]
934:06 - ethers
934:08 - and this hooks folder should be in
934:09 - source so let's just make sure that
934:11 - we have hooks in source here now we're
934:13 - going to want to interact with this
934:15 - token farm address contract right we're
934:17 - going to want to run that proof function
934:20 - first we want to create like an
934:21 - interface so we can do const
934:24 - token farm interface we'll say this
934:27 - equals new
934:29 - utils.interface with the abi
934:32 - this utils we can again grab from the
934:35 - ethers project or excuse me from uh from
934:37 - ethers so we'll do comma utils
934:41 - now we can create a token form interface
934:43 - here and now that we have interface
934:44 - we'll create a contract so we'll do
934:47 - const token farm contract
934:50 - equals new
934:52 - contract
934:54 - and this will be a combination of this
934:55 - token farm interface and the token farm
934:58 - address actually it's address first and
935:00 - contract is something we can grab from
935:03 - import
935:05 - contract from at ether's project
935:09 - slash
935:10 - contracts
935:12 - all right
935:13 - you're probably starting to follow along
935:15 - and figure out okay cool i have a token
935:16 - farm contract
935:18 - now that we have a contract we can
935:19 - actually call some functions which we
935:21 - totally can but right we need to call
935:23 - the approve first so let's get
935:26 - the token contract before we even work
935:29 - with the stake token right so to work
935:31 - with the token we're going to want to do
935:32 - the same thing so we'll do const
935:35 - erc20
935:36 - interface
935:38 - equals new utils dot interface
935:42 - interface
935:44 - and this will be from ear c20
935:47 - abi which we should probably make first
935:49 - so we'll do const erc20 avi
935:53 - equals
935:54 - we'll do it the same way we did up here
935:56 - except for instead of token farm we'll
935:58 - do something else we'll do
936:00 - look in our contracts here
936:02 - we'll do mock erc20 instead
936:05 - and then we'll just call this erc20
936:07 - or yeah we'll just call this erc20
936:10 - but we'll grab it from our mock erc20
936:13 - dot json
936:15 - so now that we have the crc20 we do
936:17 - const erc20 api equals
936:20 - erc20.avi
936:23 - and we can just pop this api
936:25 - to create our interface we'll now do
936:27 - const erc20
936:30 - contract
936:31 - equals new contract of
936:35 - the token address
936:37 - comma the erc20 interface
936:41 - boom okay
936:42 - now we have both of these contracts we
936:44 - have the erc20 contract we have the
936:46 - token farm contract now we should be
936:48 - able to go ahead and call some functions
936:50 - right now to actually send one of these
936:52 - we're going to use this thing called use
936:53 - contract function it's a hook in use dap
936:57 - that returns an object with two
936:59 - variables a state and a send this state
937:03 - bit is used to represent the status of
937:06 - the transaction and that's how we're
937:08 - actually going to automatically kick off
937:10 - the stake after we approve to send a
937:13 - transaction we have to actually have to
937:15 - we actually have to use this send
937:16 - function here
937:18 - so we're going to use this use contract
937:19 - function to get to get a state and
937:21 - ascend so that's what we're going to
937:23 - first need to do so we're going to const
937:25 - send
937:27 - and then we're going to call this
937:28 - approve erc
937:30 - 20 send
937:32 - and state because this is what it's
937:34 - returning it's returning send an estate
937:37 - i'm going to say state is going to be
937:38 - approved
937:39 - erc20 state
937:42 - equals
937:44 - use contract function
937:47 - we pass the token contract the erc20
937:50 - contract
937:52 - comma the name of the function which is
937:54 - going to be approve
937:55 - then we do a comma and then we'll do a
937:57 - little object here we'll call this
938:00 - transaction name
938:01 - and this will just be approve
938:03 - erc20
938:05 - transfer
938:08 - then of course i have to import this
938:10 - from used app this use contract function
938:15 - now oddly enough
938:16 - oops i got rid of the
938:18 - closing tag here but great so now in a
938:21 - weird way we actually have these two
938:23 - new pieces here we have this send
938:25 - function this approve vrc20 send
938:27 - and this approve erc20 state this is
938:30 - going to be
938:31 - the status of our transaction and this
938:33 - is going to be the actual function that
938:34 - we use and if we want to call this
938:36 - approve function what we can do
938:39 - is now we can return calling this proof
938:41 - function so we'll do const approve
938:45 - we'll have this be
938:47 - a function we'll say it'll take a string
938:50 - amount as an input parameter
938:52 - and we'll just have it return
938:54 - this approve erc20 send and we'll give
938:57 - it the token
938:59 - farm
939:01 - contract address
939:04 - as a first input parameter excuse me
939:06 - token farm address and we'll use this
939:08 - input amount as the second parameter and
939:11 - then we'll just have this
939:14 - this use stake tokens return this
939:17 - approve function
939:20 - and then also
939:21 - this state here so it's going to return
939:24 - approve
939:25 - and it's going to return state we could
939:26 - also just have it return this if we
939:28 - wanted
939:29 - but we're going to wrap it just all up
939:31 - in this approved thing here we also
939:33 - probably want to return this state right
939:35 - so we're going to turn this into
939:38 - hook as well
939:40 - so we're gonna do const
939:42 - state
939:44 - set state
939:47 - equals
939:48 - oops
939:51 - use state and we'll have this be the
939:54 - approved
939:55 - or the approved erc 20
939:58 - state
939:59 - as the input and of course since we're
940:01 - using use state we're going to grab this
940:03 - from react as well we also want to
940:04 - return the state so we'll return this
940:06 - approve erc20 state here so now we have
940:09 - a way
940:10 - to actually do all this
940:12 - so in our stake form
940:15 - what we're going to have
940:17 - is we're going to create const that's
940:19 - going to grab those two variables so
940:21 - we'll do const approve
940:23 - and approve erc20 state is going to be
940:26 - equal to use
940:28 - stake tokens
940:30 - with that token
940:32 - address
940:34 - pulled down from the token as the input
940:36 - parameter
940:37 - and this is our new hook so we're going
940:39 - to import
940:42 - use stake tokens
940:45 - from
940:46 - dot dot slash dot dot slash hooks now
940:49 - that we have these two functions we have
940:50 - the approve function and then we have
940:52 - the state of that function
940:54 - now we can add a handle submit
940:57 - functionality for our button here
941:00 - so now we can say okay on click
941:02 - when we click this button
941:04 - we're gonna do
941:06 - a handle
941:08 - stake
941:09 - submit
941:11 - right because this is that our big well
941:13 - it's not gonna show up now because i
941:14 - broke everything but this is our big
941:15 - button right this is our this is our
941:17 - stake button so we're going to create
941:18 - this function called handle stake submit
941:20 - let's go ahead and do const
941:23 - handle stake submit
941:24 - this will be a function
941:27 - and what it's going to do
941:28 - is we'll get this amount here so we'll
941:31 - do const
941:33 - amount
941:35 - which we're going to actually have to
941:36 - convert it from
941:38 - string to way so we'll call it amount as
941:41 - way
941:42 - we'll do equals utils.parse
941:44 - ether we'll grab parse ether
941:48 - we'll grab utils
941:50 - again from ethers
941:52 - utils from
941:53 - ethers
941:55 - and we'll do the amount dot 2 string
941:59 - so we're going to grab this amount this
942:01 - statehook amount here we'll turn it into
942:03 - a string
942:04 - and then what we can do is we can return
942:08 - this approve function
942:10 - with this amount as way
942:12 - okay oh and then we're getting a fail to
942:15 - compile so in our hooks section we're
942:17 - just gonna do an index.typescript
942:20 - and we're gonna export this use stake
942:23 - so we'll do export
942:25 - use
942:26 - stake tokens
942:28 - from dot slash use stake
942:31 - tokens
942:33 - close that
942:35 - we'll restart the server
942:37 - and then i should import this from the
942:38 - right place
942:40 - and i should import this from the right
942:41 - place as well
942:54 - and let's get rid of the brackets here
942:55 - whoops sorry
942:58 - and let's do this
943:00 - as a dot to string oops because you
943:02 - can't do a big number
943:04 - now let's save it'll recompile we'll pop
943:06 - into our front end here we'll do a
943:08 - refresh
943:10 - our stuff is up that's cool our stuff is
943:12 - getting
943:13 - logged out now if we hit stake
943:16 - we should call the approve function here
943:19 - metamask pops up we do get allow
943:21 - localhost to spend your dap this is
943:23 - amazing we're gonna reject this for now
943:25 - though because
943:26 - or don't want to bother testing it so
943:29 - amazing job getting this far we're
943:32 - hitting a button
943:33 - metamask is popping up and
943:35 - we're doing it we're actually sending a
943:37 - transaction this is incredibly exciting
943:40 - great work so far let's keep going uh
943:42 - the approve function is working
943:44 - perfectly it's working as intended or
943:46 - we're just we're kind of assuming it's
943:47 - working as intended but that's great
943:49 - this is perfect so now we've got to go
943:51 - one step further we need to have this
943:53 - call stake after it's been approved this
943:57 - is where we're going to do a little
943:58 - something called use effect we can
944:00 - import in here
944:02 - just to use effect
944:04 - comma what use effect does it allows us
944:08 - to do something if some variable has
944:10 - changed
944:11 - so the way that we're going to do that
944:13 - is we're going to say okay
944:15 - use effect
944:17 - and it takes one of these functions as
944:20 - an input and then we'll do a little
944:21 - comma here and similar to those state
944:23 - hooks we'll do an array
944:25 - of different things we want to track and
944:27 - if anything in this array changes we'll
944:29 - kick off this use effect and we'll do
944:31 - something in here
944:33 - so one of these things that we
944:34 - definitely want to
944:35 - track is this approved erc20 state
944:38 - if approved erc20 state if this
944:40 - transaction comes back successful
944:42 - then we want to do some stuff
944:44 - so we'll say we'll track this
944:46 - this state and we'll go ahead and say if
944:50 - approve erc20 state dot status
944:55 - equals
944:58 - success
945:00 - then
945:02 - we're going to go ahead and do like a
945:04 - stake function
945:06 - and to do a state function we're going
945:07 - to follow this exact same methodology
945:09 - that we did for the approve
945:12 - so first
945:14 - we're going to use this use contract
945:15 - function thing
945:17 - so we'll do const
945:19 - send is going to be
945:21 - stake
945:23 - send
945:24 - and then state
945:26 - will be
945:27 - stake state
945:30 - this is going to be equal to
945:32 - again we're going to use use contract
945:34 - function
945:35 - this is going to be on our
945:37 - token farm
945:40 - contract this is going to be our stake
945:43 - tokens
945:44 - function
945:46 - and this will be trans action name it's
945:49 - just going to be stake tokens
945:52 - and that's it
945:53 - so let's make this look a little bit
945:54 - more readable here lovely
945:57 - so we have our little used contract bit
946:00 - here and now this stake send we can just
946:02 - call this right in this approve erc20
946:05 - dot state does status we need to do
946:06 - stake send
946:08 - and if we look back in our token farm if
946:10 - we do stake
946:12 - tokens we have an amount and a token
946:14 - address so that's what we're going to
946:16 - have to put in here
946:17 - we have to put some amount
946:19 - and then token address will just be
946:21 - token address
946:23 - where do we actually get this amount
946:24 - from
946:25 - well when we originally called
946:28 - this approved function this is when we
946:30 - should actually do it and you might be
946:32 - asking hey
946:33 - how come we wrapped this approve your
946:35 - c20 into a function here but we're not
946:37 - going to do that here i'll tell you why
946:38 - in just a second so what we're going to
946:40 - have is we're going to have a state hook
946:42 - for how much we want to actually
946:44 - stake so we'll do const
946:47 - amount to stake
946:50 - and set amount to stake
946:53 - it's going to be equal to use state
946:56 - and we're going to start with zero we're
946:58 - just going to get this defaulted right
946:59 - to zero
947:01 - and what we're going to do actually
947:02 - is once we call this approve function
947:05 - the first time
947:06 - we're going to set amount to stake
947:08 - to be
947:10 - this amount and what we should do
947:12 - instead of calling this approve is we
947:14 - should call this approve
947:17 - and stake
947:19 - since it's this function that's going to
947:20 - kick off yes it's going to kick off our
947:23 - approve erc20
947:25 - but it's also going to change
947:27 - the amount that we're going to stake
947:29 - and later on
947:30 - once the transaction succeeds it will
947:33 - also then kick off our steak send
947:36 - or our staking function so we're going
947:38 - to change this to a proven stake that
947:39 - means below we have to actually return a
947:42 - proven stake and not just approve
947:44 - and for stake send the amount is going
947:47 - to be this
947:48 - amount to stake which we got from our
947:51 - original proven stake and then we just
947:53 - have to change this to approve
947:55 - and stake
947:57 - and we'll change this from improve to
947:58 - approve and stake and realistically
948:01 - that's all we really need to do here so
948:03 - if we save we go back to our front end
948:06 - let's go to one of these that i actually
948:07 - have some of i'll type in one
948:10 - for in here i'll hit the stake button
948:13 - and what should happen is approve will
948:14 - come up i'll confirm
948:17 - and once this actually confirms then
948:19 - i'll be able to another transaction
948:22 - should pop up
948:23 - telling us
948:25 - to actually stake and that's exactly
948:27 - what happens here so we've approved now
948:29 - we can stake we'll even watch metamask
948:31 - really really quick here i'm doing this
948:33 - on coven
948:35 - right i just called this state tokens
948:37 - function
948:38 - for those of you doing this on ganache
948:39 - will be a lot quicker but perfect that
948:42 - was fantastic our balance even got
948:44 - deducted by one now we have
948:47 - one
948:48 - of these tokens actually staked and this
948:50 - is fantastic however
948:52 - there's obviously a couple issues here
948:53 - right
948:54 - what was happening during that that
948:56 - whole section right there is there was
948:58 - no indication for us of what was really
949:00 - going on got no notifications we're
949:02 - totally left in the dark here
949:04 - additionally
949:06 - this page still looks disgusting so we
949:08 - want to clean this up we want to make
949:09 - this look a lot nicer so how can we
949:12 - actually do this
949:13 - so for switching between these we want
949:14 - to actually just change our use effect
949:16 - here
949:17 - so we do want to check let's approve
949:19 - erc20 state but we also want to see if
949:22 - we switch the token address
949:24 - we want to just check to see if approve
949:25 - vrc20 is done if we switch our token
949:28 - address
949:28 - and we also want to just check to see
949:31 - this if amount to stake actually changes
949:33 - so if we do amount to
949:36 - stake
949:37 - we want to check kind of during all
949:39 - these these three if any of these three
949:40 - changes we'll just do a quick check hey
949:42 - is the prove vrc20 done if yes great
949:46 - then we'll we'll stake some tokens so
949:48 - this is great but we're going to want to
949:49 - get some notifications that these
949:51 - transactions are going through these
949:53 - transactions are pending
949:55 - and these transactions finish so why do
949:57 - we actually add those pieces to this
949:59 - well used app has this thing called use
950:01 - notifications this notifications bit
950:04 - will help us actually get notified on
950:07 - whether or not our transactions are
950:08 - completing so to use these notifications
950:10 - we're going to do a couple of different
950:12 - things in here first all the way back in
950:14 - our app.tsx we're actually going to
950:16 - change our config here
950:18 - we're going to add some notifications
950:21 - in here
950:22 - to check periodically if our things are
950:25 - done
950:26 - and there's a couple of different
950:27 - parameters there's a
950:29 - x
950:30 - variation period and then we'll set it
950:33 - to be 1000 this is in milliseconds so
950:36 - we'll set it to be a thousand which is
950:37 - just one second
950:39 - and we'll do a check interval
950:42 - also of one thousand so basically we're
950:43 - saying hey every second check the
950:45 - blockchain on our transactions that we
950:47 - send please thank you and now that we
950:49 - have this notifications bit identified
950:51 - in our staking form
950:53 - we can add this bit so from used up
950:55 - decor we'll do comma use notifications
950:59 - and now we can actually start using some
951:01 - of these notifications so right here at
951:03 - the top
951:04 - we'll do const
951:07 - notifications
951:10 - equals use notifications
951:13 - we can actually start working
951:15 - with some of these notifications now
951:17 - we're going to want to see if anything
951:19 - in any of these notifications actually
951:21 - change and if these notifications change
951:23 - we're going to want to do something so
951:25 - since we're going to want to check to
951:26 - see if this if notification changes
951:29 - those who have been following along with
951:30 - what i've been explaining for use effect
951:32 - you know that means we're going to want
951:33 - to use a use effect we're going to say
951:36 - use effect
951:37 - it's going to be this function
951:39 - and if we don't have it imported let's
951:41 - go ahead and import this from react
951:43 - let's use effect
951:45 - we're going to be looking to see if
951:46 - these notifications change we're going
951:48 - to be looking to see if our transaction
951:49 - has completed so in our little watching
951:52 - array here
951:53 - we're going to say let's watch the
951:56 - notifications here let's make sure
951:59 - if any of those notifications changes if
952:01 - anything in our meta mask changes we're
952:03 - going to want to do something right so
952:06 - we're going to say
952:07 - if
952:08 - there are any notifications that are
952:10 - approved erc20 or transaction succeeded
952:14 - we want to show hey you know good job
952:16 - it's been approved
952:17 - so to do this we're going to say if
952:20 - notifications
952:21 - dot
952:23 - filter
952:24 - all right this is going to be a function
952:26 - based off the notification
952:29 - on this notification we're going to say
952:31 - notification.type
952:34 - it's going to be
952:35 - transaction dot succeeded
952:39 - succeed
952:40 - and
952:41 - that
952:42 - notification dot transaction name then
952:45 - this is why we need to give them names
952:47 - before
952:48 - in our use state
952:51 - it's going to be approve
952:53 - erc20 transfer
952:55 - dot length
952:58 - is greater than zero
953:00 - then we're going to do some stuff
953:02 - our transaction succeed
953:03 - so we're saying if
953:05 - in these notifications we're going to
953:07 - filter on a notification
953:09 - if the type is transaction succeeded and
953:12 - the name is approved erc20 transfer then
953:15 - we're going to do some stuff and for now
953:17 - we're just going to do console.log
953:20 - approved
953:21 - we can also then do the same thing for
953:23 - if
953:24 - notifications dot filter
953:26 - author on the notification
953:30 - notification dot type
953:33 - if that notification to type is going to
953:34 - be again that transaction
953:37 - succeed
953:39 - and
953:40 - notification
953:42 - dot transaction name
953:45 - equals stake
953:48 - tokens capital t
953:50 - stake tokens
953:52 - there are more than one dot length
953:55 - is greater than zero
953:57 - then
953:58 - we'll do console.log
954:01 - tokens staked
954:03 - okay so we've got some notifications put
954:05 - in
954:05 - we're gonna do a little console logging
954:07 - let's see if our use effect stuff is
954:09 - actually gonna work so let's go to our
954:11 - front end we'll do a quick refresh
954:14 - we'll go to where we have some tokens
954:15 - i'm gonna type one in here i'm gonna hit
954:17 - stake
954:19 - i'm gonna hit
954:20 - confirm and we're gonna wait a little
954:23 - bit and if this confirms correctly
954:26 - then we're gonna see a little
954:27 - console.log printout that says approved
954:29 - and we do indeed and that's perfect
954:32 - metamask pops up again for our stake
954:34 - tokens
954:35 - we hit approve there as well
954:37 - and we should see a little console.log
954:39 - out here for state token staked and we
954:41 - do perfect so now we have a way to
954:44 - actually track some of these
954:45 - notifications and track what actually
954:47 - happens on the blockchain
954:49 - console.logging stuff is great but we
954:51 - want to actually see it in our ui here
954:54 - what we're going to want to do is show a
954:56 - little waiting thing here
954:58 - while we're waiting for it to be
954:59 - approved and then she'll pop up when it
955:01 - actually does get approved we can add a
955:02 - little
955:03 - constant called is mining
955:06 - which will be based off of whether or
955:08 - not the transactions are approved so
955:10 - we'll do const
955:12 - is mining
955:14 - and this will be equal to
955:16 - the state of these transactions so this
955:18 - should actually instead be approved
955:20 - erc20 there should be approve
955:23 - and stake erc20 state now we'll say oops
955:27 - now we'll say is mining will be equal
955:30 - to approve and stake erc20 state dot
955:33 - status
955:35 - equals equals equals
955:37 - mining should probably have it look like
955:39 - this
955:40 - then back in our
955:42 - use stake instead of
955:44 - approve your c20 i'm going to change
955:46 - this to approve and stake your c20 state
955:49 - and then we're also going to return
955:51 - prove and stake erc20 stake
955:53 - let's make this make a little bit more
955:55 - sense here get that little red line to
955:57 - go away and now what we can do with this
955:59 - is mining thing is we can add this to
956:01 - our button now we have this is mining
956:03 - thing it's gonna be based off of whether
956:05 - or not approve and stake are done so we
956:08 - can scroll down to our button
956:10 - and we can add a little disabled flag so
956:12 - we'll say disabled
956:14 - equals
956:17 - it'll be equal to dependent on whether
956:18 - or not it's done we'll just add is
956:21 - mining
956:23 - and if this is true then disabled will
956:25 - be true and if this isn't mining then
956:27 - this will be false
956:28 - we can also add
956:30 - this to be kind of like a little loading
956:31 - thing so instead of just saying stake
956:33 - all the time
956:35 - we'll do a tertiary operator we'll say
956:37 - if it is mining
956:39 - then we'll do like a little loading
956:40 - thing material ui has this thing called
956:44 - circular progress that we can use it's
956:46 - like a little loading thing
956:47 - so we can do if it is mining we'll do a
956:50 - circular progress
956:52 - we'll say the size is 26 or whatever we
956:55 - want it to be
956:57 - we'll close the tag out
956:58 - and if it's not mining again we'll do
957:00 - this stake with a bunch of exclamation
957:02 - marks here so now if we save that go to
957:05 - our front end
957:06 - it looks like i need to fix something
957:08 - can't find name approve your c20 state
957:10 - that's because we changed it this is now
957:12 - a proven stake er20 state
957:15 - so let's change it to that
957:17 - now let's save go back to the front end
957:19 - and okay cool
957:20 - let's go to one of these that we have
957:22 - some stuff with we have a little dial
957:24 - we'll do one here
957:25 - we'll hit stake and if we did this right
957:28 - this should show a little loading thing
957:30 - while the transaction is going through
957:32 - so we're gonna hit approve
957:34 - and perfect we do see a little loading
957:36 - thing and it should stay like this
957:39 - until the transaction finishes
957:41 - this is a good way to indicate to the
957:42 - user that we've actually
957:44 - approved
957:46 - now i'll hit confirm for staking so we
957:49 - didn't actually see the loading thing go
957:51 - back up again so this probably means
957:53 - that we didn't actually reload this is
957:55 - mining correctly
957:57 - and the reason we don't see the little
957:58 - spinny thing is because this a proven
958:00 - stake erc20 state is really only
958:03 - tracking the approve right we have our
958:05 - cost a proven stake which does all this
958:07 - good stuff here but our staking part
958:10 - this stake state we actually never use
958:12 - right and we need to pass this back to
958:14 - our our stake form so it can actually
958:16 - know you know what's going on so what we
958:18 - can do is we can add a new state hook
958:21 - we'll do const we'll just call this one
958:23 - state
958:24 - and then we'll do set state it's going
958:26 - to be equal
958:27 - to
958:28 - use state
958:30 - and this will be that
958:32 - approve in stake ear c20 state
958:34 - we'll start it off there and this will
958:36 - represent kind of the overall state
958:38 - right for this will be the true proven
958:40 - stake ear c20 state
958:42 - what we're going to do now is we're
958:43 - going to have to track those both of
958:45 - those states we're going to track both
958:47 - the proving and the staking so we're
958:49 - going to do use effect and we're going
958:51 - to track both of those
958:53 - with our little
958:54 - our little wonderful
958:56 - use effect stuff so we're going to track
958:57 - them with by doing of course
958:59 - proven stake erc20 state and then
959:03 - stake state so if either one of these
959:05 - change now we're going to want to change
959:08 - this overall state function and that is
959:10 - going to get pushed back to our our
959:12 - stake form here so what we're going to
959:14 - say is we're going to say if proven
959:15 - stake erc20 state dot status
959:18 - equals equals equals
959:21 - success
959:24 - then
959:25 - we're going to set state to be the stake
959:28 - state
959:28 - otherwise we're going to set this
959:31 - overall state we're going to do set
959:32 - state
959:33 - to be this approve and stake bit
959:36 - or just or really just kind of approve
959:38 - here now we're going to pass this just
959:40 - kind of overall state variable here
959:43 - to our front end like this
959:45 - excuse me to our stake form and in our
959:46 - stake form we're just going to say we're
959:48 - just going to map this state variable to
959:50 - the proven stake erc20 state we'll save
959:53 - here that should work perfectly great
959:54 - now if we go back to our front end we'll
959:56 - go to die or whatever we'll do one we'll
959:58 - hit stake
960:00 - metamask will pop up we'll confirm we do
960:02 - indeed get this little loading thing
960:04 - which is perfect once it's done once
960:06 - it's approved we'll confirm again and we
960:08 - get loading again and this is perfect
960:10 - this is exactly what we want because now
960:12 - the user has a good idea ah okay i need
960:15 - to wait right the transaction is going
960:17 - through the transaction is being built
960:19 - and once it's done
960:21 - it's all set so this is fantastic we now
960:24 - have basically all the functionality for
960:25 - staking right we have a proof we have it
960:28 - doing some waiting we have it actually
960:29 - staking
960:30 - let's clean this up a little bit right
960:33 - let's make this look a little bit nicer
960:34 - so first we're gonna go to index.css
960:37 - we're gonna we're gonna add some bits in
960:38 - here for a body we're just going to do
960:40 - background
960:41 - color we're going to set this to
960:44 - set a background color
960:46 - to
960:46 - [Music]
960:48 - hsl we'll do 227 comma 61 percent
960:54 - 26 there's a whole bunch of tools the
960:56 - background color doesn't really matter
960:58 - but we'll save we'll refresh our front
961:00 - end and we'll get a nice little uh
961:02 - background color here which is cool but
961:04 - let's actually be even more creative
961:06 - than just this let's do a nice little
961:08 - linear gradient in here we'll just get
961:10 - rid of this actually we'll do background
961:12 - do lin ear
961:14 - gradient
961:17 - we'll do 135
961:20 - right here do hsl 227
961:24 - 61 percent
961:26 - comma 13 percent
961:28 - then we'll do hsl 227 61
961:32 - 26
961:34 - we'll do one more we'll do hsl again
961:37 - this will be 227
961:39 - 61
961:41 - 39
961:42 - for some colors in here semicolon there
961:45 - let's look at our front and k we're
961:47 - getting somewhere we got some cool
961:49 - double gradients going on in here we'll
961:51 - go to our main section here and we'll do
961:53 - that use styles bits again so right in
961:55 - our looks like we don't have any
961:57 - material ui in here so we'll do a little
961:58 - import
961:59 - make styles
962:01 - from
962:02 - at material
962:04 - dash ui dash core
962:08 - and right at the top
962:09 - we'll do const use styles
962:12 - equals make
962:14 - styles
962:16 - some theme which we're ignoring
962:18 - nice little function thing here let's
962:21 - then for our titles in here we'll do a
962:23 - little
962:24 - make the color be theme dot
962:27 - palette dot common dot white which again
962:30 - we're ignoring theme but if we did
962:32 - everything we would do like that we'll
962:33 - do text align
962:35 - center do some padding
962:37 - [Music]
962:38 - theme.spacing4
962:40 - and then our main of course we'll just
962:42 - add this in here const
962:44 - classes equals use
962:46 - styles
962:48 - and then we'll just put like a little
962:51 - little section in here
962:53 - do an h2
962:55 - or class name it's going to be equal
962:58 - to classes.title
963:01 - and we'll just call this dap
963:03 - token
963:05 - app
963:06 - we'll go back to the front end we got
963:07 - like a nice little deck token dap token
963:10 - app nice white right at the top that
963:12 - looks good we'll go to our your wallet
963:15 - component we'll add some styles in here
963:18 - looks like we don't have any styles in
963:19 - here so we'll do the same thing we'll
963:21 - grab
963:22 - make styles in here
963:25 - do a little const
963:26 - use styles equals make styles
963:31 - a theme that we're going to ignore
963:34 - some fun little function syntax stuff
963:36 - here
963:38 - we'll say tab content
963:41 - give this some styling we'll say all the
963:43 - tab content stuff we'll have
963:45 - display of flex
963:47 - flex direct
963:50 - sean will be
963:52 - column
963:52 - [Music]
963:54 - align items in the center
963:58 - and then we'll do a gap for this which
964:00 - will be
964:02 - theme.spacing04
964:04 - give our boxes some stuff so we'll say
964:06 - box
964:08 - we'll say
964:10 - background color is going to be white
964:14 - we'll say border
964:16 - radius it's going to be 25 px
964:20 - to give it some roundness here
964:22 - then we'll also do a header
964:25 - which we'll just do color of white
964:29 - we're going to grab tab content
964:31 - scroll down
964:33 - this is going to be inside this little
964:35 - tab panel bit here
964:37 - this div
964:38 - it's gonna have class name
964:41 - equals
964:43 - classes dot
964:45 - tab content
964:48 - oops we gotta add classes in here right
964:52 - before the return
964:53 - so do const
964:55 - classes equals that use styles
965:00 - we'll say this box
965:02 - well it's not we're not going to do the
965:04 - overarching box this could actually just
965:05 - be this if we wanted to we'll just say
965:07 - it's this first box so this will be
965:09 - class name
965:11 - equals
965:13 - classes dot box
965:16 - and then our h1 is going to be class
965:18 - name
965:19 - equals
965:20 - classes.header
965:23 - let's save it and let's take a look
965:26 - whoa
965:27 - this is already starting to look a lot
965:28 - better now as you guys can kind of see
965:31 - the functionality is really the
965:32 - important part behind the application
965:34 - and doing a lot of this use style stuff
965:37 - is what's really going to make it look a
965:38 - lot prettier right so if you're like hey
965:40 - how do i do this pretty stuff now i know
965:42 - i didn't really explain what any of this
965:43 - pretty
965:44 - prettiness was doing
965:46 - there's a ton of tutorials on doing css
965:48 - that's basically what this is that you
965:49 - guys can learn a little bit more to make
965:51 - your stuff look pretty now it looks like
965:53 - for the most part we have everything
965:55 - that we need to stay i know we have the
965:57 - spinning wheel which is great but let's
965:59 - also add a little bit of an alert at the
966:00 - bottom to say hey your transaction has
966:03 - gone through successfully
966:05 - so what we're going to do
966:06 - is we're going to pop back over to our
966:08 - stake form we're going to wrap
966:10 - our input and our button into their own
966:13 - little div here right and that is going
966:15 - to
966:16 - put a little bit of space actually
966:17 - between
966:19 - our little component here and some other
966:20 - stuff which is kind of nice
966:22 - but what we're going to do is the reason
966:24 - that we're doing this is so that we can
966:25 - add some alerts this section down here
966:27 - is where we're going to add some
966:29 - alerting
966:30 - to do that we're going to use what's
966:32 - called a snack bar
966:34 - and alerts from material ui
966:36 - you can look at both of these
966:39 - in the documentation
966:40 - provides a brief message about app
966:42 - processes and something like this like
966:45 - we're just going to say hey you did it
966:48 - transactions has come through
966:50 - so what we're going to do is we're going
966:51 - to import snack bar from material ui
966:55 - so we're going to do comma
966:57 - snack bar we're also going to import
966:59 - alerting
967:00 - like a little alert box import
967:03 - alert from
967:05 - at material
967:07 - ui lab slash alert and what this is
967:10 - going to do is it's also going to make
967:12 - these alerts basically down below our
967:15 - button and our input we're going to do a
967:17 - little
967:18 - little snack bar in here
967:20 - snack bar and we're going to say this is
967:21 - going to open when we want to show that
967:24 - the erc20 is done which we're not
967:26 - exactly sure how to do that quite yet
967:28 - we'll have it auto hide
967:30 - auto hide
967:31 - duration it's gonna be equal to
967:34 - about five seconds or five thousand
967:36 - milliseconds and then on close
967:38 - we're also going to do some stuff
967:40 - inside this little snack bar
967:42 - yes i know we haven't filled this out
967:43 - yet
967:44 - actually let's just do this for now
967:49 - having blanks for now
967:51 - inside the snack bar
967:52 - we're going to have some alerts
967:56 - where we say on close
967:58 - we're also going to do some stuff
968:00 - severity is going to be
968:03 - success
968:05 - and this alert
968:06 - is what's going to have our text in here
968:08 - so we'll say erc
968:11 - 20
968:12 - token
968:13 - transfer approved
968:15 - now approve
968:17 - the second
968:18 - transaction
968:20 - and we're going to have two of these
968:21 - little snack bars one is gonna be for
968:22 - the erc20
968:24 - and one is going to be for staking token
968:26 - so we're going to call this one
968:29 - token staked
968:31 - or excuse me tokens staked
968:34 - now we need to define when these open
968:37 - and also
968:39 - when they close and what to do when they
968:40 - close
968:42 - so
968:42 - this erc20 thing should pop up when
968:45 - erc20 has been approved so we're going
968:47 - to want to create
968:49 - some variable that's going to track
968:51 - whether or not it's actually been
968:52 - approved so we'll create another state
968:54 - hook here
968:55 - we'll do const
968:57 - show
968:58 - erc20
969:00 - approval
969:01 - success comma set show
969:04 - erc20 approval success this is going to
969:08 - be equal to
969:09 - use state and we're going to start with
969:11 - false right we don't want to show this
969:13 - thing right away
969:14 - and then we're going to want to do the
969:15 - same thing for staking tokens so we'll
969:17 - do const
969:19 - show
969:20 - stake
969:22 - token success
969:24 - and then set
969:26 - stake token
969:28 - success
969:29 - and this will be also used
969:32 - and we will start this out with false
969:34 - and what we're going to do
969:36 - is right now we're doing this
969:37 - console.login here right and this is
969:39 - cute
969:40 - but we want to actually turn this into
969:42 - changing show erc20 approval success
969:45 - right so when this actually goes through
969:48 - when notification says hey it's been
969:50 - approved we want to say okay great show
969:52 - that approval status
969:54 - so instead of doing console.log here
969:56 - we're going to say set show
969:58 - your c
969:59 - 20 approval
970:02 - success to true
970:05 - and then we're also going to set show
970:07 - stake
970:08 - token success
970:10 - tokens success
970:13 - to false
970:15 - i hopefully i'm spelling this right
970:18 - set
970:20 - show
970:22 - stake token success and let's
970:24 - make sure that's spelled right
970:26 - great
970:27 - and then we're going to do the same
970:28 - thing but the opposite for staking token
970:30 - so get rid of console.log
970:33 - we'll do set show erc 20 approval
970:36 - success to false and set show stake
970:38 - erc20 to true
970:40 - now we'll say the erc21 is going to open
970:44 - and now we can also have this
970:46 - notifications thing
970:47 - track
970:49 - these two
970:50 - if these ever change
970:52 - we'll also run through this
970:55 - so we'll grab both of these in here so
970:57 - this use effect will now track these as
970:59 - well and we'll say show erc20 approval
971:01 - status will open up
971:04 - the erc20 alert
971:06 - and then the show state token success
971:09 - will open up
971:10 - the state tokens alert and then for both
971:13 - of these we'll add a new function called
971:15 - handle close snack
971:17 - which will just close it out
971:20 - and turn those
971:21 - variables that we just made to false so
971:24 - we'll do
971:25 - const
971:27 - handle close snack
971:31 - this will be a function
971:32 - and we'll just say
971:34 - set show erc20 approval status to false
971:38 - and then set
971:39 - show stake
971:41 - token
971:42 - i'm just going to copy paste it
971:45 - this one also to false awesome now if we
971:47 - go back we refresh our front ends here
971:50 - looks like i forgot to do an on close
971:52 - ah okay yep
971:54 - we'll do handle on closed snack here
971:57 - for the alerts as well
971:59 - and there are no
972:01 - tags there there are no brackets there
972:02 - so i've got to change that
972:04 - but now if we go to our front end we'll
972:06 - do a quick refresh we see everything in
972:08 - here looking great
972:10 - let's add one in here we'll hit stake
972:12 - this will pop up we'll confirm we'll get
972:15 - the little progress bar which is exactly
972:17 - what we want and you see here now we get
972:20 - this little pop-up it says erc20 token
972:22 - transfer approved now approve the second
972:24 - transaction this should
972:26 - uh go away after a few seconds or not
972:30 - let's just approve this second one oh
972:32 - looks like it now went away so maybe it
972:34 - was a little bit longer than five
972:35 - seconds
972:36 - and now we can see the token stake
972:38 - popped up perfect
972:39 - so we have some pop-ups we have a little
972:41 - bit of ways to show the user how to do
972:43 - everything
972:44 - now you'll notice this doesn't look
972:46 - exactly like what we see in the github
972:48 - repo right and this github repo looks a
972:50 - little bit different it's got this
972:51 - little slidey bar it's got this second
972:53 - token farm contract for unstaking
972:55 - however a lot of what we're going to
972:57 - keep doing is just going to be a lot of
972:59 - more front-end stuff and at this point
973:01 - you pretty much should have everything
973:03 - that you need to build the rest of the
973:04 - contract
973:05 - so what we're going to do
973:07 - is we're going to have the rest of this
973:09 - be a challenge if you want if you would
973:11 - like to complete it you can absolutely
973:12 - add this second tokenfarb contract with
973:15 - this unstake all weth bit or unstay golf
973:18 - fau dap etc
973:20 - we're going to have two versions
973:23 - of this front end in here we're going to
973:24 - have kind of this more cleaned up
973:26 - version and then we're going to have a
973:28 - little bit more raw version this one's
973:29 - the the more raw version all the code is
973:31 - going to be there so if you want to say
973:33 - i don't really want to code and follow
973:34 - this along you can just copy paste the
973:36 - code or you can say you know what i'm
973:38 - going to do
973:39 - this unstaking part all myself and that
973:42 - will be awesome also fantastic you
973:44 - should be incredibly proud of yourself
973:46 - because at the end of the day at this
973:48 - point you have a way to stake
973:51 - tokens into a smart contract and build a
973:53 - front end which is absolutely massive
973:56 - absolutely fantastic you should be
973:58 - patting yourself in the back excellent
974:00 - job excellent job let's go ahead and
974:02 - wrap this course up welcome back friends
974:04 - how do you feel good
974:06 - smarter empowered ready to take on the
974:08 - world
974:09 - excellent well you absolutely 100 should
974:12 - be and you deserve a massive round of
974:15 - applause because you have just done
974:16 - something fantastic you have started
974:19 - your journey and equipped yourself with
974:21 - the tools to become an incredibly
974:23 - powerful intelligent smart contract
974:26 - engineer in the space now i would be
974:28 - remiss if i didn't comment on security
974:31 - and audits when it comes to doing your
974:32 - smart contracts as you know all these
974:35 - smart contracts are available on chain
974:37 - for anybody to see and anybody to work
974:39 - with this means that having a security
974:41 - mindset is incredibly incredibly
974:43 - important and i highly recommend if
974:46 - you're going to go maintenance if you're
974:47 - going to take your application onto a
974:49 - real network where it's going to be
974:50 - securing a lot of people's money and a
974:52 - lot of people's assets you absolutely
974:55 - need to get an audit there is no excuse
974:59 - for not getting an audit and having an
975:01 - application that's securing a lot of
975:02 - people's money getting an audit is
975:04 - essentially just having somebody else
975:06 - peer review your code looking for any
975:08 - vulnerabilities that could be exploited
975:10 - an audit can be the difference between
975:12 - your protocol
975:13 - skyrocketing into the future and doing
975:15 - fantastically successfully
975:17 - or dwindling getting hacked and everyone
975:20 - losing faith in your abilities audits
975:22 - are essential we've got some helpful
975:25 - links in the github repository
975:26 - associated with this course to learn
975:28 - more about audits who to get them from
975:30 - and some helpful tips on setting your
975:32 - smart contracts up to make auditors
975:34 - lives easier while we're talking about
975:36 - security it's also helpful to know some
975:38 - of the most common attacks in this space
975:40 - we've got another wonderful link in the
975:42 - github repository that will show you
975:44 - some of these attacks and how to get
975:46 - around them and what they actually look
975:47 - like two of them that are big enough
975:49 - that i think i need to mention here are
975:51 - going to be oracle attacks and
975:53 - re-entrancy attacks these are the two
975:55 - attacks that i see happen most often
975:58 - unfortunately right now in the state of
976:00 - d5 protocols get hacked for millions of
976:03 - dollars literally almost every day and
976:06 - it is a travesty to the space that this
976:08 - is happening most of the time these
976:10 - attacks are preventable so understanding
976:13 - some of these security tips doing your
976:15 - due diligence and getting an audit is
976:16 - going to make both you as a smart
976:18 - contract developer and as adapt
976:20 - developer and as a protocol better but
976:22 - also the entire space is going to be
976:24 - more safe secure and easier for
976:27 - newcomers to get into thankfully you can
976:29 - sleep a lot easier on those oracle
976:30 - manipulation attacks because you've
976:32 - learned some best practices for working
976:34 - with oracle's you've learned how to work
976:36 - with a chain-link decentralized oracle
976:38 - network to get your data and do your
976:40 - external computation using a chain-link
976:43 - decentralized oracle network or a dawn
976:45 - will solve these oracle manipulation
976:48 - attacks so that you don't have to deal
976:50 - with people manipulating a centralized
976:52 - oracle because you are going to be using
976:54 - a decentralized one reentrancy attacks
976:57 - are a little bit trickier to detect but
976:59 - whenever you call an external smart
977:01 - contract a smart contract outside your
977:02 - project you especially should think hm
977:05 - does somebody in that smart contract
977:07 - have access to changing some variables
977:09 - that i don't want them to change again
977:12 - we have some wonderful examples in that
977:13 - github repository associated with this
977:15 - course to teach you more about that
977:17 - additionally i highly recommend
977:19 - everybody check out both ethernet and
977:21 - damn vulnerable defy these are two games
977:24 - that show you some of the exploits and
977:25 - some of the low-level solidity things
977:27 - you can do that you might want to look
977:29 - out for when you're writing your smart
977:30 - contracts all right so now that we've
977:32 - got the security piece out of the way
977:33 - once again huge congratulations for
977:35 - getting this far you now have the tools
977:37 - to build a better world to build these
977:39 - smart contract applications and to
977:41 - empower yourself and your community with
977:43 - these blockchain applications now the
977:46 - first question you might be asking is
977:47 - patrick this is great but
977:49 - where do i go now what do i do i have
977:52 - all these tools i want to go use them
977:54 - absolutely my first bit of advice here
977:56 - is going to say you can always learn
977:58 - more and there's always going to be more
978:00 - places to learn and grow and even though
978:02 - this course gave you a full setup of
978:04 - everything that you're going to need to
978:06 - get going and get off the races and
978:08 - start building it's good to know where
978:09 - else you can learn more and where else
978:11 - you can grow some amazing places are
978:13 - going to be crypto zombies dapp
978:14 - university ivan on tech chain shop eat
978:17 - the blocks patrick collins my youtube
978:19 - channel austin griffith's youtube
978:21 - channel nader's youtube channel the
978:22 - ethereum.org website
978:24 - chain link blogs and really any other
978:26 - material you can get your hands on while
978:27 - you're learning you should 100 be
978:29 - growing with the community this is
978:31 - something that i've been pushing from
978:32 - the start
978:34 - blockchain and smart contract world is
978:36 - different from these corporate worlds we
978:38 - are a decentralized open source group
978:40 - open source open source ecosystem where
978:43 - we flourish if the people around us
978:46 - flourish so growing and connecting with
978:48 - the community is a absolute must and is
978:50 - eight and it's a way to really
978:51 - accelerate all the momentum that you're
978:53 - getting after taking this course twitter
978:55 - the reddit brownie discord the ethereum
978:58 - discord the chain link discord there are
978:59 - all these discords in all these
979:01 - communities that you can jump in you can
979:02 - grow ask questions chat spread ideas
979:06 - then once you're in these communities
979:07 - then you can start really coding and
979:09 - tinkering more hackathons are some of
979:12 - the best places to put your stuff to the
979:14 - test and also really learn and build and
979:16 - grow in the blockchain space there are
979:18 - hackathons happening all the time and
979:20 - these are places where you can show up
979:22 - you can learn from some of the sponsors
979:23 - you can build really cool things and you
979:25 - can win prizes as well we've seen some
979:28 - projects win a hackathon go on to raise
979:30 - millions in seed funding and become a
979:32 - billion dollar protocol some have gotten
979:34 - advisors from top investors like mark
979:36 - cuban and these products do wildly
979:38 - successful but at the same time we also
979:41 - see a huge uptick in a huge number of
979:43 - the newcomers in this space people have
979:45 - never written a smart contract never
979:47 - written any of the code come in try
979:50 - learn grow and come out an incredibly
979:51 - powerful engineer with more networking
979:54 - and with more people around them who
979:55 - they know they can lean on and talk to
979:57 - in this community so whether or not you
979:59 - want to win a hackbond doesn't really
980:01 - matter hackathons are a great place to
980:03 - sharpen your coding skills get better
980:05 - meet some people maybe win some prizes
980:07 - and a lot of these decentralized
980:08 - products do look at the hackathon
980:10 - winners looking for some talent to pick
980:12 - up for their teams a lot of the
980:13 - engineers that i work with right now i
980:15 - work with them because they got picked
980:17 - up from a hackathon so hackathons are
980:19 - great places to go eat global eath india
980:22 - eath global eth india and the chain like
980:23 - hackathon are some of the best
980:25 - hackathons in the business so be sure to
980:27 - check those out all these decentralized
980:29 - protocols have a ton of work that people
980:31 - can be doing to help grow their protocol
980:33 - in some way and they all have community
980:35 - grant projects where people can come in
980:37 - propose some grant propose something to
980:39 - the community and that person builds it
980:41 - out so if you have an idea on how to
980:43 - improve one of these decentralized
980:44 - applications you can go ahead propose
980:46 - what you want to improve and if you get
980:49 - approved you could be awarded a grant to
980:51 - work on that as well you can become a
980:52 - smart contract consultant here you can
980:54 - start offering your services to people
980:56 - who are looking for really strong
980:58 - solidity and smart contract developers
981:00 - you can start reaching out to some of
981:01 - these projects now that you have these
981:03 - skills you can start reaching out to
981:05 - other people saying hey i've got a great
981:07 - idea of something i want to build and
981:08 - i'm looking to take it to the next level
981:10 - and that's the most important piece of
981:12 - advice i have for you here
981:14 - just
981:15 - build just have a good time and build
981:18 - things that you enjoy building you'll
981:20 - learn the most the fastest by building
981:22 - tinkering and trying new things and this
981:25 - is also one of the best ways to meet
981:27 - people in the industry everybody that i
981:29 - work with in my life in this space i
981:32 - work with them because i was building
981:34 - something and we became close because we
981:36 - were working on the same things i feel
981:38 - incredibly lucky to have met and
981:39 - interact with so many fantastic people
981:41 - in this space and i hope that one day
981:43 - i'll get to meet and interact with you
981:45 - too so good luck to you all and let's
981:47 - rebuild this world let's make a world
981:49 - where there's more economic opportunity
981:51 - there's more equality and let's rebuild
981:53 - some of this institutional trust while
981:56 - having an absolute blast in this wild
981:58 - west that is cryptocurrency smart
982:00 - contracts and blockchain like i said i
982:02 - hope to meet you all one day and just do
982:04 - me a favor and make today an amazing day
982:07 - take care everybody

Cleaned transcript:

hello everybody and welcome to the free code camp blockchain and solidity beginner to expert full course python edition we're going to go through everything you need to know for developing on a blockchain using solidity and engaging in the future of finance we're going to cover topics that will teach you all the skills you need to become a smart contract expert that you can take with you no matter which blockchain you're developing on blockchain engineers are in extreme demand and they're building billion dollar applications almost every day at this point at the time of filming protocols like ave yearn.finance and synthetics have billions of dollars of locked value in them allowing people to engage in decentralized finance or defy this allows people to make censorship resistant moves and so much more some of these protocols with billions of dollars are even less than a year old so whether or not you're brand new to this space or you've been in here a while hi my name is patrick collins and i live in the smart contract world i'll be taking you through your journey to becoming a blockchain and smart contract expert a little bit of background on myself i'm an engineer and developer advocate on the chain link protocol and i also have my own blockchain infrastructure company called alphachain where i run different nodes and different infrastructure for blockchains including one of the main technologies we're going to be talking about today which is ethereum i love being a pioneer in the smart contract ecosystem and i love taking new users like yourself along to the journey with us and we are going to teach you to become a smart contract expert building blockchain and solidity applications is building a world of more trust and accountability it means building a financially free future and we get to be the ones that will go down in the history books as the pioneers of this space additionally blockchain and smart contract engineering skills are some of the most sought after in the world with an average salary of a solidity developer being between 150 and 175 000 in this video we're going to teach you how to become one of these developers and go out into the world and participate in the world of smart contracts in the world of blockchain this course is ideally for engineers who know a little bit of python programming and you can have any level of smart contract engineering whether you're a complete beginner to blockchains and you don't even know what one is or you're an advanced solidity engineer and you're looking to learn more this is the perfect place for you having a little bit of experience in other objectoriented programming language like javascript as well will be helpful here too and if you're brand new to coding in general that's all right because we're going to take you step by step through everything if you do want a little bit more indepth python coding video there is a fantastic free code camp video in the description if you do prefer javascript we will also be releasing a javascript edition of this video as well but everything that you learn here will be applicable there and if you watch both you'll learn even more you can find the entire itinerary for this entire course along with all of the code associated with everything that we do and additionally discussions and support and everything else in this smart contract kit full blockchain solidity course pi github repository it has a table of contents and then the entire itinerary of everything that we're going to go over in this course and like i said with helpful tips resources for getting support and resources for getting help now for your convenience every single piece of code that we're going to go over in this video has a github repository associated with it so be sure to grab the link in the description grab that github repository and look through all the different repos that we're going to give you if you ever get lost or need to refer to some code or want to copy paste some code all of it will be there for you it'll also be a great place to reference in the future when you're working on some project and you want to remember how to do something so be sure to start and refer back to it as you watch this video so let's talk a little bit about some best practices for watching this video this space moves really quickly so if we show you some documentation it might be a good idea for you to open that documentation up as well read through it as we do so you can stay up to speed now we've packed a ton of information in this video and studies have shown if you try to digest a massive amount of information in a short period of time your retention isn't as good so it's highly recommended that every 25 minutes to half an hour you take a five minute break and then every two hours maybe you take an additional 30 minute or an hour long break you can pause bookmark areas and come back later and learn at your own speed there are timestamps in the description that will help you come back to where you left off and you don't even have to go in order if you want to bounce around from topic to topic you're absolutely free to do so we're also going to get really technical with the fundamentals of blockchain and if you want to just jump right into solidity you can jump down the timestamps below and get right into it and if you're watching this on youtube you can adjust the speed that i talk and then i give this presentation so if i'm talking way too quickly for you you can slow it down or if i'm talking too slowly for you you can have me speed up so be sure to set me at the pace that you like best you are highly encouraged to pause come back and ask questions the blockchain in smart contract world is a very collaborative community so if you have questions some of the best places that you can go going to stack overflow and tagging your question with the specific technologies that you're working on make an issue on the github repo that we're working with go to stack exchange eth and make a question there as well jump into the discord of the technology that you're working with or even on github discussions if those are there learning to become a blockchain and solidity engineer is actually a lot more than just learning solidity becoming comfortable with all the tools in the space is going to be just as essential as becoming familiar with solidity itself and continuing the conversation on maybe twitter or reddit or any of these other channels and maybe even showing your stuff in the next ethereum or chainlink hackathon are going to be majorly beneficial to increasing your skill as an engineer now before we get actually coding a lot of people want to understand what is actually happening with all this blockchain stuff what is blockchain what is a smart contract how did this all get started and understanding these core fundamentals will actually shape the way you code and architect your smart contract applications so learning these is really really critical however if you're already familiar with blockchain and you just want to jump into the solidity feel free to grab a timestamp from the description and jump to that section now since you're here though you've probably heard of bitcoin before bitcoin was one of the first protocols to use this revolutionary technology called blockchain the bitcoin whitepaper was released by the pseudoanonymous satoshi nakamoto and it outlined how bitcoin could be used to make peertopeer transactions in a decentralized network this network is powered by cryptography and allows people to engage in censorship resistant finance in a decentralized manner due to some of the features of bitcoin a lot of people took it to be as a superior store of value over another asset like let's say gold and that's why it's commonly referred to as digital gold similar to gold there is a scarce and set amount of it on the planet and people use it to buy and sell similar to other assets you can read more about the original vision in the white paper and there's a link to it in the description now this was a fantastic breakthrough and in a little bit we're actually going to look through how blockchains can actually work and how all of this is possible but some people took this and saw this technology and thought that they could do even more a few years later a man named metallic buterin released a white paper describing a new protocol called ethereum which used this same blockchain infrastructure but with an additional feature and in 2015 they released this project called ethereum him and a number of other cofounders took this blockchain technology and applied it in ways that people can make entirely decentralized applications decentralize organizations and build smart contracts and engage in agreements without a thirdparty intermediary or centralized governing force their idea was to take the same pieces that made bitcoin great and add smart contracts to it and in fact this technically wasn't even a new idea back in 1994 a man named nick zabo proposed a technology called smart contracts a smart contract is a selfexecuting set of instructions that is executed without a third party intermediary they come to life on a blockchain and these smart contracts are really going to be the core thing that we're going to be working with and we're going to be developing smart contracts are similar to regular traditional contracts that people make between each other but instead of writing these contracts down on pen and paper or typing that on the computer it's entirely written in code the terms of the agreement are written in code and automatically executed by the decentralized blockchain network instead of being written pen and paper and executed by the two parties or three parties or however many parties involved this is one of the main differentiators between the ethereum protocol and the bitcoin protocol now technically bitcoin does also have smart contracts however they're not touring complete meaning that they don't have the full range of capabilities as a turing complete application like ethereum this is actually an intentional move by the bitcoin developers they view the bitcoin network as an asset whereas ethereum and the ethereum and developers viewed that acid as an asset and also a utility for people to build these smart contracts now these smart contracts are revolutionary technologies and we're going to talk a little bit more about what their advantage is in a little bit but they actually come with a fatal flaw with what's known as the oracle problem these blockchains are deterministic systems and we'll learn why they're deterministic very soon and this determinism means that they're a walled garden meaning that everything that happens in these smart contracts and on this blockchain happens in this little box now of course if you want these smart contracts to actually be these digital superior agreements then they need some way to interact with the real world and get real data and external outside the blockchain computation this is where oracles come into play oracles are devices that bring data into a blockchain or execute some type of external computation so great so oracles are the solution now blockchains can talk to the real world right well not quite our blockchains and smart contracts are these decentralized applications and in order for them to stay decentralized that means they would also need to get their data and external computation from a decentralized manner as well your onchain logic will be decentralized on the blockchain but you'll also need your offchain data and external computation decentralized as well combining these onchain logic settlement layers and these offchain data and external computation builds what's called hybrid smart contracts and a large majority of d5 applications in the largest applications today are these hybrid smart contracts this is where the protocol chain link comes into play chain link is a decentralized modular oracle network that allows you to bring data into your smart contracts and do external computation and it's these hybrid smart contracts that can have this onchain settlement and interact with the real world in some meaningful way chain link is an incredibly powerful oracle network because it allows us to get data get randomness do some type of upkeep or really customize our smart contracts in any way we want and elevate them to do anything that we want them to do now throughout the course when we're talking about smart contracts oftentimes we are also talking about hybrid smart contracts smart contracts is used a little bit interchangeably with hybrid smart contracts but just know that when we say hybrid smart contract we're talking specifically about smart contracts with an off chain component now throughout this video you'll hear people say smart contract you'll hear people say decentralized protocol decentralized application or dap and they kind of all are a little bit interchangeable a decentralized application is usually a combination of several smart contracts and when we start coding some solidity you'll see what a singular smart contract or singular contract looks like smart contracts are going to be what we code write and deploy for the majority of this video and learning some of these fundamental concepts will allow us to be better smart contract and better solidity developers now since its inception the ethereum protocol has given rise to many new paradigms and industries including d5 nfts dows or decentralized autonomous organizations layer twos and so much more and a couple of other protocols have taken this ethereum vision and gone in a different direction with it like polygon polka dot or avalanche if we learn the core basics of smart contract development on the ethereum platform all these skills translate to these other chains as well so don't worry about learning a specific tool or chain because most of them work together pretty seamlessly now there are a few exceptions to this rule and there are some smart contract platforms aka blockchains that don't use solidity however learning the fundamental skills here will still translate to every single other blockchain and ethereum is by far the most popular and most used smart contract blockchain or smart contract protocol you'll also hear those words used a little interchangeably as well sometimes i'll say blockchain or sometimes i'll say smart contract platform smart contract protocol and the like similarly chain link is the most popular and powerful decentralized oracle network and is going to be the one that we're going to focus on here chain link is also blockchain and smart contract platform agnostic meaning it'll work on ethereum avalanche polygon polka or really any blockchain or smart contract platform out there even in this introduction we've already learned a lot so let's do a quick summary of what we've talked about bitcoin was the first application to take the blockchain technology into the limelight and into a meaningful way bitcoin is a sort of digital gold able to make transactions between users as almost a sort of currency ethereum takes this blockchain technology one step further but you can also build smart contract or decentralized applications decentralized autonomous organizations and more because you can code with smart contracts these smart contracts can then access external data and external computation outside the blockchain using what's called oracles chain link is the most powerful decentralized oracle network and allows us to build these hybrid smart contracts which is a combination of decentralized onchain logic settlement layer and any decentralized external offchain data or computation hybrid smart contracts and smart contracts are often used interchangeably now you're probably asking yourself a lot of questions right now like what makes bitcoin so interesting what makes it like a digital gold and how are these smart contracts going to add any value to the real world and that's what we're going to go into now so before we get into the nittygritty of how these blockchains and how these smart contracts actually work from a low level let's go high level and talk about some of the features and massive advantages that blockchains and smart contracts have over our traditional environments the first feature that these have is they are decentralized and you'll hear this term used a lot because it has a massive benefit blockchains are decentralized meaning there's no centralized source that controls the blockchain the individuals that make up blockchain are known as node operators and they are the independent individuals running the software that connects the whole blockchain together it's all these different independent individuals that make the blockchain and blockchain like networks decentralized we'll dive deeper into that concept later great example of why this is so fundamentally groundbreaking is if we go back to what happened recently even with robinhood and gamestop gamestop shares were no longer allowed to be bought because a centralized entity didn't want them to be bought anymore so they flipped a switch and nobody could buy that stock anymore essentially having a single entity controlling the entire financial market the fact that a single entity has the power to make these choices for us is a travesty and blockchain is here to solve that there's a narrative here called the bankless narrative where users can actually live in a world where they don't have a bank banks while good in their own right have a history of doing some shady things they also have the power to potentially freeze your funds not letting you withdraw or move or do anything because they are a centralized entity that again can flip a switch and control how you interact with your life every day being free of these centralized entities have this much power and this much control over your life has widespread positive ramifications transparency and flexibility everything that's done on a blockchain and all the rules that are made can be seen by everyone there's no backdoor deals there's no shady happenings everything that happens on chain you can see this means that there's no special information that a few have everyone has to play by the same rules and everyone can see exactly what those rules are now additionally this doesn't mean that everything you do is tracked the blockchain is pseudoanonymous so you can create different accounts and you can interact with it in many different ways this leads me to my freedom point but i'll get there in a second speed and efficiency have you ever tried to make a withdrawal from the bank and it took three to five days all the bank is doing is adding and subtracting numbers basic first grade math so why does it take so long because blockchains are verified by a decentralized collective the settlement or withdrawal period in this case is substantially faster and depending on the blockchain that you're using it can be from 10 minutes all the way down to just a couple of seconds in the stock trading or hedge fund world it can actually take up to a week for your buy or sell of a stock to go through security and immutability blockchains are immutable which means they can't be changed and because of this it means that they can't be tampered with or corrupted in any way shape or form this allows us to have massive security on our data on our transactions and anything of the like if your computer goes down and your backup computers go down in the regular world your data is gone if all your data is on those two computers you're out of luck on a blockchain if several nodes go down it doesn't matter because as long as one node and the entire system is running the data is safe and secure there are thousands or hundreds of thousands of nodes running these blockchain softwares meaning that everything that happens happens and is immutable and won't change hacking the blockchain is nearly impossible and substantially harder than hacking a centralized entity and this is also much more secure in the asset sense as well instead of having gold in a vault or contract written on a piece of paper or on your computer you have a asset that is locked on the blockchain forever and all you need to do to access it is have a private key or mnemonic which is essentially a password so you don't have to lug your gold around or lug your contracts around with you it is always on the blockchain smart contracts in particular remove a massive conflict of interest in the traditional world when we engage with users or individuals they don't always have our best interests at heart a lot of them are usually selfmotivated in some sense and there's nothing wrong with that that's how a lot of people are however when we make an agreement with them this agreement can have a massive conflict of interest with the user who's supposed to execute that agreement let's take insurance for example if i pay an insurance provider 100 a month i'm paying them a hundred dollars and in the event that i get hit by a bus we've made an agreement or a contract that they're going to pay my medical bills or bail me out however they have this massive conflict of interest insurance companies aren't in the business of giving out money they're in the business of making money so even though they've signed this agreement when this event occurs they still don't want to pay this money out to me and if they can find a loophole in the contract they will because that is what they are motivated to do so they sign this agreement but it's not in their best interest to do so so they have this massive conflict of interest and this is native in all of the agreements that we make today they are the ones who decides whether or not they're going to execute their agreement giving execution power to the party that doesn't want to execute something has often led to frustration now the followup is you can always sue them and go through this process but now you're wasting all this time going through this long process to get something that you should have originally gotten in the first place this leads me to one of the biggest value adds to smart contracts smart contracts allow us to engage in trustless and trust minimized agreements we currently live in a world of brandbased agreements if i engage in some agreement and i don't like the service that i'm provided my alternative to this is to waltz down the street to another brand to another service who's going to make the exact same set of promises to me and then i have to trust them that they're going to execute faithfully smart contracts allow us to move from this brand based agreements to mathbased agreements these mathbased agreements we don't even have to trust that they're going to do the right thing hence the name trustless one plus one is always going to equal two in a math world whatever the code determines is the input output that's exactly what's gonna happen every single time now for me these really all add up to two major pieces freedom and trustless all these pieces allow us to live in a world that's more accountable more trusting more friendly and just better it allows us to work in an environment and a universe where things just work it allows us to do the freedom to engage with other people how we wish because there's no centralized controlling body influencing every action that we make all the rules are the same and nobody's getting special treatment this brings out this new world of economic opportunity as well and as our lives become more and more digital we're constantly being bombarded with centralized services that want us to use their interface so they can profit on how we interact and force us or push us to making the decisions that they're motivated for us to make smart contracts decentralized applications and blockchain allows us to be free of these repressors and live in an environment that's truly free and trustless so with all that high level being said let's do a quick summary of what we just learned blockchains are decentralized meaning that they are not controlled by a single centralized entity it is run by a network of independent users transparency blockchains are transparent everything that happens on a blockchain everybody else can see and everybody else can work with and see that everyone's playing by the same rules blockchains are quick and efficient especially when it comes to monetary policy settlement on blockchains are fast and easy immutability and security blockchains can't be changed or tampered with or corrupted and are incredibly incredibly secure smart contracts remove the massive conflict of interest traditional agreements have smart contracts allow us to move away from political brandbased agreements to secure mathbased agreements smart contracts allow us to engage in trustless and trust minimized agreements smart contracts are a set of instructions which when placed on a blockchain are selfexecuting pieces of code not run by any centralized intermediary in addition smart contracts are typically paired with some type of oracle to get some information about the real world when smart contracts are paired with an oracle they're called hybrid smart contracts chain link is a secure decentralized modular oracle network used to bring data into your smart contracts and also make some type of external computation i also briefly want to mention dao's or decentralized autonomous organizations you'll hear this referred to a lot as well decentralized autonomous organizations are organizations that live online and live in these smart contracts they're similar to a regular organization in the traditional world however they have people who maybe hold governance tokens to make voting decisions or they do all their governance on chain on this decentralized settlement layer giving us the freedom to engage with each other as we please so now that we've taken our first dive into blockchains and smart contracts and at least from a high level understood why they're so advantageous let's jump in let's get an ethereum wallet and let's make our first transaction on a live blockchain are you ready now let's jump into ethereum we're going to make our first interaction with the ethereum blockchain and once we do this interaction once we make this transaction then we're going to go back and look at what actually happened what were the technical implications that allowed this transaction to go through so in order for us to interact with the blockchain the first thing that we're going to need is an ethereum wallet so i'm going to go ahead and go to metamask because it's one of the most popular wallets and one of the easiest to use we're going to go ahead and download it i'm using the brave browser but it works for chrome firefox or really any other browsers and it's just going to be a little extension in the top right hand of your browser this way we can really easily see at any time what we have in our wallet this will store all of our ethereum based currencies so i'm going to go ahead and install metamask for brave add to brave add extension and now we can go ahead and get started with working with brave this is the first step you absolutely need to take when starting your journey and one of the easiest steps to take so we're going to go ahead and get started and we're going to create a brand new wallet so we're going to go ahead and hit create wallet if you already have a wallet you can actually import it via i have a seed phrase and we'll talk about the seed phrase or secret phrase in a little bit so let's go ahead and create a new wallet and sure we'll agree to help out metamask now we will create our password make sure that this is really secure for the purpose of this demo my passwords are just gonna be password but please don't have that be a password now when i'm doing my testing when i'm doing my coding i actually use a separate account from the account that i actually have real money in however if you want to use this account and actually put real ethereum and put real money into it you absolutely 100 need to back this up so we're gonna go ahead and click reveal secret words i'm showing you guys here because uh this is just a demo and i don't really care however if you show this secret phrase to anybody else they will have access to all funds so everything that we're gonna do in this tutorial we're gonna use fake money we're gonna use not real money so it doesn't matter however if you're going to actually put money in here you absolutely need to have this written down because if you lose access to this and or your private keys which we'll talk about in a little bit you will lose access to your wallet and you will lose access to all your funds so they give some tips like store this phrase and a password manager like one password write this phrase down on a piece of paper put it in a secure location memorize it whatever you want to do just make sure you have this backed up somewhere i'm just going to go ahead and hit download this for now and i'm going to save it on my computer it's not best practice to save to your computer it is much better to use a password manager or write it down on a piece of paper or something but again because we're just demoing here i'm going to show you it here and we're not going to put any real funds into this so we're going to go ahead and hit next and we're it's going to ask us to make sure we and it's going to ask us to verify that we actually have it written down and we're gonna go ahead and hit confirm and great and it gives us a couple other tips remember definitely take these tips very seriously especially if you're gonna use this for real money like i said for this demo we're just gonna use test money so it's not as big of a deal but if you put real money in you absolutely need to back up this seed phrase or secret phrase or we're going to refer to it as our mnemonic phrase awesome now we can see the user interface of this wallet and depending on your browser if you actually go ahead and look in your extensions you can pin it to your browser and you can even just click it and get the same interface here let's take some inventory of what is actually going on in here and what we actually have our mnemonic phrase that secret phrase that we got has given us access to a new account and here's the address of our account we can use a tool like etherscan to view different addresses and what's been going on with them so if we look at this address that we just created on etherscan we can see that no transactions have happened it's empty it has zero ether in it it has zero dollars worth of value in it and this address here is our unique address this address represents exclusively this single account that we just created we'll talk a little bit more about etherscan in a bit as it's a tool that we're going to use more and more now we can even click this circle here and we can even create more accounts and give it a different account name we'll call it account 2. this one has a different address so if we go ahead go back to etherscan and look this up this one has a different address here so we can have multiple addresses in here and now if i click this i have two accounts account one and account two the mnemonic that we've been given gives us access to create multiple accounts with that same mnemonic so having that mnemonic will give us access to every single account that's ever created with that mnemonic this is why securing your mnemonic is so crucial especially if you create multiple different accounts now each account has a unique identifier with them as well so so this right here is the public address when we copy this this is the public address of that account however there's also a private key to work with this account a secret key and we can go ahead and view it by clicking these three dots go to account details and export private key put our password in and confirm so this is going to be our private key so this is a single password associated with this account if you give somebody else access to this private key they will have access to my account too they won't have access to my account one because the private key of account two is only associated with account two the mnemonic however is associated with all accounts and this is why when people say store your private keys in a safe place or store your keys in a safe face they're usually referring to both your mnemonic and your private keys if you lose your private key you lose access to this account if you lose your mnemonic you lose access to all your accounts so long story short back up your mnemonic since it has access to everything and back up your private keys too but just keep in mind they only have access to the individual accounts and great those are some of the main security pieces here now what else is going on in metamask is we can see this section here that says ethereum mainnet if we click it we actually see a bunch of other networks in here so when you buy eth and when you work with eth you're working on the ethereum mainnet when you interact with smart contracts or d5 or any things that we're going to talk about later on mainnet with real value you're going to be working on the mainnet however since we're engineers oftentimes we're going to want to test our applications or do some type of integration tests or just make sure our code actually works so there's also what's called test nets these are networks that resemble ethereum and work exactly the same way as ethereum does however they're not with real money and it's just for testing your applications so we can even go to ether scan and look up brinkp ether scan we can see the rink be test on explorer we look up at our address and it's the exact same information here nothing has gone on on rink b and this is totally different so when we make a transaction these are all different networks and it says test network it's made to be made without real money later on we're actually going to show you how to work with other evm compatible chains don't worry about what evm compatible means for now but we can work with avalanche polygon and other applications through this networks interface as well so remember a testnet blockchain is a blockchain where the currency doesn't have any real value but it resembles and acts exactly like the ethereum mainnet so we can test our applications so we can test and practice our applications in fact what we're going to do right now is make our first transaction on the rink b test net and this will simulate exactly what it's like to make a transaction on the ethereum mainnet so we're going to go to this application called the rink b faucet this is where we're going to make our first transaction ring b is going to be one of two test nets that we're actually going to work with the other test net that we're going to work with is going to be coven it's important to know how to switch between test nets and evm compatible chains which is why we're going to be working with both for now we're just going to be working with rink b a faucet is a tested application that gives us free test ethereum hence why it has no value because anybody can get it for free from one of these faucets so to get tested ethereum with this application we actually have to post a tweet or a facebook post with this tweet so i'm actually going to i'm going to sign in real quick and now that i'm signed in i can post this tweet requesting faucet funds into and this is where i'm going to put my address on the rinkby ethereum test network i'm going to go ahead and tweet that out now that i have this we're gonna copy link to tweet and we're gonna place it in here and we're gonna hit give me ether and we're gonna say 18.75 ether for three days and it said funding request accepted for patrick alpha c into this and what we can do then is if we take this address again we go over to rink b ether scan we now see that the balance is 18.75 and we can even see that in our wallet on the ringbeat network we have 18.75 eth but again if we look at mainnet we have nothing there if we look at robson we have nothing there if we look at rink b we have 18.75 right so these are very different networks and we've just made our first transaction we've been given 18.75 eth and if we refresh this page we also see that this is our first transaction that was made some account sent us 18.75 ether from this account to us and we can actually even look at the details of this transaction etherscan is what's known as a block explorer block explorers are applications that allow us to see details of things that happen on a blockchain easily we can see the transaction details of this transaction here and whenever we work with smart contracts we will also see them in a transaction similar to what we're seeing right here and again we'll talk about that soon now we can see a number of information here we see a unique transaction hash this hash or this unique identifier uniquely identifies this transaction as the key of what this transaction is we see that it was a successful transaction this is the block number which we'll talk about in a little bit we see it was from this unique account which looks like they did a ton of transactions because this is the faucet account to our account that we created value was 18.75 ether and then we have these transaction fees gas price gas limit and gas used now gas refers to the fee paid to node operators for successfully including a transaction in a blockchain now exactly how this works is actually going to change pretty soon but the concept is basically anytime you want to change the state of blockchain whether this is sending some ethereum or making any type of transaction you actually have to pay a little bit of ethereum or a little bit of that native blockchain token to actually execute that transaction whenever we do something on the blockchain it costs gas and if we do something that would take a lot of energy for the blockchain to do it will cost more gas so if i send a single transaction that's going to cost 21 000 gas however if i were to do if i were to send a transaction that called the smart contract function and did a whole bunch of other stuff it would cost more gas so we see here when we got sent 18.75 eth whoever sent us that eth also paid the blockchain miners or the blockchain validators a little bit of ethereum to include our transaction now we actually get to pick how much of a fee we want to send with our transactions so let's look at another example so in our accounts in metamask let's even expand the view here we have two different accounts we have account one and account two account one has 18.75 account two has zero we can actually send money from account one to account two and again remember this is all fake money so so we're gonna go ahead and hit transfer between my accounts so we're gonna send money to account two and here's where we can see some transaction details and we see the asset that we're going to send which we only have ethereum in this wallet so we're only going to send ethereum later on we'll learn how to get different assets into this wallet we're going to choose an amount i'm just going to choose to send one and then we have these pieces here associated with the transaction fee so we have a gas price in guay and a gas limit so when we send a transaction we can choose a gas limit we can say hey if this transaction is going to spend more gas than 21 000 gas we're not going to do it we also get to set a gas price in guay but here's the quick example of guay versus ethereum one ether is this many gray and one gray is this much ether because if we just said hey could you send me .00001 that would be kind of really obnoxious so we just just say send me one way or send me one way so i know we've been throwing this gas term around for a little bit but here is it basically simplified gas is going to be the measurement of how much computation something uses the gas price is going to be how much it costs per unit of gas a gas limit is going to be the maximum amount of gas that can be used in transaction so for example if we make a transaction that uses 21 000 gas and each one gas is one way in price that means we're going to pay 21 000 way in transaction fee so back in our transaction we have we're saying the gas price is going to be one way so the transaction fee is going to be the gas that we use which will be up to this gas amount times the gas price so it'll be 21 000 way will be the transaction fee so then the question is well why would we ever bump it up why would we want to pay more gas price why do i even have the option to pay more well and this comes down to block space we'll talk about this a little bit more when we get into how the blockchain actually works but the blockchain can only process so many transactions at a time and nodes and blockchain nodes can only process so many at a time so when i make a transaction a node has to decide why they want to include my transaction into the block and if there are a ton of people looking to make these transactions then the nodes are going to be highly incentivized to pick the transactions that are going to give them a high price that are going to give them a lot of money for including that transaction so this is what's called eath gas station and it is a a gas estimator of the blockchain it currently says that if you want to get your transaction in right away it's going to cost you 31 way to do so if you want to get it in less than five minutes it's going to take you maybe about 21 gway so the gas prices of ethereum fluctuate with how much people use it and the gas prices of all these blockchains fluctuate with how much people use it so this is an important concept so typically when you're setting your gas price in a transaction you can take a looksee at you know gas station and say okay if i want mine to go in right away i'm going to do asap if i want to go in fast maybe i'll do you know this fast amount standard i'll do this standard amount but it all depends on how many people are looking to work with this blockchain at the same time and and as you can see it fluctuates pretty quickly right it just went all the way up to 46 so maybe more people are using the blockchain now this is obviously for the eth main net and on the test net there's not going to be that same competition but we can still change it anyway so if i go ahead and do 100 for the gas price and i hit next and i hit confirm if i go to activity i now have this transaction in my metamask but i can go ahead and view this on etherscan as well and we can see this is what it looks like when it's still processing this transaction and now we can see that it's passed and now if we look at the gas price we see it's a hundred gray and this is what we set it as when we were working with it before so gas prices 100 way here versus our first original transaction was just one way now if we look at our metamask we can see that the funds have indeed been subtracted from this account and they have been added to this account now there's one eighth in this account awesome and you can see the activity there's one ethan here so again the reason that these gas prices exist is because nodes can only put so many transactions into a block so they're highly incentivized to input the transactions that are going to give them a higher fee so in times when a lot of people are looking to use a blockchain prices will get very high and when very few people are using a blockchain prices will be very low this ether scan tool is incredibly incredibly powerful and we'll be using it more and more as time goes on now here's something that's incredibly exciting with just this little bit of information you now know how to interact with blockchains and interact with the ethereum protocol so if you don't want to learn how to code anything you can go and you can start interacting with ethereum and interact with protocols with just this much information however i know most of you guys are here to learn how to code so let's look under the hood of ethereum and what is actually going on with these transactions and with these gas and with these blockchains and what's really going on let's learn all the fundamentals of a blockchain now if you want to just go ahead and jump into the coding go ahead and grab a timestamp from the description however learning exactly how the blockchain works is going to make you an incredibly powerful developer so let's take a look at that first so we're going to be going through this blockchain demo on this site right here now the creator of the site has a fantastic video and a fantastic walkthrough blockchain 101 it is right on their site so if you're looking for another explanation definitely check out his video it is absolutely fantastic but the first thing that we really need to do in order to understand blockchain in order to find really anything and everything that's going on here we first really need to understand this shot 256 hash or hashing just kind of in general let's first understand what a hash is a hash is a unique fixed length string meant to identify any piece of data they are created by putting some piece of data into a hash function in this example the hashing algorithm used is sha256 now ethereum actually uses this this right here for its hashing algorithm which isn't quite um sha256 but is in kind of this shaw family but it's it's really just another way to hash things and uh the specific hash algorithm doesn't matter uh so much so uh this example uses sha256 but you can imagine it's the same as the ethereum hash they're just gonna you know result in a different hash so what's going to happen in this application here is whatever data or whatever information we put into this data section here as you can see below this hash changes so what's happening is this data is running through the sha 256 hash algorithm and it's outputting this unique hash so this hash is a unique fixed length string that's going to identify like a blank data piece here right so if i put in you know my name like you know patrick collins this is the hash that's going to represent patrick collins right and you can see even when i put you know tons and tons of data in here the length of the string doesn't change right so it's always going to be the same amount we can put almost any amount of data in here there is an upper limit on the max size of the data but for all intents and purposes we can pretty much put any length in here and you'll see too that you know every time i type in patrick collins this hash is always going to be this 7e5b right i'm going to delete i'm going to do patrick collins again you know seven e5b it's always this this unique hash is always going to be unique right it's always gonna be this fixed length string here so now we can take this idea right of putting this data in here and we can move on to uh this concept of a block so with this block concept we're going to take the exact same thing with this hash this this data section right but instead of having everything just being this this singular data area right here we're going to split this data up into block nuns and data so all so what we're going to do is we're actually going to hash all three of these to get to get this hash right we're going to put all three of these we're going to say all three of these are combined uh together we're going to put every all three of them into this hashing algorithm uh to figure it out so if i type a bunch of stuff here we can see that block one with nuns you know this nonce and this data we're gonna get this hash and as you can see actually the screen turns red this block turned red now what happens when i hit this mine button when i hit this mine button it's actually going to take some time it's going to think for a little bit and we can see that the nuns here actually changed right the nuns is different from what it was before and this hash now starts with four zeros okay and then it the the back turned green when we're talking about mining we're talking about miners solving some type of very difficult problem that takes a lot of time to do now in this example here the problem that the miners had to solve was they had to find a nuns or or a value in this nun section that when hashed with at block number one with this data it would start with four zeros so the problem here the miners had to solve was to start with four zeros and the only way for them to really do that is kind of this brute force you know trying stuff so they tried one okay one didn't work okay two nope two didn't work three no four or five six okay five well that started with one zero but it's not four and they have to keep trying all these numbers until they uh get to this one where you know let's hit mine again where it has four zeros at the top at the start now this specific problem changes blockchain to blockchain right ethereum has a different problem for miners to solve um bitcoin has different problems for minor itself but this concept is going to be the same so they have to take one block is going to be this uh this concept is going to be all this data it's going to be the block number and it's going to be this nunce right and so this nunce is the solution um is is going to be the the number that they use to get like the solution to the problem right so if i go to one here you know when i do this again i'm gonna hit mine and the nuns has changed right it went from one to thirty three thousand one hundred and twenty eight because this is the nuns that allowed this hash to start with four zeros and so that's what's happening when uh blockchain miners are mining they're going through this process this very computationally intensive process of trying to find a nuns that fulfills whatever the problem is so that's really it actually so that's a block and that's really what's happening when miners are mining they're just looking there's trial and error brute force trying to find this nut so so now that we know what a block is let's go to the next step and figure out okay well what's a block chain so here we have an example of what a block chain is going to look like right we have a combination you know we have back here in the block section we have one what one block looks like now here we have multiple different blocks right each one of these represents a different block but we have an additional column here or we have additional uh variable here so like before you know we have block nuns and data right we have block nun's data but we also have this thing called previous right and so this is actually pointing to the previous hash of the last block so for example if we go to the the last block in this blockchain it says previous is 008 and if we look at the hash of block number four it's zero zero zero zero eight e eight and then we look at its previous it's uh four zeros b9 we have four zeros b9 and so on all the way back to our first block which has previous of just all zeros right and so the block with the previous of all zeros is going to be known as the genesis block so you've probably heard that before the genesis block it's the first block in the blockchain where the previous hash points to a hash that doesn't actually exist now as you can imagine kind of the same as how this block worked how the block nuns and data all go through the hashing algorithm in the blockchain the block nuns data and previous hash all go through this hashing algorithm to figure out you know what the hash is okay so if we go to over here you know for example if i type in you know patrick obviously this is now no longer valid right because this nuns uh combined with the block the data and the previous hash aren't gonna solve you know our problem of having four zeros at the start right so i'm going to go and fix that and and that's that's kind of an easy way to see it being broken but but let's take a look if i break this block right here what happens if i if i break the data in here if i do like trick in here you can see that both of these are now red both of these are now invalid right because the block hashed with the nuns hash with the new data which is my name patrick has worked hashed with the previous block is now a brand new hash right and this block is still pointing to this previous hash right here right it's pointing to this previous block and now it is wrong and it is messed up and now um and now it's nuns with this previous hash is also wrong right and this is where when we talk about uh blockchains being immutable this is exactly how it's immutable right because if i go back and i change anything you know if i've just typed a right here the entire blockchain is now invalidated because none of these are going to have nunses that solve this equation anymore so this is why blockchains are immutable is because anytime you change one thing you ruin the rest of the blockchain okay so however though you know if if an a was here originally we can go ahead and mine these we can mine all these but as you can see you know this is going to start getting very computationally expensive because i have to go redo basically the entire blockchain and the farther and farther down the line you get the harder and harder it becomes to you know rehash and redo all these different blockchains here now this makes a lot of sense right so we have this blockchain it's really hard to change something in the past but if we do we can just go ahead and remind it now if i'm the one who controls the blockchain right if i'm the one who controls this you know and i want to change something in the past well okay great all i got to do is change this data here and then you know mine each one of these and you know obviously it's going to be very computationally expensive but it's something that i can do right if i'm the one who owns the blockchain now here's where the decentralized nature or the distributed nature really uh makes it incredibly powerful so we're gonna go to the distributed tab here which i also refer to as the decentralized tab here it's going to show us what a blockchain looks like in a decentralized manner so we have this exact same initial setup here we have distributed blockchain we have you know our first block chain which is kind of exactly as the one from here but we also have more than one so we have peer a peer b and peer c and when people are talking about peer to peer appear to be your transactions they're really talking uh this is kind of that concept that they're talking about right so we have a number of different peers who are running this blockchain technology they're all weighted equally right each one of these peers or each one of these nodes each one of these entities running a blockchain has the exact same power as anybody else right so the way that we can tell very easily which blockchain is correct or which ones are correct are by looking at this end hash here right or by looking at where we are in the blockchain because again remember because again remember this this hash that this this in this last block here is going to encompass all of the blocks from before right because this last hash is going to have the previous hash here which includes the previous hash here which this hash includes the previous hash here in which so this last hash is encompasses everything in here right and we can look we can look at the hash of pure c which is four zeros and then e4b we can look at the latest hash of peer b which is four zeros e4b and then pure a which is for zeros e4b so all of these peers all of these nodes all of these decentralized you know these independent all these independent users running this blockchain software they're all matched up it's very easy for their nodes to look at each other and say hey great we are all matched up now what let's say that a decides that you know something happened on the blockchain that they didn't like and they wanted to go back and change something right so let's say they change here you know obviously the rest of their blockchain is invalidated and they have to spend a lot of computational power to catch up to speed so let's go ahead and humor it let's say that they they did they ended up catching up uh they ended up catching up you know they ended up mining everything and now they have a valid blockchain right it solves the equation awesome however in block number three there's something new right this is here and it shouldn't have been here this is something that pier a put in by themselves all that happens now is we look at all the blockchains that are running the software and we're looking at all the hashes at hash at block number five so pier a has this new hash now 009 bc but peer b has a different hash 0 e4b right so who's right is it is it pier a with their new stuff or is it peer b well that's where the decentralizator comes in because then we can look at pier c and pierce c also has e4b so pure b and pure c both say hey pure a you're wrong get out right and peer a will stop being able to participate in the mining rewards because they have essentially forked uh the blockchain and started their own little blockchain right with their own history because they're the only ones with this this piece of data in block three whereas peer b and peer c have nothing in there so that really shows why uh in these blockchain worlds in this decentralized world there really is no central identity you know pier a you know might have been maliciously motivated to change you know this block number three however democracy rules right the majority rules in the blockchain peer b and pc both say hey you know that's cute and all pure a but you're wrong right that that's not right now it might be a little abstract that you just look at data and you know us typing kind of random stuff in here and think okay yeah that's that's data right that makes sense you know just kind of random strings in here doesn't really do anything for us so if we actually go over to the token section here this is where everything really starts to make a lot of sense so we have the exact same setup here with peer a peer b peer c except the difference is instead of having kind of this this data section we have this tx this transaction section right and this represents all the transactions that are happening in this block right so we're we're sending 25 dollars from darcy to bingle or to bingley uh force uh four dollars and 27 cents here uh 1922 right and it's the exact same thing so this all these transactions are going to get hashed in the exact same way uh that the data is going to get hashed and and this is why it's so powerful because again you know if i want to be malicious right if uh if i want to say hey i really wanted to give jane a lot more money from elizabeth so i'm pure a and i go back and i change it to 100 well now you know not only do i does my whole blockchain get invalidated because that was so far so long ago but i'm not going to match any of these other chains right and so my blockchain is going to be excluded from the overall blockchain so and let's let's go ahead and fix this and it's the same thing if down here if i become malicious and i want to send you know i want uh miss audrey to have less money maybe i want to send a dollar and i go ahead and mind it the same thing here this hash now this 2a1 is not going to match peer b's preb's hash of bba and it's not going to match pc's hash of bba as well so the two of them are going to say hey this your blockchain isn't valid it's not matching the majority you know you're out right so that's really how these blockchains work at a low level and it all goes back to this this understanding this hash idea and using it in this very sophisticated manner uh to kind of cryptographically prove um you know where where stuff lies now the way the blockchain works is that instead of random stuff put in this data section it's actually going to be solidity code in here to finding ways to interact with different blocks and different protocols that are on chain or as we've said before different smart contracts now the next question that you might be asking is okay well how do i know how can i be sure that i'm the one uh you know let's say this is let's say i'm darcy right how can i be sure that i was that darcy was the one to actually send this money here how do we know that darcy sent 25 to bingley well this is where we get into uh private keys and public keys and that's what we're going to go into now let's just do a quick recap of what we've learned in this section so far right we've learned that ethereum actually runs on this ketchup 256 but you know we used shot to v6 for this demo it doesn't really matter we're just talking about hashing algorithms so again a hash is a unique fixed length string meant to identify any piece of datum a hash algorithm or a hash function is a function or algorithm that computes any type of data into a unique hash mining is the process of finding the solution to the blockchain problem in our example the problem was to find a hash that starts with four zeros whenever a node mines a block they get paid a little bit of that gas we were talking about earlier for doing something a block in a blockchain is basically a combination of a block nonce transaction and previous hash to create this unique hash for this block and again depending on the blockchain implementation this might have a couple other fields or might have different fields but this is essentially what's going on blockchains are decentralized and distributed because many independent users are going to run this blockchain software and they will check and they will compare against each other to see which blockchains are acting honestly and which ones are acting maliciously in the blockchain world majority rules the nuns here is the answer used or the number used to get this hash now nuns is kind of an overloaded term it's actually used for a number of different reasons in this case we're using it to solve this problem of getting you know four or five zeroes at the stop of the hash however in ethereum it'll also be often used as the number of transactions from a given address so now we're going to talk a little bit about signing these transactions and private keys and some other cryptography pieces right because in this blockchain demo here we can see we hover these these fantastic transactions right all these things went through but how do we know that it was darcy who was the one to send 25 to bingley right how do we know that actually happened and this is where all those pieces that we just learned about uh in our our test net in our metamask account are really going to start to to come to life here a little bit here so here we have an example of public and private keys okay at the top we have this private key right that was that was randomly generated a private key is is you know as it kind of states is a key that you really want to keep secret because you're going to be using this as kind of your secret password for all your transactions right i can really pick you know any any any private key anything that i want and with it uh this algorithm they're going to use an algorithm you know for ethereum in bitcoin they both use this elliptic curve digital signature algorithm it's a variant of just a digital signature algorithm and it's going to create this this public key right i'm really not going to go at all into kind of this digital signature algorithm but just know it does use some of these some of the hash knowledge that we just learned combined with some other pieces to kind of get this this public here so i'm not going to go too deep into it but we have this private key that we create and we get this public key now this public key we want everybody to have access to right this is yeah whole world can see this this private key we really want it to be uh private we don't want people to see this we're going to use this private key as like a password to quote unquote digitally signed transactions and then people can verify them with this public key so let's let's see what this actually looks like let's pick a random key a more secure key right because the longer it is the more secure it's going to be and if we go to signatures now right let's say we have this this message that we want right we'll say hi world right we want this to be the message what's going to happen is this private key that we've created we can use to sign this data right remember how in the blockchain demo you know we were kind of we were hashing stuff right we were we're using this uh shay256 hash to to get this hash well we're doing something similar but instead of hashing we're we're using this digital signature algorithm to create this message signature now what's really powerful about how this uh this algorithm works is that you can create this message signature with your private key but somebody else can't derive your private key from the message signature and that's what makes this really really powerful however if we go to verify using this public key right and so this is the this is that o four zero three this is that same public key using this using this public key anybody can verify let's go ahead and sign again anybody can verify that the signature is yours right so you have a public a private key just for you so you can sign things and a public key that anybody can verify something right so anybody can verify this and let's say somebody tries to fake a transaction from you they say hey you know this is this is this is their transaction all they have to do is verify that this signature against your public key and very easily this whole thing turns red because it isn't verified right the the algorithm says hey that's wrong so we can go ahead and take that into transactions in this exact same way so if i want to send money you know if i want to send 400 from you know my address to another address using my private key i can sign that transaction and anybody else in the world can then verify this transaction right and this is why when people say hide your keys you know protect your keys this is what we're talking about in our accounts here right if we go to uh settings and again the only reason that i'm showing you guys my mnemonic in my private key is because this is a uh this is a dumpster account i'm gonna throw this away at the end of this video or i'm just not gonna put any real money in it um but when we look at our our metamask here we have this mnemonic phrase which allows us to easily get these different private keys right so demonic phrase combined uh with you know whatever account number will get us a private key so demonic phrase combined with one we're going to get this private key and this is when we look at account details export private key password confirm this is going to be the private key that we're going to use to sign our transactions right this if anybody else gets access to this private key they then can sign transactions for us and they can send transactions for us and that's why we want to keep these private so it works the exact same way right so this is why it's so important to hide your private keys and hide your mnemonics now your ethereum address is actually a piece is actually a piece of your public key now to get our address in ethereum all we have to do is take this public key that we've created with our private key hash it using that same ethereum hashing algorithm and then take the last 20 bytes and that's how we'll actually derive to our um to our address here now knowing the exact methodology of how to get the address doesn't really matter because it could change blockchain to blockchain and could even change an too but just know that that is essentially how kind of these addresses are derived right there's some derivative of the public key right because the public key is public and you know using the public key in kind of any public way is is totally fine but not the private key so that is how we sign our transactions note though this isn't how we send the transaction so so this is just going to sign it create a transaction for us to send we'll learn later on how to send these transactions so that was a lot of information there too let's do a quick recap your public key is derived by using a digital signature algorithm on your private key right and you want to keep your private key private at all times because you're going to use your private key to sign transactions signing transactions with your private key you are the only one who can actually do this because you can't get the private key from a message signature however using your public key you can anybody can very easily verify that a signature that's signed by you is in fact signed by you in our metamask our private keys are located in this account details section you just hit show private keys and type in your password and you'll get your private key here a quick note here is often times when using your private key somewhere they want it in hexadecimal form so if we're going to use our private key for something like brownie which we'll go into later we need to actually append in a 0x to the front but we'll get into that later and the address of your account is derived from this so if you think about it your private key creates your public key which then can create your address and there's a little barrier or a big barrier here because your private key you want to keep private and your public key and your address can all be public information awesome so now that we know all the cryptography pieces and all the little nitty gritties of how the blockchain actually works and how our signatures work and how everything sticks together let's talk a little bit about how this works in actuality and what's really going on now for a lot of this each different blockchain has slightly different algorithms and slightly different metrics and criteria for doing a lot of the stuff so when we're talking about these specific implementations keep in mind the exact algorithm might be a little bit different but the concepts are all still going to be exactly the same hashing and hash function is going to be the same no matter where you look a decentralized blockchain is going to be the same no matter where you look how it's actually implemented is going to be a little bit different now traditionally when you run an application you know be it a website or something that connects to some server you are interacting with a centralized entity and unlike how we saw with the blockchain with multiple different peers it's going to be run by a single centralized group now it still could be run on many different servers but all those servers are still going to be controlled by the same centralized group blockchains as we saw run on a network of different independent nodes when we saw peer a peer b peer c those were different examples of different independent users running the blockchain technology on their own node now when i use the term node i'm usually referring to a single instance of a decentralized system so when i say a single node when i'm talking about a blockchain i'm talking about one of those peer a's peer b's pcs running that blockchain software i'm talking about one server running this technology and again it's this network it's this combination of these nodes interacting with each other that creates this entire blockchain what makes this so potent too is that anybody can join the network and that's why there's decentralized the barrier to entry is a little bit of hardware requirements you're getting the correct materials to run the software and then you running the software anybody can join these networks and participate and that's what makes it truly decentralized in fact you can go to github right now and run your own ethereum node in a few seconds now in the traditional world applications are run by centralized entities and if that entity goes down or is maliciously bribed or decides that they want to shut off they just can't because they're the ones that control everything blockchains by contrast don't have this problem if one node or one entity that runs several nodes goes down since there are so many other independent nodes running that it doesn't matter the blockchain and the system will persist so long as there is at least one node always running and luckily for us most of the most popular chains like bitcoin and ethereum have thousands and thousands of nodes and as we showed in our demo if one node acts maliciously all the other nodes will ignore that node and kick that out or even punish it in some systems because they can easily check everybody else's node and see okay this one is out of sync with the majority and yes majority rules when it comes to the blockchain each blockchain keeps a full list of every transaction and interaction that's happened on that blockchain and we saw if a node tries to act maliciously then all their hashes are going to be way out of whack and they're not going to match everybody else this gives blockchains this incredibly potent immutability trait where nothing can be changed or corrupted so in essence we can think of a blockchain as a decentralized database and with ethereum it has an extra additional feature where it also can do computation in a decentralized manner now let's talk consensus proof of work and proof of stake because you've probably heard these before and they're really important to how these blockchains actually work we went through that blockchain example and we did that mining feature this is what's known as proof of work proof of work and proof of stake fall under this umbrella of consensus and consensus is a really important topic when it comes to blockchains consensus is defined as the mechanism used to reach an agreement on the state or a single value on the blockchain especially in a decentralized system i briefly alluded to this consensus mechanism in our blockchain example when i said if one changes something and the other two don't then majority will rule and kick that one out this is part of that consensus mechanism now very roughly a consensus protocol in a blockchain or decentralized system can be broken down into two pieces a chain selection algorithm and a civil resistance mechanism that mining piece that we were doing or or the proof of work algorithm is what's known as a civil resistance mechanism and this is what ethereum and bitcoin currently use please note that depending on when you're watching this if eth2 is out then it's no longer proof of work now proof of work is known as a civil resistance mechanism because it defines a way to figure out who is the block author which node is going to be the node who did the work to find that mine and be the author of that block so all the other nodes can verify that it's accurate civil resistance is a blockchain's ability to defend against users creating a large number of pseudoanonymous identities to gain a disproportionately advantageous influence over said system and in layman's terms it's basically a way for a blockchain to defend against somebody making a bunch of fake blockchains so that they can get more and more rewards now there are two types of the civil resistance mechanisms that we're going to talk about here namely proof of work and proof of stake let's talk about proof of work a little bit more in depth first in proof of work this is silver resistant because a single node has to go through a very computationally expensive process called mining which we demonstrated earlier to figure out the answer to the blockchain's riddle of finding that correct nonsore or whatever the blockchain system has in place in proof of work this works because no matter how many pseudoanonymous accounts you make each one still has to undergo this very computationally expensive activity of finding the answer to the proofofwork problem or the proofofwork riddle which again in our demonstration it was finding a nunce with that first four zeros but again each blockchain might change the riddle work or change the problem to be a little bit different in fact some of these blockchains make this riddle intentionally hard or intentionally easy to change what's called the block time the block time is how long it takes between blocks being published and it's proportional to how hard these algorithms are so these problems actually can change depending on how long they want the block tone to be if the system wants the block time to be very very long they just make the problem very very hard if they want to be very short to make the problem a lot easier we'll talk about civil attacks in a little bit and how they can affect the system but with proof of work it's a verifiable way to figure out who the block author is and be civil resistant now you need to combine this with a chain selection rule create this consensus now there are some consensus protocols that have more features but very very roughly these are the two pieces that we're going to look at the second piece is going to be a chain selection rule how do we know which blockchain is actually the real blockchain and the true blockchain now on bitcoin and ethereum they both use a form of consensus called nakamoto consensus and this is a combination of proof of work and longest chain rule the decentralized network decides that whichever blockchain has the longest chain or the most number of blocks on it is going to be the chain that they use this makes a lot of sense because every additional block that a chain is behind it's going to take more and more computation for it to come up that's why when we saw in our transaction we actually saw confirmations the number of confirmations is the number of additional blocks added on after our transaction went through in a block so if we see confirmations is two it means that the block that our transaction was in has two blocks ahead of it in the longest chain now i do want to point out that a lot of people use proof of work as a consensus protocol and i do want to say that this is a little bit inaccurate but sometimes people use it interchangeably proof of work is a piece of the overall consensus protocol which in bitcoin and ethereum one's current case is nakamoto consensus nakamoto consensus is a combination of proof of work and its longest chain rule both equally and very very important now proof of work also tells us where these transaction fees and these block rewards go to remember how when we made this transaction we had to talk about gas and a transaction fee so who's getting paid who is getting this transaction and this transaction fee is going to the miners or the validators in a proof of work network they're called miners and in the proof of stake network they're called validators there are a little bit different and we'll get into that when we talk about proof of stake in this proof of work system all these nodes are competing against each other to find the answer to the blockchain riddle remember in our example it was to find a hash that has four zeros at the start and again depending on the blockchain implementation that riddle is going to be a little bit different but all the nodes are trying as many as possible to try to get this answer first why because the first node to figure out the answer to the blockchain rule is going to get that transaction fee they're going to get paid from that now when a node gets paid they actually get paid in two different ways one is going to be with a transaction fee and another piece is going to be the block reward remember how we talked about alternating the gas price or the way on our transaction well that's the transaction fee that we're going to pay to these blockchain nodes for including our transaction the block reward is given to these nodes from the protocol from the blockchain itself you've probably heard of the bitcoin having before the having is referring to this block reward getting cut in half and it's supposed to be cut in half roughly every four years this block reward increases the circulating amount of whatever cryptocurrency that is being rewarded for example on ethereum the block reward is giving out ethereum and on bitcoin the block reward is giving out bitcoin so these nodes are competing against each other to be the first one to find this transaction to be the first one to find the answer to this problem so that they can be the ones to win both this block reward and your transaction fee some blockchains like bitcoin for example have a set time when they are no longer going to give out block rewards and the miners or the nodes are only going to get paid from transaction fees now this gas fee again is paid by whoever initialized the transaction when we got our funds from the faucet there was some server and somebody else was paying the transaction fee for us however when we sent ether from one account to another our first account actually paid some transaction fee to send that ether in proof of stake there's also a gas fee but it's paid out to validators instead of miners and we'll talk about that in a little bit now let's talk about two types of attacks that can happen in these blockchain worlds let's talk about the first one being the sybil attack the simple attack is when a user creates a whole bunch of pseudoanonymous accounts to try to influence a network now obviously on bitcoin and ethereum this is really really difficult because the user needs to do all this work in proof of work or have a ton of collateral in proof of stake which again we'll talk about in a bit the other more prevalent attack is what's known as a 51 percent attack now as we saw as part of our consensus protocol these blockchains are going to agree that the longest chain is the one that they're going to go with so long as it matches up with 51 percent of the rest of the network this means that if you have the longest chain and you have more than 51 percent of the rest of the network you can do what's called a fork in the network and bring the network onto your now longest chain now sybil attacks obviously are when a single node or a single entity tries to affect the decentrality of the network by pretending to be multiple different people although they're just the same person or entity and like i said it's really difficult to do in proof of work and proof of stake so you can see now that blockchains are very democratic whichever blockchain has the most buyin and is the longest is the blockchain that the whole system is going to corroborate when nodes produce a new block and add to the longest chain the other nodes will follow this longest chain that the rest of the network is agreeing with add those blocks to their chain and follow up so very small reorganizations are actually pretty common when a blockchain picks a block from a different longest chain puts it on and then has to swap it out for another block and continue with a different blockchain however if a group of nodes had enough nodes or enough power they could essentially be 51 of the network and influence the network in whatever direction that they wanted this is what's known as a 51 attack and it's happened on blockchains like ethereum classic which is not ethereum this is why the bigger a blockchain is the more decentralized and the more secure it becomes so after you watch this video and you become a blockchain engineering expert i definitely recommend you run a note as well because you are going to increase the security of the network as a whole by running a node so proof of work is fantastic because it allows us to very easily protect against these civil attacks and keep our blockchains decentralized and secure however it has some drawbacks as well proof of work costs a lot of electricity because every single node is running as fast as they can to win this race to get the rewards this leads to obviously an environmental impact now since proof of work and nakamoto consensus a lot of other protocols have taken this idea and gone in a different direction with a different civil resistance protocol a lot of them with the intention to be a lot more environmentally friendly and the most popular one right now is proof of stake there are some chains that are already using this proofofstake protocol and that are live and thriving some of them are like avalanche solana polygon polkadot and terra and additionally ethereum has decided to upgrade to eth2 which will have this of stake algorithm as well it'll also have some other features which we'll talk about in a bit now as a quick aside all the tools that we're going to learn here are still going to work in eth2 so depending on when you watch this everything here is still valid so let's talk about proof of stake now again this is a different civil resistance mechanism instead of solving this difficult problem proof of stake nodes put up some collateral that they're going to behave honestly aka they stake in the example of ethereum 2 nodes put up some ethereum as a stake that they're going to behave honestly in the network if they misbehave to the network they are going to be slashed or removed some of their stake obviously this is a very good civil resistance mechanism because if you try to create a whole bunch of anonymous accounts then each one of those accounts you have to put up some stake and if you misbehave you're going to run the risk of losing all the money that you put up as collateral in this system miners are actually called validators because they're no longer binding anything they're actually just validating other nodes now unlike proof of work which every node is racing to be the first one to find the block in proof of stake nodes are actually randomly chosen to propose the new block and then the rest of the validators will validate if that node has proposed the block honestly as we saw with our cryptography lesson it's usually very easy for other nodes to verify if a proposal or a transaction is honest now randomness is a really important topic when we're talking about blockchains because keep in mind these blockchains are deterministic systems they're walled gardens from the rest of the world and as you know a determinic system by definition can't have random numbers so how do we choose the random validators in the system well it changes from blockchain to blockchain and actually choosing the node will change blocks you to blockchain but in eth2 they're using what's called randow at least for the original implementation this is a decentralized autonomous organization that collectively chooses the random number and collectively chooses which node is going to run next we aren't going to dive too deep into this because there's a good chance that this might change in the future but we will go into randomness solutions in blockchain later on in this course now proof of stake obviously has some pros and cons as well pros are that again it is a great civil resistance mechanism and a great way to figure out who the author of a block should be the other pros are that it's way less computationally expensive to figure out the new block because instead of every single node on the network trying to do this only one node needs to do this and then the rest of the nodes just need to validate it the cons are that it's usually considered a slightly less decentralized network due to the upfront staking costs it costs to participate now this gets into a little bit of a philosophical battle on how decentralized is decentralized enough and i think that's up to the community to decide and as we progress i think we'll learn more and more about how decentralized is decentralized enough the general consensus amongst blockchain engineers though is that proof of stake is very very decentralized and very secure this massive environmental impact improvement is one of the two main reasons why eath is shifting to eth2 it reduces the environmental impact by up to 99 percent now these are the main pieces of proof of work and proof of stake but i did want to talk about another concept that's really important in these ecosystems and that is scalability when we were talking about gas prices we were saying that the gas prices can get really high if a lot of people want to send a transaction because a block only has so much block space and the nodes can only add so many nodes so when a lot of people want to use a blockchain the gas price skyrockets this is not very scalable because if we want to add more and more people to these blockchains it's going to cost more and more to use the blockchains because more people are going to want to get into these blocks this means that there's kind of a ceiling to how many people can use the system because of the financial constraints that will get imposed as gas prices keep rising ethereum 2 is not only attacking the environmental impact of proof of work by switching to proof of stake but they are also implementing this new methodology called sharding and sharding is a solution to this scalability problem a sharded blockchain really just means that it's going to be a blockchain of blockchains there is a main chain that's going to coordinate everything amongst several chains that hook into this main chain this means that there's more chains for people to make transactions on effectively increasing the amount of block space that there is sharding can greatly increase the number of transactions on a blockchain layer 1. now there's another term that might be the first time you heard it a layer 1. we're going to talk about layer ones and layer twos in terms of scalability really quickly as well a layer one refers to any base layer blockchain implementation bitcoin's a layer one ethereum's a layer one avalanche is a layer one these are the base layer block chain solutions a layer two is any application that is added on top of a layer one added on top of a block chain some examples of layer twos are going to be chain link arbitrarily or optimism arbitrary and optimism are very interesting because they are layer twos that also look to solve this scalability issue arbitrary and optimism are what's known as rollups and they roll up their transactions into a layer one like ethereum we're not going to go too deep into rollups and how they actually work but all you really need to know is that a rollup is kind of like a sharded chain they derive their security from the base layer from the layer one like ethereum and they bulk send their transactions onto the layer one they solve some of the scalability issues by being another blockchain that people can make transactions on still on kind of this base ethereum layer now they're different from side chains because side chains derive their security from their own protocols roll ups derive their security from the base layers so arbitrary optimism for example is going to be just about as secure as ethereum there's some fantastic guys in there that go a little bit deeper into rollups and i've left a link in the description for you all right so we just talked about a lot of stuff so let's do a quick recap before moving on ethereum and bitcoin are currently both proofofwork blockchains that follow nakamoto consensus however ethereum is moving to ethereum two which will be a proofofstake sharded blockchain civil attacks are prevented due to protocols like proof of work and proof of stake 51 attacks grow increasingly harder with the size of blockchain so you should run a node consensus is the mechanism that allows a blockchain to agree upon what the state of the blockchain is sharding and rollups are solutions to scalability issues on layer ones a layer one is any base blockchain implementation like bitcoin or ethereum a blockchain scalability problem is that there's not always enough block space for the amount of transactions that want to get in them this leads to very high gas prices and again gas prices are how much it costs to interact with a blockchain so we've learned a ton in this video so far everything that you went over is going to make you 10 times better as a developer because yes being a good developer means you understand the code at a very technical level but if you can understand the overall architecture as well you can make the informed decisions about how to architect your design or how to build your software in however you want to do so so with all that being said it's finally time to jump into some solidity and jump into some code so let's do this now again in the description of this video there is a link to this github repository that's going to be the home base for all the code that we work with in this tutorial we scroll down to this main section this readme there's a table of contents in here we can go to lesson one simple storage and we'll have links helpful tips the itinerary of what we're going to learn and everything else that you need to work with here all the code that we're going to be working with is located in this simple storage link that we can go ahead and click it's in its own different repository we can go ahead and click the file to see all the code that we're going to be working with so let's jump into it additionally back in our full blockchain solidity course right at the top there's this resources for this course section if you have questions engaging in github discussions stack exchange ethereum and stack overflow are going to be great places to get help and get support i highly recommend making a stack overflow stack exchange ethereum and a github account so you can participate and engage with the community welcome to the remix ide or the remix integrated development environment this is going to be where we're starting to teach you how to work with solidity and work with smart contracts and deploy to blockchains we're going to use remix to get us up to speed as it has a lot of nice features that allow us to really see and interact with blockchains and really see what's going on but eventually we're actually going to move off of remix to another platform but all the solidity that we're going to learn here obviously is going to apply everywhere as well when you come to remix there's a whole lot of different plugins like solidity learn eth soul hint linter and a whole bunch of other plugins as well i'm going to go ahead and start by clicking the solidity plugin but we're not going to use any of these plugins for now but later on you can kind of go back and learn a little bit more about what these plugins do so let's start perusing let's start coding some things on the left hand side over here is where we're going to interact with everything so let's go ahead and click the files up here now you can always go back and peruse this a little bit more and in fact i highly encourage you to because that's how you're going to learn the most the quickest but for us we're actually just going to go ahead and start with our own brand new file we're going to create a little application that can store information on the blockchain for us and this is our first project that we're going to do in solidity so we're actually going to create a new file and we're going to call it simple storage dot soul all solidity has an extension of dot soul at the end stands for solidity now let's take inventory of what we're going to be working with here this is the solidity compiler tab it compiles all the solidity code down to machine understandable code or machine language here there's a whole bunch of different parameters we can choose when working with sliding we choose the compiler version we can choose the language which we're only going to be working with solidity the evm version don't worry about this for now so let's code our first solidity contract here now we are going to use something a little bit special here when we actually deploy these we're going to use a javascript virtual machine so we're going to use a virtual machine that's going to simulate actually deploying to a test net or a real network we're not actually going to deploy on a real network we will in a little bit but just to get started we're going to work with a javascript vm which is kind of a fake environment for now okay testing locally and understanding how to test locally will make your coding experience a lot faster as you saw when we sent some transactions some of them actually took some a lot of time to actually deploy we don't want to have to spend that much time waiting around for our tests to actually finish so we're going to use a javascript vm to kind of dummy it for now but let's just start coding and go from there so the first thing that you're going to need in any solidity program is the solidity version so that's always going to be at the top of your solidity code it's defined by doing pragma solidity and the version we're going to be using some version between 0.6.0 and 0.9.0 so we're saying we want to use anything between 0.6 and 0.9 and and as a force of habit i just automatically hit command s whenever i write anything so that's why you saw some of this pop up here we can hitting command s or control s depending on if your windows or not we'll hit this compile button and we'll compile everything for us now if we want a specific version of solidity we can also do 0.6.0 and if i go ahead and hit command s or compile our compiler will automatically convert to 0.6.0 however if i try to do 0.8.0 with my solidity at 0.6.0 it's going to give us an error it's going to say the source file requires a different compiler version we're using 0.8.0 and this is 0.6.0 so we're going to go ahead and hit compile and it's going to automatically move down to 0.6.0 we can also do carrot 0.6.0 and this will allow us to work with really any version of 0.6 it'll work all the way up to 0.7 where if we hit command s or control s there it'll give us an error so this only works with any version below 0.7 and above 0.6 we're going to be using version 0.6.6 however in future contracts that we work with we're actually going to work with different versions of solidity the reason we're going to be changing versions throughout this course is that solidity is a constantly updating language being good at switching between versions is going to make you an incredibly powerful smart contract engineer the next thing that we're going to do is we're going to define our contract so contract is a keyword in solidity which stands for our smart contract that we're going to create you can think of a contract similar to a class in java or any other objectoriented programming language so we're going to give our contract a name here we're going to call it simple storage and we're going to add this little curly bracket to say this is the contents of our contract simple storage and i went ahead and hit command s and we can see it is compiling successfully you could hypothetically deploy this right now and this would be a valid contract so great job for making it this far now in solidity there are many different types that we can work with let's go into some of the types of solidity we can have integers aka whole numbers they can be uint as in an unsigned integer meaning they're not positive or negative we can also have an int and we would define a variable by doing you in 256 favorite number equals 5. so we have an unsigned integer you went 256 means this is an integer of size 256 bits so we can have this be upped this number be up to 256. you can also do uint favorite number equals 5 but if you want to be a little bit more precise a lot of protocols and a lot of smart contracts will do the whole name like you and 256. we can also have booleans booleans are true false so we can have boolean favorite bool equals true so this favorite bool would be true it could also be false we can have strings string favorite string equals string a string is a string of text here right it's going to be some word or phrase or really any of these keystrokes here similar to the unsigned integer we can have an int 256 favorite int equals negative 5 so it could be positive or negative we can have an address which is going to be some type of ethereum address so we could do address favorite address equals and then we can even copy right from our metamask and just paste it right in here this is going to be a valid address here you'll also notice that we end all of our statements with a semicolon we can have a bytes object size 32 bits favorite bytes for our example we're just going to use the word cat because cat is a string which can be converted down into a bytes object by 32 means that there's 32 bytes in this variable favored bytes we can also do bytes 2 bytes 3 bytes 5 etc with the maximum size of bytes 32 for example we can't do bytes 64. we're going to be talking about some other variables as well like arrays and mappings but let's just stick here for now if you want to learn more about the different types and the different variables that you can use head over to the solidity documentation and there's a link in the github and the description to show you this section for now for our simple storage let's say we only want to store numbers we don't want to store anything else so we're just going to go ahead and delete everything and just have uint256 favorite number at the top now in solidity if i do this favorite number actually does get initialized even though i didn't have it initialized to 5. if i leave it blank it gets initialized to the null value in this case it would be initialized to 0. so for now let's just not initialize it to anything that way it'll get automatically initialized to zero this means that when we deploy this contract as of right now favorite number will start off as zero if you get confused you can also make a comment on this you could say this will get initialized to zero this double slash here is the way to make comments in solidity and it won't get executed as code so we can write whatever we want as long as it's preceded by two backslashes now let's go ahead and create our first function functions or methods are selfcontained modules that will execute some task for us and in solidity it's the exact same thing they're defined by the keyword function let's make a function called store that will change the value of this favorite number here so we're going to call store and we're going to allow it to be past a variable so we're going to allow it to be passed a variable of type unsigned integer 256 and we're going to call it underscore fave or it number we're going to make this a public function which we'll get to in a minute and all we're going to do is we're going to set favorite number equals to whatever variable we passed in favorite number so this in its simplest form is how you can define a function now just to visualize what we're working on so far let's go ahead and deploy this contract so we can actually start to interact with it so if we hit this button this will bring us to the deploy tab and will allow us to deploy our smart contract here using our javascript vm it's given us a fake account with some ethereum in it it has 100 ethereum in it to start and same as before anytime we want to interact with the blockchain we have to pay a little bit of gas even in our fake virtual machine here and we want to simulate that so you'll see it has some of the same parameters here as making a transaction like gas limit for example when we deploy a contract it's going to cost a little bit of ethereum or a little bit of gas to do so so let's go ahead and hit this deploy button and see what happens so once we deployed with this virtual machine a few things happened we have remix kicking out this section down here saying great job you've deployed something and if we scroll down it says transactionsrecorded1 we can look at all the transactions we've recorded and we can see it says deployed contracts and we have a contract here that we've deployed now let's zoom out just a hair here so we can see everything a little bit better in this simple storage contract we see this big store button because there's one public function that we can actually interact with so we can add this number here and we'll hit store and you'll see again we have a completed transaction and if we look at our contract we'll have paid a little bit more gas right we'll have paid a little bit more to interact with this function because again anytime we want to make a state change in the blockchain we have to pay a little bit of gas the reason metamask isn't popping up is because we're kind of doing it in this simulated environment so this is great however it looks like we can't actually see what our favorite number is we can't actually look at it so how do we actually make sure that we can view this favorite number well let's add another parameter to this as well if we add public to our favorite number we recompile by hitting command s or hit the compile button we delete this contract and we redeploy and scroll down now we'll see two buttons pop up this blue button to show us favorite number which again is initialized to zero and we have the store function so let's talk a little bit about why this public variable allowed us to see this new button this new favorite number button this public keyword defines the visibility of the variable or the function there are currently four different types of what's called visibility in solidity there's external public internal and private we're mostly going to be working with public for now but it's important to know how the rest of these work public functions can be called by anybody including variables so oddly enough variables are a function call to just look at them and return whatever that variable is an external function means it can't be called by the same contract it has to be called by an external contract so if in this contract i had this be external i couldn't call the store function i couldn't call the store function inside this function because the function is external it means somebody outside of the contract has to call this function internal functions however can only be called by other functions inside of this contract or in its derived contract and then private is the most restrictive as private functions and state variables are only visible for the contract they are defined in and not derived contracts now the reason that we didn't see favorite numbers show up in our original contract deployment is that if we don't give a state variable a visibility it will automatically get set to internal so if we want other people to be able to read it we have to change it to public now let's see how this interaction actually works if we hit the favorite number button right now we'll get this call thing that shows up and it'll show us right here that the value of favorite number is zero now this function however is set so that whatever value we pass it is going to change the favorite number to whatever we pass it as so if we pass one two three hit store that transaction goes through and then hit favorite number we can see the value is now one two three now i will also be using transactions and smart contract interactions and function calls a little bit interchangeably that's because on a blockchain whenever you call a function or whenever you make some state change to the blockchain you're actually also making a transaction that's what makes this whole thing so powerful and again that's why making a function call or deploying a contract costs a little bit of gas now the reason we can access this favorite number variable inside this function is because favorite number has this global or contract scope so even if we made union 256 tests equals 4 or equals equals 4 we wouldn't be able to use this variable outside of this function right because it's selfcontained it's selfcontained inside this bracket and if i were to make another function store two perhaps public 2 doesn't know that this test variable exists functions only know about the variables that are in the same scope as them so favorite number is in this global scope because the only bracket that's above them is simple storage and test is in this store scope because it has two brackets above it it has it's inside of the store function and inside of this contract simple storage store two isn't inside of this store function or this store scope so it can't access this test variable so let's go ahead and make this back to public and we'll compile again i'm hitting command s to compile but you can go ahead and click the button if you like and let's get rid of this now as you saw when we deploy this there's this button here that we can click called favorite number we can also make a function called retrieve and make it a public function that is of type view and returns uint256 and all this is going to do is return favorite number so we're going to talk about views and returns here so i'm going to go ahead and compile i'm going to go ahead and delete delete this contract i'm gonna go ahead and deploy it now and we can see now we have two functions or two blue buttons here we have retrieve and we have favorite number if i change favorite number by calling the store function favorite number and retrieve will both now say it's one two three so then the question might be well why is this one orange and these two are blue and the key relies in this view function or this view keyword there's two special keywords that define functions that you actually don't have to make a transaction on and those keywords are view and pure a view function means that we want to read some state off the blockchain so we're just reading off the blockchain if we're reading off the blockchain and we're not actually making a state change then we don't need to make a transaction these blue buttons are blue because they are view functions public variables also have view functions that's why both of these are blue this technically is a view function and when i click it i get to view and i get to read the state off the blockchain retrieve is the same way we could have this without a return but it wouldn't do anything pure functions are functions that purely do some type of math we'd have you in 256 favorite number public pure and just have favorite number plus favorite number so we're doing some type of math here but we're not actually saving state anywhere we're going to do this math but we're not going to save this favorite number anywhere we're not going to save anything deploy this now this pure function we would have this retrieve function one two three it's blue as well because it's again not going to change the state of the blockchain so view functions and pure functions are both can have this blue color now the reason that nothing shows up at the bottom is because we didn't return anything all we're doing is we're saying add these two numbers together and that's it in order for this function to give us something back we need to have it return something so if we go back to this retrieve to this retrieve function we have to define what we're going to return when we're defining this function so we're going to say this is a public function it's a view function because we're going to read some state and it's going to return a unit 256. so favorite number is of u 256 so that's what we're going to return our public variable favorite name is also a view function that returns a un256 for now let's just remove that so we can work with this retrieve function so let's go ahead and deploy so now we see we don't have this favorite number button anymore because it is no longer a public function because again it gets initialized to internal so we can't actually view it now keep in mind later on we're going to talk about how everything on chain you actually can see and we'll talk about that a little bit later though so retrieve is going to do 0 we can call store and now retrieve is going to be 1 2 3. now this application is great so far it allows a single person to store a favorite number and then go ahead and retrieve it later which is fantastic but what if we want a list of people or a group of people and store their favorite numbers or what if we want to associate a favorite number with a single person well what can we actually do now we have a whole number of different choices but the one that we're going to talk about is using a struct structs are ways to define new types and solidity they're almost like creating new objects as well so we can create a struct called type people and allow it to start storing a favorite number associated with a certain people so inside of our struct we can have different types as well so we have a uin256 favorite number and we could also have a string name now we have a new type of type people that has a favorite number and a name inside of it now what we could do with destruct is we could say people public person equals equals people and then inside we add the variables so we could say favorite number favorite number is 2 and name is patrick and of course the semicolon at the end and again i'm hitting command s to save but you can also go ahead and compile in the compile tab so let's go ahead and delete this contract and see what this looks like now so now we've deployed this new contract and we have this person struct which at the zero index is the favorite number and the variable stored in the first index is going to be the name storing variables and solidity always works in this numeric index fashion in fact in contract simple storage uint 256 favorite number is at index 0. if we were to add another object here like boolean favorite bool this would be at index one if we were to add bool favorite bool2 this would be at index two zero one two and it works the same in structs this is at index zero inside the struct this is at index one inside the struct so we can see the variables associated with this person we're gonna go ahead and delete this for now because instead of just creating one person we actually want to create a whole list of people so how do we create a list of people let's delete that contract and what we can do is we can make what's called an array an array is a way of storing a list or a group of some object so as you're starting to see the way the syntax works for defining any type of variable is going to be the type of the variable the visibility of the variable like public or if you don't declare it it gets initialized to internal and then the name of the variable it works the same with arrays so we'll make a people array the people array is the type we'll make it public and we'll call it people now if we deploy this contract we go and see we now have a people array but if we click this button you'll see that nothing shows up the reason is because it's an empty array to start with right we don't have anything inside of it now this type of array that we've created is what's known as a dynamic array it's a dynamic array because it can change its size right now it's a size 0 and if we added something to it it's of size one you can also create arrays of a fixed size so if i were to do people one public people this array could only have a maximum of one person inside of it so we're going to work with a dynamic array though because we want to add an arbitrary number of people into here so let's go ahead and create a new function called add person where we can add a person to this array so we'll do function add person string memory name i'll talk about this memory keyword in a minute uin256 favorite number and then we'll make this a public function and inside we'll do we'll add this person to our array the way to add a person to your arrays is using the push method so we're going to push a new people or a new person and we're going to give it those variables again so we're going to give it so we're going to give it favorite number is this variable that we passed in here oops this needs a bracket and then we're going to give the name going to be this underscore name and then end bracket oops zoom out again here just so i can see stuff this needs a semicolon and perfect now in that last clip we saw this little red box pop up whenever a little red box like this pops up after you compile it means you have a compile error this means that there's something wrong with your solidity code or your salinity syntax and it won't compile and deploy properly red is going to be this compile error now we're going to see a bunch of yellow warnings in the future if you get a little yellow popup these are okay to ignore but they usually have some helpful tips about something that might be going wrong in your code so to summarize if it's red if it's red it's broken if it's yellow you might want to check it out but it could be okay so we can see we have our new function add person where we pass a string memory name and a unit 256 favorite number and then we create this people person this people object here and then we push it onto our people array and i'm going to show you another way we can actually create a people person is just by passing favorite number and name and getting rid of this other bracket by passing favorite number and name because we know that the zeroth index of people is favorite number and the first index of people is name so we can also create a new person by adding it like this now let's talk about this memory keyword here now in solidity there's more or less two ways to store information you can store it in memory or in storage when you store an object in memory it actually means that it'll only be stored during execution of the function or of the contract call if we hold it in storage that means that that data will persist even after the function executes a string in solidity is actually technically not a value type a string is actually an array of bytes a variable of type string is actually a special type of array that we can append text to so because it's technically an object we have to decide where we want to store in memory or in storage and since we only need this name during the execution we can have it be string memory name and then when we create this new people object we will create a new copy of this name variable into storage memory means that after execution delete this variable and storage means keep it forever if this is a little bit confusing for you just know that for now when you use a parameter that's going to be a string for one of your functions you need to call it string memory so let's go ahead and deploy this contract and see what happens now now we have this new function add person and since we are making a state change here we can see that this indeed is a orange button instead of being a blue button so we can add in here a string name we'll add patrick and we'll say his favorite number is 2. again right now if we look at people we see people 0 there's nothing in here if we retrieve there's nothing in here so we're going to add person patrick and now if we hit people of 0 we can see that the person at the zerowith index in this people array is going to be string patrick if we try at one there's nothing in here let's add another person we'll add becca and her favorite number will be 24. let's add her now if we hit one we see favorite number 24 string name is becca and retrieve is so showing up blank because we haven't touched favorite number awesome this is great we can just keep adding people however there is kind of an issue here what if i'm looking for a person what if i'm looking to find becca and find her favorite number in this array what if i know her name but i don't know her favorite number is there an easy way for me to find that favorite number without having to triage the entire array there's another data structure called a mapping so let's create this new data structure so this data structure is going to be of type mapping a mapping takes some type of key and spits out whatever variable it's mapped to so in this case if we're saying we want to use the name becca to find her favorite number we would say the string becca is going to be mapped to the uint 256 favorite number and similar to all the other variable declarations the first part is going to be the typing so this is going to be a type mapping of string mapped to un256 we're going to give this public visibility and we'll call it name to favorite number and without adding any other functions that work with it if we deploy this we can see we have this blue button because we're not making a state change name to favorite number and if we type in becca in here obviously nothing's going to happen because we haven't added this mapping in yet so in our ad person down here let's even have this ad person also add to the mapping so we can do name to favorite number and then the key is going to be this name so of becca we're going to say we're going to map the name becca to the favorite number now we're going to go ahead and compile again i'm hitting command s deploy we can scroll down here if we look up backhand here we're going to get nothing however if we add becca and her favorite number being 24 this add person is going to add it both to the array and to this mapping now if we look up name to favorite number we see that becca returns 24. now one other thing i want to show you guys just because compilers are going to yell you if you don't have them is typically at the top of these contracts you want to add an spx license identifier basically solidity and the ethereum community found out that trust in a smart contract can be better established if source code is available and in terms of legality and copyright it just makes life a lot easier if you add that license identifier right at the top of your solidity we're going to use the mit license identifier because it's the most open license out there it means hey anybody can use this code and we don't care so you'll see a majority of salinity contracts have this spx license identifier mit at the top and compilers will yell you a lot less awesome we now have a contract that we've decided that we liked it's got mappings it enables us to actually store people and their favorite numbers this is fantastic we've done all of our testing in this javascript vm and we've decided you know what we want to deploy this to an actual test net or an actual mainnet how do we actually deploy this so that other people can interact with this contract we are again going to use rink b because that's what we use to make our first transaction now again you will need some type of test ethereum in your test and wallet so again if you get lost you can always just google rink b faucet or ring b test net faucet and find a faucet or a better alternative would be to come to the link token contracts in the chain link documentation at docs.chain.link and scroll down or just look up rink b this linked token contracts page has the most uptodate faucets for any test net that it supports so for example we get a test and eth faucet right here which also just happens to be that exact faucet that we used earlier the only thing you need to change in remix is we need to change from javascript vm to injected web3 and metamask will actually pop up and say hey would you like to connect to this application anytime you're working with a web3 application or a web application that wants to access your funds or work with your metamask metamask will pop up and ask for authorization first this is really good so that we know which applications we're actually connected to so we're going to go ahead and say next connect and we can see here that we've even connected here and that our account on the main network has zero eth and remix even tells us hey you're on the main network so let's go ahead and switch to the rink b network and we can now see we're on the rink b network and we have 17.74 eth on this ring b test network injected web 3 means we're taking our meta mask and injecting it into the source code of the browser here and that's the difference between injected web 3 and javascript vm web web3 provider is if we want to use our own blockchain node or our own web3 provider when we do injected web3 we're saying our web3 provider is our metamask which will work perfectly for what we're trying to do so since we already have some tests on ethereum let's go ahead and deploy this and see what this would actually look like if we deployed to a mainnet the process is going to be exactly the same right the only difference was we would be on the main net instead of rank b so let's go ahead hit deploy we'll uncheck publish published ipfs hit deploy metamask will pop up asking if we want to do this transaction because remember we are deploying a contract we are changing the state of the blockchain so we have to pay a little bit of gas fee for it so we're going to go ahead and hit confirm and we get a link to ring the ether scan similar exactly as we saw before when we made a transaction the difference here is that instead of sending ethereum to somebody we're actually making a transaction on the blockchain to create a contract after a short while it will show up here on etherscan with a success the number of block confirmations which again is the number of blocks appended to the block that included our transaction we see from which is our account here and we see two is this new contract that we just created and we can even click it and we see that there's this unique transaction hash that created a new smart contract and same as working with the vm we have all the exact same functions in here and you can see if i hit retrieve these three functions since they're not making a state change you can just click them and no transactions will be made however what do you think is going to happen if i hit store if you guessed metamask will pop up you guess correctly again we see the familiar pieces here we have a gas price gas limit go ahead and hit confirm we get another transaction here and once this transaction goes through we should be able to call our retrieve function and see a new number if we call it now nothing shows up because our original transaction hasn't succeeded but i bet if we look at it now okay it's still indexing but it looks like it's been included if we hit it now we do indeed see this value here and we can do the same thing with adding a person we'll add becca we'll say her favorite number is 24. metamask will pop up we'll go ahead and confirm the transaction and if i look up becca and the name to favorite string right now it's going to show nothing because our transaction hasn't gone through yet but if we wait a little bit i should probably spell her name right we do see 24. and if we look at the zeroth index we also see becca's been added here as well now all the solidity code that we wrote and when we interacted with this blockchain here all this solidity was compiled down to the evm also known as the ethereum virtual machine a lot of the blockchains out there today are what's called evm compatible and that means that all this solidity and all these functions that we're creating can still compile down to evm and deployed on their blockchain you'll find out a little later when we look to work on a nonethereum based chain that we can still deploy our solidity smart contracts to these other chains as well but that's a term you'll hear more and more the ethereum virtual machine or ebm now take a break give yourself a high five because you just deployed your first smart contract and you learned the basics the fundamentals of solidity so huge congratulations on how far you've gotten now in our second projects we're going to take the fundamentals a step further and start going into the more of the intricacies of solidity but just as a quick recap the first thing you always got to do in your smart contracts is name the solidity version then you'll have to name your contract a contract in solidity is like a class and defines all the functions and parameters of your contract there's many different types in solidity like unsigned integer 256 boolean and bytes we can create structs in solidity we can create arrays in solidity we can create mappings in solidity we can create functions in solidity view functions don't make a state change memory and storage are two different ways to initialize where a variable is going to be saved all the solidity code that we're working with gets compiled down to the ethereum virtual machine and last but not least congratulations on taking your first step in learning solidity let's move on to the next project all the code tips and links that we're going to be working with can be found in our course repository we can scroll down to lesson two storage factory click it here and we can see all the code we're going to be working with good luck all right so we've done it we've got our first contract out of the way we're understanding some of the basics of solidity now let's move onward let's get a little bit more advanced with what we're going to do with our smart contracts and let's build what's called the factory pattern of smart contracts so we have our simple storage contract here which is great it allows us to store numbers and store favorite numbers associated with different people and this is great what if though i want to have a lot of these simple storage contracts deployed i want to give people the ability to generate and deploy their own lists based off of this contract this is where the factory pattern comes into play so let's go ahead and create a new contract so in this contracts folder i'm going to do new file we're going to call this storage factory dot sol and now we'll have a storage factory.sol now the way that we're going to do this is that you need simple storage and storage factory in the same folder i have both of them in this contracts folder but if you have them outside or in a different folder that's okay just make sure wherever they are they're in the exact same folder so let's figure out how to get a contract to actually deploy another contract we're going to add those basic pieces that we added in that simple storage.sol we'll add the spdx license identifier which will be mit we'll choose our solidity version which will be pragma solidity and we'll say anything in the six range and then we'll create our contract we'll say contract storage factory and we'll create our brackets here and i'm going to do command s or compile whatever you want to do things are looking good here great so how can this contract deploy a simple storage contract well the first thing that we're going to need to do is actually import this simple storage into our storage factory contract we need to import it so that our storage factory contract knows what a simple storage contract even looks like the way that we can import it is by doing the command import and then the file path that the simple storage is located so the file path for this is going to be at dot slash simple storage dot soul this means that simple storage is in the exact same directory as storage factory doing this line is equivalent to copying everything in this contract bit coming over to storage factory and pasting it above you can even save and compile and have two contracts in the same file now what's interesting about having two contracts in the same file is that when you go to deploy you'll actually have a choice of which one you want to deploy and it's the same thing if i do that import statement so if i delete all this and i go back to import dot slash simple storage dot sol in our deploy tab still you'll see that we still have our choice of which contract we actually want to deploy so this is how we actually import a contract or import any type of file that we want so that our contract knows what that contract looks like and can do so if we want this contract to then be able to deploy a simple storage contract we're of course going to have to create a function that can do that so we'll do function we'll call it create simple storage contract we'll make this a public function we'll do our little open and close bracket in here the way we can generate a contract of simple storage type is by using a new keyword so let's create a simple storage variable we'll say a variable of type simple storage contract we'll name this variable simple storage with a lowercase s equals new simple storage what this line is saying is we're saying we're going to create an object of type simple storage contract we're going to name it simple storage with a lowercase s and we're going to say this is going to be a new simple storage contract and we're saying this simple storage contract takes no input parameters of course if we deploy this contract as is by going to our deploy tab choosing the storage factory staying on a javascript vm deploying scrolling down we have this function that doesn't return anything so we're creating new contracts but we can't really read where those contracts are being created we'd have to look on a block explorer like etherscan or something so let's make a way for us to keep track of all the different simple storage contracts that we deploy let's put them in a list or in an array so what we can do is we can say simple storage array of visibility public and we'll call it simple storage array we'll initialize this symbol storage array and every time we deploy we create one of these new simple storage contracts we'll add it to our simple storage array so we'll do simple storage array dot push and we'll push this simple storage variable so again i'm compiling or hitting command s delete that most recent contract we'll choose the storage factory and not the simple storage and we'll hit deploy now if we scroll down to our storage factory we have this blue button which stands for our simple storage array if we try to see what's at index 0 we get an error of course because we haven't added anything to it yet if i click this create simple storage contract orange button here now i've created a transaction that's going to create a new simple storage contract and push it onto our simple storage array now if i try to access the zerowith index or the first index of this array i'm going to get this address here this is the address that this simple storage contract was deployed to so we've successfully deployed a contract to the blockchain from another contract and this of course is really exciting now we can actually do more than just deploy the contracts we can actually deploy contracts from another contract and then call those functions as well so let's create a new function where we call this store function and we'll also create a function where we call the retrieve function from our storage factory so we'll do function storage factory store we're going to shorthand it by saying sf store we'll have it take unit 256 simple storage index and a uint256 underscore simple storage number we'll make this a public variable as well in our little brackets here and the reason i'm choosing a simple storage index is because we're going to choose which simple storage contract in our list that we want to interact with and then we're also going to pass a simple storage number to call on the store function which of course we need to pass a favorite number to any time that you interact with a contract you need two things you need the address of the contract you want to interact with and you also need the abi for us we figured out that we're going to push and get this address from this simple storage array we can get the abi or the application binary interface from this import we'll explain the application binary interface a little bit more later for now just know that in order for us to interact with this simple storage contract we can just do simple storage and then we'll pass this simple storage the address of that simple storage contract to get the address of that simple storage contract we'll say grab the address inside the simple storage array at index simple storage index this will return that contract that we want to interact with so we could even say simple storage simple storage equals simple storage at that address in the array once we get this contract we can then call any and all of its functions so we could call simple storage dot store this simple storage number now if we compile this we go to our deploy tab deploy the factory hit deploy open this up we can see we have a couple different functions here we of course have our create simple storage function which creates the contract and adds it to our array we now have this sf store which stores a number to one of those contracts on this array and then we have a lens into that simple storage contract so if i create a simple storage contract i can now store on that zerowith contract on that first contract any number that i want like 55. of course i can't really see that 55 because we didn't add a retrieve functionality we didn't add a way to actually listen or read or retrieve that favor number that we got so let's add that now so we'll create a new function called sfget and this will take a uint 256 simple storage index and as a parameter and we'll choose one of these contracts on this array and return its favorite number calling the retrieve function on that contract so since we're just going to be reading state this can be a public view function that will return a uint256 to do this we need to access that contract once again so we'll say simple storage simple storage equals simple storage at that address of simple storage array at index underscore simple storage index and we can return return simple storage dot we call this retrieve function i'm just going to copy paste it so i don't spell it wrong simple storage we'll put the semicolon here too and here now if we compile this go to our deploy tab delete the most recent choose the storage factory and hit deploy we can see we now has have an sfget function so let's go ahead create a simple storage contract we'll store a function on the zeroth contract we'll store 55 as its favorite number and we'll hit that and then for s of get we'll see if we can get the favorite number of the zero with contract and we do indeed get 55. awesome we can actually even refactor this code to be a little bit simpler here we don't need to save this simple storage contract is a variable here we can actually just call retrieve on this whole section here paste retrieve at the end and just return like this the same goes for our sf store we can delete saving it as a variable we can copy this dot store paste it at the end here and delete this as well now we'll compile delete the most recent we'll deploy the storage factory and if we go into it create a simple storage store the number 55 see what's at the zeroth index and we do indeed see 55. so this is really cool this is a way for us to actually deploy contracts and interact with contracts from another contract now to deploy a contract we do need all the functionality of that contract imported however to interact with the contract we don't need all of the functionality we'll learn about interfaces in the next lesson which will allow us to actually interact with the contract without having all the functions defined and now i'm going to show you something really cool now i'm going to show you something really cool simple storage has got a lot of really cool functions and maybe i want all these functions inside my storage factory i want my storage factory to be able to create simple storage contracts and i want it to be a simple storage contract itself well what i can do is my storage factory can actually inherit all the functions of simple storage without me having to copy paste all these functions and all these variables over to storage factory what i can do is i can do solidity's version of inheritance i can say contract storage factory is of type simple storage or is of contract simple storage and just by doing this line right here my storage factory contract now will have all of the functions and variables of simple storage so it'll have a store function a retrieve function an add person function a people array a name to favorite number mapping it'll have everything because i will inherit it with this is syntax so if i go to my deploy tab now let's look at what our last storage factory was all we did to change this was add is simple storage and we can see just the four functions that we originally added if i delete this now if i save and compile the storage factory let's go ahead and deploy storage factory if we open this up now we can see not only do we have all the functions originally defined in our storage factory but we additionally have all the functions from our simple storage and awesome you've completed the second lesson we've learned about some incredibly powerful tools here we've learned how to import entire chunks of code from other files into our files we've learned how to do inheritance we've learned how to deploy contracts from our contract and then we've learned how to interact with different contracts from outside of our contract well done now is a great time to take a breath take a breather and review what you've learned the github repository associated with this course also has all the code for this lesson so let's jump into it so we're back in remix now and we're going to go to contracts and same as before we're going to create a new file we're going to call this fundme.sol now same as last time we're actually going to add this spdx license identifier mit right at the top and then we're going to choose our solidity version so we're going to go pragma solidity and for this we're just going to do greater than equals to 0.6.6 and less than 0.9.0 and great this should look pretty familiar now we're going to do contract fund me and we're going to start working so what again do we want this contract to do we want this contract to be able to accept some type of payment so let's create a new function that can accept payment we'll call it fund so we'll do function fund public and we'll add a new keyword in here called payable when we define a function as payable we're saying hey this function can be used to pay for things when you call a function every single function call has an associated value with it whenever you make a transaction you can always append a value this value is how much whey or gray or fini or ether you're going to send with your function call or your transaction as we mentioned before whey way and ether are just different ways to talk about how much ether you're going to send so if we look at a way to ethereum converter one each is this much way one way is the smallest denomination of ether you can't break up ethereum into anything smaller than one way this is why when you're talking about how much something costs everything always defaults to whey or the smallest unit of measure in ethereum so again for us to test we're going to stick with the javascript vm for now if we hit deploy we get a new contract and this button is now red it's red because it is a payable function so now if i hit this fun button i can add a value associated with it so what do we want to do with this funding what do we want to do when people send us something well let's keep track of who sent us some funding so what we can do is we can create a new mapping between addresses and value so let's do a mapping of address to uin256 which will represent the value we'll make this a public mapping and we'll call it address to amount funded now in this fun function let's keep track of all the people who sent us money or all the addresses that sent us some value to do this we can use some keywords that go along with every transaction so we'll say address to amount funded of message.sender equals or plus equals message.value message.sender and message.value are keywords in every contract call and every transaction message.sender is the sender of the function call and message.value is how much they sent so whenever we call fund now somebody can send some value because it's payable and we're going to save everything in this address to amount funded mapping so if we deploy this now in our javascript vm we now have again a new view function called address to amount funded and we can even hit the drop down to see the full name now if i hit fund nothing's going to happen right because my address is going to be sending zero in order for me to send something i have to add some value along with my transaction so let's send for example one way which is going to be equal to 1 1 2 3 4 5 6 7 8 9 this much way so before i hit fund here if i copy this fake account which is up here and i put it in this address to amount funded it's going to return zero but now if i add 1 1 2 3 4 5 6 7 8 9 in here and we go ahead and hit fund now we've now just called this fun function with a value of one gray associated with it so if i call this address to amount funded now with the same address i can now see how much we've funded this smart contract and we can even add more gray we'll add we'll add 11gway for example we'll call fund and if we call this now we can see that even more has been added when we send our funds to a contract this actually means that this contract wherever this is deployed now is the owner of this amount of ether so this is fantastic we now have a way to fund our smart contracts now here's the thing in this smart contract in this funding that we're doing we want to create a minimum value for people to be able to fund our endeavors which whatever they may be we want to set some minimum value here and ether is great but for whatever reason we want to work in usd or maybe we want to work in some other token so how are we going to get the conversion rate from that currency to a currency that we can use in this smart contract well the first thing that we're going to need to do to set this value is we're going to need to know what the eth to usd conversion rate is because if i want to accept ethereum as the token but i want it in its usd currency well then i'm going to need to know what that conversion rate is so how are we going to get this data into our smart contract where are we going to get this data from now remember how we talked about blockchains being deterministic systems and and oracles being the bridge between blockchains and the real world well this is exactly where oracle's come in when we're talking about these systems you know these blockchains they can't connect to realworld events they can't connect to external systems they can't do external computation they're intentionally these deterministic systems these walled gardens so in order for us to make this connection we need a blockchain oracle we need some type of network here now just to get a little bit more technical for you if we look at a blockchain a blockchain can easily say one plus one equals two and every other node can easily verify this however a blockchain can't easily say okay let's all grab the same random number because each node is going to get a different random number they also can't say hey let's make an api call because if one node calls the api at a different time another node calls it or specifically an http get there could potentially get very very different results and if another node tries to replay these transactions by calling these apis again maybe 10 years in the future there's a good chance that that api is going to be depreciated and they could be hacked they could be malicious et cetera et cetera the other reason that blockchains intentionally can't make api calls is because then they would be making assumptions about the real world and layer ones typically don't want to have an opinion on any political or geopolitical issue whereas an oracle network on the other hand can make those assumptions the other main thing we need to talk about here is centralized oracles being main points of failures if you or i say hey i'm just going to be the oracle i'm going to be the one to put this data on chain we now have this massive centralized point of failure we've done all this work to make our decentralized computation decentralized and on chain but we ruin all the decentrality by having a single point of failure remember one of the whole purposes of blockchain is so that not a single entity can flip a switch and restrict our freedom to interact with a centralized oracle a single entity can flip a switch and restrict our freedom to interact with each other we also need to get data from many different decentralized sources or do any type of computation in a decentralized manner this is where chain link really shines chain link is a modular decentralized oracle infrastructure and oracle network that allows us to get data and do external computation in a highly civil resistant decentralized manner it can be as customizable as you want as you can run with one node or many nodes or do as many nodes as you like now currently one of the most popular features of chain link is their data feeds or their price feeds we can even go check them out over at data dot chain dot link we can see a number of different price feeds and the networks that are providing the prices for these specific pricing powers we can see here by looking at the ui there is a whole number of decentralized different oracles returning data for different price feeds this one for example is fusd and it's also exactly the price view that we're looking for having a decentralized network bring this data on chain and have it as a reference point of definitive truth allows users to all collaborate and use this common good and it will be cheaper more secure more efficient than anybody even running their own centralized oracle so these price feeds are incredibly powerful additionally they're being used by some of the top protocols in the defy system right now like synthetics which at the time of recording is securing around 2 billion sushi swap for leveraging trades set protocol commodity money ave for understanding the price of an underlying collateral now this is an example of an out of the box decentralized solution that's already been packaged in the decentralized manner for you to consume and for you to use this makes going to production a thousand times easier than building everything yourself however if you want to make api calls and build your own decentralized network you absolutely can with the chainlink api calls we're not going to go into that here because using the chainlink price feeds chainlink vrf keeper network and all these other prebox decentralized services are going to make going live and going mainnet a lot easier you can always make a chain link http get call as well we're not going to go over this though because putting this into production is a little bit trickier and working with chainlink vrx if you ever want to try them out by themselves you can always head over to docs.chain.link and head over to get the latest price feed there's usually a remix button actually that we can click and it will kick us out to a remix edition with all the code already ready to go for us if we just hit this just right here this will include all of our code which we'll go into in a second but let's go ahead and compile it we're going to deploy it to a real network here this one looks like it's actually for covin so we're going to go ahead and switch to coven looks like i don't have any covent ethereum so we're going to grab a covent faucet we can usually find different faucets in the chain link documentation let's look up kovin here there is a coven faucet here it looks like in order for us to get some covent ethereum here we have to log in with github then we can add our address in here and get the ethereum in the interest of time i'm going to skip ahead for me doing that great it looks like i've got some covent test that now being able to switch between test nets is going to make you a lot more effective as an engineer as well because you're going to be able to understand how each network actually works so now we've compiled this let's deploy this again metamask is going to pop up and let's go ahead and click to get the latest price and we can see that this function does indeed return the latest price of ethereum now you might be asking why does this number look so big well remember how we talked about whey and gray and ether well the reason that those exist is because decimals don't work in solidity so we actually have to return a value that's multiplied by 10 to some number so this value is actually 2614 times 10 raised to the eighth now the next question you might ask is well why did we work with this on a test net why can't we do this on a local network and the answer to this is because there is a network of nodes looking at this test net and delivering data onto this test stem when you spin up a local network or do a simulated vm there are no nodes actually doing that we'll learn later how to actually mock these interactions and mock a chain link node returning data onto our blockchain but for now let's head back over to the contract that we're working on so we can learn how to implement this in any contract that we ever want to another contract called in this case called price feed has a function called latest round data which returns a lot of data it returns a round id which defines how many times this price feed has been updated it returns a price which is the actual conversion rate between the two assets it returns a started at which defines when this was last updated it returns a time stamp and it returns an answer in round don't worry about answered in round for now if you want to dive a little bit deeper into what these rounds mean and what answered in round means you can definitely check out the chain link documentation and some of the faqs to learn more now how do we implement this data feed into our fundme application well the first thing we're actually going to need to do is we're going to need to import the chain link code so we're going to do import at chain link contracts source v 0.6 interfaces slash aggregator v3 interface dot soul now let's talk about what this is actually doing oops looks like i spelt aggregator v3 interface wrong all right great now it's actually compiling so let's talk about what imports actually do as we know an import will take whatever code you're importing and stick it at the top of your project so when we import from at chainlink contracts we're actually importing from the at chainlink contracts npm package we can look up at chain links contracts in npm and we can see and read more about this repository this links us back to the github which will tell us a little bit more about what's really going on if we follow that import path that we got from the documentation we'll end up on this file in front of me now we have what's called an interface you can see these contracts don't start with the contract keyword but they start with the interface keyword they have the exact same pragma solidity at the top but the main difference is that you can see that their functions aren't completed they just have the function name and its return type now just to be a little bit more explicit here i'm actually going to go ahead and delete this import statement on the top and replace it with that interface code from github just to show you exactly what's going on however if you've already typed that at import syntax feel free to leave it in there and just remember that it's going to be the exact same as me copy pasting the interface code in our code here solidity doesn't natively understand how to interact with another contract we have to tell solidity what functions can be called on another contract this is where interfaces are actually going to come in similar to structs what we can do with interfaces to find a new type so if we copy all this code from this section and place it at the top of our code here above where we're declaring a contract we can actually then interact with contracts that have these functions if we go ahead and even compile this we can see this does indeed compile correctly remember how we said before we talked a little bit about abis well interfaces actually compile down to what's called the abi or the application binary interface the application binary interface tells solidity what functions can be called on another contract we need solidity to know what functions it can use and what functions it can call other contracts with and if that was a little bit confusing just know any time you're going to interact with another contract in solidity or smart contract programming in general you're going to need that contracts abi we'll go into what these apis look like a little bit later anyways to simplify it interface compiles down to an api we always need an api to interact with the contract so how do we actually work with this contract here to interact with an interface contract it's going to work the exact same way is interacting with a struct or a variable let's define a new function called getversion and we're going to call this version function on this other contract so we'll start out doing function get version public remember it needs to be a view since we're just going to be reading this state and even in the interface it even defines it as a view returns so we'll even grab this whole bit right here view returns unit 256. now the exact same way we define variables and structs we define working with other contracts and interfaces so the first thing is we name the type which in this case is aggregator v3 interface then we'd name the visibility but since again we're inside of this contract we're going to skip it then let's give it a name we'll call it price feed since this aggregator v3 interface is going to be giving us a price fee then we can do equals and this is where we're going to initialize the contract so how do we actually choose where to interact with this contract well we just type aggregator v3 interface and then we put in here the address of where this contract is located in order to find where this fusd price feed contract is located on the rink b chain we can look at the ethereum price feeds chain link documentation it has a ton of different price feeds and even more not price related data let's scroll down to rink b because again on each different chain the contract address that has all this price feed information is going to be different let's scroll down and find fusd which is right here and we'll copy it and we'll paste it into here now what is this line saying it's saying that we have a contract that has these functions defined in the interface located at this address if that's true then we should be able to call price feed dot version and we should be able to return it whoops looks like we forgot to add those here and we need a semicolon here i hit ctrl s or command s compiled it looks like we're compiling successfully and we do need to deploy this on a test n remember this address here is located on an actual test tent it's located on an actual network it's not going to be located on our simulated chain here so we do need to deploy this to injected web 3. we do need to deploy our contract to rink b because the rink b chain has this address we'll learn later on how we actually can work with a simulated chain and work with these price feeds but that's much later in this course so let's go ahead and save we'll deploy make sure we're on injected web 3. now we can go ahead and hit deploy metamask is going to pop up per usual confirm we're going to get a transaction link to etherscan showing us our contract and once it actually is confirmed we can see we have our contract right here now we have our familiar functions with one additional function we have our fund button which is red because it's payable we have our address to amount funded mapping which is blue because it's a view and we also have this get version button that's also blue if we go ahead and click it we can see that the version of our aggregator v3 interface is version 3. this is the third version of the aggregator interfaces hence the name aggregator v3 interface so we just made a contract call to another contract from our contract using an interface this is why interfaces are so powerful because they're a minimalistic view into another contract so this is great we have a get version function but this still isn't the function that we want we want to call the get price function which if we look at our interface we can see there's a latest round data function that returns an answer this is the function that we're going to want to call on this contract so let's go ahead and make a function that calls that instead so we're going to do function get price public view returns uint 256. uh oh this latest round data function though returns five variables so how do we actually work with that well let's find out to work with this contract we're gonna do the exact same thing we're gonna do aggregator v3 interface because this is the type of the contract price feed equals aggregator v3 interface we'll do this same address in here because this is the fusd address then we'll do price feed dot latest round data now since this is going to return five different values we can actually have our contract also return these five different values we can copy paste like this and literally do this these five values equal price feed that latest round data and you can see that even compiles correctly let's adjust the formatting a little bit here so it looks a little bit nicer a tuple is a list of objects of potentially different types this is the syntax for getting a tuple we can define several variables inside one of these tuples although our compiler is going to give us some warnings it's saying unused local variable because we're not actually using these for anything we'll come back to this now we can go ahead and do return and we can pick one of these variables that we want to return answer is going to be the price so we're going to do return answer but uhoh we're going to run into an error return type argument in 256 is not implicitly convertible to expected type answer is an int 256 and we want to return a uint 256 so how do we rectify this we can fix this by using what's called typecasting if we just return answer we're going to be returning the wrong type however integers and solidity are really easy to cast into each other so we can just do uint 256 and wrap it around this answer and then compile and save that instead as you can see now our compiler is happy because we've changed this answer into a unit 256 awesome so now this get price should return the latest price of ethereum in terms of usd let's go ahead and deploy this new contract with this new function so same thing we're going to come to our deploy section hit the deploy button up remember we got to go to the fundbean.sol let's deploy it confirm with metamask here and let's scroll down to our newly deployed contract as you can see we have our get version function which still works exactly the same but we have a new function too called get price and this should return a uint 256 answer let's go ahead and click it amazing we've actually returned an answer now again if you're a little confused on why this number looks so big you have to remember that this actually has eight decimals we could call this decimal's function on the contract to learn that one two three four five six seven eight and we know that the current price of ethereum in terms of usd is two thousand four hundred and eightytwo awesome so now that we have the price we can actually get the conversion rate but let's clean up this function a little bit before we go on up there as you can see one thing that the compiler is complaining about is we have a lot of unused local variables but latest round data returns five different variables so how do we actually return the five variables but make our compiler happy with us well we can actually just return blanks for each one of these sections with commas in between each other to say hey there is a variable here but we're not going to use it this will also make our code look a lot cleaner because now this function's a lot smaller we say something's here we're ignoring it in 256 answer we're going to use some things here ignore it something here ignore it and ignore this too and we can even test this out by compiling it deploying it checking on rank b scrolling down hitting this and hitting get price and you can see indeed it's the exact same as before awesome so now we're all done cleaning things up right not quite yet see the other thing that's really annoying here we have this massive chunk of code at the top that is probably a little redundant there's a good chance that a lot of our contracts are going to want to use this aggregator v3 interface so let's just go ahead and add that at chain link contract syntax back in because it's going to look a lot cleaner here and do at chain link contracts if you ever get a little bit confused with what you should be importing to work with their contracts we can see right in the documentation at the top this at syntax is what this is going to use now you can also go ahead and browse that npm package of at chainlink contracts see what other applications are in there and what other files are in there or you can just peruse around the github now the third way we can actually do imports is we can import from contracts that are in the same file system as our contracts well awesome our contract is starting to look more and more put together now one other thing that i usually like to do with these is i usually like to put everything into the gray way standard so as we saw this get price had eight decimal places however the smallest unit of measure aka whey if we look at it has 18. one two three four five six seven eight nine ten one two three four five six seven eight so typically in these i like to try to make everything have 18 decimals as well you don't have to do this and it'll save some gas if you don't but i usually like to multiply everything so that everything has 18 decimal places so since i know this has 8 i can just do 1 2 three four five six seven eight nine ten and now this will return the price with eighteen decimal places instead of ten now we have the price of ethereum in us dollar which is fantastic so we could set the price of our funding function to anything that we want here for example let's say 50 we could convert whatever value that they send us to its us dollar equivalent and see if it's greater than or less than fifty dollars all we have to do is make a new function that converts that value that they send to its us dollar equivalent so we could do function get conver generate and it will take a u 256 f amount let's get this out of the way for the rest of this it'll be a public view function since again we're not actually going to have it make any state change we'll do returns you want 256 and then in this function we can do uint 256 f price equals get price and we can call this get price function up here now we have the price in here what we want to do is we want to convert whatever value that they send as f amount let's say they send one way or again that's going to be this much way what how do we convert this to fusd well we can now do unit 256 s amount in usd equals this f price times the f amount that they sent this is actually going to result in a much bigger number than we're looking for and then of course we're going to return it let's test this out and see why we have to do one more thing here so let's again fund me we'll deploy rank b we'll scroll down and we have this new function called get conversion rate let's grab this one gray and put it in here whoa this seems like it's a really big number we're saying that one gray is equal to one two three four five six seven eight one two three four five six seven eight nine ten this many dollars now i don't know about you but i don't think the price of even one ethereum is that many dollars maybe in the distant future but definitely not right now the reason that it's off is we have to then actually divide by this number the reason that we have to do this is because both f price and f amount have an additional 10 raised to the 18th tacked on to them so now we have to divide it out in order to get the right number so we're going to compile compile deploy confirm we can scroll down and now let's try this one way we'll get the conversion right here and we can see we get a number that makes a little bit more sense now remember this has 18 decimals as well so the real number is 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 9 10. and we know that this number is actually accurate because we can go ahead and pull up a calculator pop that into here and we know that this is one way in us dollar if we get the conversion rate we're saying that this many gray equals one each so we can check it back by multiplying this number by that and we see that we do actually get the price of one ethereum in us dollar so our math here checks out awesome now since we're on the topic of math i do want to talk briefly about some of the pitfalls of solidity especially when it comes to math prior to solidity 0.8 if you added to the maximum size a uint number could be it would actually wrap around to the lowest number that it would be and in fact you can even demo this with a contract here now you don't have to follow along with this contract but just watch to see the example we're going to call this overflow dot sol now in here we're going to add all kind of the normal stuff contract overflow and we're going to add a function called overflow we'll make a public view and we'll have it return a uint 8. i'll show you why in just a minute a union 256 is a really really big number and it's hard to kind of imagine going over the maximum cap of a u and 256 but a uint 8 is a lot smaller with the maximum number actually being 255. so if we create a uint 8 and we call it big equals 255 and then we just do return big what do we think we're going to get here for this we can go ahead and use javascript vm because we're not interacting with any other contracts let's deploy this and we'll see in our contract if we call overflow now we're just going to get 255. however what happens if we add 1 to this number or try to add 1 to this number if we do it just like this solidity actually knows that there's an issue here and says hey try not to do this but if we typecast this as a uint eight solidity gets a little bit more confused and goes ahead and lets us do this now what do we think big is going to be it should be 256 right but big is the uint 8 and this is the maximum size that it could be so what happens when we deploy this we look down we actually get zero what happens if we do 100 and we deploy that we actually get 99 and this is because integers can actually wrap around once you reach their maximum cap they basically reset this is something we need to watch out for when working with solidity if we're doing multiplication on really big numbers we can accidentally pass this cap luckily as a version 0.8 of solidity it actually checks for overflow and it defaults to check for overflow to increase readability of code even if that comes a slight increase of gas costs you can use this unchecked if you want to have it keep that wrapping functionality so just be aware if you're using a lower version than 0.8 you're going to have to do something to make up for this and we could write a whole bunch of code here basically to check all of our math or we could just import something called safe math from another package similar to how we imported chain link we can go ahead and import a package called safe math from a tool called open zeppelin now open zeppelin is an open source tool that allows us to use a lot of already prebuilt contracts we can go ahead to the documentation and go to their utilities and see safe math and they even have a little sticker here saying safe math is no longer needed started with solidity 0.8 safe math is a tool and a way for us to avoid some of these problems with doing math and solidity now i'm not going to spend too much time on the contracts that actually fix this but we can actually import right from the chain link directory as well a solidity file called safe math chain link and what we can do is right after our contract we can do using safe math chain link for uint256 and what this will do is it will use safe math chain link for all of our unit 256 and safe math chain link doesn't allow for that overflow to occur libraries are really similar to contracts except that they're isolated code that can be run in a reusable context in this case we're attaching the safe math chain link library to uint256 so that these overflows are automatically checked for just keep in mind if you're using anything less than 0.8 you're going to want to use some type of safe math just to check for your overflows now this is for those of you who are familiar with safe math and integer overflows and underflows we are not going to be calling the functions that safe math provides us like div add mole you know all those functions simply because in 0.8 moving forward we no longer have to use those and we can just use our regular operators like plus and minus so this is great our contract is coming along really well we now have a way to get the conversion rate of whatever f is sent and turn it into us dollar now we can set a threshold in terms of us dollar but how do we guarantee that whatever amount that the users send when they call fund is going to be at least fifty dollars well first we might want to set a minimum value so we can do unit 256 minimum usd equals let's say 50 and again since we're using everything in way terms we want to then multiply this by 10 raised to the 18th and just want to take a pause for a second because this line is actually wrong this should be raised to the 18th so this line should really look like this where it has the double star so apologies the rest of this has that single star but it should be the double star here if you do have the single star though the rest of the contract will still work fine so this will be the minimum value it'll be 50 times 10 raised to the 18th so that everything has 18 decimals now that we have a minimum amount how do we actually make sure that this minimum amount is met in the value that they send us well if you're familiar with if statements we could do something like if message.value is less than minimum usd then revert or we could do something a lot easier and better practice and much cleaner we do what's called a require statement when a function call reaches a require statement it'll check the truthiness of whatever require you've asked so in our case the converted rate of message.value needs to be greater than or equal to our minimum usd this line says that if the conversion rate of message on value to usd if they didn't send us enough ether then we are going to stop executing we're going to kick it out we're going to say hey this doesn't count and we're going to do what's called a revert we're going to revert the transaction this means that the user is going to get their money back as well as any unspent gas and this is highly recommended we can also then additionally add a revert error message something like you need to spend more eath so now let's try this out as we saw one way is going to be way less than fifty dollars so if we send one way along with this fund contract call it should kick out and say you need to spend more eth so let's actually try this let's go to the deploy tab we'll get rid of our overflow we use injected web 3 because again we are working with the chain link aggregated contracts that are on chain we're going to move to fund me and we're going to hit deploy metamath's going to pop up and we're going to hit confirm now if i try to hit fund let's see what happens we're getting a gas estimation failed since gas estimation error failed with the following message execution reverted you need to spend more eth so the contract isn't even letting us make the transaction we can go ahead and try to send the transaction but here's what's going to happen on ether scan once this goes through you can see that once this transaction finished we got this status fail with error you need to spend more eth we don't want to force these transactions to go through if we look at our metamask we can even see this failed bit here so whenever you see these gas estimation failed errors usually that means something reverted or you didn't do something that was required however if we go to value here and we spend a lot more let's say 0.1 ether which if we take out our calculator 2500 times point one it's going to be 250 dollars this should easily be well and beyond past our 50 threshold so let's add 0.1 ether remember we got 0.1 by adding it in the converter and grabbing the way again the way is the smallest denomination now if we change this to way and hit fund this should go through we're gonna hit fun now you'll see men and mass pops up because metamask goes oh yeah this transaction isn't going to revert and that's what we want so we can go ahead and hit confirm and now we'll finally have sent some funding to our contract now that this is confirmed we go ahead and grab our address here pop it into our address to amount and we can see that indeed our funding has gone through now we can be part of this crowdsourcing application with our minimum value which is fantastic awesome great job awesome so now we can fund this contract with a certain minimum usd value in this case it's going to be 50 now you'll notice though that right now we don't do anything with this money so we're going to fund this contract however that's it and we don't have a function in here to actually withdraw the money so there's no way that even though we just sent this contract some money there's no way for us to get it back so how do we fix this well we can add a withdraw function in here so let's go ahead and add that function withdraw and this is also going to be a payable function because we're going to be transferring eth we'll make this public and we can do message dot sender dot transfer transfer is a function that we can call on any address to send eth from one address to another this transfer function sends some amount of ethereum to whoever it's being called on in this case we're transferring ethereum to message.sender so all we need to do now is define how much we want to send well we're going to send all the money that's been funded so to get all the money that's been funded in this contract we can do address this dot balance now there's a couple of special things going on with this line first we're saying address of this this is a key word in solidity whenever you refer to this you're talking about the contract that you're currently in and when we add address of this we're saying we want the address of the contract that we're currently in whenever you call an address and then the balance attribute you can see the balance in ether of a contract so with this line we're saying whoever called the withdraw function because whoever calls the function is going to be the message.sender transfer them all of our money so let's go ahead and try this let's deploy fundme and now let's fund this with a lot of ether so that we can see it we'll fund it with one whole ether so that we can see it go into the contract and get pulled out of the contract we'll hit the fun button and you'll see we're sending one whole ether into this contract now if we look at our balance it's gone down from 17 to 16. or if you're still at 18 it went down from 18. so let's try to get it back if we call this withdraw function now confirm once this transaction goes through we should get all of our ether back let's look at our metamask and boom indeed we have got all of our eth back however looking at this contract we can see that hmm well maybe we don't want anybody to be able to withdraw all the funds in this contract that seems like it might be a really bad idea maybe we only want the funding admin to be able to withdraw funds so how do we set this up in a way that only the contract owner can actually withdraw funds well we learned before that the require function can actually stop contracts from executing unless some certain parameters are met we can do the same thing here with require message.sender equals the owner but we don't have an owner to this contract yet so how do we get an owner to this contract the instant that we deploy it well we could have a function called create owner but what happens if somebody calls this function right after we deploy it well then we wouldn't be the owner anymore so we actually need a function to get called the instant we deploy this smart contract and that's actually exactly what the constructor does so typically at the top of your smart contracts you'll see a constructor and this is a function that gets called the instant your contract gets deployed you don't even need to do add function here we can literally just call it constructor because it's what constructs the smart contract so we'll make constructor public and whatever we add in here will be immediately executed whenever we deploy this contract so one thing that we could do is we could have an owner be set the instant we deploy the smart contract so in the top we could add address owner and in our constructor we could say owner equals message.sender because the sender of this message is going to be us it's going to be whoever deploys this smart contract we can even test this out in the javascript vm to be a little bit quicker because we're not actually going to be calling the fund or the getprice function for now oops let's also make this public so that we can interact and see this owner variable so now if we go to fund me we deploy this in the javascript vm we should be able to see who the owner of this contract is and it should be our address because this constructor function should have been immediately called the instant that we deployed the smart contract awesome we can see the owner of this smart contract is indeed our wallet because remember we're working with the javascript vm our wallet is these fake wallets that they kind of give us we can even try this with an injected web 3 with deploying this and the owner should be this ox 757 etc address let's go ahead and look at fundme see the owner and we do indeed see the owner is us okay great now we have an owner we can go down to our withdraw function and use that same require so we can call acquire message.sender equals equals owner equals equals is the way that solidity understands true false we're saying that message.sender has to equal owner now let's go ahead and try this and we'll try with the javascript vm again for speed reasons let's deploy this funding and if we go down here we try to call the withdraw function and it looks like it is successful because currently this is the address that deployed the contract and it's also the address that is calling withdraw however if we switch to a different account and call withdraw you'll see that remix actually freaks out down here it says uh oh something wrong happened and this is essentially the require statement kicking out if you want to try it with injected web 3 as well can absolutely do that too and remember the way to switch accounts in metamask is to either create a count right here or just switch like this and then we'll connect with account two so if i try to withdraw from this second account that didn't call the contract and i hit withdraw now it's going to give us gas estimation failed because the required statement is going to kick out but again if we switch back to account 1 and we call withdraw metamask is going to pop up and it's going to allow us to withdraw now obviously there's nothing in this contract right now so we're going to withdraw nothing but we can still call it it's going to do message.transfer 0. so this is great we can now require this withdraw function is only callable by the owner now what if we have a ton of contracts that want to use something like this they require the message.sender to be some owner or maybe it's more complicated than this is there an easier way to wrap our functions and some require or some other executable well this is where modifiers come in we can use a modifier to write in the definition of our function add some parameter that allows it to only be called by our admin contract modifiers are used to change the behavior of functions in a declarative way let's create our first modifier we'll call it modifier which is a keyword only owner and we'll add this require statement in here require message.sender equals owner then after this we just add an underscore and a semicolon what a modifier is going to do is it's going to say hey before you run this function do this require statement first and then wherever your underscore is in the modifier run the rest of the code so we could also do a modifier where the underscore is up here and then this is afterwards but but we want to run the require first so now what we can do is we can make this function withdraw payable only owner public and what's going to happen is before we do this transfer we're actually going to check this modifier we're actually going to run this require message.sender equals owner and then again where this underscore is that's where we'll add the rest of the function so again for speed reasons and since we're not actually going to be interacting with the chain link data contract we can go to javascript vm switch to funding deploy and we can call withdraw obviously we can call withdraw from our account but if we switch accounts and try to call withdraw we're going to get an error which is perfect because that means our modifier is working correctly awesome now we have a fantastically succinct fund me contract here the only thing that we're really missing is that when we withdraw from this contract we're actually not updating our balances of people who funded this so even after with we withdraw this is always going to be the same so we need to go through all the funders in this mapping and reset their balances to zero but how do we actually do that we can't actually loop through all the keys in a mapping when a mapping is initialized every single key is essentially initialized now we obviously can't go through every single possible key on the planet however what we can do is create another data structure an array something we're already familiar with so let's go ahead and create a new funders array that way we can loop through them and reset everyone's balance to zero we'll do an address array because it's going to be an array of all the funders addresses we'll make it public and we'll call it funders now when somebody funds a contract what we're going to do is we're going to do funders now whenever a funder funds this contract we can go ahead and push them onto our funders array so we can do funders dot push message dot sender now if somebody funds multiple times the funders array is going to be a little bit redundant but we're going to ignore that for now now that we have an array of funders when we withdraw everything we're going to want to reset this to 0. when we withdraw everything we want to reset everyone's balance in that mapping to 0. so we're going to do what's called a for loop a for loop is a way to loop through a range of numbers to do something so we're going to say 4 you and 256 funder index equals zero because we want to start with the zeroth index we're going to give it a max size to go to we're going to say the funder index has to be less than funders dot length dot length is how we get the length of our array and then we're going to say funders index plus plus this means that we have an index variable called funder index and it's going to start from zero this loop is going to finish whenever funder index is greater than the length of the funders every time we finish a loop we're going to add one to the funder index that's what that funder index plus plus does it adds one to the funder index and every time whatever code is in this for loop executes we're going to restart at the top and all we're going to do in here is we're going to grab the address of the funder from our funders array funders so the funder at the index in our funders array we're going to use this as the key in our mapping so we're going to take address to amount funded of funder and we're going to set it equal to zero so now our mapping is going to be all updated to people having xero funded in there we do have to do one more thing as well we have to reset our funder array as well now there's a couple ways to do this but a really easy way is just to set funders equal to a new array so we could do funders equals a new blank address array so all right it looks like we've got everything in here we need right away when we deploy this we are set as the owner we can allow anybody to fund whatever public good that we're doing and they have to fund it with the minimum usd value that we actually set whenever they fund we'll keep track of how much they're funding and who's been funding us we can get the price of the ethereum that they send in the terms of usd and we can convert it to check to see if they're sending us the right amount we have our only owner modifier so that we're the only ones who can withdraw from the contract and when we do withdraw everything from the contract we reset all the funders who have currently participated in our crowdsourcing application awesome let's see if everything works end to end so we're going to go to fundme we're going to deploy it we're going to confirm from metamask and remember if you're ever confused about what's going on or or something weird is happening in your transactions or your deployments you can always go into etherscan and read more about your transaction and what's going on now that our transaction has been deployed let's go ahead and just take inventory as what's going on we have our owner which is our address right here we have the aggregator v3 interface version which is version 3 which we can kind of ignore we have the price of ethereum in terms of usd with 18 decimals instead of 8. we have a function that allows us to get the conversion rate of any ethereum amount to its us dollar equivalent we have an array of funders which right now starts out as empty we have a mapping of addresses which also right now starts out as empty let's go ahead and try to fund this contract we'll use way just that we're always on the same page and we'll fund it with 0.1 away remember everything has 18 decimal places so if we want to do 0.1 we just do 17. so we can do one one two three four five six seven eight one two three four five six seven eight nine and that'll be 0.1 ethereum now we can go ahead and hit fund and we're going to send 0.1 eth to this contract great so if we look at the zeroth index of funders we can see that indeed we have funded this contract let's even have our second account fund this contract so all we got to do is switch to this contract in metamask we can go ahead and put point one eth back in here for value and hit fund now as you can see we're deploying this from account two let's go ahead and hit confirm funder at index zero is going to be our admin and the funder at index one is going to be our second account and if we go ahead and we add this funder in here we can see we've indeed sent point one ether with this account if we go back to our count one and put this in here we can see that that address also has 0.1 ether fantastic so let's try to be malicious let's try to have account number 2 actually withdraw all the funds in here let's hit this withdraw function uhoh the transaction has failed we're relentlessly malicious we want to send this transaction regardless so even though i'm not the admin of this contract i've gone ahead and still tried to send those withdrawal so what happens now we can see that remix is saying hey something went wrong and again if we look at ether scan we can see that there is a fail here since in our modifier we didn't give a reason here nothing shows up but we could have always put a reason in there and something would show up so all right let's go ahead back to the actual admin and now let's try to withdraw everything so if we hit withdraw now we can go ahead and confirm what should happen is everything in here should be back to zero and this array should be back to zero as well and if we watch our address we can see it literally just went from point four to point six because it got point one from the original funding that this account put in and the 0.1 that our second account put in so now if we look at funder 0 we can see it actually errored because it is now a brand new array and there is nothing at index zero if we try to see how much this address now is funded it's back down to zero awesome you've now learned how to deploy a relatively simple yet effective crowdsourcing application where users can fund and an admin can withdraw those funds to go spend them on things now we've been working with remix so far to start our smart contract in our solidity development journey remix is an incredibly powerful what's known as a web ide or an integrated development environment and in my opinion remix should always be the starting ground for anybody looking to start their smart contract journey because it is a wonderfully friendly way to really show what's going on behind the scenes and it's really easy to see everything we're doing with ethereum with chain link and with our smart contracts now it does have some limitations though it's really hard to integrate other parts of different projects it has some limited support for testing or custom deployments it's a little tricky to save files locally you need an internet connection to actually interact with it and it doesn't have python so in order for us to deploy test and automate everything about our smart contract development cycle we want to connect our solidity and our smart contracts with a more traditional programming language like python this way we can customize our entire development environment in any way that we like we're first going to teach you all how to work with what's known as web3.pi which is an incredibly powerful python package for doing everything that we want to do with smart contracts then once we learn some of the basics of web3.pi then we'll move on to browning which is a smart contract development framework built on top of web3.pi which makes our lives even easier however it's still really important to learn web3.pi first because this will teach you what's going on behind the scenes of brownie now for the rest of this course i'm going to be working with visual studio code which is an incredibly powerful text editor that will give us a lot of formatting and a lot of really nice tools to work with deploying and interacting with our smart contracts if you've already got vs code and python and your entire coding setup set up the way that you like it feel free to use the timestamps in the description to skip ahead to the next section you'll often hear people referring to this as vs code or visual studio code but just to point out this is not what you're looking for right in front of you here visual studio is a different application make sure you're on visual studio code if you want to be a total hardo and just work with vim or emacs or whatever else you want to do you absolutely can but i'm going to go through setting up visual studio code the way that i like it and if you guys want to follow along i highly recommend it because it's going to make your life a lot easier there's a link to download visual studio code in the github repository basically all you have to do is come to the site right here and you can hit this big download button it should recognize what operating system that you're on be it windows be it mac or some other operating system and if it doesn't you can go ahead and hit this little drop down and pick one there so let's go ahead and download visual studio code and open it up awesome once you've downloaded visual studio code this is approximately what you should be seeing there's a fantastic getting started section here where if you're brand new to vs code and you want to learn a little bit more quickly you absolutely can and we have some links as well in our github repository giving you a crash course in vs code if you want to learn more let's set this up though so it's going to be really friendly for us to be doing our smart contract development here so first we want to go to this extensions tab it looks like these little blocks thing right here and first we're going to look up python and you want to install this python extension right here this is going to make our lives a lot easier for interacting with python and doing a lot of things with python then you're going to want to go ahead and download this and install this solidity extension this is going to make formatting our solidity a lot easier now we want to download python if you haven't already so go ahead to python.org let's go to downloads and it should recognize what operating system that you're on and you can just go ahead and hit the download button and then follow the steps to download this i've already got it download so i'm not going to walk through this okay great now that we have python installed one of the other amazing things about vs code is you can actually open a terminal up inside a visual studio code the way you can open your own terminal if this is your vs code you can go over on this top bar to terminal and select new terminal and you'll see something that looks like this it might be a bash it might be a zch it might be a powershell there's a lot of different types of terminals that you'll be able to see by looking right here we can now test to see if python is installed correctly if we type in python space dash dash version we should get something that looks like this the exact version of python doesn't really matter here but ideally you're at least on python 3.8 if python dash version doesn't work you can also try python 3version now if neither one of those works we actually have a number of troubleshooting tips in the github repository for this course and oftentimes a quick google search on whatever error that you have you'll get a link which will lead you to the answer but if that google search doesn't lead to the answer then just go ahead and drop an issue or conversation associated with your issue on the github repo associated with this course in particular there are a couple of common errors that i've definitely seen a number of times so if you see an issue on your instance that matches something on the screen here definitely 100 be sure to check out those troubleshooting tips sometimes just installing some of these applications is really the hardest part of doing the entire coding journey here so please make sure you have python and vs code installed correctly before moving on and don't be discouraged if this doesn't work exactly the way that it should right away now if you're on a mac you can actually hit control back tick and it will toggle back and forth between having the terminal open and closing it i find this really helpful and i use it all the time instead of hitting the buttons a key tip for productivity is going to be using keyboard shortcuts instead of clicking around all the time you'll be much faster okay great we have python installed we have python and solidity extensions of visual studio code installed let's start working on a new project so in our terminal so in our terminal we can create some folder i've already created a demos folder here you can create one as well if you'd like by doing mkdir demos since i've already done it the file already already exists and then cd into demos you can type clear or if you're on a mac command k to clear the terminal now here's what we're going to be doing we're going to be working with simple storage again the exact same contracts but instead we're going to be using web3.pi so we're going to make a new directory inside of our demos folder slash directory called web3 pi simple storage and we're going to cd into this new folder right here now again all the completed code is going to be in our github and there's going to be a link to everything that we do in this folder in this github so you can always refer to that if you get lost and the next thing that we want to do is we want to have our visual studio code know that we're in this folder so we can go ahead and click this files icon and hit open folder and i'm just going to go to this web 3 pi simple storage and hit open and another vs code will actually pop up we can see on the left hand side here we have a folder this will show all the different files and folders in our web 3 pi simple storage directory let's go ahead and create a file dot sol we can right click on this area and select new file and do simple storage dot soul and then we can go back to our simple storage dot soul in remix copy everything and then paste it into here if you don't have it up remember you can always refer back to the github repository which will have it in there for you awesome now we have our solidity in its own file called simplestorage.soul you'll notice that some of the words are actually highlighted different colors this is known as syntax highlighting and it's due to the fact that we added the solidity extension in it makes reading this code a lot easier now this file is in here we'll see that we have this little dot here whenever you see this little dot this means that your vs code file isn't saved so we want to always save it otherwise when we compile or we go to write a script things might not work correctly so we can save it by going up to file and then selecting save or again you're going to want to learn how to do the keyboard shortcuts because you're going to want to hit save often for mac it's command s and for windows it's ctrl s now the other thing that you'll see is you get this red line here this is vs code's way of telling us it thinks that there's an error at this position so this is really just the extension being a little bit confused here and we can safely ignore this and normally when i'm coding i do just ignore it we're often going to be flipping back and forth between compiler versions so oftentimes this isn't really a helpful warning here but if it is really bothersome you could right click it and do something like solidity change global compiler version or we can go to code preferences settings let's close this so we can see some more things in here we'll look up solidity and we'll come to this solidity extension config what we can do then is scroll down and we can see solidity compile using remote version this will allow us to choose what version we want to compile with if we do 0.6.0 and hit save and go back to simple storage you'll see the red line is now gone while we have this up another really helpful piece that we can do here is we can add what's called a formatter so if we scroll down to solidity formatter you'll see that this enable slash disables the solidity formatter we can go from none to prettier then we'll also look up format on save and we want to make sure we have this editor format on save check marked what we can do then is we can come over to simplestorage.sol and maybe i've got some bad formatting in here we'll move over favorite number string name and put a whole bunch of new spaces in here or something now if i hit save it automatically reformats our file to look a lot nicer so to recap we want to turn on format on save and if you get issues with a red line under pragma solidity you can just change the compiler version in your settings here now while we're in here we're also going to go ahead and set up our python formatting as well so the first thing that we're going to do is we're going to install the black python formatter so we're going to open up our terminal here and whenever you install python it comes preinstalled with this package called pip to check to see if you have pip installed correctly run pip dash dash version now we can install the black formatter by running pip install black i already have it installed so it's going to be pretty quick for me then we'll come to our settings and we'll look up python formatting and we'll scroll down to python formatting provider you might have autopet bait or none in here you're going to want to change it to black this way whenever we save our python files now they will also get automatically formatted to be very readable and really nice and just to note for my demos in solidity i don't always have format on save for solidity i do have format on save for my python but i'm still going to highly recommend you have format on save for both your python and for your solidity anyways so how are we going to actually deploy this well this is where our python is going to come into play let's go ahead and create a new file on the left here and we'll call it deploy dot pi now let's go into this deploy.pi file and let's start actually figuring how we can deploy this in python and this is the part of the course where we start using python here if you're unfamiliar with python or a little bit weaker on python there is a fantastic free code camp course that goes through all the basics of python if you want to learn more i definitely recommend checking it out however we are going to walk you through all the scripts that we write anyways so don't be afraid to just jump in and follow along with what we're doing here even if you have no experience so the first thing that we're going to want to actually do is read this simple storage solidity file we need to get this into this deploy script so that our python file knows what it's going to deploy so how do we do this well we're going to type with open quote dot slash simple storage dot sol comma r as file simple storage file equals file dot read now what is this actually doing well it's saying that we're going to execute some code inside this indented area after the colon and then once this code is finished we're actually going to close this file because right now we're opening it we're going to close it once it's done the file that we're going to open is going to be this simple storage.sol which is located right here in this same directory that we're in we're going to only read from it and we're going to call it file and then we're going to read all the contents of this file and place it in a variable simple storage file so then we can go ahead and write a print statement print simple storage file and if you hit save here you'll see that it automatically gets formatted which is really nice if you want to run black yourself you can just type black dot and it'll automatically format all the python files in your folder here you'll know that you're doing it right if you add a whole bunch of new lines and then save it anyways enough on formatting let's head on down to the terminal and let's call python deploy.pi and we can see our terminal printed everything in simple storage file which is perfect now our python script has what it needs to actually get started working with our solidity now something you'll see i do a lot is i save a lot and if you're looking for some keyboard shortcuts you can always do command p add a little bracket here and look up keyboard shortcuts reference and click this it'll bring you to this keyboard's reference page based off of what operating system that you have all right great so now that we can actually read from our simple storage.soul file we actually have to compile it because remember back in remix every single time we did anything with our files we had to compile them first so we need some compiler in python luckily there is a fantastic python package called pi silk x that does exactly this now i also want to point out though that pi silk x is actually a fork of this package called pi silk now you can still use pysol however i'm going to highly highly recommend that you use pi silk x instead as pike sulk x is a lot more actively maintained than ethereum pixel we can install it with pip install pi sulk x we could even hit this little copy button move back on over here paste it in and hit enter again i've already installed it so it's pretty quick for me the way that we can use it now is by importing it into our python here so we'll say from sulk x import compile standard compile standard is going to be this main function that we actually use to compile this code so let's go ahead and compile our solidity we're going to save our compiled code to a variable called compiled soul this is going to be equal to us calling this compile standard function but we're going to add a lot of variables and a lot of parameters into this function here first we have to add is a language which in this case is solidity we're going to add in some sources which we're going to say our sources are going to be simple storage.soul and it's going to have some content which is equal to this simple storage file variable that we made oh excuse me this all has to be in a bracket piece as well and see if i hit save here it auto formats which is really nice and another quick tip you can see how even my brackets are highlighted in these fun colors if we go down to extensions and look up bracket you can add this bracket pair colorizer which will help make the brackets look a little bit nicer kind of as you see here you can go ahead and install that as well anyways then we'll add some settings and a lot of this is a little bit lower level stuff than what you're really going to have to know or use so i'm not going to go too deep into everything that's actually going on here for now but in our settings we're going to choose an output selection which is going to choose what we output when we compile this we do a little star here and in the star we're going to do another star we're going to choose our output list we're going to get an abi out that's incredibly important which we've talked about before we're going to get some metadata we're gonna get an evm dot byte code we're gonna get an evm dot source map that's pretty much it again i'm not gonna go too deep into what this output selection and what these settings are actually doing but if you want to learn more you can go to the home page of pi sulk x scroll down to the documentation section and read more in the docs on what you can actually put and all the different features that this actually has the last thing we're going to do is we're going to add a sulk version or solidity version we're going to say sulk version equals and then we'll choose the version that we want to use so we'll put in 0.6.0 and then what we should be able to do is print out this compiled soul and we'll see just a whole bunch of really really low level stuff so let's go ahead and run this we'll run python deploy.pi and you'll see we get this massive object here which has a whole bunch of basically unreadable pieces but this is a lot of the lowlevel code that actually gets compiled whenever we use the compiler in remix or now in python remix actually does the exact same thing once we compile something on remix you can actually copy the bytecode if you hit this little copy button and copy the bytecode and come back to your vs code and create a new file a keyboard shortcut to create a new file is command n and we paste everything we can see there's a whole bunch of stuff in here these op codes are the low level code that our contract is actually doing that actually governs how this code works this is what our written code is getting compiled down to so solidity can actually read it and understand what's going on you'll also see this thing called abi which is in remix and we're even going to output it right here we have this abi thing now in remix if you hit copy the button on the api come back create new file paste it you can see we have this long json object this is that application binary interface that we've talked about so much you can see that it's actually describing all the functions and variables so for example we have a function called add person and it takes two parameters a name and a favorite number so we have this input section for the function and we have this section that describes what the function can is actually doing so the name is ad person it doesn't have a return type it's nonpayable and it's a function and we can see that for pretty much everything in here this is the lowest digestible way to say hey here's where all the functions are here's what the parameter types are here's what the return types are going to be and everything like that so we're going to close it out for now though so this is fantastic we've now compiled our solidity typically i usually also like to output it and print it out to a file as well so to do that we'll do with open compiledcode.json and this time instead of reading we're going to write and we'll call this as file as well instead of doing file.write we're going to do what's called a json.dump compiled soul file we do need of course to import json also just a note i know it says we're using sulk here but please use sulk x still i ended up filming a little bit of both versions so i did a little bit of a mix and match but please use sulk x even if you see seoul what this line is going to do is it's going to take our compiled soul jason variable and just dump it into this file here but it's going to keep it in the json syntax so it's still going to be json e so now if we run python deploy.pi we'll see we have a new file in here called compilecode.json the other reason that i wanted to do this was because if i hit control s it actually formats this into a readable way now again we can go into these settings here we can look up json and we can do enable json formatter and this will automatically make it so that we format this json so it's a lot more readable again the reason i like to output this is because this abi is so important and we're going to use it so much that i like to kind of be able to see it and and read through it really quickly the rest of this lower level stuff like evm and byte codes and op codes we don't really work with so much however as you learn more and more about solidity you'll probably see more and more of opcode so if you really want to learn a lot of really lowlevel stuff look into opcodes but for the purpose of this tutorial we're not going to be going too deep into it okay awesome so we've compiled our solidity we've even stored our solidity code to this compiledcode.json file now what do we do we probably want to deploy it and test it out so how do we actually do that well first we actually have to get the bytecode we need the bytecode of the file so that we can actually deploy it so we're going to do bytecode equals compiled soul contracts simple storage dot sol simple storage evm white code object all right great there we go so now we have our byte code we also need to get our abi so we need to get the api so what we're doing here when we're typing in all these words like contract simple storage simple storage is we're walking down the json here so when we say we want to get the byte code in this compiled solidity json we want to go to contracts simple storage symbol storage evm byte code so contracts inside this contracts json you got to go to simple storage inside this simple storage dot soul there's another simple storage inside that there's an avi but that's not what we want we want the evm so we're going to scroll down we're going to get the evm then what do we want then we want the bytecode great and then we want the object so this is the bytecode of our contract it's the really low level stuff that the ethereum virtual machine or the evm is going to understand now we also need the avi when we deploy this to a chain this is what we're going to need we need the byte code and the abi the abi we can of course get from this kind of same method here so to get this we can do abi equals compiled soul same thing contracts simple storage dot soul simple storage and as you can see we're right here and then we can just grab this api object avi and we can even do print api we'll do python develop.pi and indeed our abi is printed here awesome so now that we have our two main pieces to deploy this now all we have to do is deploy it but the question then becomes is where are we going to deploy it to which blockchain are we going to deploy to in remix when we were first playing around we were using a javascript vm or a fake or a simulated environment we absolutely could and we absolutely will learn to deploy this to a test in because that's going to be the same way that we're going to deploy to a mainnet but before we do that we should learn how to deploy this on a simulated environment or something similar to that javascript vm so it's much faster and easier to test things and this is where ganache is going to come to the rescue ganache is a simulated or a fake blockchain that we can actually use to deploy our smart contracts to and have it interact like it's a real blockchain ganache is going to allow us to spin up our own local blockchain and it'll look something like this now the user interface is really nice because it allows us to kind of do this oneclick blockchain to create our own local blockchain that means that this blockchain isn't connected to any other blockchain out there but it'll act like a blockchain but it'll be a lot faster than us having to interact with a testnet and we control the entire blockchain because it's only one node we're the only node so ganache great way to test things quickly now we're going to mainly we're working with the user but i'm also going to show you how to work with the ganache command line you can really use either one depending on what you want to do but a lot of the tools actually have builtin ganache command lines so it's definitely really useful to learn that as well so again ganache is going to be our simulated environment here so what we're going to do once we get into ganache we can just go ahead and hit quick start this will automatically upload and get started with our own local fake blockchain you can even see it gives us some accounts this should look pretty familiar it should look very metamasky right we have an address here and each one of these addresses has a private key in your ganache you can go ahead and just click the key and hit show keys and it'll show you the account address and the private key but of course these are for development purposes only each one of these accounts has a balance associated with it we can see a mnemonic or your secret phrase you can see blocks transactions and a whole lot of other really useful features here and it even tells us how to connect to this blockchain and these are the connecting features that we're going to want to use let's learn how to connect to this ganache blockchain from this user interface first and then we'll learn how to do the command line version this is when we finally start working with web3.pi you can just do pip install web3 and now we can start working with web3.pi right at the top a little confusingly we're going to do import web3 from web3 whoops and this should be from web3 import web3 sorry about that now to connect to this blockchain we choose what's called an http provider if we look at this ganache instance we have this rpc server which has this url http 0.0.0 this is the url that we're going to use to connect to this blockchain in remix we're actually using our metamasks directly to connect to the blockchain however we want to connect directly to our simulated our fake blockchain right here so what we're going to do is we're going to do w3 for connecting to ganache w3 equals web3 web3.http provider of http 0.0.0.0 and it was on port 845. port 845. now with everything that we show you you're probably going to want to get really familiar with the documentation because even after being a pro you're going to want to use it more and more if you want to learn more about other providers you can go to the providers page of the documentation the next thing that we're always going to need as well is we're going to need the chain id or the network id what is the id of this blockchain and for ganache it's one three three seven supposed to be a funny leat reference so we'll do chain id equals one three three seven now we're also going to need an address and address to deploy from we can go ahead and grab one of these fake addresses in here to work with similar to how in remix when we were working with the javascript vm we were given a bunch of fake addresses we're doing the same thing but with ganache and then we're also of course going to want a private key we need the private key of course to sign our transactions so we'll do private key equals this now just note whenever you import a private key in python you need to add an ox to the front python is always going to look for the hexadecimal version of the private key awesome now we have all the parameters that we need for interacting with and connecting to our ganache local chain it's time to finally deploy our simple storage.soul contract let's do it so the credit contract that we're going to deploy with web3.pi we're going to do simple storage we're going to call this variable w3 dot f dot contract and we're going to give it abi equals abi and byte code equals byte code great does this mean we've deployed it well no this just means we have a contract down so we can do print simple storage and you'll see if we run python deploy.pi we'll see we have a new type here class web3.utils.datatype.contract this is another type that if you want to learn more you should definitely check out the web3.pi documentation so we have a contract object awesome how do we actually deploy this well we need to actually build our transaction because again whenever we interact with the blockchain whenever we make a state change and in this case we'd be deploying a contract we're going to make a state change so we first need to build a transaction sign a transaction and then send a transaction and to do that we need to talk about that nuns thing again remember way back in our blockchain demo when we used a nuns to solve the answer to that really difficult mining problem well the definition of nuns is just a word coined or used for just one occasion and in cryptography it's an arbitrary number that can be used just once in a cryptographic communication so this nuns that's used to find the answer is going to be different from another nuns that we're actually going to need to make our transaction see if we look at our meta mask and we look at our activity and we look at one of the transactions we've made recently on etherscan if we scroll down we'll see nuns here as well this nunce is the number of transactions that our account has actually made every time we make another transaction our transaction is hashed with a new nuns this is what's going on behind the scenes with our transaction and we need this to send our transaction we can actually get our nuns by just grabbing our latest transaction count get the latest transaction we can do nonce equals w3 dot eth dot get transaction count and we'll put in my address this will give us the number of transactions and it'll effectively give us our nuns we can even test it out with a print python deploy we can see we can see that the answer is zero because on our local blockchain this address that we're using hasn't been used before we can even go to the transactions tab we can see that there are no transactions that have ever occurred on our local blockchain now to deploy this contract we need to make a transaction remember everything that we do every time we change the state of a blockchain we're going to do it in a transaction let's create a transaction object to do this we can do transaction equals symbol storage which again is this contract object dot constructor dot build transaction now as you might have pointed out our simple storage.sol doesn't actually have a constructor every contract technically has a constructor this one's is just blank we're not telling our simple storage.soul to do anything we saw back in our fund me example that the fund me example does have a constructor so now we want to put in some parameters for the transaction in web3.pi we always have to give at least a couple of parameters we always have to give the chain id which we already got from above which is one three three seven so we can just do chain id we need a from address in this case my address and then we need a nuns which in our case is just nuts great now we have a transaction object let's even print this out and see what it looks like whoa what's this we can see there's even more parameters in here than just what we made so we have value which is the ether or the ethereum that we're going to send we have gas we have our gas price which we could arbitrarily set if we'd like we have the chain id we have from address we have the nuns and then we have this giant data object and then two is just empty because it's sending it to the blockchain this giant data object here is encompassing everything that's happening in this simple storage dot sol now that's just a transaction and anybody could actually send this transaction as long as it's signed by them so we have this transaction but we need to sign it from somebody since we're sending it from our address our private key is going to be the only key that's going to work to sign this remember back when we were talking about public and private keys we right now have a message that is defining how to deploy simple storage but it's not signed yet so we're going to need to use our private key to sign it to create this unique message signature that we're the only ones that can create the private key but anybody else can verify that it was us who signed it so now signed transaction equals web3 dot eth dot account dot sign transaction and the parameters it takes are going to be transaction and then private key we're gonna say the private key equals private key because above we've actually gone ahead and added our private key in here now guys a really really important note about putting a private key in your code this is really bad practice if you push this to source or you push this to github somebody else can see your private key and steal all your funds so we don't want to hard code our private keys in our code like we're doing here so let's take this time to talk about environment variables and how to set them environment variables are variables that you can set and that we set in our terminal and in our command lines the following is a way to set an environment variable in macos and linux only don't worry we'll show a way to make an environment variable in windows as well you can set an environment variable by running something like export private key equals and then adding whatever variable that you want now if you type echo dollar sign private key this variable actually shows up to set environment variables with windows the process that we're going to do is actually a little bit different i've left a link in our github to actually set environment variables in a windows setting and we've left a couple of really helpful links for working more with environment variables you should definitely check them out it's important to note that this export method that we're doing here for creating environment variables only works for the duration that our shell is live so if we were to close out of our shell and then reopen it our environment variable that we set would be gone so we'd have to rerun that export command we're gonna show you a way to set environment variables so that you don't have to keep doing that now it's also not great to have in plain text on your computer however it's a lot better than hard coding it into our script here now remember if you're using an account that has real money in it which i highly recommend you do not do don't send this environment variable or this private key or any of this code anywhere because then people can steal all your funds once we move to brownie we'll show you a more effective way for private key management but for now be cautious here but if you followed along and set up a brand new account that has no real money and only test that money in it then great who cares because it's test and it's fake money anyways i think i've talked about it enough anyways let's get back to it we can actually access this environment variable in python using os.get env we just need to import os and now we can access our private key in our script without actually hard coding it in let's see what happens if we do print private key python deploy to pi you can see our python script was able to pull our private key from our environment variable the other thing that we can do is create a dot env file a dot emv file is typically where people store environment variables it's important to not push these to source if this is what you're going to do in this dot envy file in python we can just do export private key and then same as what we did before add the 0x at the start and then private key so we could put 100 environment variables in here export some other var equals seven if you're going to do it in this way please please please always set a dot git ignore and make sure dot env is in here this will help make it harder for you to accidentally push your env folder or your emp file to github python actually has a way of loading directly from a env file without having to export our environment variables or run source.env or export or really anything and we can do it with this python.env package if we close our shell and then reopen it if we run echo some other var we're going to get none here and in fact if we run python develop.pi when we print this environment variable we're going to get none however we can use this.env to have it pulled directly from our.emv so we just do pip install python.env i've already downloaded it so it just says requirement already satisfied and then what we can do at the top of this we can do from dot env import load.enb and we can run a load.enb function right at the top this load.env looks for this.env file and automatically imports it into our script so if we run this now you'll see that the environment variable was successfully imported into our script and now we can use it so let's let's use it for example with our private key private key equals os that get private key now we can even print it out just a test we'll run our script and awesome we can see our private key is being successfully pulled in and we didn't hard code it into our application all right let's get back down to our signed transaction here now let's go ahead and print this out and take a look at what this looks like now we can run a script and great what we see here is an example of a signed transaction remember this is exactly what's happening when we were looking back at public private keys we are signing a transaction that is actually deploying a contract to the blockchain that anybody can easily verify all right so we finally have our signed transaction now we want to send this to the blockchain so it actually can deploy let's send the signed transaction we can do transaction hash equals web3.eth here's a little helpful tip if you see this little box underneath with suggestions show up and you just hit tab it'll auto complete the rest of your text here that's send raw transaction and we'll give it our sign transaction dot broad transaction this will send our transaction to the blockchain now if we look at our local ganache and we look at transactions right now it'll be empty but let's see what happens when we run this script okay so we didn't print anything out but if we go to our ganache we can see that a transaction actually did go through it was from the address that we put in here we created a contract at this address this is how much gas it used and this is how much value was sent with it we can even click on it to see more information about this now this is the other advantage of doing this locally is that the transaction automatically went through we've sent our first transaction to a local blockchain and this transaction is deploying a contract great work you can already see how much faster this is than working with a test net one other thing that's really good practice whenever sending a transaction is we wait for some block confirmations to happen so we can do transaction receipt equals web3 dot eth wait for transaction receipt txhash this will have our code stop and wait for this transaction hash to go through awesome so i just ran it again and if we go to transactions we can now see that there are two transactions here and our code waited a little bit longer for this one to complete so of course we've deployed a contract but how do we actually interact and work with the contract let's start doing that so when working with contracts and we're working with on chain whenever we work with a contract we always need two things we need the contract address and the contract abi often times if you're looking for a specific abi of a type of contract you can usually just google it so we need to make a new contract object to work with contracts let's go ahead and create this simple storage contract so we can actually interact with it so we'll do simple storage equals dot w3.eth.com now we need our address which we can get from ganache but that might be a little bit hard to always be checking the blockchain for a transaction it's actually also in this transaction receipt address equals transaction receipt dot contract address and then since we've compiled this we also have our abi already abi equals abi sometimes you'll see people have a file called abis.pi or abis.json or something like that and they'll load apis in directly from there and great now that we have the address and the api we can start interacting with this contract exactly as we did in remix so let's do a print statement to get that initial value that is returned from our retrieve function remember it should be initialized to zero so if we do print simple storage dot functions dot retrieve let's see what happens here huh what's this we get this function retrieve bound to in these parentheses here so what's going on when making transactions in the blockchain there's actually two different ways that we can interact with them we can interact with a call or we can interact with a transact when we use a call this is just to simulate making the call and getting a return value calls don't make a state change to the blockchain and it's similar to how in remix we would call these blue buttons and nothing on the blockchain would actually change we can actually also call these orange buttons or these nonview functions and just not actually make a state change remix defaults these blue buttons to be calls and these orange buttons to be transacts in python we can actually pick which one we want to do a transact a transact call is when we actually make a state change and this is when we actually have to build a transaction and send a transaction you can always just call a function no matter what that function is but just keep in mind you won't make a state change you can also always transact on a function even if it's just a view and this will attempt to make a state change something like retrieve even if we transact on it it won't make a state change so for something like retrieve where we don't actually want to make a state change we just use the call function so we'll just do dot call now if we try to run this you'll see we do get the zero because now we're actually calling this transaction awesome so now we have our initial value for our retrieve function let's keep going let's try to update this favorite number using this store function this we'll just keep in mind is our initial value of favorite number we know that this store function is orange and we'll actually make a transaction but if we wanted to we can even just use call on it we'll do simple storage dot functions that's store we'll put that 15 in here call let's see what happens when we send this you can see it returned a blank that's because this store function has no return type if we give this returns unit 256 and then we say return favorite number and now we go back here and we run this again you'll see now that we get a 15 back if we go to ganache you'll see that we keep making a whole bunch of different contracts but none of these are contract interactions that's because when we call a function we just simulate working with it if we call retrieve again right afterwards you'll see that it's still zero it's because calling is just a simulation now let's delete all that so let's actually build a new transaction to actually store some value into this contract since we want to make a transaction we got to go through the same process as when we deployed this contract let's first create a transaction called store transaction equals simple storage dot functions about store and we'll give it some number in this case 15 and then we have to do dot build transaction and we'll put those same pieces in here from before we're going to have chain id be the chain id we're going to need from give me my address nunce is going to be the nuns plus 1. we're going to need to do nuns plus 1 because we actually use this nuns already when we create our initial transaction remember a nuns can only be used once for each transaction so this transaction is going to have to have a different nuance than the nuns we use to deploy the contract now that we have the transaction let's go ahead and sign it we'll do signed store tx and we'll do web3 that eath dot account dot sign transaction store transaction and then private key equals private key and we'll go ahead and save then of course we need to send it so we'll do transaction hash equals w3.eth dot send raw transaction signed store transaction dot raw transaction and let's grab that transaction receipt again by doing transaction receipt equals w3 dot eth dot wait for transaction receipt and actually let's call this send store tx that way for receipt send store tx awesome it looks like we're following the same steps here as we did above we created the transaction we signed the transaction and then we send the transaction down here we create a transaction we sign the transaction we sent the transaction and then we waited for the transaction to finish so let's run this all right great we still have this print function printing out the current value of retrieve let's go over to ganache and see if there's anything different here there is instead of all these contract creations here we now have a contract call we can see there's some transaction data that was sent a different amount of gas same gas prices however this actually updated and sent the transaction to our blockchain now if we call this retrieve function again this should print out our newly updated value which in this case was 15. let's go ahead and run python deployed up high and we can see it started at zero and then it turned to 15. awesome we've made our first state change to a contract that we've deployed on our local blockchain great work sometimes it's nice to put some lines in here to tell you what's going on to make it a little bit more clear so i'll put something like deploying contract dot dot right before we deploy our contract after we do it i might do deployed then right before we update our contract we'll print out something like updating contract and then right after it's done maybe something like updated now if we run this now you'll see as this goes along we'll get these things printed out saying deploying contract contract deployed updating contract updated this will make those moments when waiting for these contracts to actually finish a lot easier you're doing fantastic so ganache user interface is really nice because we can see a lot of things that are going on here however it's a little tricky to do a lot of programmatic stuff oftentimes engineer will use what's called a command line interface of ganache instead of the ui so we're going to go ahead and close this out and we're going to use the ganache cli instead of that user interface that we just saw and this is what and this is what brown is going to use on the back end when we move to brownie let's learn how to actually do that so in order to use the ganache cli or command line interface the first thing that we need to do is download node.js yes i know this is a python video however we do need to install node.js to work with the ganache cli you can come to this download page and choose your operating system and download it accordingly we will link to a video showing you how to do this in the github you'll know you've done it right if you can run node dash version in your command line and you get a version it might be 12 might be 14 might be something else depending on what version you downloaded next we're actually going to install yarn yarn is a package manager similar to pip and will allow us to actually download pieces and packages like the ganache cli from the package repository we can install it with npm install dash dash global yarn and you'll know you've done it right if you can run yarn dash dash version in your command line and you get the version outputted here then we want to install the actual ganache cli we're gonna be installing it with yarn so to install this we're gonna yarn global add ganache cli this will install our ganache cli as a global command in our terminal we can test to see if we've done it right if we can run ganache cli dash dash version perfect we now have the ganache cli let's spin up a ganache chain with the cli if you have your ganache ui open right now please close it otherwise it'll conflict so to run a local blockchain from the command line all you need to do is run ganache cli and the node will start running directly in your terminal if you scroll up you can see a lot of familiar pieces we see the available accounts just like on the ui these are the different addresses and then we see a whole bunch of different private keys this ganache spins up with a bunch of random addresses and random private keys if we wanted to always spin up with the exact same private keys so we don't have to update our private key every time we can do ganache cli dash dash deterministic this way we'll always get the exact same private keys and the exact same addresses you can check out the documentation to see a bunch of other flags that you can use to run this and you can see it's listening on 127.2 127.0.0.1 is also known as the loopback address or localhost now to work with ganache in the command line all we need to do now is update our private keys and our addresses let's also update the http provider since now we're going to be looking at the loopback address for my address we'll scroll up to this top address here and we'll place it in for our private key we're going to copy this and put it into our dot emv file it already has the ox at the top here great now let's open up a new terminal you can open up a new terminal by hitting this plus button here and you can flip back and forth by hitting this drop down and flipping back to the ganache terminal now let's go ahead and run python deploy.pi we can see the exact same output as we got when working with the ui and if we flip over to the command line we can see we've made a whole bunch of different calls to our blockchain each one of these calls is a specific json rpc call to our blockchain that we're making to interact with it we can see information about the transactions that we send this one creates our simple storage contract this one updates our simple storage contract and great you now know how to work with the ganache cli and the ganache ui fantastic so how do we actually deploy this to a test net or a real network we were working with remix all we had to do was switch to injected web 3 and we used our meta mask as our blockchain connection well in our script here we don't have metamask natively with our script so we need some way to connect to the blockchain we can see that when we're connecting to our own local blockchain we just use an rpc url that connects to our local blockchain to connect to a test net or to a mainnet we can actually do the exact same thing all we have to do is swap this out with the url that connects us to a mainnet or a test app we can also run our own blockchain node similar to how we're running our own local blockchain node we can run a node that actually connects to a real blockchain however it's not always practical or really easy to do this so sometimes we want to use an external or a thirdparty client that actually will run a blockchain for us let's learn a little about inferior inferior.io is an application that will give you a blockchain url for you to connect with for you to run whatever you want to run and you can get started for free let's go ahead and register then we just check our email confirm email address and awesome now we're inside of infira there's a couple other services out there that you can also check out like alchemy which is another fantastic blockchain as a service platform fura is a freemium service it starts out as free if you make too many api calls or too many calls to the url they'll start charging you but we can create a project for free for now let's go ahead hit the ethereum tab hit create project we'll call this free code camp brownie hit create now we'll have a whole bunch of project keys and project secrets we also have this endpoint section as well this is how we're going to be deploying to the different networks we can see we have an ethereum mainnet connection as well as robson coven rink b and gorilla testnets there's also polygon in here as well since we want to test and deploy to a ring b chain we can go ahead and move to ring b and then we can copy this url back in our application all we have to do is swap this out for the new url we also have to change the chain id our address and the private key if you ever are confused as to what is the chain id of the chain that you're working on you can always check this chain id dot network or you can usually ask somebody let's look up ring b we see the chain id is four so we'll grab four and we'll place that in our script now this address and the private key that we gave it now this address and the private key that we gave it aren't going to have any testnet ring be in them so we need to go in our metamask and grab the address place it in for address and then account details export private key type in our password and grab the private key go into our dot emb file leave the 0x and replace the rest with our private key since i have my private key stored as an environment variable i need to then run source.env so that my private key is now updated the reason we're using this is because again since we're making transactions to a testnet we need some test and eth alright so now we have everything updated for deploying to rinkeby let's go ahead and run this now as you can see it's going a lot slower this is because we actually have to wait for the contracts to get mined and for everything to happen on the test net deploying to a tesla will result in nearly the exact same experience that you'll get when deploying to an actual main net so it'll take a lot longer but you can see we got the exact same responses here now if we take this address and we go to the rink be ether scan we can verify what just happened we can see that 38 seconds ago we made this transaction and then 23 seconds ago we made this transaction we can look at all the different details of this transaction that we just made from our python script we can see it even tells us we created a smart contract and then we made this call which called this store function on this contract we've learned a lot so far this is fantastic now is a perfect time to take a break and take a quick breather and reflect back on what we've just learned we've learned a lot about python deploying to our own local blockchain deploying to a test net and deploying to a mainnet working more with private keys creating transactions signing transactions and then sending transactions now as you can see there's going to be a lot to actually managing all the contracts that we work with having to write our own compile code our own storage code is going to take a lot of work and what if we wanted to interact with one of the contracts that we deployed in the past well we'd have to keep track of all those addresses and manually update our address features here with an address maybe we didn't want to deploy a new contract every single time maybe we want to work with a contract that we've already deployed what if we want to work with a whole bunch of different chains what if we want to work with rink b and mainnet and our own local network there seems to be a lot to manage here and we still haven't even talked about writing tests this is where brownie is going to come into play brownie is currently the most popular smart contract development platform built based on python it's used by d5 giants like yearn.finance curve.phi and out each having billions of dollars currently locked in value and the reason that we learned a little bit about web3.pi first is because brownie heavily relies on web3.pi so let's do all this again but in brownie and we'll see how much easier it is to actually interact with in our shell let's go back one directory and let's make a new one we'll call it brownie simple storage now another really cool trick that vs code has is instead of us having to go to file and open up this folder in this explorer here what we can do is we can type code and then type the directory that we want to work with in our case this directory so we can just type code dot and we'll get a new vs code popup inside of this brownie simple storage folder let's get learning about brownie and this is where you're going to spend the majority of your time move forward brownie is incredibly powerful and makes our lives fantastically easier so get ready to learn one of the most powerful tools in the smart contract developing ecosystem let's go ahead and open up our terminal and let's get started installing brownie it's recommended to install brownie via pipex pepex installs brownie into a virtual environment and makes it available directly from the command line once installed you'll never have to activate a virtual environment prior to using browning which is really good to install it with pipex we can go ahead and run python dash m pip install dash dash user pipex once we've run that we can then run python3m pick at pipex in surepath then we'll want to close the terminal by hitting the little trashcan and then reopen it and then we just need to run pipex install f brownie i've already got it installed so that's why we see this here and then just one more time we're going to close and reopen the terminal you can tell you have brownie installed correctly if you run brownie dash dash version and you get some output that looks something like this or you just run straight up brownie and it'll output a bunch of commands that we can run let's create our first brownie project we're going to be using the exact same simple storage code that we just went through except for we're going to use it in brownie this is going to make our lives a lot easier when working with simple storage to create a sample folder with everything we need with brownie we can just run brownie init and we will get a new brownie project initialized in the directory that we're currently in if you type ls you'll be able to see all the folders that are created or you can just see them on your side panel in vs code let's talk really quickly about what each of these folders is going to do the build folder tracks a lot of really important lowlevel information it's going to track any interfaces that we're working with or deploying it's going to keep track of all of our deployments across all of the different chains so we no longer have to manage that ourselves and it's going to store all the compiled code remember how in our simple storage code we actually saved everything to this compile code.json well brownie is actually going to do all of that for us into this contracts directory so we can always reference it later this contracts directory outside the build folder is where we're going to put all of our contracts brownie knows to look inside of this folder when looking for new contracts to compile deploy or anything else interfaces is where we can save and store different interfaces remember how when we were working with chain link working with interfaces makes it really easy to interact with a blockchain application reports are to save any type of report you run scripts or we can automate tasks like deploying calling different functions or really anything we want and then we have a test folder which is incredibly powerful and we're going to be using a lot we also have git attributes and get ignore which are helpful when working with version control like git so let's go ahead and start working with brownie and really understand what's going on here so let's go ahead and add our simple storage contracts to the contracts folder so in here we're just going to make a new file we'll call it simple storage.soul and i'm just going to copy and paste the code i have from the simple storage that we've been using this whole time let's go ahead and save that with command s okay great now that we have our contract in here we can already start working with brownie and even compile this code without even having to write or work with our own compiler all we need to do is run brownie compile brownie will automatically read the version of solidity and then store all of the compile information in this build folder so if we go to contracts we can see we have a simple storage.json and there's a lot of familiar pieces in here for example we see the abi opcodes section which is the low level language we'll see a pc map and we'll see a lot of useful information and great obviously deployments and interfaces are still empty so great we've already compiled our smart contract so why don't we actually deploy this to a blockchain to do this we do have to write a script which will allow us to do whatever we want so we're going to create a new file and we're just going to call this similar to last time deploy dot pi this is where we're going to define working with and deploying our code brownie can run scripts by running brownie run in fact if you want to take a quick minute to familiarize yourself with all the different commands that brownie has just run brownie and you'll see we can do a lot of different things we do brownie init which will create a new brownie project we will do brownie bake which allows us to pull from the brownie mix which we'll talk about later we can compile we can go into a console test run we do a lot of wonderful things in here if we do brownie run it'll run a script for us and we can define that we want to run this deploy all we have to do is add a def main so def in python is the way to define a function we're going to call this function main and for now let's just say print hello and we can run brownie run scripts deploy and as you can see it automatically does this launching thing so brownie defaults to always working with a local ganache cli blockchain it's running the exact same command that we ran earlier and it has a bunch of different flags like accounts 10 a certain hard fork a certain gas limit etc so at the beginning of all of our scripts if we don't give brownie a network to use it'll spin up a local ganache and at the end of the script it'll tear it back down typically what i like to do is actually put all the logic of our deployment in its own function def deploy simple storage and we'll do pass for now and then our main function we can just call deploy symbol storage now in order to deploy our contract let's look back at our web 3 pi version of deploying this and see what we did so first we compiled it great brownie does that automatically then we jumped into a file great brian does that automatically we got a byte code and an abi great brand does that automatically we added a local blockchain to use great brownie automatically spins up a local ganache we'll learn how to do test nets in a little bit aha we do need an address though and a private key so how do we actually get our private key get our account into brownie brownie has an account package that actually natively understands how to work with accounts and we can import it into our script here so we can do from brownie import accounts and with this accounts keyword we can add an account a number of different ways if we're going to work with our local chain as you see here the ganache cli will spin up 10 fake accounts for us and brownie automatically knows that we can work with that account so we can do something like account equals account zero and then just do something like print account so we're going to take the account that's spun up at the zerowith index because this accounts object is just an array so if we run this now brownie runs scripts deploy it's going to spin up us an address and a private key that we can just work with without having to define a private key or do anything it does all of that for us which is fantastic we do of course still want to know how to add our own private keys so that we can work with the test net so this is great and works when we're working with a development network or working with brownie's automatic ganache cli if we want to work with a test net though we have to do something else another way to add your accounts in brownie is to use the command line and actually add them natively into brownie we can do brownie accounts new and we'll give it a name free code camp account this will then prompt us and say enter the private key that you wish to add let's go ahead and grab our private key from metamask account details export private key put your password in grab the private key and then we just add ox and paste it in brownie will actually password encrypt your private key in this way so we'll give it a password and now we have a new account natively integrated into brownie to see it we can do brownie accounts list and you'll see that we have a free code camp account with this address and also a testing account i made this a little bit earlier we can get rid of it by running brownie accounts delete testing helpful terminal tip time so if you hit up or down on your keyboard you can actually toggle through the history of the commands that you've written so if you hit up it'll actually bring you to the most recently run command which can allow you to run previous commands a little bit faster and if we run browning accounts list again we'll see it's now just free code camp if we want to work with this free codecamp account that we've added to brownie via the command line we can get it with account equals accounts dot load free code camp account and then we can do print account let's run this script again this time when we on the script it's going to ask us for the password we need to enter the password to decrypt the account because right now it's password encrypted so we're going to type in the password and it's going to go ahead and execute with our unlocked private key we can see the address it printed out was right here and if we copy the address and we go back we can see that that is correct now if we're going to talk about safety and you want to safely secure your keys this is one of the safer ways to do it because it's not going to store it in git you're not going to accidentally push it up to github or show it to anybody and it's going to be password encrypted this is going to be one of the ways that i highly recommend you store your keys oftentimes you're going to want to do a mix of working with the local ganache ones and your own keys and we'll learn how to flip back and forth between them in a little bit now the third way that i like to use is still again using an environment variable script oftentimes it's really easy just to have your private key be an environment variable this way you won't have to keep putting the password in every single time you run a script so it's a little bit less secure and just another tip for myself i never put my private keys associated with wallets that have real money in them as environment variables or in a env file just in case i accidentally do something really stupid i don't trust myself enough so i'm gonna highly recommend that whatever private key that you use and you store it as an environment variable here always have it be just kind of a test account that you're gonna use to test things and then for some of your more serious accounts that's what you'll use the encryption for so let's go ahead and create an environment variable file so we'll do a new file call it env and we'll do export private key ox this now we have a private key set as an environment barrel so brownie has an additional feature that allows us to easily work with environment variables in an environment variable folder we can tell brownie to always pull from our env file in a brownie config yaml this is a special file that brownie always looks for to grab information about where you're going to build where you're going to deploy and where you're going to grab things in this config all we need to do is add env and set dot env this is telling brownie hey when you run scripts grab the environment variables from the dot env file and what we can do is after we import os we'll do account equals accounts dot add os dot get env this is how we get that environment variable a private key then let's just print out that account see if we did it right brownie run scripts deploy.pi and great all right great so this seems to work perfectly but i like to make this method even more explicit so we're going to take this version that we just learned and improve it in our brownie config we can actually add more information about what wallets we want to use and when we want to use them what we can do is we can add a wallets section and add in here a from key section and then add that environment variable private key in your yaml file if you surround a string with dollar sign and some curly brackets it will automatically get transformed into the environment variable so if we go back to deploy we can actually change this we can grab right from our config file so we'll do from brownie import accounts config instead of using os we can do accounts dot add config and then we'll do wallets since that's what we're defining right here and then from key wallets from key and this will do the exact same thing as our os dot get emv the reason that this is better is because now we have one canonical place where we're always going to pull our private key from instead of having to go through all of our scripts and update it based on whatever we change an environment variable now let's try this out brownie run scripts deploy and great we see our address printed here for now let's just stick with using accounts zero since we want to just use the account that brownie makes for us with ganache now brownie is really intelligent and we can actually go ahead and import a contract directly into our script and a web3.pi version we opened a contract and read from it and that's how we were able to interact with it after we deployed it in brownie what we can do is from brownie import and then just the name of the contract simple storage then we can do simple storage dot deploy and this is how we're going to deploy it to a chain anytime you deploy to a chain or you make a transaction you always need to do a from and then say who you're going to be deploying from what's the account that's going to be deploying this as you can see this step of just deploying is much quicker than what we did in web3.pi in web3.pi we had to get the byte code and the abi then we had to get the nuns we had to create the contract we had to create the transaction sign the transaction and then send the transaction remember how i said before you could either make a transaction or a call brownie is smart enough to know whether or not what you're doing is going to be a transaction or a call in this case since we're deploying a smart contract brownie's smart enough to know that ah we want to make a state change so let's make a state change it'll return a contract object so we can just add print simple storage and we'll see what prints so let's run this brownie run scripts deploy.pi awesome so what happened was brownie again per usual it launched a local ganache chain and then it sent a transaction to deploy simple storage and it says simple storage deployed at and then the address it was deployed at and we can see how much quicker this is to actually deploy now let's go ahead and do exactly what we did with web3.pi let's call this initial retrieve function and then we'll update it with a new value of 15. but we'll do it in brownie now remember here's how we did it back in web3.pie in brownie what we're going to do is first we're going to do stored value equals simple storage dot retrieve now since this is a view function we don't have to add from account in here again brownie is intelligent enough to know if this is a call or transaction and we know that retrieve is a view function so we know we don't actually have to make a transaction here then we can print out the value of stored value print stored value let's go ahead and try this great we get 0 right here perfect now let's try updating this so we can do transaction equals simple storage dot store and in here we'd want to do 15. but remember since we're doing a transaction in brownie we always have to add who we're going to transact from in this case we're going to do from account similar to web3.pi we can do transaction.wait for how many blocks we want to wait and then let's call that retrieve function again to see if it's been updated so we can do updated stored value equals symbol storage dot retrieve and then we can print the updated stored value and if we run this we now see we have two transactions here one that deployed our original simple storage contract and we called the retrieve function and we returned zero here then we updated with our store function and then we called retrieve again and we see we did indeed update it to 15. you see how much smaller and easier and more intuitive this is in brownie and how much our lives are going to be much better awesome now you've learned how to deploy to a local chain now running these scripts is fantastic but we need a way to actually automate that our contracts are doing what we want them to do we don't want to always have to manually check that all of our stuff is doing what we want to do right we don't want to have to manually check that 15 is actually updating appropriately this is why running tests are so important and automating your tests is going to be crucial to becoming a successful smart contract developer now i do want to point out that you actually can write tests directly in solidity and this is a great way to actually test your smart contracts is to learn how to do it right in solidity however a lot of the professional developers code their tests in the smart contract development framework language like python or javascript doing it in this way allows you to get a lot more flexibility and customization with what you're doing with your smart contracts and not being confined to whatever only solidity has so let's go ahead and learn how to actually write our smart contract tests in python this is what this test folder is for so we're going to create a new file called test simple storage dot pi make sure you do add tests to the front of these because this is the syntax that pi test is going to be looking for and then in our test we can actually set it up the exact same way we set up our deploy function we can do from browning import simple storage and accounts then we can start defining our tests we want to test to see that when we deploy our smart contract that it gets started off with zero in that retrieve function so we'll create our first test we'll do def test deploy and typically testing in smart contracts or testing really in anything is going to be separated into three categories arranging acting and asserting we're going to bounce around and be a little bit loose with this definition for the duration of our tutorials here however keep in mind that typically this is the setup that you want to use later on in one of our later smart contract examples we're going to go through a much better testing setup so in our arrange stage we're going to set up all the pieces that we need to get set up so first we're going to grab an account we're going to say accounts equals account zero and this is really all we need to do to start getting set up now for our acting stage we're going to deploy a simple storage contract exactly as we did with deploy so we do simple storage equals simple storage dot deploy from account then we're going to get our starting value starting value is going to be equal to simple storage dot retrieve and we're expecting this to be zero so then all we have to do in our search sage is we have to run assert starting value equals expected so let's recap this in our arrange stage we're just getting our account so that we can actually make contracts then in our x stage we're going to deploy this simple storage smart contract we're going to call the retrieve function to see what its starting value is and we're going to compare to see if that starting value is what we expect and we expect it to be zero we can then test this with brownie test and per usual brownie is going to kick off a ganache lie and then it's going to test this for every test you have you're going to get a little green dot and we're going to say one pass in 1.86 seconds which is perfect if we had expected to be 15 and we ran brownie test we should get a fail here awesome and that's exactly what we got now let's go ahead and test updating this with 15 and see if it works as we want it to so we can do a new test in here we'll do def test update thing storage and we'll do those three phases arrange act and assert in our range all we need to do is get our account from account zero and in this one arranging is also going to be deploying our smart contract since this is really just part of the setup and not the act that we're really testing now in our act we're going to add expected to be equal to 15 and we're going to run simple storage dot store expected and then from account you'll notice this is nearly exactly the same as this deploy function here now same as last time all we have to do is assert expected equals equals simple storage dot retrieve we're saying we want to store 15 in our smart contract and then when we call our retrieve function it is stored correctly so let's go ahead and run brownie test awesome we can see two dots here this means two have actually passed correctly that's great now i do want to quickly show you a couple of useful tips that i pretty much always do when i'm running my tests if you want to test just one function you can do dash k brownie test k test updating storage and we will only test this test updating storage we can run brownie test dash dash pdb and add something wrong in here like five equals simple storage dot retrieve and what will happen is once this kicks out and is wrong will actually get put into a python shell and now we can check to see some variables in here like if i see what expected is expected is 15. if i try to run simple storage.retrieve expected is 15. if i run simple storage i'll see this is the simple storage contract pdb is a really useful way to mess around and see okay well what did i really go wrong why is my test failing another important flag is going to be dash s so you'll notice that no print lines actually get sent out when you're working with these tests if you do dash s it'll be a little bit more robust and telling you exactly what's going on and if we had any print lines it would print the lines out as well everything that you can do with brownie test actually comes directly from pi test so if there's some flag you want to use or some awesome debugger you want to use you can use it with brownie just by looking at the pi test documentation all the tools are exactly the same all right we're coming along fantastically we have a script to deploy we have some tests we have our contract this is great but now we actually want to deploy to a test net how are we going to do this let's look at back how we did it with web3.pi back in web3.pi to deploy this to a test net we just needed to add our http web3 provider which was our infira account and that was pretty much it and add our address and our private key brownie our lives are even easier brownie comes prepackaged with a list of networks that it's already compatible with you can see all the networks by running brownie networks list now mine has a couple more actually because i've been playing around with this for a long time but if you want to see all the different networks you can look at this list here something important to note is that there's a difference between the development networks and the ethereum networks whenever we deploy to a network we default to this development network any network that you see under this development section is going to be a network that is temporary these are networks such as the temporary ganache network that brownie automatically spins up when we've run any of the scripts we've written so far so this is really important to know remember anything in this development section is going to get torn down after it's deployed however the ethereum ones are going to be our persistent networks anything under this ethereum tab brownie is actually going to keep track of our deployments and keep track of everything in there these networks under here represent persistent networks like mainnet rink b coven etc now in our web3.pi we used an rpc url or an http provider from infira to connect to a testnet we're going to use that exact same methodology here so how do we actually get this rpc url this blockchain url into our brownie smart contract package well one of the easiest ways is with an environment variable so brownie actually already knows that infuria is thing and can look natively right away for inferior web 3 infuria project id and use our project id from infira if we go to our project back in inferior and we go to settings you'll see the project id is a little bit different than the whole url it's just going to be this id right here we can then copy this and paste this right into our emv now that we have our web3 inferior product id directly in our project if we do brownie networks list any network that infuria has access to you'll see a little inferior in colons here these are networks that brownie will automatically know about if we're working with inferior so we can see here that ring b is one of these inferior keys if we wanted to deploy to ring b we could then just run brownie run scripts deploy.pi and then select the network with dash network rink b now we're going to get an issue here because remember account zero only works when brownie works with a ganache cli we have to use our actual private key here and that's where some of those other versions of working with private keys is gonna come into play sometimes i'll even add a get account function so down here we'll do def get account and then in here i'll just natively check if we're working on a development chain we'll use account zero and if not we'll use the method that pulls from our config so we can check by saying if network does show active equals equals development then return accounts 0. network is another keyword that brownie actually has this network keyword allows us to interact with different networks now if it's not on the development network we're going to pull directly from our config so we'll return config wallets from key and instead of doing account equals account zero we can just do account equals get account now if we run brownie run scripts deploy to pi network ringby it should pull directly from our config file and great we can actually see transactions being sent directly on the rinkby chain if we pull up ether scan the ring be ether scan and we take this transaction has and post it into the bring to ether scan we can see this transaction actually going through we've deployed our simple storage contract and it's initialized to zero then we're going to go ahead and update it and it gets updated to 15. now once we've deployed to a blockchain you'll see our build contract will actually change our deployments folder will have a new deployment every time you deploy to a blockchain brownie will actually save that deployment so you can always go back and say hmm where did i deploy that or what happened with that deployment you'll notice that it's separated by chain id remember the chain id ring b is four you'll also notice that none of our development deployments are in here again anything that's in this development section isn't going to get saved to the deployments area however anything up here and these ones will get saved and that's going to be really powerful because we can actually interact with contracts we've already deployed onto a chain so let's go ahead and even add a new file in here called read value this function is going to read directly from the ring blockchain and it's going to read from a contract that we've already deployed remember we did something similar in web3.pi by using the address and the abi we're going to do the exact same thing but in brownie so in brownie again we're going to do from brownie import simple storage accounts and config we'll do def read contract and we'll just do pass for now and then def main is going to be read contract oops didn't mean to do that down here and if we run brownie run scripts read value to pi network rank v obviously right now nothing's going to happen so how do we actually interact with this simple storage contract that we've already deployed well this simple storage object is actually just an array if we were to print simple storage let's see what we get see we get this brownie.network.contract.contractcontainer object at here this object works the same as an array we can access the different indexes inside of it so what if we do print simple storage at position zero you'll see we get this address here and if we check on ether scan we can see that this is indeed the contract that we just deployed ronnie knows that we just deployed it because again in our build section in the deployments on the rink b chain which has the chain id of four we have this contract that we've deployed now we can actually just directly interact with this contract we can do simple storage equals simple storage of xero or if you're always looking to get the most recent deployment minus one is a little bit easier if we always do zero we're just going to get the first deployment that we made and if we make deployments later we're never going to get past it i want to always work with the most recent deployment so i can just do minus one remember how i said whenever we work with a smart contract we need to know its abi and its address well brownie already knows what the address of this contract is it's got it saved in this deployments folder it also knows what the abi is because when we compile it we get this big json file and one of the first inputs that it has is the abi so brownie automatically knows what the abi is and what the address is already so then we can just go ahead and run simple storage dot retrieve and print it out and we should see 15 since we already updated it brownie run scripts read value to pi dash dash network rink b and great we do indeed see 15. now that we know how to write some scripts and actually deploy things with brownie and work with brownie i'm going to show you one of the most powerful features to also work with brownie typically we write our scripts when we want something to be reproducible and we want to do something over and over again deploying simple storage or reading of value is something that we're probably going to want to do over and over again however maybe we want to work with some of these contracts a little bit ad hoc and get into a shell where we can actually interact with these contracts this is where the brownie console is actually going to come into play and make our lives a lot easier so what we can do is we're going to brownie console and what will happen is brownie will actually kick us off into a console it has all of our contracts and everything already imported so if i run simple storage it gives me back an array it's saying great that's your simple storage contract since we're working on a brand new local test environment there are no simple storage contracts deployed so what i can do is i can say account equals account zero and we now have our account that we can work with accounts is one of these keywords that's automatically imported into our brownie console everything that is imported via brownie in our script is automatically already imported into this little shell here so with that being said we can go ahead and even deploy our simple storage contract so we can literally take this line copy it paste it in here and you'll see exactly the same thing that happens as if we ran our script we get a little transaction hash here and we get a simple storage now if i type simple storage the simple storage variable now has a storage contract here if i type simple storage you'll see i now have a contract in here the length a simple storage is now one because i've deployed one simple storage contract if i were to deploy it again the length is now two browning now knows i'm holding on to two simple storage contracts and i've deployed two simple storage contracts i can then even do things like simple storage dot retrieve and we can see we start with zero i can go ahead and even run simplestorage.store 15 from account and we'll see we'll get a transaction now if i rerun simplestorage.retrieve a nice little hack here is in these shells if you just hit the up key you'll actually be able to go back in the history of the shell so if i just hit up twice here i can go back to this command and i hit enter now we see the 15 is here so the brownie console is a great way to interact with these scripts in a more ad hoc manner maybe we want to test some weird functionality or maybe we have some experiment that we want to try it's a great way to really interact with anything that we have in browning and the other thing is we can do everything that we normally do in python in here so for example i could write print hello and it'll print out hello i could do cat equals 1 plus 2 and i type cat and i get 3. so this brownie shell is a python shell with all of our smart contract features already natively integrated and it's incredibly powerful here we go and quit it by doing quit so i know we've learned a lot so far i'm sure you're starting to see why working with brownie is so much easier and makes our lives as smart contract developers a lot easier for testing them deploying them and working with them all right let's move on to our next project is we're going to take the fund me contract that we made recently in remix and actually import that one into brownie with this we're going to go over a lot more of the advanced features that brownie has to offer us and we're going to get into some more sophisticated testing and deployment mechanisms for this so i'm going to make a new directory brownie fund me we're going to cd into brownie fund me and remember if you hit tab it will auto complete i'm going to open this up in a folder again if code period doesn't work you can always go up to file open folder and do it like that we're in our brownie fund me project and we're going to initialize a new project by running brownie init we're going to create a new contract called fundme.soul this is going to be exactly what we had before for our fund me contract so if you have remix up great you can go ahead and grab it or you can check the github repository associated with this course and just copy paste the code now typically this is where in our last project we just ran brownie compile what happens if we run brown and compile here brownie is going to give us this error it's going to say hey this source wasn't found so what's going on here well remix understands that at chain links slash contracts is an npm package that it can import from however brownie isn't aware of npm packages and brownie can't actually download directly from npm however brownie can download directly from github so we have to tell brownie where it should be downloading these external these thirdparty packages from so that we can use them in our contracts here and while i'm in here i might as well change the global compiler version to 0.6.6 and we'll just change the compiler version to carrot 0.6.6 so that our linter is happy so we need to tell brownie where to import these contracts from from github instead of from npm luckily there is a package out there specifically created for downloading chain link contracts the way that we can tell brownie where to get these from is in our browning config so let's create our browning config in here we're going to create a the pen then sees section and this is where we tell brownie the organization slash repo name at version that we want to download from so so to get these chain link contracts we can look up chain link brownie contracts and we can use this repository to get it so instead of downloading from npm we're just going to download directly from this github repo so we need to tell brownie the organization which is going to be smart contract kit the repository name which is going to be chain link brownie contracts and then the version you don't always have to use the latest version here in fact we can go to the past nine versions by clicking on the version history we're actually going to be using 1.1.1 and yes it does look like the latest version went backwards but as of a recent release as a 1.2.0 version of this package all the releases of chainley brownie contracts is going to match exactly the at chainlink contracts npm tag so that's why it looks like this is an earlier version so we'll say 1.1.1 so great so now brownie knows to download this repository from github once we do that everything everything in this contract section will be available for our solidity code to import and use however that's not the final story here we also need to tell brownie what this at chain link thing means because we're downloading from smart contract kit slash chain link brownie contracts ronnie's going okay cool well what's the sat chain link thing so we need to tell brownie whenever we're using at chain link we're actually referring to this import so we need to tell the compiler this so let's add a new section we'll say compiler when it compiles sulk we need to remap at chain link say whenever you see at chain link here it means we're referring to this package so compiler soccer mappings at chain link is equal to this package up here now let's go ahead and try to compile perfect we see here that it compiles successfully and if we look at our build folder in the contract section we now have this new folder called dependencies and if we even expand this a little bit we can see it says dependencies smart contra kit chain link browning contracts at 1.1.1 and this is what it downloaded from that github repository it downloaded aggregator v3 interface and smart math chain link because we're using both of those files in our solidity code all right great so let's write our first script to deploy this to a development ganache chain to brownie's builtin chain let's do this so in scripts let's go ahead we'll create a new file let's go ahead and build a simple deploy script to work with rink b and then we'll actually learn how to deploy this to our own local ganache development chain so let's build our deploy script so in scripts we'll do new file deploy.pi and we'll start by doing def deploy fund me then we'll do pass for now and then we'll do our entry point of deaf main and then we'll call deploy fund me in this file of course we're going to do from brownie import fund me so we can actually use this and let's go ahead and build this deploy fund me function so first we're going to need to get an account and same as last time we used a function called get account which would know to switch back and forth between if we were on development or if we were with an actual testnet that we could pull from our config we can actually once again copy that function and use that and use that in our script here so once again we can use that get account function that we had before what i like to do with this get account is add it into its own file called helpful scripts so what i'll do is create a new file called helpful scripts.pi and in here i'll add that getaccount function right so literally just pasted it from our last project and just a quick recap on what this is doing is we're saying if the network is in development we're going to use the accounts 0 syntax otherwise we're going to pull from our config and of course we're going to have to from brownie import network config and accounts and then of course in our browning config we're going to have to add wallets and from key so let's go to our config we'll do wallets from key and we'll add our private key environment variable setup which of course means that we're going to have to set dot env to dot e and v and we're going to create new file dot amv and we'll paste the exact same values from our last dot emv so it's going to be our private key and our project id kind of just a lot of the basics of the setup here but now that we've added this get account to its own script how do we actually use that in our deploy script depending on the version of python that you're in you might actually have to create a new file first named underscore underscore init underscore underscore dot pi you might not but just in case let's make it here because it doesn't hurt and with this now python knows that it can import from other scripts and other packages in this project so now we can do from scripts dot helpful scripts import get account so we're importing that get account function from our helpful script here and we're gonna make this get account function a little bit more robust a little bit later but for now it'll work perfectly for what we're looking to do now we can just run our typical deploy function funny we'll do the fundme contract equals fund me dot deploy and of course we'll do from account because again since this deploy is going to make a state change to the blockchain we always need to do a from account section here then we can even do a little print we'll do a print f here so we'll say contract deployed to fund me dot address this is how we'll get the address of our fund me and great we can even go ahead and try this out right now remember you'll need some testing ethereum in your metamask brownie run scripts deploy.pi dash dash network rank b and perfect contract deployed here it is we can even go to bring the ether scan again and we'd see the contract right here now this is great and all but if we look at our contract it's kind of this blank jarble of bytes here right nobody can actually see this contract and and easily interact with it and we want to make our contracts easy to interact with what we can do on etherscan is verify and publish our smart contracts to verify our smart contract all we have to do is hit that verify button we'll choose our solidity compiler type which we know is going to be 0.6.6 and we know we're working with the mit license here now to continue we would then have to add in all of the rest of these pieces we'd have to do optimization which is going to be yes we'd enter our solidity contract code below which importing fund me like this wouldn't actually work because etherscan doesn't know what at chainlink contracts is so we would have to copy paste the code from these imports to the top of our contract here removing these imports and copy pasting the code associated with those files is known as flattening and this is an important concept for verifying our smart contracts on platforms like etherscan however brownie has a really nice way to get around this actually what you can do is go to their main site etherscan.io you can sign in and sign up and get an api key i've already signed up so i'm going to go ahead and sign in here log in and what we can do is we can go to my profile and scroll down to api keys and this is where we can create an api key for us to interact with and programmatically verify our smart contracts on etherscan i've already got one here but all we need to do is hit add we'll give it a name i'll call it verify browning continue and we've created this new api token that will allow us to verify our smart contracts what we'll do to use this in brownie is we'll copy this api key and we'll move back to our scripts here we'll set this api key as an environment variable so we'll do export the name of this is etherscan token and we'll set it equal to that key that we just got now to verify this all we have to do then is once we deploy this contract we'll tell brownie whether or not we want to verify the contract so after our dictionary here we'll do comma publish source equals true we're saying yes we would like to publish our source code now if we rerun this script let's see what happens again remember we'll do browning run scripts deployed up high dash dash network space rinkaby and says fund me has been deployed to here now we're going to say waiting for api rink b dot etherscan.io to process contract and we're submitting our code for verification here and it'll say verification pending verification complete pass verified it'll say where the contract has been deployed and what's been done with it now if we go back to ether scan again we're going to have to go back to rink be ether scan because we deployed this to rank b and we paste this in we now have this little check mark associated with our contract and if we click contract we can see all of the code in here for our contract we have contract fund me payable you need to get more everything that we defined in here and if we scroll up we can see that they did indeed flatten this contract right they pasted that aggregator v3 interface import and they also pasted that library safe math chain link now that's verified we can even read the contract see the different public variables in here such as the owner get version get price and all the exact same buttons that we saw in remix this read contract section is for all these view functions right the ones that aren't going to be making a state change right contract is going to be for when we want to call something like fund or withdraw and we could even go ahead and interact with this so for example we could connect to web3 metamask okay and it would automatically get connected to our metamask here then we could call fund and withdraw just like we did in remix if you want to give it a shot go for it all right we're back in our code editor after successfully verifying one of our smart contracts on etherscan now just a quick note sometimes the verification process can be a little bit touchy and for version of solidity 0.8.4 there's currently a bug that makes it verifying a little bit tricky but it's being worked on so don't be discouraged if it gets a little bit funky so this is great that we've written a deploy script for deploying directly to ring b however as you know we're always going to want to be able to deploy to our own local blockchains or or brownies builtin development chain so we can test a lot quicker and that yes so that we can write some tests but we have a little bit of an issue here the first issue being that our fundme contract currently has an address hardcoded to work with the rink be chain so in fact the way it's written right now it's going to be hard to work with any other chain other than ring b the second bit is that these price feed contracts don't exist on a local ganache chain or a gnost chain that brownie spins up there's two ways we can get around this we can do what's called forking and work on a forked simulated chain or we can deploy a mock or deploy a fake price feed contract on our ganache local development chain deploying mocks is a common design pattern used across all software engineering industries and what it applies doing is deploying a fake version of something and interacting with it as if it's real so again right now if i run brownie run scripts deploy.pi and i don't set this network flag we're going to actually have a default spinning up a ganache chain it's even going to try to verify which it's going to run into an issue because we can't verify on a ganache chain so we have a couple issues that we need to address here in order for us to get this to work on a ganache chain similar to how in this get account function in our helpful scripts we do a little bit checking we say hey if we're on a development network use this development accounts version otherwise pull from our config we can do that exact same mentality but with working with these marks so the first thing that we need to do is we need to parameterize our fund me solidity smart contract so that we don't have this hardcoded in here anymore so what we can do is right when we deploy this contract we'll tell it what price feed address it should use right when we call our deploy function here instead of having it hard coded and we can add this parameter to our constructor we'll say address price feed as an input parameter and whatever input parameter we use here is going to be our global price feed address so instead of us creating these aggregator v3 interface contracts right in the functions here we're just going to create a global one so we'll say aggregator v3 interface public price feed and right in our constructor right when we create this we'll set price feed equals aggregator v3 interface price feed and now what we can do is we can just delete this part because as you can see this is doing the exact same thing is up here this is doing aggregator v3 interface price feed equals aggregator v3 interface and then the address here and we're going to do the exact same thing but in our constructor meaning right when we deploy this contract so we can delete this and we can delete it here as well in our get price function we can even verify this with brownie compile great looks like it's compiling perfectly now our deploy function is going to need to look a little bit different we're going to need to pass the price feed address to our fund me contract to do this all we'd have to do is paste that address before we have our from account variable here so this is how you can actually pass variables to constructors anything inside this constructor function you can pass through brownie in our deploy script here so great so we could 100 always just pass this rink b address here but that's not really going to solve our problem obviously right the problem is that the problem right now is that we always have this ring b address when we say if we are on a persistent network like rink b use the associated address otherwise deploy mocks and i know we've been talking about mocks we'll get into them in a second but let's first set this one up here so we can check what network that we're on again by importing from browning this network bit and we can say if network dot show active does not equal development then we'll say price feed address equals this address here and we'll just pass this price feed address now this still doesn't solve our issue because we're just always passing this the rink be hardcoded piece here so what we want to do is parameterize where we get these addresses from so instead what we can do is in our browning config we can add different addresses for different networks so right underneath our dnv we'll add a new section called networks and we'll do one called rink b and we'll say the fusd price feed address is going to be this price feed address now what we can do in our deploy script is we can say if we're not on a development network let's grab the address from our networks section this way we can define different addresses for this price feed across different networks so we can add we could add a coven section we could add a mainnet section any other networks that we want to work with all we need to do is add add these flags for those contracts so back in our deploy now we can see the price feed address is going to get pulled from the config instead so we'll say config and this means we're going to import config or brownie say config of networks based off of the network dot show active and then we'll use the fusd price feed flag here perfect so this little if statement is going to say hey if we're not on a development network pull the address right from the config and this will make it so that we can deploy to really anywhere that we want to deploy to but what if we are on a development chain well what do we do then we can say else if we're not on a development chain we're going to have to deploy a mock so right now on all these live networks that we're working with there is a version of this price feed contract this price feed address our development chain obviously there won't be one because it's going to start off as blank so what we can do is we can deploy our own version of the price food contract this is known as mocking and we can interact with it accordingly in order for us to deploy a price feed contract ourselves we're obviously going to need to have the solidity code associated with it so what we can do is in our contract section we'll create a new folder called test when you create a test folder in your contracts folder this is typically where mock contracts are going to go and we'll create a new file called mock v3 aggregateor dot sol and this is where we'll add the code for us to deploy our own price feed now i'm going to show you another repository pretty soon called the chain link mix that we're going to work with for now if you're looking for one of these mocks i highly recommend just pulling it from this chain link mix repository so we can grab it by going to contracts test and grabbing my aggregator dot soul we can just copy this whole code and paste it into our mockv3 aggregator.sol this has all the same exact functions as a real price feed contract such as decimals and latest answer which are going to be two of the ones we use the most we can also see its constructor here these are the variables that it takes whenever this contract is deployed it takes a decimals and an initial answer decimals is of course going to be how many decimals that this contract should have an initial answer is going to be its starting value like 2000 for example once we have this contract in our test section we can of course run brownie compile and brownie will go ahead and compile this mock v3 aggregator as well because remember brownie compiles any contract in this contracts folder let's go back to our deploy script now that we have this mock v3 aggregator in here now we can do is we can do a little else here saying okay well if we are on a development chain let's do something let's deploy these mocks so let's do a little print statement here a little printf saying the active network is we'll do network dot show active another print statement print f saying deploying mocks dot dot dot oops i need a little closing there and this doesn't need to be print f it can just be a regular print and then now the same way we import fund me we can import mach v3 aggregateor we can just deploy this contract the same way we deploy all of our other contracts so we'll do mach v3 aggregator dot deploy and as we just learned we have to add the parameters the constructor takes which is going to be decimals and initial answer so maybe we'll set decimals to 18 and then maybe we want to set the initial to answer to 2000 so two one two three one two three four five six seven eight nine ten one two three four five six seven eight comma and of course since we're deploying we've got to do a from and we'll use our account here we'll do another print saying mox deployed and of course we're going to need to get this mock v3 aggregator's address so we'll do mock aggregator equals this and we'll set price feed address to equal our mock aggregator dot address and now we're development or live network agnostic if we deploy this on a live network we'll use the address from our config otherwise we'll use a fake aggregator contract that we've deployed let's go ahead and even try this on a development network so we can do brownie run scripts deploy.pi we don't need a network flag here we'll hit enter it'll spin up the ganache and we even will deploy a mock aggregator contract first and then we'll do our fund me part of course we are running to an issue because we're trying to verify a contract on a chain that doesn't exist etherscan doesn't know about our local gnost chain so to fix this instead of doing publish source equals true we can have this published source be again based on what chain that we're on so we'll go back to our browning config and for rank b we'll say verify will be true but for development we'll say verify will be false and back in our deploy script we now say publish source is going to be pulled from our config so again we'll do config networks network dot show active and then we'll do dot get verify this dot get verify will make our lives a little bit easier if we forget to add verify in here you could still do like this like verify but you run into some index errors if you forget to actually put the verify so sometimes i get lazy and uh it's just a little bit nicer like this now if we run this again deploy.pi we'll spin up our local ganache we'll deploy a mock price feed contract and then we'll deploy our fund me contract and it completes successfully so this is awesome we have a way our fund me contract that uses a price feed contract to our own local development environment with a mock aka a fake price feed contract this is awesome now this is great but our deploy script is starting to look a little big and a little clunky so let's actually clean this up to make it look a lot nicer the first thing that we want to do is we want to fix this this big 2000 number just looking at right away i'm not exactly sure how many zeros it has so to make this look a little bit nicer and more readable we can once again call on our friend web3.pi from web3 import web3 and down here we'll do web3.2 way 2000 comma ether this twoway function will just add 18 decimals to this 2000 so now this is much more readable that the initial value for this is going to be 2 000. the next bit is that we're always deploying this mock v3 aggregator here and if we already have a mock deployed to whatever network that we're working on we don't need two marks here so what we can do then is right before we deploy this mock is we can do a little if statement we can say if the length of our mock v3 aggregator is less than or equal to zero only then will we deploy this mock v3 aggregator remember we can check the length of our v3 aggregator because this v3 aggregator is just going to be a list of all the different v3 aggregators that we've deployed now instead of using mock aggregator.address we can just use mach v3 aggregator minus one dot address so we're just saying okay great just use the most recently deployed mock v3 aggregator and then of course we don't we no longer need to set this as a variable and that looks a little bit cleaner and we'll make this a little bit more efficient so this deploying mox bit though is going to be something that so this deploying mox bit though is going to be something that we're actually going to do relatively frequently let's even move this print statement up here so instead what i like to do is put this whole mock deploying bit in its own function in our helpful scripts so let's open back up our helpful scripts we'll do a new function called def deploy mocks and we'll just paste that code in here of course this means that in our helpful scripts we're gonna have to import mock v3 aggregator we'll also have to do from web3 import web3 instead of account we'll just use this get account function now back in our deploy script we just delete this whole part replace with deploymox and then import deploymox from our helpful scripts and then we can also delete this import now let's remove some of these comments if you'd like this is starting to look a lot more sophisticated and this is great because now we have a way to deploy base off if we're on a live chain or a development chain and then one more thing i like to do so that everything is parameterized i like to set these as static variables in the top of our helpful scripts so i'll set decimals equals 18 and then i'll set starting price equals 2000 and then i'll have mock v3 aggregator to deploy to decimals web 3.2 way to starting price here so no so let's say now that i wanted to deploy this to my own ganache instance well what we could do is we can open up our ganache here we'll do quick start and we'll just quickly create our own ganache blockchain in our script let's go ahead and just run this deploy script again let's see what happens instead of brownie spinning up its own ganache here it says attached to local rpc client listening ad and then this address here brownie is smart enough to detect if you're running your own ganache instance here and will automatically attach itself to it knowing that that is going to be a development environment if we go to our ganache we'll see we have two transactions which are going to be contract creations we're going to create a price feed contract and then also our fund b contract so this is great this is great for testing quickly and locally but there is an issue with this for development networks again brownie doesn't keep track of those so in our build folders if we go to deployments we only are saving stuff from the rink b chain here so we would need to tell brownie hey there's another network that we want you to work with and we want you to remember the deployments to that chain so what we can do is we can add a new network to our browning networks list remember in brownie networks list we have all these different pieces in here these are the ones that brownie is going to not remember and these are going to be the ones that brownie remembers so let's say we want to deploy to a grenache chain and we want brownie to remember those deployments well we can add a network here and this is going to be how we add any blockchain that we want any evm blockchain like avalanche like polygon etc to add a new network to the brown networks is we'll run brownie networks add we'll choose development or ethereum we're going to choose ethereum because we want this to be a persistent network we'll do ethereum we'll give it a name i'm going to call this ganache local we need to give it a host aka an http address which we know is right here and then i'm just gonna make this lower case and then a chain id which for this we know is one three three seven hit enter now if i do brownie networks list i see a new blockchain called ganache local and this is going to reach out to our ganache ui or our ganache command line depending on what we're running now just a note we are going to be deploying to this ganache ui or ganache cli a lot for the rest of this lesson so please keep your ganache instance running now what i can do is i can run brownie run scripts deploy.pi network ganache local let's see what happens of course we run into our first issue ganache local isn't development so it's going to go ahead and try to pull from our config file we don't want this we want to actually deploy mock for our local ganache if a mock hasn't been deployed so what we can do is we can extend our definition of what a development environment is in our helpful scripts we can add a flag in here we'll say local blockchain and vi romance equals and this will be a list we'll say development of course will be one but we can also say ganache local will be another and now we can import this local blockchain environments into our deploy so from at the top from scripts.helpful scripts do a comma here paste that and save mine gets reformatted which is really nice and instead we'll say if network.showactive not in local blockchain environments then go ahead and pull from the config what this is saying is it's saying if whatever network that we're on if it isn't development or ganache local then go ahead and use a config if it is one of these two we're gonna go ahead and deploy a mock here now that we have that let's try this again ronnie run scripts deploy.pi dash dash network ganache local and we run into a different issue we're saying hey you don't actually have enough gas well why is this let's look at our get account function aha this one is also looking directly for this development chain this one will say if network.showactive is in local blockchain environments then return accounts zero so we're saying if the network we're working on is development or our ganache local then just return accounts zero so let's try this okay we're getting closer now we're running to this key error of ganache local well we do know how to fix that as well in our config we'll add this new network we'll say ganache local and we'll set verify to false so let's try this one more time perfect now mocks have been deployed and our fundme has been deployed and if we look in our build folder in deployments we now have a new chain id for one three three seven for saving these deployments and it looks like in our ganache chain we have these actually saved in here which is great now an important thing to note if you were to close this or delete this ganache chain all of your contracts will be lost so you won't be able to interact with them again to account for this you can always delete 1337 and delete the entries in one three three seven from your map.json or if you're fine deleting the whole build folder you can delete the whole build folder so now that we've deployed this let's actually write a script to interact with this so let's create a new file we'll call it fund and withdraw dot pi and this will be the script we use to fund and withdraw so let's create a function called fund we can say fund me equals the most recently deployed fund me we have to do from brownie import fund me we're gonna have to get an account since we are gonna be making some state changes and we just have this equal to get account and we can do from scripts dot helpful scripts import get account let's get the entrance fee so we can figure out how much we want to fund actually sorry since this is going to resemble that fusd price feed it actually only has eight decimals two one two three four two thousand and one two three four five six seven eight the reason we want to do it like this too is because in our get price function we know that it only has eight decimal places so we're multiplying it by an additional 10 here we want to resemble that as well so we'll do eight decimals starting price of 2000 with eight decimals here and for our mock v3 aggregator we're just going to use those exact values and we're not going to do the web 3 converting we're just going to make it exactly those hardcoded values now we're going to want to get the entrance fee so i've gone ahead and actually added a function called get entrance fee to our contract to make our lives a little bit easier here i'm going to recommend that you take a look at this and then type it in yourself or you just copy paste it from the github repository so that we can use this get entrance fee because it's just a whole bunch of math here so back in our fund and withdraw what we can do then is we can do entrance fee equals fund me dot get entrance fee excuse me get interested and we can even print out this entrance fee just to see if we're doing it right but first we're going to want to run brownie run scripts deploy network ganache local because we changed our fundry.soul all right great and now we can run brownie run scripts find and withdraw network local and whoops i need a main function so we'll do def main fund in here and let's rerun this and great we can see this is the entrance fee do a little print statement here printf saying the current entry fee is entrance fee we'll do a little print saying funding and then we'll call fundme.fund and of course we're going to do a from account and we're also going to send a value of entrance fee any low level transaction data that we want to send with our transactions and function calls we'll add in this little bracket piece here let's set up let's do brownie run scripts funder withdraw again and great it looks like it's going through perfectly awesome let's also do a withdraw function for the owner to withdraw we'll say fund me equals fund me minus one do account equals get account and then we'll just call fund me dot withdraw from account and then right after fund is called we'll have withdraw be called and our main function here let's go ahead and try this brownie run scripts find and withdraw network ganache local this is our funding script our funding transaction going through and then our withdrawal transaction going through perfect so it looks like our approximate functionality here works great and this is a script that we can run on a main network if we'd like now again it's still much better for us to run so now we're going to move into actually writing those tests and for these tests we're going to want to quit our ganache ui let's go ahead and write some of these tests create a new file called test fund me dot pi we'll quickly speed through this test because we're not going to learn too much new here keep in mind when we're on this test we're going to want it to be able to work independent of the network that we're working on so let's just keep that in mind let's do a test just to see if we can fund a withdrawal so we'll do def test can fund and withdraw and we'll do basically exactly what we've done before do account equals get account of course we'll do from scripts that helpful scripts import get account then we'll want to deploy fund me and we can even just use our deploy fund me script in our deploy.pi so we can do from scripts dot deploy import deploy fund me in our deploy fund me at the bottom we'll just say return fund me so that our test can now have this fundme contract for it to work with so now we'll say fund me equals deploy fund me grab the entrance fee which will be equal to fund me dot get entrance fee and then let's go ahead and fund it so do transaction equals fund me dot fund and we'll call from account we'll do value entrance fee we'll do tx.weight one we'll do an assert here we'll do assert fund me dot address to amount funded it's going to be account dot address it's going to be equal to the entrance fee so we want to check that our address and the amount that we funded is being adequately recorded and then we'll do transaction two will be fund me dot withdraw from account tx2.weight one and then we'll assert fund me dot address to amount funded account dot address equals zero and let's go ahead and run this test so we'll do brownie test and perfect looks like it's doing well now you may be wondering why sometimes we use the dash dash network flag and sometimes we don't in our network section brownie automatically picks a default network to use and the default is always set to development however we could set this to be anything that we wanted we could set the default to be ganache local we could set it to be rink b whatever we want it here whatever you set for the default in your brownie config is what the network will be defaulted to so right now when we run brownie test this is equivalent to running brand test dash dash network development we can even go ahead and run that too now we could also run this test on rink b and we will in a second but oftentimes we don't want to test all of our functionality on rink beat and on live networks because it's going to take a long time for them to run so sometimes we only want to run tests on our local chains well how do we do that we can use pi tests skip functionality to do so to work with pi test we're going to first need to install it so go ahead and run pip install pi test to demonstrate this let's create a test that makes sure only the owner can withdraw and nobody else can so we'll call this def test only owner can withdraw to skip this test if we're not on a local network we'll first check the network we'll say if network.showactive is not in and yep probably would have guessed it we're going to pull this local blockchain environments in from our helpful scripts so we'll do comma local blockchain environments and we're going to say if the network dot showactive is not in this list of local blockchain environments we're going to do pi test.skip and say only for local testing of course we're going to import network and we're also going to import pi test now if i try to run this test here with brownie test dash k dash dash network rinkeby it should skip perfect and we do see with this s here meaning that it's skipped this function if we run this with dash network development it should go ahead and run this and it will pass because nothing happens in this function and it does perfect let's keep going so now we'll say account equals get account we'll say fund me equals deploy fund me and now let's get a different account to try to call the withdraw function so we'll say bad actor equal and this will just give us a blank random account but we do have to import accounts from about here now we want to test to see that them calling this withdraw function actually reverts them and causes an exception because if i try to do fund me dot withdraw from bad actor right now what do you think will happen well that well we know in our fundme.soul our withdrawal function has the only owner modifier so technically only the owner should be able to call this function so what happens actually we don't even need this account get account bit let's just go ahead delete that so what happens if somebody else tries to call this withdraw function well let's go ahead and test this we'll do browning test dash k test only owner can withdraw hmm and you can see we're getting this error here writing browning.exceptions.virtualmachineerror revert from this fundme.withdraw well we want this to happen we were expecting this to happen so how do we test that we want this to happen well we just need to tell our test that we want this to happen so first we're going to import from brownie this exceptions package this way we can tell our test exactly what exception we're expecting to see then we'll say with pi test dot raises exceptions dot virtual machine error fund me dot withdraw and then we'll just actually we'll just copy this line down here now what this is telling our test is that if this reverts with this virtual machine error that's good we're saying we want you to revert when you try to call this line so if we delete this line and hit up and try to run this again we can see that it now passes and this is exactly what we're expecting so this is awesome all right we've learned a lot of fantastic tools for working with brownie here now the last version of testing that i want to show you how to use is mainnet forking maintenance forking is incredibly powerful when we're working with smart contracts on mainnet that we want to test locally so let's talk about forking for a minute so on the left here i have a blockchain right an example of a blockchain this is going to be like a test net like rinkaby or something like mainnet right this is going to be a blockchain that we actually deploy to now there are a whole bunch of blocks in here right and there's a huge chain that we can actually work with all this information is public information right this block is going to have like transaction transaction transaction it's going to have you know each one of these blocks is going to have a whole bunch of transactions and all this information is here in addition to all these transactions it's going to have price feed contracts ave contracts you know et cetera it's going to have all these different contracts in it so hypothetically if it's already there we should be able to basically copy this all this whole blockchain and do some simulations ourselves and that's exactly what forking does a forked blockchain literally takes a copy of an existing blockchain on the left here and brings it into our local computer for us to work with we actually have control of this blockchain since it's going to run on our local computer similar to ganache now all the interactions that we do on this local blockchain are not going to affect the real blockchain because it's our local chain right it's a simulated blockchain but because it's simulated we can go ahead and interact with price feeds we can interact with avid we can interact with all these different contracts that are already going to be on chain maintenance fork is a builtin part of brownie and also pulls from inferior the same way it works with rink b and coven and everything else we can start to interact with the mainnet fork contracts the exact same way therefore so we can take this whole ring big section copy it paste it and we'll just change this fusd price feed address to its mainnet address so we'll go to docs.chain.link ethereum price feeds get fusd here copy that and we'll paste it into here and we'll change this to mainnet fork and since this is going to be a fork of course for verify we're going to do false now if we try to run one of our scripts like brownie run scripts deploy.pi network mainnet fork you'll see we'll actually run into an issue here it's saying insufficient funds for transfer in our deploy script when we do our get account and our helpful scripts right now we're using accounts.ag config while it's from key yes it's going to be our account which right now has zero money in it on mainnet so brownies right away gonna say hey you don't have any money on mainnet what's the deal so we need to tell brownie that when we're working with mainnet fork it should create us a fake account with a hundred ethernet however we don't want it to deploy a mock because the price feed contracts already exist so we don't want it to deploy a mock but we do want it to get us an account here so typically what i like to do is i'll add another variable here and i'll call it forked local environments and i'll add maintenant fork in here and i'll use this now as part of my if statements so i'll say if network does show active in local blockchain environments or network dot show active in forked local environments then we're going to go ahead and return account 0. however in our deploy.pi mainnet fork is not going to be in this local blockchain environment so we will just get our price feed from our config so now if i run this maintenance fork again now if we run this you'll see we'll still get an error we'll get list index out of range so brownie's builtin forking mechanism doesn't actually come with its own accounts here however it has these issues so what normally i like to do is i like to create my own custom maintenance fork right in browning the way we can create our own development custom network is by using the brownie network's add key so we do brownie networks add we'll make this a development network instead of a persistent network and we'll call this mainnet fork dev to set this up we'll do a ganache cli so we'll say the command to run this fork is going to be ganache cli the host is going to be the same as always http dot colon slash 127.0.0.1 fork is going to be equal to and this is where we just put https mainnet dot infira dot io v3 slash web 3 infira project id now don't hit enter quite yet i'm going to explain a couple things so this single quote means run this as is if we run this without the single quote our environment variable would get actualized here and we'd always have to use whatever our current environment variable is so we want to have this little semicolon here then we would do accounts equal 10 this tells brownie for us to set up 10 fake accounts for us we'll give it a mnemonic of brownie so we'll say great make those accounts just have a new monica brownie and we'll do a port equals eight five four five now once again don't hit enter quite yet i do wanna explain one other thing so this is great for working with inferior and forking from inferior however i have to note that performance wise forking forming fura has pretty much always given me an issue so i prefer actually to fork from this application called alchemy and in fact if you'd like you could set up all of your networks to work with alchemy by modifying them i'm going to go ahead and sign in here and we're going to give it an alchemy url instead of an inferior url so i'm going to go ahead and create an app i'm going to call this fund me demo description will also be a fund me demo via development environment on the ethereum mainnet let's create this we can now view the details of this we'll go to view key and we'll copy this http address and we'll move back over here and for forking we can just delete everything next to this fork and we'll just paste that in here instead and let's go ahead and hit enter you'll know you've done this right if you can see something like this mainnet fork dev has been added oftentimes in my example i will actually just delete maintenance fork and have mainnet fork dev be my default for maintenance for but for us we're going to go ahead and do mainnet fork dev so in our config we're going to change mainnet fork to mainnet fork dev so since we're giving this a different name that means in our helpful scripts we're gonna have to have do a comma here and say mainnet fork dev all right great now our get account should return accounts 0 for maintenance fork dev and it should actually work so let's run our script again brownie run scripts deploy dash dash network mainnet fork dev and perfect we're running our maintenance fork dev and it is running successfully now we should also be able to test exactly the same way let's look at our test real quick test fund me and see okay cool we're going to be skipping this one since main at fork forkdev isn't in the local blockchain networks but this should work perfectly and then oftentimes in my tests here i'll actually do like a little plus 100 or something for entrance fee just in case i need like a little bit more money for whatever reason so now if we run founding test dash dash network mainnet fork dev we'll see that this does indeed pass and this is awesome so this is fantastic incredibly powerful project here now we're going to teach you how to actually share your code and enter the world of open source and decentralized code the way the world works when sharing code and sharing ideas and collaborating together is they use what's called open source git repositories github is an example of one of these git repositories that we can use to share our code and it's one of the dominant ways that smart contract engineers share ideas and share code we are now going to learn how to add our code to github and then we can even share the code and show the world what we've built and what we've done this isn't going to be a full endtoend git course however there are some links in the course repository that will show you how to work with git work with github and work with version control so the first thing that we're going to do is we're going to come to github and we're going to sign up for a service add our email create a password enter your username no now we'll go to our email to verify it continue we're going to be working with some collaborative coding we're going to choose the free edition and perfect we are now in github now that we're in github we're going to create our own first open sourced repository so we're either going to hit this plus button here or create repository let's choose a repository name for this we'll give it the same name as our main folder so call this brownie fund me give it a description maybe smart contract application and we'll hit create repository this is where we're going to upload our code to share with the world back in our vs code now we're going to send this folder to that repository first thing we need to do is installing git there are a couple different ways to install git depending on the version that you're on we'll put this link in the description to our course to actually install git once you have it installed you should be able to run git dash dash version and see a git version here now we're going to initialize our repository in here by doing git init we're going to choose a branch name we're going to call it main we'll go ahead and add our username and email to our git config user dot name quotes free code camp video git config user dot email free code camp video gmail.com now we're going to do a couple things to push all of our code to github here however remember we do not want to push our dot env pieces up here so we can do a couple of things we can a we can go ahead and delete this of course but we can also add in our dot git ignore file a dot env this will help us so that we don't accidentally push our dot env file to github we can choose what files we want to push by doing git add and then a period and if we do get status it will now show us all the different files that we have staged to push to github if we look in here we see we have git attributes git ignore browning config fund me some contracts some scripts but we do not have that dot emv file if you were to remove dot emv from dot git ignore and you ran git add dot again and then we did get status we now see the dot env in here we do not want this in here so we can do git remove dash dash cached dot e b we'll add dot env back to our dot get ignore file and then we'll run git status again and then we'll run git add period and then get status and great we do not see that dot env in here so that's very good now we'll commit this by git commit minus m first commit and now we can add this folder to our github back in our github there's a little line here which even tells us how to do it we're going to copy this line right here git remote add origin https free code camp brownie fund me i'm going to copy that paste it in here hit enter and now we can just do this second line git push dash u origin main we'll do git push dash u origin main we get an output like this and if we go back we'll now see all of our files and folders in here now i've already added my email and password in here but instead of this you'll probably get github asking you for authorization you can just go ahead and put your github username in and your password in there if your username and password doesn't work you can come into github go down to settings scroll down to developer settings personal access tokens and generate new token we'll call this f brownie and we'll want to give it at least repo authorization here and we'll hit generate token and instead of using your password you can go ahead and use this github token amazing and you now have your first github repository we could even come in here add some topics like solidity chain link python brownie etc so that we know what our file is about and this is incredibly exciting now i'm gonna even encourage you to pop onto twitter and share your excitement i just made my first first at thanks to at free code camp at solidity brownie s at chain link if you want to tag me you can also tag at patrick alpha c and pop your repo in there go ahead and hit tweet the community absolutely loves hearing about all the fantastic things people are doing in this ecosystem so be sure to reach out have fun and engage i know we've gone over a lot here but let's talk a little bit about some testing pieces here now a big question you might have is well okay so i learned a ton of stuff we learned about maintenance forking i could do stuff on ganache i can use brownies ganache i can use brownies main net fork there's i can do a test there's all these places to do stuff where do i need to run my tests the default for every single one of your contracts is as follows you always 100 need to have tests that pass on a local brownie spun up ganache instance that should be priority number one to get all your tests to pass on this this means that you will need to deploy mocks after that the other place you absolutely need to have tests or do some type of development is on a test knob these are going to be what's known as your integration test and we'll talk more about those later so those are the two places you always need to have tests development and a test net i think testing on main net fork and your own local ganache are optional testing on mainnet fork can be done and probably should be done whenever all of your contracts and all of your interactions are going to be on chain on one chain without any external offchain components testing on your own local ganache is really more meant for tinkering and kind of exploring and seeing things yourself so that's going to be the setup here so great now let's move into our most challenging example once you pass and once you complete this example you basically will have all the tools to be an incredibly powerful smart contract developer then after that we're going to show you the chain link mix package and how to do what's called a brownie bake to automatically open up this package with all these scripts and all these contracts prebuilt in this is going to make our lives substantially easier and faster for deploying our smart contracts however let's go through the process of understanding all the pieces that are going to be inside of this brownie mix are you ready you should be let's get excited and jump in okay so let's get into our most advanced smart contract project that we've made so far this is going to be the best example of a full scale application and by full scale i really mean endtoend full suite of our brownie all of our smart contracts are really solid here what we're going to want to do is create a lottery application where anybody can enter the lottery and a random winner is selected so let's get to it and let's get started so first of course we're going to make new directory we'll call it smart contract lottery cd and a smart contract lottery and then open that folder great we are now in our lottery application so let's go ahead and start a new project brownie init we've got our project here now let's create a quick readme.md to explain what we're going to be trying to do here so number one we're gonna say users can enter the lottery with f based on a usd fee so for example let's set the price to be like fifty dollars and the users actually pay with ethereum so we're gonna have to get that conversion rate number two an admin will choose when the lottery is over and then three lottery will select a random winner now something important to note here is since we have an admin here this means that our application isn't necessarily going to be truly decentralized because we have a single person chooses when the lottery is over we could scale this out to have maybe a dow being the admin or something like that or we could have the lottery automatically open and close based off some time parameters but for the moment this is the setup that we're going to have keep in mind even though this is much less decentralized it's still going to be a great use of smart contract technology so first thing that we're going to get started with of course is our lottery contract so create a new file called lottery dot sol and let's begin with our initial setup here so let's choose our version pragma solidity carrot 0.6.6 and this will be the version that we want to work with here we'll do contract lottery bracket here now let's think for a second on what some of the functions that are going to be what our main functions are going to be here we'll probably have a function enter that'll be public we'll probably have a function get entrance fee to get the entrance fee of the lottery we'll probably have a function start lottery that only the admin can call this will be public as well which means we'll also probably have an end lottery function and those are really going to be the main functions the user can enter based off the entrance fee we can start the lottery and then of course we can end the lottery so let's get started with this enter function just because this is most likely going to be the entry point as we know since we're going to want them to pay using this entry function in ethereum we're going to need to make this function payable and in here we're going to need to keep track of all the different players everybody who signs up for this lottery to keep track of all the players we're going to make an address payable array we'll make it public call players and anytime somebody enters we'll just do player dot push message dot sender however right now we're not checking to see how much value that they're actually sending we want to set the price of this to be at least 50 so we'll say 50 minimum so here we're gonna have to do a require statement requiring them to do at least 50 in order to do that we're probably going to need to have some function to get the entrance fee to check whether or not how much they're sending is actually 50 so let's go ahead and make that get entrance fee function now since we're just going to be returning a number for get entrance fee we can probably go ahead and make this a public view and have this return a u and 256. to get this entrancy we're first going to have to have stored somewhere what the entrance fee is we're going to store this 50 minimum somewhere this is something we'd probably want to set right when our contract is deployed so where can we put stuff like that well in our constructor we'll do constructor public we'll create a new variable outside here we'll call it un256 public usd entry fee in our constructor we'll set usd entry fee equals 50. now because i like to have units of measure always in way we'll also do times 10 raised to the 18th now we have some usd entry fee let's go ahead and get this entrance fee as we know since we're going to try to get a conversion rate here we're going to want to use a chain link price feed so we can head on over to docs.chain.link we'll scroll down to get the latest price and we can even just go ahead and copy paste this again but for the sake of robustness let's just walk through again how to actually set this up we're going to need to pull from the price feed to convert fifty dollars to fifty dollars in each so let's go ahead and create an agra gator v3 interface internal f usd price feed and in our constructor we'll go ahead and set this we'll say fusd price feed equals ag redgate tor v3 interface and we're going to want to grab an address from our contract addresses but of course as you know as we've learned from last time we're going to want to parameterize this so we're going to want to pass the address of our price feed as a constructor parameter so we'll do address price feed address and we'll have our aggregator v3 interface we passed that price feed address then of course since we're using an aggregator v3 interface we're gonna have to import this from chain link so we can just go ahead and copy this from the documentation and paste it right at the top or if you want to rewrite it out yourself feel free to do so and of course since we're doing this import here new file browning config. we're going to want to add this as a dependency so we'll do d pendancies smart contract kit chain link browning contracts and we'll do add 1.1.1 again and then compiler sulk remappings we'll say at chain link equals this right here we'll pull up our terminal and we'll try this out do brownie compile see if we're doing everything right we forgot an spdx license identifier which is just a warning but let's add it in anyways spdx license identifier mit i should probably spell me remappings right mappings and let's try to compile again all right lovely so we at least know that we are compiling correctly here awesome so now that we have a price feed let's go ahead and set up this entrance fee so we're of course going to need to get a price from this price feed so we can even check the documentation how to do that we can call this latest round data function so we could copy paste it i'm just going to go ahead and rewrite it but again we don't need round id started at timestamp or answered in round we only need price so we can go ahead and ignore these variables on our call so what we'll do is we'll do blank comma into price and then comma comma comma equals fusd price feed dot latest round data and this means we're just going to get the price here now we're going to want to do a little bit of quick math typically if we're setting the price at 50 and we have a price feed of two thousand dollars per eth we would just wanna do fifty divided by two thousand but of course since solidity doesn't work with decimals we can't actually just do this so we'll have to do 50 times some big number divided by the 2000 so we're going to go ahead and do it like that but first let's go ahead and convert this price from into 256 to uint 256. so we'll say you went 256 adjusted price equals you went 256. you in 256 price and then since we know we're going to be using an ethereum usd price feed that has eight decimals let's also just convert it to having 18 decimals as well so we can also do times 10 raised to the 10th so now we can have 18 decimals now that we have this adjusted price we'll do um 256 cost to enter it's going to equal usd entry fee times again we're going to want to times it by some big number here so we'll just times it by 10 raised to the 18th this way usd entry fee has 18 decimals but it has an additional 18 decimals here that'll be canceled out with our price feeds and the math will work divided by price and then we'll return cost to enter now of course since we're doing some interesting math here it's recommended to use safe math and use safe math functions we're going to skip over the safe map functions here again because in the newer versions of solidity you don't really have to use them but i think it's important to note here that sending this code this exact code to production would be a bad idea for at least the reason of the safe math functions but in any case we have a function here we think our math is pretty good but i know for a fact that my math is usually not very good so let's go ahead and do some testing as we code just to make sure our get entrancy function is working properly so based off of our last lesson let's talk about how do we want to test this well we could do a main net fork here because we're only working with some onchain contracts and some math we will at some point have to do our develop mint with marks and of course our test net i kind of want to just do a quick and dirty way so let's try our maintenance fork just for now just to see if if this is really making any sense if the current price of ethereum is 2 500 or this much here and we want the price of this to be fifty dollars we do 50 divided by this and we get .019 so this should be approximately what we get for our eat value so if we were to write a test test lottery dot pi if we were to test this function we would expect to get 0.019 or in way it'll be 1 9 1 2 3 4 5 six seven eight nine ten one two three four five six we expect to get approximately this so let's go ahead and create a function that tests us so we'll do test get entrance fee and here we'll deploy lottery and in here the first thing we need to do is deploy this lottery function of course so we'll do from brownie import lottery in order to deploy this we're going to need to get an account we are going to import our helpful scripts from the last project to this one too so we can get our get accounts but for the time being we can actually just use accounts 0 from brownie so we'll say count zero let's start with def then we'll do lottery equals lottery dot deploy from account and ah of course we have a parameter here of our price feed address so we're gonna have to add some type of parameter here for now let's just hard code it from our config and we'll go into our config and we'll start our networks flag we're going to be working like i said on the maintenance fork for this quick and dirty here we'll call f usd price feed grab the fusd price feed from mainnet since we're going to be doing a main net fork here pop that in here now we can just say from config networks network dot show active usd price feed of course we're going to need to import network here and now we can do our kind of quick and dirty test we can do lottery dot get entrance fee am i spelling that right get entrance fee yes assert lottery.get entrance fee should be greater than let's just say let's just go down 18 or if we wanted to make sure we're actually doing this right we'll do from three import web three we'll do web3.2 way 0.019 comma ether should be greater than and then we'll even do 0.018 just to make sure and it should be less than 0.01 now these numbers are of course going to be a little bit different for you and if you want you can go ahead and skip this part so that you don't have to do the math but it is kind of nice to do a quick sanity check saying okay like based off what things are right now what would this price end up to be now in our last section we made a mainnet fork dev network i'm going to just go ahead and customize our mainnet fork the way that we showed you guys how to do maintenance fork dev this way you can use accounts and we can be a little bit more robust here to do this we're first going to have to delete brownie's internal builtin mainnet fork so we'll do brownie networks delete mainnet fork maintenance fork has been deleted and now let's go ahead and add our own maintenance fork using alchemy as our ethereum connection so you'll want to create a new app i've already created one here called smart contract lottery we'll view the key and this is the http endpoint that we'll use so to do this we'll do brownie networks add this will be a development chain we'll call this maintenant fork it'll be a ganache cli the host is going to be our local host so 127.0.0.1 and the fork is going to be equal to our alchemy http here we'll do accounts equal 10 that way we can use the accounts do the new monarch equals brownie import is going to be eight five four five and great maintenance fork has been added now that we have this here we can go ahead and run our test brownie test dash dash network mainnet fork whoops looks like we got a little compile error on our math here oops it looks like we're divided by price when we need to be divided by adjusted price and we forgot the parentheses on latest round data let's try this again and i put an extra comment in here let's try this one more time lovely and it looks like we're forking correctly and awesome it looks like our test indeed passes here of course we know that we're going to want to change this because this isn't a great way to actually test our contracts here but it can be a nice sanity check and we know we're going to have to refactor this as well for mocks and for accounts but we'll get to that in a little bit awesome sanity check complete let's get back to our contract here so we are getting the cost to enter correctly perfect we're getting this entrance fee what that means we can do in our enter function we can do require message.value it's got to be greater than or equal to our get entrance fee function and if it's not give them an error of not enough eath we have a way for them to enter and we have a way to get the entrance fee but we want to make sure that we're not ending the lottery before the lottery even starts right or we're not entering a lottery when a lottery hasn't even begun so we're going to want a way to iterate through the different phases of this lottery and we can do that with what's called an enum or an enum according to the solidity documentation enums are another way to create userdefined types in solidity we saw an earlier version of doing this with a struct enums are a little bit different in that they're explicitly convertible to and from all integer types so what does that actually mean well we can have an enum like this action choices go left go right go straight and sit still they're just more readable ways to say go left is going to be represented as state 0 go right it's going to be state 1 go straight state 2 sit still state 3. so for our lottery contract we're going to want to create this new type that represents the lottery state so to do this we'll do enum lottery state open closed and calculating winner this means that we have a new type called lottery state with three positions open closed and calculating winner these different states are actually represented by numbers so open is actually a zero closed is actually one and calculating winner is actually a two now that we have this new type we can create a variable of type lottery state so we'll say lottery state public lottery state and right when we initialize our contract here we're going to want to set our lottery state to being closed so in our constructor we'll do lottery state equals lottery state dot closed now since these are represented by numbers as well we could also just do lottery state equals 1 because 1 stands for closed however it's much more readable to do lotterystate.closed now that we have a lottery state in our enter function we can require that the lottery state is going to be equal to lottery state dot open so we can only enter if somebody's started this lottery and that's exactly what we're going to do in our start lottery function we're going to do a require in here that the lottery state is going to be equal to lottery state dot closed we can even add a failure function here saying can't start a new lottery yet and when we do start this lottery we'll say lottery state equals lottery state dot open now when somebody starts the lottery they'll be able to enter of course this start lottery bid here needs to be called only by our admin so this is where our only owner modifier is once again going to come into place we could write our own only owner modifier or we can once again use open zeppelin's access control and open zeppelin's ownable function instead which is what i'm going to use here so we're going to go ahead and grab this copy this paste it in import at open zeppelin contracts slash access ownable and of course since we're doing this we're gonna have to add this dependency into our config we're gonna be using open zeppelin open zeppelin contracts at 3.4.0 we're going to remap at open zeppelin equals this oops and then we'll say our lottery is ownable perfect now we'll try to compile this awesome looks like brownie grabbed everything correctly and we're good to go great now we can finally move into our end lottery function this is where we're actually going to choose a random winner here we only want the admin to be the one to actually end the lottery so let's add the only owner modifier here and let's talk a little bit about randomness because this is what we're looking to do now we're looking to get a random winner here now as you know the blockchain is a deterministic system right and this is super ambitious because that allows us to do all these smart contracts and have this system that can actually reach consensus very easily random numbers are much harder if let's say you had a blockchain with a whole bunch of different nodes and each node responds and gives their own random value well each node is never going to be able to sync up and say hey you know we all agree on a random number what you could do is you could base the random number on some other attributes in the system but then it's not really random it's actually going to be pseudorandom so getting truly random numbers in a deterministic system is actually impossible and if you know a lot about computer science you actually know that even when you call like math.random in your javascript what your computer is really doing is it's looking at some place in memory grabbing some value and saying hey this is probably random enough here go ahead and use this now in smart contracts especially when working with any type of financial application such as a lottery having an exploitable randomness function means that your lottery is at risk of being hacked or destroyed and this isn't even a fairy tale at the time of recording about two weeks ago i did a rundown on an exploit where a protocol used insecure randomness and got hacked for seven hundred thousand dollars so i am going to show you this insecure way first and the reason that i'm going to show you is that it is a quick and dirty way to get a pseudo random number but please do not use this in any production use cases i'm going to show you a method that's often used to teach people how to get random numbers and then we're going to explain why it's so vulnerable and not a good method of randomness and what some insecure protocols will do is they'll use a globally available variable and hash it so in your smart contracts there's actually a number of globally available variables one of those as we saw above is going to be message.value right it's going to be the value that's sent with the transaction another globally available variable is going to be message.sender you can actually see a whole list of these different globally available variables in the solidity documentation here so since there are these globally available variables a lot of times some will see something like block.difficulty which returns the current block difficulty now one of these globally available now one of these globally available variables is going to be block difficulty or block dot difficulty it's the current block difficulty remember how i said that the time between different block generation is called the block time well you can always keep that block time as is by changing the block difficulty over time the harder the problem or the harder the proof of work algorithm the longer it's going to take or the more nodes you're going to need to solve that problem there's this constantly recalculating metric called ethereum difficulty or block difficulty depending on the chain that you're working on that constantly changes so you might think this would be a great use of randomness right because it's a somewhat hard to predict number so what a lot of people do is they think that hey those sound pretty random let's use them as a unit of randomness and what you'll see is you'll see like something like uint 256 which is again this hashing algorithm let's do something like abi dot encode pact so i know there's a whole lot going into this line and let's talk about it so first as we can see is that we're casting or we're converting everything in here to being a uni256 the reason that we're doing this of course is because we're going to want to pick a random winner based off of an index right we're going to want to pick somebody some random winner in our players array or our players list so we say okay whatever number that we're going to use that's going to be the index of the winner that we're going to randomly pick then they use cache 256 which is again our hashing algorithm so they hash a whole bunch of variables together and they do this abi dot encode packed api is another keyword for some lowlevel work and they'll add maybe a nunsen they'll add the message on sender block that difficulty and block the timestamp basically what they're trying to do here is take a bunch of seemingly random numbers mash them all together in a hashing function and then say yeah this this is pretty random but the issue here is that the hashing function itself isn't random the hashing function is always going to be exactly the same could check 256 it's always going to hash everything exactly the same way so we're not actually making it more random by hashing it all these numbers inside are the pieces that actually determine how random it is so if the block to difficulty is random then this will be a random method if the blocked out difficulty isn't random then this won't be a random method and the blocked difficulty is not random difficulty can actually be manipulated by the miners in time stamp timestamp is predictable nuns is predictable aka transaction number because in this regard they're using the nuns as some transaction number and message.sender is predictable when using a random number in this way the hashing algorithm is always going to be the same union 256 is always going to be the same we have a predictable number a predictable address a predictable timestamp and then a manipulatable value so all this is really doing is giving the miners the ability to win the lottery or win whatever lottery that you're working on so this isn't going to be an effective way to get a random number this is an unacceptable way to get a random number in our applications yes we do have this only owner modifier here which means that we are the ones who are going to choose when to call this so it is still centralized in that regard but let's just teach you the best practices for working with random numbers right from the getgo so you don't run into any issues i'll explain what this part is doing in a little bit in order to get a true random number we are going to have to look outside the blockchain the blockchain itself like i said is a deterministic system so we need a number outside the blockchain but what we can't do is we can't use just an api that gives a random number right if that api becomes corrupted if they're malicious if they go down if something happens etcetera what we need is a provable way to get a random number and chainlink vrf is actually that solution chainlink vrf it stands for chainlink verifiably randomized function and it's a way to get a provably random number into your smart contract it has an onchain contract that checks the response of a chainlink node to make sure the number is truly random using some cryptography magic it's able to check a number of the parameters that the chainlink vrf started and ended with to make sure that it's truly random it's already used for protocols like avagochi ethercards pool together and a whole bunch of other protocols as well because it is a secure reliable truly provable way to get a random number which is incredibly powerful in a decentralized system so that's how we're actually going to get our random number here so let's work on getting that what we can do is we can go ahead and head right over to the chain link documentation to actually learn how to work with one of these let's go over the chain link documentation just to make sure that we get it right so if we go to the get a random number here we have all the documentation you could ever want so if you ever get lost or confused you can always come right back here to work with it what we're going to do is we're going to deploy their simple version in remix version of working with the chainleaf vrf and we're going to walk through a minimalistic contract to see how it actually works in a contract so once again we hit this remix button remix pops up and we immediately get this random number consumer.soul in our files that we can check out so awesome so here is our files right here we can see that this is actually using a different chain than what we've been using we've been mostly working with rink b but for this demo it's actually on coven so we can do some work with kovin here and remember if you do want to stay with rink b you can always go to this contract addresses section of the vrf and grab these addresses to use so what's going on in this contract how do we actually use this well as you can see the first thing that happens is we're importing some code from the chain link package and our contract is inheriting the abilities of this vrf consumer base contract so we're going to see what functions we're actually going to use that are inherited from this contract and the first thing that we notice is we can see that our constructor in here does some weird stuff it looks like it almost has two constructors so what's actually going on here well let's look at this vrf consumer base.cell contract in the chain link github so we can come to the chain link github here we'll go to evm contracts or depending on when you're watching in this it's migrating to contracts at some point we go to evm contracts we'll go to src so once we're using v0.6 we'll go there and we'll look at this vrf consumerbase.sol as we can see this vrf consumer base that we're importing has its own constructor and it takes an address for the vrf coordinator this is the on chain contract that actually checks to make sure our numbers are random and the address of the chain link token which we'll talk about erc20s in a little bit what we're doing is we're also inheriting the constructor into our contract so this is our constructor for our random number consumer but we can also use the constructor of the vrf consumer base and this is actually how we go ahead and do that we grab the constructor of the vrf consumer base and pop it in here now it's taking two addresses it's taking the vrf coordinator and the link token like i said the vrf coordinator is a contract that's been deployed on chain that's going to verify that the return of the chain link node is truly random and we're going to use the link token as a payment to the chain link node for its services and then we also have a key hash and a fee defined inside of this constructor as well the key hash uniquely identifies the chain link node that we're going to use and then the fee is how much link we're actually going to pay to the chain link node for delivering us this random number now let's talk about a couple things here in ethereum whenever you make a transaction you have to pay some eath gas right or transaction gas this is to pay the smart contract platform a little bit of eth for performing our transaction with a smart contract with a smart contract that operates with an oracle we have to pay some link gas or oracle gas this is to pay the oracles a fee for their services for providing data or doing some type of external computation for a smart contract the question that might then follow up is oh okay well how come i didn't have to pay when we did this price feeds thing well for price feeds somebody had actually already paid for the data to be returned and if we go to data.chain.link and we scroll down we can actually see a list of sponsors here that are paying to get this data delivered so they're already paying the oracle gas to bring this data on chain for us since no other protocol is getting a random number for us we're actually going to have to pay the oracle gas here now in this contract we have a function called get random number which is going to return a bytes 32 and what it's going to do it's going to call this request randomness function which is inherited from this vrf consumer base if we look in here we look for request request randomness we can see there's a function right here called request randomness this function is going to send our oracle fee or the link token and it's going to call this specific to the link token function called transfer and call this function is going to call a chain link node now i'm not going to talk now i'm not going to go into exactly how it's doing that right now but we will talk about it in a little bit so we call this request randomness function and we send the key hash and the fee remember the key hash uniquely identifies the chain link node and the fee is going to be how much oracle gas we're going to pay if you ever get lost on how much to pay or what the contract addresses are you can always head over to this vrf contract section and see where the most recently deployed vrfs are how much the fee is etcetera now here's where it gets a little bit interesting getting a random number actually follows what's called the request and receive style of working with data let's go ahead and just try this out and i'll explain what this means once we see it now we're going to save the answer to this random result variable here and let's just go ahead and try this and see what happens so we're going to switch to our injected web 3 and since we're now swapping to a new test network this means that we have to get tested eth and test that link again we can always look for the link token contracts page to find the most uptodate faucets so we'll scroll down we'll find coven looks like this is the at link faucet and the test and eat faucet so here's our kovin faucet we'll just want to switch from rink b to coven grab our address paste it in send me a hundred test link here's our transaction we can see we're transferring some erc20 we'll take this contract address we'll add it to our metamask by copying the address scrolling down to add token pasting it in here i already have the address in here so i'm just going to go ahead and hit cancel for now and we'll also want some testnet coven ethereum which looks like this faucet has it so we'll paste the address in here i'm not a robot and we'll do send me 0.1 test eth and perfect now that we have some tests on ethereum and some test that link we can proceed we're going to make sure we're on the coven test network and we're going to deploy our random number consumer gist here let's go ahead and hit deploy metamask pops up we're going to go ahead and confirm i didn't explain this fulfill randomness function intentionally you'll see why in a second and great a random number consumer comes up let's check what our random result is right now it's obviously zero because we haven't got a random number so i'm going to do something intentionally wrong because there's a good chance that you'll run into this at some point if i hit get random number right now we see this air gas estimation failed we have plenty of eath why would this fail the reason that it's failing is because the contract doesn't have any oracle gas so we got that gas estimation failed because we need to fund this contract address with some link to actually get a random number so we're going to hit this copy button and this is going to copy the address and we're going to come into our meta mask here and we're going to send this address we're going to paste it there swap to link and we'll send it one link this is probably overkill because as you saw the fee is only 0.1 but we're just going to be overkill for now and great now that this contract has some test net link now we can call this get random number button because we can actually pay the chain link node to actually return our random number so we're going to go ahead and do confirm and this is fantastic so we're paying a little bit of transaction gas to make this transaction to make this request and then we're paying a little bit of oracle gas to make this transaction now so the transaction now so the transaction confirmed but if i hit random result now it's still going to be zero so why is that what's going on well getting a random number like this actually follows what's known as the request and receive cycle of getting data you can read more about it here in this basic request model in the documentation so in one transaction we actually request some data or in this case a random number and then in a second transaction the chain link node itself will make a function call and return the data back to the smart contract in this case the function that we're calling is fulfill randomness it calls this fulfill randomness with byte32 request id which is going to be the request number of when we call this and it's going to return with this random number called randomness so after we wait a little bit if we hit random result now we can see indeed our random number is in here again the reason that it's in here is because we actually had two transaction occur one paid by us when we called get random number and one paid by the chain link node when it called fulfill randomness now i lied to you a little bit technically that vrf coordinator contract calls this function and then the chain link node calls the vrf coordinator function but for simplicity's sake you can kind of just think of it as the chain link node itself is calling this fulfill randomness function so now that we know how to do this from remix let's go ahead and add this to our brownie project so actually before we even do that we need to require so before we even get a random number let's change the state of our lottery so now we'll do lottery state equals lottery state dot calculating winner and while this is happening no other functions can be called right this will lock out nobody can start a lottery and nobody can enter a lottery while we're calculating the winner awesome so now that we know a little bit more about random numbers and everything that we're doing here let's go ahead and try implementing this now so in our chain link smart contract docs of course we're going to scroll down we're going to go to our get a random number bit here we can copy and paste all this code as well into our smart contracts so the first thing that we're going to need to do of course is import the vrf consumer base code let's move back over scroll to the top and we'll just paste this in at chain link slash contracts src v0.6 vrf consumer base and we'll inherit this into our lottery contract so we'll say the lottery is vrf consumer base and it's ownable let's take a look at this vrf consumer base in the chainlink github here if we scroll down to the constructor of our vrf consumer base we can see it takes these two parameters the address of the vrf coordinator and the address of the chain link token we can use a constructor we can use a constructor of a contract inherited in our contract inside our constructor so what we'll want to do is we want to come down to our constructor and right after this public keyword we can add any additional constructors from inherited smart contracts so we'll say constructor and this is our normal constructor and then we'll put vrf consumer base and we'll add the vrf consumer base addresses in here we know that it's going to be a vrf coordinator address and a link token address similar to the price feed these two addresses are going to change based on the blockchain that we're on so it'll probably make sense for us to parameterize them the same way we parameterize the price feed address so in our top level constructor parameters we'll add an address for the vrf coordinator and we'll pass this to the constructor of our vrf consumer base then we'll also grab an address for the link token so we'll do address link and we'll pass this to the vrf consumer based constructor as well great what else do we need to make this work well back in the documentation we can see we need a fee and a key hash the fee is associated with the link token needed to pay for this request so we'll make a public variable uint 256 public fee since this might change blockchain to blockchain we'll have this as an input parameter as well so we'll do uni256 underscore fee and in our constructor we'll do fee equals underscore fee we'll set our global variable to fee and i need a comma here and no semicolon here what else do we need well we need a key hash the key hash is a way to uniquely identify the chain link vrf node so create another one we'll do bytes 32 public key hash we'll add this as a parameter in here bytes32 keyhash and then we'll say keyhash equals underscore keyhash perfect our contract is coming along great here now that we have the main pieces that we need how do we then request this random number well if we scroll down in the documentation we can see we have this request randomness function that we need to call if we scroll back to our vrf consumerbased contract this request randomness function is a builtin function from the vr of consumer base so our contract can natively call this request randomness function right in our contract and you can see it takes a key hash and a fee as its parameters so right in our end lottery function we can add this function and we can see this also returns a bytes32 called request id this return syntax is pretty powerful you can actually identify the name of the variable you want to return right in your write in your function declaration so by saying bytes32 request id we're saying we're going to return a bytes32 variable named request id so right in our function here we can do request randomness because again that's this function that we're importing passing it the key hash and the fee this will return a bytes 32 called request id so this is actually doing this and having our function having our function declaration tell us that there's going to be a variable name request id is going to be exactly the same as if we did bytes 32 request id equals request randomness now this function call follows again what we've talked about as the request and receive mentality the request and receive architecture this means that in this first transaction we're going to request the data from the chain link oracle in a second callback transaction the chain link node is going to return the data to this contract into another function called fulfill randomness so again if we look back in our vrf consumer base we can see it has this function raw fulfill randomness we can read some of the comments in here saying raw fulfill randomness is called by a vrf coordinator when it receives a valid vrf proof raw fulfill randomness will then call fulfill randomness so there's a little bit of contract tag going on but it's going to eventually call this fulfill randomness function which is going to be what we define in here and that's how our contract is going to know what to do once it gets the random number back so in our first transaction we're going to end the lottery request a random number and then a second transaction later on once the chain link node has created a provably random number it's going to call a second transaction itself based off of what we define we just have to call it fulfill randomness and as you can see it takes a byte 32 request id and a random number so in here we'll do fulfill randomness it takes a byte 32 request id and then a uin256 randomness we don't want anyone else to be able to call this function we only want our chain link node to call this function so we can return a truly random number so we're going to make this an internal function it's internal because actually the chainlink node is calling the vrf coordinator and then the vrf coordinator is calling our fulfill randomness so we'll make this internal so that only the vrf coordinator can be the one to call and return this function and then we're going to give it a keyword of override this override keyword means that we're overriding the original declaration of the fulfill randomness function our vrf consumer base has a function fulfill randomness defined but it doesn't have any parameters or anything about this function actually laid out this function is meant to be overridden by us and that's exactly what we're doing right here so in this fulfill randomness function let's go ahead and define what's going to happen once we get this random number back so before we can process this random number let's just check to make sure we're even in the right state so we'll do require our lottery state is going to be equal to lottery state dot calculating winner and if we're not in that state we'll just say you aren't there yet my auto format is is on for this one so it's uh it's jumping in then let's just do another check to make sure we actually get a response so we'll do require underscore randomness is greater than zero and if it's not we'll just say random not found now we need to pick a random winner well we need to pick a random winner specifically out of our list of players our list of payable public players so our players array is just a list of players so it's like one player one player two player three player four and they're each at a different index what we can do then to pick a random winner is to do what's called a modulo function in fact let's even open remix to do an example of this remix let's pop open a new contract we'll call it mod.sol do pragma solidity carrot 0.6.6 we'll do contract mod and in here we'll do a constructor blank constructor and we'll get a global variable you went 256 number and we'll set it equal to 5. and we'll go down to 0.6.6 save compile and you know let's even just get rid of the constructor let's now create a function called do mod we'll take a un256 mod value make this a public function public view returns ui 256 and we'll just return 5 modulo mod value now let's go to javascript vm we'll deploy this we'll go in here so our number is right now five and let's learn about how the modulo works if we have this do mod function what we're doing is the module divides by the number and returns the remainder for example if we did 5 mod 5 what do you think we're going to get so we're going to do 5 divided by 5 and then return the remainder well 5 divided by five is one and there's no remainder there's no decimal there so five mod five should be what zero exactly well what's five mod four then well four can go into five evenly once but there's one number left over so five mod four is going to be one five mod three is going to be two five mod one is going to be zero right since one goes with everything this is how the mod function works and it's this little percent here we can use that mod function in our fulfill randomness with the length of our players so we can say uint 256 index of winner is going gonna be equal to the random number that we got modded by the players dot length so let's say for example we had seven players sign up and our random number was 22 well we want to get one of these random seven players so we would do 22 mod 7. 7 divides evenly into 22 three times with one left over seven times 3 equals 21. difference between 21 and 22 is 1 7 times 4 is 28 so we know this is how we know we've reached our upper limit so this is how we can get a random number based off of the index now that we have this index what we can do is we can say the winner equals players of the index of winner and just to keep track let's make a new variable called recent winner at the top we'll do address public recent winner we'll grab this recent winner instead of winner we'll say recent winner equals players and this index of winner here now that we've got a winner wallet we want to pay them all the money gathered from our enters here so what we can do is we'll do this recent winner dot transfer the entire balance of this address so we'll say address of this that balance and perfect we'll transfer them everything that we have then of course we're going to want to reset the lottery so that we can start from scratch we can start blank again so we'll do players equals new address payable array of size 0. so we're just resetting players to just be a brand new array then we're going to change our lottery state to being lotterystate.closed because the lottery is now complete and i often also like to keep track of the most recent random number so at the top i'll do a uint 256 public randomness variable and in our fulfill randomness i'll say randomness now equals underscore randomness and perfect we now have a contract here of course we haven't actually tried it out but we're assuming that it works great so you know what this means it's time to go into testing mode testing and development mode but let's even just try to do a brownie compile first looks like we have an issue here send and transfer are only available for objects of type address payable not address oops looks like we made our recent winner just an address but it needs to be an address payable so let's try browning compile again and beautiful we at least know it's compiling so that's a great sign let's now move into our testing and development phase as you are starting to figure out we can ignore these file import callback not supported bugs and vs code for now i'm sure the solidity linter will get better as time progresses but great so now let's go ahead and move into actually testing and working with everything here so let's go ahead into our scripts and we'll make a little deploy script first let's do a new file call it deploy lottery that pi and let's go ahead and deploy our lottery so same as always we'll do def main we'll come with a new function called deploy lottery and then we'll do def deploy lottery and then we'll just have a pass for now and if we run this brownie run scripts deploy lottery.pi our default network is not defined which means the default is going to be development and we can even verbose here develop meant write that in our brownie config run this gnosh will get spun up and nothing will happen because our deploy lottery function doesn't do anything right now awesome the first thing we need always to deploy a contract is we need an account so we'll do account equals and we've been using this getcount function for some time that we've been adding in a helpful script section so that can pull from a real test net or from a local development environment if we like so to do this of course let's create our new helpful scripts dot pi we'll create our underscore underscore init underscore underscore dot pi so that python recognizes it as a package and in here we'll create a new function f get account for now we'll just have it pass we'll copy this into our deploy lottery we'll do from scripts.helpful scripts import get account now this now this is what our get account looked like in our last project along with that we had these forked local environments we also had from brownie imports accounts and network and config to make this look really nice right let's flush this out just a little bit more so it's even more robust right now as we know we have a way to use brownies ganache accounts and we have a way to use our environment variables however there was a third method that we learned that isn't identified here accounts.load and this is with our id if you still have your account and you still have all your brownies set up if we do brownie accounts list you'll see we have a couple accounts here we want our get account to be even more liberal so that if we wanted to use one of these as well we could so let's modify our get account script here a little bit let's first get rid of this else and rid of this indent what this will do is this will be our default if nothing that we define prior to this is defined we'll just default to grab right from our config which since we are doing that let's create our dot env we'll paste our different variables in here our private key web 3 and fura and etherscan token and in our brownie config of course we'll do wallets from key private key and now let's flesh this out a little bit let's add an index and an id index equals none and id this way if we pass an index to our get account function we'll just use an index from this accounts variable if we pass an id we'll have trying to do this accounts.load here so now let's change this up a little bit we'll say if an index was passed we'll just return accounts on that index otherwise if we're doing a local blockchain we'll just return account to zero but if there's an id we'll return accounts.load id whoops we need to actually move this up a little bit so that it's before our local blockchain checking so now in our deploy lottery we could do something like get account id equals free code camp oops and this is actually free code account precode camp account let's try one more time it's going to ask for our password here now we have a much more liberal get account function so now that we have a count we can actually deploy our lottery so we'll say lottery equals lottery.deploy and this is where we're going to import from brownie import our contract lottery and we're gonna have to add in all these different variables so if we go back over to our lottery contract we need to give it a price feed address a vrf coordinator a chain link token a fee and a key hash now the way we did that in fund me is that we did it in a way where we checked to see if we were on a local chain or not if we weren't on a local chain then we would just pull our addresses directly from our config if we weren't on a local chain though we'd deploy some mocks and use the address of those mocks we're going to want to do the same thing here but let's make our lives a little bit easier we can take this whole process and put it into its own function so let's make this a little bit easier mentally the first thing we're going to need is this price feed address if we're on a real test net of course we would just go into our brownie config and add the address which we will do we'll add our rink b network here in a little bit but for now don't worry about that but if we're not on a wrinky chain what we're going to need to do is deploy our mock we're going to wrap all of this mocking and checking into a single function called get contract and we're going to add this function in our helpful scripts so let's create this function called get contract do def get contract pass let's talk a little bit about what we want this function to do let's add one two three three double quotes here and three double quotes here to start what's called a doc string this will define everything about this contract so we're just going to say this function will grab the contract addresses from the brownie config if defined otherwise it will deploy a mock version of that contract and return that mock contract for the arguments of this chain we're going to take a contract name this is going to be a string and it'll return a contract or in particular it's going to return a brownie dot network dot contract dot project contract the most deployed version of this contract so for example if we have a mock v3 aggregator contract it'll do the most recently deployed version of that with this 1 syntax now this get contract function if this is a little confusing to you again we're going to go over this chain link mix in a little bit and inside of this it has a more robust description of what's going on in this get contract bit so you can check that out if you want to learn more but let's go ahead and actually define this so we obviously want a contract name as an input parameter so let's go ahead and add contract name in here meaning that this getcontract function we'll get something like f usd price feed right that's gonna be the same as what's defined in our browning config and from this name we're gonna get the type of contract that it is contract type and to do that we're gonna have to create some mapping that'll map the contract names to their type so right above we're gonna do contract to mock and we're to create a mapping in here which will map everything out so an fusd price feed is going to be of type mock v3 aggregator so we have to import mock v3 aggregator from rounding so now we're saying anytime you see fusd price feed you know that that's going to be a mock v3 aggregator if we need to deploy a mock so we'll say contract type is going to equal contract to mock of the contract name now we need to check okay do we actually even need to deploy a mock so sure let's check if we're on a local blockchain so we'll say if network.showactive is in our local blockchain environments and we'll skip the forked local environments because again we don't need to deploy a mock price feed address on a fourth local environment which say if network.showactive is in the local blockchain environments then we'll check to see if one of these contracts has already been deployed we'll say if the length of contract type is less than or equal to zero then we're going to go ahead and deploy mox so this is equivalent to doing something like mach v3 aggregate or length we're checking how many mach v3 aggregators have actually been deployed if none have been deployed we're going to go ahead and deploy them so we're gonna have to create this deploy mox function so we'll do def deploy mox and this is gonna be the same as what we did in our brownie fund me right it's gonna be the exact same so we'll say account equals get account i'm not going to put the prints in here but you absolutely can we'll say mock price feed equals mock v3 aggregator dot deploy we'll need to give this some decimals and an initial value so right above we'll do decimals equals eight initial value equals two thousand one two thousand one two three four five six seven eight and in our deploy max we'll say decimals equals decimals initial value equals initial value to deploy decimals and initial value of course this is going to be from account and for now that's it i'll say print deployed all right great so now we have a way to actually deploy the mock price feed here so let's go back up to our get contract function so we have a way to deploy the mock if one already isn't deployed now what we're going to want to do is we want to get that contract right we're going to want to get that mock so we'll say contract equals contract type minus one right so this is going to be equal to doing mock v3r gregator minus one this is saying hey let's grab the most recent deployment of the mock v3 aggregator which is exactly what we want perfect so this will work perfectly for our development context however we're not always going to just want to deploy to a development network we're also going to want to deploy to testnets so then we'll say else and this is where we'll just grab that contract from the running config for example fusd price feed so we'll say contract address equals config networks network.show active and that contract name for example again if it's fusd price feed it'll be fused price feed here and the way we're setting it up it's got to be the same as what's in our contract to mock dictionary here so up here the way that we did it was we actually got the contract because we had its contract type based off of browning for here we're gonna have to interact with the contract getting those two pieces that we always need which are gonna be the address we actually have the api from our mock v3 aggregator type right here and we just got the address so we can create this new contract type by saying contract equals contract dot from abi and this contract package can be imported right from brownie and it has this function from abi that allows us to get a contract from its abi and its address so we'll just give it a name we can say contract type dot underscore name we do the contract address and then the contract type dot abi so these mock v3 aggregators and all these contracts have a dot avi attribute that returns the api they also have a dot underscore name which returns their name so this is perfect this is how we'll get the contract otherwise and then at the end of all this we'll just do return contract awesome so this is an incredibly powerful function for us to get a contract based off of if it's already deployed as a mock or it's a real true contract i know there's kind of a lot here but definitely check the github repository if you're a little bit confused on what's going on with this function and let's and let's also just deploy this to make our linter happy why not yeah vs code's happy now but now that we have this function let's go back to our deploy lottery now we can do a comma get account and now we have a get account function so let's go through this again this lottery.deploy getaccount is going to get an fusd price feed if we don't have a mock deployed it's going to deploy a mock price feed for us and we're going to return that mock price feed however if we're on a test net if we're on a real network we're going to grab its actual address and return a mock contract of it our mock contract here has all the same functions of a regular contract so we can just use it as the same this way we don't have to adjust this function for whether or not we're deploying to a test net or to an actual address the only additional piece we should put in here just for clarity is we should add dot address here because this is going to return the actual contract and we really only want the address this is going to make our coding a lot more robust for moving between development environments and test environments and working with scripts in a really effective manner so now that we have this incredibly powerful function let's go back to the lottery and figure out what are the different pieces we need in here okay great we also need a vrf coordinator so to do this we're going to go back to our docs.chain.link we'll go to contract addresses and we could do mainnet here but let's also just set this up to work with rank b so we'll do ctrl f for rink b vrf coordinator is going to be this address right here so we'll copy it we'll go back and we're going to have to do in our config is we're going to have to add a new network here for rank b we'll do vrf core data nato will be that address right there and then while we're doing this let's also get the rink b address for our price feed so ethereum price feeds rink b let's scroll down for fusd fusd here we go grab that enter this will be f usd price feed face adder sit here perfect so now we can do get contract vrf coordinator dot address of course we are gonna have to go back to our helpful scripts because there's currently no mapping between what a vrf coordinator is and what its mock needs to be so we'll add a comma here and we'll do vrf coordinator and we need to get a mock vrf coordinator well first of all we don't even have our mach v3 aggregator so let's go grab that as well so we can grab both of these again i'm going to highly recommend going to the chain link mix going into the contracts here going to the test folder for these different mocks because these are already set up to work with the chain link mix however you can definitely go into the chain link github as well go to contracts src 0.6 tests and then look for the different mocks in here so mock oracle vf coordinator mock et cetera so we're just gonna i'm just gonna grab it though from this chain link mix so let's go to vrf coordinator mock and i'm just gonna grab this whole thing here so i'll do contracts new folder test new file vrf core core moc.sol paste it in here and then while we're in here we want to do new file mock v3 ah greg sol we'll grab this as well from our chain link mix again it's got all the functions of a price feed update answer latest round etc vrf coordinator walk has different functions for actually working with the vrf coordinator one of the specific ones in particular is this callback with randomness that we're going to use in our tests so our vrf coordinator is going to get mapped to our vrf core nator mock which will also import this from brownie great and just to double check everything's working we'll want to run just a quick brownie compile make sure we are importing our mocs correctly and everything is compiling so it looks like we're good there all right so now we have git contract vrf coordinator dot address perfect what else do we need in here we need a link token the chain link token is of course just another smart contract so we're going to do the exact same thing here get contract link token dot address of course this means in our config for rink b let's add a link token address we'll go to the chain link documentation go to link token contracts look for rink b we'll grab this address we'll drop it in here perfect now we have it in our brownie config we'll also need to add it to our helpful scripts so we'll need a mock link token which again we can just go ahead and grab from our chain like mix here so we can go to test and as you can probably see what i often normally do is literally just copy this entire test folder project to project so i'm going to copy this whole thing create a new file we're just going to call this one link token.sol contract link token perfect and then in our helpful scripts we're going to have this be linked token and of course we're going to import this from brownie great git contract link token.address perfect what else do we need we need a fee and a key hash so the fee and the key hush are both just numbers right these aren't actually contracts so we don't need to put this through that get contract bit what we can do is just in our config and our development network we just add a default for the key hash and for the fee i'm just going to set my development key hash and fee equal to the rink b ones so to grab those go to the chain link docs once again we'll scroll down to using randomness contract addresses we'll look up rink b we'll grab the key hash here which we'll paste in for both are development and rink b and then the fee it says 0.1 link so we'll just do that in way here which will be one one two three four five six seven eight nine ten one two three four five six seven and we'll do this line for ring p as well now in our deploy lottery we can just grab this directly from a browning config because we're always going to have this default key hash and this default fee here for our development network so we'll do config networks network dot show active which one's first the fee fee of course this means we're going to grab network from brownie and also config then we'll do config networks network dot show active and then of course our last bit here from account and then additionally as we learned last time if we want to publish this we'll do publish source equals config networks network dot show active we'll say dot get verify and then we'll add this false bit here what this is saying is get that verify key but if there's no verify key there just default to false this way if we don't set a verify key in development that's fine it just won't get verified for ring b let's go ahead and set verify to true so we can actually verify this on the rigby chain and then we'll even do a print statement here deployed lottery all right lovely let's try this out we'll do brownie run scripts deploy lottery.pie we won't set a network flag so it will go to the default development network let's try this out things are compiling ganache is spinning up it looks like we did run into a little issue here with our our get contract function ah of course we forgot to add deploying these mocks in our deploy mock script whoops let's go ahead and add that as well right now our deploymox only deploys the mach v3 aggregator so let's add the rest of our mocks in here we're going to need to deploy a vrf coordinator mock and a chain link token mark so let's open up those contracts see what they need a link token for a constructor doesn't have a constructor so we can just have it be blank so we'll do link token dot deploy and all we need is a from account here and then let's see what that vrf coordinator mock takes prf coordinator mock it takes the link token as an address perfect so then when we deploy the link token here we'll say link token equals link token.deploy and then we'll do vrf core donator mock dot deploy ploy and then we'll use the link token.address as an input parameter and then of course from account all right so now we're deploying all three of those mocks right away let's try this again brownie run scripts deploy lottery.pi ganache is spinning up perfect so we can see here that our mach v3 aggregator was deployed then our mock link token was deployed then our mock vrf coordinator was deployed and then our lottery was deployed with those mocks defined and we deployed the lottery awesome now we could 100 percent go ahead and then run this script on an actual test net right because our config is set up well let's write some more functionality for actually interacting with this lottery before we actually do that and then we can actually just run a script which will do all this functionality end to end because again deploying to testnet takes a long time and we really only want to do that when we're done and we're fairly confident that everything's working well let's even just delete this here so now what's the next thing that we'd want to do here what's the next thing we want to do in a script here well we'd probably want to go ahead and start the lottery so let's write a script that can actually do that we'll do def start lottery and then here we get our account equals get account we'll say the lottery is going to be the most recent deployment of the lottery and we're going to call this start lottery function here this is indeed changing state so we do have to make a transaction we'll do lottery let's start lottery we'll say from account then we'll do a little print and just say the lottery is started and then in our main function down here we can even call this start lottery function so if we run this again on our development chain we'll see if everything works smoothly here okay we did run into an issue and this is something that you'll see from time to time typically the workaround is you want to wait for that last transaction to actually go through so we'll say starting transaction equals lottery.start lottery it will do starting transaction.weight 1. brownie sometimes gets a little confused if you don't wait for the last transaction to go through so let's try it again and perfect we do get this working as intended so that is really helpful helpful tip if you run into those weird issues you'll notice that even when we didn't have this it's still completed successfully i just got a little confused at the end all right cool so what do we want to do next well we probably want to enter the lottery let's do def enter lottery so how do we enter the lottery say account equals get account lottery is going to be lottery minus one we need to pick some value to send when we call the enter function right because we need to send that entrance fee with it so we'll say value equals lottery dot get entrance fee and just to be safe i usually will tack on a little bit of whey as well because sometimes it might be off by like one or two or something like that so we'll do lottery. get entrance fee plus you know maybe something like this which is like barely anything then we'll do transaction equals lottery.enter do from account send a value which will be value we'll do tx.weight and then we'll do print you entered the lottery and we'll do this enter lottery bit down here too enter lottery we'll run this see if our enter script is working appropriately you entered the lottery looks great and let's do our last function here we'll do def end lottery count equals get account lottery equals lottery minus one we'll make a transaction which will be lottery dot end lottery now before we actually end this lottery we're going to need some link token in this contract because remember our end lottery function calls this request randomness function and we can only request some randomness if our contract has some chain link token associated with it so we're going to need to first fund the contract and then end the lottery since funding our contracts with the link token is going to be a pretty common function that we use let's go ahead and turn this also into a helpful script so let's go to our helpful scripts we'll make a new function called fund with link and let's have this take a couple of parameters so first we'll want to have a contract address of course we'll want to know who we're going to fund with link we'll set a default account to being none so if you want you can send an account but you don't have to if you don't want to we'll also do the same thing with a link token we'll say if you want to use a specific link token you can otherwise we'll just grab it ourselves and then we'll also do a default amount which we'll set to 1 one two three four five six seven eight nine ten one two three four five six seven which is going to be 0.1 link so first let's get an account we'll say account equals we're going to do a little clever python stuff here we'll say account equals the account if somebody sent it if account so we're saying the account that we use is going to be this account thing if this account thing even exists otherwise we'll call our get account otherwise we'll just do our regular get account function then we'll do the same thing with the link token say the link token is going to be equal to the link token that somebody supplies as a parameter if they applied something as a parameter otherwise we'll just do that get contract stuff that we did before of the link token now that we have this link token contract from our get contract function which again is basically the equivalent of doing which again is doing this contract up from abi on our link token pulling from our config or from our mock now we can just call the functions on this link token so we can say our transaction equals link token dot transfer we're going to transfer token to the contract address with a certain amount and of course we'll do from account we'll do tx.weight and then we'll do print funded contract and then we'll even return that transaction i do however want to show you another way to work with this using the interfaces instead of doing this linktoken.transfer directly on the contract we can use this interfaces section to actually interact with some contracts so right now we have our mock link token in here which is great because it has all the definitions and all the functionalities defined in here sometimes you're going to have contracts that you don't have everything you don't have all the functionality and maybe you only have the interface maybe you only have some of the function definitions so we can still interact with contracts with just an interface because again that interface will compile down to our api so as another way of teaching us how to actually work with some of these contracts what we can do is we can use we can use the link token interface basically the same way as we used the link token contract here so again i'm in my chain link mix because there's already a link token interface in here and this will compile down to a way that our brownie package knows how to interact with these contracts so if you wanted to we could just grab this go to our brownie section we'll do a new file in interfaces we'll call it link token interface dot soul we'll paste it in here save my auto format auto formatted here and what we can do in our helpful scripts instead is transaction equals interface and we can also just import interfaces right from brownie interface dot link token interface and we just need to give it a contract address so we can say link token dot address excuse me we could say link token contract equals interface dot link token interface link token dot address so this is another way we can actually create contracts to actually interact with them so we saw up here this contract.from abi which is great this is another way we can do that exact same thing so then we can just do linktokencontract.transfer contract address amount from account so this is tx equals so this is another way to actually interact with contracts that already exist you're probably starting to see that brownie has a lot of builtin tools that make it really easy for us to interact with contracts if we have the api we can just pop it into contract.from avi and again with the address and the api and then just give it some name if we have the interface we don't even need to compile down to the api ourselves because brownie is smart enough to know that it can compile down to the api itself and we can just work directly with that interface which is incredibly powerful for now i'm going to comment these two lines though and we'll just use the linktoken.transfer for now now that we have a funding script or a funding function we can import this from our helpful scripts from scripts.helpful scripts import get account get contract fund with link and we can just call in our end lottery function we'll do fund with link and parameters we just we only really need a contract address because the way we set this up we'll just automatically grab a default otherwise so we can say lottery dot address and that's it that's all we need and then i know we're doing tx.weight right in the fund with link but just for to be verbose here we'll get the transaction from the fund with link and we'll do tx.weight here as well and then once we're funded with link then we can go ahead and call our end lottery function because again this is going to call that request randomness function from the vrf we'll do end ending transaction equals lottery dot end lottery and all we have to do is from count to ending transaction.weight one so from our end this is really all that we need to do right but remember when we call this end lottery function we're going to make a request to a chain link node and that chain link node is going to respond by calling this fulfill randomness function so we actually have to wait for that chain link node to finish now typically it's within a few blocks so normally what we can do is we can just do a time dot sleep for something like 60 seconds and typically in that time the chain link node will have responded so we'll just do import time at the top time dot sleep and then we can see who that recent winner is if that chain link node responded with a recent winner so we can say print f lottery dot resent winner is the new winner all right now of course for those of you who are thinking ahead a little bit you might be thinking hey well there's no chainlink nodes watching our local ganache and you're exactly correct so what happens when we add our end lottery function to our main function here do you think that we're going to actually get a recent winner back why are we not what do you actually think well let's give it a shot do brownie run scripts deploy lottery.pie so we're doing a lot of transactions here we've started the lottery we're entering the lottery you entered the lottery we're sending some link token now we just called the end lottery function while we're waiting here this is when the chainlink node would go ahead and start responding with our randomness however as you're probably astutely telling however as you probably astutely guessed there's no chainlink node that's going to call this fulfill randomness function right now so for our grenache chain this will hypothetically end with nothing right because there's no chainlink node actually responding here zero is the new winner of course this means that the chainlink node actually didn't respond because there is no chain link node on our local ganache for our testing purposes we're going to figure out how to actually get around that and deal with that awesome it looks like we have everything set up to be successful in our lottery here but we want to do our due diligence we want to make sure that our tests are really solid on a development chain before we actually test this on an actual test then so let's jump into some of these tests we've already started with this testlottery.pi bit here but we're going to iterate on this and make this even better now before we get into these tests there's a couple of things we want to talk about here and that's going to be integration tests and unit tests unit test is a way of testing the smallest pieces of code in an isolated system and we're going to use it to loosely define testing independent functions in our lottery contract we also want to do what's called integration testing which is going to be testing across multiple complex pieces typically i like to run my unit tests exclusively on a development environment and my integration tests on a test net this is really helpful because we can test the majority of our application like we said on a development network and then still be able to see what actually happens on a real test net and see what happens on etherscan and everything like that typically what people do is in their side their tests folder they'll create two different folders one for unit and another folder for intergration since for this demo we're only going to have one file for both i'm just going to go ahead and not create these folders but but it's a pretty common practice instead what i'm going to do is i'm going to rename this i'm going to hit enter to rename it i'm going to do underscore type unit for unit tests and we're going to create a new file called test lottery integration dot pi so this one we'll do our integration test and in this one we'll do our unit tests now when writing unit tests we really want to test hypothetically every single line of code in our smart contract this is incredibly important of course because smart contracts are open to everybody to see and interact with so we really want to test every single line of code we have in here so let's go ahead and let's go ahead and finish writing a get entrance fee test that will work on a local development network as you can see we're already going to have to refactor this from what we originally had let's go ahead and just delete everything under here for now we already learned so much more from there all right so how are we going to test this get entrance view function now so first we're going to want to deploy our lottery again since we have a deploy lottery script already we can just use this deployed audio script as well if we wanted to we could just copy paste this hold part into our test but we're just going to go ahead and work from this deploy lottery script so we're going to import this and then we can actually even get rid of this from web3 line for now we can get rid of these two comments too and we'll say from scripts that deploy lottery import deploy lottery and on this deploy lottery function would say lottery equals deploy lottery and we will return our lottery now our unit test we'll say lottery equals deploy lottery and this will give us our lottery contract once we have our lottery contract we can just call this get entrance fee so we can say entrance fee equals lottery dot get entrance fee and oops let's just make sure we're doing the arrange act assert mentality here and we're going to want to make sure this entrance fee is what we expect it to be so what do we expect it to be well again our helpful scripts is going to deploy these mocks right it's going to deploy this mock and the initial value is this 2000 number so if the price of eth here is 2 000 2 000 f usd feed and the usd entry fee is 50. we'd say 2 000 over 1 is equal to 50 over x which is going to be equal to 0.025 so we can go ahead and even do this math here we can say expected expected entrance fee is going to be equal to it's going to be equal to 50 divided by 2000. we'll just do 0.025 but we'll do this in way so do from web3 import web3 we'll say this is web 3.2 way 0.25 ether and now we'll assert our expected entrance fee equals the entrance fee now to test this we'll do brownie test k and perfect this is working exactly as we anticipated so that's awesome now as we mentioned since this is a unit test we really only want to run this when we're working on a local environment a local blockchain environment or a local development network so we'll go ahead and do this with pythons again so if network dot showactive is not in local blockchain environments pi test dot skip of course we're gonna have to import pi test we're gonna have to import this local blockchain environments from our scripts.helpful scripts my vs code automatically added that bit here now if we try to run this brownie run excuse me brownie test dash k get entrance fee dash dash network rank rink eb it should go ahead and skip this perfect that's what it does what's the next piece that makes sense here enter is going to be one of the first things that these developers do so let's do test def test enter but let's even be more specific than that we don't want people to be able to enter our lotteries unless the lottery is actually started so let's make sure that this line actually works so we'll call def test can't enter unless started and again we're only going to run this on a local development chain so we'll just copy paste this section down here we'll say lottery equals deploy lottery because we're going to want to work with the lottery and now we're going to want to that when people try to enter a lottery that hasn't started yet it's going to revert so we can use what we've used before we'll say with pi tests dot raises exceptions dot virtual machine error lottery dot enter from get account value lottery dot get entrance fee of course we're going to import both get account from our helpful scripts and exceptions from ronnie perfect and this as well is following the arrange and this is actually act slash assert so let's go ahead and test this brownie test k test can't enter unless starter oops let's do start ed and great that's passing as well let's go ahead and keep going down this list what else now we've tested whether or not they can't enter let's test whether or not they can enter so we'll do def test can start and enter lottery so we're going to copy this again paste it down here since we're going to work on a local blockchain we'll do lottery equals deploy lottery account equals get account we'll start the lottery lottery.start lottery we'll do from account we'll do lottery.enter from account save value is lottery dot get entrance fee and then we'll assert that we've correctly added a player to this lottery so we'll assert lottery.players of zero is going to be this account right because we have our players array and we're going to assert that we're pushing them onto our array correctly lottery.players 0 equals account so here's our act here's our assert so let's try this now brownie test dash k test can start and enter lottery and once again awesome things are looking great now let's test to see if we can actually end a lottery so we've tested we can start a lottery so we'll do def test can and lottery we're going to copy this again paste it down here do lottery equals deploy lottery account equals get account we'll start the lottery with lottery.start lottery now we could 100 just import the rest of these functions in here like n lottery enter lottery and start lottery and similar to how we're just doing lottery equals deploy lottery we could absolutely do that for being very verbose here i'm just going to go ahead and write all the functions and transactions myself and this way we'll actually be able to test a little bit more granularly anyways we'll do lottery dot start lottery from account do lottery dots enter from account we'll give it a value lottery dot get entrance fee so i'm gonna have to do account course equals get account now to actually end the lottery we do need to send this some link because we're calling request randomness we use our fund with link script that we have in our helpful scripts we'll import this from our helpful scripts we'll call fund with link on our lottery contract once we fund with link we'll then call lottery dot end lottery from account and then how do we actually know that this is being called correctly well if we look back in our lottery contract here when we call end lottery we don't we're not really doing a whole lot all we're doing is changing our state so let's go ahead and check to see if our calculating winner state is different so we'll say assert lottery dot lottery state is equal to what so calculating winner if we scroll up to our enum is in position two open is zero close is one calculating winner is two so we can say assert lottery.lotterystate equals two two we can go ahead and test this as well we'll do brownie test k test can end lottery we'll see if this works and it does now let's test the most interesting piece of this entire lottery contract we're going to test whether or not our fulfill function actually works correctly does this correctly choose a winner does it correctly pay the winner and does it correctly reset so let's go ahead and build our most complicated and most important test of this whole contract choosing the winner we'll do def test can pick winner correctly let's copy paste this bit about getting started we'll do lottery equals deploy lottery account equals get account we'll do lottery dot start lottery from account and then we'll enter with a couple different players we'll do lottery dot enter let's say from account value lottery dot get entrance fee enter and we'll copy this two more times but instead we use some different ids we'll do index equals one and we'll do index equals 2. these are going to be different accounts here because we're going to use a different index because we want to just test for multiple different people here this unit test is getting drastically close to being an integration test but as i said we're being a little bit loose with the definitions here now we're going to want to fund it with link so we can just go ahead and copy this line here fund with link lottery and now we're going to want to choose a winner here and this is where we actually have to modify one more thing in our lottery contract so in order to test actually calling this fulfill randomness function and testing everything in here we're going to need to call this fulfill randomness function now if we look at our vrf coordinator moc we have this function called callback with randomness and this is the function that actually calls this raw fulfill randomness.selector which eventually will call that fulfill randomness function but this is the entry point that the that the node actually calls we have to pretend to be a chainlink node and call this function we're going to return a random number of course we're going to choose the contract we want to return to but we also have to pass the original request id associated with the original call now in our lottery contract our end lottery function isn't going to return anything and even if it did it would be really difficult for us to get that return type in our python so what we want to do to keep track of when this contract actually entered the calculating winner state is we want to do what's called emitting an event events are pieces of data executed in the blockchain and stored in the blockchain but are not accessible by any smart contracts you can kind of think of them as the print lines of a blockchain or the print statements of a blockchain we can go to this logs section which also includes all the different events now there's a lot of information here so we're actually going to do an event ourself just so that we can see what this really looks like you can see here that when we call this end lottery function in the logs if we scroll to the bottom there's an event here called randomnessrequest this was spit out by the vrf coordinator this was spit out by the vrf consumer base that we inherited and it even has some data that's already been decoded one of those pieces of data is the request id now to add an event we first need to create our event type so at the top we'll go ahead and do event requested randomness we'll say bytes 32 request id so now we've identified a new type of event called requested randomness it's really similar to the enum in this regard to omit one of these events all we have to do in our end lottery bid is we'll do omit requested randomness and then request id because requested randomness takes a bytes32 as an input parameter and we're going to pass it that request id as an input parameter now that we have this event being omitted back in our test when we call end lottery it will actually omit one of these events to our transaction so what we can say then is transaction equals lottery.nd lottery same way we've always done it but now we can look inside of this transaction object inside of this transaction object is actually an attribute called events which stores all of our events we can then look for a certain event name which we know is requested randomness so we'll say out of all the events look for the requested randomness event and in there in that request randomness event find the request id request id now we can say request id request id is going to get grabbed from this event that we omit so these events are going to be really helpful for writing tests these events are also really helpful for a number of other reasons one of the big ones is is upgrading our smart contracts or understanding when a mapping is updated but for now we're going to be using them for testing now that we have this request id what we can do is pretend to be the chain link node and use this callback with randomness function to dummy getting a random number back from the chainlike node so what we're going to do is we're going to call our getcontract function and get that vrf coordinator of course we're going to import it from our helpful scripts and we're going to call that callback with randomness function so we're going to do dot callback with randomness and we need to pass it this request id a random number and then the contract to return to so we'll do request id we'll do some random number like we'll say static rng equals 777. so we'll say the random number that we're going to return is going to be 777 and then we'll do lottery dot address because we're going to return it to the lottery once again we're going to say from account because this is making a state change and now that we've got a call back what we can do is do our asserts now so this is us dummying getting a response from a chainlink node and this is how we mock responses in our tests to make our lives way way easier so now we can do we can figure out who the winner of this lottery actually is if these are our three enter entries that means it's 777 mod 3 since our random number is going to be 777 if we pull out a calculator 777 divided by three it divides evenly so we know that this means the answer to this is going to be zero aka our account is going to be the winner so let's assert the lottery dot recent winner is going to be equal to our account right because we set a recent winner in here we transfer them some money we'll assert lottery.balance is now zero because we're transferring this account all the money and let's even make sure that the account gets more money right so we'll do starting balance of our account starting balance of account equals account.balance count balance and we'll do balance of lottery equals lottery dot balance and then we'll assert account dot balance is now going to be these two added together started balance of account plus the balance of the lottery because we should get all of the lottery winnings here okay so this is a long test but this is probably the most important test let's make sure this is doing what we wanted to do so we'll do brownie test k test can pick winner correctly let's see if this works oops i forgot to put a put some parentheses here let's parentheses here let's try this again and perfect we are actually updating paying out and running our lottery correctly and fairly with true randomness this is incredibly exciting and we've emitted events in our lottery contract to use in the off chain event logging of ethereum i know we're getting antsy to actually run this on a real chain so let's go ahead and do our last bit here create our integration test which we will run on an actual chain and then if we wanted to we go ahead and try our deploy lottery function on a real chain as well all right so let's do our integration test here this is where we're going to actually test on a real live chain we're going to use ring because that's the network that we've been using this whole time which is great now i'm being a little bit liberal in the way that we're doing our tests here and we're just going to do one test for this integration test but keep in mind you're going to want to test every piece of your code so let's just create a test called def test can pick winner now this is going to be the opposite of our unit test our unit tests are only going to be on our local blockchains right we're going to skip if it's not on our local blockchains we're going to do the opposite of this one so we can even just copy this or we can type it out we'll say if our network dot show active is in those local blockchain environments then we're gonna do pi test dot skip of course since we're grabbing these pieces we're gonna do from brownie import network we're going to import pi test and we're going to do from scripts dot helpful scripts import local blockchain and by enronments we're going to deploy our lottery so lottery equals deploy lottery which we're just going to grab from scripts deploy lottery import deploy lottery we'll do account equals get account of course we're going to grab that from our helpful scripts as well so we'll do lottery let's start lottery this will be from account do lottery.enter say this will be from account we'll do some value which is going to be dot lottery.get entrance fee and if we run into an issue here sometimes again we can do lottery dot get interest fee plus like 100 or a thousand or something like that this is going to be barely any way but for now let's keep it like this then let's just copy this line right again we'll have two people enter the lottery of course it's going to be us both times and great now we're going to want to actually end the lottery so first we're going to want to fund it so let's import that funding script so we'll get fund with link or that function so we'll call our fund with link function on our lottery contract here and then we'll go ahead and end the lottery so we'll say lottery dot and lottery we have to do this from our main account we have to do this from the admin account now this is where it's going to be a little bit different from our integration tests or from our unit tests in our unit tests we pretended that we were the vrf coordinator and we called the callback with randomness we pretended that we were a chainlink node here we're not a chain link node because we're on an actual network so we're actually just going to wait for that chain link node to respond so for simplicity we'll just do time dot sleep and we'll wait like a minute for it to respond of course since we're using time we're going to want to import time right at the top and then since account was the only one to actually be in this we'll do assert lottery recent winner equals equals account and we'll also assert lottery.balance 0. all right great so we have an integration test that we can run which is going to run through pretty much the vast majority of our functionality here so we can go ahead and test this with brownie test will be a little bit verbose here we'll say dash k test can pick winner and then of course we'll do dash dash network rink b now before we run this per usual we got to make sure do we have any test that ring the ethereum we do great do we have any test net chain link we do perfect we have a dot env we do it's got all of our pieces let's check our brownie config dot env dot env awesome and again if you don't want to use the dot envy you can use that other method that we showed you guys how to encrypt with a password that you can actually use oops before we run this let's set this to start lottery because that's the actual function here and we'll also need to be lottery.balance with parentheses here sorry about that and now we can run brownie test dash k fast can pick winner dash network rink b we'll also add this dash s flag which will print out whatever brownie is going to be printing out make everything a little bit more verbose here and if you want to you absolutely should because this is something that we'll have to do at some point anyways however if for this tutorial you want to skip it go ahead because we're actually going to run through this whole process of deploying and waiting again anyways so now we've added all of our tests what we can do is run our entire test suite so we'll do brownie test and this is going to run through all of our development tests here you'll see it'll go really quickly and you see how much faster it is for us to run our test on a local chain as opposed to doing everything on a test map so it's going to make your life way easier and we have everything passed here so we know that our contract code is doing approximately what we wanted to do so it's time for the moment of truth let's deploy this to an actual test net so we have our deploy lottery script which oftentimes i'll have it be just this deploy lottery bit and then i'll have some other scripts for these other pieces or maybe i'll do it in the brownie console but just to demonstrate everything end to end we'll have deploy lottery start lottery enter lottery and end lottery all in this one script so that we can see everything end to end and see what it looks like on etherscan so let's go ahead and run this script on a ringbeat network and then we'll go jump onto etherscan and see everything so let's do it brownie run scripts deploy lottery network ring can be so first we went ahead and we deployed our lottery we got our addresses with our get contract method we got our fee we got our key hash we got our published source and everything here then we went ahead and verified it because of this published source so if we grab this address lottery deployed here we jump over to rank the ether scan paste this address in here we'll see this contract with a little check mark is verified again we'll go to the read contract we can see all the public variables and all the public functions we can go to write contract and we'll see all the transacting functions that we can interact with after we get verified and things get deployed we went ahead and called our start lottery function to actually start the lottery we got our little print line saying the lottery started then we entered you entered the lottery we then funded the contract with link so we could get our random winner back and then right now our end lottery is confirmed and we're just waiting this 60 seconds right because we did this time.sleep and if we sit on this contract if we go to transactions and we refresh we can actually see some of these different method calls over here we can see we did a contract creation we started the lottery we entered the lottery and then we recently ended the lottery and you'll see in our script here it says zero x blah blah is the new winner which is perfect right that means that the chain link node actually responded we can actually verify that by looking in the contract we'll go to read contract we can go to the recent winner and see somebody did indeed recently win we can also go to events and we can see some of the events that we created we can see this first event right here is this requested randomness event this is the event that we called we have this end lottery here we can also see an ownership transferred function that got called this was called when we actually deployed this in the first place now a little bit more on these events aka these logs right so topic zero this hash represents this entire event right here and this bit is going to be our topic one our first topic which represents that request id so this is going to be the request id awesome we have successfully created a working smart contract lottery with true provable randomness this is absolutely insane incredible job here now one additional piece that i want to talk about before we jump off here is again in our testing a file that you're often going to see is what's called conf test dot pi python automatically knows to look for this comp test file and we'll grab different functions from it we can also add external plugins fixtures hooks testing root path it adds a lot of really fantastic features and is a common thing that you'll see we skipped over in here for simplicity but in future projects you'll probably see this comp test file which has a lot of really nice testing configuration pieces in it now that was a lot of stuff to code and quite frankly i don't think any of us want to have to do that every single time have to code everything from scratch now you can absolutely get clone all these repositories right from their github but there's actually an even easier way first to start with a blank project here and this is with brownie mixes so if we google brownie mixes github we'll get this mixes organization which just has a ton of boilerplate code for us to go ahead and get started and start developing the one we're going to be working with is this chain link mix piece which is forked from this official one here this gives us some wonderful contracts some tests a browning config and really everything that we need to do to get started so if you have brownie installed we can just bake this mix so we'll do brownie bake chain lick mix and in our new empty directory here we'll get this new chain link folder with everything inside of it so then we can see the chain link and we can see it has all these pieces in here here already in the contracts we have a whole bunch of different samples of working with the vrf working with the price feed working with this thing called keepers to automate our smart contracts and making api calls and delivering any api call that we want to the blockchain it also has a brownie config which already has a number of wonderful pieces in each one of these networks so that we don't have to go copy paste and add it in here it's even got support for test nets like avalanche polygon finance and more it has a number of really powerful tests including testing some price feeds it has a whole bunch of deployment scripts some mocking scripts some helpful scripts and really everything that we need to get started and get going for starters we can run brownie test and it's going to compile everything and then on a development chain run all these unit tests and if we wanted to test this on a real test net we could do brownie test dash dash network ring b or any network that we wanted if you're looking for a good starter place that has a lot of really powerful smart contracts for you to get started i highly recommend using this mix as a boilerplate starting point for any of your contracts or any of your projects here now we are cooking so we've learned a ton of the fundamentals of working with brownie and working with smart contracts now that we have kind of all the building blocks though we can actually code a lot of these much faster and much more efficiently than before one of the things that we've seen over and over and over again is working with tokens and the erc20 token standard we're going to learn how to build our own token before we do that let's understand why we'd even want to do this now first let's define even what are erc20s so erc20s are tokens that are deployed on a chain using what's called the erc20 token standard you can read more about it in the erc20 token standard here link in the description as well but basically it's a smart contract that actually represents a token so it's token with a smart contract it's both it's really cool tether chain link uni token and die are all examples of erc20s technically chain link is in the rc677 as there are upgrades to the erc20 that some tokens take that are still backwards compatible with erc20s and so basically you can think of them as erc20s with a little additional functionality now why would i even care to want to make an erc20 well you can do a lot of really cool stuff with it you make governance token you can secure an underlying network you can create some type of synthetic asset or really anything else in any case how do we build one of these erc20s how do we build one of these tokens well all we have to do is build a smart contract that follows the token standard all we have to do is build a smart contract that has these functions it has a name function a symbol function decimals function etc all these functions we need to be able to transfer it we need to be able to get the balance of it etc and again if you want to check out some of the improvements that are still erc20 compatible like the erc677 or the erc777 you definitely go check those out and build one of those instead so let's create a new folder and get started we're going to create our new browning file of course with brownie init it's going to start up our repository and start up everything that we are going to work with here we can kind of actually just jump in and start right with our contracts so let's create a new file and we'll call it our token dot sol and this is where we're going to add all of our token code now since this is an eip right this all this is is a smart contract so what we could do is we could grab all these functions copy and paste them in here one at a time grab the name grab the symbol grab the decimals and then you know code all these up be like this does some stuff blah blah blah or we could do it the much easier way right since we're engineers we don't always want to reinvent the wheel so once again our friends at open zeppelin have some amazing contract packages for actually building our own erc20 token so we can go right to the opens up and documentation i'm working on the 4x version but again it doesn't matter the version that you use so long as in our config file we add the version that we're going to use which again we've already gone over so let's go over to their erc20 documentation and this is the entirety of the code that is needed to make an error c20 so we can just go ahead and even copy this paste it in here and boom we have some erc20 code in here let's actually just change the name of everything in here though so we're going to call this our token dot sol we have this spdx license identifier mit great we're going to be using solidity version 0.8 which i know i've done a lot of this code actually in point in 0.6 but i highly recommend working with 0.8 because it has a lot of really fantastic improvements to solidity you'll notice this is our first dive into using a different version of solidity here you'll notice that most of the syntax is exactly the same there are like i said a couple of nice improvements with 0.8 the main one being you no longer have to use those safe math functions that we talked about before but then we're going to go ahead and import opens up when contracts token erc20.sol now of course since we're importing open zappone we're importing this package we've got to add this to our browning config diamo and before we even get started you technically have all the tools that you need to code and deploy your own erc20 token now i'm actually going to challenge you to go ahead and try to start a browning project create your own token using opensupplement packages and then deploy it on a test net i'm going to show you how to do all of it here anyways but challenging yourself and trying to do things your own and exploring is really one of the fastest ways to learn and grow in this space did you give it a shot no really pause it now and give it a try all right welcome back now we'll go through it and we'll do it together of course we need to add these dependencies open zeppelin open zeppelin contracts let's do their version four so let's even go to github open zeppelin and we'll do 4.2.0 which was released yesterday at this time which is great 4.2.0 and of course again compiler we'll have silk remappings we'll add at open zeppelin equals this and then we're going to go ahead and save now we can use this at opens up line and it will refer to the opens up and contracts here so great now we can go ahead and import these let's change the contract name to our token we're going to inherit this erc20.sol from open zeppelin we can even go ahead to opens up on contracts github and we can even see what this erc20 looks like so we can go to their contracts down to token erc20 erc20.sol and this is their initiation of an erc20 which has all these functions like name symbol decimals total supply etc in our constructor we're going to add an initial supply which is going to be in way of course so the initial supply of that token and we're going to use the constructor of the erc20.sol which again we can go ahead and check in the code here and we can see the constructor uses a name and a symbol so we have a name we'll call it r token and the symbol will do ot and boom that is literally all we need for our token here i told you this is going to be a much faster project now for scripts all we have to do is create a new file we'll add a 1 deploy token dot sol and we'll also add a helpful scripts apply excuse me this deploy token dot pi excuse me we'll just quickly add a account function we'll say def get account and you can go ahead and just copy paste from the last one and if you want you can actually just copy paste from our last helpful scripts because it's pretty much going to be exactly the same so we have all these wonderful ifs statements so that we can deploy from really anything that we want now in our deployment token script we'll do from brownie import our token and then from scripts that's helpful scripts import get account and just to make sure let's add an init dot pi in here just to make sure that our scripts can actually import so since we know since we know that we need an initial supply here let's go ahead and do initial supply equals and then we can do you know whatever we want here if we want to make it a little bit more readable we'll also do from web3 import web3 and we can do web3.2 way and we'll say 1000 as the initial supply and this is in ether so our initial supply is going to be 1000 ether then we just add our main function we do account equals get account we do our token equals our token dot deploy we just add as a parameter this is initial supply do from account and then we'll do print our token dot name and that's the whole function now of course if you don't have your environment variable set we're going to add our dot enb file this is where we can add our private key our web3 infiera project id and then if we want our ether scan token i'm going to skip doing this for now because my environment variables are already set and then last but not least we'll add dot env dot env so private key equals ox blah blah blah when three inferior priority equals blah blah blah ether scan token equals blah blah blah and perfect now if we want to actually deploy this to a testnet all we have to do go into our config we'll add wallets from key we'll add our environment variable private key now brownie knows where to grab this from because we've defined it in our helpful scripts what i can do now so brownie runs scripts deploy token.pi and we can go ahead and see that our token is printed out we can see that we have this token deployed on our local ganache we can see our token here and this is great now i can go ahead and run this again network ring b now if i grab this address go to the ringby ether scan pop it in after a quick refresh i can now see that my contract has indeed been added and etherscan even picks up that it's a token now we could do we can grab this and grab this contract address go to assets add it in our metamask here next add tokens and you'll see we are the proud owners of 1000 hour tokens now something else that you might want to do is add this to a liquidity pool or add this to a place where you can actually go ahead and sell it and put it on the market you can do something like that as easily as just popping onto uniswap going to pool hitting more create a pool and then adding our token in here we'd have to manage the token list and be sure to add the token in here but we could go ahead and add a token create our own pool and automatically put it on your swap and that's how easy it is to actually sell it on one of these pools but alright so this was probably our easiest project of the course but it really shows how far you've come along everything here i thought we know a little bit more about d5 and why it's such an amazing amazing technology that only works in the blockchain world let's look at this site d5 pulse or if you want to look at another one uh there's another fantastic one out there called defined llama which also shows a lot of these different protocols in here so defy pulse is an application that shows some of the top d5 projects based on how much total asset is locked into each protocol ave which currently is the number one ranked d5 application with 9.32 billion in assets under management in terms of usd then we have some fantastic ones like curve compound maker instadap etc now we're going to be looking at two of these protocols in particular the first one of course being ave and the second one is going to be a type of what's called a decentralized exchange you start with ave we're going to go to testnet.ave.com dashboard and it'll bring us to a screen that looks something like this with please connect your wallet and everything will be pretty empty parasop is what's known as a dex or a decentralized exchange it allows us to trade tokens incredibly easy on the blockchain now there's not a whole lot of test net indexes that actually work so we're just going to look at them and simulate as if we were working on them for example if i wanted to trade one eth for some usdt or maybe some wrapped bitcoin or some dye or some ave or link or really any token that we wanted all we would need to do is connect our wallet here and a swap button would show up and we would go ahead and hit swap some other really powerful these dexes and really popular ones are going to be curve finance uniswap and it's a really really easy way to go ahead and swap your tokens for one another depending on what you're looking to do ave is incredibly powerful and it's going to be one that we're going to be working a lot with because it has pretty much all the fundamentals of working with the d5 protocol that we're looking for and it has a test stand that we can go ahead and test and simulate actually working with some of these protocols so we're going to first work with the ui or the user interface and then we're going to do everything here programmatically first things first if you don't already have it make sure you have some test net ethereum at least and again you can get some test and ethereum from looking at the link token contracts and going to coven this one indeed uh the test net of ave right now is only on coven so we're going to go ahead here we're going to add our copy our address paste it in i'm not a robot 70.1 test eth remember we use this linked token contracts page because this is going to have the most uptodate faucets here once we see some eath in our coventestnet here we can go back to ave so whereas paraswap allows you to simply swap between assets and do a lot of buying and selling of tokens ave is a lending and borrowing application so we can actually put down a token as collateral and we can borrow and we can generate some yield from interacting with this protocol borrowing and lending is a critical piece to doing any type of really interesting financial applications or financial instruments such as short selling being exposed to more assets etc you can also gain some percentage back if you look at apy it'll tell you how much percentage over a year you'll actually get in returns from staking or depositing an asset so here's what we're going to go ahead and do we're going to connect to the application using metamask and you'll see on the deposit tab here we'll see our balance be 0.1 each because that's how much i currently have in my wallet right now what we can now do is click on ethereum click this max button to deposit some ethereum we'll hit continue and a little dashboard will pop up asking us okay would you like to deposit clicking this deposit button will actually have us deposit right onto the ave contract on the coventest net make sure once you hit deposit here that you're actually on a test net here it looks like i actually have some insufficient funds so i'm actually going to go borrow a little bit more or from the faucet here grab a little bit more from the faucet here we're going to come back we're actually going to go back refresh and now it says i have 0.1 we're going to deposit 0.1 continue deposit and metamask is going to pop up saying hey are you sure you want to do this right we can check our data we can grab this address even if we want pop it on to coven.etherscan paste it in here we can even double check to make sure that this is indeed the right contract that we want funnily enough you'll see that this is the west gateway when we deposit our covent eath it actually gets transferred into an erc20 version of our ethereum and then it'll go ahead and deposit it into the ave contract so we're going to hit confirm now we're going to get this pending here we have a link to the explorer which shows us this transaction that's going through and then we'll see that we've indeed successfully deposited our ethereum now down here you'll see a little button add a eth to your browser wallet and we're going to go ahead and click this and this will automatically add this token to our wallet so we're going to hit add token and we see now in assets we have this ae down here we could also have manually hit added token got the contract address but avi was nice enough to just go ahead and add us a little button that does it for us ae is what's called an interestbearing token and it goes up in real time you'll see if i sit here long enough you'll see this number actually continually going up this is the profit given to us from other people borrowing the eath that we've deposited into ave if we go to our dashboard now we can see we have 0.1 each deposited and if we roll over it you'll constantly see the amount go up and up and up we can go ahead and withdraw our eath which will convert our a back into eath with the additional interest that we got from depositing so depositing into ave will give us interest back as a payment for other people borrowing the eath that we've deposited we can also use this eath as what's called collateral so if i go to this borrow tab i can actually use the eath to borrow some other acid maybe i want to borrow dye which is a stable coin meant to always equal one dollar usdc and usdt also are meant to always reflect a dollar we can borrow what's called wrapped bitcoin which represents the bitcoin price we could borrow some ave token some bat token some link token we can borrow all these different tokens now borrowing an asset is incredibly incredibly powerful by borrowing you're allowed to obtain liquidity without selling your assets and borrowing is one of the first pieces in order to actually short sell borrowing in default protocols is absolutely massive because it allows you to frictionlessly short sell obtain liquidity without closing your position gain yield on some deposited collateral you can do a massive number of new things only in the default world such as flash loans now an important note on borrowing assets on mainnet since we're just borrowing it on test net and this isn't real money this is 100 okay to experiment with and work with however if you borrow an asset and you do not pay attention to how much you have for an underlying collateral you could get liquidated and lose some of your funds so be very careful and pay a lot of attention if you're going to do this on an actual network now let's say we want to borrow the ave token for example we click here and we can choose the amount that we want to borrow now here's the thing since we've placed down some collateral right 0.1 if the amount that we borrow ends up being too high we'll actually get what's called liquidated every time we borrow an asset we get some type of health factor the health factor represents how close to being liquidated you are once your health factor reaches one the collateral that you've actually deposited will get liquidated and somebody else will get paid to take some of your collateral this is so that the the ave application is always solvent being solvent means it's never in debt so when i want to borrow i want to choose some amount that might be a little bit safe here and so that i'm not going to get liquidated so zoom in a little bit i'm going to choose some number where i see a health factor maybe like 5.6 we're going to continue now we'll have to choose our interest rate when we borrow an asset we actually have to pay some interest this payment is actually going to go to the people who are depositing die or depositing the asset the interest rate that we're going to pay is actually going to be paid to those who are depositing the asset that we're borrowing so like how we're getting interest on our deposited collateral others are getting interest on their deposited collateral based off of how often people are borrowing it we choose a stable apy which will always be four percent or a variable apy which will change based off of how volatile and how in demand this asset is for now i'm going to choose variable but you can pick whatever you want especially for this demo we're going to hit continue i'm gonna zoom out just a little bit and the same interface is gonna show up we're gonna go ahead and hit borrow metamask is gonna pop up and ask us if we really want to borrow we're gonna go ahead and hit confirm and now we've successfully borrowed die into our application we can even hit this little add die to your browser wallet to add the token to our wallet now if we hit the button we go to assets we can now see die is indeed in our token assets here now if we go back to our dashboard you'll see we have a health factor score here this is a really important score if you click on this little i thing it says the health factor represents the safety of your loan derived from the proportion of collateral versus amount borrowed keep it above one to avoid liquidation and we'll see all of our deposits here so we still have 0.1 in each deposited we also have 28 die deposited you can see a whole lot of different stats here for working with our application we can withdraw our die we can withdraw our eth we can borrow more die or we can go ahead and repay we can either repay from our wallet balance or from our current collateral yes we could repay with our collateral let's go ahead and do from our wallet balance we'll hit max continue and we even get this little thing that says you don't have enough funds to repay the full amount well why is this the case we just borrowed this amount it's because already since depositing we've accrued a little bit of we've accrued a little bit of extra debt remember we hit that variable apy and every second it's going to tick up just a little bit so let's go ahead and pay back what we can with our wallet we're going to confirm we're going to approve our data to be spent and then we're going to go ahead and hit the repay button and gray now if we go back to our dashboard you can see we've repaid almost everything here but we have a little bit left so let's just go ahead and hit repay with our current collateral we'll hit max continue and this will use our eth to pay back the collateral instead of the die and then we'll hit repay this way we'll have no more debt great now if we go back to our dashboard we can see we have no more debt which is fantastic ave is one of these applications that relies on the chainlink price feeds in order to understand the ratio between how much you have deposited as collateral and then how much you can borrow and take out if we look in our wallet now we can see we still have some aethe we also have some eath and now we have zero die because everything's paid back but we're still gaining interest on the eth we have deposited let's go ahead just reconnect let's go ahead back to testnet.aver.com and let's just withdraw all of our eth now keep in mind when working with some of this this is a test net right and working the way we're working right now is just on a test head so sometimes the test net doesn't work quite as well as a main net because it's just for testing and doesn't have the exact same support we were just working on the test net but if you want to go to ave for real you can go to app.avefork.com connect your wallet on the ethereum mainnet connect your wallet move to the ethereum maintenance and interact with it exactly the way we just saw now if we're on the maintenance here we can see some additional pieces when you deposit something like die yes you get 2.3 back as interest paid to you for depositing the die you also get a little bit of what's called a governance token you also get a little bit of ave token i know it's really small here but this is an additional incentive that ave has given the users for working with their protocol since ave is a decentralized protocol in order for anything to be improved or anything to be updated on the protocol it actually has to go through a decentralized vote so these governance tokens actually dictate and decide how the protocol improves moving forward now that we understand how to work with all of that through the ui let's actually learn how to interact with ave and interact with defy all from our scripts learning how to do it this way will get us one step closer to being a quantitative defy engineer or d5 researcher this is someone who programmatically does algorithmic trades algorithmic modeling and just does everything in a programmatic sense making them much more efficient and powerful interacting with d5 now all the code that we're going to be working with here is in this avi brownie pie application and you can always refer back to it in the link in the description or in the link in the github repository and see all the code written yourself so with that create a new folder and open up your vs code to that folder and let's get into it and ave has some fantastic documentation that we're going to use as well link here is also in the description let's go ahead and start with our our basic brownie setup just with brownie init and we got a new brownie project we got all of our folders in here and we are good to go now for working with browning we're actually not going to really be deploying any contracts because all the contracts that we're going to work with are already deployed on chain all of them are just going to be working right with ave here create a quick readme.md so we can know what we're doing here number one we're going to try to deposit some eath into ave then we're going to borrow some acid with the eth collateral and then if you wanted to i challenge you to actually sell that borrowed acid this is what's known as short selling but we're not going to do that here and then we're just going to repay everything back great and this will be the full functionality of working with ave in this deployed contract everything that we're going to learn here will teach you how to work with other contracts as well such as paraswap or unit swap or any other type of swapping contract that will allow us to buy and sell so let's just go ahead and create a script we'll call it ave borrow that pie let's go ahead and create a function called def main and we'll just do pass for now the first thing that we need to figure out how to do is deposit some f into ave when we actually deposited our f via the ui you can actually see when we call this deposit function if i hit this deposit button here oddly enough if we go to this contract address on the coven ether scan we'll see that this address is actually what's called a west gateway what ave is doing like i was saying before and let's go ahead and actually cancel this for now reject what ave is actually doing here is swapping our ethereum for west again west is an erc20 version of ethereum and this allows it to easily work with all the other erc20s on the obvi protocol like die usd coin you know ample fourth link et cetera so we actually have to do the that as well so the first thing we're going to need to do actually isn't deposit some of our eth the first thing we're going to need to do is going to swap our eth for west so let's even just put this in its own little script we'll call it get weth.pi so we're going to have a function def main i'm just going to do pass for now but we're actually going to want to use this get wet function in our ave borrowed a pi so we're going to actually have a main and we're going to have a def get weth and our main function is just going to call getwef so how do we actually convert our ethereum to wef or wrapped ether we'll even do a little dock string here mint's weth by depositing eth now to save gas we could actually interact with this weft gateway for ave but i'm going to teach you guys how to just get west in general so we can look up the west contract ether scan the west coven contract ether scan and we'll see here we have this wrapped ether page and we can go to the contract and we can see that this is indeed verified the way ath works is there's a withdrawal and deposit we deposit eth into this contract and it transfers us some wealth so this is the first contract that we actually want to interact with so we need our script to be able to call this deposit contract so per usual the two things that we need to do this are going to be an api and an address for this web contract i really like just doing everything directly from the interfaces i've already copy pasted the interface into this here so we're going to go to interface dot sol and we're just going to copy all this right here so in our interfaces we create a new file we're going to call it iweth dot soul we're going to paste it in you can see this has all the exact same functions as our deposit contract symbol name transfer pretty much everything you'd expect from erc20 plus this extra deposit piece we'll call this iweb it's a common naming standard to just have i in the name of what your contract is when you're talking about an interface so we have an interface now and we also have an address but again this is our address on the coven network since we know ahead of time that we're probably going to be using this on different networks like mainnet and coven and etc we're actually going to create a new file we're going to add our brownie config hopefully this is starting to look a little familiar to you now we're going to go ahead and add our networks in here in here we're going to go ahead and add coven and in here we're going to write west token and we're going to add this address of the web token paste it in here while we're in here we're going to add the rest of our pieces we're going to add wallets from key private key and that's all we really need for now speaking of which we probably are still going to want to test this locally now since we've done some work with testing we know that for testing we can do our integration test into integration tests on kovan because there's an integration test there what about our local tests well this is something good that we're thinking about right now we know that ave actually has all these same contracts on the main net as well and we also know that we're not going to be working with any oracles because that we don't actually have to deploy any mocks ourselves we can if we want to but we don't have to what we can do is for our unit tests we can actually just use the mainnet fork network and just fork everything that's on the mainnet into our own local network so instead of actually using mocs we'll basically just mock the entire mainnet and one more time just so that we absolutely have it here if you're not working with oracle's and you don't need to mock responses we can just go ahead and use a mainnet fork to run our unit tests if you are using oracle then it makes a lot more sense to do the development network where you can mock oracles and mock oracle responses with this in mind we know that we're going to be doing a lot of our tests on mainnet fork we can go ahead and add a mainnet fork network here and then we can just add the mainnet web token for mainnet fork so we'll look up web token etherscan web token etherscan and we'll grab this contract address remember absolutely positively if you want to double check that the contract address that you're working with is correct i highly recommend you do so because if you get it wrong you could accidentally add some money to a contract address that you don't want so we're going to have the mainnet fork address b the web token address and in our terminal we can do brownie networks list and see that indeed we have a mainnet fork here that's going to use the ganache cli to fork mainnet for us there's there's a link in the description to refer back to the section where we actually set this up so now that we have the interface we know that we can actually compile it down to the abi so back in our get wet here first thing we need to do to make any transaction obviously is get an account well this is where we can go back and make our helpful scripts so we can go ahead do def get account index equals none id equals none same as before and if you have your get account function from our last demo you can just go ahead and copy paste it in here all right great now we have our get account function so we can do account now equals get account oh but we have to import it in here so we'll do from scripts dot helpful scripts import get account and depending on your python version we'll add in it that pi just so that python recognizes that scripts is indeed a module all right cool so we have our account where we can make some transactions with now let's go ahead and get our wef contract to do this we can import interfaces from routing browning import interface same as we did before and we can do with equals interface dot i with and the address here is going to be from our config config networks dot show active and then web token we also have to import config from browning and network as well now you might be asking why aren't we using the get contract function here well you can absolutely 100 go ahead and use that get contract function but since we're going to be testing on mainnet fork here i know that we're always going to refer back to the config so i'm confident that i'm not going to be deploying any mocks it's better practice to go ahead and use that getcontract function but for this one we'll just make it a little simpler and use the config and now in a fig if we're on the coven network we're going to use this one if we're on mainnet or maintenance fork we're going to use this one for going to mainnet or for to real production you could also have a mainnet network and it'll just be an exact copy of the maintenance fork and remember we're going to want our dot env our env file our environment variables to get pulled from that dot env file so we can just set it like this now everything in our env file will get pulled in automatically great so we have an address and we have an abi which comes from the interface now we can just call we can just call this deposit function where we deposit ethereum and we get wef so now we'll just do transaction equals wealth dot deposit and we'll do from account value is going to be let's just say 0.1 so 0.1 times 10 raised to the 18. so we'll deposit 0.1 and we should get 0.1 wef in return do a printf string received 0.1 weft this doesn't even need to be printf and then we'll just return tx now per usual if your environment variables aren't set such as private key we're going to want to do that so in our emb we do export private key equals 0x at the beginning right here we're going to export web 3 infero project id we'll want our ad our web3 inferior project id which we've got before if we want to use our etherscan token we absolutely can and since we're putting a whole bunch of stuff into dot and v we want to make sure in our git ignore we have dot and v so we don't actually push this up to github again if you're nervous about having all these ambs in here you can absolutely do the accounts.add or whatever other methodology you like to set your environment variables anyway let's go ahead and run this script now so we can do brownie run scripts get wet pie network coven generating the apis from our interface we have a little transaction hash that we can use pop into the coven etherscan and we can see the transaction going through in our wallets we'll get minus 0.18 and we'll get plus 0.1 weth so we can see it's actually been successful to add this and see this on our metamask we're going to grab the contract address here we're going to go back to metamask add token paste it in here add tokens and you can see we now have 0.1 with if you want to switch back your weft to ethereum you would just hit this withdraw function or we could programmatically add a withdrawal function in here this withdrawal function will run for ethereum withdrawal and take our ethereum out of the contract and burn the weapons replace it with weft so you need to swap your weft back to get your eth out awesome we have some weft and now we have an erc20 token we have an erc20 token that we can use to interact with the ave application now that we've got this get weth function let's go ahead and start borrowing so let's go ahead and start with our account it's going to equal to get account which now we're going to want to import right at the top like so then we're going to get our west address or we can even just do our erc20 address because the web token is in erc20 and maybe we want to deposit some other erc20 we'll do config networks network dot show active left token and of course we're going to have to now add from brownie import network and now we want to call this get weth contract just in case we don't already have wef we would just add another from scripts dot get weft import get west but we don't actually need to call it right now because we already have some wrapped ethereum in our covenant address now if we want to test this though on our local mainnet fork we probably will want to call this getweft so i'm just going to add a little if if network.showactive is going to be our mainnet fork we should go ahead and call this get wet function and for brownie we're also going to want to import this config we'll also have to add mainnet fork to our local blockchain environments like so so that when we call git account in our scripts it actually knows that it's a local environment that we're working with and it will just return accounts zero instead of us having to actually load a private key in every single time and we want to actually wait for our transaction to complete here so we'll go ahead and add this weight and then do tx.weight and wait for this transaction to actually finish otherwise brownie will get a little bit mad so now that we have that we can run brownie run scripts ave bar to pie network maintenance fork so you can see that actually in this case testing everything on mainnet fork is going to give us a really really accurate view of what doing this on mainnet actually is going to give us we don't have to do any mocking we can literally just fork all of mainnet and go from there we are still going to test on kovan though in a little bit just so we can see all the transactions that go through how long it takes for stuff to happen so now that we've gotten some wealth here we actually need to go into our second bit we're going to deposit some f or in our case some wealth into ave so how do we actually do that well everything that we need is going to be in this ave documentation here where we deposit and borrow from in ave is in their contract this lending pool you can see here the lending pool contract is the main contract for the protocol it exposes the useroriented actions that can be invoked in solidity and webthree libraries and these have all of the functions that we need it has deposit where we deposit our asset as a collateral withdraw where we take it back we have borrow we have repay and we can have we have swap borrow rates and a couple other interesting ones which we'll go into later but for now we just really need to focus on repaying borrowing withdrawing and depositing so as you probably guessed deposit is the function that we're going to work on right now and since this is the contract that we're going to work with as always the two things you need when working with a contract are going to be the abi and the address so we're going to get this lending pool contract we're going to say lending pool equals and we're actually going to even make a function called get lending pool so down below we're going to do def get lending pool lending pool not poll and we're going to get the lending pool address and the lending pool contract so we can interact with it down here now something about this lending pool is that the lending pool address can actually change a little bit depending on a lot of different pieces so there's actually this address provider which gives us the address of a specific or particular market if we go back to this ave ui there's actually different markets so there's different types of ways we can interact with ave we're just going to work with the basic ave v2 because it's easily the most used on mainnet as well the address provider registry will give us so this address provider will give us the address of the lending pool for our market if we want to go across different markets we'll have to go to the address provider registry to find it but the addresses in here don't change and the addresses in here don't change it's just the lending pool address itself might change so we just have to go to this address provider here and there's just one function that we need to work with it's this get lending pool which will give us the address of the actual lending pool so don't let this confuse you too much basically all we're trying to do is we're saying hey where is ave located right now and ave has a contract that will always tell us where the main ave contracts are and that's this addresses provider right here so this is another contract that we have to work with and again when we have a contract what do we need we need an api and we need an address so we can absolutely once again we could go ahead and you know copy paste like abi equals whatever the abi is but we're just going to use an interface because because life is great with an interface so a couple of great things about interfaces too if we know we're only going to work with one or two functions we can actually just make the interfaces ourself so an interface we could do a new file we could do i lending pool address provider that's sol and we can just add it in here ourselves so we'll first do sp dx license identifier and we'll do like mit or something we'll do pragma solidity 0.6.6 or whatever we want to do and then we'll do interface i landing pool addresses pro divider excuse me this should be a lending pool address says provider and we know that there's only one function called get lending pool and we're not exactly sure what getlendingpool is defined as but what we can do is we can go to ether scan eat the scan ave lending pool addresses you can see here this is actually the lending pool but what we can look at is the ave protocol we can go right to the github we can go to contracts we can see they have an interfaces section and they have this lending pool addresses provider get lending pool and kind of as we expected it's an external view and it returns an address so we can literally just copy paste this into here and we could run with this and this would work perfectly fine but this leads us to the next point we might as well just grab the whole thing this way we know for a fact we're not getting anything wrong but yes if we wanted to our interface could be this right because this is going to compile it could be this because this interface is going to compile down to an abi and the abi is going to say hey there's a function here and that's all the abi is really doing it's just telling us how we can interact with a contract but let's just go ahead and add everything so that if we want to interact with more things we can so now we have the api we also now need an address which we can definitely find from the ave documentation we can go to their deployed contract section we find lending pool addresses provider which is going to be right here we're going to copy that and where are we going to put this well as you know we're going to put this in our brownie config we're going to do lending pool addresses provider i'm going to paste that right there and since we know we're also going to do coven we can also grab from kovin here so lending pool addresses provider we're going to copy this here and do and we're going to add this addresses provider for coven as well boom now we have it for both coven and for maintenance fork awesome so we can keep going now now that we have an avi and we have an address for both coven and for our mainnet maintenance fork what we can do now is we first get the lending pool addresses provider it's going to be from our interface which again we're going to grab from brownie interface dot i lending pool addresses provider which the address of that is going to be config networks network.showactive lending pool addresses provider and then we're just going to say lending pool address it's going to be equal to blending pool i'm just going to copy and paste instead of typing the whole thing address divider provider dot get lending pool right because again this address provider has this get lending pool which returns this address which is the address of the lending pool then now that we have this address we can actually return the lending pool contract by once again getting the api and the address of the actual landing pool so we have the address check we just now need the api which once again we can work with our wonderful interfaces here do new file i lending pool and there's only going to be a couple of functions we're going to work with here but ave actually gives us the interface right here and ave actually even gives us the interface of the lending pool address provider for us so we can go ahead and copy this pop it over into here now we do need to actually change one thing in here as well this interface imports locally with this dot slash so we actually just need to change these imports to actually import directly from github instead of importing locally luckily this is something we already know how to do so let's go to our brownie config and up at the top we're going to add this dependencies bit in pen then c's so we're just going to work with ave's protocol right from github so we're going to work with ave slash pro tow call v2 and let's see what their latest version is looks like they got a couple different versions here 1.0.1 so let's go ahead and work with this one at 1.0.1 and then with compiler sulk remappings per usual we're going to say at ave is going to be equal to this dependency this way brownie will download this right from github and now we can just use this at ave instead so back in our eye lending pool.sol we can just change this to poll right from github and if we look in github we go to their contracts section we go to their interfaces section by lending pool we know that we can pull this from at ave slash contracts slash interfaces because we see this eye lending pool addresses provider right in here and then this data types bit you can actually look in contracts and this i know because i've i've been through already it's in protocol libraries types and here it is datatype.sol so we can just take this exact path again and do at ave contracts slash protocol slash libraries slash types data type dot sol okay great so now that we've actually imported this interface for us to use we can go ahead and compile just to make sure that everything is working correctly brownie compile and perfect if these interfaces had an issue they actually wouldn't compile through brownie here so we know that they're compiling correctly but great so now that we have an interface we know that these interfaces compile down to the abi and we already have the address here so to actually interact with the lending pool now we can just do lending pool equals interface dot i lending pool and we'll add this lending pool address blending pool and then we can return lending pool so now we have a function that goes through the lending pool addresses provider from the ave documentation and returns this lending pool contract that we can now interact with and we can even test this out by just printing this landing pal address in our script so we'll do brownie run scripts ave borrow network mainnet fork and perfect we we can see the address here is printed out and there are no errors so we know we're doing it right so now that we have the actual address what we're going to do now is we're going to take this wrapped aetherium that we've got this erc20 version of ethereum and we're going to deposit it into this contract just like what we did in the user interface in order to actually first deposit it we need to approve this erc20 token erc20 tokens have an approved function that makes sure that whenever we send a token to somebody or whenever a token calls a function that uses our tokens we actually have given them permission to do so so that's the first thing that we're going to actually have to do is we're going to have to approve sending our erc20 tokens and this resembles so since i know that we're going to have to approve a lot i'm actually just going to go ahead and make an approve erc20 token function similar as to what we did with the get lending pool so we're going to need to approve this erc 20 so we're going to need to approve this erc20 so let's go ahead and make a function we'll call it def approve erc20 so how do we actually call this a prove function on a token contract well as always we're going to need the abi and the address of the token contract same as always i told you i was going to be saying this a lot now we could create our interface ourself looking at all the functionalities of the erc20 tokens so we could go to eip20 look at the token standard find all the different functions and put them into our interface or we can go ahead and just cheat and just grab it from my github repository here so i already have an ierc20.soul right here and we're just going to copy everything in here and add it in a new file called i yourc20 that's sold and paste it in here so you can see there are a number of different functions in here we can check the allowance we can check the balance of different addresses how many decimals a token has the name the symbol we can do some transfers and transfer from and then the function that we're going to be using is this approve function so right here we can already see the parameters this approved function takes we're going to need to have a spender of who to approve can spend our tokens and then how much they can actually spend so if we come back over to approve erc20 we know that for input parameters we're probably going to need an amount a spender address the erc20 token address so which token we're actually allowing to spend and then an account right or this is going to be that from account bit so we'll just have this be passed as part of the function parameters so let's go ahead and code this let's first just do a quick print line so that people know what this transaction is doing we'll say approving prc20 token and then we'll get the erc20 token by saying e or c equals interface same as always dot i e or c 20 and then we'll give it whatever erc20 address that we pass to this function and now we can actually interact with this contract and we can call that approve function so we'll say transaction tx or again tx usually stands for transaction equals erc20 dot approve and we're going to approve this spender for an amount and then we'll say from account we'll do tx.wait we'll wait one block confirmation for it to finish and then once it's done we'll do print approved and we'll return the transaction awesome so now we have an approved erc20 function that we can use to approve any erc20 token so back up in our main function we can run approve vrc20 for some amount which right now we don't have defined the spender is going to be this lending pool but the address of the lending pool because remember lending pool is the entire contract we just want the address the erc20 address of course is going to be the erc20 address and the account of course is going to be our account the only thing we don't have to find right now is some amount which we can make it really whatever we want to be to keep things standard let's just go ahead and do 0.1 so i'm going to make this a global variable i'm going to say amount equals one one two three four five six seven eight nine ten one two three four five six seven and we can go ahead and do amount we're gonna of course doing all these zeros is from incredibly disgusting so we're just gonna refactor to do from web 33 import web and then instead of always and we'll just do web three three two two 0.1 0.1 which is the amount that we actually want and we'll say either now we can run browning run scripts ave borrowed a pie network main net fork and we can go ahead and see that our approval function is working as intended network that will always be doing this fine any type of we can do so let's go foreign and change our default network to mainnet for mainnet so we don't have any network in our browning let's go back to our ave borrowing section now so we have everything approved now we just need to go ahead and deposit it into ave since we know we're probably going to use this a lot too let's go ahead and create a deposit function since we have everything approved we can now go ahead and use the lending pool deposit method and we can check the documentation here or look on github or etherscan to see what the parameters that it takes are so i'm even just going to go ahead and copy all this bring it over here so what we can do now is we do lending pool dot deposit and then all these parameters let's go ahead and walk through them one by one so first thing is going to be the address of the asset which we know is going to be your erc20 address boom the amount of the token which we can go ahead with our amount variable address on behalf of is just going to be our account.address we're depositing this collateral for ourselves and then referral code so referral code is so the referral code is actually deprecated and workloads don't actually work anymore so we're just always going to pass 0 here and just to make sure we know that this is what we're doing we're going to go ahead and print depositing one two three and then after we're done we're gonna do print the ted and whoops looks like we forgot to add that final dictionary here of from accounts ah one more thing here let's go ahead and do tx for transaction equals lendingpool.deposit and we're going to go ahead and once again we're going to wait for one block confirmation wait one transactions still being processed so now if we run brownie run scripts ave borrowed up high we can see that this actually went through fine all right now that we have some collateral deposited we can go ahead and actually take out a borrow we can go ahead and borrow some other asset the question is going to be how much how much can we actually borrow how much should we borrow what would result in a positive health factor well maybe we should actually pull off chain some of our stats how much do we actually have deposited how much collateral we have how much debt we have and so on and so forth that way in the future when we don't start clean we can take some inventory of where we stand with our collateral in our debts at the ave documentation we can go ahead and see this this function called get user account data this is going to return the user account data across all reserves so it's going to get the total collateral that we've deposited in terms of ethereum it's going to get our total debt in terms of ethereum how much we can borrow the borrowing power that we have the liquidation threshold or how close to that liquidation threshold will be the loan to value ratio and again this health factor this health factor is obviously incredibly important because if it drops below one or reaches one users can call this liquidation call now this function returns all these variables but for now we really only care about how much collateral we have how much debt we have and how much we're available to borrow so let's go ahead and write a function that will actually sort that out for us we'll call it get borrowable data borrow a bull data so let's go ahead and create this def get borrowable data and we're going to pass in the lending pool as a first parameter and then the account as the second parameter because we're looking to call this function on the lending pool from an account so let's go ahead and just call that function so we'll do lending pool dot get user account data and we'll pass in account that address because we look at the api again all that it needs is a user's address to get started here and it returns one two three four five six variables so we can go ahead and get all of them with this tuple syntax here so we'll say total collateral eath total debt eath available borrow eth current liquidation loan to value and then the health factor so it's with this syntax here that we can actually get all of these variables with this one call and again this get user account data is a view function so we don't need to spend any gas all of these variables are going to return in terms of way so let's just go ahead and convert these from whey to something that makes a little bit more sense to us so we want to get this available borrow each so we can figure out how much we can borrow let's get that in terms that we can actually understand so we'll do fromway available borrow eth in terms of ether we'll do total collateral eth equals web3 that from way and we'll do total collateral eth ether ether and then we'll do total debt eth equals same thing web3 dot from way total debt eth terms of ether and let's even do a little printf statement for each one of these so we'll do print f this f allows us to put variables inside the print function and we'll say you have total collateral eath worth of eath deposit 10. we'll even copy paste that a couple times and we'll change this one to total debt eath and we'll change this one to available borrow eth so we'll say you have worth of ease deposited you have total death eat worth of f borrowed and you can borrow available borreeth worth of eath and then we're going to go ahead and return again we're going to use this tuple syntax so we can return two variables and we're going to say a float of this available borrow eth and a float of the total debt eth the reason that we have to add this float variable here is that without it some of the math that we're going to try to do later won't pan out as well so now we have this function get borrowable data we're going to pass the lending pool and we're going to pass our account here since we're returning the borrowable eth and the total debt we can say borrowable eath and then total debt equals that function right there so let's go ahead and try this out with running run scripts ave borrowed a phi pi again because in our config we have a default network of mainnet fork things seem to be approving things seem to be depositing and awesome we have we have our output here we deposited 0.1 worth of f we have 0 f borrowed and we can borrow 0.8 worth of f yes this is correct even though we have 0.1 f deposited we can only borrow 0.08 this is because the liquidation thresholds of different assets are different in this risk parameters documentation here we can see the different liquidation thresholds on the different assets we can see that ethereum has an 80 loan to value so with ethereum we can only borrow up to 80 percent of the deposit assets that we have and if we have more than 82.5 percent borrowed will actually get liquidated it also tells about the liquidation bonus reserve factor and some other helpful pieces in here as well but now that we have this borrowable ether mount we can go ahead and actually borrow some dye so let's do a quick print saying let's borrow now in order for us to borrow some dye we also need to get the conversion rate we need to get die in terms of f so we're going to have to use some price feed here luckily we already know how to work with chain link and how to get price feeds ave uses the chainlink price feeds as well so we're using the exact same conversion rate tools that avi is going to use so let's go ahead and create a function to get us this conversion rate we'll say the die to f price is equal to get asset price and then here we'll pass the die f price feed this will be the address of the die ethereum conversion rate let's go ahead and create this function call it def get asset price and the parameter needs is going to be price feed address so the first thing that we're going to need is we're going to need to get this die f price feed where can we get this well as we know per usual we'll head over to the chain link documentation we'll go to ethereum price feeds we'll find done and we'll paste it into our config for mainnet so we can go ahead and add the die f price feed in here and paste it into our config again if we want to test the coven we can obviously just scroll down look for coven find the dieth right here grab that address pop it in for coven and then we can get this the same way that we got the address of the web token so i'm just going to go ahead and copy this paste it here but instead of having weft token in here we'll do die f price feed and now we have a way to change the price feed address depending on what network we're on so in our get asset price function we're going to do the same exact thing that we always do we're going to grab an api and an address to work with the contract so again we can get the abi by just working directly with the interface so we'll say die f price feed equals interface dot aggregator v3 interface because this is the name of the price feed interface which again if we look in our interfaces it looks like we don't actually have so what we can do is we can go to the chain like github or as you guys are already starting to figure out all my example code has all these interfaces as well but we can go right to the source too what we can do we go here we go to contracts we're going to add source we'll do 0.6 we'll do interfaces and right here is the aggregator v3 interface so if we want we can just copy this whole thing move back over to our interfaces new file and this file is actually named aggregator v3 interface you could call it eye aggregator v3 or aggregator v3 interface you could keep it with i aggregate or v3 outsole to keep with the convention that we have or you can just call it aggregator v3 interface dot sol to keep in line with what the chain link code is actually called them i'm going to call mine aggravated v3 interface you'll notice a couple different projects have a couple different conventions but now that we have it saved we can do interface the aggregator v3 interface and we'll pass it this price feed address now this diet price feed is going to be a contract that we can call a function on again we can always refer back to the get the latest price documentation to see how to actually work with it there's even some python code here for working with it in web 3. we're going to go ahead and call this latest round data function which we can also find in our aggregator v3 interface this latest round data which returns a round id answer started at ended at and answered it around all we're really concerned with is this answer bit here so the way we can do this is we can say latest price equals die dieth price feed the latest round data and instead of grabbing all five of these one two three four five what we can do is we can actually just grab the price which is at the one index so round id is at zero price is at one started it's two et cetera so we can just say at the first index and then we can return a float of this latest price we can even print another printf statement the die f price is latest price so let's go ahead and run this and great we have the die f price video which of course we know that looking at this right now this isn't in the right units we know the diet price feed has 18 decimal places so what we can do then is we know that this number would be one two three four five six seven eight nine ten one two three four five six seven eight this number is really zero point zero zero zero four blah blah blah blah blah so maybe we don't want to return it like so maybe we want to say the diet price feed is and we add a little bit of web3.pi to make this make a little bit more sense so we'll say web3 dot from way and we'll add this latest price bit in here comma ether maybe we'll even do a converted latest price which is going to be equal to web3 dot from way latest price ether and we'll print that out instead so let's go ahead and run this again all right that looks a little bit more accurate perfect okay great now we have the die eat price we're getting really close to being able to borrow this actual asset and let's even return this converted lated price here just so that we're always working in units that we understand okay now we're getting somewhere now we can calculate the amount of dye that we want to borrow we can find this by doing a little bit of math we're going to do the reciprocal of the die eat price times our borrowable eath and just to be safe we're going to times it by 0.95 so this line we're converting our borrowable each to borrowable die and then we're timing it by 95 percent we're timing it by 95 because we don't want to get liquidated so we're going to be a little bit more cautious remember how we slid that sliding scale around to make it safer and less safe well the lower percentage that we actually borrow maybe we even borrow 50 of our collateral the safer that we're going to be so keep that in mind when you're deciding how much to actually borrow if you want to run this in a production environment so now that we have this amount data borrow let's even print it out let's say print f we are going to borrow amount down to borrow die and then we're finally going to do it now we will borrow looking at the ave documentation we can look at their borrow function and we can see the api here let's go ahead let's go ahead and call this function so we'll do borrow transaction it's going to be equal to lendingpool.borrow let's look at those parameters so the asset that we want to borrow die address so first we should get a die address which we can once again we'll want to put in our config so we'll go over to our config and we'll add a die address or a die token here which we can find on etherscan token it looks like this is the token right here so we'll copy this address for mainnet remember if you want to run this on coven you're also going to need to have a die token for coven now on test nets avi actually changes up where the tokens for its test nets are actually going to be so if we go to their documentation we go to deployed contracts and we go to coven here you'll always see this little flag thing pop up say always ensure using the latest lending pool address since coven is updated from time to time it's going to be the same thing if we scroll down for tokens they have an uptodate list of coven addresses in a json file here so it looks kind of gross but if we look up die we can see symbol die and the address of die on the coven test net so sometimes this does change so if you run into an issue maybe it's because the die token that you were working with on their coventestnet has actually changed then we're going to do config networks network dot show active diet token great now let's move on to the next parameter the amount which we just figured out here amount diet to borrow which we do need to change back to whey so we're going to do web3.2a mount dye to borrow ether because right now amount down to borrow is in our human readable version which we need it in way then our interest rate mode which is going to be stable or variable stable is where the interest rate will always be exactly the same variable will change depending on a lot of different things going on with ave for safety we're just going to go ahead and add one here then we're going to do a referral code and on behalf of so referral codes no longer exist so we'll leave zero it's going to be on behalf of our self so we'll do a countdown address and then of course we have to do a from account then we'll wait for this transaction to complete and if we've done this right we should have borrowed some dye programmatically from the ave protocol so let's even print borrowed some die and we can once again call our get borrowable data function since this get borrowable data function will print out our new account information for how much we borrowed so let's go ahead and run this on mainnet fork again awesome so if we've done this correctly we now see that we've borrowed some die so we can see here we now have 0.1 worth of f deposited 0.059999 worth of f borrowed and we can borrow a little bit more worth of f this 0.75999 is actually the die that we've borrowed so we've deposited some eath and we've borrowed some dye and obvious telling us how much that dye converted to eat is there so we actually borrowed 160 die which is great all right we've now learned how to borrow everything which is fantastic let's go ahead and actually repay that back so we're going to call their repay function and let's just put this into its own function called repay all and we'll give it the amount that we want to repay the lending pool address and our account so let's call let's define repay all or we're just going to repay everything that we have again we're going to add an amount lending pool and account for parameters so if we're going to pay back this network first thing that we need to do is actually call the approve function i'm going to prove that we're going to pay back so the first thing we're going to have to do per usual is we're going to actually have to approve that erc20 so let's say how much we're going to approve web 3.2 way amount ether to the lending pool and we'll grab it from the config networks network dot show active and this is going to be the die token again and of course with our account i believe our proof erc20 already calls weight so we don't have to call it here so once we approve we're going to be using this die that we borrowed to pay most of what we have borrowed back now we're going to call the repay function so we'll say repay tx equals lendingpool.repay first we need the asset that we're going to use to repay which we're going to use config networks network dot show active diet token the amount which is going to be passed in here amount the rate mode which we've hard coded to one and the address on behalf of which is going to be account dot address and then of course we always have to do from account then we're going to do repay tx dot wait we're going to wait one block confirmation and then we'll print repaid and if we've done all this right we'll do one more print line saying you just deposited borrowed and repaid with ave brownie and chain link all right moment of truth let's see if this works we did it repaid you just deposited borrowed and repaid with ave brownie and chain link awesome work now if you want to what we can also do is we can see if this will work with our wallet address here so what i can do is i can copy my address go to coven ether scan and paste it in here and right now we can see that i have a whole bunch of link and some ether what i can do is actually test everything that we just ran through on the cove intestine and see everything happen right on this ether scan address so if we've been following along correctly and we've added contract addresses appropriately we should be able to run the exact same script on the coven test net i'm going to do one additional thing here though i'm going to have us not repay so we can see us with a little bit of debt so let's go ahead and run brownie run scripts ave bar to pie and we'll change to network coven and now it's going to take a lot longer as we've seen before because we're actually making these transactions on a real network whoops it looks like i got one of the die f price feeds wrong for coven so i can once again just go over to the documentation die s it looks like this is the real address for coven so we'll copy that paste it in here whoops we should also probably have some wet token so first let's go ahead and run our get wet script for coven and we're going to change this account to get account brownie run scripts from our helpful scripts that way we can actually that way we can actually use our wallets correctly all right great so now we have 0.1 weft and actually again what we can do is grab this address here add token paste it in add tokens for the web token and now we can see we have 0.1 with which is perfect so now that we have some width we can run the borrow script ave brownie run scripts ave borrow network coven and wow we can see that everything went through correctly and successfully so since i actually commented out this repay function we still should have die in our address here in our wallet here and again we can see that by going to our brownie config grabbing this dye token address add token custom tokens next ad tokens and we can see we do indeed have 160 die in our wallet we have no weft since it'll be in ave now and we have borrowed die instead you can also see that we now have this a weft if we added it from when we were working with the ui we have this interest bearing with instead of regular wrapped ethereum let's look at one of these transactions we can see that our borrowed transaction gave us some stable debt bearing dye and also some dye so we owe ave some die from this debt we got some debt we got some dye and we gave out some ave interest bearing dye to the rest of the albe protocol you'll notice now if we go to test.ava.com dash dashboard we'll see exactly what our script just did we have 160 borrowed and we have 0.1 eth deposited if we want to repay our funds we can do it with our current collateral or from our wallet balance and you'll notice something if i try to repay everything from my wallet all the diet that i've actually borrowed you'll notice we don't have enough funds to repay the full amount this is because since we actually borrowed a little bit we've include some of that interest so we actually owe more back than we originally borrowed that's how the loans work so when you're designing this repay functions be sure to have that in mind you can also have your repay be 1 to repay the entire debt it's recommended to send an amount slightly higher than the current amount borrowed but in any case maybe we say we want to do from our current wallet we'll hit max but maybe we want to actually just repay with our current collateral we can go ahead and repay the maximum amount again we could do this all from the ui we'll approve and this is exactly what our repay function actually did and now we're all repaid up if we go back to our dashboard and we hit refresh we'll see we just have a tiny bit of ethereum and no more borrowed assets awesome you've essentially learned everything that we need to go through for here this is a massive step forward in teaching you how to become quantitative defy wizards and build really robust applications and really robust financial applications in the default world now something i want to point out even though this isn't a python course and we're teaching more about solidity and smart contracts it's still in your best interest to test these functions yes i know they're python functions but it's still going to be in your best interest to test them to make sure your application always works as you expect it to now i'm not going to go through this testing suite that i put here but it's a really simple testing suite to test some of the different functions that we created it can be really helpful especially for something like get asset price where the math might be a little bit off and you want to make sure it's correctly again link in the description to seeing some of these tests this is actually going to be even easier than that lottery contract that we did since we're just testing python functions and again you can test these all with brownie test all right you are all doing fantastically now is another fantastic time to take a break go for a walk get some food because our next session our next lesson we're going to be learning about nfts how to build them use them and deploy them look nfts are hot right now nfts also known as erc721s are a token standard that was created on the ethereum platform nft stands for nonfungible token and is a token standard similar to the erc20 again erc20s like link ave maker all those goodies that are found on the ethereum chain an nft or a nonfungible token is a token that is nonfungible this means that they are starkly unique from each other and one token isn't interchangeable with any other token of its class a good way to think about it is one dollar is interchangeable with any other dollar one dollar is going to have the same value of another dollar those are fungible tokens that's like erc 20s one link is always going to be equivalent to one other link by contrast is going to be nfts those you nerds out there would know like a pokemon would be a good example of an nft your one pokemon is going to have different stats different move sets and isn't interchangeable with any other pokemon or maybe a more relatable one is like a trading card a unique piece of art or the like so that's what these nfts are they are nonfungible noninterchangeable tokens that for the moment are best represented or thought about as digital pieces of art that are incorruptable and have a permanent history of who's owned them who's deployed them etc now like i said nfts are just a token standard so you can actually make them do much more than just be art you can give them stats you can make them battle you can do really unique things with them you can do pretty much whatever you want with them but right now the easiest way to think about it and the most popular way to think about it is by calling them art it's odd or some type of collectible or just anything that's unique now they've been getting a ton of buzz recently because we've been seeing more and more of these being sold at insane prices like we saw axe infiniti sell nine plots of their land nine plots of their unique land for 1.5 million dollars we also saw the original creator of the neon cat you know this cap sold for like 300 eth so like i said they're just tokens that are deployed on a smart contract platform and you can view them on different nft platforms like openc or wearable and these are the nft marketplaces that let people buy and sell them you obviously can do that without these marketplaces because it's a decentralized but they help and give a good user interface so that's the basic gist of it let's talk some more about the standards the erc721 standard or the nft standard this is the basis of it all there is another standard that's semifungible tokens the 1155 we're not going to talk about that here but you can check it out the main differences between a 721 and an erc20 on erc20s they have a really simple mapping between an address and how much that address holds 721s have unique token ids each token id has a unique owner and in addition they have what's called a token uri which we'll talk about in a minute each token is unique each token id represents a unique asset so since these assets are unique and we want to be able to visualize them and show what they actually look like we need to define those attributes of the object if it's a piece of r we need a way to define what that art looks like if it's some type of character in game we need a way to define that character's stats in the nft this is where metadata and token uris come in so if you know anything about ethereum you know that sometimes gas prices get pretty high especially when it comes to storing a lot of space it can get really really expensive so one of your first questions might be well are they storing these images and and these are pieces on chain and the answer is sometimes back when they were coming up with nfts and artists were deploying stuff the eth devs and the artists were like yeah art let's do that art i'm just going to deploy this one megabyte image onto the ethereum chain and oh god it's so much a gas expensive how do i totally find it i don't know why it's not um it's not delivered and they realize that if they put all this art on chain it's gonna be incredibly expensive so to get around this what they did is they put in the standard what's called the token uri this is a universally unique indicator of what that asset or what that token looks like and what the attributes of that token are and you can use something like a centralized api or ipfs to actually get that token uri typical token uri has to return something in this format like this it has the name the image location the description and then any attributes below now if you're like me your first question would probably be we paul from a single source seems pretty centralized this is a current limitation of the end of the ecosystem there is often this talk of onchain metadata versus offchain metadata because it is so much easier and cheaper to store all your metadata offchain a lot of people will use something like ipfs that is decentralized but does take a little bit of centrality to keep persisting but they can also use their own centralized api however obviously if that goes down then you lose your image you lose everything associated with your nft because of this most nft marketplaces actually can't and won't read off onchain attributes or onchain metadata because they're so used to looking for the token uri obviously if you do offchain metadata you can't do anything really cool or really interesting or have any games with your nfts for example if you wanted to create an onchain pokemon game all your attributes would need to be on chain in order for your pokemon to interact with each other because if it was off chain then that becomes a lot harder to cryptographically prove so if you're new with nfts and you're like wait this is kind of a lot of information i'll make it easy for you if you're looking to render an image of an nft add your image to ipfs add a metadata file pointing to that image file on ipfs and then grab that token uri and put it and set it as your nft the chain link dnd article does a great job of walking you through this and showing you how to do this so be sure to read that if you're looking to learn how to do that so all the code that we're going to be working with is actually available for you in this nft mix brownie mix it's an official brownie mix and it allows us to deploy these three adorably cute dogs and there are two different types of contracts that we're going to be working with we're going to be first working with a simple collectible and then we're going to work with an advanced collect the simple collectible is going to be a very simple erc721 standard we're not going to really add any bells and whistles other than give it like a name and then our advanced collectible is going to take advantage of some of those more advanced true scarcity features that we were talking about so protocols like avagochi and ethercards use chainlink vrf to get verifiably random numbers to create verifiably scarce nfts something that's important to keep in mind is that in the real world when companies create trading cards there's no way to prove how scarce or how valuable these trading cards actually are if we use a verifiable random number then whoever is deploying these nfts can't even control how rare these nfts really are so we get this verifiable scarcity and this verifiable rarity which adds some value to the tokens if you want to just go ahead and work right from the brownie mix you can actually just run brownie bake nft mix and then cd into nft and all of our code is gonna be right in here we're gonna go through and deploy and develop everything from scratch because we're going to actually take some previous concepts that we've learned improve on them and we're going to learn a lot of nitty gritty interesting pieces about making this hybrid smart contract because these nfts really are a perfect example of a hybrid smart contract they have some offchain component interaction with a random number and restoring their metadata with ipfs and i'll explain ipfs a little bit more in depth as we go on here so let's go ahead and get to it i'm going to go ahead and make a new directory called nft demo i'm gonna cd into it code period and perfect i have a blank project here and you already know what the first step we're gonna do is is do brownie init to create our blank brownie repository now let's go ahead and create our first contract we'll call this simple collectible dot soul since this is going to be it since this is going to be a simple collectible a simple nft that we're going to get started with now similar to the erc20 this erc 721 standard has a number of functions that we can actually work with we can go ahead and even look at the 721 the erc721 nonfungible token standard on the eips.ethereum.org website and we can see a sample interface and some sample events and some functions and kind of everything that we've grown to know and love and once again instead of us kind of recoding copy pasting all this from scratch we're going to be using we're going to be using open zeppelin's erc721 documentation for this now we're going to be working with version 3.x there is a version 4.x that has come out using version 3.x of their open zeppelin contracts is also i think a little bit easier to explain but again those who want to challenge yourself definitely try their 4.x version so let's go ahead and jump right into it first we'll do our srspdx license identifier mit then we'll choose our solidity version we're going to use pragma solidity 0.6.6 but again most of this should work for 0.8 moving forward and then we're going to go ahead and look at the open zeppelin erc721 documentation and we're going to go ahead and grab this line right here import open zeppelin slash contracts token erc721 erc21.soul you can even see a sample erc721 that they give you and this is actually going to be similar to the erc721 that we're going to make so we're going to go ahead and paste that and of course since we're doing this at opensupplement contracts we're going to need to create our brownie config and same as always the pen then sees it's going to be open zeppelin slash open zeppelin contracts and again like i said we're versing we're using version three so 3.4.0 again and then we'll do compiler sulk remappings and we'll say at open zeppelin equals this and great let's even try to just compile this right now browning compile and perfect it has been compiled now similarly to our erc 20 that we did with open zeppelin we're going to do the same startup here so we're going to say contract simple collectible is erc erc721 and this is how we're going to inherit all of those functions in the erc721 token standard here and we can start adding r and we can start coding our simple erc 721 now for our erc 721 we're going to make it be a couple of these cute adorable dogs so it's going to be one of these three dogs for our simple collectible we're just going to go ahead and use the pug here so so you can use any image that you want for this demo um however if you want to just follow along with us we can just download this dog and we'll call it pug create a new folder here called img and then i'm just going to add pug.png to this img folder so this is going to be the mft that we're going to deploy we're going to deploy this very simple pug for our smart contract so we're going to be deploying this pug this is the image that we're going to use for our nft it's going to be this adorable pug so let's go ahead and create the rest of the contract for this pug so the first thing we're going to make is our constructor it's going to take no input parameters it's going to be a public constructor and then we're going to go ahead and use the erc721 constructor which if we look at the documentation we give it a name and then a symbol we're going to use the erc721 their parameters which is going to be a name which we're going to say is doggy and a symbol which we're going to say is dog and perfect that's all i really need to do for the first part this nft contract is actually what's known as a factory contract there's a main contract and in it it has a list of all the nfts and the owners that are of this type of nft so in this example all the type of nft is just going to be this pug and it's just going to be this dog and we actually need a function to mint new nfts based off of this pug now we can absolutely have an nft factory contract that only creates one single nft but we're going to use this factory implementation to create multiple nfts we're going to do it with a function called create collectable this will create a new nft and assign it to whoever called this function so anybody can come here and create a new puppy for themselves or in other words adopt a puppy so we're going to say function crate collectible public and we're going to say returns you went 256. you'll see why we need to do this in a minute now when we create this collectible all we're doing is we're assigning a new token id to a new owner and if we look at the open zeppelin erc721 github we can see they have this safe mint function this is the function that they use to mint or create a new nft this function it's it takes a new address 2 which is going to be the new owner of the nft and a token id every nft in this factory contract has a unique token id we're going to have our token ids start from 0 and and just increment every time we have a new token minted this safe mint function calls this safement function which calls this minting function so if you're looking at the code here this mint function is really the the function that calls and creates this nft you'll see actually that they just have two mappings that they update they update this owner's mapping which is just a mapping of token ids to the owners of the token ids and then they update this balances mapping which is a mapping of owner address to the token count so the number of tokens that an owner actually has and that's all that's happening when we call this mint or in our case safement function the difference between safe mint and mint is safement checks to see if a token id has already been used or not and this way we don't actually override who owns tokens and who owns tokenids so we're going to use the safement function so first we need to think okay well we're going to need to a way to count these token ids so that every single person has a unique token id so let's create a global variable un256 public token counter and we'll initialize it tokencounter to zero of course this is the same as initializing token counter to zero but let's just make it very explicit so when we create a new collectible we're going to say uwen256 new token id is going to be equal to this token counter and we're going to iterate this every time we mint a new token so for example we're going to iterate that in this create collectable here so new token id equals token counter we're going to call this safement function since we're inheriting it from open zeppelin's erc721 we need to give it this new nft and owner which is going to be message.sender so whoever calls this function and then we need to give it a unique token id which is going to be this new token id now whenever we mint one we're going to want to increment this token counter so then we can say token counter equals token counter plus one and we can then return this new token id so we'll return the token id of the token that we just created and boom if you're looking for an incredibly minimalistic contract to deploy nfts this is all that you need so we can run brownie compile to make sure we did everything right and project has been compiled we can see it in the build so great job obviously this might be a little dissatisfying to you after the breakdown that we just gave how do we view this token what does this token look like i thought we wanted this to be a doggy how do we know that this looks like a dog how do we get this image on the blockchain this is where metadata is going to come into play now if we look at the original erc 721 there is this part called the metadata extension is optional for erc 721 smart contracts as we've talked about anytime you make a transaction on chain it costs some gas even very tiny amounts of data can cost more and more gas images are much bigger than these little bits of data here and they can cost a lot more gas so when this standard was being created the developers kept this in mind and knew that storing entire images and entire gifs and entire videos on chain was going to be incredibly costly so they added this piece about metadatas and token uris the token uri is a distinct uniform resource identifier for a given asset this is an example of a uri and the metadata that we're going to be demoing today a uri is just a unique resource identifier so this can be something like https or ipfs or any url string that uniquely points to some metadata your metadata file is going to look like this it's going to have a title for the title of the nft can have a type and it can have all these different properties or stats or attributes for example we're going to have our pug nft which is going to be defined like this it's going to have a name as pug description is going to be an adorable pug pup and it's going to have what's called the image uri which defines what the token actually looks like and if we copy paste this into another browser we get returned this it's this token uri with this metadata json object that's going to enable different nft platforms to actually render our nft so this is an example of what this pug is going to look like on different nft marketplaces like openc platforms like openc understand that they need to show this image they need to use this name they need to use this description and have these traits so if we look back at this nft on openc we can see the name is pug we can see the description here if we go to levels we see its cuteness as 100 out of 100 now this of course leads us to a really interesting point if we're storing the image off chain then how is this image decentralized if we're storing this image off chain how can we guarantee this nft is going to stay forever now this leads us into a little tidbit about storing data on blockchain as of current recording storing a lot of data on chain can get incredibly expensive the more data that you store the more transactions that you have to make to store that data on chain and the more gas that you're going to have to spend at the time of recording ethereum is about little less than 900 gigabytes in size if a ton of people were to put full videos or movies or massive images ethereum would grow exponentially out of proportion and this would become unsustainable for the blockchain network as a whole so ethereum isn't great for actually storing a ton of data it can store a lot of data but it's a lot better for doing the logic and the smart contracts so there are a lot of different platforms that are actually working on this problem of storage these platforms allow people to store data in a decentralized way that isn't going to exponentially explode the size of ethereum or different smart contract platforms the decentralized storage methodology we're going to work with is going to be ipfs or interplanetary file system and this is where we're actually going to store our image and this is actually where we're going to store our image so that nft marketplaces know what our nft looks like now here's what some protocols do some protocols just set up a server and set this token uri to instead be from a decentralized service like ipfs and use just maybe their own centralized server this is obviously a massive issue because if their server goes down or if they want to change the image or they want to change the stats all they have to do is change it in their server and this is why a protocol like ipfs is going to be a lot easier quicker and more decentralized version of doing this the full solution is going to be using something with ipfs and filecoin but easy solutions to do that are still being built out so for now we're just going to use ipfs because it's free it's quick and it's easy and it can be expanded to combine with file coin to be even easier to work with now something else that i want to touch on too when it comes to this metadata right now all these nft marketplaces only know how to pull attributes from this token uri now if we want to build really cool nfts that can interact with each other having some attributes or maybe some like like attack stats or attack moves like in pokemon for example or trading cards we can't just store these in this token uri because the blockchain doesn't know anything about this token uri so we actually need to store these attributes on chain i'm really hoping in the future a lot of these nft marketplaces are going to get better at and pulling metadata from on chain but now right now any attribute that we give our nfts we actually have to reproduce in the token metadata and the token uri as well so we've just learned a lot about metadata ipfs token uris and everything like that let's update this simple nft to be able to render on openc and render on these nft platforms because right now if we were to deploy this nobody would know what this doggie looks like so let's give it a token uri so in this crate collectible let's do string memory token uri and after we call this safemint function there's another function that we're importing called set token uri and we're going to set the token uri for the token id and we're going to give it this token uri this will allow our nft to actually have an image associated with it that we can actually see so let's go ahead and so let's go ahead and create a script that's going to deploy this nft factory contract and then create us a collectible so we're going to do new file we'll call it deploy and create dot pi and let's jump into our script so we'll do def main first we need to start with an account and once again we can go ahead and create helpful scripts dot pi we can go ahead and copy paste this get account function in here if you want but of course since we added this config wallet from key we're going to go to our browning config we'll add wallets from key and we're going to grab our private key environment variable since we're using a private key again we're going to create a dot env and we need our to export private key and we're also going to need to export our web3 infuro project id so we can just copy paste for my last project the private key web3 inferior project id and our etherscan token so that we can actually verify this on chain and we'll add a new file init dot pi so that older versions of python know that this is indeed a package so we'll go ahead and do from scripts dot helpful scripts import get account now all we have to do is import our simple collectible and run simple collectible equals simple collectible dot deploy and if we look ours and if we look at our simple collectible we have no constructor parameters here so we can just do from account and now this will have our simple collectable deployed now we need to actually call this now we actually need to call this create collectable function and we're going to pass it a string which is going to be this token uri i'm going to go ahead and use this sample token uri that is included in our nft mix so if you're looking to get this token uri look up nft mix patrick collins hopefully the github will show right up and we can just go right to the scripts in here it's in the simple collectible folder create collectable that's the bigfoot we're going to grab this and in our script we're going to do sample token uri equals this now when you paste this token uri in your browser if you can't see it you might have to add something like ipfs companion to your browser like this some browsers don't natively have it so so there is a link to ipfs companion for this project in the github repo but now that we have a token uri we can call this create collectable function so we'll do transaction equals simple collectable dot create collectible and we'll pass in this sample token uri and then of course we'll do from account we'll do tx.weight we'll wait for one block and then if we've done this correctly we'll actually be able to see this nft on an nft marketplace like open c so let's do a quick print line here we'll do print awesome you can now you can view your nft at and we'll do this in fstring and this is where we're going to put the openc url for this ring b so we're going to say open c url which is going to be equal to if we pop over to open c if we pop over to this open c pug here on the ring p test net we can go ahead and grab this first start of the string so it's going to be https testnets.openc.io assets and then this is the address of the contract so we can say openc url is going to be this slash and we'll put this little brackets here slash and then another one of these and this is because the url for here testness.openc.io assets it's the contract address and then the token id on the end here so this is what it's going to look like so in our print line awesome you can view your nft openc.format simplecollectable.address comma and we do simplecollectable dot token counter minus one for the most recently deployed one and then we'll run this now brownie run scripts deploy and create network rink b and awesome we get this print line here saying awesome you can view your nft at https testness.openc.io just keep in mind obviously for mainnet we can't use this testnet.openc.io but assets the address of the nft contract and then the token id as well so if we go ahead and click this and it looks like it's already actually been rendered here in openc we could even go ahead and hit refresh metadata just in case it doesn't show up right away but it looks like for us it did show up right away which is awesome some other kind of fun parts about openc is if we go to our profile here we'll actually be able to see all the nfts that we own on this testnet i've actually deployed this this doggie twice here once to test and then once i actually do it great we've created our simple collectable of course no project is complete without some tests so let's create some tests since we're also going to be doing an advanced collectible i'm going to skip the integration test and i'm just going to write a really simple unit test so we'll create a new folder we'll call it unit and in here we'll do a new file test simple collec so let's create our first test we'll do def test can create simple collectible we'll just make sure that we can actually create a simple collectible now we'll make sure that this is our unit tests so we'll do from scripts dot helpful scripts import local blockchain environments and then we'll do if network.showactive not in local blockchain environments pi test.skip so of course we need to do from brownie import network and then also import pi test now something that we could do here is actually in our test we could go ahead and even test our scripts by importing uh deploy and create here and testing this we do something like return simple collectible and in our test then we could do from scripts dot deploy and create import deploy and create and then back in our deploy and create script we can modify this a little bit instead of main here we'll call this deploy and create and then we'll have our main function just call deploy and create and you'll see ronnie runs scripts deploying create to pi if we go ahead and run this again we can just run this on the development network real quick instead of on ring p you'll see that this does also work obviously we won't actually be able to see our nft on openc because this is deployed to the brownie temporary ganache chain as opposed to a persistent wrinkly chain in our test here we could then just do we just run simple collectible equals deploy and create and then we'll do an assert here we'll assert simple collectible that owner of zero is going to be equal to get account and then we'll also import get account so we can run brownie test make sure this works and perfect now this was all fun and dandy but there's a couple of things that we didn't go over and that we didn't do so let's create a quick readme.md for a couple of notes so number one we didn't upload an image to ipfs ourselves so we just used a token uri that was already existing right we didn't actually upload something to ipfs we didn't go over why is ipfs decentralized we didn't really talk too much about what ipfs is number three anyone can mint an nft here with any type of stats right it's not going to be it's not verifiably scarce or random right this isn't that cool so we want to actually build an nft project that has all these pieces where we upload the image to ipfs ourselves we're going to talk a little bit more about why ipfs is decentralized and it's the preferred solution for storing nft metadata and we're going to make our nft more verifiably random and verifiably scarce like for things like ethercards and avagoji let's go ahead and do this project again but we'll integrate the chain link vrf to make this nft verifiably scarce and verifiably random and then we'll also teach you guys how to upload to ipfs and work with ipfs ourselves so let's go ahead and do this so let's create a new file in our contracts and we'll call it advanced collectible dot sol and what we're going to do here is we're going to make again an nfc contract where the token uri can be one of three different dogs so if we look at this nft mix in the images section there's a pug a shibba in you and a saint bernard or one of these three dogs we're gonna make it so that when you mint one of these nfts you're gonna get you're gonna get a random one of these three dogs now i'm not gonna go over stat generation and like creating battle battling nfts or really games out of these nfts if you guys wanna see a version of those contracts check out this dungeons and dragons nft there's a link in the github to see this and it actually creates characters that can do battle and have like stats and attributes like um like attack and different things you'd find in dungeons and dragons this one's done actually with truffle as opposed to being done with brownie but all the contracts are going to be the same other than this migrations.soul so if you're looking to check this out you absolutely can it is a ton of fun and they have some really cool images as well so be sure to check that out if you're looking for more anyways here's what we're going to be looking to do we're going to make an nft contract where the token uri can be one of three different types of dogs and it's going to be randomly selected so let's go ahead and do it so first again we're going to do this spx license identifier right at the top so we can go ahead and put that there and we're going to even use same solidity version and we're going to use open zipline again so we can literally just copy and paste that from our last project now we're going to create our contract advanced collectible we're going to say is erc 721 great and then since we're going to want to work with chain link vrf to get a provably random nft we're also going to want to import at chain link contracts slash src v0.6 vrf con consumer base dot sol and of course that means we're going to go back to here and we're going to add smart contract kit slash chain link brownie contracts at 1.1.1 and then we're going to go ahead and add the remapping in we'll say at chain link equals boom awesome so we've imported the chain link bit our advanced collectible is erc 721 and it's going to be vrf consumer base so same as always let's go ahead and start with the constructor we know from our lottery smart contract that we're actually going to want to parameterize a lot of these pieces for working with the vrf coordinator for working on different chains and different test nets so we're going to do address vrf coordinator we're going to do address link token bytes32 keyhash and we can always head back over to docs.chain.link go to get a random number just in case we forget what some of the parameters are vrf coordinator link token keyhash and fee great you went 256 feet i will make this public as well add a little curly bracket there and we can go ahead and start doing the rest of this of course we need to do the vrf consumer based constructor and the erc721 constructor so vrf consumer base is going to be this vrf coordinator and this link token and the erc 721 we could paramore ties these as well but we know it's going to be a dog so we'll do doggy and the symbol of dog which is the same as our simple collectible here we know we're also going to need to do this token counter bit so we'll do you want 256 token counter and right in here we're going to do token counter equals zero of course we're going to need a key hash so let's make this unit 56 public token counter excuse me we're going to do a bytes32 public key hash and we're going to do a uint256 public fee and we'll set key hash equals key hash and fee equals fee great so this is a combination of a lot of the stuff we did in our lottery smart contract and some of the pieces that from our erc 721 we need the key hash the fee vrf coordinator link token all for the vrf consumer base oops i should put a extra quote here and then we need dog doggy and a token counter for erc 721 so now we're going to create our function create collectable so we're going to do function create collectible and again we're going to do a string memory token uri but this time in our python scripts we're actually going to define where we're getting this token uri from and we're going to create it ourselves but we're going to make this public and it's going to return a bytes32 remember way back in our lottery when we did this event requested lottery winner when we called the chainlink vrf we're going to do a similar thing here where we're going to make an event for whenever we request one of these new dogs and that is also what we're going to return we're going to return that request id here so since we're using the chainlink vrf here we can go ahead and call that request randomness function which again over the docs.chain.link this is imported from the erc721 and then in that request and receive model it's going to call back with our fulfill randomness function we're going to need to do a couple of different things here because we want the user who called create collectable to be the same user who gets assigned the token id so first we'll do bytes 32 request id equals request randomness and we're going to pass obviously the key hash and the fee this is going to create our randomness request to get a random breed for our dogs so let's go ahead and just define a little bit of the fulfill randomness function so we can figure out how we're actually going to pick a random dog well the first thing that we're going to need is we're going to need some definition of what the different breeds that the dog can actually be and again similar to the lottery we're going to create a new type called breed using the enum so we're going to do enum breed and then we're going to give it three types pug which is going to be state 0 shiba inu which is going to be state 1 and say bernard which is going to be state 3. so our breed is going to be one of these three breeds here so then in our function fulfill randomness when we get that random number back we can use that random number to pick one of these three breeds so of course we need to have a byte32 request id and uint256 random number and we're going to make this internal override so that only the vrf coordinator can call this and what we're going to do now is we're going to select a breed based off of this random number so we're going to say breed breed which we're saying this breed variable is of type breed it's going to be equal to breed generated from that random number mod 3. since we have one two three different breeds awesome so this is how we're going to get our random breed however we do need to assign this breed to its token id so now that we have a random breedback how do we actually go ahead and assign this well we're going to have to create a mapping to do this it'll look something like token id 2 breed we're going to have to get our token id somehow and we're going to have to equal it to the breed so then our first question is okay well in order for us to assign this breed to the token id how do we actually get the token id well we're going to grab the token id by doing uin256 new token id equals token counter and then we'll just set the token id to breed using this new token id equal to the breed so we're going to want to make this token id to breed mapping up here so which we can do mapping uint256 map2 breed and we'll call it tokenid to breed this way each token id is going to have a very specific breed based off of this mapping's results perfect okay what else do we need in this fulfillment we need to mint the nft and we need to set a token uri well when we minted it before we call this safement function however message.sender here is always going to be the vrf coordinator since the vrf coordinator is actually the one calling this fulfill randomness so we can't actually have this just be message.sender we need to figure out how we can get the original caller of create collectable here how do we get the original message.sender of create collectable well the answer there is actually going to be in another mapping when we call create collectable we can create a mapping of request id to sender and this is going to take the request id as a key and then whoever sent it as the value so we're going to create this new mapping at the top and then actually let's make this other mapping public as well we'll do mapping bytes32 to address we'll call this public request id to sender now in our fulfill function the same request id that requested the random breed is returned so what we can do is we can say address owner or sender is going to equal request id to sender of request id and then this address owner is who we're going to safemint the nft to and of course while we're matching up the functions we don't want to forget to always do token counter equals token counter plus one at the end awesome now we still need to set the token uri here so back in our advanced collectable we're gonna have to do this set token uri at some point so let's actually think about this for a second we're only going to know breed of our dog once this random number is returned and we know the breed of the dog is going to be one of these three breeds it's going to be a bug a shiba inu or a saint bernard and let's actually for now let's even just go ahead and add those three images to our project here create a new folder we'll call it image and you can put whatever images you want here i'm actually just going to download i'm actually just going to download the three images right from the nft mix boom and now i have my pug my shiba inu and my saint bernard in here so anyways it's going to be a pug shipping in you or a saint bernard here we're only going to know what the breed is once the random number is returned and the breed is actually going to govern if it's a pug ship in you or a saint bernard so we technically could actually just get rid of the input parameters for crate collectible since there's going to be no token uri initially created what we could do is we could create a new set token uri function that sets the token uri based on the breed of the dog for the simplicity of this project we're actually just going to create our own set token uri function that we're going to update based off the breed of the dog a challenge for you after we finish this project is to make this even more decentralized and have the fulfill randomness function actually be the one to decide what the token uri is but for now in our fulfill randomness function we're going to skip setting the token uri and we're actually going to call it in a separate function we're going to create our own function called set token uri and we're going to pass it a uin256 token id a string memory token uri and we're going to make this a public function once this fulfill randomness function is responded the breed of the dog is going to be set right this token id to breed is going to say hey this token id now is associated with this breed which is going to be pug shiba inu or saint bernard all we want to do then is now that we have the on chain metadata we're just going to reciprocate that with the off chain metadata so we're going to need three token uris for those three dogs we're going to need one for pug ship inu and then obviously saint bernard however we want to make it so that only the owner of the token id can actually be the one to update the token uri so we can use a require function for this we can say require and we're going to use an imported open zeppelin function called is approved or owner message sender token id and we're gonna do comma here erc 721 caller is not owner nor approved this is approved or own a function if we go into the erc 721 github for open zeppelin we can find this this function is approved or owner which checks the owner of the erc721 of that token id and it makes it so that only the owner or somebody approved to work with this token id can actually change the token uri so then we're just going to call that function called set token uri of the token id and the token uri now we're actually manually going to be the ones to call this set token uri once the breed has been decided we could of course like i said use a mapping at the top that automatically routes it there but so that we can experiment a little bit more and learn a little bit more about ipfs we're gonna leave it a little bit more general like this and perfect this is pretty much the majority of what we're going to need for our erc 721 contract obviously we still need to work with ipfs and getting our token uri but for the most part this is everything that we need now i do i am going to introduce a new best practice here whenever we update a mapping typically a good best practice is going to actually be to omit an event so let's create an event for each one of these mapping updates we'll call it event requested collectible and we'll do a bytes32 indexed request id and we'll also do a address requester this requested collectible event is going to be omitted when we request id to sender because we're updating the mapping here this is also going to be really helpful when we run our tests so we can get this request id similar to what we did with the lottery so down here we're going to do omit requested collectible let's collect dibble here let's use an i instead of an a here collectible and we'll pass it this request id and then message.sender we also update a mapping down here with tokenid to breed so we're going to do a new event we're going to call event breed assigned and we'll do uint256 indexed token id and then we'll do a breed breed and then when we assign the breed here we're going to omit breed assigned with new token id and breed so let's see if we did everything right let's do brownie compile looks like we have a quick error here did you mean fee or fee let's do a quick underscore there now let's try to compile much nicer all right great let's move on all right so now let's take a little looksee at our scripts here so we have this deploy and create script which is going to work for our simple collectable so let's go ahead and actually give them both their own folder so we're going to do a new folder we'll call one simple collectible and we'll do another new folder called advanced collectible and we'll grab this original deploy and crate and we'll place it into this simple collectable folder here awesome now if we wanted to run this we would do brownie run scripts simple collectible deploy and create and we can go ahead and test this out on our local ganache here and cool looks like it's working correctly great so now let's create our advanced collectable script and a lot of what we're going to do is going to be the same as this simple one deploy and create so i'm actually going to copy this we're going to create a new file called deploy and create dot pi we're going to paste everything in here but we are going to change a couple things up so let's do a little bit of refactoring first so this opencrl we're going to be accessing in a couple different scripts so we're actually going to take this copy it get rid of it in our deploy and create here and we're going to move it to our helpful scripts and place it under here openc url equals this script right here and now what we do in our simple deploy and create is we're going to do from scripts.helpfulscript import openc url we're going to delete that here so now in this script this openc url is going to come from our helpful scripts which is what we want and we're going to do the same thing for our deploying create for advanced okay great so i've now copied and pasted all the code from deploying create into this deploy and create for our advanced collectable so let's go ahead and modify this now so instead of from brownie import simple collectible we're going to import advanced collectible and we're going to do the same thing down here and i'm just going to go ahead and delete everything before this we're going to change this to advanced collectible and awesome okay this is going to be our starting point and we actually we can even get rid of this sample token uri great so this is going to be our new starting point we've done a little bit of refactoring now openc url is going to be in the helpful scripts we're pulling in advanced collectible instead of simple collectable and the rest applies we're still using our get account to get the account and now we have this advanced collectible equals advancedcollectable.deploy of course our advanced collectable has a different constructor it's got a vrf coordinator a link token a key hash and a fee so we're going to have to add those as the parameters in here we want to work with ringpi for this because the openc marketplace right now for test nets only works with rinkby so that's why we're going to work with ringby here so let's get started and just grab those ringpie addresses first so our advanced collectable needs a vrf coordinator and a link token so if we head over to the chainlink documentation we go to contract addresses for the vrf we can scroll down to rank b we'll grab the vrf coordinator here and same as before we'll jump into our browning config we'll do networks rinkaby and we'll do vrf core did nator we're also going to need the link token here so we'll do link token we need the key hash key hash and we need the fee which is going to be 0.1 link which we can do fee as one one two three four five six seven eight nine ten one two three four five six seven which can be 0.1 you can of course just copy and paste brownie configs over to different projects because because these values are always going to be the same now on our advanced collectable deploy and create we can go ahead and add those variables in here since we're going to be interacting with actual contracts that are on chain and we're going to want to be able to flip back and forth between the mock versions of them we're going to bring back that get contract function that we used before this is the function that's going to be smart enough to know if we need to deploy a mock or just grab from an actual contract i'm going to show a little fast forward of me rebuilding this function but feel free to copy and paste it from our last project now something that we do need to talk about though is our deploy mocks function the syntax here is going to be basically exactly the same however we do need to deploy a couple of mocks so make sure you have these in your deploy marks function specifically we're going to need a mock link token and a mock vrf coordinator and again feel free to just grab these from our last projects and then of course be sure to add your contract to mock dictionary where the link token is mapped to the link token and the vrf coordinator is mapped to the vrf coordinator if you guys look in the github repo there's a couple try catches there that just make it a little bit nicer for error handling but this is basically the entire script so now what we can do we can go back to our advanced collectable deploy and create import this get contract from our helpful scripts and we'll just replace this with get contract vrf coordinator get contract link token and then for key hash and fee since these don't really matter these can be whatever we want and these aren't really contracts we can go back to our config we'll add the development network and we'll just add key hash and fee and again since it's just testing we can just go ahead and make them exactly the same as ring b done a lot of work now let's go ahead and run this on the development network again so we'll do brownie run scripts advanced deploy and create no network so it's going to default to development let's see what happens here and awesome so we can see we actually did a couple of things here so first we deployed this mock link token then we deployed our mock vrf coordinator we finished that and then we deployed our advanced collectible all on a local network so let's go ahead and continue here once we deploy this code we're going to want to fund this contract with some link the reason we're going to want to fund it with some link of course is that we can call the random number i like to have my funding with link also in a function so we'll do fund with link and we'll give an address advancedcollectable.address and let's go ahead and create this function in fastforward we're going to fast forward this as well but feel free to copy and paste your fund with link functions from past projects or if you want to slow this down and follow along feel free to do that too let's go back to our deploy and create we now have this fund with link that we're going to do right here and then all we have to do now is call our create collectable function here so we'll just do advanced collectible dot create collectible of course from account and we'll do creating tx we'll wait one block confirmation and then we'll print your token has been created so we are definitely going to want to test this because we have a number of custom scripts here right so let's go ahead and just do a manual test so we'll do brownie run scripts advanced collectible deploy and create and we'll do it on a development network whoops we got to add ether here sorry about that in the web 3.2 way one ether so let's go ahead and run this script again and all right it looks like everything worked everything was deployed new token has been created great this is fantastic now ideally before we do an integration test we would of course write some tests but i want to teach some things that are easier to demonstrate on an actual test net so we're going to go ahead and deploy this to an actual test dent before we write our tests so we're just going to run the script again and do dash dash network rank b and awesome a new token has been created so what we can do is we can grab the contract address once again we'll paste it into the rank b ether scan and we can see everything in here we can see we've given it a little bit of link we can see our two function calls one is going to be the contract creation one is going to be create collectable our contract has already been auto verified actually because i verified this contract on rank b already and etherscan says ah this bytecode is the exact same of another contract that we've already verified and if we go to read contract and we go to token counter we'll see one token has been created we've actually created our first token now what we can do in our advanced collectable scripts we can create a new script and just call it create collectable dot pi and in here we'll just create a collectable so well all we have to do is we'll do def main per usual we'll have to do from brownie import advanced collectible we'll import accounts from our helpful scripts we'll import fund with link in our main function we'll do account equals get account of course we need to import this as well for my helpful scripts then we'll do advanced collectible equals advanced collectible minus one because we just want to get the most recently deployed we'll fund this contract with link so we'll do advanced collectible.address and we'll also choose an amount here we'll just do web3.2 way of 0.1 with ether that means we also have to do from web3 import web3 then we'll do transaction then we'll do creation transaction equals advanced collectible dot create collectible from account we'll do creation transaction dot wait we'll wait one block confirmation and then we'll print collectible created oops sorry i actually don't have to import account here or accounts excuse me and sorry this actually needs to be amount equals excuse me now let's go ahead and run this and what we're going to do is we're going to fund our advanced collectible with link which is 0.1 link and then we're going to create a new nft awesome collectible created so if once again we take this address go back over to etherscan do a quick refresh here we go to our contract read contract we'll look at the token counter it may still be one so you might have to give it a second for the chain link vrf to respond once the chain vrf responds we'll see 2 in here we can also check the token id to breed if we look at 0 with 1 we'll see the breed is 2. and if we look back at our contract the advanced collectible without soul we know that if the breed is two that means it's a saint bernard see the token id of one it has a breed of one so it got randomly assigned a shiva inu awesome so we have tokens and they're get randomly assigned breeds fantastic as you can see we're doing kind of a lot of manual testing work here right so what we're probably going to want to do instead is you guessed it automate these tests now go ahead and want to deploy dance import that deploy script that we just wrote so we would do from scripts dot advanced collectible dot deploy and create import deploy and create and then all we have to do is call deploy and create in this function we'd probably want to then return the advanced collectible contract so we can make sure that we actually get what we want here so we'll say advanced collectible equals deploy and create and that'll be our acting step beginning we'll do arrange then we'll do an assert of we'll just check to see that the token counter has been increased we'll do assert advanced collectible the token counter is equal to one all right great so this will return our advanced collectable however we know that since we're actually going to be working with a mock vref coordinator if we look at our advanced collectible we know that the bulk of the work actually comes in this fulfill randomness function and we're going to have to tell our mock to actually return and call this function so in order to do that we should probably also return this creating transaction here so that we can get the request id remember how in our lottery we actually just directly called everything and we needed this request id to call this callback with randomness function in our test here we're actually using our scripts a little bit so we could either just go ahead and write out all the steps similar to what we did in the lottery or we could adjust our scripts a little bit for simplicity here we're just going to go ahead and have this deploy and create function also return the creating transaction this way we can go ahead and get the request id so back in our test here that means we have to do deploy and create equals advanced collectible and creation transaction now that we have this creation transaction we can use it to get our events and again if we look back in our advanced collectible we can see here that we're omitting this requested collectible with request id so we can go and do request id equals creation transaction dot events we'll add the name of our event here which is requested collectible and then we'll get that request id once we have this request id we can then go ahead and grab the vrf coordinator so from our scripts we'll grab this get contract and we've coded our get contract in a way that if the mock has already been deployed again if we go back to our helpful scripts if the contract has already been deployed then we're just going to go ahead and grab it so since here our mock will have already been deployed so we don't have to redeploy it so we can just do get contract vrf core did nator dot call back with randomness and we'll use the request id we'll pick some number like 777 we'll give it to the address of our advanced collectible and remember we're going to be calling the callback with randomness this is what a real chain link node is actually going to call back and it just needs a request id a randomness number and a consumer contract so request id random number and then the consumer contract and then of course we have to do a from account from get account and we'll import get account as well now we can move into our cert phase so first if this is correct then our token counter should be at least one so we can assert advanced collectible dot token counter is greater than zero or we could be a little bit more specific here equals equals one we also should technically be able to get the breed and figure out the breed of this first token of this first collectible let's go ahead and parameterize the 777 we'll call it random number equals 777. we'll place that here and then what we can do is we can say certain collectible dot token id to breed of zero right in our fulfill randomness we're going to assign the token id to being the breed and the breed is going to be this random number mod 3. so on our test we can say the token id to breed of dog 0 is going to be equal to random number mod 3 and this is pretty much our full test so let's go ahead and run this we can do that test with dash k whoops it looks like our simple test has actually got an error now we're getting this module not found no module named scripts.deploy.create this now since we actually changed it it's going to be scripts.simplecollectable.deploy and create so now if we rerun our test we'll see brownie isn't going to err out anymore so even though we skipped this test brownie still compiles it to make sure that everything makes sense but what we see here is fantastic our advanced collectible unit test has worked perfectly let's go ahead and make an integration test for our advanced collectible here so now we'll have our test folder here and we'll have unit and we'll have integration our integration test is actually going to look really similar to our advanced collectable here so i'm just going to go ahead and copy everything new file test advanced collectible integration pi and we'll just paste everything in here now the only thing that we're going to have to change is that we're not going to be the ones to call back with randomness here so we can remove this part we also don't need the request id anymore since the chain link node is going to be responding this means that the breed that we're going to get is actually going to be random so we can get rid of that assert as well all we need to do is wait for the transaction to get called back so we're going to import time and instead of us calling back with randomness we're just going to do time dot sleep then we'll wait 60 seconds test can create collectible we should also give this a different name integration now we should be able to test this on a ring b chain and our token counter should indeed increase with the chain link node actually responding so now we can run brownie test dash k just that test dash dash network rink b oh whoops right now we're skipping this because we're saying only for local testing now since this is going to be our integration test we're going to do the opposite if network.showactive is in these local blockchain environments then we're going to skip it and say only for integration testing all right great so now we have a quick and dirty integration test that we can run we're not going to run it for now because we're going to be working a lot with this rigby chain and we're going to be deploying a lot of different things and we don't want to wait so long so this is fantastic we have a way to deploy this we have a way to get these new collectible tokens and create them but if we were to take this address right now and try to view this token on something like openc we would get nothing back we wouldn't get any result right now our token doesn't have a way to be viewed or be visible by everybody else these mt platforms don't know what they look like and again this is where that set token uri is going to come into play so we have to figure out a way to host an image and host all the metadata for our token uri and the way that we're going to do this is by using ipfs and this is a lot better than actually hosting this on our own server because anybody can then go ahead and host this image or this metadata themselves now there's further improvements to this with something like filecoin where you actually pay to have your image hosted forever however ipfs can hook into filecoin in the future and is going to be a good enough solution for what we're looking to do here just keep in mind that what we do not want to do is run this on a centralized server when we spin up our ipfs node we will be the only node that actually runs and actually hosts our image however the image is open for anyone to pin to their nodes as well so it's much easier for us to host our images in a decentralized manner what's bad obviously is if we just had the image stored on our own centralized server because if our server goes down then that url no longer exists if at least one node on the ipfs network is hosting this image it will be available for anybody to see so that's why it's going to be a much better solution than some centralized server as i mentioned decentralized storage is a topic that's getting better and better and we're looking forward to seeing more and more ways to interact with them in any case we need to create an ipfs node that's going to host some data that looks like this or like what we saw with our simple collectable it needs to host metadata that will look like this we both have to host a metadata file and an image uri file which will host the actual image both of these need to be stored on ipfs so let's go ahead and create a new script called create metadata which will read off chain and create our metadata file so we'll start our scripts per usual with def main and we'll get the most recently deployed advanced collectible using this 1 syntax of course we're going to do from browning import advanced collectible once we have this advanced collectible we can then loop through all of the tokens and actually figure out the metadata for each one of them so we'll do number of advanced collect bowls equals advanced collectible.tokencounter because we want this crate metadata to create the metadata for every single token that we've created do a quick print line here just saying print you have created number of collectibles collectibles we even run this really quick brownie run scripts advanced create metadata network rank b since we've already run this on the ringpi chain we'll see you've created one collectible if i were to run our create collectable script again and then our create metadata script would of course get more but right now we only have one collectible now let's loop through all these collectables and create their metadata so we're going to create that that file it looks like this and it's going to have it's going to have the name which is going to be based off of the random breed that i got it's going to have the description which is based off of again the random breed that i got it's going to have an image which will also be based on the random breed that it got and i just put some attributes in here but again these attributes so we're going to say for each token id in the range of number of advanced collectibles for each one of these advanced collectibles first we need to get the breed so we're going to say the breed the breed is going to be equal to advanced collectible dot token id to breed of the token id now advanced collectible that token id to breed this is going to return an integer right because again our advanced collectible this enum breed is going to be 0 one or two so we actually want to create a quick mapping that represents that zero is pug one is shipped in u and two is saint bernard so i actually like to create this in a helpful script called def get breed and then it takes as an input it takes a breed number and it uses a switch statement so up top we'll say breed mapping equals zero is going to be pug one is going to be shiba inu and two is going to be saint bernard so in this get breed function now we can just do return breed mapping of that breed number that we get so instead of doing advanced collectible the token id to breed we can now just do get breed and this will this will return the number and this will return the actual string so we can just do from scripts dot helpful scripts import get read now that we have the breed we can start creating this metadata file now what we're going to want to do is we're going to want to have some type of format for our contract to always pull from so what i like to do here is i'll create a new folder called metadata and in this folder i'll have a new file called samplemetadata.pi and then i just have metadata template equals and i'll just have this this template that we're always going to use now in here we're going to need a name and then we're going to leave the name blank because we're going to want to fix it later we're going to have a description which we're also going to leave blank for now we're going to have that image uri which will also leave blank and then we're going to have some attributes which should be blank for this dog because we don't actually have any onchain attributes but i'm just going to go ahead and add some to show you what you could do if you wanted to give your dog some stats you know maybe maybe cuteness maybe maybe raw power maybe speed agility you know whatever you want to do so we'll do trait type gonna be cuteness and then value is gonna be 100. this would basically say hey there's a trait type called cuteness and the value of that is a hundred so the cuteness of the dog is 100. so now once we have this sample metadata file we can import this into our script here so we'll say from metadata dot sample metadata import metadata template and another quick note you might have to put a underscore underscore init underscore underscore dot pi file in that metadata folder if you're working on older versions of python and we start creating our new metadata file for this break for this dog we want to save each collectible under their network and with their token id so let's go ahead and create a new folder call it rink b and this is where we'll save all of the rink b metadata for all these collectables for all these token ids now before we actually save it though we should just check to make sure that the file doesn't already exist right because if the file already exists that means we've already created the metadata for that token and we don't need to so we can just go ahead and get the metadata file name which is going to be equal to dot slash metadata slash network dot show active of course this means we need to import network from brownie slash the token id token id with a hyphen with the breed dot json just to make sure we're doing this right we can even just print this out do a quick manual test brownie run scripts advanced create metadata network rink b so this will be the name of the file so metadata rink b token id and then the breed.json okay cool now we can actually check this to see if this already exists and we're going to use a python library called path so we're going to say from pathlib import path and we're going to say if that path this metadata file name dot exists if that path exists we'll do a quick print saying metadata file name already exists delete it to overwrite this way we won't accidentally overwrite metadata that we've already created and do extra work so if it exists we'll print that out great otherwise we can go ahead and print print def creating metadata file metadata file name you can even run this real quick great you have one collectible creating metadata file perfect so let's go ahead and start creating this metadata file so we're have to give it a name description image uri and we're not gonna give it any attributes though so just name description and image uri so name is easy enough since this is a dictionary or a mapping in python we can actually just go ahead and start mapping so up above before this if we'll do collectible metadata it's going to be equal to this template so this is going to be where all we sort all of our metadata and we'll say collectible metadata of name is just going to be the breed so if it's a pug the name will be pog if it's shipped in you name it will be shipped in you if it's st bernard name will be saint bernard and we'll give it collection metadata description is going to be equal to we're going to do an f string here and adorable breed pop now if we print out this collectible metadata we should see at least the start of the metadata which we do great name saint bernard description and adorable saint bernard pup of course you'll have a different random breed but it should look something like this now we're going to need collectible metadata image uri this is where we're going to have to have our image already uploaded to ipfs so we can assign it to our metadata here so how are we going to do this well we're probably going to need some upload to ipfs function it's going to return our image uri and then we can just set that image uri to the collectible metadata of image so let's go ahead and start doing that let's create our upload to ipfs function now in order to upload to ipfs we of course need to have the images ourselves i already have them downloaded here and again you can download them right from the github yourselves if you like to make this a little bit generic we'll have this upload to ipfs take a file path that way we can pass this imagery upload to ipfs we're going to give it some type of file path here we're going to have to grab that image path so we'll grab that image file name by just doing breed dot lower because right now our breeds are all upper case so we're going to want to make a lower case then we're going to replace the underscores with hyphens dot png so we'll say plus dot png and then you know let's just go ahead and add the full path here so we'll say dot slash image slash plus 3. lower perfect so and then we'll even change this to image path and then we can pass this to our upload to ipfs so this file path now is going to be the location of the object that we're going to upload to ipfs we're going to use this path library to actually grab that path to upload it to ipfs so we're going to say with path file path dot open rb as file path now this is a little bit of sophisticated python here what we're doing is we're taking this path here we're opening the file rb means we're going to open it in binary since these are images that's how we're going to actually open it and we're going to upload the binary actually to ipfs and then as fat fp so we're saying this opened file is going to be named fp or file path we're going to do image binary equals fp.read and that's how we actually read the whole binary and now this whole image is stored as binary in this image binary here now here's where we're going to do the upload stuff now to get started here we're actually going to have to download the command line for ipfs download command line ipfs we'll come right to the docs here and again there's going to be a link in that github and in here there are instructions to to download it for whatever system that you're working on right if you're working on windows if you're on linux if you're on mac these are the different ways to actually download this ipfs command line you'll know you've done it right if you can type ipfs version and you see something like ipfs version 0.9.0 it's important to note that we could also do the ipfs download desktop and we could download the desktop version of this and we'd see a user interface which looks something like this we could upload our files manually and then manually go ahead and grab those files and place it into our scripts but we're engineers we want to do this programmatically in any case once we have this api downloaded we can actually follow the documentation here the http api reference for actually uploading our code we're going to be mainly working with this endpoint api v0 slash add as this is the endpoint that's actually going to add our file or directory to ipfs now what we're going to want to do is we're going to actually upload our images to our own ipfs node we can run our own ips node by doing ipfs daemon and we'll see an output that looks something like this we can even see a web ui using this web ui url here this will look similar to what the ipfs desktop looks like but again we're going to work just mainly from this damien from our own ips note congratulations you're running your own ipf's node right now as you can see it's currently running on our own localhost right here http 127 0.0.1 at port 5001. so to actually upload this we're we first need to get that ipfs url which is going to be equal to this url right here paste now we want to make an api call or a post request to this endpoint using this api v0 ad and these are all the different parameters that this ad can actually take in so that we can actually post it to ipfs for those of you familiar with curl and you want to test this out using a curl i've added a curl into this create metadata file as a comment so that you can actually go ahead and test this if you want to use this now what we're going to want to do to keep working with our scripts is you should have like a little plus button somewhere on your vs code we're going to hit that plus button and now we're actually going to have two different shells one which is running our ipfs node and one which is running our bash or zch or whatever other shell that your os natively works with now that we have this ipfs url we're going to grab the endpoint which is going to be again this right here dash api dash v0 add and we can make a post request to it so for us to do that we're going to say response equals requests dot post we're gonna do the ipfs url plus the endpoint and we're gonna say the files that we're gonna upload is gonna be equal to file image binary requests is a python package that we're going to import so we're going to say import requests now if we go back to the ipfs documentation we can scroll down to see what the response looks like it's going to return a bytes a hash a name and a size now if we look at this sample token uri we can see the api call here ipfs stores all its data using a hash and if we're looking at this and if we're looking at the simple collectible this hash here is the hash that represents this pug.json file everything in ipfs gets hashed and every single piece of data has a unique hash which is why it's so fantastic if we were to change anything with this image this hash would be drastically different all we need to do is get the hash that ipfs gives the image that we upload we go ahead and plug it into a template url like this one here so what we're going to do then is we're going to say ipfsh it's going to be equal to this response.json since we're just going to jsonify the response to make it look like this response here and we're going to grab that hash right since it's going to return this dictionary we just want the hash here then we're going to give it a file name by saying it's going to be that file path dot split we're going to do some fancy python stuff here we're going to say 1 to 0 which basically all this line is doing is saying you know if we have dot slash image slash pug dot png we're going to remove we're going to split it up by these slashes into an array and we're going to grab the last part of the array so we're basically just changing this to this with this line right here then with this we can get the image uri which is going to be equal to an f string again https ipfs.io ipfs slash ipfshash question mark file name equals file name and it's this format right here which will give us this so if i go ahead and even just copy paste this under as a comment to show you guys we see this part's exactly the same and then this is that hash here represented here and then we have question mark file name equals and then the file name so excuse me this is actually gonna be like zero hyphen pug zero hyphen pod and that's exactly what we need we need this image uri so we'll do a quick print image image uri and then we'll go ahead and return the image uri now since we're actually going to be testing this with ipfs we can add a new integration test so we'll call this test ipfs upload.pi now you might want to write a test for this and we're not going to do one but i challenge you to later on maybe come back and and write your own test for this upload to ipfs for now we're actually just going to manually test it so we're going to go back up to our script here and we're going to run image uri equals upload to ipfs image path and then we're going to get printed in image url since we're working with the saint bernard here we should get a saint bernard image uri so if i run brownie run scripts advance create metadata network rink b let's see what happens i need to add brackets here sorry about that now let's try it again awesome we were able to create this metadata file now if we go ahead and copy this and paste it perfect we see exactly what we're looking for we see our saint bernard awesome job and this has been uploaded to our own ipfs node now i want to show you guys actually another service and another way we can actually upload these to ipfs some people don't want to run their own ipfs node because they're not actually going to be keeping it running the whole time anytime their node goes down this means that nobody will be able to see your image unless somebody else pins your image or or uses your image so what i also like to do is i like to upload it to some other thirdparty service as well as uploading it to my own ipfs note so i like to create another script actually called deploy to pinata so let's go to scripts new file upload to pinata.pi so pinata pinata is an ipfs file management service and they actually will pin whatever files that we're working with as well so we'll have it pinned in our node and they will have it pinned as well so we can go ahead and register awesome this is what pinata looks like it's a way to upload and work with ipfs and they'll give us some extra support and they have a free tier which is fantastic as well they have some wonderful documentation as well under this documentation section so let's go ahead and upload this to ipfs so that when our node goes down our images don't go down so we'll do pinata base url is going to be equal to https dash dash api.pinata.cloud you can find all this in the documentation as well if we scroll down the documentation we're going to be using this pin file to ipfs endpoint here and you can see that entire endpoint right here with the base and then the endpoint so we're going to copy that endpoint we're going to say endpoint equals pinning pin file to ipfs we're going to choose some file path and for us we're just going to do dot slash image slash pug.png of course if you want to upload some other image you can you know change this file path or you could even do some type of for loop to pin everything uh in the image section here again we're going to do file name we're going to use that same syntax before that's we're doing file path dot split slash some fancy python stuff just to get this last part and we also need and we need to use some headers in this post request so it's a type post request we need to use some headers here so we're going to say headers equals copy this pinata api key which is going to be some api key and then we also have this pinata secret api key pinata secret api key which is going to be something else we can find these two api keys if we scroll all the way down we hit api keys create a new api key i'm going to call this you can make this an admin key i'm just going to do limit max users limit max uses i'm going to set this to 200 because i'm going to make this a public key so i don't want people using this a million times please make sure you select at least one permission pin file to ipvs for those of you guys watching you can absolutely just grab all these if you want you can make this an admin you know do whatever you want to do here since i'm only going to be using this pin file to ipfs that's all i'm going to do hit create key and here are our tokens here so our api key is going to be right here and we're going to copy that we're going to open back up that dot env and add this as one of our environment variables here so we're going to export pinata api key equal to that key there this api secret we're going to copy and we're going to export pinata api secret equals that key there and we actually don't need this jwt but if you guys wanted to you could copy it as well so now that we have them in our dot env file these are now going to be environment variables that we can use and brownie's going to automatically put them into our environment so what we can do then is we can do os dot get env pinata api key and then of course we're going to import import os and then for our secret key we're going to do the same thing os dot get env pinata api secret this is how we get those two headers for uploading to pinata then we're going to do a lot of the same code we did before we're going to say with path a file path dot open rb for the binary as fp of course since we're using path we're going to do from path lib import path we're going to do this same piece image binary equals fp.read response is going to be equal to requests which we have to import requests import requests dot post pin you have a base url plus that endpoint that we have and for files oops it's going to be equal to file and we're going to upload a couple of things here though we're going to give it a file name we're going to do the image binary and that is getting really annoying when it keeps getting in the way file name image binary and then outside of these brackets here we're going to do comma headers equals equals headers and then we're just going to print response.json so to have this run in browning we're just going to do a def main function here a nice little trick we can do is we can select all this text and just hit tab and it'll move it over one and perfect we can now run this inside of brownie so we can do brownie run scripts upload to pinata and perfect we get a little output that's going to look something like this it's going to give our ipfs hash the pin size the timestamp so now if we go back to pinata we go to pin manager do a little refresh here we now see our pug has actually been uploaded to pinata awesome work we're going to keep going using the ipfs daemon to actually upload things but if you want you could totally swap out this upload to ipfs to use that script that we just created to upload it via pinata instead of our own ipfs node anyways this upload to ipfs is going to return this image uri so we can go ahead then and set the image uri it's going to be set on this collectible metadata image and then all we have to do is dump this collectible metadata into its own file and then upload that as well to ipfs we'll dump this to its own file by doing with open metadata file name and we open it with a w which means that we're going to write as file json.dump collectable metadata to the file so we're going to import json to do this and what this is going to do is just going to dump this dictionary as json to this collectable metadata file then we can upload to ipfs also this metadata file name and this upload to ipfs should print out the image uri or in this case the metadata uri so let's go ahead and try this out so remember we do need our ipfs daemon running let's go back to our scripts and we'll do brownie run scripts advanced create metadata network rank b and boom okay so here is our image uri which we click this will be able to see looks just like this and then here is our uploaded saint bernard metadata file which is fantastic so now we have both a metadata file and we have an image uri this is fantastic we've uploaded both of these to our ipfs and if we scroll over go to our metadata file in ring b we'll see we have this new file in here because we've gone ahead and saved it in here it has everything that we need it has st bernard it has the description it has this image uri that we just created and it has some attributes that again we're basically ignoring now to make our lives a little bit easier and since i've already actually uploaded these to ipfs myself a couple times and since the hashes of these are going to be the exact same for all of us when we upload this we're going to go ahead and just quickly refactor this to make it a little bit easier so we don't always have to have ipfs running so in our dot env i'm going to add a new environment variable called upload ipfs and we're going to set it equal to false so now down here i'm just going to say if os dot get env upload ipfs equals equals true anyway since we're going to do os here we're going to do import os and before this i'm going to do image uri equals none and we're going to say image uri equals image uri if image uri which again i know this could be a little confusing but we're saying we're setting image uri to whatever image uri is if image uri isn't none else we're going to create a mapping called breed to image uri of the breed so again since i've already uploaded them i already know what all these image uris for these three dogs are going to be so up at the top we're just going to create a new mapping called breed to image uri equals i'm actually just going to go ahead and copy paste this whole thing now you can skip this you don't have to refactor here and you can just always have your daemon running and always upload to ipfs it's a little bit quicker to not always have to do that again this brief image uri is in the github repo feel free to just copy paste it to use it you can even click the links to check it to check to see that those image uris are really there and this is what we'll use so back down here reach the image uri uri perfect and then we're also going to add if again os.get env upload ipfs equals equals true then we're also going to upload to ipfs down here but this is to go and actually just show you how exactly we could upload all this stuff to ipfs since i've already done it we're going to make it a little bit easier on ourselves another thing that you might do is you might actually save all these urls to their own file to their own json object maybe inside of the metadata folder maybe under wrinkby or something and then you could go ahead and just pull directly from those files same thing with the metadata once we upload to ipfs we're not actually going to save these urls anywhere you could absolutely 100 percent after you run this upload to ipfs script we go ahead and save it to a file and pull directly from there moving forward but awesome okay so we've done a lot of work here we have uploaded to ipfs our metadata and our image uris so we have everything that we need to actually just set the token uri finally for our advanced collectible we finally can call this set token uri function so let's go ahead and do this last bit here this last set token uri function so let's go to scripts advanced scripts create a new file we'll call it set token uri uri dot pi and this is where we're gonna set the token uri so we'll do def main and in here we'll do a quick print print f working on network dot show active of course since we're using network from browning imports network to close that there and let's grab the most recent advanced collectible it's going to be equal to advanced collectible minus one since we're using advanced collectible contract let's import that from brownie let's once again loop through all the tokens that have been deployed so we'll do number of collectibles equals advanced collectible dot token counter do a quick print you have print f excuse me number of collectibles token ids and let's loop through this list of collectibles again so we'll say for each token id in range number of collectibles first we'll get the breed saying breed equals advanced collectible token id to breed of the token id we actually have to call this getbreed function again which luckily we generalize so we can do from scripts.helpfulscripts import get breed and now let's first before we actually set the token uri let's check to see if it already has a token uri set so we're going to say if not advanced collectible dot token uri of token id dot starts with https so what this line is doing i know it's a little bit long is we're grabbing advanced collectible.token uri of the token id so we're grabbing this token ids token uri and we're saying if it doesn't start with https that means we know that it hasn't been set so we can go ahead and print setting token uri let's actually make this a print f of token id and then we can set the token uri so i'm actually going to generalize this out into its own function so let's go ahead and we'll do def set token uri and as inputs this is going to take the token id the nft contract which is going to be our advanced collectible contract and the token uri so the first thing that we're going to do we'll say account equals get account so we're going to grab this get account of course from our helpful scripts because this set token uri is actually going to call that set token uri function we're going to say nft contract dot set token uri of the token and the token uri remember this is a function that we added to our advanced collectible right here set token uri it takes a token id and a token uri and this is going to be from of course account we just created so we're going to say transaction equals that we'll do transaction.wait wait one second for it or one block for it and then we'll print we'll do printf awesome you can view your nft at we use that openc url dot format nft contract.address comma token id then i'm just going to add another print here saying please wait up to 20 minutes and hit refresh metadata and hit the refresh metadata button so now we have our set token uri function we can add the token id in here the advanced collectible contract and then we just have to add the token uri here so since we've already uploaded and since i've already actually uploaded all three what you could do and what i like to do is just have a dictionary here so we don't always have to be pulling from something so i have a dog metadata dictionary it's going to be equal to and we're going to add those different dogs in here so saint bernard this this saint bernard url we're going to paste it here i've actually gone ahead like i said and uploaded this metadata for all three dogs so i'm just going to go ahead and copy paste all three in here again we're shortcutting a little bit here but what you could do is you could save all these metadatas to their own file and you could just pull from that file instead of doing kind of this dog metadata dictionary so in any case though we're going to do dog metadata dictionary of breed right because dog metadata dictionary of saint bernard is going to be this which again has our image uri has everything about our dog and is perfect what we also might want to do is write some tests around our set token uri function of course but i'm just going to move on so in any case we've done a lot here i'm actually going to even close down my ipfs node and we should be just about ready for everything so of course we'll run our brownie test we want to make sure that all our unit tests are working great which they look like they are working fantastically but we are ready to do a full endtoend manual test here and you could 100 and i actually highly encourage you to 100 we're just gonna run these scripts in order and look to see if our stuff shows up on the openc nft marketplace so are you guys ready let's do this so make sure of course your environment variables are set here make sure that your metamask for rink b has some eth and has some link and then we can go ahead and start running some of these scripts so we'll do brownie run scripts advanced collectible deploy and create network rink b integration test moment of truth and perfect a new token has been created awesome we can even go grab this address let's delete all these tabs that we have opened up and we'll go to ringpi.etherscan.io we'll paste it in here and we can see contract has been verified even though we didn't verify it because it matches some other source code we can see token counter is one and we can even go to tokenid to breed of zero see what breed it is so it's breed two and it looks like we're getting a saint bernard again which is incredibly adorable we can even go to events here and we can see the different events since this is verified we can even see the name of the events so we have our breed assigned event and we have our requested collectible event first is an index topic of token id and then there's the un8 read and then we have the bytes32 request id and the address requester now let's run our create metadata script here so we'll do brownie run scripts advanced create metadata network rink beam we don't have to run create collectible since our deploying crate already does that so now if we run our create metadata i've actually already have i actually since this is the same bernard again i'm going to go ahead and get this already exists delete to overwrite so what i'm going to do is i'm actually going to even create another one so that i get a new nft so i am actually going to run this crate collectible script so we're going to do brownie run scripts advanced collectible create collectible network rank b and what this is going to do all it's going to do is it's going to fund with some link which it's going to be a little bit overkill with the link but that's fine and then we're going to do advanced collectible.create collectable so we're just going to do two transactions here perfect collectible has now been created now i'm going to wait a solid 30 seconds to have that chainlink vrf respond and i'm even going to go to the contract give it a quick refresh look at this token counter once the chainlink vrf responds this token counter will then be 2. now that i see a token counter of 2 here that means that it actually has responded so we can now run the create metadata script and we should have a new metadata file now you have two collectibles zero saint bernard already exists deleted to overwrite create a metadata file metadata ring b pug so now if we look in metadata for rink b we have a saint bernard and we now have a pug awesome so we're going to set the token uri of both of these if i grab this contract and i go to testnets.openc open c i can paste this address in and i'll get this doggy and then this random hash here right and we see there are two token uris deployed again if they're not here you might have to refresh but they don't have the images right because we haven't set the token uri so we'll go back look at the advanced collectible we've deployed and created we've created another collectible we've created their metadata now all we have to do is set the token uri so brownie run scripts advanced collectible set token uri network rink b and this script it's going to loop through all of them and actually going to set those token arrives so we have setting token uri of 0 so this transaction is doing exactly that and it's going to go ahead and say awesome here's your output and then it's going to say setting token uri of token id one and that's that second transaction and it also gives us an output to that one as well so if we've done this correctly and we hit refresh metadata on this testnet openc.io and we do a little refresh here we can now see our saint bernard which is fantastic and then if we change this from 0 to 1 since i've deployed 2 and i refresh this one's metadata and then refresh the page we can now see the pug as well again just keep in mind sometimes the refreshing metadata does take some time and you might have to wait up to 20 minutes but for all intents and purposes we have just deployed our nfts given them token uris that aren't around centralized servers we can now see them on an nft marketplace like openc you can let out a big sigh of relief because you just did something fantastic that not a lot of other engineers can do you should be incredibly proud of yourself at this point let's take a minute go back over to some of the new things that we've learned here when deploying your smart contracts on chain we all know that those smart contracts are immutable or unchangeable but what if i told you that they were mutable well technically i wouldn't be correct however smart contracts actually can change all the time when people transfer tokens when people stake in a contract or really do any type of functionality those smart contracts have to update their balances and update their mappings and update their variables to reflect this the reason that they're immutable is that the logic itself never changes and will be on chain like that forever so technically yes once they are deployed they are immutable and this is actually one of the major benefits of smart contracts in the first place that nobody can tamper with or screw with our smart contracts once we deploy them however this can be an issue if for example we want to upgrade our smart contractor protocol to do more things or we want to fix some glaring bug or issue that we have now even though we can't change the specific code that's been deployed to an address we can actually do a lot more than you think we're going to explain the different methodologies behind upgrading your smart contracts and then we're going to show you how to do it now at first glance you might be thinking if you can upgrade your smart contracts then they're not really immutable then in a way you'd be right so when explaining kind of the different philosophies and patterns that we can use here we do need to keep in mind the philosophies and decentralization implications that each one of these patterns have as they do all have different advantages and disadvantages and yes some of the disadvantages here are going to affect decentrality so we need to keep that in mind and this is why it's so important that before you go ahead and jump in and start deploying upgradable smart contracts you understand the tradeoffs we're going to look at three different ways to upgrade your smart contracts the not really upgrading method the social aka my grading method and then the method that you're probably here for which is proxies so let's talk about the not really upgrading method or the parameterization method or whatever you want to call it this is the simplest way to think about upgrading your smart contracts and it really isn't upgrading our smart contracts because we can't really change the logic of the smart contract whatever logic that we've written is there we also can't add new storage or state variables so this is really not really upgrading but it is something to think about upgrades is just parameterizing everything whatever logic that we've deployed is there and that's what we're interacting with this function means we just have a whole bunch of setter functions and we can update certain parameters like maybe we have a reward parameter that gives out a token at one percent every year or something like that maybe we have a center function that says hey update that to two percent or update that to four percent it's just a setter function that changes some variable now the advantages here are obviously this is really simple to implement the disadvantage is that if you didn't think of some logic or some functionality the first time you deployed their smart contract that's too bad you're stuck with it you can't update the logic or really update anything uh with the parameterization aka not really method and the other thing you have to think about is who the admins are who has access to these setter functions to these updating functions if it's a single person guess what you have a centralized smart contract now of course you can add a governance contract to be the admin contract of your protocol and that would be a decentralized way of doing this so just keep that in mind you can do this method just need a governance protocol to do so another example of this might be a contract registry and this is something actually that early versions of ave used before you call function you actually check some contract registry that is updated as a parameter by somebody and you get routed to that contract and you do your call there again this really doesn't allow us to have the full functionality of upgrades here you can argue that this registry is a mix of one of the later versions but for all intents and purposes this doesn't really give us that flexibility that we want for our upgrades but some people might even think that upgrading your smart contract is ruining the decentrality and one of the things that makes smart contracts so potent is that they are immutable and that this is one of the benefits that they have so there are some people who think that you shouldn't add any customization or any upgradability you should deploy your contract and then that's it trillabits has actually argued that if you deploy your contract knowing that it can't be changed later you take a little bit extra time making sure you get everything right and there are often less security vulnerabilities because you're just setting it for getting it and not looking at it again now if i were to deploy a smart contract and i wanted to upgrade it with this philosophy in mind that hey we got to keep it immutable we could use the social yate method to actually upgrade to new versions the social yet method or the migration method is just when you deploy your new contract not connected to the old contract in any way and by social convention you tell everybody hey hey this new contract this new one that we just deployed yeah this is the real one now and it's just by convention of people migrating and over into using this new one that the upgrade is done hence my slang name of social yi because you yeet the first one out of the way and move to the second one i think i'm funny this has the advantage of truly always saying hey this is our immutable smart contract and this is our new one this is really the truest definition of immutable because since you give it no way of being upgraded in place then if somebody calls that contract in 50 000 years in the future it'll respond exactly the same another huge disadvantage here is that you have to have a totally new contract address so if you're an erc20 token for example you have to go convince all the exchanges to list your new contract address as the actual address keep in mind that when we do this we do have to move the state of the first one over to the second one so for example if you're an erc token moving to a new version of that erc token you do have to have a way to take all those mappings from the first contract and move it to the second one obviously there are ways to do this since everything is on chain but if you have a million transfer calls i don't want to have to write the script that updates everyone's balance and figures out what everyone's balance is just so i can migrate to my new version of the contract so there is a ton of social convention work here to do trailer bits has actually written a fantastic blog on upgrading from a v1 to a v2 or etc with this yeet methodology and they give a lot of steps for moving your storage and your state variables over to the new contract so link in the description if you want to read that now let's get to our big ticket item so in order to have a really robust upgrading mentality or philosophy we need to have some type of methodology or framework that can update our state keep our contract address and allow us to update any type of logic in our smart contracts in an easy way which leads us to our big ticket item the proxies proxies are the truest form of upgrades since a user can keep interacting with the protocols through these proxies and not even notice that anything changed or even got updated now these are also the places where you can screw up the easiest proxies use a lot of lowlevel functionality and the main one being the delegate call functionality daily gate call is a lowlevel function where the code in the target contract is executed in the context of the calling contract and message.sender and message.value also don't change so you understand what delegate call means now right great and in english this means if i delegate call a function in contract b from contract a i will do contracts b's logic in contract a so if contract b has a function that says hey store this value in a variable up top i'm going to store that variable in contract a this is the powerhouse and this combined with the fallback function allows us to delegate all calls through a proxy contract address to some other contract this means that i can have one proxy contract that will have the same address forever and i can just point and route people to the correct implementation contract that has the logic whenever i want to upgrade i just deploy a new implementation contract and point my proxy to that new implementation now whenever a user calls a function on the proxy contract i'm going to delegate call it to the new contract i can just call an admin only function on my proxy contract let's call it upgrade or something and i make all the contract calls go to this new contract when we're talking about proxies there are four pieces of terminology that we want to keep in mind first is the implementation contract the implementation contract has all of our logic and all the pieces of our protocol whenever we upgrade we actually launch a brand new implementation contract the proxy contract proxy points to which implementation is the correct one and routes everyone's calls to the correct implementation contract you can think the proxy contract sits on top of the implementations the user the user is going to be making contracting function calls through the proxy contract and then some type of admin the admin is the one who's going to decide when to upgrade and which contract to point to in this scenario the other cool thing about the proxy and delegate call is that all my storage variables are going to be stored in the proxy contract and not in the implementation contract this way when i upgrade to a new logic contract all of my data will stay on the proxy contract so whenever i want to update my logic just point to a new implementation contract if i want to add a new storage variable or a new type of storage i just add it in my logic contract and the proxy contract will pick it up now using proxies has a couple of gotchas and we're going to talk about the gotchas and then we're going to talk about the different proxy contract methodologies because yes there are many proxy contract methodologies as well and this is why trillabits doesn't really recommend using upgradable proxies for your smart contracts because they're fraught with a lot of these potential issues not to mention again you do still have some type of admin who's going to be upgrading your smart contracts now if this is a governance protocol then great you're decentralized but if this is a single group or entity then we have a problem the two biggest gotchas are storage clashes and function selector clashes now what does this mean when we use delegate call remember we do the logic of contract b inside contract a so if contract b says we need to set value to 2 we go ahead and set value to 2. but these smart contracts are actually kind of dumb we actually set the value of whatever is in the same storage location on contract a as contract b so if our contract looks like this and we have two variables in contract a we're still going to set the first storage spot on contract a to the new value this is really important to know because this means we can only append new storage variables in new implementation contracts and we can't reorder or change old ones this is called storage clashing and in the implementations we're going to talk about they all address this issue the next one is called function selector clashes when we tell our proxies to delegate call to one of these implementations it uses what's called a function selector to find a function the function selector is a four byte hash of the function name and the function signature don't worry about the function signature for now now it's possible that a function in the implementation contract has the same function selector as an admin function in the proxy contract which may cause you to do accidentally a whole bunch of weird stuff for example in this sample code in front of you even though these functions are totally different they actually have the same function selector so yes we can run into an issue where some harmless function like get price has the same function selector as upgrade proxy or destroy proxy or something like that this leads to our first out of the three implementations of the proxy contracts this is called the transparent proxy pattern and this is actually going to be the pattern that we're going to be demoing to you today in this methodology admins are only allowed to call it admin functions and they can't call any functions in the implementation contract and users can only call functions in the implementation contract and not any admin contracts this way you can't ever accidentally have one of the two swapping and having a function selector clash and you run into a big issue where you call a function you probably shouldn't have if you're an admin you're calling admin functions if you're a user you're calling implementation functions so if you're an admin and you build some crazy awesome d5 protocol you better come up with a new wallet address because you can't participate the second type of proxy we're going to talk about is the universal upgradable proxy or the ups this version of upgradable contracts actually puts all the logic of upgrading in the implementation itself this way the solidity compiler will actually kick out and say hey we got two functions in here that have the same function selector this is also advantageous because we have one less read that we have to do we no longer have to check in the proxy contract if someone is an admin or not this saves on gas of course and the proxy is also a little bit smaller because of this the issue is that if you deploy an implementation contract without any upgradeable functionality you're stuck and it's back to the yeet method with you and the last pattern or methodology that we're going to talk about is the diamond pattern which does a number of things but one of the biggest things that it does it actually allows for multiple implementation contracts this addresses a couple different issues for example if your contract is so big and it doesn't fit into the one contract maximum size you can just have multiple contracts through this multiimplementation method it also allows you to make more granular upgrades like you don't have to always deploy and upgrade your entire smart contract you can just upgrade little pieces of it if you've chunked them out the disadvantages here really only seem like you have a lot more complicated code all the proxies mentioned here have some type of ethereum improvement proposal and most of them are in the draft phase there isn't really a standard here for the proxy that the whole community has landed on and says yes this is great let's do it so for all these be sure to jump on the discussion and give your thoughts all right so now that we know a lot more about upgrades and how they actually work and some different methodologies behind them let's go ahead and learn how to actually implement some of these strategies and implement our contract so that we can upgrade them now there is a brownie upgrades mix directly in the brownie mixes organization that if you want to use you absolutely can once again to do that it's just brownie bake upgrades mix and this will have all the code that we're going to teach you how to use right now but let's go ahead and build this up from scratch ourselves so we're going to go ahead and run brownie knit this of course we're going to create our new browning project here we're going to be using the open zeppelin proxy contracts to actually work with this and run with this the methodology that we're going to be working with is the transparent upgradable proxy now they've been using the universal upgradable proxies a little bit more however the transparent upgradeable proxy is really fantastic and easy to understand so that's going to be the one that we're going to be working with here and these are the two contracts that we're going to be importing directly from open zeppelin so let's get to it we're going to create a really simple contract that we can easily tell if it's upgraded or not we're going to be using the exact same ones that open zeppelin actually uses so let's create a new file and this is going to be called box.soul we're just going to have it store and retrieve some type of value so let's give the spdx license identifier of mit so let's pick our solidity version and for this we're actually going to use 0.8.0 oftentimes you're going to have to quickly pick up new versions of solidity anyways anyways we're going to do contract box and we're going to give it a uint256 private value we're going to do an event called value changed i'm going to give it to you in 256 new value give it a function store uin256 new value and this is going to be a public function that anybody can call and all we're going to do is we're going to set value to be new value and we're going to omit this value changed event then we're going to have a function retrieve and this will be a public view and it's just going to return the ui 256 value return value and this is going to be our whole contract hopefully you can understand everything that's going on in this contract i should spell license right shouldn't i now we're going to copy all of this code and create a new contract called box v2.sol we're going to paste it in and box version 2 is going to be exactly the same except we're going to add one more function called increment this is going to be a public function and we're going to set value equals value plus one and we're also going to omit a value changed event with that new value now this is going to be really easy for us to check to see if a contract has been upgraded or not if we can call increment on the same address that we originally deployed box to then this means that the contract has been upgraded we shouldn't be able to call increment on this box contract but we should be able to call it on box v2 perfect so that's all we need to do to get started now to actually work with the proxies and the transparent proxy that we're going to be working with we do need to add them to our browning project so we're going to create a new folder and we're going to call it transparent proxy and in here we're going to add those two contracts we're going to add one called proxyadmin.sol and all we're going to do is we're going to grab all the code from the opens up and proxy contract and paste it right in here since since this code is pulling directly from it it opens up one package we are going to have to fiddle with the imports a little bit to make a match so brownie can actually compile it and of course since we're going to be working with another package we have to add this dependencies to our browning config so dependancies open zeppelin open zeppelin hyphen contracts and for this one we are going to actually use 4.1.0 then we have to do compiler soak remappings at open zeppelin is going to be equal to this dependency now while we're in here we might as well do our dot env so we can get our environment variables and we'll add our wallet in here while it's from key private key we can now just have this be at open zeppelin contracts access ownable.soul and we don't need to change this at all because we're actually going to keep this transparent upgradableproxy.com because this is the second contract that we're actually going to grab from open zeppelin so let's create a new file to be called transparent upgradableproxy.soul this exact text here and we're going to copy paste this whole thing from open zeppelin boom paste it in here awesome and then same thing here we just have to a little reverse engineer this at open zeppelin slash contracts slash proxy erc 1967 erc 1967 proxy and perfect that is exactly where we are so great now if we've done this right we should be able to run a quick brownie compile oops i got to change this to box v2 now let's run a brownie compile and perfect looks like we have compiled we've got some stuff in build great everything's working correctly so okay so we have our box here our box v2 and we have our proxy contracts as well that we can use to upgrade this box to a new version we can even look if we go back to proxy of open zeppelin if we look at our proxy admin here we see it has this function upgrade and call and this calls the upgrade to and call on the proxy contract if we look in the transparent proxy this upgrade to and call calls upgrade to and call which has been imported actually so we can actually even go back go back go to erc 1967 proxy upgrade look for that again and this is the function that it's actually going to call and it calls this upgrade to function which calls this set implementation function and all we're doing is we're doing storage slot dot get address slot of this implementation slot that value is going to be this new implementation all it's doing is it's setting the implementation slot to being our the new address that we wanted to use and we can see now if we look in the proxy contract the way that it actually works is it has this fallback function where it's always going to delegate all of our calls to whatever the implementation contract is this delegate function if we look at him there's a little bit of lowlevel assembly here and he uses this lowlevel delegate call to send any function call or any call to this contract to the implementation contract so this is exactly the function doing all that delegation all right so now that we've dug deep into the code let's actually script this out and turn this into a script so let's create a new file and we'll call it zero one deploy box dot soul and this is gonna be how we're actually gonna deploy the box so since this is a brand new script we're gonna do def main of course our account going to be equal to get account which we're going to do from scripts dot helpful scripts import get account so let's go ahead create a new file help full scripts oops scripts.pi and again we're just going to paste in that getaccount function from our past helpful scripts all right our get account script again so we can just do account equals get account oh this should be sorry should be dot pi excuse me do a quick print deploying to we'll do network dot show active that means we got to do from brownie import network and then we'll do box equals box dot deploy from account little brackets here of course since we're going to be deploying this contract we also have to import that from brownie and perfect this alone should just deploy the box contract right so this means we could do something like print box dot retrieve and it should be zero right so if we run brownie run scripts o1 deploy it will deploy that whoops we also got to add our env we don't have to put anything in here yet because we're not actually deploying to a real network but let's go ahead and run this i spelt retrieve wrong it's probably good to spell things right let's try it again and great so we get 0 here perfect that's exactly what we'd expect it's cool however though if we run box dot increment this should error out right boom exactly it has no attribute increment so this is what's known as our implementation contract this box is implemented it's the implementation contract now we have to hook it up to a proxy so let's first give it a proxy admin and proxy admins are optional um and it's also recommended that if you do have a proxy admin you're and you're going to use some type of default protocol sometimes it's great to have your proxy admin be something like a multisig gnosis safe which is really fantastic there's going to be a link in the github for learning how to actually spin one of those up let's go ahead and do a proxy admin because they're really helpful anyways we could optionally we could just set ourselves to be the proxy admin but let's set it to be this this contract so we'll do proxy admin equals proxyadmin.deploy and again this will be from account and since we're using this proxy admin we're going to import that as well so if we look at the proxy admin we see a couple functions here we see like get proxy implementation which is just going to return the address of the implementation we have get proxy admin it's going to be us change proxy admin we have this upgrade which is just going to call that upgrade function on the proxy and then we have upgrade and call upgrading call changes the implementation to the new implementation and then calls that initializer function since we want these to be proxies you can see here that we don't have a constructor this is intentional instead we could have some type of initializer function for example maybe we want to have this store be our constructor instead of having a constructor what we do is we call what's called our initializer function the instant we deploy this contract for the demo here we're just not going to have an initializer anyways so now we have this proxy admin we have the implementation contract we have the proxy admin let's now hook them up to the actual proxy first thing that we need to do actually is we need to encode the initializer function if we wanted store to be our initializer function like i said we could do something like ini shi al lizer equals box.store comma one and this would be our initializer box.store combined with one what we then have to do is we'd have to encode this for our proxy if we look at our transparent upgradable proxy if we look at the constructor we have address logic address admin and data here the logic is that implementation right this is going to be the address of our box the admin is going to be ourselves or in our case it's going to be that proxy admin contract and then data is going to be that initializer function if we go into the erc 721 proxy contract should go back to proxy erc 1967 upgrade and we look at this as one's constructor we can see that this data bit here once this is built with this constructor it's immediately going to call this upgrade to and call so it's going to call this this initializer if we go to upgrade to and call if we go back to this upgrade contract we can see this upgrade to and call it's going to call this address dot function delegate call new implementation data and this is how it actually calls that initializer function we have to actually encode this into bytes so we have to say box.store is the is the function a call and then one is going to be the first parameter right if this is what we'd want to do so we do box encoded initially function equals encode function data and this is where it gets a little bit tricky but i usually have this encode function data once again in my helpful scripts so we'll do quick def encode function data and it's going to take an init which we're going to start off as none and then any number of arguments after that so again this could be like you know initializer equals box.store and then the arguments could be you know one two three four five etc or whatever right for us we only have one variable that can be put into store but this is how you would do it and to do this brownie actually has a builtin function that can actually do this we just return initializer dot and code input star args and that's all we'd have to do however there is a bit of an issue when the length of the args is zero so i've already hacked away at it for you guys so we're just gonna do if the length of the args is zero or we're not using an initializer then we're going to return s utils dot two bytes x string equals ox and we do have to import f util import at utils and of course we'd have to pip install it with pip install ethertails so i know i kind of rushed through that but basically what we're doing like i said is we're encoding this into bytes so that our smart contracts actually know what function to call so we're just encoding it that's all we're doing and if it's blank or there's no initializer we're going to return an empty hex string and our smart contract will understand ah okay arguments are blank here perfect i've got a nice doc string in the upgrades mix that explains this even better i'm even just going to paste it in here for now if you'd like to pause and read this a little bit more to kind of get the full depth of what this function is really doing feel free to do that this is a little bit lower level solidity and evm stuff that we're getting into here but it can be good to know anyways okay great so now that we have this we could go ahead and run box encoded initializer function equals encode function data which we would import from our helpful scripts and this is what we use when we call the constructor for our transparent upgradable proxy i'm just going to have it be blank for now but feel free to fiddle around and try to actually use an initializer after we run through this demo so this box encoded initializer function is going to be blank we're saying hey don't use an initializer and that's totally fine if we were to add some stuff to here we would say hey use an initializer so now we can actually deploy this transparent upgradable proxy if we open this up with the constructor we can see what we need here so we're going to say proxy equals transparent upgrade able proxy.deploy of course import this from brownie and what are those variables that we need okay we're gonna need the address the logic this is gonna be our implementation contract address so we just say box.address which is our because we've already deployed this which is great then we're going to need our admin which we could just say is us but we're going to use the proxy admin dot address and then last we need that function selector we need that encoded function call which for us is just blank but we still need that so box encoded initializer function and then we have to add from account of course and i've also noticed that sometimes it's helpful to add some type of gas limit so i'll even add a gas limit of one one two three one two three that's six zeros there but sometimes you might be fine but uh with the proxies they they sometimes have a hard time figuring out the gas limit so i've just manually put it in here you can if you want to it might work fine without it and then great let's do a quick print function we'll print f proxy deployed to proxy you can now upgrade to v2 now what we can do is on the proxy's address we can call functions so typically right if we wanted to call a function on this box contract we do box dot you know retrieve or however you spell it box.store let's just do box store right you'd call it like this however we want to actually call these on the proxies right because box this box contracts address this box contract is always going to be the same address and can't change the proxy code can change we want to always call these functions to the proxy and not to the box here right so the way we do that is we can do proxy box equals contract dot from abi we'll call it box on the proxy.address box.abi and of course we'll import this from brownie what we're doing here is we're assigning this proxy address the abi of the box contract and this is going to work because the proxy is going to delegate all of its calls to the box contract typically if you put an abi on top of an address that doesn't have those functions that the api defines it would just error right but the proxy is actually going to delegate all those calls to the box so we could actually go ahead and try something like print proxybox dot retrieve hopefully that's about that right and even though we're using the proxy address here we are going to delegate the call to box so let's go ahead and run this so we'll do brownie run scripts deploy box it's going to deploy the box it's going to deploy the admin it's going to encode that initializer function which we've set to nothing then it's going to deploy our transparent upgradable proxy and then it's going to call retrieve on the transparent upgradable proxy instead of our box so let's do this and perfect we did it right it's returning zero here that's awesome what we could also do is we could also do proxybox.store one and then we'll call retrieve we'll see what happens here whoops it's yelling at me because i got to do from account now let's go ahead and run it and perfect see so after we stored on the proxy box on this proxy we're able to retrieve the value there so this is fantastic all right now that we've deployed it let's learn how to upgrade it we're going to change this to deploy and upgrade dot pi and we're just going to do everything in here so now that everything's deployed let's go ahead and now upgrade this so so now we can always point to this proxy box address and it's going to be the most recent upgrade it's always going to have the code that we want it to have so let's go ahead and upgrade from box that doesn't have that increment to box v2 that does indeed have this increment function so let's try this out so first thing we need to do is we actually need to deploy that box v2 so we'll do box v2 equals box b2 dot deploy we'll save from account and we'll leave it like that of course we're going to have to import box v2 from brownie and right now actually let's even do proxy box increment if we call boxy proc proxy box that increments from account this should error right it shouldn't be able to call this increment function because that doesn't exist oh and then we also change the name of the script sorry this is actually going to be deploy and upgrade and perfect we see it actually errors out here it says hey box object doesn't have this increment function you're crazy i don't know what you're talking about well good that's what we want to do so let's delete that line box v2 and we'll even do a quick little upgrade here now all we need to do is call an upgrade function now basically all we have to do is call this upgrade to function right but depending on if we've added a proxy admin contract if we're using initializer function there might be a couple of of different ways to go about this so i like to just wrap everything up into its own upgrade function you'll see what i mean in just a second so what i like to do again we're going to pop into our helpful scripts and we're going to create a new one called upgrade now for parameters in here of course we're going to take some type of account so that we have something to account to deploy from we're going to use the proxy which is again going to be that proxy contract which is going to be our proxy contract here we're going to need a new implementation address we're gonna need the proxy admin contract which could be none for us we're gonna have one but it could be none and then we're gonna have an initializer which also could be none and then we're going to have the args for the initializer which also could be known again this star is a special thing in python which says any number of arguments will just get stored into this list called args and perfect this is going to be our function that's just going to take care of everything for us so first thing let's check to see if there is a proxy admin contract so we'll say if there is a proxy admin contract then we want to check to see if there is an initializer what we're going to do is we're first going to want to encode that function data of course so we'll say encoded function call equals and code function data with the initializer and those star args this is going to be the encoded initializer function here then all we have to do and actually let's do start with a blank transaction equals none we'll say transaction equals proxy admin contract since we're using one of these proxy admin contracts since we've detected one dot upgrade and call since we also have an initializer we're going to pass the proxy.address new implementation address and the encoded function call and then of course from account so this upgrade and call if we look in that proxy admin there's this upgrading call function right on the proxy admin and it just calls upgrade to and call of the proxy contract so hopefully don't don't let this bog you down a little bit that there's kind of a lot of mix and matching going on but this is what's going on i'm sorry this is encoded function call not encoded function data great now if they don't have an initializer well what do we do well we don't need to encode any function call here we need to say transaction equals that proxy admin contract dot upgrade so it has an upgrading call it also just has a regular old upgrade so we'll just call upgrade and we'll give it the proxy.address the new implementation address and then from account now if it doesn't have a proxy admin contract this means that the admin is just going to be a regular old wallet well what do we do then well first check to see if it has an initializer still and if it does we need again to encode that function call we can just copy and paste that there and then once that's encoded we can just call directly off the proxy contract we're going to call exactly what the proxy admin contract is calling which can be proxy.upgrade to and call we're going to give it the new implementation address the encoded function call and then from account and let's wrap this all up in a big else so if proxy admin contract do this stuff else do this stuff if initializer do that otherwise we can just do transaction equals proxy dot upgrade 2 and we just add that new implementation address from account and then we'll finally return transaction so i know that there's a lot here but we're really just making this upgrade function really general we could always just know okay if we we we're going to use a proxy admin let's just do it like this okay no we're not going to use a proxy admin we're also not going to use an initializer great it would just look like this but this is essentially all that we have to do so now that we now that we have our upgrade function we can go ahead and use it here so we need to give it an account a proxy a new implementation address so we'll say account so we'll say upgrade transaction equals upgrade account we need a proxy and a new implementation address we're going to give it the proxy and we're going to give it box v2.address for that new address we do have a proxy admin contract so we'll say proxy admin contract equals proxy admin and we don't have an initializer so we can leave that part blank of course we need to import this upgrade function from our helpful scripts and this is all that we need so now we can do print proxy has been upgraded and what we could do now is we can do proxy box equals contract dot from abi we'll call it box v2 we'll give it the proxy.address box v2.abi and now we should be able to call proxybox.increment from account and then we can print proxy box dot re retrieve and this should now be one and what we'll actually see is that this will return two why does it return two well in our original proxy box we stored one so it started with one we then upgraded to this new contract and then let's actually just do a wait of course we upgraded to a new contract right here however the storage of that contract stayed in the proxy so that one stayed in the proxy so even though we upgraded the contract there's still one stored at the location in storage so then when we call increment now and then we call retrieve it's gonna go from one to two so let's go ahead and run this brownie run scripts deploy an upgrade enter and boom that is exactly what we see output here this is an incredibly incredibly powerful and advanced feature and if you've gotten to this point you are on the border of being one of the most powerful smart contract engineers on the planet huge congratulations for getting this far but we're not quite done we of course need to write some tests because that is what's going to make sure our project always stays in sync and always stays up to date so let's write a couple of tests here so let's create a new file we'll call test box proxy dot pi and for this we're really just going to test to see that our contracts work we're going to see that this box actually is going to work correctly so let's create a new test def proxy delegates calls so we're going to make sure that we actually can delegate calls to our contract we're going to say account equals get account which means we have to do from scripts.helpfulscripts import get account then we're gonna do box equals box.deploy of course this is going to be from account since we're using box we're going to do from brownie import box we're going to do this proxy admin so we're going to say proxy admin equals proxyadmin.deploy of course from account let's import proxy admin from brownie all right so now we'll do the box encoded initializer function or whatever we call to perform this is going to be that encode function data which my vs code actually automatically imported thanks vs code and again we're leaving it blank because we're not actually going to have a store there and then we're just going to go ahead and run that deployment so we're going to say proxy equals transparent upgrade proxy and we're going to grab this from brownie dot deploy say again the box.address proxyadmin.address box encoded initializer function i'm going to say from account and then we'll give this a gas limit of two three one two three now we're gonna put the abi on top of this proxy so we're gonna say proxy box equals contract dot from abi we're gonna name it box this is going to be with the proxy.address and the box.api of course we're going to need to import contract from brownie and okay so now we can assert proxybox dot retrieve if i spot that right is equal to zero then we're going to do proxy box that's store we'll do one and this will be from account and then we're going to sir again this proxybox.retrieve should now equal 1. so we're using this proxy contract we've slapped the abi on top of it and this should work so we're just testing to see that our proxy is working correctly so we can go ahead and test this then with rounding test and beautiful it passed now let's go ahead and create a new script for testing the upgrades create a new file called test box v2 upgrades dot pi and let's do it called def test proxy upgrades so account it's gonna be equal to get account hopefully at this point you're getting pretty good at writing these these tests from scripts.helpfulscripts imports and of course we want to add this init dot pi just in case you forgot so now we're going to import get account perfect so we have our account here now as you can see we're doing a lot of this box equals box dot deploy deploy the proxy admin it would probably make sense in one of your scripts to just write a deploy three to write a function called like deploy all or something like that so again if you guys want to learn more if you want to improve upon this i would highly recommend you go back and you make some of those improvements to to really modularize this up but for the time being let's just keep going so box.deploy from account and since we're doing this we're going to do from brownie import box say proxy admin equals proxyadmin.deploy this will also be from account comma proxy admin we're going to get those initializer functions so we'll say box encoded initializer function equals encode function data which we're going to grab from our helpful scripts as well and then we're going to do the proxy again box equals transparent up gradable proxy that deploy we've got to import this from brownie as well oops not twice though deploy it's going to have the box that address proxy admin dot address box encoded initializer function from account gas limit one two three one two three all right so we have the proxy deployed we've already tested that this proxy works in this test box proxy so we're not going to go ahead and test that again what we're going to do instead now is now we're going to deploy box v2 and we're going to update the proxy and make sure that everything still works so we're going to do box v2 equals box v2 dot deploy it's going to be from account of course now we're going to say proxy box equals contract.from api box v2 proxy.address v2.abi and we're going to grab both this and this from brownie and what we're going to try to do is slapping this abi onto this proxy address we're going to try to call a function only box v2 can call however we know that like what we tested before it actually should revert so we can actually check for reverts by importing pi test and we can say with pi test dot raises and i know that this is a brownie exception i know what type of exception this is it's an exceptions dot virtual machine error you can figure out what type of error this is by just just running it and getting the error so this is actually from brownie this exceptions thing so we're going to actually also import exceptions from brownie we're going to say proxybox.increment from count and i saved and everything sorry got formatted here but calling proxybox.increment should throw this exceptions.virtual machine error so this test will pass if this throws an error and that's how we test that so we want this to throw an error the first time we call it then we're going to upgrade and then we'll call it again and it'll actually work now we're going to call upgrade on account proxy box v2 proxyadmin contract equals proxy admin we're going to need to grab upgrade from our helpful scripts and now we should actually be able to call increment with our proxy box so first we'll do a quick assert proxy box dot retrieve equals zero then we'll do proxy proxybox.increment from account and then we'll assert proxybox dot retrieve is one so we're deploying our box we're deploying our proxy and everything around it then we're deploying our v2 implementation we're trying to call increment which won't work we then upgrade our proxy to this new address and then we can go ahead and call increment and it should actually increment our box here so let's go ahead and run this test brownie run test excuse me ronnie test dash k grab this paste it in and we've done it our tests are working correctly so we know that our box is working correctly awesome great job like i said this is an incredibly incredibly powerful feature to be able to do these upgrades with these there comes a lot of risk at least in the form of centralization risk if you're the only wallet that controls the proxy that means your application is centralized full stop so if you're going to deploy anything with proxies to mainnet absolutely absolutely be sure to get it audited beforehand now before we close this project up let's actually deploy this to an actual test snap so that we can see everything that goes on when we call this deploy and upgrade let's go ahead and do it so let's pop into our emv file and let's paste the variables that we have in here we need the private key web three inferior project id the ether scan token awesome let's even let's even publish the source of all these contracts so that we can see them on etherscan so for box we'll do a little comma here we'll say publish source equals true i'm just going to copy this comma to publish source equals true and paste it on all of my deployments over source equals true publish source equals true on the on the admin on the initial transparent upgradable proxy on the box v2 deployment and that's it i've got my ether scan token my web 3 and fira my private key my brownie config is indeed pulling from the private key my env has env let's check to see my wallet we have some rink being here perfect let's do this brownie run scripts deploy and upgrade network rink all right so it looks like a couple of our contracts weren't able to actually verify there are a couple bugs being worked out with some of the verification so we're going to ignore the ones that weren't able to be verified here but let's go ahead grab these addresses pop them onto the rink etherscan and see what just happened this is our box implementation let's grab this address let's paste it into the rinkby testnet ether scan awesome this is exactly what we have contract has been verified this is exactly the code that we have here and we can see all we have is a contract creation and this is exactly correct because when we call the store function on this it's actually going to get stored we never actually called any functions directly on this contract all we did was deploy it which makes perfect sense let's go check out this proxy admin now this second address the second counter that we deployed sadly this one didn't get verified however we can see we did indeed call this upgrade function at some point which makes a lot of sense if we look at our script proxy admin in our upgrade code since we did have a proxy admin contract we did call that upgrade function perfect makes sense now let's go to this transparent upgradable proxy this is going to be the most interesting one out of all of our applications interestingly enough we look at this contract we can see store in increment both have been called on this contract not on the box because again this is the proxy that we're going to call all the functions on to make our contracts upgradable internal transactions are calls that another smart contract made to this transaction and if we look at a couple of these we can see if we click more we had increment called from another contract which makes sense we had upgrade called from the proxy admin and then we also of course we had store called from another contract and if we verified this we would be able to see etherscan recognize this as a proxy contract as well hopefully when you work with this you'll be able to verify it as well but if not not a big deal you can always just manually do it later yourself so this was an incredibly powerful project that we just did here and that we worked on and all right maybe take a nap maybe go for a walk get some food get a drink because we are on to our last coding project now i do want to say that this project is considered a bonus because we're going to be going very quickly over the front end pieces we're going to take all the building blocks that we've learned and build an amazing full stack application gear up get ready let's jump into this bonus project and then after we finish this up we're going to close everything out with a final quick section about security the future and and thank you for joining this course so let's do this last one all right now we are moving on to our final project this is going to be the most advanced products and combine all the knowledge that we've learned so far into one project then we're additionally going to put a front end or a user interface onto this project when we build our own applications we're going to need a way for nondevs to actually interact with it in a meaningful way so now this isn't a front end or react tutorial course although we will be explaining some of the choices that we've made and how to actually do them you should be able to follow along fine even if you don't have any front end experience here if you're looking for a full front end tutorial free code camp has some amazing videos that you can absolutely try out all right welcome back everybody and now we're going to be embarking on the most exciting the most end to end we're going to take everything that we've learned and wrap it all together in this single last application here and we're also going to be learning about front end development we're going to be building a front end on top of our application on top of our contracts here now this isn't a front end tutorial however free code camp has some wonderful wonderful react tutorials we're going to be teaching you guys just enough so that you can go ahead jump in and build your own simple but also kind of nice looking front ends on top of whatever contracts that you have for those of you who want users to actually interact with your applications and interact with your contracts building a usable front end is a really important piece so let's take a quick walkthrough of what this application is going to look like so here is our our front end here and what this application is going to allow users to do is it's going to allow users to stake or deposit their tokens into what's called our token farm contract once they have some token deposited that's when you can kind of go get creative with what you want those tokens to do you could use it as staking in some governance you could use it to you could go ahead and invest it in something like ave or another d5 protocol to gain interest you could build a yield aggregator there's a ton a ton of different features that you can actually do once you have users stake their tokens and here's how they would do it on their ui side so we have this little button here which we go ahead and click connect on metamask is going to pop up and we're automatically going to sign in that's going to connect our meta mask to this user interface now so if i look at my meta mask i'm on the coven test network we can see that i am indeed connected now what i can do is i can now stake some of my tokens into this contract we currently have three different types of tokens that this platform allows you to stake wrapped ether fiu which is mimicking die on the test network and our dap token this dap token is going to be the reward token that our platform gives users as an incentive for staking on our platform once we stake we can actually then unstake and that's really it so we'll go ahead and stake maybe we'll stake 10 dap we'll hit stake metamask will pop up this is the approve function this first approved function that gets called we get a really nice little waiting bar here and once it's been approved we get a notification saying the transfer's unapproved we then go ahead and we'll confirm staking we'll get this little loading bar while it's being staked and we'll see that popup that says tokens staked successfully now if we go to the token farm contract we can see that we have 10 of this dap token state we can also unstake it the other thing that we can do is as admins of this wallet we can actually issue a reward to our users based on how much they've staked so you see right now we have 95 dap token we have 10 dap tokens staked on the back end i'm going to run an issue token script it's going to send all users that have some stake a little bit of a dap token reward now you can see it's been updated and we have we've been given a little bit of dap token that resembles the amount of dap token that we have staked the way that we figure out the value of all of our different tokens is using of course chaining price feeds we can then of course unstake everything and we see tokens unstaked successfully and that's it and this is what we're going to build now we aren't going to go over the unstaking portion of the front end application here right here's what it would look like if you were to go ahead and finish building out the front end yourself there is a full repository with the entire front end with this unstaking piece but for simplicity we're just going to skip over this unstaking bit so let's go ahead and get started i'm going to go ahead and make a new directory called defy stake yield brownie and then i'm going to open this up in a new text editor now the first thing of course that we want to work with is going to be our contract so we're in here remember always start with brownie init or you can start with the chain link mix i'm just going to go ahead and start with brownie unit and perfect here is our setup all right first thing we're going to do is we're going to make our app token dot sol this is going to be the token that we're going to give out to users who are staking on our platform this is our reward token you might have heard of yield farming or liquidity mining this is our token that allows users to actually engage and participate in that and this is just a regular old erc20 so you guys already know we've done this before and for this one we're even going to use the latest and greatest in solidity remember i said that you're going to have to get really good at bouncing around between solidity versions so for this one we're going to do everything in 0.8 so let's go ahead and do that so we're going to do pragma solidity 0.8.0 and we're going to do this the exact same way we made our other erc20 token we're going to go ahead and use open zeppelin again we can even just copy paste the import from their documentation or we can just write it out import at open zeppelin contracts slash token erc20 erc20.sol and you guessed it because we're using this at opens up on syntax we're gonna make a new file routing config.yaml we're gonna make some dependencies we'll do open zeppelin slash open zeppelin contracts this time we're going to actually use version 4 of these at 4.2.0 and again you can find out everything about this package by going to opens up when slash opens up on contracts on github and then compiler sulk remappings at open zeppelin equals this part right here paste it in okay great then what we can do we can go back to our dap token and just do some basic erc20 bits here so do contract dap token is erc20 and we'll give it our constructor public erc20 we'll call it depth token and we'll give it a symbol of dep and we'll give it an initial supply as well so we'll call the mint function and we'll set the meshes.sender as the owner give it an initial supply of one million which will be one one two three one two three plus those eighteen zeros so one two three four five six seven eight nine ten one two three four five six seven eight and now that we have our first contract we can try to compile it ronnie compile and looks like it worked great now we're gonna go on and to create our more interesting contract our token farm we can even take a quick second and figure out what we want this to be able to do well we want to be able to stake tokens tokens issue tokens this is going to be issuing those token rewards we're probably going to want to add allowed tokens to add more tokens to be allowed to be staked on our contract and we're probably going to want some type of get f value function where we can actually get the value of the underlying stake tokens in the platform with that in mind let's move on so you know the drill pragma solidity carrots 0.8.0 and we're going to be here for a while so i'm going to close those out and this will be our contract token farm contract token farm oh and let's not forget our s pdx license identifier of mit well let's go ahead and start with the staking of the tokens right because that's going to be the most important piece of our application so we're going to do function state tokens you'll probably want to stake an amount of token and they'll probably want to stake a certain address of the token so some amount of some token now there's a couple things we need to keep in mind here what tokens can they stake how much can they stake so these are our first two questions for our application we're just going to say you can stake any amount greater than zero so we can even add that we'll do require amount is greater than zero and if it's not we'll just say amount must be more than zero since we're using version 8 we don't have to worry about anything to do with safe math which is awesome so we can just go ahead and do stuff like this we now we only want certain specific tokens to be staked on our platform so we could say require token is allowed or something to this effect so we might have to actually create a token is allowed function so let's go ahead and create that function token is allowed it'll take some token address make it a public function and it'll return a boolean it'll return true if that token's allowed or false if it's not allowed so how do we know if a token is actually allowed we probably want some list or some mapping of these tokens and whether or not they're allowed after all we've learned you'll probably learn that there definitely are some tradeoffs between lists and mappings here for simplicity's sake we're just going to stick with a list for now so we're going to create an address array we'll make it public called allowed token and this will just be a list of all the different allowed tokens for our token is allowed function we'll just loop through this list and see if that token is in there so we'll do a for loop four uint256 allowed tokens index equals zero allowed tokens index is less than allowed tokens dot length allowed tokens index plus plus so we're going to loop through this list and we're just going to say if allowed tokens of allow token index equals equals this token then we're going to return true otherwise if we get through this whole for loop and we don't find this token in here we're just going to return false now we have a way to check to see if allowed tokens are there let's actually write a function to add aloud tokens so we can do function add aloud tokens address token public function and we'll do allowed tokens and we'll just push it onto that array now adding allowed tokens is probably something we only want the admin wallet or the owner of this contract to do so we'll add only owner as a modifier to this function and we'll make this token farm ownable is ownable and we'll import from open zeppelin here too import at open zeppelin contracts slash access ownable.soul let's do a quick compile great things are being compiled fantastically now that we have a little bit of functionality here now might be a good time to actually go ahead and start writing some tests if you want to since i know that we're going to change the constructor a little bit and we're going to change a little bit of how this is actually formatted i'm just going to keep going but now might be a great time should i start writing some tests for my application you know we're going to do those tests later on anyways though all right great but in any case now that we have these two functions we can go ahead and actually start checking to see if the tokens that these stakers are going to stake is actually allowed so what we can do now is we're going to add this require statement in we can require token is allowed of token otherwise we'll just say token is currently not allowed and perfect now we have two required statements that answer these questions what tokens can they stake and how much can they stake so now all we have to do is we just have to call the transfer from function on the erc20 remember erc20 remember erc20s have these two transfer type functions they have transfer and they also have transfer from transfer only works if it's being called from the wallet who owns the tokens if we don't own the token we have to do transfer from and they have to call approve first so we're going to call the transfer from so we're going to call the transfer from function on the erc20 since our token farm contract isn't the one that owns the erc20 we also have to we also have to have the avi to actually call this transfer from function so we're going to need the ierc20 interface we could go ahead and pop it in here we could also make it near c20 contract we could also just grab it from openzep1 so we'll do import at open zeppelin contracts slash token slash erc20 ierc20.sol we're using the interface here because we don't need the whole contract anyways let's now wrap ier c20 let's wrap this token address as an erc20 token so now we have the abi via this interface and the address and we'll call that transfer from from the message.sender and we'll send it to this token farm contract so from whoever calls stake tokens to this token farm contract and we'll send the amount and perfect now we just need to keep track of how much of these tokens they've actually sent us so we're going to want to create some type of mapping here and this mapping is going to map token address to sticker address to the amount this way we can keep track of how much of each token each staker has staked so it's a mapping per token per staker per amount so we'll just call this mapping of that token address which is going to get mapped to another mapping of those user addresses which then gets mapped to a uni256 so we're mapping the token address to the staker address to the amount we'll make this a public mapping we'll call it staking balance now that we have this mapping in our state token function what we can do is we can say staking balance of this token from message.sender is now going to equal whatever balance that they had before plus the amount all right this is great now we have a way for users to stake different tokens that we've actually allowed them to stake on our platform awesome work so what do we want them to be able to do next we want them to unstate tokens we want to be able to issue some reward we want to be able to get the eth value based on that reward typically you might want to do this unstake tokens bit first however i know that we're actually going to need some additional functionality in our state tokens function for us to actually issue tokens properly so let's just go ahead and do this issue tokens bit remember this issue tokens is a reward we're giving to the users who use our platform so we want to issue some tokens based off the value of the underlying tokens that they've given us so for example maybe they've deposited 100 eth and we want to do a ratio of one to one for every one each we give one depth token that's pretty easy for us to figure out however let's say they have 50 each and 50 die staked and we want to give a reward of one dap one dapp token per one die well then we'd have to convert all of our eath into die so we know that conversion ratio for the dap token so that's the problem that we're going to work on now let's create this function called issue tokens and this is going to be a function only callable again by the owner or the admin of this contract so how do we actually go ahead and issue tokens here well the first thought would be to loop through a list of all the stakers that we have but right now we don't have a list of stakers what do we have we have a mapping of stakers and we have a list of allowed tokens well we're probably going to need to have a list of stakers so we'll do an address array because again we can't loop through a mapping so we'll do an address array we'll make it public called stakers this is just a list of all the different stakers on our platform now when somebody stakes a token we're going to have to update this list we want to make sure they're only added if they're not already on the list so in order for us to do this we should get an idea of how many unique tokens a user actually has so i'm going to create a function called update unique tokens staked with message.sender and the token and what this function is going to do it's going to get a good idea of how many unique tokens a user has and if a user has one unique token we can add them to the list if they have more than one we know that they've already been added to the list so we don't need to add them there so let's create this function update unique token state we'll have it input an address user and an address token and we'll make this an internal function so that only this contract can call this function and what we'll say is if staking balance let's even do a little underscores here of token of user is less than or equal to zero we're going to update some unique tokens staked mapping so we'll say unique token staked of the user it's going to equal the unique token staker of the user plus one and since we have this new mapping called unique token staked we'll make that as well so we'll do a mapping of an address to the un256 public called unique tokens state so this way we know how many different tokens each one of these addresses actually has staked now that we have a better idea of the unique tokens each one of these users has staked what we can do is we can figure out whether or not we want to push them onto this stakers list if they're already on there we don't want to push them on there if they're not on there then we do want to push them on there so we can just do is say if unique token staked of message.sender it's equal to one if they have one unique token state if this is their first unique token we're going to add them to that stakers list so we'll say stakers.push message.sender and this is going to be our completed sake tokens function here so we had to add this little extra functionality between the unique tokens to figure out how to actually issue some reward for them but now that we have this list and it's going to get updated here and it will also get updated when we unstake what we can do now is just loop through this list of stakers so we can say 4 unit 256 staker's index equals zero stakers index is less than stakers dot length stakers index plus plus and now we're going to issue some of these tokens here so we're going to say the address recipient equals stickers stakers index so one at a time we're going to loop through grab these recipients and then we're going to send them a token reward based on their total value locked so we got to do a couple things here we have to send them a token reward we have to figure out how to actually send them this token and then we also have to get their total value locked so let's do this to send them a token reward this is going to be this dap token that we created in the beginning this is going to be our dap token so right when we deploy this contract we need to know what a reward token is actually going to be so we can do right at the top and then i'm actually going to i'm actually just going to move this array up here so that they're all kind of nicely together what we need to do is we need to create a constructor right when we deploy this contract we need to know what is the address of the dap token what's the address of the reward token that we're going to give out so we can say constructor it will be passed an address of the dap token address this will be a public function and we'll store this dap token as a global variable so we can say ierc20 since we're already importing it here public dap token what we can do now is set depth token equals ierc20 underscore dap token address so now we have this dap token with its associated address and what we can do now is call functions on it for example we can call dap token dot transfer we can call transfer here because our token farm contract is going to be the contract that actually holds all these dap tokens and we're going to send this token to the recipient of course but how much are we going to send right how much this of this token are we going to send to them well we need some function to get the total value so we're going to say u and 256 use your total value equals some function right and we can go ahead and define that right now we'll call this function get user total value right or get recipient total value or whatever you want to say so we'll pop recipient in here and let's go ahead and create this function so we'll call function get user total value address user and this is where we do a lot of looping right we're gonna we gotta find out how much each of these tokens actually has now what a lot of protocols do instead of actually them sending and them issuing the tokens is they actually just have some internal method that allows people to go and claim their tokens right you've probably seen that before people claiming airdrops that's because it's a lot more gas efficient to have users claim the airdropped instead of the application actually issuing the tokens right it's going to be very gas expensive to do looping through all these addresses and checking all these addresses right we're going to do it though because we are a wonderful amazing protocol and we want to give our users the best experience but in any case this is going to be a public view function that will return a uin256 right because we want to return this total value to our issue tokens function up here so how do we actually get started here well let's create a unit 256 total value and we'll set it off to start it to be zero here and let's even start it off with a quick require statement right we want to require that the unique token state of this user going to be greater than 0 right and if it's not we'll say they don't have any tokens state right so the value is going to be nothing now if this is true if they have some token staked we'll go ahead and find it so we're going to loop through those allowed tokens up here the allowed tokens and we're going to find how much this user has for each one of these allowed tokens so we're going to say 4 uint 256 allowed tokens index equals zero allowed tokens index is less than allowed tokens dot length allowed tokens index plus plus and let's go ahead and we'll add the total value and now we'll say the total value is going to be equal to the total value plus however much value this person has in these tokens in this single token so get user total value is the total value across all the different tokens we need a way to get the total value across one token so we're going to create a new function called get user single token value and we'll pass it our user and we'll also pass it the single token that we're on right now so we'll pass it allowed tokens allowed token index so we got to create a new function here function get user single token value this is going to take an address of a user and an address of a token it's going to be a public function i'm just going to put this on a new line to make it a little easier to see it's going to be a view function and it's going to return a u in 256. we want to get the value of how much this person staked of this single token so for example if they've staked one each and the price of one eath is two thousand dollars we wanna make sure that this returns two thousand or if they have two hundred die stakes and the price of two hundred die is two hundred dollars we want to make sure this returns 200 right so we're getting that conversion rate we're getting exactly how much value this person has staked in our application now we'll do a quick if we'll say if token staked of the user is less than or equal to zero then we'll just go ahead and return zero right we don't want to do a require here right as we did up here because we want this to actually keep going right if this is zero we don't want the transaction to actually revert okay we want this to keep going so how do we actually get the value of a single token well we're going to need to get the staking balance right but we also need the price of that token so we're going to need to get the price of the token and then multiply that by the staking balance of the token of the user so once again we need to create another function we'll call this one get token value so in another function we're going to call get token value you could pass an address of a token we'll make this a public view function that will return a uin256 and this of course is where we need some pricing information and this is where we're going to actually work with the chain link price feeds once again and hopefully this part is going to be a little bit more familiar for you so what we're going to need is a price feed address that's the first thing that we're going to need so we're going to actually have to map each token to their associated price feed addresses so we're going to need some mapping that does that right so we're going to need some mapping that's going to map an address to an address it's going to be a public one and this is going to be token price feed mapping right it's going to map the token to their associated price feeds and with that that means we're going to have to have a function called set price feed contract where we actually set the price feed associated with a token so this will take an address of a token and an address of a price fee this will be a public and this will be only owner we don't want anybody to be able to set what these price feeds should be we just want the owner to be able to do this so we'll do token price feed mapping of the token is going to equal the price fee and that's it so now we have a way to set the price feed contracts we have a way to map the tokens to their price feeds right and again go to docs.chain.link we can go to price feeds ethereum price feeds we can find these different price feeds here and this is where we're going to set those price feeds now back down in our get token value we can grab that price feed address now by saying address price feed address is going to equal that token price feed mapping of that token parameter and now that we have this we can use it on an aggregator v3 interface again we can always go back to the docs here we can grab this bit right here of course we're going to change it to 0.8 and for those who would rather i just wrote it out we're going to import at chain link slash contracts slash src slash interfaces slash agreed gate or v3 interface dot sol and since we're doing this import we're gonna go to our browning config smart contract kit chain link brownie contracts and we're going to see what's the latest version of these now i'm going to point something out this package recently changed to mirror the mpm package versions so it does look like it went backwards in versions and there's even a little little update here but this is the the newest version even though it's a 0.2.1 it's literally just to match the mpm contract tags so this is what we're going to use so we're going to at 0.2.1 and then in our remappings we'll also do at chain link equals this bit right here now that we've imported that we can now grab that aggregator v3 interface or that price feed and say aggregator v3 interface of price feed address and grab that price feed contract then once we have this price view contract we can call dot latest round data and again you can always check back to the documentation to see what that function actually looks like and this is going to return it's going to return a whole bunch of stuff but we only care about the price so the first thing it returns is round id we don't care about that so we'll just put a comma we do care about the n256 price so we'll put that in there but we don't care about the rest of these so we'll just do comma comma comma because we only care about the price here we also care about the decimals we need to know how many decimals the price feed contract has that way we can match everything up to be using the same units so we'll say u and 256 decimals equals price fee dot decimals and what we can do now is we can return both of these so this actually needs to return a un256 and another uint 256. put the decimals here and we do return we can return both of these so we'll do a uint 256 price we'll wrap that price into a u and 256 and then we also need to wrap the decimals in the u and 256 since decimals actually returns a u uint eight so we'll return the price and the decimals all right now we're cooking now we can go ahead and start scrolling back up and adding all this stuff in so we can say you and 256 price you went 256 decimals equals this get token value that we just created right here and then we can just have this return staking balance of the token of the user times the price and do some interesting math here divided by those decimals 10 raised to decimals and i know there's a little bit of math here right and so you might be going wait wait what are we doing here wrap that up like that just so that we're absolutely certain we're doing correct order of operations here so we're taking the amount of token that the user has staked right let's say for example 10 die and we're taking the price of that die maybe we have all of our contracts all of these tokens get converted back to the usd price so we have die usd actually better yet let's say we have 10 eth right our price feed contract is going to be eth usd let's say the price is is 100 100 dollars per usd so this first bit is we're going to do that 10 eth times 100 so we're going to do 10 times 100 which is going to equal to 1 000. 1000 value the only thing is we also have to divide by the decimals so our staking balance is going to be in 18 decimals so it's going to be one two three four five six seven eight one two three four five six seven eight nine ten but let's say our fusd only has eight so one two three four five six seven eight so we need to multiply these first and then divide by the decimals that way we can arrive at a price that actually makes sense is going to be a function that we're definitely definitely definitely going to need to test to make sure that we're doing everything right so that we're doing all the math correctly but okay now that we have this user single token value we go ahead and come back up to our user total value and we can literally finish this function by just calling return total value and then we can pull up to our issue tokens now that we have the total value that this user has actually logged we can just transfer the amount of tokens that they have in total value so we can say dap token dot transfer this recipient we can transfer them the total value right we'll say however much they have in total valued staked on our platform we'll issue them as a reward and that is our issue tokens function we are making great progress all right so we have a way to stake done we have a way to issue done we have a way to get value or just get value done we've added a way to add allowed tokens and all we have to do now is add some way to unstake the tokens so let's go ahead and create this function i'm going to make it right underneath the state token one we'll do function unstake tokens we'll do we'll pass it the token address we'll make this a public function so anybody can call this the first thing we're going to want to do is fetch the staking balance how much of this token does this user have so we'll see you in 256 balance equals staking balance of the token from message.sender and we're going to require the balance is greater than zero otherwise we'll say staking balance cannot be zero and then we're going to do a transfer so we'll do ierc ierc20 of the token dot transfer message.sender balance once we actually transfer the token we'll do staking balance of this token of message.sender we're going to update this balance to now be zero right because we're going to transfer the entire balance here and then we're going to update how many of those unique tokens that they have now a quick note here later on we're going to learn about reentrancy attacks so at some point come back here and figure out hey is this vulnerable to reentrance the attacks so we'll say unique token staked of message.sender it's going to equal unique token state message.sender minus 1. now the last thing that we could do is we probably should actually update our stakers array to remove this person if they no longer have anything staked this is a little bit sloppy but we're just going to skip doing that for the time being however if you want to go back and add the functionality to remove the stakers from the stakers list as they unstag please go for it it's not a big deal if we don't actually do this because our issue tokens function is actually going to check to see how much they actually have staked and if they don't have anything staked then they're not going to get sent any tokens but all right that's basically all of the functionality here let's just try a quick sanity check with a brownie compile whoops i forgot to add v0.8 in here let's try again that little bit this needs to be token and this needs to be user whoops and then it looks like i did the same thing down here this is actually staking balance let's try it again and perfect everything is at least compiling correctly just because it's compiling correctly though doesn't necessarily mean that we're doing everything correctly so this is fantastic typically now we'd want to go ahead and start doing our tests i'm actually going to go ahead and build one of our scripts first the reason i'm going to build one of the scripts first is because i'm going to use my deploy script pretty regularly in my test i'm going to use it as part of my testing this way i can also test some of my scripts as well in addition to the contracts so let's go ahead and make our deploy script so let's create a new file in here we'll call it deploy.pi we'll also create an init.pi for those of you on older versions of python and let's go ahead and do this so we're going to have a main function in here and in our main function we're actually just going to call deploy token farm and dap token and then we're going to have a function def deploy token farm and token right and i should be able to run running run scripts deploy.pi and great everything's compiling right and we're running our scripts here so first thing that we're going to want to do as always is get our account and i am going to copy a couple of those helpful scripts from our past projects so i'm actually going to pull up our nft demo that we did so i'm actually going to go to our chain link mix that we did i'm going to grab our helpful scripts remember we can always jump onto the chain link mix here and we can just grab some of the scripts from here so we could go to scripts helpful scripts and just copy paste this whole thing or just grab it like i did right these are going to be those exact same scripts that we built previously so now we have our helpful scripts in here right we're going to have this contract to mock for running our tests we have get account so we can get our accounts easily we have encode function data which we're not going to have to work with since we're not doing upgradable contracts but we have it here anyways we have upgrade which we're also not going to use but we have it here anyways we have get contract which returns mocks if they're not already deployed or it just returns whatever contract that we're looking for and then of course we have our deploy mox script here so now we can do from scripts dot helpful scripts import get account and perfect we can get our account like that no problem now and now we're going to want to start deploying some contracts so we're going to deploy that dap token first so we'll do from brownie import dap token and we'll do dap token equals gap token dot deploy and this takes no parameters so we can just do from count then we're going to want to deploy our token farm so we could say tokenfarm equals tokenfarm.deploy and this takes one parameter which is the dap token address right because we need that address so we can give it out as a reward so we're going to say dab token dot address we'll do a comma and then we'll say from account and we'll need to import this from brownie as well and while we're here we might as well add some publish source bits on here so we can say publish source equals config we'll grab this from the config networks network dot show active verify grab network from brownie grab config from brownie and in our config here let's do networks lad development we'll set the verify here to be false and then we're going to work with the coven chain so we'll say coven verify will also be false actually kovan sorry covenant will be true and then we'll do a persistent ganache or verify for this will be false and i'm even just going to put this up here so that all these ganache chains are kind of with each other so we'll verify in coven but we won't on development or ganache now once we've deployed this token farm contract we need a couple things right we're going to need to send this some dap tokens right we're going to need to send pretty much all the dap tokens so that i can actually give those tokens out as a reward so we're going to want to do a transaction it's going to equal to dap token dot transfer we'll send it to the token farm address and then we have to choose how much we're going to send and we'll send the total supply but we'll keep a little bit for ourselves so we can do some testing and so just in case so we'll also do minus kept balance some static kept balance which we can say at the top we'll say the kept balance is let's keep like 100 so this will be equal to web 3.2 way 100 ether so we'll do from web 3 import web 3. so in our transfer we'll do dab token dot total supply minus the kept balance and then of course we're gonna have to do a from account so now we're sending our token farm basically 99.9 of the total supply of this dap token so that it has this token to actually give out as a reward we'll do a tx dot wait we'll wait for one block confirmation there now what do we want to do well if we look at our token farm we know at our state tokens function we can only stake tokens that are allowed in each one of these tokens also is going to need to have some price feed associated with it right and our token price feed mapping so we're going to have to add those so what we're going to want to do is we're going to want to create a function called add allowed tokens and what this is going to do it's going to add the tokens that we want to allow and it's going to give them a price feed contract associated with them so let's create this function we'll call it def add allowed tokens and this is going to take a couple things we're going to want to take that token farm because we're going to need to call the add aloud tokens function on it we're going to take a dictionary of allowed tokens and this is going to be the names this is going to be a dictionary of the different token addresses and their associated price feeds so we're just going to price everything in usd so so we can figure out the value of everything in usd and then last of course we're going to need an account for now i'm just going to do pass here let's look at the different inputs that we're going to put into this so obviously we're going to do token farm but then we're going to need to make this dictionary of allowed tokens so we're going to need the address of the different tokens that we want to have now how do we get the addresses of the different tokens that we're going to use and what are the tokens that we're even going to use here for simplicity we're just going to start with three tokens we're going to allow our platform to allow three different tokens to be state we'll use the dap token as one we use weth token or wrapped eth because that's pretty much a standard in most smart contract platforms and then we're also going to use an fau token which stands for faucet token and we're going to pretend that this fafsa token is dye or dai the reason we're going to use this faucet token is because there's this erc20 faucet.com which allows us to get this fake faucet token we can get unlimited amounts of this faucet token on different test nets we're going to pretend that this faucet token is going to be die right so fau token slash die so how do we actually get these addresses well dap token we know with token what we can do in our config so we can actually add those addresses here so for coven the weath token address is going to be this right here which again you can go check this out and you can find it on etherscan you can write your own if you want we're just going to use this already deployed one on coven fau token which is gonna be this token here which i know is gonna be this address right here and if you want you can come here and grab your address paste it into this erc20faucet.com put an amount of 10 in here connect to metamask oh and even tells us the token address right here which we can just copy paste we can do mint free tokens confirm great says success if we don't already have it we can take this token address go to our meta mask assets add token paste it in i've already got it we can see right now i have 5 fau once this confirms i'll have an additional 10 and now you can see 15 here this is going to be this fau token that we're going to use we have wes here and then we know what the depth token address is going to be for when we deploy it here now we could do again we could do the config you know networks etc and just always get it from our config or we could use our get contract method that we grab from our helpful scripts which will deploy a mock weath token it doesn't exist in one of these and that's what we want because we're going to want to test this locally so we're going to want to deploy our own fake weath token so we'll say the weath token equals get contract with token and then the fau token is going to be get contract fau token and remember what we put in here our string that we put in here needs to match our string in our config now in order for this get contract to work for weth token and the fau token we're actually going to have to modify our helpful scripts here so if we copied and pasted it directly from our chain link mix this is basically what we're going to have here we're importing all of our mocs which we can go ahead and copy paste these as well from the chain link mix our test our mock contracts here we have some forking implementations we have contracts to mock which tells us based off of the key what token or what contract we use to mock we have get account which we use all the time in order for us to do this contract to mock correctly we're going to have to mock west and fau and actually we don't even need all these in here we don't even need this whole contract to mock in fact we can get rid of mock oracle we can get rid of vrf coordinator and we can even get rid of the link token for this we do need this sdusd price feed later on so i'm just going to leave it in here for now we definitely do need though fau token which is going to be mocked to something and we need weth token which was going to be mocked to something else so what are these tokens going to be mocked to well they're each an erc20 mock but we want to give them kind of their own identity so what we're going to do is we're actually going to make a mock erc20 for both fau and for web so we're going to come in here we're going to do new file we'll call it mock die dot sol and this is going to mock that fau token so it could be mock die it could be mock fau whatever we want it to be and we're just going to make this a basic erc20 so we'll do pragma solidity 0.8.0 we'll import at open zeppelin contracts token ear c20 your c20.sol obviously this is going to look very familiar this should spell pragma not whatever i just spelled this is going to look really similar to that dap token so now we can call contract mock die is erc20 and we'll do constructor public erc20 mock die will be the name of this and the symbol will be die and perfect and that's all we need we'll copy this whole thing and then we'll do the same thing for mockweath.soul we'll paste this whole thing in here and we'll just change the name call this mock west crc20 mock weft and this will be what token right so now that we have those mocks in here we can change fau token to mock die and west token to mock weft we can import those from brownie and in fact we can get rid of the mock oracle here and the vrf coordinator instead we'll do mock die and mock west now of course since we have diusd price feed and fusd price feed we're going to make sure we have these in our mocks here and then we're also gonna have to deploy these in our deploy mox script below so if we scroll down to deploy mocks we can see this is what it currently has which is pulling directly from the chain link mix so we just go ahead delete the vrf coordinator mark and the mach oracle and instead we'll deploy those that mock weath and that mock die so we'll do print deploying mock die die token equals mock die dot deploy from account and then we'll do print f statement floyd to die token.address and then we'll do print deploying mock mock web and then we'll do left token equals mock west dot deploy we'll say from account and then we'll print this deployed be another printf with token.address now additionally we have our fusd price feed left over from the chain link mix we also need this die usd price feed so we can go ahead in here we'll add usd price feed and we'll set this as a mach v3 aggregator we could do is we could parameritize this up so that the mock v3 aggregator takes maybe some different decimals a different initial value so that these could be different but for the sake of testing we're just going to leave them being the same here so great so we have the address of the wet token we have the addresses of the fau token and if those don't exist on the network we're working on we're going to deploy a mock so now that we have all these addresses we can do a dictionary of allowed tokens is going to be equal to this dictionary that we make so we're just going to route each one of these contracts like the depth token to its equivalent price feed for the dap token we're just going to say that the dap is going to be equal to die we're going to say the fau token is also equal to die and our weath token of course is going to be equal to eth so we're going to want to get a usd price feed another di usd price feed and an f usd price feed so in our config we can add i usd price feed and since we're going to be testing since we're going to be doing our integration test on coven here we'll come to the chain link docs we'll go to ethereum price feeds we're on coven and we'll scroll down to dye usd which is this address right here pop that in and then we'll also want the fusd price feed which we'll also go grab that from here on the coven network and we'll grab that from right here and we'll paste it in so now to complete this deck we can do this get contract again and we'll deploy mock price feeds if they don't exist so now we can just do get contract die usd price feed fau token is also going to be usd price feed and then our weft token is going to be fusd price feed and awesome now we have our dictionary of allowed tokens that we can pass to our ad allowed tokens this will map the tokens and their addresses with their associated price feeds so we can get them all to equal the same value in our contracts so we can go ahead and create this function called add allowed tokens we'll pass it this token farm we'll pass it the dictionary of allowed tokens and then of course we'll pass it the account now in our add allowed tokens function we're going to loop through all these different tokens and call the add allow tokens function on it so we're gonna do four each token in the dictionary of allowed tokens we're gonna do tokenfarm.add allowed tokens and we'll do the token.address and we'll do from account we'll say add tx equals that we'll do add tx dot weight 1 then we're going to call this set price feed contract so we're actually going to set the price feed associated with that token so we'll do set tx equals token farm dot set price feed contract and we'll do token.address the dictionary of allowed tokens of that token that we're for looping and then of course from account and we'll do set text.wait one and then we'll just return the token farm but we probably don't have to return anything and great that deploy script looks pretty good and in fact we're going to end our deploy script here with returning token farm and adapt token this way we can actually use this deploy script in our tests so i'm just going to do a quick little zoom out and we can see our wonderful deploy script right here and awesome it looks like we have just about everything here let's give this an initial test on a local ganache chain see if our mocks all work see if everything at least makes sense we can call our functions awesome it looks like we can call all of our functions and we can deploy our mocks and the mocking is working at least somewhat correctly here this is great we'll zoom out a little bit here we've got our deploy scripts we've got our ad allowed token scripts we've got all of our mock contracts added under tests things are looking good now what do we want to do here well of course we want to run some tests we want to make sure our contract is actually going to do what we say it's going to do you guys ready let's jump into it so in our tests let's make a new folder called unit we'll add a new file we'll call it test token farm dot pi let's do some tests now ideally we would also write some tests for our dap token however we're going to skip over those because we're basically just doing open zeppelin's implementation but in a fullscale production here you probably would want to write some tests on your tokens as well so let's get into this let's look at our token farm and see what we need to test remember ideally every piece of code in our smart contract here should be tested in some form or another so with that in mind let's get started so one of the first functions that we see is set price feed contract so let's make a test for that so we'll do def test set price feed contract and we're literally gonna test just this one function so how do we test that well first let's make sure we're on a local network right because we only want to be doing this on our local network since this is one of our unit tests so in our arrange stage we're going to do if network dot show active is not in local blockchain environments then we're going to run pi test.skip and say only for local testing of course we've got a number of pieces here that we need to import we're going to do from browning import network we're going to do from scripts.helpfulscripts import local blockchain environments and then we're going to import pi test all right so now we're going to get an account to make these transactions we'll say account equals get count and let's grab that for my helpful scripts as well so now we have an account we can use let's even grab a nonowner account so we'll say nonowner equals get account and we'll do index equals one this will give us a different account rather than this account and we'll use this to check some only owner functions and then what we're going to do is we're going to get the token farm and the dap token based off of our deploy script so we're going to use this deploy token farm and dap token we're going to import that by saying from scripts.deploy import deploy token farm and dap token and we're just going to call this function in our test right here so we're going to say token farm dap token equals deploy token farm and dap token awesome this is how we're going to do this a lot this arrange step for a lot of these tests here because this is how we're going to set them up we could even hypothetically turn this into a conf test or into a wrapper if we wanted to but we're just going to leave it in here like this for now now we can move on to our act phase so we're going to want to do token farm dot set price feed contract because remember this is what we're testing right now and we're going to use a token and a price feed address so we use the dap token dot address we'll use get contract to actually get an fusd price feed address which we can also grab for my helpful scripts get contract an important note here if you try to set a contract as an address parameter like this ronnie will know okay that you're looking for an address instead of the actual contract in any case then we'll do from account save it and it reshifts over here now this should work perfectly so we're going to assert this we're going to move into our assert stage right if we check our price feed mapping this should now be updated so we can do assert token farm dot token price feed mapping and remember token price feed mapping is an address to an address so we'll say dap token dot address this should be equal to get contract of fusd price feed this should be updated with exactly what get contract of fuc price feed returns in fact we can even make this a little bit better copy this we'll say price feed address equals get contract and then we'll pop this in here and we'll pop this here that way now we're just using this single variable for both all right that's our first test let's run it brownie test this will run the whole test suite and we're passing awesome now let's also do a test to make sure that nonowners can't call this function we want to make sure that somebody other than the owner who deployed this right because deploy token farm and dap token is going to be run by get account we want to make sure that somebody else can't call this function so we'll do with pi test dot raises exceptions dot virtual machine error excuse me for that getting in the way and then we'll try to call this exact same function here right we can even just copy paste it but instead we'll call it from nonowner right and then we do also have to import exceptions from browning so this should also pass it's expecting this contract call to actually revert so let's try this perfect it passes right we can double check to make sure that this pi test.raises is working because what if we did a count here right this now should fail because this isn't going to revert and that's exactly what happens perfect so we can leave this as nonowner and our first test is looking great let's even zoom out just a hairier we can sleep easy that this function is going to work as we intended isn't that a wonderful feeling yes it is great let's move on so let's look at our token farm what's the next function aha issue tokens all right great let's write some tests for issue tokens so what are we going to do def test issue tokens so how are we actually going to do this well in order to test issuing tokens we actually need to stake some tokens first so for now i'm actually just going to do pass here and before we test issuing the staking tokens we need to write a test for staking those tokens right because in order to issue tokens you need to have some tokens state so let's write a test stake tokens first and then we'll write this test issue tokens so we'll do def test stake tokens now let's set this up so we're going to copy this bit here because we are going to be working on a local network with this we'll do account equals get account and then we'll go ahead and deploy the token farm and the dap token so this initial bit is going to be exactly the same making sure we're on a local network getting the account deploying the token farm and the dap token so now let's move into the act phase let's go ahead and act let's go ahead and actually send some tokens to our token farm so first we obviously need to call approve on the dap token contract so we'll do dap token dot approve to the token farm dot address and again you can see and again we can go to the open zeppelin docs to figure out what the parameters of this are but it's going to be an address and it's going to be some amount and then obviously from account now i put a couple question marks here because we're going to constantly be using an amount right we're going to be using an amount staked for a lot of our tests here so what we're going to do is we're actually going to turn that into a fixture we're going to call it amount state and we're going to define this in our conf test folder so we're going to make our conf test file so in here we're going to do new file conf test dot pi and whoops it's in the wrong directory so we're going to go cd tests units i'm gonna do move confidence.pi down one directory and it should be in here now if that didn't work you should be able to drag and drop it uh into test you just wanna pull it out of unit is what we're doing here right just want to get it so that's just in this test directory here in the case in our conf test.pi we're going to create our first fixture so we're going to do at pi test.fixture we'll do def amount staked and then we're just going to return web3 dot 2 way one ether now of course we need to import pi test here then we're going to need to import we're going to do from web3 import web3 and now it saves perfectly so now we can use this amount staked fixture as basically a static variable right we could have done at the top we could do something like amount staked equals you know that exact same thing but we're going to get into the habit of working with these fixtures so we have our def test stake tokens and we're going to pass it this amount staked fixture pi test and brownie will grab all this stuff from the conf test folder and put it into here so now we can just use amount staked as a parameter in our test here so once we approve we can then do token farm we now call our stake tokens function right here and it takes an amount and then a token address so of course we're going to do amount staked as the amount and then we'll do depth token address as the address and of course from account and perfect this is going to be our basic action of testing the staking functionality so we can go ahead and down here and move into our assert phase and we can just assert a number of things right and do a little bracket here we're gonna do a couple of things here we're gonna assert the token farm that's staking balance of dap token that address of account dot address equals amount state so let's talk about this really quickly what is this actually doing so if we go to our token farm we know that we have this mapping called staking balance and this is a mapping of a mapping right so we need to actually pass two variables the first address and then the second address to get this amount this is how you do that syntactically with brownie you just pass it as additional parameters in here so we pass the dap token address which is going to be the token address here and then the account address which is going to be the address here and perfect so we can even run this by doing brownie test dash k test stake tokens and great looks like that passed perfectly but we have a couple of other assertions to make right because if we look at our stake tokens function it does a lot of things so let's check all of these and make sure that they all are working correctly so we'll also assert that the dot tokenfarm.unique token staked of account that address is going to be equal to one right this is going to be the first token so it should have a unique token state we should also assert that the token farm dot stakers at the zeroth index is going to be this account that we're using we update our unique token staked we update our staking balance and then we add stakers.push right so we're going to be the first address in this array now and then i'm going to do one other thing here too i'm going to do return token farm and dap token the reason i'm doing this is because now we can actually use this test in some of our other tests now we're getting a little bit integration here we're kind of mixing and matching some stuff we could even probably put this whole thing in a function in our regular scripts directory but for simplicity's sake this is how we're going to architect it but great let's test the rest of those we'll just hit up ground to test k test stake tokens we'll hit enter and perfect this is passing correctly as well awesome let's keep going now we're moving into this test issue tokens phase here and we're going to use our test stake tokens test here so the way that we're going to use this is we're going to grab this amount staked parameter place it in here and we're going to set this up exactly the same way we're going to set this up almost exactly the same way so we can even just copy these few lines here paste it we're going to do an arrange we're going to check to make sure we're on a local network we're going to get our account but instead of doing deploy token farm and dap token we're going to do token farm comma dap token equals test stake tokens and we're going to pass it that amount state so this is why we're returning the token farm in the dap token in our test stake tokens that way we can use that function now in our test issue tokens and perfect now we can test issuing these tokens so to test issuing tokens to issue this reward we want to first take some inventory of the current starting balances of our address we'll say starting balance equals depth token dot balance of account dot address and great this is how we're going to start off in our range phase now let's move to acting open our act phase and we'll just do tokenfarm.issue tokens we'll save from account and this is really the only thing that we're testing here so now we can move into the arrange stage and we'll do assert i'm going to do a little parentheses here because this is going to be a long thing and we're going to assert that the dap token dot balance of the account dot address should equal the starting balance plus some new amount what's that new amount going to be well if we look at our issue tokens function if we're staking in our conf test if we're staking one ether right or one die right because we're staking the dap token we're just taking one our marks are going to be this fusd price feed right our mock v3 aggregator when we deploy it the initial value is going to be this 2000 right here and we're saying in our mock in our sample here we're saying we are staking one depth token which is equal in price to one each so we should get 2 000 depth tokens in reward since we're saying since the price of eth is 2000 usd so there's a little bit of math here but the initial value is going to be 2000 right you can almost think of it like this with 18 decimals and our application pays us reward based off of the total usd value that we have locked so we actually can know that this is going to be that 2000 price so what i'm even going to do is i and if this isn't already in the chain link mix shame on me i should add this in here because we're going to add a new variable called initial price feed value it's going to be equal to 2 000. one two three four five six seven eight nine ten one two three four five six seven eight that super big number and we're gonna take that and we're gonna set that here to our initial value is going to be now this initial price food value and what we can do in our test is we can then import that from our helpful scripts and we can just assume that our starting balance is going to be now we are starting balance plus that initial price feed balance and if we've done our math correctly and if we've done our issue tokens and if we've done all of our get value correctly this should work we should have done our testing already on the things like get user total value right because get user total value is a subset of issue tokens but we're jumping the gun a little bit here and we're going to test this later on anyways so with that being said let's run this test brownie test dash k test issue tokens and lovely so our math is correct awesome we are doing wonderfully with her tests here we've even gotten some of the harder ones out of the way early which isn't too bad either now as far as this video goes we're actually going to stop writing the test because we're literally just going to keep going down that solidity file and grabbing functions and adding tests to them we've got all the tests located in the github repository associated with this lesson there is both a unit test file and an integration test file in the github repository if you want to just go ahead and check that feel free to do so we're going to move on to the next section to keep things moving forward but i highly highly recommend you trying to write all these tests yourself so good luck we're gonna have all right now we're going to umv private and our website make sure your integration projects work well make sure that you get started if you run your deployment on copy paste network directly we're going to be testing everything works we'll save dots of course you're going to want to get out.env file you're going to want to add that to your browning config address privacy and add your web3 inferior project id and make sure you have plenty of test dent coven so that you can actually run these deploy scripts we can always find the latest faucets from the link token contracts page under our coven or rink b networks here we're also going to need our wallets section we'll do from key and this is where we'll put the dollar sign private key now now that we've got the contract now that we've done all the contract work we're going to learn something totally new that we haven't covered yet we're going to learn to do some front end development now like i said this isn't a front end course and the focus isn't going to be on front end and i want to point out right away that this is considered a bonus section there are a ton of pieces in this section that we're not going to have the time to go over thoroughly because we're not going to be going into what's going on on the front end side the editing is a little bit choppier and i highly recommend having the documentation having the github associated with this front end with you while you're going through this free code camp has an awesome video on doing frontend work and if you want to learn more about react and typescript and some of the technology that we're going to go over definitely check out those videos after this we're going to make this though so that you should be able to follow along with everything that we're doing if you're not interested in front end feel free to go ahead and skip this part however understanding how these front end applications work is really helpful and it'll give you a massive massive incredible skill to actually build front ends for your smart contracts having a really solid user interface is really important in the web3 in the blockchain world if people can't use your contracts then what good is your application so with that being said let's jump on and let's build our front end and i know we said we didn't like javascript we're gonna be working with typescript here which is a improved version of javascript and catches a ton of the different bugs and allows us to be much more explicit with how we're working with our front end we're also going to be working with react we're going to be working with create react app this is a frontend framework that allows us to quickly spin up a front end to build for our applications here we're also going to be working with this tool called used app it's a framework for rapid dap development and works great with react here so let's get started building this front end the first thing that we're going to want to do to build a front end for our full stack application create react app boilerplate so you should have mpx installed if you run mpxversion it should show up this should be installed from when we installed npm if you don't have mpx installed you can run mpm install g npx additionally we're going to want to install yarn here to install yarn again you just run mpm install dash dash global or dash g yarn you'll know you have yarn installed correctly if you can run yarn dash dash version you see a version of yarn and i have a link to install both npx and yarn in our github repo great once you have those we can actually create a folder with all of our boilerplate code in it we're going to run mpx create react app we're going to call it front end and this is going to create a new folder called frontend and we're going to do dash dash template type script because we're going to want to work like i said with typescript instead of javascript for those of you who've never worked with typescript before and who have worked with javascript don't worry the syntax is nearly identical for those of you who have never worked with either don't worry we're going to walk through everything that we do and then we'll hit enter here what's going to happen is you'll see we're going to create this new react app in this new front end folder in our project here awesome now that we've downloaded our create react app we have this new folder called frontend and it's got a whole bunch of stuff in it now typically what different applications will actually do is they'll have one repository for all their python and for all their contracts but they'll additionally have a different folder or different repository for their frontend application and their frontend work this is really good practice we're just going to bundle everything up into the same repo here just to get started and just to make it easier for us getting started here however what you will see across different projects is they'll have a totally separate repo for their front end so let's take some inventory on what's actually going on inside this folder so the first folder you'll see is node modules these are basically the pip installs these are the different packages pulled in from javascript and typescript we can pretty much ignore this folder for the majority of what we're working with here next we have our public folder we're also not really going to go in here but it's got some nice little images it's got our basic index.html which has the html that we're going to be running with it has a couple logo images and it has a manifest the manifest is something that we want to change this tells our browsers a little bit about what our app is and what our app actually does so this is something that we we would change but everything in here is pretty selfexplanatory the short name of our application the long name of our application some icons start url this is something that if you want to fiddle with it later absolutely please go for it and then robots.txt we're not going to talk about this at all this helps web searchers and indexers learn a little bit more about your site we can ignore this one as well so for the most part we're not really going to do anything in the public folder or the node modules folder our source folder however we are going to be spending a lot of time in it has our app.css which includes a whole bunch of formatting for html we have app.test.tsx this is going to be testing our front end yes you can even test your front end we're going to totally skip over testing the front end which yes i know we've spent a lot of time testing our contracts if you want to learn more about testing your front ends there's some fantastic links in the github and in the description to go over this app.tsx which we are going to be spending some time in and it's one of our the main places for us to write some code index.css again a formatting and styling file anything that ends in css is some type of formatting and styling all these tsx are going to be type scripts index.tsx we're going to pretty much ignore we are going to change the logo and we can ignore all these last bits here a package.json this file tells our project what dependencies it needs and node.js packages it actually needs to get started we have a readme which of course is a readme we have a typescript config which gives us some options on how to work with typescript we're going to ignore this and then we have our yarn.lock which is an autogenerated file we're not going to touch it at all because yarn is going to automatically create this if you're not if you're unfamiliar with yarn.lock and unfamiliar with a lot of this stuff don't worry too much about it this isn't going to be a file you're really going to need to pay attention to but okay now that we've created the basic create react app we can actually go ahead and right now we can see what a front end will look like so we'll cd to the front end we'll run yarn just to make sure we have everything installed what yarn does is it actually installs all of our dependencies anything in this package.json yarn is going to go out and download these dependencies and store them into node modules and then yarn.lock is going to tell us exactly what it downloaded once running yarn now it just checks to see it says ah it looks like you already have everything installed because when we run create react app it already goes ahead and downloads everything but now we can just run yarn start if you want to know where this is coming from if you go in your package.json and you look under scripts these are the four different scripts that we actually run running yard start runs this mpx react scripts start which will actually start our front end so we'll do yarn start you'll see react script start you'll see it says starting the development server and after a little bit of time we'll get something that looks like this edit source slash app.tsx and save and reload and this is a super simple front end obviously this isn't at all what we're looking for but we've now started a front end which is fantastic it'll say compiled successfully it'll say you can now view frontend in the browser it'll tell you exactly where it's located on our local host on the network and it'll give you any outputs from the front end down below so we're just going to stop the front end for now by hitting command c or control c and closing it down of course if we reload now on the front end it's going to be blank but great so we have a really basic setup for working with a front end awesome if we look at an application like app.avi.com you'll see they have like this really fun connect button that pops up and they've got some nice user interface tools for actually working with the blockchain we don't want to have to reinvent the wheel and build all these custom tools for doing this so we're going to use this application called used app or this framework called used app which has a whole lot of these already built in to get started installing all we have to do is run this command right here yarn add use dap slash core so here in our front end we'll do yarn add at use dap slash core and this will go ahead and install all the used app pieces into our front end so we can actually work with used app and not reinvent the wheel with working with wallets and working with ethereum and other smart contract applications awesome now we have that installed we can actually go ahead and start building our front end now what we're going to do is we're going to go to app.tsx folder and we're going to start in here we're going to start adjusting some bits in here so what we can do is we can do the yarn start and we'll get our a little react front end here now what we could do is we go ahead and do something like change anything in here right see how this line says edit source that app source slash app and saved reload we could do we change this whole line being something just like hello we'll save it it'll recompile we can go back and now it just says hello right so this is how we can actually upload and update our front end we have these these wonderful return pieces here these return sections here which will return the html to actually render the front end and this is also our starting point for allowing our application to be web 3 compatible so if we go to this use dap documentation right we go to our getting started section we have a little example here that shows kind of what what something should look like right but it's not exactly clear where we put all this code so they do have this wonderful stepbystep bit and this is probably the most helpful bit here it says the first thing you need to do is set up dap provider with optional config and wrap your whole app in it so we're going to use these depth provider tags right this is the open tag and this is the closing tag we just wrap it around our app so we can see here this this whole thing right now is our app so we could take this whole thing delete it right and if we save right now we can go and see our friend is going to have nothing it's going to be blank this function app here that's getting exported export default app and this is getting rendered in this index.tsx we have this cool little app.html tag thing right but any case we want to wrap this whole thing with this tag here right so we can even just copy this paste it in i can do dap provider and then my vs code even auto adds a second dap provider here we can delete this div class name equals app i'll just put put a little divider in here and just say hi and at the top we'll just import this dap provider thing like what is this weird tag we're going to import it so we'll do import depth provider from and use dap core now if we hit save we'll get this weird error saying hey property config is missing in our dap provider and that's because this dat provider needs a config associated with it so we need to add this config bit into this dat provider so we're going to do config equals at this first bracket says we're going to type in typescript and the second bracket is saying we're an object here so in this config we're going to tell our application a couple of different things so we're going to tell it what supported chains there are what are the networks that our application can actually work with the default value for supported change in used app is going to be mainnet reli coven wrinkby robsten and xdi since we're going to be testing only on coven and ring b we could just do chain id dot coven and chain id dot chain id is another term that we can pull right from our used app slash core right and now if we wanted some other chain id we could just go ahead and put it in here right like if we wanted to work with our ganache we could just do one three three seven if we wanted some other random chain we could just put the other number in there right but chain id coven is going to be 42 and chain id that ring b is going to be what is it three yeah three or what or whatever it is and this is all we need to get started working with in a web 3 a blockchain compatible application so let's go back let's save and we'll refresh and now it just says hi how's it going so we're going to spend a lot of time in this source folder and since we're going to be here a lot let's let's do some cleanup just to cut down on the amount of fat that we have with that create react app so app.css we're going to toss this app.test yes tests are great but we're going to toss it we're going to leave index.css we do need index.tsx we don't need this logo bit anymore because we're going to use our own logo we do need this we also need this and since we're not running tests anymore we don't need this but i'm going to leave it in here just in case you guys want to later on go back and add some tests great so now we're looking a little bit lighter and in our app let's just remove amp.css let's remove logo.svb logo.svg goodbye now okay so we're going to create what's called a component we're going to create a header component now in react components are basically where you you put modular parts of your front end and we're going to create one of these components is going to be our header component to do this we're going to create a new folder called components and in here we're going to create a new file called header.ts and this is where we're going to put our header stuff and we're looking to to make a little button up here right we're looking to make a little button in this header so what we're going to do is we're going to import some stuff so we're going to import use ethers at usdap core again if we look at the documentation real quick this use ethers thing has got some cool stuff it's got this activate browser wallet thing got this account thing it's got some it's got some cool stuff so what do those actually do we're going to start by exporting a constant variable called header this is going to be a function and this is some really this is some really fancy typescript syntax what this is meaning is that we're saying header is a function and here's what the function is going to do we're going to use this use easter's thing to get a couple variables so we're going to say constant variable account activate browser wallet deactivate equals use ethers in order for us to actually use these though we need to figure out first if the user is connected so we're going to create another constant variable we'll call it is connected and this is going to equal an account it's going to equal an account it's going to equal account does not equal on d find so we're saying if the account is undefined we're not connected if it's not undefined then great we're connected so we're literally just looking to see if there's an account here and whether or not we're connected we'll decide if we show a connect button or not so to do that we're going to return a div this is where we're going to return some html stuff and we've got to check to see if we're connected so we'll do is connected i'm going to use this question mark which is known as a tertiary operator which means if this is true we're gonna do something and if it's false we're gonna do something else so we're saying okay if we are connected right what do we do if we're connected here well we're gonna create a button we'll have the color equal primary create this button here and then my vs code auto makes these closing tags we'd even leave this button blank if we want or we're actually going to put some fancy stuff in here and then we'll put a little function in it we'll say on click equals deactivate this is this deactivate function pulled in from our use ethers thing i should spell it right though and we're going to call this button oops there's a little parenthesis next to this so this is what this is connect thing does so we're saying if if we are connected right do this now we're going to do a little colon here and this is going to represent what we're going to do if we're not connected okay if we're not connected what we're going to show is a different button color can still be primary and we're going to do on click we're going to do a function activate browser wallet then we close up the button tag with another backslash button and we'll call this one though so if we are connected we're going to show a disconnect button and then if we're not connected we're going to show a connect button and that's it right just make sure all of your divs all your tags are matched up and we can go ahead and save this and if we look at our ui you'll see nothing's changed right okay well why isn't anything changed well this component that we just made it's living inside of this components folder and we've exported this this header variable this header function right however it's actually not in our app here right so if we look at our index.tsx this is what's actually getting rendered so we're just rendering this app variable which is pulled in from you know dot slash app right this app.tsx so index.tsx is really our true ground zero this is where everything really comes from this is kind of our entry point right this is our main function you kind of think of it that way that pulls from this app file that we have here you can see in here we don't have any reference to this header right we have our dat provider we have our div tag saying hi but we don't have the header in here so what we need to do is we need to import this component we just made into our app.tsx so we're going to do is we're going to import header from dot slash components slash header and now we can take this header bit we can place it inside our header tags here we can just do header and we'll close the tag by adding it right here we'll save and we'll head back and now we can see a little connect button here which is great obviously it doesn't look great but we have the functionality here which is what we want if we hit the connect button our meta mask will actually pop up and say hey would you like to connect which account would you like to connect i'm going to go ahead select my first one next connect it's connecting and now i'm actually going to be connected let's go to one of the supported networks like coven and now we can see here we have this on click equals disconnect if i click this now oops i need to actually sorry i need to put this inside the tag here so we just moved on click to be inside of this little button here now we can see it actually says disconnect and if i click it i get disconnected and if i connect i get automatically connected right so if we look at our metamask we can see we're connected right here right that little little green thing we can also manually disconnect by going right into our metamasks click this connected thing here click the account and hit disconnect the account and you'll see our front end does indeed update awesome this is how we can take our meta masks and actually inject it into our front ends so we can actually use the front ends great job this is absolutely massive where we are so far now you might be saying to yourself hey patrick this is cool uh but it doesn't look very good that's kind of a gross button in the top right corner can we can we style this up can we make this look a lot nicer and the answer is absolutely yes so there's a lot of different styling packages out there you can 100 write your own custom ones we're going to be using one called material ui it's a popular react framework for creating components and just doing a lot of styling and doing a lot of really nice work so we're going to be adding this to our project as well so to add it we're just going to use this this line and i'm just going to go ahead and do it myself and come in here we're going to cancel this with control c we do yarn add at material hyphen ui core and this will give us access to some really nice libraries for styling all these buttons installing a lot of the things that we're going to be working with back in our header we can add this styling here so we're gonna do import button make styles from app material hyphen ui core and we're gonna use their button and their make styles if we look in the documentation here you can find there but this is double narration kind of like what their default buttons look like and this looks pretty good looks a lot better than what we currently have we're also going to be taking advantage of their make styles bit here so make styles is a way to actually do styles for based off of different themes that you can actually use with materials ui we're not going to be working with css files because we're going to be working with this make styles instead if you prefer css you can absolutely easily translate these to css files so we are going to add some used styles first of all using make styles so in here we're going to do const use styles equals make styles and this is where we put a theme in here we're just going to set it to be a default theme um there's some documentation if you want to go ahead and add your old themes though so this make styles function it's going to have a container and in this container we're going to add some padding of theme.spacing for we're going to add display flex we're going to add justify content flex end and then we're going to add gap theme.spacing 1. so this is really just some typical css stuff now we're going to take this use styles constant that we just made and down here we're going to do const classes equals use styles so now we have this classes object that we can start working with we're going to take this classes object in our little is connected thing we're going to do div class name equals a little javascript in here classes.container we're going to wrap this whole thing in this div right and this is going to style this whole button div here so now if we go ahead and do yarn start again because we shut it off if we come back here we're going to see it's going to look a little bit different now it's been moved over here we have this like fun little disconnect connect button where there's some padding and it looks a little bit nicer and we're going to change all of our buttons to being kind of this builtin button from the materials ui so we're going to swap out all those buttons with this with our new button here if we go back we can see it's it looks even nicer now now that we've swapped it out with that with that new type of button right it's got a nice little clicky feel to it and then we can also do another line called variant equals contained for each of our buttons so right next to the color primary we'll do variant contained and then now we go back and we have a really nice button now so awesome now we have like a really nice button let's create a component that will contain the meat of our application now though from materials ui we're going to use what's called containers right and these are nice little containers that are going to allow us to style and make these different sections well we can use we can import this container bit from this materials ui by doing import container from at material hyphen ui core in our app.tsx and what we'll do to our header we'll make a little container here container give it a closing tag container and then maybe in here we'll put this little div high right so we'll remove that div we'll paste it in here and now we can see that it's been formatted a little bit right it's been pushed over from the side it still says hi we're going to want to do one more thing we're going to give it a max width of being md oops max width equals md and this max width now if we look in the docs again on materials ui these are the different sizes we have large medium small extra large extra small and then false right these are the different options we can have for max with we're just going to do medium so if we save this now go to wrap we can see it's been pushed over a little bit more it's time to add our main pieces right we're going to need that top piece for staking and the bottom piece for unstaking so we're actually going to create a new component called main and this is going to be our main component so we're going to create a new file in components called main.tsx so let's start by just showing some information about our wallet right showing what we have in our wallet associated with what we have in their smart contracts so we'll say export a constant variable called main and this will be a function here's that syntax for functions in typescript and javascript in order for us to show what amounts that we have in our current wallet we're going to need to know what chain that we're even on because the network that we're on is going to determine where the addresses are right because it's going to be different if you're on coven or mainnet etc now this is where it gets a little bit interesting because obviously with brownie we know where these addresses are right and brownie keeps track of this for us right it does it in our builds folder in our deployments folder if we look there now if you actually deployed something to coven you'll see this 42 you'll see some stuff in here you'll see this map.json which has the most recent deployments of our tokens our tokens and our token farm if you actually deployed it to coven if you haven't deployed it to coven i highly recommend you doing that now as well this way we can test our front ends against a real test net so in order to get these addresses we're going to have to ask brownie hey brownie what are these addresses where are these coming from so we're going to need to grab some information from this brownie config we're basically going to need to get all the information all the information that's in this brownie config right because this has has these addresses already and this is what we want however it's really hard for node.js to work outside of this source folder so what we're going to want to do is we're going to want to send that brownie config to our front end the way we're going to do that is we're going to actually modify by adding a new function called def update front end now the only reason that this works is because we have both our contracts and our frontend in the same repository in the real world once you deploy your contracts those addresses are pretty much set so you can just copy paste them over to your front end repository but for us we don't have set contracts yet so we need a way to update our front end so what we're going to do is we're going to send that brownie config over to the front end right that way our main can know where those addresses are we're also going to need to send so we need to send the brownie config to our source folder we're also going to send the build folder why because this will have access to the dap token address or any other mock addresses that we're using we're going to open up our brownie config and we're going to paste and we're going to dump the config into that source folder now typescript doesn't work with the ammo so well it works with json really well so we're actually going to convert it from yaml to json and dump it to the front end so we're going to open up our brownie config we're going to say with open brownie config yaml we're going to open it in read format we're going to say as brownie config we're going to say config dictionary equals yaml dot load brownie config loader equals yaml dot full loader so we're gonna have to import this yaml from the top we're gonna do import yaml and what this yaml is gonna do is it's going to allow us to load our yaml into a dictionary that's really it so you probably don't have it right now you're going to want to run pip install pi yaml to actually get it now we'll be able to have that now that we've got this in a dictionary we're going to want to send this to the front right we're going to want to write this dictionary as a json object to our front end so we're going to say with open we're going to open that front end source folder and that's just where we're going to dump this file we're going to call it brownie config dot json we're going to open this new file in write mode we'll say it's as brownie config json what we're going to do is just do what's called a json dump we're just going to take this dictionary and dump it as json into this file so we're going to say json.dump config dick brownie config json of course we're gonna have to import json and then at the end we'll even print front and updated so now we have this update front end script what we can do when we run our deploy token indepth token we can just add this update front end bit now we don't want to always update the front end right we only want to do when we're working with the front end so in our deploy token farm in depth token we're going to set update front end equals false so by default this is false this way when we run our tests the front end won't get updated right and down here we'll just say if update front end and we'll update the front end otherwise we won't and in our main function here we'll just say update frontend equals true now if we deploy this to coven or rink b we'll automatically update and send this browning config and then let's actually change this to front and update instead of update front end so that we don't have the same method name as our boolean here so we'll do front and update instead so now when that we deploy we'll actually go ahead and update our front end here but we're not always going to redeploy so let's also create an up date front end dot pi script and this we'll just call that function that we just made so we'll do def main update front end and then we'll do from scripts dot deploy import update front end semicolon there great let's open up a new shell by hitting a little plus button here now we have two shells and we can just do brownie run scripts update front end doesn't matter the network and what this is just going to do it's just going to run that copy script right it's going to run our our update frontend script which we made right here so if we did this right we should now have a brownie config.json in our end source directory so if we go in here we go into our source directory we can indeed see it's right in here do we need anything else well so that's going to give us those addresses right it's going to give us it's going to give us some of the addresses but it's not going to give us everything what about dap token right the app token isn't going to be something in our brownie config last token and fau token sure they'll be in our config but dap token is going to be something that only is going to be deployed by us so we need to send that to the front end too we need to send basically our whole build folder so we're going to need to update this update frontend script to also send send the build folder i know that we're actually going to be copying a number of different folders so i'm just going to go ahead and make a new function called copy folders to front end and in here so we're going to make this copy folders to front end function here we're going to do a couple of clever python things this is going to take a source and a destination so we want a source folder and then a destination folder so we're going to copy this build folder and move it to you know some folder in the front end first we're going to check that that destination exists and if it exists we're gonna kill it we're gonna we're just gonna remove it so we're gonna say if os.path dot exists destination we're gonna do this shuttle dot rm tree dest and this is gonna kill everything so we need to import both of those we're going to import os we're going to import shuttle or shutil i actually have no idea how to pronounce that but we're going to remove that whole bit and we're just going to copy everything over from our build folder so we're going to do shuttle dot copy tree src dest so we're going to say hey if that build folder exists in the front end just delete it and we're just going to copy everything over from the build folder and we're going to do this copy folders to frontend a few times the first thing of course like i said is going to be with this build folder so we're going to do this copy folders to frontend the source is going to be dot slash build so we're going to take this whole build thing and we're going to move it to dot slash front end src and we're gonna create a new folder in here called chain info right and this is just gonna have all of the build information and all right cool so now we can run that brownie run scripts update frontend we'll go ahead and run that and great front end is now updated so if we look at our front end we're looking source we now have this chain info folder which is literally just the build folder which is awesome now we can actually start working with these pieces in our front end so let's figure out how to get the depth token address well to get this dap token address we're going to need that map that we just got from chain info in our deployments but we're also going to need to know what chain that we're currently on like what we saw before we have this chain id from used app core which will tell us what chain id of the current network that we're on so we can go ahead and import that in here as well so we're going to do is we're going to import use ethers again from at use dap core what we're going to do here is use ethers allows us to get the chain id that we're working on so we can say cons chain id equals use ethers now that we have the chain id we're going to have to map it to the name of the network right because our browning config has this network section but it's mapped by the name of the network not by the id so what we're actually going to do is we're going to create a helper config in our src so we're just going to create a new file helper config dot json and it's literally just going to be a json object that maps numbers to their associated chain names so 42 for example is going to be kovan four is going to be rank b one three three seven gonna be dev or it could also be ganache right one is gonna be mainnet etc now that we have this helper config we can do import helper config from dot dot slash helpworkconfig.json and before we even get the dab token address we can do const network name is going to equal that helper config at the chain id now typescript is actually going to get a little bit mad at us here so we need to add a little bit more to this line actually so we need to say okay only grab from this helper config if chain id exists right because there might be a chance that train chain id is nothing or it's something really weird so we're going to say chain id i'm going to use this tertiary tertiary operator again we're gonna say if this chain id exists then go ahead and use the helper config however if it doesn't exist just use dev i should spell chain id right so it doesn't get really confused to me and whenever we return one of these components or try to use one of these components we're always going to have to return some type of html or div tag like this we head over to our app we add our little main bit here of course we're going to want to import this say import main from dot slash components slash main we save it we'll add our main tag syntax we're basically saying in it now depending on your setup you might actually run into this error here saying element implicitly has an any type because expression blah blah blah you might be saying okay well what's going on here now to make our lives easier we're going to tone down typescripts strictness here so what we're going to do is in our typescript config.json we're actually going to add suppress implicit any index errors so we're basically suppressing when we get this type of error because it's not ever actually going to affect anything i should probably i should probably spell this correctly we'll save it now if we save this file here we're going to actually get this saying everything's compiled everything looks good and if we refresh our front end we're gonna get back to exactly where we are before now what we can also do is we can also console.log these out we can also see in the console exactly what these are gonna look like so if we do console.log chain id and console.log network name we save and we go back we can go hit inspect go to the console and we'll see 42 and coven gets printed out in the console over here so that's 42 is the chain id and coven is the is the network name so we know that we're doing this right okay great so we have our network name and we have a chain id we've got a way for us to update our front end with a new script let's finally get those different addresses that we need say the constant variable gap token address is going to equal something from that build folder or that chain info folder that we created inside here inside deployments we have this map.json and since i've already deployed this to coven we have dap token and token farm on the cova network so we can then use that and say if if we are connected to a chain id and that's again that's what this question mark is doing saying if this chain id exists then look into that mapping else we're just going to use a zero address right so how do we actually get this mapping in here though so i'm going to say import network mapping from this is going to be in that chain info folder inside the deployments deployments and it's just going to be map.json so we're going to take this network mapping object and we're going to say if the chain id exists then inside this network mapping json object we're going to cast that chain id as a string and then we're going to grab the name of the dab token which is going to be dap token and we're going to grab whatever address is at the top right so this is going to be a big list the more times we deploy the more times brown is going to keep track of it and there's going to be all these different addresses and we just want this one right at the top right we want the most recent one here so we're just going to say at position zero otherwise if we're not on a chain id we're just going to use a zero address and ether's js actually has a really nice package to give us what's called constants so we're going to do constants dot address zero and we can import that from ethers so we'll do import cons dance from ethers if you don't already have ethers installed here we're going to do cd front end we're going to do yarn add ethers and now we have the ethers package in here now we're not going to do the same thing for the weft token or the fau token because those tokens are defined in the brownie config as opposed to being defined in our map.json here so to get those ones we're going to say const with token address it's going to equal let's check first if the chain id exists and if it does we're going to grab it from the brownie config so to grab that we're going to do import brownie config from again now that we've imported it brownie config.json now we can work with this brownie config inside of our front end so we'll say browning config of networks of that network name of the left token and if chain id oops chain id does not exist then once again we're gonna do constants dot address zero so we're just gonna leave it blank and then we're going to do the exact same thing for the fau slash the die token so we'll do const fau token address equals chain id question mark so if the chain id does exist it'll be the brownie config networks network name fau token and if chain id doesn't exist it'll be constants dot address zero okay awesome and if we save it oops looks like i put in an extra comment there by accident i'm just gonna get rid of that and resave and then refresh here so i'm getting an issue uh because i'm on the rink beat chain right now and it's saying hey there's no there's nothing for rink there's no dap token for rink b you gotta be on coven so if i go back to coven here and i refresh now it works out fine right this might still break for you if you're on coven and you haven't deployed anything to coven we can fix this in our config for the dap provider by changing the supported chains for this now typically a lot of the times you're going to want to test using a ganache chain or some type of local chain so that your front end testing can be a lot faster for this we're just going to do everything on coven but a nice little challenge for you would be to refactor this so that it also works with something like ganache and we're going to not use ganache so i'm just going to go back to app.tsx we're going to remove ganache even we're going to even remove rink b for now we're just going to work with coven just to make it simple if i go to our react page now refresh i can connect awesome if i go to ring b it's not going to freak out because it says hey ring b is not even supported so i don't care what you're doing however covent is supported so we're connected and we're looking good and the thing is we really don't want to couple our front end with our contracts right we really want to code the contracts independently and the front end independently anyways so let's get back into our main.tsx because we're going to be in here for a while but we've already done some great things we've gotten what network we're on what chain id we're on and we've gotten the different addresses for these different tokens so as you can probably see the place that we're actually going to put stuff on the front end is in this little return statement here right right now we're just returning i'm main and we just see my main right here to do this we're actually going to make another component we're going to make a component called your wallet this component is going to be a part of this main component here it's a component inside of a component that is literally only going to address our wallet needs so in our little components tab here we're going to go ahead and create a new folder and we're going to call it your wallet and this is just going to have everything to do with our wallet in here so let's get in here we'll create a new file because we're going to actually make a couple files and our first one is going to be your wallet.tsx this is going to be our component that is just going to deal with getting our wallet getting the token balances of the different tokens that we have since we know we're going to put this component in main and main is in our our home base our app.tsx you know that we're going to do an export const your wallet in here and we'll make this a function now in order to actually show these tokens we do need to get some information from our other component we need to get some information on what the supported tokens even are so we're going to have our main actually pass a variable to our wallet here we're going to call it the supported tokens and this is going to be of type your wallet props and this is going to be a your wallet props here just to tell typescript what this is what this supported tokens is going to look like we're going to say interface your wallet props it's going to look like this supported tokens and it's going to be an array of tokens and array of some token we're going to grab that token type from main as well so actually we're going to do import token from main and in our main we're going to pass this token and we're going to pass some supported tokens to our wallet so right underneath those three token addresses back in main we're going to do const supported tokens is going to be an array of token this token type so above here we do export type token equals and we're going to say a token type is going to involve an image which is going to be a string an address which is also going to be a string and a name which will also be a string so we're creating a new type called token here in our main function we're creating this supported tokens object which is an array of tokens and this is excuse me and this is going to equal that array syntax so our first token is going to be have an image that we haven't defined yet the address is going to be this dap token address and the name the name of course is going to be gap for dap token now we're going to need a couple images so at this point you should see where we're going with this we create this array of supported tokens first is our dap token and we need an image for this dap token so if you're following along you can just grab this image right off of the github and we're going to grab that dab token and we're going to pop it into src we're going to change this to dap.png now we can import this by doing import dap from dot dot slash dap dot png now i can take this dap image and under image i'll put now let's do the other tokens so we'll do a comma we'll do image we'll be f oops f address will be weath token with token address name will be wef and again we can either oh and let's close this off and again we can either grab right from my github or pop it into my src here we'll change this to f dot png we'll scroll up and we'll import this as well import f from dot dot slash at that png and boom that looks good one more comma image it's going to be fau or it's going to be our die token address is going to be fau token address name it's going to be fau or die this will be our die token we'll pop it into our src change the name to die dot png no import die from dot dot slash die dot png grab die and it looks like we're going to name it die actually instead and if your vs code starts yelling at you about this can't find module it's really confused what we're going to do at the top here so we're just going to add a little comment backslash star eslint disable spaced comment star backslash dash dash dash ref errant types equals react scripts and we'll save and that issue will go away all right well now that we have our supported tokens token array we can actually pass this to that your wallet bit right so now we're going to go to this return bit we're going to remove that div on main and we're going to actually start getting to some meat here so we're going to pass this to our your wallet component that we're going to import in just a second and we're going to send it our supported tokens let's say supported tokens equals supported tokens backslash like this and of course we're gonna have to import your wallet here so we'll scroll to the top we'll do import your wallet from dot slash your wallet we're actually going to make a new file in our your wallet folder called index.ts and we're just going to export your wallet from dot slash your wallet save that i'm getting an issue saying you wallet it's not defined it's because this should be your wallet okay cool so we're getting another issue but i'm going to fix that in a second great so now we have some supported tokens we have a wallet here we're exporting our wallet with our index.ts and our your wallet folder now let's finish our your wallet implementation and this needs a little equal sign here whoops and we're going to get this little error basically because we don't have a return here so we could just do return just to make it happy div hi and we'll even change this to i'm your wallet and we'll save and now everything's happy we'll go to our front end we'll do a quick refresh and now we see i'm your wallet so let's keep diving into your wallet here right because this is going to be where we're doing all of this stuff about what's in your wallet now we're going to use a couple of these components from the materials ui here to get started to start we're just going to use this box the box component it serves just as a wrapper component for most of the css utility needs it's just a box right it's a box that we can put on our front end so we're going to come over in into our your wallet and we'll start working with this box we're going to put everything inside of this little this little box here i'm going to import this box import box from at material ui core we'll give this a little header h1 we'll say your wallet h1 get a little header your wallet on your wallet great now we'll get rid of this little i'm your wallet and we'll create another box and in here we're going to add all of our functionality for what is in our wallet now we're going to use some tabs here from the materials ui to swap between the tokens right we're going to have one tab for fau token another tab for zap token and for wrapped ether we're going to use this this this tabs thing here so to work with tabs we're going to need to import some tab stuff so we're going to import tab context tab list and tab panel from material ui lab so material ui material i slash lab these are some components that they're not quite ready to move to the core so we do have to add these as well so we'll go to our front end and our other shell and we'll do yarn add and material ui lab these are kind of their testy ones but they have some really nice features that we're going to use but let's get into this box and let's make our first tab context value equal to now in our box here the first tab that we're going to have to use is going to be whatever token that we have selected to select tokens we're going to use what's called a state hook so we're going to create a state hook here inside of this we're going to do const selected token index set selected token index equals use state number zero so use state we're going to grab from react it looks like i've already imported here import react comma brackets use state from react and what this is going to do it's going to create one variable select the token index this is going to be whatever token that we're on and then set selected token index is going to update this selected token index this u state state components thing is a way of saving state between renders of components so in our little box here we're going to start with a tab context we'll start basically with our own tab and the value is going to be equal to whatever token we currently have selected dot to string and we're gonna have to make a list of these tokens in our tab context we're gonna have to add some way to change between the tabs right when we change between the tabs we want a different token to be selected and we're going to make a tab list that's going to change whenever we click the different tab so we're going to add we're going to add some functionality to this but for now we're just going to give it an aria label call this our stake form tabs and based off the supported tokens in a mapping of token to index we're going to call a function in here where we return a tab which will have a label equal to the token.name the value would be equal to the index dot string or excuse me dot 2 string and the key is going to be equal to the index tab is something that is just from the material ui core so we're going to import tab from that material ui core i should probably spell supported tokens correctly supported tokens now if we look at our ui we can now see we've got a couple different buttons here which great we have dap west and die right these are the different supported tokens that we're mapping here now of course if we click the different buttons nothing actually happens so we do need to to handle a change we do need to code some functionality to handle a change whenever we do something different so in our tab list we're going to add on change on change equals handle change i'm going to code a little functionality at the top to actually handle a change so we'll say const handle change equal to an event a react dot change event we'll do a new value it's gonna be a string and this is a function so we're gonna do this little function syntax again and all we're going to do is we're going to use our little state hook here so we're going to do set selected token index and we're going to parse the int of the new value that we get so what's happening here we've added this new functionality where whenever we change one of those tabs we're going to change this the selected token right this selected token number is going to be different and what we do is we map the indexes to a token right so each one of these tokens is going to represent a certain number so now when we save let me go check out our front end you can now see that we do indeed swap between tabs here which is really nice all right let's keep going so that's cool we have a way to swap between the different tokens visually here but we need a big stake button right the reason that we need to swap between the tokens is because we need a way to stake between them so when we're on one of these tabs we're going to add a stake form here we're going to add a big button that allows us to stake so we're going to do some typescript we're going to do supported tokens.map i'm going to map that token and index again function use that and then here we're going to return a different tab panel the value in here is going to be the index dot to string key is gonna be the index we'll make a little div in here and we're gonna need to put two pieces in here we're gonna need to be putting our wallet balance in here and then also a big stake button right of course we're looking at right now it's just going to say our wallet balance and a big stake button but how do we actually do this how do we actually get our wallet balance and one of these big stake buttons well we're probably going to need some type of component to get our actual wallet balance that we're going to stick in here so yup you already know we're going to go in here into our your wallet component we're going to create a new file and this is where we're going to define that wallet balance component and we're going to import our wallet balance into our wallet here so that we can actually see the balance of our wallet right in the front end and right and this is where we're going to actually be reading off chain finally after a lot of typescript and react setup since we're going to be importing this into our your wallet component here of course we're going to start with export const wallet balance we're going to make this a function so we'll do this really weird function syntax and we're probably going to want to pass this the token right the token that we want to get the balance of so we're even going to set that up like this a token in here and we'll define what this looks like uh with the interface called wallet balance props so we'll say export interface wallet balance props and this will be a token right this will be that same token type that we defined before so we're gonna have to import that so we'll say import token from main all right great that's our initial setup here we'll grab from the token that we passed to this we'll pass we'll get the image address and the name from that token address and name we'll grab the account right because we're going to need the account with along with the token so we'll say const account equals use ethers and of course we're gonna have to import account from excuse me imports not account use ethers from at use dap slash core we're gonna need the account we're gonna need the address and use dab core has a nice little hook called use token balance that we're going to use you look check it out in the documentation provides a way to fetch the balance of erc20 tokens specified by a token address it makes our lives a lot easier so we'll just import that as well use token balance and all we have to do really is do const token balance equals use token balance of the address of the token and our count here we can even do a quick console.log token balance see if we're doing it correctly and we take this wallet balance and import it into our wallet here we should be able to see something so we'll import it into our wallet now let's go into the top we'll do import wallet balance from dot slash wallet balance and down inside our very large return function here we'll add this new tab or this new uh component we'll say wallet balance we still remember we need to send it the token so we'll send it tokens at the index of the selected token index i should spell supported tokens right i should spell wallet balance right capital b we do need to do a return so that it's actually a jsx component we'll do a div we'll just have to say i'm the wallet balance if we go to our front end we do a quick refresh we do indeed see this little print line here uh this is javascript's big number so if we really want to see this token balance we'll do dot to string and we have to put this question mark here to tell typescript hey turn it to a string if it's not undefined and now if we save we go to our front end we do a refresh since we are connected to coven here we can see we get an amount printed out here and if we switch tabs you'll see the different amounts being printed here which is fantastic cool so let's remove this little console.log we want to show this token balance obviously in our ui right we don't want to have people to have to go to the console.log right to actually see it we want it to represent we want to show up where it says i'm the wallet balance so what we're gonna do first we should probably format it right because this is in units of way so we're gonna do const formatted token balance this will be a number which will equal to token balance if token balance does exist again we're using this tertiary operator we're going to parse float format units balance 18 otherwise we're just going to use zero format units is a nice little import that we're going to grab from the ethers project so we'll do import format units from at ether's project slash units and of course yarn add at ethers project and of course we're going to do a yarn add on this here we'll do yarn add at ether's project units and now this formatted token balance is going to be this token balance that we just got but formatted formatted much nicer in our little div here what we could just do so we could just add this formatted token balance we'll save and we'll look at the front end now and aha we now see we have 100 dapp zero weft and 15 die right these numbers might be a little bit different depending on how much you actually got but this is perfect this is exactly what we're looking for so let's close out the console and let's let's flesh this out a little bit let's make this look a little bit nicer here so instead of just returning a little div like this let's actually make a new component called balance message and we'll use this instead create a new component called balance message and it'll format up the way we actually show these formatted tokens and here we'll pass we'll pass it a couple variables we'll pass this component an amount we'll pass it a label we'll say the label is going to be your unstaked name balance right we're grabbing name from the token and we'll pass it a token image src which is going to be that image so we're going to pass it a label or excuse me not img it's going to be image we're going to pass it a label token image and an amount right and this component is just going to make us have this balance look a little bit nicer so in our our your wallet section i'm going to do a new file called balance message.tsx oops not tsx tsx and we can kind of rip through this pretty quickly so per usual we're going to export const balance message is gonna equal a function where it's gonna take those parameters a label and a mount and a token image src and this will be an interface of balance message props this will be a function of course so we'll do this weird function syntax of course we need to tell typescript what this looks like so we'll say interface balance message props what are those inputs we'll say the label is going to be a string the amount it's going to be a number and the token image src is going to be a string and in here we're going to use and in here we're going to once again do that use styles bit for materials ui because we want to style this up a little bit so we're going to import make styles from at material slash ui core we'll do a const use styles it's going to equal make styles theme which we're going to skip doing a theme but let's make some styles for the different pieces let's give it balance message be surrounded mainly by a container which will have a couple of styles in here we'll say the display it's going to be an inline grid the grid template columns are going to be auto auto auto again you can check out all these parameters in the documentation there's going to be a gap which will be theme dot spacing one again we're skipping theme but this will just be a way to add some spacing and then align items in the center we'll also give token image its own styling we give it a width of 32px 32 pixels and then the amount just do we go to font weight of 700. so we'll make that a a little thick so now that we have our use styles we have our styling here we can go into our export below we'll do const classes equals use styles and we're going to return we're going to return a div class name is going to be equal to that main container classes.container we'll do another div just for that label that we're looking for we'll do another div for class name equals classes dot amount so have that that nice font weight and then here we'll just have the amount and then we'll grab that image of the token class name is going to equal to classes dot token image we'll grab the source of that image is just going to be that token image src that we get passed and we'll give it an alt called token logo and we'll close that tab out great so we're going to want to do is in our wallet balance here it's balance message that we just created we'll do import balance message from dot dot com mints slash your wallet capital w and actually i know we're going to use this balance message a little bit later so i'm actually going to grab it and drag it into components move it into components and move it out of your wallet because i know that we're actually going to use it a little bit later so that means in our wallet balance we're just going to pull it right from components slash balance message and whoops we actually need to make this look like this close it out here remove this part like this boom right like that and now let's try out the front end okay we're looking a little bit nicer right we have a really thick number here explaining how much of the token we have we have the images popping up this looks starting to look great let's add this stake button right so that when they see this they can actually stake and interact with our contract here so to do this we do need to create another component called our stake form so in your wallet we're going to create a new file called stake form dot ts x and this is where we're going to add a little button and an amount for the users to actually stake on our contract so you already know we're going to start with export const state form equals and we're going to have our wallet pass the token just like we passed the token to wallet balance so we'll say token and we'll have this be stake form props which is an interface we're going to define in a second this is a function so we'll do this fun function syntax here and then stake form props as you know is just going to be a token so do inter export interface stake form props this is just going to be a token of type token which again we're going to import token from maine great and that is our starting point for this so we're going to create a stake form with a big button that says stake and the user can actually choose how much they want to stake on our smart contract so we're going to do some similar stuff as we did before we're going to grab some variables we're going to say the address is going to be that token address that we get from the pass token we're also going to get a name of the token from that token we're going to get our account from use ethers again so we can import that we'll say from or oops import use ethers from at use dap slash core we're going to want to grab the token balance so we'll do const token balance once again we can grab that with the use token balance with the token address and the account so we're going to use use token balance this will also grab from used app slash core we're going to want to format this token balance so we'll do const format it token balance it's going to be a number again this is going to be the exact same as we did before say token balance do parse float format units token balance 18 or zero in format units once again we're going to import that import format units from at ether's project slash units perfect importing here we've gotten some some starter boilerplate let's just go ahead and grab those buttons right because those are really the things that we're going to care about here let's just return some stuff here so something can show up on our front end right so let's do return i'll start returning something here and whenever we return something it's all gonna be in one tag right so i'm gonna i know i'm gonna be doing a whole bunch of different tags so i'm just gonna go ahead and make an open and close tag here and this is where i'm going to put all my stuff now we know we're going to want to have a big stake button right so let's go ahead and just do let's get a let's get a button tag in here and of course since we're going to have a button we're going to pull this in from that materials eye material ui right so we'll do import button from material ui core just so we can get get started with something here and then back in our your wallet.tsx let's add this button in here inside of our tab panel right below our wallet balance we'll add this stake form thing we'll open and close of course we've got to import it so we'll say import stake form from dot slash stake form and we need to pass this that token object so back in our your wallet we're gonna say okay token equals supported tokens of that selected token index selected token index and let's not have this let's just do a little backslash here to close that out let's be sure to close this bracket here we'll give this button some stuff right we'll do color equals primary say size equals large then we'll give it some text called stake double exclamation point or however many you want to put in there and now if we look at the front we got this big stake button nice okay we're looking a little bit better currently doesn't do anything but we have a stake button great now we can start adding some implementation right we can have it do some stuff now when we hit this stake button what do we want it to do we want to do two things we want to approve whatever token that we have and then we want it to stake that amount we also need to have some type of form here we need to know how much we want to stake right so we're going to need some little input box that we can add a certain amount in well we can do that too with a little input box from materials ui so there's another package we're going to grab which is called input from materials ui core and then we're going to use this little input box before the button so we're gonna do input little slash here now if we save refresh the front end awesome now we can do some typing in here we can click this stake button now to do this though we're gonna need to keep track of how much amount is in here right we're going to need to keep track of how much amount's in here so we're going to inspect on the front end and we're going to go to console and see if we can follow along with how much is in here or what amount is in here and to do this we're going to make another one of those state hooks and we're going to track that amount in there so we're going to say const amount set amount for one of these stakeholders equals use state which is going to be a number or a string or an array number or string zero and we're going to import this use state here from react so we're going to do import import react use state from react and now we have this state hook that we can use to keep track of the amount that's going to be put in there with our input tag here we're going to say on change whenever this changes we're going to have to have some handle function right we're going to call it handle input change and this is going to handle the input change so we're going to create that function we're going to do const handle input change equals and we're going to use some event stuff in here we're going to say this is going to take an event a react dot change event of html input element this is going to be a function that's going to set amount it's going to say const new amount equals event.target.value whenever we change that value in that field if if it's equal to nothing then we're just going to say okay we're going to do nothing otherwise we're going to cast it as a number event.target.value we're going to cast whatever is in there as a number and then we're going to do set amount to this new amount what we could do is we can even do a console.log new amount and now and we can start using it right so if i go back here and do one two three right you can see it's console.logging every time i change something in here so now we have a way to actually get that amount with this input now we're going to need to weigh to send that amount as part of our stake right so we're going to first have to call that approve function with this amount and then we're going to have to call from our token farm then we're going to have to call the stake method so how do we get it to call this approve function here well to do these we're actually going to make some new state hooks that we're going to use in our staking form here we're going to make state hooks for approving and for staking and even for unstaking so back in our folder here we're going to create a new folder called hooks and this is where we're going to add some different hooks first hook that we're going to make is going to be called use use stake tokens dot type script and this is something that we're going to import into our our stake form here so we can actually stake some tokens and the way we want to do it too is that once we hit stake once we hit our stake button it kicks off the approve and then and actually right afterwards it kicks off ascend it kicks off a stake token we want to run these two functions sequentially and we're going to make this use stake token hook clever enough to do it in that order so let's do it hooks are basically just like components except for they're more functionality wise so since we know we're just like components we're going to do export const use stake tokens and this is going to be a function just like our other components and as input we're going to take a token address that's going to be a string and inside of this we're going to have some intelligent scripts to know if it's already been approved if it's not already been approved and what we need to do right we know we're going to need some approved thing and we know we're going to need some stake tokens thing so let's let's at least try to approach this approved thing first before we get too creative right how do we approve this transaction to get an approve we're going to need a couple things we're going to need the address as you guys know we're probably going to need the abi we're probably going to need the chain id so we know which chain it's on so let's go ahead and let's grab those so we'll do const chain id equals use ethers and since we're using use ethers here we're going to import this so we'll do import use ethers from at use dep slash core we're also going to want the abi of the token farm so we'll do const abi equals well where do we get this api from ha that's right we've imported it in our little chain info piece and should be right in here we could should be able to do import token farm from down to directory it'll be in chain info slash contracts slash tokenfarm.json and now we can say avi is going to be equal to this this token farm right because in token farm we have an abi key so we can just abstract that away and just pull out the api perfect we're going to need the token address of course we're also going to need our token farm address and we can find that the exact same way we found it before with const token farm address it's going to be equal to depending on if the chain id exists once again we're going to want to use that network mapping so we can even go back to main.tsx let's see how we did it here for the depth token address you can copy this as like a frame of reference we'll say if this chain id exists we'll pull right from that network mapping right we'll pull right from the network mapping so we got to import that too which we can grab from import network mapping from chain info chain info slash deployments slash map.json so once again we're going to say if that chain id exists in the network mapping we're going to use that string chain id so we'll do string chain id of the token farm at position 0 right because we obviously want the most recent one otherwise again we'll do constants dot address zero and since we're going to do that of course we're gonna have to do import constants from ethers and this hooks folder should be in source so let's just make sure that we have hooks in source here now we're going to want to interact with this token farm address contract right we're going to want to run that proof function first we want to create like an interface so we can do const token farm interface we'll say this equals new utils.interface with the abi this utils we can again grab from the ethers project or excuse me from uh from ethers so we'll do comma utils now we can create a token form interface here and now that we have interface we'll create a contract so we'll do const token farm contract equals new contract and this will be a combination of this token farm interface and the token farm address actually it's address first and contract is something we can grab from import contract from at ether's project slash contracts all right you're probably starting to follow along and figure out okay cool i have a token farm contract now that we have a contract we can actually call some functions which we totally can but right we need to call the approve first so let's get the token contract before we even work with the stake token right so to work with the token we're going to want to do the same thing so we'll do const erc20 interface equals new utils dot interface interface and this will be from ear c20 abi which we should probably make first so we'll do const erc20 avi equals we'll do it the same way we did up here except for instead of token farm we'll do something else we'll do look in our contracts here we'll do mock erc20 instead and then we'll just call this erc20 or yeah we'll just call this erc20 but we'll grab it from our mock erc20 dot json so now that we have the crc20 we do const erc20 api equals erc20.avi and we can just pop this api to create our interface we'll now do const erc20 contract equals new contract of the token address comma the erc20 interface boom okay now we have both of these contracts we have the erc20 contract we have the token farm contract now we should be able to go ahead and call some functions right now to actually send one of these we're going to use this thing called use contract function it's a hook in use dap that returns an object with two variables a state and a send this state bit is used to represent the status of the transaction and that's how we're actually going to automatically kick off the stake after we approve to send a transaction we have to actually have to we actually have to use this send function here so we're going to use this use contract function to get to get a state and ascend so that's what we're going to first need to do so we're going to const send and then we're going to call this approve erc 20 send and state because this is what it's returning it's returning send an estate i'm going to say state is going to be approved erc20 state equals use contract function we pass the token contract the erc20 contract comma the name of the function which is going to be approve then we do a comma and then we'll do a little object here we'll call this transaction name and this will just be approve erc20 transfer then of course i have to import this from used app this use contract function now oddly enough oops i got rid of the closing tag here but great so now in a weird way we actually have these two new pieces here we have this send function this approve vrc20 send and this approve erc20 state this is going to be the status of our transaction and this is going to be the actual function that we use and if we want to call this approve function what we can do is now we can return calling this proof function so we'll do const approve we'll have this be a function we'll say it'll take a string amount as an input parameter and we'll just have it return this approve erc20 send and we'll give it the token farm contract address as a first input parameter excuse me token farm address and we'll use this input amount as the second parameter and then we'll just have this this use stake tokens return this approve function and then also this state here so it's going to return approve and it's going to return state we could also just have it return this if we wanted but we're going to wrap it just all up in this approved thing here we also probably want to return this state right so we're going to turn this into hook as well so we're gonna do const state set state equals oops use state and we'll have this be the approved or the approved erc 20 state as the input and of course since we're using use state we're going to grab this from react as well we also want to return the state so we'll return this approve erc20 state here so now we have a way to actually do all this so in our stake form what we're going to have is we're going to create const that's going to grab those two variables so we'll do const approve and approve erc20 state is going to be equal to use stake tokens with that token address pulled down from the token as the input parameter and this is our new hook so we're going to import use stake tokens from dot dot slash dot dot slash hooks now that we have these two functions we have the approve function and then we have the state of that function now we can add a handle submit functionality for our button here so now we can say okay on click when we click this button we're gonna do a handle stake submit right because this is that our big well it's not gonna show up now because i broke everything but this is our big button right this is our this is our stake button so we're going to create this function called handle stake submit let's go ahead and do const handle stake submit this will be a function and what it's going to do is we'll get this amount here so we'll do const amount which we're going to actually have to convert it from string to way so we'll call it amount as way we'll do equals utils.parse ether we'll grab parse ether we'll grab utils again from ethers utils from ethers and we'll do the amount dot 2 string so we're going to grab this amount this statehook amount here we'll turn it into a string and then what we can do is we can return this approve function with this amount as way okay oh and then we're getting a fail to compile so in our hooks section we're just gonna do an index.typescript and we're gonna export this use stake so we'll do export use stake tokens from dot slash use stake tokens close that we'll restart the server and then i should import this from the right place and i should import this from the right place as well and let's get rid of the brackets here whoops sorry and let's do this as a dot to string oops because you can't do a big number now let's save it'll recompile we'll pop into our front end here we'll do a refresh our stuff is up that's cool our stuff is getting logged out now if we hit stake we should call the approve function here metamask pops up we do get allow localhost to spend your dap this is amazing we're gonna reject this for now though because or don't want to bother testing it so amazing job getting this far we're hitting a button metamask is popping up and we're doing it we're actually sending a transaction this is incredibly exciting great work so far let's keep going uh the approve function is working perfectly it's working as intended or we're just we're kind of assuming it's working as intended but that's great this is perfect so now we've got to go one step further we need to have this call stake after it's been approved this is where we're going to do a little something called use effect we can import in here just to use effect comma what use effect does it allows us to do something if some variable has changed so the way that we're going to do that is we're going to say okay use effect and it takes one of these functions as an input and then we'll do a little comma here and similar to those state hooks we'll do an array of different things we want to track and if anything in this array changes we'll kick off this use effect and we'll do something in here so one of these things that we definitely want to track is this approved erc20 state if approved erc20 state if this transaction comes back successful then we want to do some stuff so we'll say we'll track this this state and we'll go ahead and say if approve erc20 state dot status equals success then we're going to go ahead and do like a stake function and to do a state function we're going to follow this exact same methodology that we did for the approve so first we're going to use this use contract function thing so we'll do const send is going to be stake send and then state will be stake state this is going to be equal to again we're going to use use contract function this is going to be on our token farm contract this is going to be our stake tokens function and this will be trans action name it's just going to be stake tokens and that's it so let's make this look a little bit more readable here lovely so we have our little used contract bit here and now this stake send we can just call this right in this approve erc20 dot state does status we need to do stake send and if we look back in our token farm if we do stake tokens we have an amount and a token address so that's what we're going to have to put in here we have to put some amount and then token address will just be token address where do we actually get this amount from well when we originally called this approved function this is when we should actually do it and you might be asking hey how come we wrapped this approve your c20 into a function here but we're not going to do that here i'll tell you why in just a second so what we're going to have is we're going to have a state hook for how much we want to actually stake so we'll do const amount to stake and set amount to stake it's going to be equal to use state and we're going to start with zero we're just going to get this defaulted right to zero and what we're going to do actually is once we call this approve function the first time we're going to set amount to stake to be this amount and what we should do instead of calling this approve is we should call this approve and stake since it's this function that's going to kick off yes it's going to kick off our approve erc20 but it's also going to change the amount that we're going to stake and later on once the transaction succeeds it will also then kick off our steak send or our staking function so we're going to change this to a proven stake that means below we have to actually return a proven stake and not just approve and for stake send the amount is going to be this amount to stake which we got from our original proven stake and then we just have to change this to approve and stake and we'll change this from improve to approve and stake and realistically that's all we really need to do here so if we save we go back to our front end let's go to one of these that i actually have some of i'll type in one for in here i'll hit the stake button and what should happen is approve will come up i'll confirm and once this actually confirms then i'll be able to another transaction should pop up telling us to actually stake and that's exactly what happens here so we've approved now we can stake we'll even watch metamask really really quick here i'm doing this on coven right i just called this state tokens function for those of you doing this on ganache will be a lot quicker but perfect that was fantastic our balance even got deducted by one now we have one of these tokens actually staked and this is fantastic however there's obviously a couple issues here right what was happening during that that whole section right there is there was no indication for us of what was really going on got no notifications we're totally left in the dark here additionally this page still looks disgusting so we want to clean this up we want to make this look a lot nicer so how can we actually do this so for switching between these we want to actually just change our use effect here so we do want to check let's approve erc20 state but we also want to see if we switch the token address we want to just check to see if approve vrc20 is done if we switch our token address and we also want to just check to see this if amount to stake actually changes so if we do amount to stake we want to check kind of during all these these three if any of these three changes we'll just do a quick check hey is the prove vrc20 done if yes great then we'll we'll stake some tokens so this is great but we're going to want to get some notifications that these transactions are going through these transactions are pending and these transactions finish so why do we actually add those pieces to this well used app has this thing called use notifications this notifications bit will help us actually get notified on whether or not our transactions are completing so to use these notifications we're going to do a couple of different things in here first all the way back in our app.tsx we're actually going to change our config here we're going to add some notifications in here to check periodically if our things are done and there's a couple of different parameters there's a x variation period and then we'll set it to be 1000 this is in milliseconds so we'll set it to be a thousand which is just one second and we'll do a check interval also of one thousand so basically we're saying hey every second check the blockchain on our transactions that we send please thank you and now that we have this notifications bit identified in our staking form we can add this bit so from used up decor we'll do comma use notifications and now we can actually start using some of these notifications so right here at the top we'll do const notifications equals use notifications we can actually start working with some of these notifications now we're going to want to see if anything in any of these notifications actually change and if these notifications change we're going to want to do something so since we're going to want to check to see if this if notification changes those who have been following along with what i've been explaining for use effect you know that means we're going to want to use a use effect we're going to say use effect it's going to be this function and if we don't have it imported let's go ahead and import this from react let's use effect we're going to be looking to see if these notifications change we're going to be looking to see if our transaction has completed so in our little watching array here we're going to say let's watch the notifications here let's make sure if any of those notifications changes if anything in our meta mask changes we're going to want to do something right so we're going to say if there are any notifications that are approved erc20 or transaction succeeded we want to show hey you know good job it's been approved so to do this we're going to say if notifications dot filter all right this is going to be a function based off the notification on this notification we're going to say notification.type it's going to be transaction dot succeeded succeed and that notification dot transaction name then this is why we need to give them names before in our use state it's going to be approve erc20 transfer dot length is greater than zero then we're going to do some stuff our transaction succeed so we're saying if in these notifications we're going to filter on a notification if the type is transaction succeeded and the name is approved erc20 transfer then we're going to do some stuff and for now we're just going to do console.log approved we can also then do the same thing for if notifications dot filter author on the notification notification dot type if that notification to type is going to be again that transaction succeed and notification dot transaction name equals stake tokens capital t stake tokens there are more than one dot length is greater than zero then we'll do console.log tokens staked okay so we've got some notifications put in we're gonna do a little console logging let's see if our use effect stuff is actually gonna work so let's go to our front end we'll do a quick refresh we'll go to where we have some tokens i'm gonna type one in here i'm gonna hit stake i'm gonna hit confirm and we're gonna wait a little bit and if this confirms correctly then we're gonna see a little console.log printout that says approved and we do indeed and that's perfect metamask pops up again for our stake tokens we hit approve there as well and we should see a little console.log out here for state token staked and we do perfect so now we have a way to actually track some of these notifications and track what actually happens on the blockchain console.logging stuff is great but we want to actually see it in our ui here what we're going to want to do is show a little waiting thing here while we're waiting for it to be approved and then she'll pop up when it actually does get approved we can add a little constant called is mining which will be based off of whether or not the transactions are approved so we'll do const is mining and this will be equal to the state of these transactions so this should actually instead be approved erc20 there should be approve and stake erc20 state now we'll say oops now we'll say is mining will be equal to approve and stake erc20 state dot status equals equals equals mining should probably have it look like this then back in our use stake instead of approve your c20 i'm going to change this to approve and stake your c20 state and then we're also going to return prove and stake erc20 stake let's make this make a little bit more sense here get that little red line to go away and now what we can do with this is mining thing is we can add this to our button now we have this is mining thing it's gonna be based off of whether or not approve and stake are done so we can scroll down to our button and we can add a little disabled flag so we'll say disabled equals it'll be equal to dependent on whether or not it's done we'll just add is mining and if this is true then disabled will be true and if this isn't mining then this will be false we can also add this to be kind of like a little loading thing so instead of just saying stake all the time we'll do a tertiary operator we'll say if it is mining then we'll do like a little loading thing material ui has this thing called circular progress that we can use it's like a little loading thing so we can do if it is mining we'll do a circular progress we'll say the size is 26 or whatever we want it to be we'll close the tag out and if it's not mining again we'll do this stake with a bunch of exclamation marks here so now if we save that go to our front end it looks like i need to fix something can't find name approve your c20 state that's because we changed it this is now a proven stake er20 state so let's change it to that now let's save go back to the front end and okay cool let's go to one of these that we have some stuff with we have a little dial we'll do one here we'll hit stake and if we did this right this should show a little loading thing while the transaction is going through so we're gonna hit approve and perfect we do see a little loading thing and it should stay like this until the transaction finishes this is a good way to indicate to the user that we've actually approved now i'll hit confirm for staking so we didn't actually see the loading thing go back up again so this probably means that we didn't actually reload this is mining correctly and the reason we don't see the little spinny thing is because this a proven stake erc20 state is really only tracking the approve right we have our cost a proven stake which does all this good stuff here but our staking part this stake state we actually never use right and we need to pass this back to our our stake form so it can actually know you know what's going on so what we can do is we can add a new state hook we'll do const we'll just call this one state and then we'll do set state it's going to be equal to use state and this will be that approve in stake ear c20 state we'll start it off there and this will represent kind of the overall state right for this will be the true proven stake ear c20 state what we're going to do now is we're going to have to track those both of those states we're going to track both the proving and the staking so we're going to do use effect and we're going to track both of those with our little our little wonderful use effect stuff so we're going to track them with by doing of course proven stake erc20 state and then stake state so if either one of these change now we're going to want to change this overall state function and that is going to get pushed back to our our stake form here so what we're going to say is we're going to say if proven stake erc20 state dot status equals equals equals success then we're going to set state to be the stake state otherwise we're going to set this overall state we're going to do set state to be this approve and stake bit or just or really just kind of approve here now we're going to pass this just kind of overall state variable here to our front end like this excuse me to our stake form and in our stake form we're just going to say we're just going to map this state variable to the proven stake erc20 state we'll save here that should work perfectly great now if we go back to our front end we'll go to die or whatever we'll do one we'll hit stake metamask will pop up we'll confirm we do indeed get this little loading thing which is perfect once it's done once it's approved we'll confirm again and we get loading again and this is perfect this is exactly what we want because now the user has a good idea ah okay i need to wait right the transaction is going through the transaction is being built and once it's done it's all set so this is fantastic we now have basically all the functionality for staking right we have a proof we have it doing some waiting we have it actually staking let's clean this up a little bit right let's make this look a little bit nicer so first we're gonna go to index.css we're gonna we're gonna add some bits in here for a body we're just going to do background color we're going to set this to set a background color to hsl we'll do 227 comma 61 percent 26 there's a whole bunch of tools the background color doesn't really matter but we'll save we'll refresh our front end and we'll get a nice little uh background color here which is cool but let's actually be even more creative than just this let's do a nice little linear gradient in here we'll just get rid of this actually we'll do background do lin ear gradient we'll do 135 right here do hsl 227 61 percent comma 13 percent then we'll do hsl 227 61 26 we'll do one more we'll do hsl again this will be 227 61 39 for some colors in here semicolon there let's look at our front and k we're getting somewhere we got some cool double gradients going on in here we'll go to our main section here and we'll do that use styles bits again so right in our looks like we don't have any material ui in here so we'll do a little import make styles from at material dash ui dash core and right at the top we'll do const use styles equals make styles some theme which we're ignoring nice little function thing here let's then for our titles in here we'll do a little make the color be theme dot palette dot common dot white which again we're ignoring theme but if we did everything we would do like that we'll do text align center do some padding theme.spacing4 and then our main of course we'll just add this in here const classes equals use styles and then we'll just put like a little little section in here do an h2 or class name it's going to be equal to classes.title and we'll just call this dap token app we'll go back to the front end we got like a nice little deck token dap token app nice white right at the top that looks good we'll go to our your wallet component we'll add some styles in here looks like we don't have any styles in here so we'll do the same thing we'll grab make styles in here do a little const use styles equals make styles a theme that we're going to ignore some fun little function syntax stuff here we'll say tab content give this some styling we'll say all the tab content stuff we'll have display of flex flex direct sean will be column align items in the center and then we'll do a gap for this which will be theme.spacing04 give our boxes some stuff so we'll say box we'll say background color is going to be white we'll say border radius it's going to be 25 px to give it some roundness here then we'll also do a header which we'll just do color of white we're going to grab tab content scroll down this is going to be inside this little tab panel bit here this div it's gonna have class name equals classes dot tab content oops we gotta add classes in here right before the return so do const classes equals that use styles we'll say this box well it's not we're not going to do the overarching box this could actually just be this if we wanted to we'll just say it's this first box so this will be class name equals classes dot box and then our h1 is going to be class name equals classes.header let's save it and let's take a look whoa this is already starting to look a lot better now as you guys can kind of see the functionality is really the important part behind the application and doing a lot of this use style stuff is what's really going to make it look a lot prettier right so if you're like hey how do i do this pretty stuff now i know i didn't really explain what any of this pretty prettiness was doing there's a ton of tutorials on doing css that's basically what this is that you guys can learn a little bit more to make your stuff look pretty now it looks like for the most part we have everything that we need to stay i know we have the spinning wheel which is great but let's also add a little bit of an alert at the bottom to say hey your transaction has gone through successfully so what we're going to do is we're going to pop back over to our stake form we're going to wrap our input and our button into their own little div here right and that is going to put a little bit of space actually between our little component here and some other stuff which is kind of nice but what we're going to do is the reason that we're doing this is so that we can add some alerts this section down here is where we're going to add some alerting to do that we're going to use what's called a snack bar and alerts from material ui you can look at both of these in the documentation provides a brief message about app processes and something like this like we're just going to say hey you did it transactions has come through so what we're going to do is we're going to import snack bar from material ui so we're going to do comma snack bar we're also going to import alerting like a little alert box import alert from at material ui lab slash alert and what this is going to do is it's also going to make these alerts basically down below our button and our input we're going to do a little little snack bar in here snack bar and we're going to say this is going to open when we want to show that the erc20 is done which we're not exactly sure how to do that quite yet we'll have it auto hide auto hide duration it's gonna be equal to about five seconds or five thousand milliseconds and then on close we're also going to do some stuff inside this little snack bar yes i know we haven't filled this out yet actually let's just do this for now having blanks for now inside the snack bar we're going to have some alerts where we say on close we're also going to do some stuff severity is going to be success and this alert is what's going to have our text in here so we'll say erc 20 token transfer approved now approve the second transaction and we're going to have two of these little snack bars one is gonna be for the erc20 and one is going to be for staking token so we're going to call this one token staked or excuse me tokens staked now we need to define when these open and also when they close and what to do when they close so this erc20 thing should pop up when erc20 has been approved so we're going to want to create some variable that's going to track whether or not it's actually been approved so we'll create another state hook here we'll do const show erc20 approval success comma set show erc20 approval success this is going to be equal to use state and we're going to start with false right we don't want to show this thing right away and then we're going to want to do the same thing for staking tokens so we'll do const show stake token success and then set stake token success and this will be also used and we will start this out with false and what we're going to do is right now we're doing this console.login here right and this is cute but we want to actually turn this into changing show erc20 approval success right so when this actually goes through when notification says hey it's been approved we want to say okay great show that approval status so instead of doing console.log here we're going to say set show your c 20 approval success to true and then we're also going to set show stake token success tokens success to false i hopefully i'm spelling this right set show stake token success and let's make sure that's spelled right great and then we're going to do the same thing but the opposite for staking token so get rid of console.log we'll do set show erc 20 approval success to false and set show stake erc20 to true now we'll say the erc21 is going to open and now we can also have this notifications thing track these two if these ever change we'll also run through this so we'll grab both of these in here so this use effect will now track these as well and we'll say show erc20 approval status will open up the erc20 alert and then the show state token success will open up the state tokens alert and then for both of these we'll add a new function called handle close snack which will just close it out and turn those variables that we just made to false so we'll do const handle close snack this will be a function and we'll just say set show erc20 approval status to false and then set show stake token i'm just going to copy paste it this one also to false awesome now if we go back we refresh our front ends here looks like i forgot to do an on close ah okay yep we'll do handle on closed snack here for the alerts as well and there are no tags there there are no brackets there so i've got to change that but now if we go to our front end we'll do a quick refresh we see everything in here looking great let's add one in here we'll hit stake this will pop up we'll confirm we'll get the little progress bar which is exactly what we want and you see here now we get this little popup it says erc20 token transfer approved now approve the second transaction this should uh go away after a few seconds or not let's just approve this second one oh looks like it now went away so maybe it was a little bit longer than five seconds and now we can see the token stake popped up perfect so we have some popups we have a little bit of ways to show the user how to do everything now you'll notice this doesn't look exactly like what we see in the github repo right and this github repo looks a little bit different it's got this little slidey bar it's got this second token farm contract for unstaking however a lot of what we're going to keep doing is just going to be a lot of more frontend stuff and at this point you pretty much should have everything that you need to build the rest of the contract so what we're going to do is we're going to have the rest of this be a challenge if you want if you would like to complete it you can absolutely add this second tokenfarb contract with this unstake all weth bit or unstay golf fau dap etc we're going to have two versions of this front end in here we're going to have kind of this more cleaned up version and then we're going to have a little bit more raw version this one's the the more raw version all the code is going to be there so if you want to say i don't really want to code and follow this along you can just copy paste the code or you can say you know what i'm going to do this unstaking part all myself and that will be awesome also fantastic you should be incredibly proud of yourself because at the end of the day at this point you have a way to stake tokens into a smart contract and build a front end which is absolutely massive absolutely fantastic you should be patting yourself in the back excellent job excellent job let's go ahead and wrap this course up welcome back friends how do you feel good smarter empowered ready to take on the world excellent well you absolutely 100 should be and you deserve a massive round of applause because you have just done something fantastic you have started your journey and equipped yourself with the tools to become an incredibly powerful intelligent smart contract engineer in the space now i would be remiss if i didn't comment on security and audits when it comes to doing your smart contracts as you know all these smart contracts are available on chain for anybody to see and anybody to work with this means that having a security mindset is incredibly incredibly important and i highly recommend if you're going to go maintenance if you're going to take your application onto a real network where it's going to be securing a lot of people's money and a lot of people's assets you absolutely need to get an audit there is no excuse for not getting an audit and having an application that's securing a lot of people's money getting an audit is essentially just having somebody else peer review your code looking for any vulnerabilities that could be exploited an audit can be the difference between your protocol skyrocketing into the future and doing fantastically successfully or dwindling getting hacked and everyone losing faith in your abilities audits are essential we've got some helpful links in the github repository associated with this course to learn more about audits who to get them from and some helpful tips on setting your smart contracts up to make auditors lives easier while we're talking about security it's also helpful to know some of the most common attacks in this space we've got another wonderful link in the github repository that will show you some of these attacks and how to get around them and what they actually look like two of them that are big enough that i think i need to mention here are going to be oracle attacks and reentrancy attacks these are the two attacks that i see happen most often unfortunately right now in the state of d5 protocols get hacked for millions of dollars literally almost every day and it is a travesty to the space that this is happening most of the time these attacks are preventable so understanding some of these security tips doing your due diligence and getting an audit is going to make both you as a smart contract developer and as adapt developer and as a protocol better but also the entire space is going to be more safe secure and easier for newcomers to get into thankfully you can sleep a lot easier on those oracle manipulation attacks because you've learned some best practices for working with oracle's you've learned how to work with a chainlink decentralized oracle network to get your data and do your external computation using a chainlink decentralized oracle network or a dawn will solve these oracle manipulation attacks so that you don't have to deal with people manipulating a centralized oracle because you are going to be using a decentralized one reentrancy attacks are a little bit trickier to detect but whenever you call an external smart contract a smart contract outside your project you especially should think hm does somebody in that smart contract have access to changing some variables that i don't want them to change again we have some wonderful examples in that github repository associated with this course to teach you more about that additionally i highly recommend everybody check out both ethernet and damn vulnerable defy these are two games that show you some of the exploits and some of the lowlevel solidity things you can do that you might want to look out for when you're writing your smart contracts all right so now that we've got the security piece out of the way once again huge congratulations for getting this far you now have the tools to build a better world to build these smart contract applications and to empower yourself and your community with these blockchain applications now the first question you might be asking is patrick this is great but where do i go now what do i do i have all these tools i want to go use them absolutely my first bit of advice here is going to say you can always learn more and there's always going to be more places to learn and grow and even though this course gave you a full setup of everything that you're going to need to get going and get off the races and start building it's good to know where else you can learn more and where else you can grow some amazing places are going to be crypto zombies dapp university ivan on tech chain shop eat the blocks patrick collins my youtube channel austin griffith's youtube channel nader's youtube channel the ethereum.org website chain link blogs and really any other material you can get your hands on while you're learning you should 100 be growing with the community this is something that i've been pushing from the start blockchain and smart contract world is different from these corporate worlds we are a decentralized open source group open source open source ecosystem where we flourish if the people around us flourish so growing and connecting with the community is a absolute must and is eight and it's a way to really accelerate all the momentum that you're getting after taking this course twitter the reddit brownie discord the ethereum discord the chain link discord there are all these discords in all these communities that you can jump in you can grow ask questions chat spread ideas then once you're in these communities then you can start really coding and tinkering more hackathons are some of the best places to put your stuff to the test and also really learn and build and grow in the blockchain space there are hackathons happening all the time and these are places where you can show up you can learn from some of the sponsors you can build really cool things and you can win prizes as well we've seen some projects win a hackathon go on to raise millions in seed funding and become a billion dollar protocol some have gotten advisors from top investors like mark cuban and these products do wildly successful but at the same time we also see a huge uptick in a huge number of the newcomers in this space people have never written a smart contract never written any of the code come in try learn grow and come out an incredibly powerful engineer with more networking and with more people around them who they know they can lean on and talk to in this community so whether or not you want to win a hackbond doesn't really matter hackathons are a great place to sharpen your coding skills get better meet some people maybe win some prizes and a lot of these decentralized products do look at the hackathon winners looking for some talent to pick up for their teams a lot of the engineers that i work with right now i work with them because they got picked up from a hackathon so hackathons are great places to go eat global eath india eath global eth india and the chain like hackathon are some of the best hackathons in the business so be sure to check those out all these decentralized protocols have a ton of work that people can be doing to help grow their protocol in some way and they all have community grant projects where people can come in propose some grant propose something to the community and that person builds it out so if you have an idea on how to improve one of these decentralized applications you can go ahead propose what you want to improve and if you get approved you could be awarded a grant to work on that as well you can become a smart contract consultant here you can start offering your services to people who are looking for really strong solidity and smart contract developers you can start reaching out to some of these projects now that you have these skills you can start reaching out to other people saying hey i've got a great idea of something i want to build and i'm looking to take it to the next level and that's the most important piece of advice i have for you here just build just have a good time and build things that you enjoy building you'll learn the most the fastest by building tinkering and trying new things and this is also one of the best ways to meet people in the industry everybody that i work with in my life in this space i work with them because i was building something and we became close because we were working on the same things i feel incredibly lucky to have met and interact with so many fantastic people in this space and i hope that one day i'll get to meet and interact with you too so good luck to you all and let's rebuild this world let's make a world where there's more economic opportunity there's more equality and let's rebuild some of this institutional trust while having an absolute blast in this wild west that is cryptocurrency smart contracts and blockchain like i said i hope to meet you all one day and just do me a favor and make today an amazing day take care everybody
