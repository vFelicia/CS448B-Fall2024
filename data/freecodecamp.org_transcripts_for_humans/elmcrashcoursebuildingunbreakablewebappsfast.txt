With timestamps:

00:00 - hello my name is mario um
00:02 - and i'm going to be doing a
00:04 - maybe a non-conventional crash course
00:06 - for you in elm uh i work at travelport
00:09 - locomote um travelport is one of the
00:12 - three major gds's in the world hands up
00:14 - if you've ever taken a flight before
00:16 - anywhere one in three chance we sold you
00:18 - that flight uh locomote what we do is we
00:21 - do corporate travel
00:22 - so those of you that work at a big
00:24 - corporate
00:26 - awesome come and talk to me later we
00:27 - have a great product for you
00:29 - but yeah we do corporate travel
00:30 - management and um we've been acquired by
00:32 - travelport so as you can probably tell
00:34 - by the accent i'm not
00:36 - english british um i come from australia
00:40 - and our company was started in melbourne
00:43 - but with the acquisition i now live and
00:45 - work in london
00:47 - you can find me on github my handle is
00:48 - super mario that is my actual real
00:50 - handle
00:52 - so
00:53 - the
00:55 - goals for what i'm going to do tonight i
00:57 - was originally thinking of doing um the
00:59 - same format that we do at the elm london
01:01 - meetups um which is to actually do a
01:03 - code night you pull out your laptops you
01:04 - actually work on stuff people get in
01:05 - different groups
01:07 - either you're going from scratch and i'm
01:08 - doing a from scratch tutorial or you're
01:11 - working on projects or you might be
01:12 - advanced and helping with open source
01:14 - stuff
01:14 - but i thought given that i've got a room
01:17 - of presumably javascript and react
01:19 - experience developers
01:22 - the more that i thought about it the
01:24 - more i thought about
01:25 - my own journey into discovering kind of
01:26 - element functional programming and the
01:28 - things that prevented me from
01:29 - understanding
01:30 - the
01:31 - value of those things to myself and what
01:33 - they would give me in my kind of
01:35 - day-to-day work and i thought it might
01:37 - be more valuable if i gave you a swathe
01:39 - of those kind of things because i found
01:41 - those really hard to find online i mean
01:43 - you control through lots of blog posts
01:45 - and things and try and scrape things
01:46 - together but until you've really kind of
01:48 - tasted
01:49 - um element functional programming for
01:51 - yourself it's really hard to understand
01:52 - some of those concepts so i wanted to
01:54 - maybe instead give you a little bit of a
01:56 - teaser of those things that you might
01:57 - not find so easily and then give you the
02:00 - resources of which there are plenty of
02:01 - for you to just learn like elm syntax
02:03 - and stuff so i'm going to try and cover
02:05 - things that might not be obvious i'm
02:06 - still going to go through a little bit
02:07 - of alum so you've got a bit of grounding
02:09 - but i'm going to talk about some awesome
02:10 - things that um
02:12 - that exist in the elm community that may
02:13 - not be obvious straight away i'll talk
02:15 - about some pitfalls and then i'll give
02:17 - you some references for more stuff
02:19 - um cool so
02:23 - this is an lmap
02:25 - that you're currently looking at some of
02:26 - you're still joining
02:27 - so let's just start really easy how are
02:29 - you feeling
02:31 - everyone's feeling good hopefully
02:33 - awesome
02:34 - uh
02:35 - no one's feeling bad that's great
02:37 - javascript experience
02:39 - zero starting confident or pro pro
02:42 - meaning you work in javascript
02:43 - professionally
02:49 - okay so we've got some people that are
02:51 - zero some people that are starting this
02:53 - is going to be awesome for you for the
02:54 - rest of you you've got prior knowledge
02:56 - that's going to hold you back
02:57 - i'm just kidding
02:59 - elm experience um has
03:01 - how has your elm experience been in
03:03 - terms of exposure or reading or anything
03:07 - awesome we have some elm developers here
03:10 - most of you zero okay great so um
03:13 - hopefully for those of you that are zero
03:14 - this will be
03:15 - informative and useful and help you
03:17 - understand one is elm something that
03:19 - you're interested investing your time in
03:21 - and secondly what it might
03:24 - give you generally
03:26 - okay cool so
03:28 - normally what happens sorry
03:31 - normally what happens with this is um i
03:33 - go through a set of live slides
03:35 - and you've got on your devices a set of
03:36 - reactions so you can give me like you're
03:38 - okay or you're confused thumbs up thumbs
03:41 - down thinking face falling asleep
03:44 - or bookmarks and then at the end of the
03:46 - talk
03:47 - you can put your email address in and
03:48 - get all that stuff back sounds really
03:50 - awesome except i'm not going to give it
03:51 - to you um because i didn't get to
03:53 - prepare these slides in the software so
03:55 - we're not going to use this i'm going to
03:56 - step out of it
03:57 - but this is more just to give you an
03:58 - idea that this is an app that i've used
04:01 - in in past talks um if you look at the
04:03 - elm europe conference you can see me
04:04 - doing it live on stage engaging the
04:05 - whole audience
04:06 - and it's something that i've tried for a
04:08 - number of years to build in lots of
04:10 - other things and i always kind of got to
04:12 - the point where i just couldn't keep
04:13 - pushing further the complexity in
04:15 - whatever language i worked in really
04:16 - really held me back
04:18 - and i think this is probably my best
04:19 - testament for myself personally
04:21 - of
04:22 - what elm can give you as a developer
04:25 - because it's the first time i've
04:26 - actually been able to succeed with a
04:27 - project of this kind of scale so anyway
04:29 - let's uh let's run through uh
04:32 - the president you can come talk to me
04:34 - afterwards if you want to know more
04:35 - about the elm app software so i'm going
04:38 - to avoid these things today
04:41 - because i think that there's better
04:42 - resources than me speaking to you for
04:44 - finding that stuff um so learning
04:45 - detailed syntax um fp concepts as a
04:48 - whole um and looking at comprehensive
04:50 - code examples it's probably better off
04:52 - in your own time and at your own pace so
04:53 - i'm going to avoid that kind of stuff
04:55 - but i will give you
04:56 - um
04:58 - things that you can
05:00 - look at afterwards for diving into more
05:02 - detail on those things so what i am
05:04 - going to go through is i'm going to give
05:05 - you a high level of what is elm i'm
05:07 - going to try and disambiguate some stuff
05:09 - that
05:10 - in my opinion i feel you might run into
05:12 - if you try and learn it yourself
05:15 - we'll run through some code but at a
05:16 - very basic level
05:18 - and i'm going to run through the elm
05:19 - architecture which i think is probably
05:20 - one of the big tripping points that
05:22 - people run into
05:23 - you know this question of is ellen the
05:25 - library is it a language
05:27 - and and trying to figure out what it
05:28 - actually does and how you do things i'm
05:30 - going to try to talk through some some
05:32 - awesome things at least as far as i find
05:34 - them
05:35 - roughly talk about how do i use element
05:37 - work which may be an interest point to
05:38 - some of you and then i'll give you some
05:40 - caveats
05:41 - that i found for myself personally
05:44 - awesome
05:45 - okay what is ellen
05:47 - so by its own admission this is on the
05:49 - top of the elm site elm is a delightful
05:51 - language for reliable web apps
05:53 - you can generate javascript with great
05:55 - performance and no
05:56 - runtime exceptions that's almost
05:58 - guaranteed
06:01 - so in more detail it's a functional
06:02 - language it's statically typed but it
06:05 - has type inference so if you don't want
06:07 - to write types you cannot
06:09 - and elm will still figure out the types
06:11 - view up until a point
06:13 - all data is immutable so there is no
06:15 - such thing as immutable
06:17 - value or reference or object in elm
06:20 - everything's immutable by default
06:22 - that's part of the language you can't
06:24 - opt out of that
06:25 - all functions are pure which means that
06:28 - every piece of code that you ever look
06:30 - at in elm
06:31 - the answer to the question of what does
06:32 - this code do the answer is nothing
06:35 - it takes inputs and it returns a value
06:37 - but it won't make any effects it won't
06:39 - change anything in the outside world it
06:41 - won't ask the outside world of anything
06:43 - it will literally do nothing so every
06:45 - line of code in any lm code base you
06:47 - ever look at has these two guarantees um
06:50 - null undefined and exceptions don't
06:52 - exist they're not part of the platform
06:54 - they're not part of the language you
06:56 - can't type null and have it compile
06:59 - and nothing within your elm code can
07:02 - throw an exception or give you back a
07:04 - null so those kind of things are removed
07:06 - from the language um so the these are
07:08 - all rather intentional choices and they
07:10 - have some really really interesting
07:11 - implications when you when you don't
07:13 - have these kind of things in your or
07:14 - rather when you have these kind of
07:15 - guarantees in your language um it
07:17 - actually comes out to be a very very
07:19 - interesting subset of
07:21 - um of the kind of programming that you
07:23 - may be experienced in already
07:26 - so to answer the question
07:28 - of exactly elm library this kind of gets
07:32 - confusing when you start looking at um
07:34 - stuff online
07:35 - if you're familiar with i mean how many
07:37 - of you using this kind of stack or
07:38 - something loosely related to this yeah
07:41 - cool
07:42 - so you know you get really excited you
07:43 - want to start with javascript like right
07:44 - how do you install packages oh you can't
07:46 - you gotta get npm right okay now i have
07:49 - npm like how do i bundle stuff together
07:50 - like you can't you gotta get webpack
07:52 - cool and then you know react at the
07:54 - moment you're all here because this is
07:55 - reactivate but this is you know a more
07:58 - recent paradigm before there used to be
07:59 - many other choices and spine and
08:01 - backbone and um you know more modernly i
08:04 - guess angular as a competitor but
08:06 - there's a lot of different options there
08:07 - so you have to pick one maybe you pick
08:08 - react
08:09 - then eventually you get to a point where
08:11 - you've got too much local state and your
08:12 - components are trying to send stuff
08:13 - everywhere and you're like ah how to
08:15 - solve this problem and you go oh redux
08:16 - so you learn redux you bring that in
08:19 - now you've got this problem where you
08:20 - know you add a new action in redux and
08:23 - now you don't know all the parts in your
08:24 - code that need to be updated so maybe
08:25 - you get something like typescript to
08:27 - flow to bring some level of kind of
08:29 - checking to figure out i've added stuff
08:31 - here and now my code breaks over here so
08:33 - you kind of bring that into the language
08:35 - then you get to the point where you're
08:36 - like oh you know mutable references are
08:37 - really killing us we're passing objects
08:39 - and accidentally setting methods on them
08:41 - and losing control of our state so you
08:43 - go well maybe we need to bring immutable
08:45 - js into
08:48 - a stack
08:49 - so what's the experience like when you
08:51 - start elm
08:52 - well you go well how do i get packages
08:56 - well that's built into elm yeah cool so
08:58 - how do i get all my files compiled into
09:00 - a single version that's built into elm
09:02 - you go okay so how do i actually
09:04 - architect my code how do i do the view
09:06 - layer and all that kind of stuff well
09:07 - that's actually built into elm so you go
09:10 - cool so how do i manage my state when it
09:11 - gets really big that's built into elm uh
09:13 - what about type checking and flow that's
09:16 - built into elm and immutability as i
09:18 - mentioned is also built into our so the
09:20 - analogy i've been trying to use recently
09:22 - for this is when people say oh well it
09:23 - can't be a language that has too many
09:25 - features
09:26 - it would probably be i'm assuming um
09:29 - similar to originally when memory
09:31 - management was all manual and you're a c
09:33 - developer and something like javascript
09:35 - came along
09:36 - now like we have automatic memory
09:38 - management now you're like so that's a
09:40 - library you're like no no it's a
09:41 - language feature and like i can't be a
09:44 - language feature like that's too
09:46 - featureful um so this is kind of the
09:48 - same in that same sense so when we say
09:51 - that elm has these things built in it's
09:53 - not built in as a library
09:55 - that you use
09:57 - it is actually the language so there's
09:59 - only one
10:01 - architecture in elm it's called the elm
10:02 - architecture there's only one way to
10:04 - structure on that initial set of code
10:06 - and that's all baked in all the
10:08 - libraries that you build in are for
10:10 - various other bits and bobs around
10:12 - is that making sense
10:14 - getting some nonsense lovely
10:16 - um
10:18 - now it's not all in isolation there is
10:20 - kind of like a lot of cross flow and
10:23 - lots of lots of the stuff that's in
10:25 - that react stack if you're already
10:26 - familiar with it lots of stuff in elm
10:28 - will just seem really really natural um
10:31 - so this is just a quote from the um
10:34 - dan abramov the author of redux
10:37 - who has quoted as pulling certain ideas
10:40 - back from elm so if you use redux you're
10:42 - actually using a
10:44 - subset of the same kind of function that
10:46 - that operates in elm so that kind of
10:48 - stuff will come natural to you um the
10:50 - the difference i feel though is that
10:53 - here you've got a lot of disparate
10:54 - components with lots of different
10:55 - authors different styles and different
10:57 - integration points
10:58 - whereas in elm the whole ecosystem is
11:00 - built around the premise that the call
11:02 - language has these functions so there's
11:04 - a huge amount of effort put into them
11:07 - working together really really really
11:09 - really nicely so a lot of the pain
11:11 - points that you may see on the left hand
11:13 - side when you kind of come over to the
11:14 - elm side um my experience has been those
11:17 - pain points are either way reduced or
11:19 - just non-existent um in that kind of
11:22 - environment so let me let me uh
11:24 - dive a little bit deeper into that
11:26 - side note let's just take a slight
11:29 - detour
11:30 - and then i'll come back
11:32 - um
11:33 - there's a personal bug bear of mine and
11:35 - it uh
11:37 - maybe it won't be the same for all of
11:38 - you but it really impacted my ability to
11:40 - learn functional because when i came up
11:43 - against these two things i was really
11:48 - defensive of my existing experience and
11:51 - a bit insulted that there could possibly
11:53 - be something that i didn't already know
11:55 - in programming
11:56 - so for me it was really humbling having
11:58 - to probably battle through a year worth
12:00 - of self-learning before i got kind of
12:03 - past these concepts and i think that
12:04 - they're needlessly complicated
12:06 - especially has anyone here tried to
12:07 - learn haskell or idris or any other kind
12:10 - of functional languages well i'm hoping
12:12 - your experience is better than mine but
12:13 - you know like
12:15 - space burritos and homomorphisms over
12:17 - funk to monads and it's kind of like the
12:19 - mathematics and the language and the
12:21 - kind of tone of that community is really
12:22 - really are really difficult to approach
12:24 - so i just wanted to kind of debunk two
12:25 - things that hopefully will help you
12:29 - separate hype from understanding a
12:31 - little bit more so two things
12:32 - unbreakable and functional um so what do
12:34 - we what do we mean when we say breakable
12:36 - yes i know it was a bit of a clickbaity
12:39 - title saying building unbreakable
12:40 - software um
12:42 - let me give you two statements first
12:44 - statement being is the sky is green
12:46 - most of you probably think that's wrong
12:49 - but like what if we're riding a computer
12:50 - game you know and maybe the sky is green
12:53 - or what if we're in the northern
12:54 - hemisphere and it's night time so this
12:57 - guy's green for those reasons
12:59 - uh
13:01 - might be wrong might be not like this is
13:02 - this is about semantics right this is
13:04 - what our job as program is
13:06 - is
13:07 - to take models of the real world and
13:09 - understand their semantics and then
13:11 - emulate them in code and we can get that
13:13 - wrong
13:14 - and probably unlikely for quite some
13:16 - time that anything's going to
13:17 - automatically replace that right because
13:19 - that's the thinking and the logic that
13:20 - really matters
13:21 - say for
13:22 - you know our ai overlords in the future
13:26 - uh
13:27 - here's the second statement this guy is
13:28 - uncaught type error cannot read property
13:30 - color of null anonymous
13:35 - this is broken i don't think you would
13:37 - ever want to have this feature
13:40 - i mean unless
13:41 - maybe you were writing like ironic
13:42 - javascript poetry or something but like
13:49 - this distinction wasn't really clear for
13:50 - me until i
13:52 - worked with functional programming
13:53 - because for me this was kind of normal
13:55 - life right like
13:56 - you can't avoid this
13:58 - this is what programming is this happens
14:00 - all the time it's called a bug and you
14:02 - fix it and you kind of move on
14:04 - and the premise of functional was yeah
14:05 - you can like you can just not have these
14:07 - in your life
14:08 - at all
14:09 - um and that kind of
14:10 - i really really struggled with so the
14:12 - reason i struggled with that is because
14:14 - of this definition
14:15 - functional will not save you from
14:17 - semantic incorrectness but it can save
14:19 - you from things that are actually broken
14:22 - we don't necessarily need to have these
14:24 - in a language
14:26 - the second
14:29 - thing um that i wanted to side note on
14:31 - was this whole notion of functional you
14:33 - know people say oh javascript's
14:34 - functional um that's
14:36 - not not true
14:38 - but
14:39 - the premise is that javascript has both
14:41 - functional features and imperative
14:42 - features and in between those two kind
14:45 - of paradigms there are actually some
14:47 - compromises yes you can draw good ideas
14:49 - from both things
14:50 - but ultimately one of the
14:53 - kind of premises of functional is
14:55 - functions and the mathematical sense
14:58 - where functions don't do things if a
14:59 - function does something we then define
15:01 - that as a procedure
15:03 - so
15:04 - straight away the fact that you can take
15:06 - imperative features and sprinkle them
15:07 - anywhere
15:08 - you put yourself in a situation where
15:10 - there's compromises and fp practices
15:12 - really require discipline
15:14 - so this is why
15:15 - you know especially redux is a good
15:17 - example of that people who maybe are new
15:18 - to the react stack and haven't used
15:20 - redux before and drag it in because they
15:22 - think that that's what they need as a
15:24 - baseline
15:25 - and it turns out maybe they don't yet
15:26 - need that now they're doing all these
15:27 - crazy things all over the place and
15:29 - trying to manage all this i'm kind of
15:30 - kind of a boilerplate um for this
15:33 - alleged
15:35 - benefit of fp
15:37 - while simultaneously having the ability
15:39 - to escape hatch and do their imperative
15:41 - stuff and i think you know path of least
15:43 - resistance the temptation is really
15:45 - really hard to do imperative features so
15:46 - i think my experience has been that
15:48 - functional features are really amazing
15:50 - learning them helps you think
15:51 - differently but ultimately wherein
15:52 - you're where you're in a code base
15:54 - especially under commercial pressure or
15:56 - time pressure you're going to compromise
15:58 - and do the imperative things um in a
16:00 - functional language as i define it uh
16:02 - you have functional features and that's
16:04 - it
16:04 - so there is no back door fp practices is
16:07 - the default you can't accidentally
16:08 - mutate stuff you can't accidentally do
16:10 - effects
16:11 - because it's kind of constrained so the
16:12 - premise is not to infantize a developer
16:15 - and say oh you can't manage this stuff
16:17 - but actually to say hey maybe when we
16:19 - don't have certain things here it
16:21 - actually helps us write better code
16:22 - right faster with more confidence and
16:24 - that's true of what i've found in l
16:27 - okay
16:29 - enough talking should i show you some
16:30 - code
16:32 - yeah
16:34 - okay so like i said i'm not going to go
16:36 - into super detailed examples but i'm
16:38 - going to give you a basic counter
16:40 - so that
16:41 - you see a full complete
16:44 - could deploy to production
16:46 - piece of elm code and then i'm going to
16:48 - use that to talk about the elm
16:49 - architecture that's powering things
16:51 - underneath
16:52 - does that make sense
16:53 - cool so i'm going to step through it and
16:55 - i'm really sorry i hope that you can all
16:57 - see
16:58 - um is that okay for everyone or is it
17:00 - struggling
17:03 - half nods okay um so uh at the top of a
17:06 - elm file um
17:08 - simply open a new elm file call it
17:10 - app.elm or whatever you want um we're
17:12 - gonna put module main
17:13 - exposing the syntax for dot dot means
17:16 - that we're exposing everything in this
17:17 - file we could choose to expose only
17:19 - certain functions if we were writing
17:20 - like a little library module but in this
17:22 - case we said wildcard just include
17:24 - everything we're going to import some
17:26 - stuff from the core library
17:28 - i'm going to import two things
17:30 - from the html library i'm going to
17:32 - expose uh four functions remember like i
17:35 - said before they're all functions they
17:36 - don't do anything they return values so
17:38 - beginner program um takes a bunch of
17:40 - parameters and returns a program value
17:42 - that l will run um button div and text
17:45 - are all
17:46 - functions that take a set of arguments
17:49 - for attributes a set of arguments for
17:51 - children and they return a virtual
17:53 - representation of what that markup might
17:55 - be
17:56 - that's all i kind of need and the
17:57 - onclick function will take a message
18:00 - type that i want to trigger and it'll
18:02 - give me a tribute that i can put in an
18:04 - element
18:05 - so
18:06 - in
18:07 - every elm app you'll experience
18:10 - at the basic level we write four things
18:14 - they are the only four things we ever
18:15 - write so once you learn these four
18:17 - things you can approach any lmap and
18:19 - immediately know where to start and what
18:21 - to look for so the four things are our
18:23 - initial model which is our initial state
18:26 - a
18:27 - type we're going to call it message you
18:28 - could call it whatever you want but
18:29 - we're going to call it message this is
18:30 - going to be um so if you know redux this
18:32 - is an action so all the actions that our
18:34 - app supports
18:36 - um we're going to write so they're the
18:37 - two they're the two models or the two
18:40 - two values that we're gonna write and
18:42 - then we're gonna write two functions
18:44 - one is an update function
18:46 - this update function will receive at a
18:48 - given any given point in time a message
18:51 - and the current model
18:53 - and what we need to return back is the
18:55 - new model based on our business logic
18:58 - so all of the business logic for an elm
19:00 - app sits in this function
19:03 - just one place
19:05 - then we've got the view and the view is
19:06 - very similar to what you might ex might
19:08 - have seen in react except here it's
19:10 - explicit it explicitly takes in a model
19:13 - and we will return to markup so let's go
19:14 - and implement that so for the counter
19:16 - we're going to start our counter with a
19:18 - value of zero our whole model is just
19:19 - going to be a single integer our model
19:21 - could be anything it could be a hash
19:23 - type with lots of things in it which is
19:25 - normally what you'd get to in a bigger
19:26 - app but let's just start with um just
19:28 - plain old value um for the message type
19:30 - uh or we want to be able to sorry i
19:33 - didn't actually show you the the button
19:34 - that we're sorry
19:36 - you're going blind uh so this is the
19:38 - this is the app that we're going to
19:39 - build so you can plus plus on the
19:40 - counter minus and we have no guards in
19:43 - our business logic so you can go
19:45 - negative
19:46 - cool
19:48 - okay so
19:52 - if you think about that up in terms of
19:53 - the actions we have we really just have
19:54 - two actions we want the counter to go up
19:56 - we want the counter to go down so we're
19:58 - going to just create two
20:00 - two
20:00 - types here in the message type so
20:02 - message is either going to be increment
20:05 - or it's going to be decrement
20:07 - i'm not going to stress this too much
20:08 - because it takes a little while to
20:10 - kind of learn this concept but
20:13 - you can kind of think of this a bit as
20:14 - an
20:15 - enumeration for now if that makes it a
20:17 - little bit easier
20:18 - or you can note that uh boolean has
20:20 - exactly the same type signature
20:22 - so type boolean is true or false where
20:25 - true and false are the actual values
20:26 - that get passed around you don't really
20:28 - pass around boolean does that make sense
20:29 - so increment and decrement are two
20:31 - actual values they're kind of like
20:32 - labels they're labels that we can pass
20:34 - around and they'll
20:36 - be type checked so we can't put a label
20:38 - that doesn't exist someone that doesn't
20:39 - exist
20:40 - um okay so our update function
20:43 - usually 99 times out of 100 we will
20:46 - start with a case
20:48 - and a case is as you would expect the
20:49 - messages of the message type so we're
20:52 - going to case on increment well if we're
20:54 - incrementing that's the message that we
20:55 - received um we're going to return model
20:57 - plus one if we're decrementing we're
20:59 - going to return model minus one
21:02 - and our view is going to use our
21:04 - functions so
21:08 - let's focus on this middle function
21:09 - first
21:10 - so you can see that the divider has no
21:12 - attributes so putting nothing in the
21:14 - tribute it's just the plain div and as
21:16 - its contents we're putting a text node
21:18 - so that's just a root text node with no
21:20 - wrapping
21:21 - and we're putting a two string of our
21:22 - model so model is an integer two
21:24 - stringed into the text version that's
21:27 - gonna be text node so that's gonna sit
21:28 - in the middle
21:29 - before and after we're creating two
21:30 - buttons the buttons do have attributes
21:32 - one has an attribute of onclick
21:34 - decrement the other one has an attribute
21:36 - of onclick increment
21:37 - and then they have the individual text
21:39 - nodes that they're showing and then
21:41 - those all those values are wrapped in a
21:43 - div
21:44 - that has no attributes and that's what
21:46 - we return back
21:49 - is everyone comfortable that they
21:51 - understand
21:52 - on a high level what this code does
21:54 - syntax aside for a second
21:58 - this is the last line that stitches
22:00 - everything together
22:01 - so elm always looks for an entry point
22:03 - called main
22:05 - and in main we have to give elm a
22:08 - program value so it's a value
22:11 - that describes how our program functions
22:14 - so what we're
22:20 - what we're doing here is
22:22 - we are
22:23 - taking the beginner program which is the
22:26 - the function that we've got from the
22:28 - elmcore library and it takes
22:31 - a hash
22:32 - that has three parameters or three
22:34 - attributes in it a model a view and an
22:37 - update so literally the stuff that we've
22:39 - just written the four things that we've
22:40 - written save for the the message type
22:42 - and we say to um okay well this is what
22:44 - our state looks like here's the initial
22:46 - model take that away lovely um here's
22:48 - the view function that i want you to run
22:51 - for me and whenever there's a new model
22:53 - and here's the update function that i
22:54 - want you to run for me whenever you get
22:56 - a message
22:59 - so the net outcome of that is
23:01 - um this little app
23:04 - and as you can see heading plus is
23:07 - triggering that message
23:09 - minus is pulling it back down
23:11 - um
23:16 - yeah okay any questions at this point
23:22 - more comfortable all right i'm just
23:23 - going to bang on the point a little bit
23:25 - um so that view function that we wrote
23:27 - takes a model and it returns something a
23:29 - value called html in elm it is an actual
23:32 - html similar to the way that react does
23:34 - it because ellen has a virtual dom
23:36 - implementation so it's efficiently
23:38 - checking for changes and things like
23:39 - that and managing the dom for us we
23:41 - don't go anywhere near the dom we just
23:42 - tell elem well here's what a markup
23:44 - should look like for that state you gave
23:46 - me
23:47 - so that's that's always a new set of
23:49 - html
23:51 - the update model works similarly it gets
23:52 - a message in the current model
23:54 - we do whatever logic we want make
23:56 - whatever changes we want to a new model
23:58 - and we give a new model back we can't
24:00 - mutate that old model
24:03 - so
24:05 - i'm going to try and visualize it again
24:06 - in another way and hopefully just just
24:08 - really syncs it in so here's our home
24:10 - runtime which we don't control the l
24:12 - runtime happens outside of our control
24:14 - we simply gave it our initial model we
24:17 - gave it our update function we gave it
24:18 - our view um so now we've compiled that
24:21 - we've booted up our javascript in the
24:22 - browser and our app is running so we've
24:25 - clicked
24:26 - a button
24:27 - which has fired one of our
24:29 - messages and remember that markup can
24:32 - only have the messages that we defined
24:33 - in our app if we typed any other kind of
24:35 - message there that was unhandled that
24:37 - would fail at compile time
24:38 - so the browser is going to give us a
24:40 - message type and it's guaranteed that
24:42 - that's going to be a message type we
24:42 - know about
24:44 - so the runtime is immediately going to
24:45 - do two things
24:46 - first it's going to send that uh
24:49 - to the update function call update
24:50 - function and get back the new model
24:52 - and it's going to go cool i'm going to
24:53 - retain that model that's the new model
24:55 - now
24:56 - then it's going to go right view
24:58 - function here's the model get me back
24:59 - that html
25:01 - great i've now got that html and it's
25:03 - going to do the virtual dom differing
25:05 - calculate the dom differences and
25:06 - actually communicate
25:08 - that back into the layout
25:13 - they're unhappy so far with that
25:16 - nods but like more furrowed brows now
25:22 - hopefully furrowed um because you're
25:24 - thinking well this is really nice mario
25:27 - but
25:28 - how do you actually do anything
25:32 - with the outside world
25:34 - um
25:35 - so like i said before the guarantee that
25:37 - we have when we're looking at any elm
25:38 - function
25:39 - in code is that it's not going to be
25:41 - doing effects
25:42 - so say we wanted to
25:44 - um
25:45 - write a little app where you pressed the
25:47 - button and it fetched a new gif of a
25:50 - hilarious cat
25:52 - animation right
25:53 - so when that button is pressed we would
25:55 - like to send an ajax request or
26:00 - a request to a server to get a new url
26:02 - and we'd like to get that request back
26:03 - and change it
26:05 - well actually it functions in exactly
26:09 - and exactly the same way as the browser
26:10 - so
26:11 - what we write in terms of our app
26:12 - doesn't change we still only have four
26:15 - things we have the model we have the
26:16 - types of messages that we can expect
26:19 - we have our update function which
26:22 - has our business logic and we have the
26:24 - view except what happens now is when um
26:26 - that message type comes through
26:28 - um this kind of upgraded so this is
26:30 - html.program we're on beginner program
26:32 - we've gone to program now so the type
26:34 - signature changes slightly um update
26:36 - function now returns two values instead
26:38 - of one so instead of just returning the
26:41 - model it now also returns an array of um
26:45 - what in l are called commands
26:47 - they're values that represent a command
26:50 - that elm may execute for you later
26:55 - so you can kind of think of it like
26:57 - promises
26:58 - that you cannot resolve
27:01 - there's no mechanism in elm to actually
27:03 - resolve commands yourself the only way
27:05 - to resolve it is to
27:07 - hand them back to the elm runtime
27:09 - so
27:10 - let's say we we'd done this and our
27:12 - request has uh we've asked for elm to do
27:14 - a request for our cat gif well in the
27:17 - meantime elm goes yeah that's nice but
27:19 - i'm gonna
27:20 - i've got a new model i'm gonna run the
27:21 - view and we're gonna put that stuff back
27:23 - in the dom so that whole process happens
27:25 - instantaneously then at a separate
27:27 - asynchronous juncture
27:30 - elm may choose to take that command into
27:32 - what is called an effect manager so elm
27:34 - has an implementation of a certain set
27:36 - of effects that the language supports um
27:39 - http requests to one of them
27:42 - and it will execute that command now
27:45 - when we issued that command what we had
27:47 - to issue along with the command is an
27:49 - instruction to elm of what message type
27:52 - we wanted to get back
27:54 - and so then elm deals with the busy work
27:57 - and the possible failures and the nils
27:58 - and all that kind of stuff and it'll
28:00 - only give us back
28:02 - well-defined conformed guaranteed
28:05 - actually okay messages if they happen to
28:07 - exist yeah so what the effect manager
28:09 - will be doing is it'll be sending back a
28:10 - message note that this message
28:12 - and this one here are the same exactly
28:14 - the same mechanism let's take it in
28:16 - isolation so imagine that that whole
28:18 - loop has happened and we've got our new
28:19 - dom and now asynchronously the effect
28:21 - manager has has triggered a command for
28:23 - us so there's been an event
28:26 - let's say we've successfully gotten back
28:28 - our http request so
28:30 - the message that we've defined which is
28:32 - a message in our update function that
28:33 - accepts back the specific value that
28:36 - we're looking for will get called for us
28:38 - the same thing will happen again
28:40 - just exactly the same route like as if
28:42 - it come from the browser we actually
28:43 - don't know where it's come from
28:45 - i mean it could have come from the
28:46 - browser it could have come from an
28:47 - effect manager we only know by the
28:48 - semantics of the messages the action
28:50 - types that we've implemented um
28:53 - model html view gets run again and the
28:55 - dom gets output so that same mechanism
28:57 - kind of works through for both versions
29:03 - that is the most complicated thing that
29:05 - i ever had to try and figure out with
29:07 - elm so i'm really hoping that that that
29:09 - um unlocks a lot a lot of the runtimes
29:11 - perhaps my favorite thing about elm is
29:13 - that it has the best
29:14 - pair programming buddy i've ever
29:17 - worked with
29:18 - mainly because they have no attitude and
29:20 - they're never wrong
29:21 - and it's just really really pleasant you
29:23 - don't have to talk to anybody like the
29:25 - the compiler just kind of
29:27 - yells stuff at you so
29:31 - i'm going to give you some nice canned
29:33 - scenarios first um just so you see the
29:35 - kind of quality of elmera messages
29:38 - um
29:39 - okay so the first one i'll show you is
29:46 - this name
29:47 - okay so here we've got um
29:51 - soon
29:52 - um here we've got an error from elm
29:55 - and uh this is how it would come up in
29:57 - your console so you could have a live
29:58 - reloader going and it's you save your
30:00 - file and it and it's i'm spitting stuff
30:01 - out or i have it directly in my editor
30:04 - and ellen said hey i've detected an
30:06 - error it's a naming error i can't find
30:08 - the variable list.nap you've lose this
30:11 - as an app a list does not expose nap
30:13 - maybe you want one of the following
30:14 - list.map any map to map three so it's
30:16 - not a heuristic search on on the name
30:19 - which is really nice so it not only does
30:22 - it tell you what's wrong exactly where
30:23 - it's wrong give it a little indicators
30:25 - to highlight specifically on which area
30:26 - of the line it's wrong
30:28 - it also gives you suggestions for other
30:29 - things so this is a live code example
30:30 - that i've just reloaded
30:34 - getting a little bit more advanced than
30:36 - that uh here we've got
30:39 - um an
30:40 - if statement we've said um if n is less
30:43 - than zero then let's return the string
30:44 - negative uh if n is greater than zero
30:46 - let's just turn the string positive
30:47 - otherwise let's return 42. um so elm
30:51 - here is telling us well you've got a
30:54 - type mismatch here the second and third
30:56 - branches of this if produce different
30:57 - types of values the second branch of
30:59 - this type is a string but the third is a
31:01 - number and then it gives you these hints
31:04 - these these are the best thing by far so
31:06 - that's the
31:07 - uh that's the nice can scenario
31:11 - which is what normally gets talked about
31:13 - in talks um
31:15 - so i figured it's probably better to
31:16 - show you where elm really shines in the
31:18 - worst possible scenario
31:20 - luckily i have the worst elm codebase
31:23 - known to me
31:25 - which is my own codebase
31:27 - and i'm just going to go and arbitrarily
31:29 - change something
31:31 - in the
31:31 - [Music]
31:33 - in the application that you're all using
31:35 - on your phones
31:37 - um to try and just give you a little bit
31:39 - of a sense of what it's actually like to
31:41 - do mass refactorings in elm
31:43 - so
31:44 - here we've got a foreign code base um
31:46 - that we've we've never been in before
31:48 - and it's got like tons and tons of code
31:50 - it has no tests like nothing like just
31:52 - you know like absolute horror someone at
31:55 - work has like gone full crazy on elm
31:57 - they've just built all this stuff and
31:59 - they've quit right now it's your job to
32:01 - deal with it
32:02 - and you're like you're ready to like
32:04 - quit your job and you know you're like
32:06 - on stack overflow looking for other
32:07 - stuff and you're like all right uh i
32:10 - remember mario said some stuff like i
32:11 - should recognize the cell map um you got
32:13 - app.um i'm gonna start okay so we've got
32:15 - a program with flags um thing here and
32:18 - we kind of see like okay um init update
32:20 - and subscriptions and some stuff is here
32:23 - um and we've kind of got this types
32:24 - thing here so it seems like uh types is
32:27 - let's say we need to extend this app
32:29 - right we want to we all want to add a
32:30 - new page to the presentation software so
32:33 - we go okay cool well we know that in elm
32:35 - to add a new page we probably need to
32:37 - find
32:38 - a type for that page or we probably need
32:40 - to find the actual core message type
32:42 - that represents all the actions that can
32:43 - happen and add something there
32:45 - so say we go into types
32:47 - we look through we've got type page type
32:49 - aliases we've got things oh here we go
32:51 - type message we go cool so this is all
32:53 - the stuff
32:54 - actually all of the things that this app
32:56 - does
32:58 - there's nothing this app does that isn't
33:00 - here
33:02 - like let that sink in for a second
33:04 - it's a code base that you've never
33:06 - touched before and immediately you
33:07 - already know everything that it does so
33:10 - let's say we go okay
33:12 - my new awesome feature
33:16 - is the new label like when you click a
33:17 - button it's going to trigger my new
33:19 - awesome feature which is going to be
33:20 - amazing
33:21 - and we save this and what we get from
33:27 - what we get from elm basically now is
33:31 - a pair programming buddy that intimately
33:33 - knows the whole code base and has in a
33:35 - split second gone through and checked
33:36 - every single file every single include
33:39 - anywhere that this type might be used
33:41 - and immediately started coming back
33:43 - with errors so the very first error that
33:44 - it's given us
33:45 - is saying well your update function
33:48 - which is in another part of the code
33:49 - remember the update function is the main
33:50 - function with all our business logic
33:52 - saying that update function doesn't
33:54 - cover this new feature that you have
33:56 - you need to go and add that in there so
33:59 - we'll say okay cool where's that update
34:00 - function
34:04 - it's quite a long update function so
34:06 - we're going to scroll to the top like i
34:07 - said is you know like the worst the
34:09 - worst possible code okay so it says
34:11 - state.m and here we go we've found our
34:13 - update function so let's kind of scroll
34:15 - to the bottom of it all the various
34:17 - things
34:18 - remember like worst worst worst possible
34:20 - code
34:21 - um my awesome
34:24 - feature
34:26 - and uh let's just say we're going to
34:29 - return the model as is and we're going
34:30 - to turn command. we're just not going to
34:32 - do anything right it's going to be a
34:33 - no-op
34:34 - now it's saying well can't find pattern
34:36 - my awesome feature why not
34:38 - because it's called my new awesome
34:39 - feature yes thank you pair programming
34:41 - buddy
34:42 - i've made that change now and only
34:45 - saying okay that's pretty good
34:48 - that's good
34:50 - that is all you needed to change nothing
34:52 - else in the code will break you didn't
34:53 - make any other side effects nothing else
34:55 - depends on that new feature you've added
34:57 - you are 100 a okay to deploy this to
35:00 - production
35:02 - so that for me is like
35:05 - chalk and cheese difference to the kind
35:06 - of development that i have day to day
35:10 - so much so that i'm finding it
35:12 - increasingly more difficult to program
35:13 - in other languages without these
35:14 - guarantees just because the
35:17 - level of uncertainty that you gain by
35:20 - working in a language like this kind of
35:22 - really decreases your confidence in
35:23 - other languages so i find myself now
35:25 - when i interrupt with javascript and elm
35:27 - and i'm working with javascript stuff
35:29 - you know with elm you you you write
35:31 - stuff and you compile it and it's wrong
35:33 - and you change it and it's wrong you
35:34 - change it again elm's like no you're
35:36 - wrong and you fix it and it's green
35:38 - you're like
35:39 - well it looks like it's pretty good and
35:41 - in javascript you change something
35:43 - and you're like where's the thing that
35:44 - tells me
35:45 - ah
35:47 - maybe it's okay i don't know like you
35:49 - gotta potentially now go write tests do
35:51 - your tests cover every single case
35:53 - potentially not
35:54 - so the wrong and broken difference that
35:57 - kind of broken bit just kind of
35:58 - disappears but the wrong bit is still
36:00 - your responsibility
36:03 - everyone's somewhat satisfied with the
36:05 - real life example
36:06 - okay
36:10 - cool
36:11 - very quickly i'm ending off with some
36:13 - high-level stuff so um lm packages have
36:15 - auto semva um so again when i talked
36:18 - about uh the nice side effects of having
36:20 - enforced purity and
36:22 - um
36:25 - side effect free code
36:27 - elm can look at your library and all the
36:29 - type signatures that you have exposed if
36:31 - you have changed no public interfaces l
36:33 - will minor version increase if you have
36:36 - added a public interface it will
36:39 - the middle version increase and if you
36:41 - have removed a public interface it will
36:42 - major version bump your code you can't
36:45 - change your own version numbers in elm
36:47 - packages it just does it entirely for
36:49 - you the flip side of that is when you're
36:52 - pulling down new package updates elm can
36:55 - automatically or you can safely pull in
36:57 - minor and
36:59 - intermediate versions because you know
37:01 - that they haven't fundamentally they
37:03 - shouldn't have changed
37:04 - they wouldn't have changed any of the
37:05 - interfaces they may have changed some
37:07 - behaviors but generally it's a lot safer
37:09 - and if you're dealing with a major
37:10 - change you know that something's going
37:11 - to be removed even still
37:13 - bringing that package in with a major
37:14 - change you're pretty happy because the
37:17 - elm compiler will then immediately tell
37:18 - you every single place in your code base
37:20 - where your usage of that package is now
37:22 - broken
37:24 - so you still have the protection and
37:25 - optional choice on whether you want to
37:26 - engage in that work or not but when you
37:28 - do upgrade it gives you like a bucket
37:30 - list of exactly how to upgrade which is
37:32 - pretty awesome
37:33 - the elm packages site if you want to
37:35 - kind of look at the kind of packages
37:36 - that exist in the om community they're
37:38 - on packages.online.org
37:41 - yeah check it out there's so much more
37:43 - to say there
37:44 - compiling elm so i haven't talked about
37:46 - how elm actually works in terms of
37:48 - compilation so like i said even though
37:49 - it has all this library stuff it is
37:51 - fundamentally a separate language that
37:52 - has its own runtime um so it's got its
37:54 - own compiler so you take you write a
37:56 - bunch of elm files and they run through
37:59 - the compiler and you get compiled
38:01 - javascript that includes both your code
38:03 - and the runtime and all the libraries
38:04 - and everything to do with it all kind of
38:05 - packaged up
38:07 - if you're in a project that has
38:09 - javascript files already you're probably
38:10 - going to want to
38:11 - pull in elm incrementally um into
38:14 - certain bits to try it out or to have
38:17 - kind of some interrupt
38:18 - so
38:19 - the very very simple way to do that is
38:20 - through webpack webpack has a elm
38:23 - webpack loader
38:24 - which will simply allow you to require
38:27 - elm files directly and then mount
38:31 - that elm app to whatever node you
38:33 - actually want that to attach to and then
38:34 - run the rest of its stuff through
38:37 - uh how do i use element work uh the
38:40 - answer is gradually there's actually a
38:42 - blog post by
38:44 - um the author of elm himself his name is
38:46 - evan um and he he talks about the
38:49 - incremental approach and also um what
38:51 - he's seen in his experience of the the
38:54 - number of years that he's been um
38:56 - improving elm for on projects that have
38:58 - succeeded
38:59 - and yeah generally the premise is that
39:01 - you take a small area of an existing app
39:04 - um or or if you're starting from scratch
39:05 - if you have that luxury
39:07 - and you can just try elm out in a very
39:09 - small section and experiment and see if
39:11 - it meets your needs and if it works well
39:12 - enough for the domain that that you
39:14 - write in and then if it does you simply
39:16 - just take more and more chunks of that
39:18 - tree or put elm in multiple places
39:20 - around your app
39:23 - so for those of you
39:25 - that are using react there's a kind of
39:27 - like a canonical example um by evan
39:29 - himself of uh react components um so
39:32 - very simply you're importing uh the elm
39:35 - uh
39:36 - elm wrapper for reactant components
39:37 - you're importing your lmap from wherever
39:39 - it might be like the compiled code and
39:41 - then you can just put that straight into
39:45 - a react render function there's a very
39:46 - simple example there's more complicated
39:48 - examples where if you want to pass some
39:49 - values of mlm initially or if you want
39:52 - to actually talk to and from that
39:54 - application um but
39:56 - all of this is like a 20 line wrapper
39:58 - it's really really simple so just with
40:00 - plain javascript you literally if you're
40:02 - using the l modpack loader you're
40:03 - requiring
40:05 - that javascript that um you've written
40:07 - and you can just embed it to a node
40:09 - that's the only attached point to get
40:11 - started
40:13 - cool cavetts
40:17 - general purpose programming language
40:18 - gets kind of thrown around a lot so
40:20 - something that i again i got cut on so i
40:22 - kind of want to put out there elm
40:24 - doesn't run on the server side yet it's
40:25 - not a server-side language and it's not
40:28 - a general purpose language you could run
40:30 - it on the server if you really wanted to
40:31 - i'm in 0.19 the next version there may
40:34 - be some server-side rendering stuff
40:36 - because a lot of people have been asking
40:37 - about that um but there is a really
40:39 - really good document about general
40:40 - purpose language written again written
40:42 - by evan um that i would recommend
40:44 - reading if that kind of infuriates you
40:46 - for some reason because it's actually
40:47 - really clear and articulate on why this
40:49 - kind of premise doesn't really exist so
40:51 - you know we might say python is a
40:52 - general purpose programming language but
40:54 - you're not going to go right assembly in
40:55 - it we might say c is a general purpose
40:57 - programming language but you're not
40:58 - going to do web development in it so
41:00 - general purpose languages do still have
41:01 - specializations so elem is the same in
41:03 - that sense it's specialization really is
41:04 - to be really awesome at front-end apps
41:08 - uh fiddling with a dom you're gonna have
41:10 - a bad time
41:12 - uh if you really really convinced that
41:14 - you really really need a fiddle with a
41:16 - dom or you have some application that
41:18 - for some reason are doing something with
41:21 - external libraries and pulling in markup
41:23 - and all that kind of stuff um that is
41:24 - not something that elm allows or is any
41:27 - good at really um you can still achieve
41:29 - what you wanted if you talk the reports
41:31 - to um some javascript kind of interrupt
41:34 - but on that side as well java script
41:36 - interrupt is really really strict in
41:38 - order for elm to preserve those kind of
41:39 - guarantees of runtime safety and not
41:41 - exploding on you the way that it talks
41:44 - in and out of javascript is also through
41:45 - a really strict typed interface so it
41:47 - makes sure that the types that come back
41:49 - are actual types that your app can
41:51 - handle and keeps anything else out so
41:53 - kind of all the javascript errors stay
41:54 - on the outside and the arm stuff stays
41:56 - pure
41:57 - and yeah this one's a little bit cynical
41:59 - but you
42:00 - you legitimately may be more frustrated
42:02 - with other languages at least i have
42:04 - been uh cool thoughts after two years of
42:07 - functional programming uh it's not a
42:08 - silver bullet i'm not claiming that um
42:11 - this is the solution for all problems
42:13 - like i've said before i'm not suggesting
42:14 - we go to linus torvalds and say hey
42:16 - let's rewrite linux and elm
42:18 - but i think if you're doing web
42:20 - development um and you're writing web
42:22 - apps which is specifically what um
42:24 - almost engineered for i think it trades
42:26 - off for better problems um the
42:27 - constraints that it gives you it's kind
42:29 - of like lego um if you've played with
42:32 - lego as a kid um you probably didn't
42:34 - think man i really wish i could just put
42:36 - glue and
42:37 - and wood sticks and and cut the lego
42:39 - pieces in half right you just kind of go
42:40 - ah they snap together and suddenly can
42:42 - you build all these kind of things so
42:44 - for me fp is that same kind of thing i
42:46 - don't see the type safety i've never
42:48 - felt it to be a restriction it's just
42:49 - been kind of like an enabler um but if
42:52 - you really really need glue and sticks
42:53 - well then use glue and sticks um i'm yet
42:56 - to see a broken run time i haven't seen
42:58 - one yet there are various edge cases
43:00 - that can cause them you can look them up
43:03 - on the online tracker i think they've
43:05 - gotten them down to like four or three
43:07 - now
43:09 - elm reveals your mistakes
43:11 - so as part of a previous talk i talked
43:13 - about why l made me realize how terrible
43:16 - of a programmer i am
43:18 - it's actually a positive
43:19 - because it improves your code overall
43:21 - but it it kind of does show you
43:24 - like i said before it lowers that
43:25 - confidence that you have in other
43:26 - languages because it increases your
43:27 - visibility of just how much you're not
43:29 - seeing that you're not catching um and
43:31 - refactoring is really awesome i
43:34 - before the last presentation that i did
43:36 - this live
43:37 - talk with i decided to change something
43:40 - from a single field to like an array
43:42 - like i had a one of something and i
43:44 - wanted to have a multi of something and
43:46 - i changed it and it broke the whole code
43:48 - base because my whole thing had been
43:49 - built with a premise of a singular
43:51 - relationship
43:52 - and 15 minutes before the presentation i
43:54 - was like
43:55 - yeah why not ah let's dive in
43:57 - managed to get like all the stuff
43:59 - checked off and all changed and
44:00 - compiling and deployed it and went
44:02 - flawlessly um so my experience with that
44:04 - has been that at a baseline level in the
44:07 - worst possible scenario writing the most
44:08 - terrible code with no tests you still
44:11 - end up in my experience better off than
44:14 - other languages that don't have these
44:15 - guarantees and you do have those kind of
44:17 - tests
44:20 - okay further reading watching uh the elm
44:22 - guide is kind of like the canonical
44:24 - intro um it'll teach you all the stuff
44:25 - that i've violently skipped over like
44:28 - actual um syntax and the type of values
44:31 - that are
44:32 - available and some of the library
44:33 - functions
44:34 - a lot of this talk i've kind of ripped
44:36 - bits and pieces out from kevin yank who
44:39 - does a much better and more eloquent job
44:41 - with much nicer slides and so check out
44:43 - developer happiness on the front end
44:44 - with elm especially if you also work
44:46 - with rails you may find that interesting
44:48 - and then two uh talks recently that i
44:50 - think really address um two problems
44:53 - that that kind of people run into um
44:55 - when they come to um because it's such a
44:56 - different paradigm is you your app gets
44:58 - larger and larger and you wanna scale it
45:00 - um or you you start with a file and like
45:02 - me i kind of started with my first file
45:04 - and once i got to 100 lines i was like
45:05 - oh
45:06 - this is bad
45:08 - 10 files and like modular structure and
45:10 - all this kind of stuff and and so evan
45:12 - talks about why that's the the reasons
45:14 - that we do that in other languages
45:15 - aren't actually present in elm so it
45:17 - doesn't make sense to do that so he
45:18 - talks through a really beautiful example
45:20 - of those kind of assumptions and how
45:22 - they fall over in the life of a file and
45:24 - growing kind of modules out and then
45:26 - richard feldman talks about scaling
45:27 - lmaps until much larger extent richard
45:30 - works at a company called no raid inc
45:32 - and i think it's 200 000 lines of elm
45:34 - code in production they have and their
45:36 - claim is that they still haven't had a
45:37 - single runtime exception so i think
45:39 - that's that's pretty cool so if you want
45:40 - to see either of those kind of things
45:42 - take it from
45:43 - the horse's mouth there
45:44 - um that's all i've got
45:46 - thank you

Cleaned transcript:

hello my name is mario um and i'm going to be doing a maybe a nonconventional crash course for you in elm uh i work at travelport locomote um travelport is one of the three major gds's in the world hands up if you've ever taken a flight before anywhere one in three chance we sold you that flight uh locomote what we do is we do corporate travel so those of you that work at a big corporate awesome come and talk to me later we have a great product for you but yeah we do corporate travel management and um we've been acquired by travelport so as you can probably tell by the accent i'm not english british um i come from australia and our company was started in melbourne but with the acquisition i now live and work in london you can find me on github my handle is super mario that is my actual real handle so the goals for what i'm going to do tonight i was originally thinking of doing um the same format that we do at the elm london meetups um which is to actually do a code night you pull out your laptops you actually work on stuff people get in different groups either you're going from scratch and i'm doing a from scratch tutorial or you're working on projects or you might be advanced and helping with open source stuff but i thought given that i've got a room of presumably javascript and react experience developers the more that i thought about it the more i thought about my own journey into discovering kind of element functional programming and the things that prevented me from understanding the value of those things to myself and what they would give me in my kind of daytoday work and i thought it might be more valuable if i gave you a swathe of those kind of things because i found those really hard to find online i mean you control through lots of blog posts and things and try and scrape things together but until you've really kind of tasted um element functional programming for yourself it's really hard to understand some of those concepts so i wanted to maybe instead give you a little bit of a teaser of those things that you might not find so easily and then give you the resources of which there are plenty of for you to just learn like elm syntax and stuff so i'm going to try and cover things that might not be obvious i'm still going to go through a little bit of alum so you've got a bit of grounding but i'm going to talk about some awesome things that um that exist in the elm community that may not be obvious straight away i'll talk about some pitfalls and then i'll give you some references for more stuff um cool so this is an lmap that you're currently looking at some of you're still joining so let's just start really easy how are you feeling everyone's feeling good hopefully awesome uh no one's feeling bad that's great javascript experience zero starting confident or pro pro meaning you work in javascript professionally okay so we've got some people that are zero some people that are starting this is going to be awesome for you for the rest of you you've got prior knowledge that's going to hold you back i'm just kidding elm experience um has how has your elm experience been in terms of exposure or reading or anything awesome we have some elm developers here most of you zero okay great so um hopefully for those of you that are zero this will be informative and useful and help you understand one is elm something that you're interested investing your time in and secondly what it might give you generally okay cool so normally what happens sorry normally what happens with this is um i go through a set of live slides and you've got on your devices a set of reactions so you can give me like you're okay or you're confused thumbs up thumbs down thinking face falling asleep or bookmarks and then at the end of the talk you can put your email address in and get all that stuff back sounds really awesome except i'm not going to give it to you um because i didn't get to prepare these slides in the software so we're not going to use this i'm going to step out of it but this is more just to give you an idea that this is an app that i've used in in past talks um if you look at the elm europe conference you can see me doing it live on stage engaging the whole audience and it's something that i've tried for a number of years to build in lots of other things and i always kind of got to the point where i just couldn't keep pushing further the complexity in whatever language i worked in really really held me back and i think this is probably my best testament for myself personally of what elm can give you as a developer because it's the first time i've actually been able to succeed with a project of this kind of scale so anyway let's uh let's run through uh the president you can come talk to me afterwards if you want to know more about the elm app software so i'm going to avoid these things today because i think that there's better resources than me speaking to you for finding that stuff um so learning detailed syntax um fp concepts as a whole um and looking at comprehensive code examples it's probably better off in your own time and at your own pace so i'm going to avoid that kind of stuff but i will give you um things that you can look at afterwards for diving into more detail on those things so what i am going to go through is i'm going to give you a high level of what is elm i'm going to try and disambiguate some stuff that in my opinion i feel you might run into if you try and learn it yourself we'll run through some code but at a very basic level and i'm going to run through the elm architecture which i think is probably one of the big tripping points that people run into you know this question of is ellen the library is it a language and and trying to figure out what it actually does and how you do things i'm going to try to talk through some some awesome things at least as far as i find them roughly talk about how do i use element work which may be an interest point to some of you and then i'll give you some caveats that i found for myself personally awesome okay what is ellen so by its own admission this is on the top of the elm site elm is a delightful language for reliable web apps you can generate javascript with great performance and no runtime exceptions that's almost guaranteed so in more detail it's a functional language it's statically typed but it has type inference so if you don't want to write types you cannot and elm will still figure out the types view up until a point all data is immutable so there is no such thing as immutable value or reference or object in elm everything's immutable by default that's part of the language you can't opt out of that all functions are pure which means that every piece of code that you ever look at in elm the answer to the question of what does this code do the answer is nothing it takes inputs and it returns a value but it won't make any effects it won't change anything in the outside world it won't ask the outside world of anything it will literally do nothing so every line of code in any lm code base you ever look at has these two guarantees um null undefined and exceptions don't exist they're not part of the platform they're not part of the language you can't type null and have it compile and nothing within your elm code can throw an exception or give you back a null so those kind of things are removed from the language um so the these are all rather intentional choices and they have some really really interesting implications when you when you don't have these kind of things in your or rather when you have these kind of guarantees in your language um it actually comes out to be a very very interesting subset of um of the kind of programming that you may be experienced in already so to answer the question of exactly elm library this kind of gets confusing when you start looking at um stuff online if you're familiar with i mean how many of you using this kind of stack or something loosely related to this yeah cool so you know you get really excited you want to start with javascript like right how do you install packages oh you can't you gotta get npm right okay now i have npm like how do i bundle stuff together like you can't you gotta get webpack cool and then you know react at the moment you're all here because this is reactivate but this is you know a more recent paradigm before there used to be many other choices and spine and backbone and um you know more modernly i guess angular as a competitor but there's a lot of different options there so you have to pick one maybe you pick react then eventually you get to a point where you've got too much local state and your components are trying to send stuff everywhere and you're like ah how to solve this problem and you go oh redux so you learn redux you bring that in now you've got this problem where you know you add a new action in redux and now you don't know all the parts in your code that need to be updated so maybe you get something like typescript to flow to bring some level of kind of checking to figure out i've added stuff here and now my code breaks over here so you kind of bring that into the language then you get to the point where you're like oh you know mutable references are really killing us we're passing objects and accidentally setting methods on them and losing control of our state so you go well maybe we need to bring immutable js into a stack so what's the experience like when you start elm well you go well how do i get packages well that's built into elm yeah cool so how do i get all my files compiled into a single version that's built into elm you go okay so how do i actually architect my code how do i do the view layer and all that kind of stuff well that's actually built into elm so you go cool so how do i manage my state when it gets really big that's built into elm uh what about type checking and flow that's built into elm and immutability as i mentioned is also built into our so the analogy i've been trying to use recently for this is when people say oh well it can't be a language that has too many features it would probably be i'm assuming um similar to originally when memory management was all manual and you're a c developer and something like javascript came along now like we have automatic memory management now you're like so that's a library you're like no no it's a language feature and like i can't be a language feature like that's too featureful um so this is kind of the same in that same sense so when we say that elm has these things built in it's not built in as a library that you use it is actually the language so there's only one architecture in elm it's called the elm architecture there's only one way to structure on that initial set of code and that's all baked in all the libraries that you build in are for various other bits and bobs around is that making sense getting some nonsense lovely um now it's not all in isolation there is kind of like a lot of cross flow and lots of lots of the stuff that's in that react stack if you're already familiar with it lots of stuff in elm will just seem really really natural um so this is just a quote from the um dan abramov the author of redux who has quoted as pulling certain ideas back from elm so if you use redux you're actually using a subset of the same kind of function that that operates in elm so that kind of stuff will come natural to you um the the difference i feel though is that here you've got a lot of disparate components with lots of different authors different styles and different integration points whereas in elm the whole ecosystem is built around the premise that the call language has these functions so there's a huge amount of effort put into them working together really really really really nicely so a lot of the pain points that you may see on the left hand side when you kind of come over to the elm side um my experience has been those pain points are either way reduced or just nonexistent um in that kind of environment so let me let me uh dive a little bit deeper into that side note let's just take a slight detour and then i'll come back um there's a personal bug bear of mine and it uh maybe it won't be the same for all of you but it really impacted my ability to learn functional because when i came up against these two things i was really defensive of my existing experience and a bit insulted that there could possibly be something that i didn't already know in programming so for me it was really humbling having to probably battle through a year worth of selflearning before i got kind of past these concepts and i think that they're needlessly complicated especially has anyone here tried to learn haskell or idris or any other kind of functional languages well i'm hoping your experience is better than mine but you know like space burritos and homomorphisms over funk to monads and it's kind of like the mathematics and the language and the kind of tone of that community is really really are really difficult to approach so i just wanted to kind of debunk two things that hopefully will help you separate hype from understanding a little bit more so two things unbreakable and functional um so what do we what do we mean when we say breakable yes i know it was a bit of a clickbaity title saying building unbreakable software um let me give you two statements first statement being is the sky is green most of you probably think that's wrong but like what if we're riding a computer game you know and maybe the sky is green or what if we're in the northern hemisphere and it's night time so this guy's green for those reasons uh might be wrong might be not like this is this is about semantics right this is what our job as program is is to take models of the real world and understand their semantics and then emulate them in code and we can get that wrong and probably unlikely for quite some time that anything's going to automatically replace that right because that's the thinking and the logic that really matters say for you know our ai overlords in the future uh here's the second statement this guy is uncaught type error cannot read property color of null anonymous this is broken i don't think you would ever want to have this feature i mean unless maybe you were writing like ironic javascript poetry or something but like this distinction wasn't really clear for me until i worked with functional programming because for me this was kind of normal life right like you can't avoid this this is what programming is this happens all the time it's called a bug and you fix it and you kind of move on and the premise of functional was yeah you can like you can just not have these in your life at all um and that kind of i really really struggled with so the reason i struggled with that is because of this definition functional will not save you from semantic incorrectness but it can save you from things that are actually broken we don't necessarily need to have these in a language the second thing um that i wanted to side note on was this whole notion of functional you know people say oh javascript's functional um that's not not true but the premise is that javascript has both functional features and imperative features and in between those two kind of paradigms there are actually some compromises yes you can draw good ideas from both things but ultimately one of the kind of premises of functional is functions and the mathematical sense where functions don't do things if a function does something we then define that as a procedure so straight away the fact that you can take imperative features and sprinkle them anywhere you put yourself in a situation where there's compromises and fp practices really require discipline so this is why you know especially redux is a good example of that people who maybe are new to the react stack and haven't used redux before and drag it in because they think that that's what they need as a baseline and it turns out maybe they don't yet need that now they're doing all these crazy things all over the place and trying to manage all this i'm kind of kind of a boilerplate um for this alleged benefit of fp while simultaneously having the ability to escape hatch and do their imperative stuff and i think you know path of least resistance the temptation is really really hard to do imperative features so i think my experience has been that functional features are really amazing learning them helps you think differently but ultimately wherein you're where you're in a code base especially under commercial pressure or time pressure you're going to compromise and do the imperative things um in a functional language as i define it uh you have functional features and that's it so there is no back door fp practices is the default you can't accidentally mutate stuff you can't accidentally do effects because it's kind of constrained so the premise is not to infantize a developer and say oh you can't manage this stuff but actually to say hey maybe when we don't have certain things here it actually helps us write better code right faster with more confidence and that's true of what i've found in l okay enough talking should i show you some code yeah okay so like i said i'm not going to go into super detailed examples but i'm going to give you a basic counter so that you see a full complete could deploy to production piece of elm code and then i'm going to use that to talk about the elm architecture that's powering things underneath does that make sense cool so i'm going to step through it and i'm really sorry i hope that you can all see um is that okay for everyone or is it struggling half nods okay um so uh at the top of a elm file um simply open a new elm file call it app.elm or whatever you want um we're gonna put module main exposing the syntax for dot dot means that we're exposing everything in this file we could choose to expose only certain functions if we were writing like a little library module but in this case we said wildcard just include everything we're going to import some stuff from the core library i'm going to import two things from the html library i'm going to expose uh four functions remember like i said before they're all functions they don't do anything they return values so beginner program um takes a bunch of parameters and returns a program value that l will run um button div and text are all functions that take a set of arguments for attributes a set of arguments for children and they return a virtual representation of what that markup might be that's all i kind of need and the onclick function will take a message type that i want to trigger and it'll give me a tribute that i can put in an element so in every elm app you'll experience at the basic level we write four things they are the only four things we ever write so once you learn these four things you can approach any lmap and immediately know where to start and what to look for so the four things are our initial model which is our initial state a type we're going to call it message you could call it whatever you want but we're going to call it message this is going to be um so if you know redux this is an action so all the actions that our app supports um we're going to write so they're the two they're the two models or the two two values that we're gonna write and then we're gonna write two functions one is an update function this update function will receive at a given any given point in time a message and the current model and what we need to return back is the new model based on our business logic so all of the business logic for an elm app sits in this function just one place then we've got the view and the view is very similar to what you might ex might have seen in react except here it's explicit it explicitly takes in a model and we will return to markup so let's go and implement that so for the counter we're going to start our counter with a value of zero our whole model is just going to be a single integer our model could be anything it could be a hash type with lots of things in it which is normally what you'd get to in a bigger app but let's just start with um just plain old value um for the message type uh or we want to be able to sorry i didn't actually show you the the button that we're sorry you're going blind uh so this is the this is the app that we're going to build so you can plus plus on the counter minus and we have no guards in our business logic so you can go negative cool okay so if you think about that up in terms of the actions we have we really just have two actions we want the counter to go up we want the counter to go down so we're going to just create two two types here in the message type so message is either going to be increment or it's going to be decrement i'm not going to stress this too much because it takes a little while to kind of learn this concept but you can kind of think of this a bit as an enumeration for now if that makes it a little bit easier or you can note that uh boolean has exactly the same type signature so type boolean is true or false where true and false are the actual values that get passed around you don't really pass around boolean does that make sense so increment and decrement are two actual values they're kind of like labels they're labels that we can pass around and they'll be type checked so we can't put a label that doesn't exist someone that doesn't exist um okay so our update function usually 99 times out of 100 we will start with a case and a case is as you would expect the messages of the message type so we're going to case on increment well if we're incrementing that's the message that we received um we're going to return model plus one if we're decrementing we're going to return model minus one and our view is going to use our functions so let's focus on this middle function first so you can see that the divider has no attributes so putting nothing in the tribute it's just the plain div and as its contents we're putting a text node so that's just a root text node with no wrapping and we're putting a two string of our model so model is an integer two stringed into the text version that's gonna be text node so that's gonna sit in the middle before and after we're creating two buttons the buttons do have attributes one has an attribute of onclick decrement the other one has an attribute of onclick increment and then they have the individual text nodes that they're showing and then those all those values are wrapped in a div that has no attributes and that's what we return back is everyone comfortable that they understand on a high level what this code does syntax aside for a second this is the last line that stitches everything together so elm always looks for an entry point called main and in main we have to give elm a program value so it's a value that describes how our program functions so what we're what we're doing here is we are taking the beginner program which is the the function that we've got from the elmcore library and it takes a hash that has three parameters or three attributes in it a model a view and an update so literally the stuff that we've just written the four things that we've written save for the the message type and we say to um okay well this is what our state looks like here's the initial model take that away lovely um here's the view function that i want you to run for me and whenever there's a new model and here's the update function that i want you to run for me whenever you get a message so the net outcome of that is um this little app and as you can see heading plus is triggering that message minus is pulling it back down um yeah okay any questions at this point more comfortable all right i'm just going to bang on the point a little bit um so that view function that we wrote takes a model and it returns something a value called html in elm it is an actual html similar to the way that react does it because ellen has a virtual dom implementation so it's efficiently checking for changes and things like that and managing the dom for us we don't go anywhere near the dom we just tell elem well here's what a markup should look like for that state you gave me so that's that's always a new set of html the update model works similarly it gets a message in the current model we do whatever logic we want make whatever changes we want to a new model and we give a new model back we can't mutate that old model so i'm going to try and visualize it again in another way and hopefully just just really syncs it in so here's our home runtime which we don't control the l runtime happens outside of our control we simply gave it our initial model we gave it our update function we gave it our view um so now we've compiled that we've booted up our javascript in the browser and our app is running so we've clicked a button which has fired one of our messages and remember that markup can only have the messages that we defined in our app if we typed any other kind of message there that was unhandled that would fail at compile time so the browser is going to give us a message type and it's guaranteed that that's going to be a message type we know about so the runtime is immediately going to do two things first it's going to send that uh to the update function call update function and get back the new model and it's going to go cool i'm going to retain that model that's the new model now then it's going to go right view function here's the model get me back that html great i've now got that html and it's going to do the virtual dom differing calculate the dom differences and actually communicate that back into the layout they're unhappy so far with that nods but like more furrowed brows now hopefully furrowed um because you're thinking well this is really nice mario but how do you actually do anything with the outside world um so like i said before the guarantee that we have when we're looking at any elm function in code is that it's not going to be doing effects so say we wanted to um write a little app where you pressed the button and it fetched a new gif of a hilarious cat animation right so when that button is pressed we would like to send an ajax request or a request to a server to get a new url and we'd like to get that request back and change it well actually it functions in exactly and exactly the same way as the browser so what we write in terms of our app doesn't change we still only have four things we have the model we have the types of messages that we can expect we have our update function which has our business logic and we have the view except what happens now is when um that message type comes through um this kind of upgraded so this is html.program we're on beginner program we've gone to program now so the type signature changes slightly um update function now returns two values instead of one so instead of just returning the model it now also returns an array of um what in l are called commands they're values that represent a command that elm may execute for you later so you can kind of think of it like promises that you cannot resolve there's no mechanism in elm to actually resolve commands yourself the only way to resolve it is to hand them back to the elm runtime so let's say we we'd done this and our request has uh we've asked for elm to do a request for our cat gif well in the meantime elm goes yeah that's nice but i'm gonna i've got a new model i'm gonna run the view and we're gonna put that stuff back in the dom so that whole process happens instantaneously then at a separate asynchronous juncture elm may choose to take that command into what is called an effect manager so elm has an implementation of a certain set of effects that the language supports um http requests to one of them and it will execute that command now when we issued that command what we had to issue along with the command is an instruction to elm of what message type we wanted to get back and so then elm deals with the busy work and the possible failures and the nils and all that kind of stuff and it'll only give us back welldefined conformed guaranteed actually okay messages if they happen to exist yeah so what the effect manager will be doing is it'll be sending back a message note that this message and this one here are the same exactly the same mechanism let's take it in isolation so imagine that that whole loop has happened and we've got our new dom and now asynchronously the effect manager has has triggered a command for us so there's been an event let's say we've successfully gotten back our http request so the message that we've defined which is a message in our update function that accepts back the specific value that we're looking for will get called for us the same thing will happen again just exactly the same route like as if it come from the browser we actually don't know where it's come from i mean it could have come from the browser it could have come from an effect manager we only know by the semantics of the messages the action types that we've implemented um model html view gets run again and the dom gets output so that same mechanism kind of works through for both versions that is the most complicated thing that i ever had to try and figure out with elm so i'm really hoping that that that um unlocks a lot a lot of the runtimes perhaps my favorite thing about elm is that it has the best pair programming buddy i've ever worked with mainly because they have no attitude and they're never wrong and it's just really really pleasant you don't have to talk to anybody like the the compiler just kind of yells stuff at you so i'm going to give you some nice canned scenarios first um just so you see the kind of quality of elmera messages um okay so the first one i'll show you is this name okay so here we've got um soon um here we've got an error from elm and uh this is how it would come up in your console so you could have a live reloader going and it's you save your file and it and it's i'm spitting stuff out or i have it directly in my editor and ellen said hey i've detected an error it's a naming error i can't find the variable list.nap you've lose this as an app a list does not expose nap maybe you want one of the following list.map any map to map three so it's not a heuristic search on on the name which is really nice so it not only does it tell you what's wrong exactly where it's wrong give it a little indicators to highlight specifically on which area of the line it's wrong it also gives you suggestions for other things so this is a live code example that i've just reloaded getting a little bit more advanced than that uh here we've got um an if statement we've said um if n is less than zero then let's return the string negative uh if n is greater than zero let's just turn the string positive otherwise let's return 42. um so elm here is telling us well you've got a type mismatch here the second and third branches of this if produce different types of values the second branch of this type is a string but the third is a number and then it gives you these hints these these are the best thing by far so that's the uh that's the nice can scenario which is what normally gets talked about in talks um so i figured it's probably better to show you where elm really shines in the worst possible scenario luckily i have the worst elm codebase known to me which is my own codebase and i'm just going to go and arbitrarily change something in the in the application that you're all using on your phones um to try and just give you a little bit of a sense of what it's actually like to do mass refactorings in elm so here we've got a foreign code base um that we've we've never been in before and it's got like tons and tons of code it has no tests like nothing like just you know like absolute horror someone at work has like gone full crazy on elm they've just built all this stuff and they've quit right now it's your job to deal with it and you're like you're ready to like quit your job and you know you're like on stack overflow looking for other stuff and you're like all right uh i remember mario said some stuff like i should recognize the cell map um you got app.um i'm gonna start okay so we've got a program with flags um thing here and we kind of see like okay um init update and subscriptions and some stuff is here um and we've kind of got this types thing here so it seems like uh types is let's say we need to extend this app right we want to we all want to add a new page to the presentation software so we go okay cool well we know that in elm to add a new page we probably need to find a type for that page or we probably need to find the actual core message type that represents all the actions that can happen and add something there so say we go into types we look through we've got type page type aliases we've got things oh here we go type message we go cool so this is all the stuff actually all of the things that this app does there's nothing this app does that isn't here like let that sink in for a second it's a code base that you've never touched before and immediately you already know everything that it does so let's say we go okay my new awesome feature is the new label like when you click a button it's going to trigger my new awesome feature which is going to be amazing and we save this and what we get from what we get from elm basically now is a pair programming buddy that intimately knows the whole code base and has in a split second gone through and checked every single file every single include anywhere that this type might be used and immediately started coming back with errors so the very first error that it's given us is saying well your update function which is in another part of the code remember the update function is the main function with all our business logic saying that update function doesn't cover this new feature that you have you need to go and add that in there so we'll say okay cool where's that update function it's quite a long update function so we're going to scroll to the top like i said is you know like the worst the worst possible code okay so it says state.m and here we go we've found our update function so let's kind of scroll to the bottom of it all the various things remember like worst worst worst possible code um my awesome feature and uh let's just say we're going to return the model as is and we're going to turn command. we're just not going to do anything right it's going to be a noop now it's saying well can't find pattern my awesome feature why not because it's called my new awesome feature yes thank you pair programming buddy i've made that change now and only saying okay that's pretty good that's good that is all you needed to change nothing else in the code will break you didn't make any other side effects nothing else depends on that new feature you've added you are 100 a okay to deploy this to production so that for me is like chalk and cheese difference to the kind of development that i have day to day so much so that i'm finding it increasingly more difficult to program in other languages without these guarantees just because the level of uncertainty that you gain by working in a language like this kind of really decreases your confidence in other languages so i find myself now when i interrupt with javascript and elm and i'm working with javascript stuff you know with elm you you you write stuff and you compile it and it's wrong and you change it and it's wrong you change it again elm's like no you're wrong and you fix it and it's green you're like well it looks like it's pretty good and in javascript you change something and you're like where's the thing that tells me ah maybe it's okay i don't know like you gotta potentially now go write tests do your tests cover every single case potentially not so the wrong and broken difference that kind of broken bit just kind of disappears but the wrong bit is still your responsibility everyone's somewhat satisfied with the real life example okay cool very quickly i'm ending off with some highlevel stuff so um lm packages have auto semva um so again when i talked about uh the nice side effects of having enforced purity and um side effect free code elm can look at your library and all the type signatures that you have exposed if you have changed no public interfaces l will minor version increase if you have added a public interface it will the middle version increase and if you have removed a public interface it will major version bump your code you can't change your own version numbers in elm packages it just does it entirely for you the flip side of that is when you're pulling down new package updates elm can automatically or you can safely pull in minor and intermediate versions because you know that they haven't fundamentally they shouldn't have changed they wouldn't have changed any of the interfaces they may have changed some behaviors but generally it's a lot safer and if you're dealing with a major change you know that something's going to be removed even still bringing that package in with a major change you're pretty happy because the elm compiler will then immediately tell you every single place in your code base where your usage of that package is now broken so you still have the protection and optional choice on whether you want to engage in that work or not but when you do upgrade it gives you like a bucket list of exactly how to upgrade which is pretty awesome the elm packages site if you want to kind of look at the kind of packages that exist in the om community they're on packages.online.org yeah check it out there's so much more to say there compiling elm so i haven't talked about how elm actually works in terms of compilation so like i said even though it has all this library stuff it is fundamentally a separate language that has its own runtime um so it's got its own compiler so you take you write a bunch of elm files and they run through the compiler and you get compiled javascript that includes both your code and the runtime and all the libraries and everything to do with it all kind of packaged up if you're in a project that has javascript files already you're probably going to want to pull in elm incrementally um into certain bits to try it out or to have kind of some interrupt so the very very simple way to do that is through webpack webpack has a elm webpack loader which will simply allow you to require elm files directly and then mount that elm app to whatever node you actually want that to attach to and then run the rest of its stuff through uh how do i use element work uh the answer is gradually there's actually a blog post by um the author of elm himself his name is evan um and he he talks about the incremental approach and also um what he's seen in his experience of the the number of years that he's been um improving elm for on projects that have succeeded and yeah generally the premise is that you take a small area of an existing app um or or if you're starting from scratch if you have that luxury and you can just try elm out in a very small section and experiment and see if it meets your needs and if it works well enough for the domain that that you write in and then if it does you simply just take more and more chunks of that tree or put elm in multiple places around your app so for those of you that are using react there's a kind of like a canonical example um by evan himself of uh react components um so very simply you're importing uh the elm uh elm wrapper for reactant components you're importing your lmap from wherever it might be like the compiled code and then you can just put that straight into a react render function there's a very simple example there's more complicated examples where if you want to pass some values of mlm initially or if you want to actually talk to and from that application um but all of this is like a 20 line wrapper it's really really simple so just with plain javascript you literally if you're using the l modpack loader you're requiring that javascript that um you've written and you can just embed it to a node that's the only attached point to get started cool cavetts general purpose programming language gets kind of thrown around a lot so something that i again i got cut on so i kind of want to put out there elm doesn't run on the server side yet it's not a serverside language and it's not a general purpose language you could run it on the server if you really wanted to i'm in 0.19 the next version there may be some serverside rendering stuff because a lot of people have been asking about that um but there is a really really good document about general purpose language written again written by evan um that i would recommend reading if that kind of infuriates you for some reason because it's actually really clear and articulate on why this kind of premise doesn't really exist so you know we might say python is a general purpose programming language but you're not going to go right assembly in it we might say c is a general purpose programming language but you're not going to do web development in it so general purpose languages do still have specializations so elem is the same in that sense it's specialization really is to be really awesome at frontend apps uh fiddling with a dom you're gonna have a bad time uh if you really really convinced that you really really need a fiddle with a dom or you have some application that for some reason are doing something with external libraries and pulling in markup and all that kind of stuff um that is not something that elm allows or is any good at really um you can still achieve what you wanted if you talk the reports to um some javascript kind of interrupt but on that side as well java script interrupt is really really strict in order for elm to preserve those kind of guarantees of runtime safety and not exploding on you the way that it talks in and out of javascript is also through a really strict typed interface so it makes sure that the types that come back are actual types that your app can handle and keeps anything else out so kind of all the javascript errors stay on the outside and the arm stuff stays pure and yeah this one's a little bit cynical but you you legitimately may be more frustrated with other languages at least i have been uh cool thoughts after two years of functional programming uh it's not a silver bullet i'm not claiming that um this is the solution for all problems like i've said before i'm not suggesting we go to linus torvalds and say hey let's rewrite linux and elm but i think if you're doing web development um and you're writing web apps which is specifically what um almost engineered for i think it trades off for better problems um the constraints that it gives you it's kind of like lego um if you've played with lego as a kid um you probably didn't think man i really wish i could just put glue and and wood sticks and and cut the lego pieces in half right you just kind of go ah they snap together and suddenly can you build all these kind of things so for me fp is that same kind of thing i don't see the type safety i've never felt it to be a restriction it's just been kind of like an enabler um but if you really really need glue and sticks well then use glue and sticks um i'm yet to see a broken run time i haven't seen one yet there are various edge cases that can cause them you can look them up on the online tracker i think they've gotten them down to like four or three now elm reveals your mistakes so as part of a previous talk i talked about why l made me realize how terrible of a programmer i am it's actually a positive because it improves your code overall but it it kind of does show you like i said before it lowers that confidence that you have in other languages because it increases your visibility of just how much you're not seeing that you're not catching um and refactoring is really awesome i before the last presentation that i did this live talk with i decided to change something from a single field to like an array like i had a one of something and i wanted to have a multi of something and i changed it and it broke the whole code base because my whole thing had been built with a premise of a singular relationship and 15 minutes before the presentation i was like yeah why not ah let's dive in managed to get like all the stuff checked off and all changed and compiling and deployed it and went flawlessly um so my experience with that has been that at a baseline level in the worst possible scenario writing the most terrible code with no tests you still end up in my experience better off than other languages that don't have these guarantees and you do have those kind of tests okay further reading watching uh the elm guide is kind of like the canonical intro um it'll teach you all the stuff that i've violently skipped over like actual um syntax and the type of values that are available and some of the library functions a lot of this talk i've kind of ripped bits and pieces out from kevin yank who does a much better and more eloquent job with much nicer slides and so check out developer happiness on the front end with elm especially if you also work with rails you may find that interesting and then two uh talks recently that i think really address um two problems that that kind of people run into um when they come to um because it's such a different paradigm is you your app gets larger and larger and you wanna scale it um or you you start with a file and like me i kind of started with my first file and once i got to 100 lines i was like oh this is bad 10 files and like modular structure and all this kind of stuff and and so evan talks about why that's the the reasons that we do that in other languages aren't actually present in elm so it doesn't make sense to do that so he talks through a really beautiful example of those kind of assumptions and how they fall over in the life of a file and growing kind of modules out and then richard feldman talks about scaling lmaps until much larger extent richard works at a company called no raid inc and i think it's 200 000 lines of elm code in production they have and their claim is that they still haven't had a single runtime exception so i think that's that's pretty cool so if you want to see either of those kind of things take it from the horse's mouth there um that's all i've got thank you
