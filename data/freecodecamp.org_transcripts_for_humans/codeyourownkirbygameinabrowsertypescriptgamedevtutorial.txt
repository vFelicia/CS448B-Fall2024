With timestamps:

00:00 - improve your typescript skills by
00:02 - building a fun Kirby game clone JS
00:05 - Legend teaches this game dep course and
00:08 - he'll teach you how to use Kaboom JS to
00:10 - create a 2d platformer game based on the
00:13 - classic video game hi everyone welcome
00:16 - to this new tutorial today we will be
00:18 - building a Kirby like platformer using
00:22 - typescript and the Kaboom Jaz Library so
00:25 - Kaboom Jaz is a library for making games
00:28 - and it can be used with typescript and
00:30 - here I'm just showcasing the project
00:31 - we're going to build so here it's a
00:33 - Kirby like character that can swallow
00:35 - enemies and shoot stars on once uh it is
00:38 - swallowed and then here you have a
00:42 - beautiful level layout by the way I made
00:45 - all the assets myself and then when you
00:47 - get hit like three times you respond to
00:51 - the original position and that's
00:53 - basically it so let's jump right into
00:55 - making a game like that what you're
00:57 - going to need for this tutorial is first
00:59 - of all I assume a basic understanding of
01:02 - typescript so maybe brush up on
01:04 - typescript you know just watch a
01:06 - tutorial or something before following
01:09 - this tutorial and I'm going to also use
01:11 - node so you need to be familiar with
01:13 - node so here I'm going to open up a
01:16 - terminal window and I'm going to set up
01:19 - the project differently than what you're
01:20 - used to if you're watching my if you
01:22 - have watched my previous tutorial
01:24 - tutorials sorry is that usually I would
01:27 - need to use index.html Etc and then
01:32 - paste the links to the libraries or use
01:34 - JavaScript modules here we're going to
01:36 - use a bundler it's called vit so I'm
01:38 - going to do npm run uh not npm
01:43 - npm create
01:46 - at vit uh not create vit
01:51 - at latest and then dot so that we we
01:55 - specify that we want the project to be
01:57 - scaffolded inside the current folder so
02:00 - by the way I'm using VSS code for this
02:01 - tutorial I recommend that you use it as
02:03 - well you can install it Etc now if
02:06 - you're familiar with typescript you're
02:07 - probably using uh vs code already so I'm
02:10 - just going to go over so after having
02:12 - done npm create V at latest we're going
02:14 - to select the vanilla template and then
02:16 - the typescript template and then you
02:18 - should have the following files now
02:20 - we're going to delete v.svg we don't
02:23 - need
02:23 - [Music]
02:25 - that also we're going to delete
02:27 - everything that is within the Source
02:30 - folder but we're going to keep the
02:31 - source
02:32 - folder and then here I think yep here it
02:36 - doesn't matter really you can just leave
02:38 - it as is it doesn't matter at all so
02:40 - let's get our assets so you will find
02:42 - the Assets in the
02:44 - description and yeah so it's basically
02:47 - just one
02:49 - file this file contains everything we
02:52 - need by the way during the tutorial we
02:54 - will be drawing our map using an an
02:56 - external editor called child and then we
02:59 - will uh basically pass this and for the
03:02 - this export to our JavaScript to take
03:04 - care of drawing so I see that the The
03:06 - Source folder is gone so we going to
03:08 - have to recreate it here we
03:12 - go so now what I'm going to do here is
03:15 - I'm going to create all the files we're
03:16 - going to need for this project right
03:18 - from the get-go so that it's going to be
03:20 - easy to follow so we're going to need a
03:23 - constant. TS file this for a constant
03:26 - we're going to need a
03:28 - entities. TS file this is going to be
03:30 - the file used to um contain the logic
03:34 - for our players our mobs enemies
03:37 - Etc we're going to also have a kaboom
03:42 - cx. TS which is where we're going to
03:44 - initialize the Kaboom library and export
03:47 - its context and then use that elsewhere
03:50 - we're going to also have a main.ts of
03:53 - course that's the entry point of our
03:55 - project we're going to need a state. TS
03:58 - to hold uh General Global state of the
04:00 - game so this is useful to know when to
04:03 - move on to the next scene for example
04:06 - and then finally we have the utils um
04:09 - UIL is just going to contain one thing I
04:13 - think just related to making the map
04:17 - basically all right so let's go to Main
04:20 - and before doing all of that I forgot we
04:22 - need to do npm install which is going to
04:25 - install the dependencies but we actually
04:28 - I should have done any npm install
04:30 - Kaboom as well so do this and this is
04:33 - going to put Kaboom accessible in your
04:35 - project so once you have this we can
04:38 - basically uh going to need the terminal
04:41 - to start a server in a moment but yeah
04:44 - that's basically it now here let's
04:47 - import Kaboom from Kaboom this how you
04:53 - import Kaboom
04:54 - here and then uh actually it's not here
04:58 - at all we're going to use the going to
05:00 - go to the Kaboom context and do this
05:02 - here so import Kaboom from
05:08 - Kaboom once this is done we're going to
05:12 - go
05:13 - to going to create our context so
05:16 - basically it's a way to initialize
05:17 - Kaboom so I'm going to export K which is
05:20 - going to be the Kaboom context we're
05:21 - going to use this constant everywhere
05:23 - when we need to use kabooma related
05:25 - functions and
05:27 - functionality Okay so to initialize
05:30 - Kaboom you just call the Kaboom function
05:33 - and pass in an object which going to
05:34 - have a bunch of um how do I say options
05:39 - so first let's specify a width let's
05:41 - start with 256 pixels and a height of
05:47 - 144 uh later on going to this is the
05:50 - resolution of the Game Boy but wider so
05:54 - it fits within a 16 by9
05:57 - ratio we're going to set the letter box
06:00 - option to being true that means that uh
06:03 - basically our canvas is going to scale
06:05 - regardless of the um of the uh of the
06:10 - screen size basically and while keeping
06:12 - the aspect ratio and we're also going to
06:15 - set the global property to being false
06:18 - the reason we want to set the global
06:20 - property to being false is that we want
06:22 - to only be able to use Kaboom related
06:24 - functions from this constant that's why
06:28 - you need to set it to false
06:30 - now in our constants TS file
06:33 - here we're going to create one constant
06:36 - reles the scale of the game because the
06:39 - current resolution is too small and it's
06:41 - also going going to act as a workaround
06:43 - because in kabon Jaz there is a bug an
06:45 - issue where
06:48 - pixels sometimes they don't get drawn
06:51 - right so you will have let's say we have
06:54 - a
06:54 - Sprite uh maybe to illustrate I'm just
06:57 - going to pull this out so here our Kirby
07:01 - like character for
07:02 - example you will have it drawn where you
07:06 - will have the image the Sprite will draw
07:09 - all right but one pixel is wider or
07:12 - smaller than other pixel and to fix this
07:16 - the workaround I've found is to set a
07:18 - scale to a value and then go to the
07:21 - Kaboom context and then first of all add
07:25 - the scale
07:26 - property and here first of uh let's
07:29 - import
07:30 - import let's
07:32 - import the scale
07:36 - constant and then by JavaScript you know
07:39 - that you can if you have a property that
07:41 - has the same name you don't have to do
07:43 - scale scale like that so you can just do
07:47 - it like this it's a short hand so the
07:51 - scale is the constant set to four this
07:53 - is what looked good but also you need to
07:55 - multiply by four here this is a a weird
07:58 - workaround I found but it
08:01 - works so yeah and so I recommend just
08:05 - using it for now if you found a way to
08:08 - get around this issue then feel free to
08:11 - add uh a comment in the comment section
08:14 - and share it with us okay so now we have
08:16 - our context that's great now let's go
08:19 - back to main and in main we're going to
08:23 - have our I'm going to import first our
08:27 - context import k from the Kaboom context
08:30 - we just
08:32 - created and then here we're going to
08:34 - have to load our Sprites okay so the way
08:36 - we're going to load our assets going to
08:38 - be a bit different from other projects
08:41 - we've made on the channel I'm going to
08:42 - create an async function I'm going to
08:44 - call it game
08:48 - setup now for now let's me let me reduce
08:51 - this let me remove that okay so we have
08:54 - the game set up and in there we're going
08:56 - to call all all over our logic and
08:58 - afterwards we call game setup here the
09:01 - reason we're going to do this is because
09:02 - we want going to want to load the asset
09:05 - assets once and when the player dies we
09:08 - don't need to refetch the map data we
09:10 - don't need to refetch the the the assets
09:13 - or something like that so to avoid
09:16 - actually this is really to avoid having
09:18 - to refetch the map data coming from
09:21 - tiled which is going to be the editor
09:23 - we're going to use to draw our maps and
09:25 - it exports to a Json file and we don't
09:28 - want to every time the player dies to
09:30 - redo the fetch logic to get the level
09:33 - layout and then redisplay it Etc so by
09:36 - just having everything done within a a a
09:38 - sync function where we can use the await
09:40 - keyword to wait for the map to be map
09:43 - layout to be extracted before moving on
09:47 - this is going to be really helpful in
09:48 - not having to repeat this logic so for
09:51 - importing the Sprites really I'm just
09:54 - going to copy and paste because this is
09:55 - logic that you just have to to I'm going
09:58 - to expl it of course but it's a bit
10:01 - tedious and not no new Concepts or
10:03 - anything like that is really
10:05 - present so I'm just going to do um
10:08 - explain what everything is first so here
10:11 - by using the K which contains all Kaboom
10:13 - functions and methods we can use we can
10:16 - use the load Sprite method this is how
10:18 - you load Sprites in Kaboom and by the
10:20 - way because you're using a bundler like
10:22 - V or or any other bundler you're going
10:25 - to have this uh some info on how to use
10:29 - the functions you're using and examples
10:32 - so that's pretty handy so the first key
10:34 - the first Pam is the name of the Sprite
10:37 - how you want it to be referenced in your
10:39 - project the second one is of course the
10:42 - path to the the project and here the
10:44 - path is just do/ Cirby like PNG even
10:47 - though we're putting our Assets in the
10:49 - public folder and the reason for this is
10:51 - simply because the vit is going to make
10:54 - sure that if you put this uh the the the
10:59 - path here is going to append or make
11:02 - sure that it it reference the public
11:04 - what's outside as well so this is
11:06 - something specific to V I don't know if
11:08 - other bundlers do this so you don't have
11:10 - to do dot
11:12 - SLU Cirby like
11:14 - PNG and then we have a slice n and slice
11:17 - 10 and the way to explain this is how to
11:19 - slice your image because our image our
11:22 - Sprite has much more than a single
11:24 - spritey within it so it's a tile set
11:27 - basically and here you can see that we
11:29 - we have one uh every every Sprite is
11:32 - drawn as a 16 by 16 has a resolution of
11:35 - 16 x 16 that means that we have 1 2 3 4
11:40 - 5 6 7 8 nine different Sprites on the x
11:44 - axis and that's why if I go to main.ts
11:48 - uh yeah slice X is going to be nine
11:50 - because we have nine Sprites nine yeah
11:54 - in the image and then here for the uh
11:58 - vertical axis we have 10 so you can just
12:03 - count them manually but I think it's
12:07 - obvious and now here is where we Define
12:10 - the various animations basically you're
12:11 - telling Kaboom wh which key corresponds
12:15 - to which uh thing you want to display in
12:18 - this image so for example for curb Idol
12:21 - so the the main character is called curb
12:24 - so it's just a it's a Cirby like it's
12:27 - not that original of a name but you know
12:29 - it's just for a tutorial in the end so
12:32 - curb in the idol is a name I've decided
12:35 - to name this animation which only
12:37 - contains one frame and the first frame
12:40 - remember that it starts from zero so 0 1
12:44 - 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Etc so
12:53 - at frame zero we have this idle Sprite
12:55 - so this is the idol Sprite we're going
12:57 - to use and we're going to use this name
12:59 - to refer to it for Kirby inhaling so as
13:02 - you know Kirby can inhale enemies well
13:05 - it's the same thing it's just a single
13:06 - Sprite and it's the Sprite at index one
13:11 - 01 and then curb full is when yeah so I
13:16 - I guess you get the point and then here
13:18 - when you want to have an animation that
13:20 - has more than just a single frame you
13:22 - use an object like this where you
13:24 - specify a couple of keys the first one
13:27 - is the from Key and you you basically
13:29 - telling Kaboom at which frame to start
13:32 - the animation here from frame three it's
13:34 - going to be this inhale effect so this
13:37 - thing and just to put it in action just
13:39 - to show it to you all right so just to
13:41 - so show you the Kirby the curb inhale
13:45 - animation it's this thing when you're
13:49 - inhaling you have a couple of pixels
13:51 - that just seems to give the effect that
13:54 - there is some inhaling going on here we
13:58 - go so now if I go back and go back to
14:01 - main.ts so from frame 3 to 8 and then at
14:05 - a speed of 15 frames per second this
14:08 - what looked good and I want this
14:10 - animation to Loop so you can decide if
14:13 - you want the animation to just play once
14:15 - or to Loop forever and we want we want
14:18 - it to Loop until we just decide to stop
14:21 - it so that's why I used the loop
14:24 - property as being
14:25 - true shooting star it's the the star
14:29 - here that you that the player shoots
14:32 - once they are
14:33 - full and basically it's the same thing
14:37 - the same logic for the various other
14:39 - entities so copy the code if you haven't
14:41 - already or you can pause here so this uh
14:44 - software is called tiled and it's used
14:46 - to draw maps and here is a map I've
14:49 - drawn for the um the first level and I
14:55 - have another one for the second level so
14:57 - the way I'm going to go about it is I'm
14:58 - going to to teach you how to use til for
15:00 - the first level and then for the second
15:02 - level we're just going to use what I've
15:04 - already had and this time around it's
15:06 - going to be different uh we're going to
15:08 - export the way we're going to use tile
15:10 - is going to be slightly different from
15:11 - the previous tutorials so let's let's
15:14 - jump right into it so first of all
15:16 - install tiled if not already a link
15:18 - should be in the description now there's
15:20 - one thing you need to do because if
15:22 - you're using a wide a big monitor then
15:25 - everything should probably look very
15:27 - small so to fix this you go to edit
15:31 - preferences and then to themes and then
15:34 - you click you check mark the use custom
15:37 - interface font and then you can here
15:39 - select the font size you want and this
15:42 - way it's going to make everything much
15:43 - more visible now uh I'm I'm going to
15:48 - keep this as a reference as I draw the
15:50 - level because otherwise it's going to be
15:52 - complicated so I'm going to create a new
15:54 - map by going to file new map and then
15:58 - you decide how many tiles you want and
16:00 - the width and height of each tiles so
16:03 - here let's start with I think 30 by 30
16:06 - um you know what I'm just going to look
16:08 - at the current map and see how many
16:10 - tiles we have it's a 27 by 20 tile so
16:14 - let's keep this so here new new
16:17 - map
16:19 - 27 by 20 so we can have exactly the same
16:23 - layout and of course every tile is going
16:25 - to be a 16 by 16 pixels and here don't
16:27 - touch anything it's on
16:29 - necessary all right we have our tiles
16:34 - here or actually we have our our map not
16:37 - the tiles we need to draw to draw in so
16:40 - first of all we need to import a new
16:43 - tile set and the way I'm going to do
16:46 - this is you specify the source so
16:48 - basically browse to where you put the
16:50 - Kirby like PNG in the uh public folder
16:55 - okay so I have done this so this is the
16:56 - path for me yours should be the same
17:00 - starting from
17:01 - here and now 16 by 16 pixels everything
17:05 - is all right and then click okay now
17:08 - once you have this you can use the
17:09 - control and mouse wheel to zoom in and
17:12 - zoom out so the only thing left is to
17:15 - start creating our V various layers and
17:18 - placing things so that's uh of course
17:21 - save so the way you save you you do save
17:24 - as I named it level. Json and I've S I
17:27 - saved it as a level
17:29 - devil -1. Json in the public folder of
17:32 - our project so I just go
17:36 - here and I click so yeah this was a
17:39 - mistake for me I just uh put it twice so
17:41 - I'm just going to delete this but you
17:44 - should have it here so once you have it
17:46 - here H we're ready to start working all
17:49 - right so now it's time for drawing so if
17:51 - I look at my reference we have the
17:53 - background as the lowest layer so
17:56 - background
17:59 - and what this is going to contain so
18:01 - just make things easy for me I'm going
18:03 - going to make everything nonvisible and
18:06 - here we can see the layout so
18:09 - basically one two and then okay so three
18:14 - 3 by two okay so I go here I'm going to
18:18 - select
18:20 - this three by two so they should be
18:25 - here yep and then one 2
18:29 - three one two and three I'm just going
18:33 - to zoom in with the control and the
18:35 - mouse wheel so you can see what I'm
18:36 - drawing so basically you select tiles
18:38 - like this and if you do control and
18:40 - select you can Al and click you can
18:42 - select more than once more than one tile
18:46 - you can have something like
18:48 - that and then here for this I'm just
18:51 - going to copy so two to the
18:55 - side here we go
18:59 - and then just try till the end doesn't
19:02 - matter really all that much by the way
19:06 - always save while doing while doing this
19:10 - and then another Hill so I'm just going
19:13 - to
19:14 - copy those two by the way you don't need
19:16 - to do control you can just click and
19:18 - drag and you can select more than one
19:21 - and here you going to have it have a
19:25 - big map
19:30 - so you know what I'm just I'm not going
19:32 - to worry about having it exactly
19:34 - anyway so this is just to show you after
19:38 - afterwards I'm probably just going to
19:41 - I'm going to probably use the same map
19:42 - that you have here but for the level two
19:44 - as I said I'm just going to use what I
19:45 - already had so here um okay so this
19:50 - looks like
19:52 - this doesn't have to be exactly the same
19:55 - otherwise we're just wasting time
19:59 - then you have like that then maybe this
20:01 - like
20:02 - that and a final
20:06 - one
20:09 - here all right so this is our background
20:11 - layer we're also going to need to add to
20:14 - the background layer some tiles like
20:16 - this you're going to see what they serve
20:18 - what's their purpose but this is really
20:21 - something optional so I'm just going to
20:23 - create a new layer so by the way by the
20:25 - way in Til There are multiple types of
20:28 - layer
20:29 - you have the image layer if you want to
20:30 - put an image as a full thing but you
20:33 - have the tile layer for tiles the object
20:36 - layers object type layers are for uh
20:39 - boundaries and spawn points so where to
20:42 - put your characters away for you to know
20:44 - this and let's create another tile layer
20:47 - and this second one is going to be the
20:49 - clouds so
20:52 - clouds here we
20:55 - go and then once you have the clouds I'm
20:57 - just going to select the full Cloud
20:59 - Sprites and just start putting them here
21:03 - as you can see they can overlay on top
21:06 - so just put to a random amount it
21:07 - doesn't matter save of course as you do
21:10 - this now the next layer is going to be
21:14 - the
21:15 - platforms so it's a tile layer as well
21:18 - platforms or platform did I call it
21:21 - platforms all right so for the
21:24 - platforms let's not stray a lot from the
21:29 - layout so that's the level okay so I'm
21:33 - going to
21:34 - use this these two oops these
21:40 - two uh wait a minute no that's that
21:43 - doesn't
21:45 - work so
21:47 - oops where should I put
21:51 - this okay okay here and then I'm going
21:55 - to expand this like that I'm going to
21:58 - put
21:59 - this like
22:00 - that here we go so really not much to
22:03 - explain here just draw draw whatever
22:05 - layout you
22:08 - want then you we're going to need
22:11 - certain structures though just so we can
22:14 - have the same thing but this is not
22:16 - something I plan uh I draw it on paper
22:19 - but I don't think it's worth you know
22:22 - copying exactly what I'm
22:25 - doing just use the proper tiles explore
22:28 - around
22:29 - Etc and then here I'm just going to have
22:31 - a
22:33 - platform here we go and I'm going to
22:36 - expand that
22:40 - further and then like
22:45 - this I think that's it and we need
22:49 - another structure that is
22:53 - similar so let's have this here
22:59 - expand it
23:03 - downward and then couple tiles
23:09 - here uh how many tiles is there five
23:13 - tiles 1 two 3 four and file five and I
23:18 - think that's uh basically it we're
23:21 - almost
23:25 - done oops doesn't matter because you can
23:29 - just draw over it and it will replace
23:31 - the tile okay so we have this let's put
23:34 - a sign post here to signify the
23:37 - beginning of a
23:38 - level let's um put the exit
23:43 - door
23:45 - whoops
23:47 - here and I think a couple of
23:53 - grass here uh we need to extend the
23:56 - background so
23:59 - in the background I'm going to need this
24:01 - fix and this make sure to change the
24:04 - layer of course all right so I think we
24:07 - have our level and then of course in
24:09 - still in the background layer we can add
24:10 - this
24:12 - down uh for the rest of the the color
24:15 - the the full background going to add
24:16 - this using Kaboom instead it's going to
24:18 - be more performant actually it doesn't
24:21 - really matter in the end but I think
24:23 - it's better to do it this
24:24 - way because the way I'm going to use
24:26 - tile today is going to be very different
24:29 - and basically just going to take the
24:32 - image and just draw use the Json to draw
24:35 - the boundaries on top so we still
24:38 - instead of drawing each tiles in Kaboom
24:40 - we're just going to take a PNG so here
24:43 - you can convert as a PNG it's going to
24:45 - be very simple okay so now we have this
24:47 - it's time to place our various colliders
24:51 - so I'm going to create a new layer on
24:53 - top an object layer this time around I'm
24:56 - going to call it colliders
24:59 - and now
25:01 - here uh the way you draw colliders by
25:03 - using this Square this rectangle on top
25:06 - here and then here's an example you drag
25:11 - Ah that's a that's a mistake you drag ah
25:16 - come on what's so basically just draw
25:19 - like that so you drag and
25:22 - drop various
25:25 - squares rectangles sorry
25:29 - and this is going to Define what is
25:31 - collidable and what
25:35 - isn't and then here we go so once you
25:39 - have done this we're done with the
25:42 - collider
25:43 - layer and now it's time for
25:47 - the
25:49 - um the spawn points so for the spawn
25:52 - points it's also going to be an object
25:54 - layer and I think I call it spawn points
25:57 - okay so I'm just going to rename by the
25:59 - way you can rename by just double
26:00 - clicking on the layer name so spawn
26:05 - points and now what's going to happen
26:08 - here is I'm going to use a pin instead
26:11 - so you see the pin icon use that and
26:14 - let's put our kir like
26:18 - character here so let's put it here
26:21 - where the sign Point sign post is and
26:24 - here you select a name and I'm going to
26:26 - call it uh player
26:29 - this is how we're going to differentiate
26:30 - between all the different mobs Etc so
26:32 - player spawns
26:35 - here the flame type mob are going to
26:38 - spawn spawn here so flame oops I created
26:41 - two pins be careful not to create pins
26:44 - by accident because you can so to select
26:47 - one you use this button here then you
26:51 - click and then you if you do if you have
26:54 - the pin selected and then you try to
26:56 - select another one it's just going to
26:57 - add another one we don't want that so A
27:00 - Flame character is going to be here and
27:05 - here flame here we
27:08 - go and then I think that's it and uh we
27:13 - have our
27:14 - birds so let's put
27:18 - two I wonder yeah it doesn't matter the
27:21 - position you know so I'm going to select
27:25 - here C bird
27:28 - and
27:29 - then bird and I think we missed the guy
27:34 - enemy so the guy enemy is this one I'm
27:37 - going to uh let's put it let's put him
27:43 - here I'm going to call it
27:45 - guy all right you have everything
27:49 - done so save and now we're ready uh
27:52 - whoops I created
27:54 - a unnecessary spawn point so we have our
27:57 - spawn points which DET terms where the
27:59 - player spawns where the flame spawn
28:01 - where the guy spawns where where the
28:03 - birds spawn I think the birds are
28:04 - spawning a bit too far so let's bring
28:07 - them down a
28:09 - bit so they can have a chance to hit the
28:12 - player at at all so here here it
28:16 - is like that all right so we have
28:21 - everything ready so for the exporting
28:23 - process you can just use the Json as is
28:27 - but for the image we need to hide the
28:30 - spawn points hide the colliders and then
28:33 - go to file and then export as image and
28:37 - then it's going to tell you the path and
28:38 - only include visible layers and
28:41 - everything else should be
28:43 - unchecked so now export now you could
28:46 - have drawn decided on the background
28:48 - color and included it but let's not
28:50 - worry about this so export that and then
28:53 - now if we go back to our editor you
28:56 - should have the level displayed like
28:58 - this so you can have the
29:01 - level as a single image and this is more
29:04 - performant or Kaboom to only have a
29:07 - single image to display that is
29:10 - relatively small and then scaled up than
29:13 - having to draw each tiles using Game
29:15 - objects there are ways around it so you
29:17 - could use a UV quad texture but this is
29:20 - more advanced so I recommend using this
29:22 - method it seems very simple and can have
29:24 - bigger much more bigger Maps than you
29:26 - could previously with boom
29:29 - Jazz all right now that we have this uh
29:33 - let's go back to main and import
29:37 - the the Sprite so k. load
29:41 - Sprite we need the level going to call
29:45 - it level one and it's going to refer to
29:48 - the level
29:50 - one.png Sprite uh image that we had okay
29:54 - let's create our scenes we're going to
29:55 - have a uh the way you create scenes in
29:57 - kaboom J is by using the scene function
30:00 - you decide on a name and you pass this
30:02 - as a first param level one and you can
30:06 - have here we're going to use an async
30:08 - function going to explain later on
30:10 - why and then actually do we need an
30:12 - async function here I don't think we
30:14 - need
30:15 - it uh we actually don't let's just have
30:18 - a a normal error
30:20 - function that is going to contain the
30:22 - logic that is going to be executed when
30:24 - we go to this scene so by default uh you
30:28 - have to specify a default scene and you
30:29 - can do this by simply calling K.O and
30:32 - the name of the scene level one to go to
30:34 - the that
30:35 - scene okay once we have done
30:38 - that we can write our logic from within
30:42 - so first of all let's set the gravity to
30:46 - being of
30:49 - 2,100 this is what looked good it felt
30:51 - good to play and then here we're going
30:53 - to create a background for a game now
30:56 - here I think we could just um
30:59 - put that logic outside actually we're
31:01 - going to have to repeat it because each
31:04 - time for each scene the background
31:06 - changes um because there is actually a
31:10 - set background function in Kaboom J just
31:12 - set the background for all everything
31:14 - the issue with it is that instead of
31:17 - having white bars here it's going to
31:18 - just use the same color of the
31:21 - background and we don't want that we
31:23 - really really don't so that's why um
31:28 - yeah otherwise we will confuse
31:30 - the the player on where is the actual
31:33 - limit of the the level for example so
31:36 - here let's create a our first game
31:38 - object in this tutorial so a game object
31:41 - in Kaboom jazz is everything that can be
31:43 - a Sprite player Etc so you in Kaboom JZ
31:47 - you create game objects that use certain
31:50 - components those components come from
31:52 - Kaboom JS you can Define your own
31:53 - components as well and depending on
31:56 - which components you add in to this
31:58 - array uh your game object will have
32:02 - different uh properties and methods that
32:05 - are usable on it so I think this design
32:08 - is really interesting and I haven't seen
32:09 - it elsewhere I think that's what is
32:11 - called an entity component system but I
32:15 - haven't had experience with any other
32:17 - one if uh so if you know uh if this is
32:20 - actually the entity component system and
32:24 - if
32:25 - other um libraries in other languages
32:28 - use it feel free to talk to say it in
32:32 - the comments I'm curious I want to
32:33 - explore it more so we're going to use
32:37 - the rect component allows us to draw a
32:39 - rectangle by we passing the width and
32:41 - the height we can get the width and the
32:43 - height by calling the width and the
32:45 - height method of the canvas so this we
32:48 - want the rectangle to actually fill the
32:50 - full canvas so that uh it acts basically
32:53 - as a background then for the color I'm
32:56 - going to use the color component and in
32:58 - there we're going to call the
33:01 - color class I guess and use the uh from
33:06 - hex method so it's probably an abstract
33:08 - class and pass in the value for the
33:11 - background color and here I just gone
33:13 - into a Sprite where I've drawn the
33:14 - Sprite and just took the color palette
33:16 - so the color for the background is
33:19 - this and uh wait wait a
33:22 - minute I need to add another
33:25 - component I'm going to add fixed
33:28 - component this is useful later on uh
33:31 - it's going to make sure that this game
33:33 - object is not affected by the camera and
33:35 - we want we don't want it to be affected
33:37 - by the camera otherwise if the camera
33:39 - removes then the the the rectangle will
33:44 - no longer faill the whole screen because
33:46 - it's going to be positioned to the left
33:48 - as the player goes to the right and the
33:50 - camera follows the player to the right
33:53 - all right we have everything we needed
33:54 - so just uh to run the project you do npm
34:00 - runev and then click on the
34:03 - link and then you have just an empty uh
34:07 - background all right so now let's write
34:10 - the logic for making the maps so for
34:14 - loading the maps and displaying them so
34:17 - what I'm going to do is I'm going to
34:18 - write this code in the
34:26 - utils.py let's go over it so first of
34:29 - all we're going to need the actually
34:31 - don't need the context here uh what
34:33 - we're going to need is to import the
34:37 - scale constant it's we're going to need
34:40 - to have this everywhere basically uh as
34:42 - I explained is to prevent pixeling the
34:46 - pixels to have two pixels that aren't
34:48 - drawn that don't take the same space
34:51 - it's very weird a very weird effect but
34:54 - it seems to be happening in Kaboom Jaz
34:55 - if you don't for some reason
34:58 - sometimes so that's the only fix I found
35:01 - for it so I'm going to export a function
35:05 - an S sync function it's a it's kind of
35:07 - required because we're going to use
35:09 - Fetch and we're going to call this make
35:13 - map it's going to take as the first Pam
35:15 - the Kaboom context so the typing is
35:18 - provided by Kaboom so all these things
35:21 - are going to also come from Kaboom and
35:23 - that's
35:24 - great and the name of the map is it's
35:27 - going to be a string it's also going to
35:29 - be
35:30 - the the path so it's going to be used to
35:33 - find the path of the level so the first
35:36 - thing we need is to have a constant that
35:38 - will hold the maybe I should increase
35:41 - the font size by the way here we go uh
35:44 - okay so we going to need the um to hold
35:51 - the map data within the map data
35:53 - constant here and we're going to use
35:55 - await await and then fetch
35:58 - which is going to fetch
36:00 - the the Json so here we're going to use
36:02 - a template
36:05 - string so
36:07 - dollar name which is the name of the
36:10 - map. Json and then at the outside. Json
36:14 - to have it as a Json so you could have
36:16 - written this line in multiple um in
36:20 - multiple lines I assume that you know
36:22 - what fetch is and how to use it with syn
36:24 - we so I'm not going to spend some times
36:26 - some time here if you aren't familiar
36:28 - look at my previous tutorials or just
36:30 - search online I think it's going to make
36:33 - a better explanation so here we're going
36:36 - to use the key uh the Kaboom function to
36:39 - make a game object so in Kaboom JZ you
36:41 - can add a game object to the scene which
36:44 - uh basically implies that you have to
36:45 - create it or you can make it and then
36:49 - you can pass what you have made into the
36:51 - ad function later on and this is going
36:54 - to add it to the scene and basically
36:55 - draw it so here because we're making
36:57 - this a utility function we're going to
36:59 - first make the map once the map is made
37:01 - we're going to pass it to the main which
37:03 - is going to call the ad function on it
37:06 - so make really works the same way as ADD
37:09 - it's just that it creates the game
37:11 - object but does not display
37:12 - it so here we're going to use the Sprite
37:16 - component and this is where you can
37:18 - Define what Sprite you want and here
37:21 - because remember in main.ts we defined
37:24 - this Sprite as being level-1 which is
37:26 - going to correspond to
37:28 - level.png and here we have the Json file
37:31 - for it level-1 Json which we get from
37:34 - here is going to give us the map data so
37:37 - if I look at the Json export you can see
37:39 - that you have layers and each layers has
37:42 - a data property if it's a a tile layer
37:44 - or an objects property if it's a
37:48 - um if it's a object layer which gives us
37:52 - X and Y coordinates you can
37:56 - use all right so here kme K Sprite
38:00 - Etc and K scale it's the scale component
38:04 - we're we going to use the scale so the
38:06 - scale of the the map so the Sprite uh
38:11 - accordingly we're going to also use the
38:13 - positional component so this is when you
38:16 - want to set the position of a character
38:19 - you can use or a game object you use a
38:21 - position component it it takes in two
38:24 - values but you can pass in only one if
38:27 - if it's this same value for both X and Y
38:29 - and here for now we just use the
38:32 - positional value and put it at 0
38:34 - 0 so that the map is drawn from the from
38:37 - 0 0 so x coordinate 0 y coordinate
38:43 - Z
38:45 - okay and now we're going to have to get
38:49 - the spawn
38:51 - points so here the spawn points are
38:53 - going to be uh X and Y coordinates
38:56 - they're going to the find what we need
39:00 - uh where to place the various enemies
39:02 - players and
39:04 - Etc and for now it's going to be an
39:06 - empty object because we're going to get
39:09 - this data from the map data but just get
39:11 - what we need and store it here so the
39:14 - typing for this is going to be an object
39:16 - of course but first we need to Define
39:20 - what the type of the key is going to be
39:21 - so the key is going to be a
39:23 - string and the value associated with it
39:26 - is going to be another object
39:28 - which is of the type number and Y also
39:31 - of the type
39:33 - number this is going to make sense in a
39:37 - moment all right so now let's iterate
39:41 - through the map itself map data so for
39:45 - that I'm going to create a for Loop
39:47 - const layer of map data.
39:51 - layers and if you've seen earlier on in
39:54 - the level one export you can see that we
39:56 - have this layer
39:57 - property that contains an array that
40:00 - contains all of our
40:04 - layers okay now what now that we have
40:08 - this
40:08 - done we're going to Simply have an if
40:12 - statement that checks the name of the
40:13 - layer so if the name of the layer is
40:16 - colliders we're going to Simply have
40:18 - another full loop cons
40:23 - collider of layer. objects
40:28 - so here basically as I told you if the
40:31 - type of the layer is a tile layer it's
40:34 - going to have the data property which is
40:36 - an array that tells us which tile to
40:39 - draw Etc we don't need this for this
40:41 - project because we have already
40:43 - everything drawn as a single PNG we just
40:45 - need to display that
40:47 - Sprite but for
40:49 - colliders for object type you have this
40:52 - objects property instead of the data
40:54 - property which is an array containing
40:56 - the list of objects that is in this
40:58 - layer which contains also the X and Y
41:01 - coordinates for each of those
41:04 - objects
41:06 - okay so now here for collider of so by
41:11 - using layer.
41:12 - name each layer has a name and this how
41:16 - we can differentiate them really easily
41:19 - so for objects which is going to be an
41:22 - array so for each element of that array
41:24 - so here the I'm just going to call it
41:26 - Collider
41:27 - we're going to add to the map so map was
41:31 - created as a game object by using the
41:33 - make it it isn't displayed yet but one
41:37 - thing in Kaboom J you can have children
41:39 - game objects and this is going to be
41:40 - handy here because we want to add to the
41:42 - map the the various
41:45 - colliders so the colliders are going to
41:47 - be game objects as well here you canot
41:49 - use the make function you can cannot do
41:52 - I don't think you can do this so you
41:54 - need to use the add function to add it
41:55 - as a child to the map and then once map
41:58 - is going to be called with the ad
42:00 - function from Kaboom then it's going to
42:02 - also draw the children of that game
42:05 - object so to create a hitbox we going to
42:07 - use the area component that defines a
42:10 - hitbox for you automatically but you can
42:12 - specify a sh a specific shape so here
42:15 - the shape I'm going to use new K rect
42:18 - Constructor and it takes in as the first
42:20 - pram the position relative to the game
42:24 - object it's a vector to and here
42:28 - it's just going to be 0 0 so a single
42:31 - value is enough now then you need to
42:34 - specify the
42:35 - collider the width and the height of
42:37 - that rectangle and this is provided in
42:39 - the uh tile Port if you look at the
42:43 - export here you can see that for this
42:46 - object we have the width and the height
42:49 - properties that's very handy because we
42:51 - can now really know where to put those
42:53 - boundaries
42:57 - okay so we also want to add another
43:00 - property inside of the uh area component
43:04 - there's this thing called Collision
43:06 - ignore and we want basically you pass in
43:09 - a tag and uh is going to know if if
43:14 - Collision should be ignored with a
43:17 - specific type of game objects so game
43:20 - objects can contain tags we haven't
43:22 - covered this yet but let's add them
43:24 - those are arbitrary names that I have
43:26 - defined that there is this platform tag
43:28 - and the exit tag which is for the exit
43:30 - door it doesn't really for now it's not
43:34 - created anywhere but it's going to allow
43:36 - us to differentiate our Behavior so just
43:39 - to explain here we're going to have a
43:42 - Turner restatement which is a basically
43:44 - condensed if statement if the collider
43:50 - name is not the actually I forgot to do
43:52 - this in til so let's go back to
43:56 - til so here in the our
43:59 - collider I forgot the collider for the
44:04 - exit so here I'm going to
44:10 - draw whoops not here so here select the
44:14 - collider you can make everything visible
44:17 - it doesn't matter and then draw this add
44:20 - at its name the exit which is going to
44:23 - allow us to know that this boundary
44:24 - corresponds to the exit of the level
44:27 - save and then if you go back to til if
44:30 - the collider name so now if I go here I
44:34 - can see that there is one of them that
44:36 - is going to contain the exit name so if
44:39 - the collider name is the
44:42 - exit is the
44:46 - exit uh is not the exit basically is not
44:49 - the exit we're going to
44:52 - add the
44:54 - component called B body and in Kaboom JZ
44:58 - this component allows us to have
45:01 - collisions affected by yeah collisions
45:04 - and if you specify within
45:07 - it that it is a static body is
45:13 - static and you set it to
45:16 - true
45:17 - then the the current game object here
45:20 - the child game object is going to be
45:22 - remain static and so that means that
45:24 - once the player uh collides with them
45:26 - it's not going to move so it's really
45:28 - useful for
45:30 - platforms and then here I put it null
45:34 - the reason I'm doing null here uh oops
45:37 - it's a question mark so the way it works
45:39 - is that if this condition is uh true
45:42 - then you go here if it's not true it's
45:45 - null that means we add nothing no
45:48 - components to our list it's going to add
45:51 - no basic and which does nothing
45:57 - here regardless of the situation we
46:00 - Define the the position and it's just
46:02 - going to be collider X collider y
46:05 - nothing
46:07 - fancy and uh that's uh basically it
46:10 - right and finally a last
46:13 - thing this is where we add the tag
46:16 - actually so if the collider name is not
46:19 - equal to
46:22 - exit then this current game object that
46:25 - is being this collider that is being
46:26 - being added to the map is going to have
46:29 - the tag platform so the way you create
46:31 - tags in Kaboom is just a string that you
46:34 - attach that you add to your array of
46:36 - components and the way it's useful is
46:39 - it's useful because later on you can
46:40 - have event handlers and you just listen
46:43 - on a tag to know if this game object has
46:46 - collided or a class of g a group of game
46:49 - object game objects have collided with
46:53 - another otherwise we okay so if the
46:56 - collider name is not equal to exit and
46:59 - don't forget the comma here we give the
47:02 - game object the
47:04 - platform property uh not property
47:09 - tag so okay just to recap if the
47:13 - collider name is not the exit that means
47:17 - that we can give the tag the platform
47:20 - tag to the current game object Cur
47:22 - current collider we created as as a game
47:25 - object otherwise we can give exit
47:28 - tag and this is going to be y later on
47:32 - really handy okay now that we have this
47:35 - I think we have everything we
47:37 - need and uh yeah so we can continue here
47:42 - so if after doing all of that so it was
47:46 - the collider actually continue can be
47:48 - outside of the for Loop and otherwise
47:51 - it's useless so here
47:55 - continue so if the four Loop okay so if
47:58 - the first if statement is true there's
48:00 - no point in going further we just move
48:02 - to the next iteration the next uh uh
48:05 - layer and now here if the layer. name is
48:10 - the
48:11 - spawn points this is where we're going
48:14 - to have a for Loop const spawn point of
48:20 - layer doobs for that specific
48:25 - layer and then
48:27 - and we're simply going to have another
48:30 - if statement if the spawn
48:33 - point if the spawn points um object we
48:37 - created
48:38 - here has has a spawn point. name okay so
48:43 - basically the way we're doing this is
48:45 - that if the the the property the spawn
48:49 - point name is already defined so the
48:52 - spawn point name is going to be the name
48:55 - here so player we're going to have an
48:58 - object that is going to have all the
48:59 - keys so this point points you can use
49:03 - the key for example player and it's
49:04 - going to give you the position of the
49:05 - player can you use the key guy is going
49:07 - to be the the position of the guy mob
49:09 - and we're making this and here this
49:11 - first if statement checks if it already
49:14 - exists in case it already exists we're
49:16 - going to Simply add to the the spawn
49:20 - points so spawn point so that assumes
49:23 - that there is an array we're going to
49:26 - create we going to write the condition
49:28 - below of if the spawn points uh for the
49:32 - specific key does so if the key doesn't
49:34 - exist in the specific uh in in the spawn
49:37 - points object then we're going to just
49:39 - create an empty going to create an array
49:42 - and then in that array we're going to
49:44 - put the uh the
49:47 - position because we can have more than a
49:50 - single flame guy a single guy mob or a
49:53 - single bird this allows us to be
49:55 - flexible so if spawn point dot uh things
50:00 - going to make make sense hopefully in a
50:02 - moment I'm going to
50:04 - push to that array that we assume that
50:07 - there is an array with X spawn point
50:12 - dox Y is going to be spawn point
50:16 - doy and then we're going to
50:19 - continue to the next iteration because
50:21 - there is no point in going further now
50:23 - if if the the key did not exist that
50:26 - mean it's the first time we going to
50:27 - have to create it so we're going to do
50:29 - this spawn point spawn point
50:32 - sorry and then spawn
50:36 - point. name equal an array X is going to
50:41 - be
50:43 - spawn point dox Y is going to be spawn
50:48 - point
50:50 - doy and here here it makes all the
50:53 - difference it's because we created a
50:55 - what's the issue ah we need to
50:59 - um uh what did I
51:03 - miss did I miss
51:05 - something
51:10 - um um okay so we have spawn point. name
51:14 - and then we push and then push does not
51:17 - exist on the type I messed up I messed
51:20 - up in the typing gear it's an array okay
51:24 - so so it's an array of objects like this
51:27 - you need to add this
51:29 - bracket so now the typing should work
51:33 - okay we have everything we need so just
51:35 - to recap again sorry if it's getting
51:39 - repetitive if the key exists already in
51:42 - the SP points object then we just add to
51:45 - the currently existing array that we
51:47 - assume exist if it wasn't the case then
51:49 - we create that array and P pass in the
51:52 - first uh the first uh member of that uh
51:56 - spawn point name so yeah okay we have
52:00 - everything uh we need and then finally
52:02 - at the
52:04 - end so right below here we're going to
52:08 - return two things we're going to
52:12 - return return the map and the spawn
52:16 - points object those two things are very
52:20 - important and that's it so we can go
52:23 - back to main.ts
52:28 - and right before we enter the
52:32 - scene so after having loaded the Sprite
52:35 - we're going to
52:37 - call um yeah I'm going to call
52:42 - map so the map here is going to be
52:44 - called level
52:46 - layout and the spawn
52:49 - point spawn points going to be the level
52:53 - one
52:54 - spawn point
52:57 - and it's going to be getting this from
52:59 - await that's why a sync was needed and
53:03 - then make map it's going to import this
53:07 - automatically we need to pass in the
53:10 - context and the name which is
53:14 - level-1 now one thing I want to cover is
53:17 - this uh you might not be familiar with
53:19 - this notation what it does is it renames
53:22 - the map and spawn points properties to
53:25 - being level one layout and level one
53:27 - spawn points this is going to be handy
53:30 - because when we're going to have to have
53:31 - two levels we're going to have level two
53:33 - layout level two spawn points and
53:36 - because it always the make map function
53:38 - always returns a map and spawn point
53:41 - properties if we were to keep the same
53:43 - names it would make things uh difficult
53:46 - for us so that's a a JavaScript syntax I
53:50 - don't think it's very common I haven't
53:52 - seen this much beforehand so in case you
53:55 - were like me and and you didn't know
53:57 - what this me
53:58 - meant yeah you now you know all right
54:02 - so let's draw our map so right below in
54:06 - the scene you can do k. add and just
54:10 - pass in the level one layout as I
54:14 - explained and this should draw the map
54:18 - the the image so let's look at the
54:21 - result voila you can see it drawn but um
54:26 - you know
54:26 - you can't see the can't see it fully for
54:28 - now but it works all right so before
54:31 - moving on let's uh actually write
54:34 - everything we need for the player the
54:36 - mobs Etc and then then we're going to
54:38 - come back here to main.ts and add them
54:41 - with the spawn points
54:42 - Etc so to do something like that go to
54:45 - entities. TS and let's write the logic
54:48 - so let's first write a function that is
54:50 - going to be responsible for creating our
54:53 - game object for the player to do
54:56 - something like that same pattern first
54:58 - we pass in the context it's going to be
55:00 - a kaboom context so Kaboom Kaboom
55:04 - context so the typing comes from Kaboom
55:06 - as well that's pretty handy then what
55:10 - we're going to need is to specify a
55:12 - position X which is going to be a number
55:15 - a position Y which is also going to be a
55:19 - number once we have all of
55:21 - this oh well my my my L uh yeah
55:27 - so
55:29 - now we're going to create a constant
55:31 - within call it player and call the K
55:33 - make function that I explained earlier
55:36 - on and here we're going to have a couple
55:40 - of components just to make things fast
55:44 - I'm going to copy and paste it copy and
55:48 - paste everything we need here and then
55:49 - go over line by line so of course we
55:52 - need the scale so import this from from
55:56 - this uh constants like
55:59 - that okay so what do we have here we
56:04 - have the Sprite component that uses the
56:07 - asset Sprites if we go here we named all
56:09 - of these assets and then here optionally
56:13 - the Sprite component can take a second
56:15 - param which is an object and you can in
56:18 - that object specify the anim property
56:20 - and specify which animation you want to
56:22 - play by default and we want to play the
56:25 - curb idle which is you know the name of
56:27 - the character it's frame
56:29 - zero then we create an area component uh
56:32 - we use the area component to create a
56:34 - hitbox with the following shape it's a
56:37 - rectangle with a width of eight and a
56:41 - height of 10 and here it's going to be
56:44 - positioned at x value 4 and Y value 5.9
56:49 - relative to the Sprite this is so the
56:53 - character doesn't look like it's sinking
56:55 - in the platform you we you need to um
56:58 - put the hitbox in such a way that it's
57:01 - going to make the the character look all
57:03 - right as if it's on the platform
57:05 - normally uh this is a bit hard to
57:08 - explain uh without uh visuals so let's
57:12 - first write this out and then while
57:14 - you're going to open the debug mode
57:15 - you're going to see everything
57:17 - everything is going to make sense k.
57:19 - body here component so that uh the
57:21 - player can be collide with others other
57:25 - game objects and and be affected by
57:27 - gravity uh the position is going to be
57:29 - the position X past here but we need to
57:31 - multiply by the scale and the position y
57:34 - as well we need to also multiply it by
57:36 - the scale so that it is placed at the
57:38 - right
57:40 - position a scale component that calls
57:42 - the scale constant uh this is to scale
57:45 - the Sprite and uh yeah so scale the
57:47 - Sprite so the the the the character
57:51 - takes the correct amount of space uh the
57:53 - double jump um component is something
57:56 - from Kaboom that you can specify a
57:58 - double jump and how much jumps you want
58:00 - to allow so 10 jumps so that it looks
58:03 - like the the floating from Kirby but
58:05 - it's not unlimited and it's very easy
58:08 - you just use that component it's for
58:10 - free so we don't have to write extra
58:12 - code to implement the feature of
58:13 - floating so that's really great the
58:15 - health component allows us to specify
58:17 - some health value and then you can use
58:19 - the HP function method and the HT
58:22 - function to know and the heel function
58:25 - as well to heal the life points Etc so
58:29 - this is something that is handy in
58:30 - Kaboom JZ and the opacity is going to be
58:32 - set to one we use the opacity component
58:35 - uh setting it to one means that it's
58:36 - fully visible this is going to be useful
58:39 - when the player is going to get hit
58:41 - we're going to temporarily reduce the
58:43 - opacity to zero so that it looks like
58:45 - it's flashing and here this is some A
58:48 - New Concept
58:51 - whoops is that in Kaboom JS you can pass
58:55 - objects
58:57 - as uh as well as your components so
58:59 - objects going to contain properties that
59:01 - going to be accessible immediately from
59:04 - within the game object so if you do
59:05 - player dot you can access the speed
59:08 - direction is inhaling and is full those
59:10 - are arbitrary properties that I needed
59:13 - for the game so the speed is to really
59:15 - control the speed the direction for
59:16 - where the the Sprite is looking it's
59:19 - going to be used for that is inhaling is
59:21 - going to be a Boolean and is full as
59:23 - well that are going to be used to know
59:25 - when to allow for uh certain uh for the
59:29 - enemy to be swallow swallowed or not or
59:31 - inhaled Etc and finally the player tag
59:34 - is going to be useful I think I'm using
59:36 - it later on to to do the on collision
59:39 - logic to know if it collides with an
59:43 - enemy what to do what we need to do
59:46 - though right after I'm going to use
59:48 - player.on Collide method that is
59:52 - available if you use the body component
59:54 - in the I think the area component
59:56 - and then as the first param you specify
59:58 - the tag of the other game object you
60:01 - want to test collisions with or listen
60:03 - to collisions with and it's going to be
60:04 - the enemy we haven't created any enemies
60:07 - yet that's normal and when we're going
60:09 - to do it we're going to add the uh the
60:12 - enemy basically uh the enemy tag to the
60:15 - to th those game objects now here the
60:18 - assing function we're going to need an
60:20 - async function for multiple reasons uh
60:24 - mainly I think uh actually do we
60:27 - actually need a sync function here yeah
60:29 - we're going to need it because we're
60:30 - going need to F to make the player Flash
60:33 - and back and forth and we going to use a
60:35 - tween for that and it's much it gives us
60:37 - much more cleaner code if you we use the
60:39 - tween the await uh syntax and here
60:43 - what's handy with the on Collide is that
60:45 - you can have the enemy game object
60:48 - passed into to your function here so the
60:50 - second function is what runs when there
60:53 - is an actual collisions With the Enemy
60:55 - so if you have here I think enemy and
60:58 - then here we're going to type it as a
61:00 - game
61:02 - object and here we need to
61:05 - import a quick fix import this type from
61:10 - Kaboom and yeah so we are ready to write
61:12 - the the content of it so if so here
61:16 - again I'm just going to go
61:20 - faster so here is the first if statement
61:23 - if the player is inhaling
61:26 - and the enemy is inhalable you're going
61:28 - to see this is going to be a property
61:29 - we're going to create later on when we
61:31 - going to create the
61:32 - enemies then what we do is we set the
61:35 - inhaling to being false we destroy the
61:38 - enemy that means that the player inhaled
61:40 - the enemy so much that they it collided
61:43 - with the player and that means that
61:45 - means it's swallowed so we can destroy
61:48 - the Enemy by calling the destroy Kaboom
61:51 - function where you pass in a game object
61:53 - to be destroyed and then player is full
61:56 - is going to be true and this is going to
61:58 - allow us to play another animation and
62:01 - the one where the the Kirby Kirby like
62:03 - character is seen as full and also is
62:05 - going to allow us to know if the player
62:08 - can now shoot a
62:09 - star the second if statement we're going
62:12 - to need comes right after
62:15 - and it's going to be this thing um now
62:18 - here Global game State we haven't
62:20 - created this for now so let's replace
62:23 - this with
62:24 - level go to level
62:27 - two for now we haven't even like put I
62:31 - created the level two as well I'm going
62:33 - to use the original what I've already
62:35 - had in the original code base to go
62:37 - faster because I think you get the
62:40 - point so if the player HP so HP is a
62:43 - method that is available since we have
62:45 - used the health component in when
62:48 - creating the player object and if it's
62:51 - zero that means the the player is
62:53 - dead so in the case we it was inhaling
62:57 - or the enemy was and the enemy was
62:59 - inhalable we would return early here so
63:01 - the the enemy would be destroyed but
63:03 - this is when the character the player
63:05 - hits the Enemy by accident or the enemy
63:09 - jumps on the player or something like
63:10 - that then if the HP is zero then we
63:14 - destroy the player and then we go back
63:16 - to actually we should go back to level
63:17 - one because we respawn so we go back to
63:20 - the current level and then we return
63:24 - early and then regardless uh so
63:29 - if if this continues that means that the
63:31 - player HP isn't uh equal to zero that
63:34 - means we need to hurt give damage to the
63:36 - player so by using the hurt function
63:38 - it's going to reduce one HP by default
63:41 - and then you can specify a number if you
63:42 - want to reduce more or
63:44 - less and then here is the logic that
63:48 - we're going to use for uh making the
63:51 - player flash uh blink we're going to use
63:54 - a first a tween so a tween allows you to
63:58 - change gradually a value from one value
64:01 - to another and here we're going to use
64:04 - await because we want the tween to be
64:06 - completed before we move on to the next
64:08 - tween so here what this tween is going
64:11 - to do is it's going to take the opacity
64:14 - of the player the initial opacity and
64:16 - the target value is going to be zero and
64:18 - the time we want to give to the tween to
64:22 - basically transition the player opacity
64:25 - from one to Z so because currently it's
64:29 - one it's going to be done in 0.5 seconds
64:32 - and this is the function that does the
64:33 - job basically of grad so every I think
64:37 - frame it gives you a new value and this
64:40 - value is set as the opacity so for
64:42 - example it's going to go from one uh 0.9
64:46 - 0.7
64:48 - 0.8 uh no 0.7 0.5 Etc until zero and
64:53 - this is where you assign it this value
64:55 - to the new value of opacity can do this
64:57 - do opacity and then finally the last
65:00 - progam is what is the rate of change so
65:03 - it's going to follow a linear function
65:06 - so it's going to be done linearly and
65:09 - here once this is done because we have
65:11 - an await because this is asynchronous by
65:14 - default so if you were to not use the
65:16 - await you could call this and then the
65:18 - code is going to continue to execute
65:20 - while this is still running so to avoid
65:23 - this we first await that the tween is
65:26 - done so we have our opacity that goes
65:29 - from one to zero and then once this is
65:32 - done we have our opacity going from zero
65:35 - to one so this is going to give you the
65:37 - blinking effect so that's basically it
65:41 - now we have finished the on Collide
65:43 - logic here for now we're going to have
65:45 - to come back here later on to change uh
65:48 - here to not hardcode this but for now
65:51 - it's fine now what comes next is another
65:54 - uncollided but this time around with the
65:57 - exit and this is the exit door we have
65:59 - created the exit collider and here it's
66:01 - going to again I'm going to replace this
66:03 - it's going to go to the next scene so on
66:06 - collide with the exit we just use the go
66:09 - function from Kaboom to go to another
66:11 - scene and by passing it the
66:15 - name and then now it's time to do the
66:17 - whole inhaling
66:19 - mechanic so to uh do this what we need
66:22 - to do is create our inhaling effect
66:26 - so this is the the sprite animation that
66:29 - you saw earlier on that gives the
66:31 - impression that the Kirby character is
66:33 - swallowing something and inhaling
66:36 - something and it's a game object that
66:39 - uses the AET Sprite but the specific
66:41 - curb inhale effect animation as default
66:44 - it has a position a scale the same scale
66:46 - and the opacity initially is zero and we
66:48 - give it a tag what we're going to do is
66:50 - that this animation is always playing
66:52 - but we just tweak when it is visible or
66:55 - not depending on the situation depending
66:57 - on the player
67:00 - input and then here what comes after is
67:03 - the inhale Zone the inhale zone is a hit
67:07 - box that is not visible it just contains
67:09 - an area component with a given shape
67:11 - which is going to be a rectangle and
67:14 - what this inhale Zone does it will allow
67:16 - us to know U when the player can
67:20 - actually swallow an enemy and here again
67:22 - we give it a tag those are going to come
67:24 - uh later on we keep an empty position
67:27 - here because we're going to decide on
67:29 - the position depending on the direction
67:31 - of the player and this is what this next
67:33 - bit of logic does so
67:38 - here so here we have an inhale Zone
67:41 - onupdate function so you can use the
67:43 - onupdate method on every game object and
67:46 - it's even a function that is can can be
67:48 - called independently what it does it it
67:50 - runs it registered an event that runs
67:52 - every frame as long as the game object
67:54 - exists in this particular form and what
67:57 - it does is that if the if the player
68:00 - direction is to the left we need to
68:03 - place the inhale Zone to be Min
68:06 - -4 to 8 and because remember that the
68:10 - inhale Zone and the yeah just the inhale
68:12 - zone is a CH is a child yeah is a child
68:16 - so because the inhale zone is a child of
68:19 - the player that means the position here
68:21 - that is specified here is relative to
68:24 - the player to the parent that's that's
68:27 - why it's going to be minus 14 plus the
68:30 - position of the of the the player which
68:32 - is the parent but we don't need to worry
68:34 - about that and here we can specify the
68:37 - position we can replace the position by
68:39 - doing equal and then passing in a vector
68:41 - 2 which is just an X and Y a a data
68:45 - structure for having X and Y values and
68:48 - a single structure yeah this is offered
68:51 - by Kaboom but it's a pretty standard in
68:54 - game development here the inhale effect
68:56 - position we're also going to Mo modify
68:58 - it but because the reason here is that
69:01 - the the inhale effect is not a child of
69:03 - the player and the reason for this is
69:05 - simply because uh we need to be able to
69:09 - make it to hide it or not and it seems
69:13 - that in kabum Jaz you cannot hide a
69:15 - child so reduce the opacity of the child
69:18 - without reducing the opacity of the
69:19 - parent so that's why I need to manually
69:22 - do a player position x minus a certain
69:25 - Val value and player position y plus a
69:28 - certain value to get the actual position
69:30 - I want the inhale effect to be in when
69:32 - the player is facing left and it y
69:37 - say yeah uh in inhale effect uh we need
69:41 - to flip X so the animation by default is
69:46 - drawn a from the right side so if you
69:49 - look at it
69:52 - here from the actually it's from the
69:54 - left side
69:55 - but we need to
69:57 - specify wait a minute
70:01 - so it's it's bit hard to explain but
70:03 - basically we need to flip the animation
70:05 - so if it's uh on the left side we need
70:08 - to flip it to being true and on the
70:12 - other end which is basically logic that
70:16 - comes after here we just do false so so
70:19 - that it goes to the the other direction
70:22 - or the default Direction which is the
70:23 - from the right the swallowing is from
70:26 - the right or the left I don't remember
70:30 - actually and then finally those are the
70:33 - last portion of code we need for the
70:36 - player here again I'm going to avoid
70:39 - this for now let's put level respawn at
70:42 - level one so here an on another on
70:45 - update but this time for the player
70:48 - specifically uh if the player position.
70:50 - Y is superior to 2,000 that means uh in
70:52 - the canvas the more you go down the
70:55 - higher the value of y so here what it
70:58 - essentially is doing is that if the
71:00 - player Falls and exceeds this value then
71:03 - we respond the player so basically it is
71:06 - considered dead we respond the player by
71:08 - just going back to the scene which
71:09 - resets everything the state of
71:11 - everything so we don't have to worry
71:13 - about resetting Val uh Health Etc so it
71:16 - does this automatically and then finally
71:18 - we return the player in the the function
71:20 - make player so this is how we get a
71:23 - player and I think we're ready to just
71:25 - test it out to see if uh what happens so
71:30 - in the main right below here right below
71:36 - the
71:37 - ad let's create our curb character
71:41 - here's the code for it so here we call
71:44 - this I'm going to import don't forget to
71:45 - import it and then you pass in the K and
71:48 - then level one point points player use
71:51 - the player key and then there's only one
71:54 - player so it's going to be at index zero
71:57 - because if you remember uh the spawn
71:59 - points are for each key it's an array
72:02 - even if there is only one because there
72:03 - is the case where there is more than one
72:05 - so instead of having to check when it's
72:07 - an array or not we just assume that it's
72:08 - an array all the way and if you know
72:10 - that there's only one player you just do
72:12 - a zero uh pass the index zero and it's
72:15 - going to give you just the the single
72:17 - player position X and
72:18 - Y now for the actually we should have
72:21 - set the controls but let's do that later
72:24 - now here let's add the curb corrector to
72:27 - the scene because remember in make
72:28 - player we just use the make Kaboom
72:30 - function not the ADD and let's write
72:33 - some Logic for the camera so the camera
72:36 - is really automatic in Kaboom J you
72:39 - there's only a few things you can do uh
72:42 - so you don't have to write a lot of
72:44 - logic in the sense that sense so here
72:47 - you can specify the scaling of the
72:49 - camera so we want to have it at 0.7 this
72:51 - is what looked good for both X and Y
72:54 - coordinates so here it's
72:56 - either either you repeat actually in the
72:59 - end it's the same so you could have
73:02 - decided to write
73:04 - 0.7 by
73:07 - 0.7 which is actually shorter to
73:10 - write and then for the on update
73:13 - function this is an on update that is
73:15 - General so if you see here register an
73:17 - events that runs every frame not until
73:20 - the the object is destroyed because it's
73:22 - not attached to any object and here
73:25 - we're just going to make the charact the
73:27 - camera follow the player in a certain
73:29 - way so if the the position of the curb
73:33 - character the player curb. p.x this is
73:36 - how you access the position is inferior
73:38 - to the level one layout. p.x so the um
73:43 - basically where the level start plus 432
73:46 - pixels this is what look good as long as
73:48 - it's inferior to that we want the camera
73:52 - so by using the Campa method uh function
73:55 - to be set at the camera the curb pos. X
74:00 - plus 500 and then at the height of 800
74:03 - so the the y coordinate of 800 this is
74:06 - going to allow the camera to follow the
74:09 - player along a certain point and not
74:11 - exceed that point uh because if it
74:13 - exceeds that point then you're going to
74:15 - see the end of the level or basically
74:19 - way for you to avoid having to show more
74:21 - than what you want to show in the level
74:23 - so if you're at the end of the level you
74:24 - don't want to the player
74:26 - to to look very far to the right for
74:29 - example and here we add the position of
74:32 - the player plus 500 so that the camera
74:35 - is really the player is going to find
74:38 - themselves to the left side of the
74:40 - screen and they're going to be more
74:42 - space available on the right side so
74:45 - that the player can see further along
74:47 - this is something that uh it's really
74:49 - handy especially if you're making a
74:51 - Sonic type game because you want the
74:52 - player to be able to see uh as as far as
74:55 - possible for this type of platform it's
74:57 - not that necessary but I thought it
74:59 - looked better so now let's look at the
75:01 - result I'm curious to see if there's
75:02 - anything is anything going to change all
75:05 - right we can see our level but now we
75:07 - don't have the movement control uh
75:09 - movement controls and this is what we're
75:11 - going to deal with in an instant okay so
75:14 - now that we have the camera working and
75:18 - the character being displayed I think
75:20 - it's best to just uh start working on
75:22 - implementing the player controls so that
75:24 - we can truly see if the camera is
75:27 - actually working so by player controls I
75:29 - mean all the mechanics of the Kirby so
75:32 - moving swallowing floating Etc to do
75:35 - something like that I'm going to go to
75:37 - the entities folder uh file sorry not
75:40 - folder and in there we're going to
75:43 - create a function right below so this
75:46 - function is going to be called export
75:51 - function set controls and it's going to
75:55 - take two things the context as
75:59 - always but it will also talk uh take the
76:03 - player object now here I could have
76:08 - simply gone with the game object here as
76:12 - the typing but we want it to be
76:14 - specifically for the player so this is
76:17 - where a new type we're going to create a
76:19 - new type so the way you can go about
76:22 - creating types is either you create them
76:25 - all in a folder in a specific file and
76:27 - then you pull them out from there or you
76:30 - create them where we need them and
76:34 - really here in this project the the
76:37 - current state of the project I might
76:39 - expand the game later on but on my own
76:42 - but for the tutorial uh really we're not
76:45 - going to export any typing really
76:48 - there's only this type and you could
76:51 - have decided not to use it but I think
76:54 - it's it's best pra like it's a best
76:56 - practice to create a specific type for
76:58 - the player because there are some
77:00 - behaviors like you're expecting that the
77:02 - game object past here in the set
77:04 - controls function is going to have some
77:07 - components uh some some necessary
77:10 - components so the way you type uh a game
77:14 - object in Kaboom Jaz you can take the
77:18 - default game object type and then add to
77:21 - it here the various components you need
77:25 - so we want the following so I'm just
77:27 - going to copy and paste it and then talk
77:28 - over the content so this is going to go
77:30 - much F
77:32 - faster so here is the typing definition
77:35 - now all of these need to be imported
77:37 - from Kaboom so update import from kboom
77:42 - uh I should have just clicked here and
77:44 - I'll add all missing
77:47 - Imports all right so to explain so the
77:50 - player game object is a is a type that
77:54 - is a game object that has the Sprite
77:56 - comp component the area component the
77:58 - body component the positional component
78:00 - the scale component the double jump
78:02 - component the health component and the
78:04 - opacity component and it has the
78:05 - following properties the speed the
78:07 - direction is inhaling and is full
78:10 - Boolean and this in make player you can
78:12 - see that those are were the properties
78:13 - here so the goal of this is that if so
78:18 - somehow you were to use this set
78:21 - controls on a mob for example which is
78:23 - just a regular game object
78:25 - then you would have squiggly lines and
78:27 - typescript will tell you that hey you're
78:29 - not entering the correct type so I'm
78:31 - just going to put player game object
78:32 - here and now let's write the body of
78:35 - this set controls
78:37 - function so let's do that give me a
78:40 - second okay so first of all what we need
78:44 - is actually um I need a reference to the
78:49 - inhale effect that we had so I'm going
78:52 - to create a constant called inhale
78:55 - effect ref which is this uh here in the
78:58 - original code base that we had and this
79:02 - is a way to to neatly get any game
79:06 - object you need is you pass in the tag
79:08 - to the get function from Kaboom here
79:11 - inhale
79:12 - effect and it will return an array
79:15 - containing all the game objects that
79:18 - have this tag so here we only have we're
79:21 - expecting one so I'm just going to take
79:23 - the one at index zero
79:25 - this is going to be useful because here
79:27 - in the controls in the input is where
79:30 - we're going to decide whatever or not to
79:31 - show the inhale effect of the Kirby like
79:35 - character so really we need to
79:40 - start coding the player
79:42 - movement the way you do this in Kaboom
79:44 - is by using the Onkey down function and
79:48 - it passes to you the key that is being
79:51 - pressed so here I could just have a
79:53 - switch case statement so
79:57 - switch K here key here you could have
80:00 - left it as an if but it's more concise
80:03 - to use a switch case statement it's a
80:05 - matter of preference so also sometimes
80:07 - it's clearer to just use if statements
80:10 - so for the left case we're going to
80:12 - first set the direction of the player
80:14 - like this since we uh previously decided
80:19 - that those are the properties we we
80:21 - needed and because we created them we
80:25 - added them here they are available to be
80:27 - modified in red here and as long as you
80:31 - have access to the game object for the
80:33 - player so here we're going to change it
80:35 - to
80:37 - left or set it to left regardless of
80:40 - what the previous Direction was we're
80:42 - going to flip the
80:44 - player horizontally by using the flip X
80:48 - property this is offered by Kaboom if
80:51 - your game object has a Sprite uh users
80:54 - the Sprite component so we're going to
80:56 - have true set it to True here regardless
80:59 - and then finally to move the player it's
81:01 - in kabj it's really simple you call the
81:03 - move function and passes in a velocity
81:07 - an x velocity or a y velocity here we
81:10 - just pass in the player speed and Y
81:12 - velocity is zero so the player is going
81:14 - to move here to the right but you have
81:17 - to do minus to get to the left this is
81:19 - very
81:20 - simple and then you of course you have
81:22 - to break otherwise the other cases are
81:25 - going to run this is something like in
81:26 - JavaScript I don't think in other
81:28 - programming language it's the
81:30 - case now we have the right
81:34 - case and it's basically going to be the
81:37 - same thing so I'm just going to copy and
81:40 - paste but just different values
81:43 - here and then after that we have the Zed
81:46 - case uh the the case z when the player
81:49 - presses the Z
81:53 - key this is where we're going to uh
81:57 - basically make the character
82:00 - inhale so simply within this we're going
82:03 - to have an if statement if the player is
82:07 - full then we need to play the the curb
82:13 - full
82:14 - animation curb full
82:18 - animation once this is played or is
82:21 - playing we can show the inhale effect
82:25 - uh no actually hide the inhale effect by
82:29 - setting the opacity of the inhale effect
82:31 - ref to zero if it were
82:33 - visible and then we break
82:37 - here and then in here and then right
82:41 - below we we are still in the Z
82:43 - case if that was not true so the player
82:46 - was not full that means it's time to let
82:48 - the player inhale so is inhaling is
82:50 - going to be set to true
82:56 - and
82:58 - then we're going to play by calling the
83:02 - play
83:04 - function the curb oops
83:10 - curb
83:12 - inhaling that's the name of the
83:14 - animation and we're going to show the
83:17 - opacity so uh we're going to set the
83:19 - opacity to one so that we can show the
83:22 - inhale
83:23 - effect so now that we have this we simp
83:26 - we can break for real as well here and
83:30 - then we need to when using a switch case
83:32 - statement to have the default which is
83:35 - going to be empty in this
83:37 - case so now we should be able to move
83:40 - left and right let's let's look at it so
83:44 - if I use if I maybe should refresh the
83:48 - page oh I haven't called it so so it's
83:51 - it's not going to work so if I go to
83:53 - main.ts and I
84:00 - go right be before adding it to the
84:03 - scene that's called the set controls
84:05 - function it should be imported
84:07 - automatically and pass in the curb
84:12 - character uh of course the context first
84:15 - as
84:16 - well now if we look at the
84:19 - result I should be able to move and then
84:21 - when I press uh Zed
84:25 - I'm making the sound effect but but for
84:27 - now you see that even if I left um I
84:33 - stopped pressing the key Zed key the
84:36 - animation is still going on because we
84:38 - need to have a Handler that checks when
84:41 - we release a key as well and by the way
84:43 - if you press F1 you can see the various
84:45 - collisions
84:47 - here so yeah let's go back to the code
84:51 - base let's go back to the entities code
84:55 - and here I'm just going to collapse the
84:57 - Onkey down
84:59 - function now
85:01 - Onkey press this let's implement the
85:03 - jumping first I think and then we'll
85:07 - go we'll go with the the
85:11 - Onkey
85:12 - release so here same logic we pass in
85:16 - the key oops not page transition you
85:20 - know what I'm just going to copy the
85:21 - code just to be fast
85:24 - and then talk over it maybe I should
85:27 - start just doing that for all
85:29 - tutorials so key on key press we have
85:33 - the key here here uh this feels like
85:37 - unnecessary code you could have just
85:40 - have a simple if statement I'm going to
85:43 - leave it though in case you want to make
85:46 - multiple allow multiple characters to be
85:49 - used for jumping and here we can use the
85:51 - double job double jump method and the
85:54 - reason we can use that is because we
85:56 - used when defining the
85:58 - player game object the double jump
86:01 - component so this is what allows the
86:03 - Kirby like character to float to jump 10
86:07 - times
86:09 - basically okay now here it's time to do
86:13 - the on key
86:16 - release
86:17 - so on
86:21 - key release
86:26 - here we go and then again here it's a
86:30 - switch statement I don't remember if
86:33 - it's going to be that much useful it's a
86:35 - single case you know what just to make
86:38 - the code better you know if key equal
86:43 - equal x let's remove all this
86:46 - unnecessary stuff let's not over
86:49 - optimize or yeah and even this is not
86:52 - necessary
86:56 - and then I of course need to remove that
86:57 - for the the linting the the formatting
87:01 - sorry to work so here if the key you do
87:04 - this actually
87:07 - um yeah anyway yeah there could be say
87:11 - that the switch case statement syntax is
87:13 - not that uh concise so
87:17 - yeah okay so on the on key release we
87:20 - have the key and then here I'm going to
87:22 - use a if statement instead of a a switch
87:23 - ke
87:24 - again and here if the Z key is
87:27 - pressed we're going to do a bunch of
87:29 - stuff so here if the Z key is
87:33 - pressed and we have another if statement
87:37 - usually I don't like that having a
87:39 - multiple ifs within let's keep it as is
87:42 - for now and I'm going to see if if it
87:45 - makes the code any more difficult to
87:47 - understand or if it can be improved
87:48 - later on so if the player is full we do
87:51 - something so we need to play
87:54 - the
87:57 - curb
88:00 - curb inhaling so the reason we're
88:04 - playing the curb inhaling animation when
88:07 - the key Z the Z key is released if the
88:09 - player if the player was full that mean
88:11 - they swallowed an enemy is because the
88:15 - animation so the image for
88:17 - both uh swallowing inhaling and um say
88:24 - shooting or spitting out the enemy the
88:26 - the star is going to be the same I
88:28 - thought it would work for both cases so
88:30 - that's why it's playing this animation
88:33 - here okay
88:37 - now let's do a const here and call it
88:40 - shooting star and this is going to be a
88:43 - game object that basically the
88:45 - projectile the star we're going to
88:47 - create it it's a disposable game object
88:49 - we just created here and we write
88:51 - everything we need for it here no need
88:53 - for mod rizing though uh if you if you
88:57 - were to expand this game and maybe make
88:59 - you know what what a good exercise you
89:01 - could do with this is try to make the C
89:05 - implement the copy abilities of Kirby so
89:08 - Kirby in except for the first game not
89:11 - only can he inhale enemies and throw
89:13 - stars and stuff like that but can inhale
89:15 - enemies and then use their powers so
89:18 - become a fire Kirby
89:21 - Etc okay so for shooting stars uh yeah
89:24 - we just going to need a to use the
89:29 - Sprite
89:31 - component and here the animation we're
89:34 - going to specify is
89:38 - shooting star I think we already defined
89:41 - it earlier on and we can also set the
89:45 - flip value so the direction from which
89:48 - you want the animation to play Within
89:50 - the second param because this is very
89:53 - disposable and we want need to change
89:54 - the direction afterwards because what
89:57 - happens is the projectile is uh shot and
90:01 - then it just goes to the and as soon as
90:03 - it either hits an enemy or a wall it
90:06 - will destroy itself so here we can do a
90:09 - simple depending on the player direction
90:12 - if the player direction is equal to
90:15 - right then this expression will evaluate
90:19 - to
90:19 - true and if it evaluates to true that
90:22 - means we need to flip X so that mean
90:24 - we're going to flip the start to be at
90:27 - the right direction because by default
90:29 - it is uh to the left like
90:33 - that and that's basically it I think
90:37 - yep now we can continue
90:40 - on so k. area here going to have a shape
90:46 - now here you can tweak these values so
90:49 - I'm just going to copy over the code
90:52 - that we need
90:54 - uh if it's at all
90:57 - possible uh let me just copy the whole
91:01 - thing so I'm going to copy the just the
91:03 - rest of the the code for this game
91:06 - object and I'm just going to go over it
91:08 - so here we have a specific shape which
91:12 - is a rectangle with this offset and then
91:14 - 6X six Etc by the way if we look at the
91:17 - the output and I press the F1 key you
91:19 - can see the the Box the hit box for the
91:22 - Cur Kirby like
91:25 - character so here and uh depending on
91:30 - how you position the
91:32 - Sprite I made sure to position the
91:34 - Sprite a bit above that's why the offset
91:37 - here was a certain value I think it was
91:40 - where it was where it was 4X
91:43 - 5.9 play with those values and you're
91:45 - going to see what happens and get a
91:48 - better understanding than me trying to
91:49 - explain it to you with
91:51 - words okay so we have the shap the the
91:54 - shape of the hitbox defined here then
91:57 - for the position it depends if the
91:59 - player direction is to the left then the
92:01 - player position. X is going to be minus
92:05 - um yeah we're going to take the player
92:07 - position to the we're going to take the
92:09 - X position of the player and do minus
92:13 - 80 otherwise if it's to the right plus
92:17 - 80 and this is so that uh when you shoot
92:20 - from the left and the right it
92:22 - corresponds you know because the the
92:24 - star is mirrored and it's going to go in
92:25 - a different direction so play with those
92:27 - values you're going to understand here
92:30 - for the Y there isn't much difference
92:32 - between either right or left Direction
92:33 - so it basically this what looked good
92:36 - taking the player position the white
92:37 - position of the player and then adding
92:39 - it five to it uh you can play with those
92:42 - values if you'd like and then of course
92:44 - we need the scale component as I started
92:48 - this game uh because as I said the
92:51 - pixels aren't going to be drawn properly
92:53 - where one pixel takes one pixel space
92:56 - but a second pixel can take uh 1.5 and
92:59 - this Distortion is a bug in Kaboom JS
93:03 - and the way to fix it I found is this it
93:05 - doesn't happen always so I think it
93:07 - depends on your resolution so if you
93:09 - were to make a game that is of a higher
93:12 - resolution you wouldn't have this issue
93:14 - I didn't have this issue very much
93:16 - before so it really depends on the
93:18 - resolution you pick it seems and then
93:21 - here depending on the direction
93:24 - we can use the move component the move
93:27 - component will just move the Sprite the
93:30 - the game object towards a Direction so
93:32 - that's the first paramet if you hover
93:34 - over it you can have a direction it's
93:36 - either a number or a vector to and here
93:38 - I'm just using the constants provided by
93:41 - Kaboom which is the left and right
93:44 - direction so if the player direction is
93:46 - to the left that means we need to make
93:48 - the star the shooting star move to the
93:51 - left otherwise we need to make the
93:54 - shooting star move to the right and then
93:57 - we add the shooting star tag here so
93:59 - that we can later on have a not later on
94:02 - just right now basically I'm just going
94:03 - to copy and paste it as well so right
94:07 - outside of this definition I'm going to
94:09 - have this on cied event listener uh that
94:13 - um actually yeah this this tag is going
94:16 - to be useful I think later on for other
94:19 - other things other event listeners
94:23 - because we don't need the tag because we
94:25 - already have a reference to the shooting
94:27 - star here so if the shooting star un
94:30 - collide with the platform tag so with
94:33 - any game object that has the platform
94:35 - tag then k. destroy is using the Kaboom
94:38 - function to destroy the shooting star so
94:41 - that's basically it and
94:44 - then here it's done and then
94:48 - finally what is needed is
94:51 - simply to put the player is full back to
94:57 - being
94:58 - false since we since the Kirby like
95:01 - character has just shooted the star so
95:03 - that they should be able now to uh
95:06 - swallow someone else another enemy and
95:10 - then you we're going to use the wait
95:12 - function from Kaboom that is going to
95:14 - wait one second
95:17 - before um making the player play the
95:21 - idol uh the curb Idol
95:24 - animation curb idle animation here we go
95:27 - here in case you didn't see it here it
95:30 - is so this is a kaboom JS function to do
95:34 - that and then we return
95:37 - early the reason we return early is that
95:40 - if we don't do
95:42 - this we can just go
95:45 - here and just set the inhale
95:47 - effect ref of the opacity to
95:51 - zero the reason we're going
95:54 - set it to zero is because now the Kirby
95:57 - like corrector has done inhaling so we
96:00 - don't want to show the inhale
96:02 - effect and then we set player is
96:05 - inhaling to being false as well because
96:09 - they're no longer inhaling anything and
96:11 - then we put the player back to idle that
96:14 - was the case if
96:16 - the um that was the case if the player
96:19 - was not full
96:21 - initially so can we
96:24 - can we make this
96:26 - better by removing this if
96:29 - statement I think we could have this as
96:33 - a second
96:35 - condition and then no I think it's best
96:38 - to just keep it as is by the way the
96:40 - source code is dis is
96:43 - available in the comment SE um not in
96:46 - the description so feel free to refer to
96:49 - that if you
96:51 - want okay uh I think our code is done
96:54 - for this so let's try it out let's try
96:58 - the
96:59 - output so I can jump I can inhale and
97:03 - then when I stop pressing it stops and
97:06 - then you can see the inhale Zone in the
97:09 - headbox so looks nice and then if I just
97:12 - go here there's no level two for now
97:16 - okay our game is is working and one
97:18 - thing about the camera I said that it
97:20 - follows you up until a certain point and
97:22 - then it stops here oops
97:25 - okay and then one thing I noticed is
97:27 - that we don't see the little thing here
97:30 - at the bottom so if I go back to
97:32 - main.ts and maybe instead of this I put
97:36 - 900
97:40 - here uh you see this I wanted to see
97:42 - that so maybe 850 is going to be a good
97:46 - value but then again this is due to the
97:49 - specific map we we drew together instead
97:52 - of the original map from
97:54 - the the uh the original source code I
98:00 - made yeah maybe a bit
98:02 - more 70 should be
98:07 - fine does it work okay it seems to look
98:11 - good okay now it's time to work on
98:15 - making the enemies
98:18 - inhalable but before doing any of that
98:22 - we should uh probably
98:24 - probably write the code for the enemies
98:27 - so I'm going to go back to
98:29 - entities I'm going to collapse this as
98:32 - well let's write another
98:34 - function for making the flame enemies
98:37 - and to go fast this time around I'm
98:40 - going
98:41 - to just copy and and talk over it I
98:45 - think it's going to be better so here it
98:49 - is ah but it expect the
98:54 - anyway yeah let's forget this for
98:58 - now okay so we have this function called
99:01 - make flame enemy and it's going to be
99:03 - the flame NPC here uh enemy so to make
99:08 - this we need the context we need the a
99:10 - position X and Y position then we use
99:13 - the same thing but this time around I
99:16 - um I use the add function that might be
99:20 - uh because we just created immediately
99:24 - I don't think it's that big of a deal
99:26 - anyway uh doesn't matter for this game
99:30 - it doesn't matter if you use make or add
99:32 - just that if you use make you have to
99:36 - use add later in
99:38 - main.ts so here we have a flame
99:41 - character basically we set the animation
99:43 - we set the scale we set the position
99:45 - which needs to be according to the scale
99:47 - so that's why we multiply by the scale
99:49 - then we have the area which is the
99:51 - headbox for it and then the Collision
99:53 - ignore which is it needs to ignore
99:55 - collisions with other enemies the reason
99:57 - for that is and we use the enemy tag
100:00 - here the the reason for that is that for
100:02 - example the bird is flying on top and
100:03 - then the the flame is going to jump and
100:05 - we don't want both to collide we want
100:07 - both to continue doing their thing
100:09 - without any collisions so that's why we
100:12 - ignore the Collision if it does occur so
100:15 - it has no effect on the game we use the
100:18 - body component and then the state this
100:20 - is something new because we're going to
100:22 - define the AI from for this little Flame
100:24 - character and the way you do that is
100:26 - using a state machine and a state
100:28 - machine contains basically different
100:31 - states and then for each States you for
100:33 - each state you need to define the
100:35 - behavior and the what happens what makes
100:39 - it go to another state and what happens
100:41 - when it enters the state and what
100:43 - happens when it remains within the state
100:45 - so here the state component kabon JZ
100:48 - takes a default State and the list of
100:51 - all possible States here I've have the
100:53 - my state machine as being two states
100:56 - Idol and jump and we start with the idol
100:59 - and here finally we have the just add
101:01 - the the enemy tag and this is going to
101:03 - be useful for both this so that the
101:05 - enemy can ignore collisions with other
101:07 - enemies so for example two Flame
101:09 - character if they were to collide
101:10 - together we don't want them to have any
101:12 - effect so we don't have we don't want
101:14 - them to push it push uh to push each
101:18 - each other and it could be fun and weird
101:21 - to not have to have enemies being able
101:24 - to collide with each other Etc but it
101:26 - creates too much
101:28 - unpredictability all right so how do we
101:31 - Define the state so here once you have
101:34 - used the state component you use the on
101:37 - State under function to Define for this
101:39 - state what happens what is run when we
101:43 - enter the idol State and here I just use
101:46 - the Kaboom weight function but this time
101:47 - using the await keyword this is just so
101:49 - we have it as uh we have it sequentially
101:53 - so the weight is asynchronous by default
101:55 - that means if you don't put the await
101:56 - keyword it's going to run and the code
101:59 - the rest of the JavaScript code is going
102:00 - to run after it as well while by using
102:03 - the await keyword what it means is that
102:05 - we wait one second before moving on here
102:08 - so that's why I wanted this await here
102:10 - so that I don't I don't want the to move
102:13 - on to another state before we have
102:16 - waited 1 second so once we wait 1 second
102:20 - we enter the jump State once we arrive
102:22 - in the jump State we Define here what we
102:24 - do in that case so on state enter jump
102:28 - we just make the player uh the not the
102:31 - player the flame jump and we can use the
102:33 - jump function provided by Kaboom if your
102:36 - game object uses the body component and
102:39 - here we specify a jump
102:41 - Force this is just how
102:45 - how so like the name it's the force of
102:48 - the jump and it can it can be tweaked
102:50 - and I think 1,000 was the value that
102:52 - looked best and then finally once this
102:56 - is done there is another thing you can
102:57 - Define for a same state it's called on
103:00 - state update and here as it says
103:02 - register an event that runs every frame
103:04 - when in a specific state so while we are
103:07 - in the jump State we want to run the
103:09 - following so if the flame is grounded
103:12 - this this is a function method provided
103:16 - by Kaboom if you use the body component
103:19 - so want uh yeah so it basically checks
103:23 - for you if the flame is on the ground on
103:25 - a platform and if it's the case then we
103:28 - can just enter the state Idol again and
103:30 - basically this is a simple AI so just to
103:34 - make things
103:36 - clear uh what what this AI does is just
103:40 - it waits one second it jumps once it
103:42 - hits back the ground it enters back into
103:45 - the idle State Waits one second and then
103:47 - jump again Etc so it's not something
103:50 - fancy but yeah it it's a it's an
103:54 - obstacle I guess and then we return of
103:56 - course the
103:58 - flame and then we return of course the
104:00 - flame game object now let's make this
104:02 - make inhalable function that is going to
104:05 - be applied to All Enemies so right below
104:08 - set controls I'm going to again copy and
104:10 - paste the code for it and then go and
104:12 - explain it I think it's going to make
104:14 - much better explanation so I don't have
104:17 - to focus on typing while explaining and
104:20 - I don't waste time typing while while I
104:22 - could be explaining okay so here make
104:25 - inhalable this is the function takes the
104:28 - Kaboom context and a enemy which is just
104:32 - a game object so here we specify a bunch
104:34 - of on Collide event listener so when the
104:38 - enemy collides with the inhale Zone by
104:40 - using it stag we make the enemy is
104:44 - inhalable equal to true now
104:47 - here didn't exist before so not only you
104:51 - can create properties
104:53 - so you can create properties on the Fly
104:55 - for a game
104:56 - object and maybe it would have been
104:59 - better if here in the game object you
105:03 - want to create you create the property
105:05 - first instead of just relying on this
105:07 - but for this tutorial I think it's fine
105:10 - so if the UN Collide yeah so if if the
105:14 - enemy collides with the inhale Zone then
105:17 - we said is inhalable inhalable true so
105:20 - the inhale zone is this
105:23 - in the game when I press F1 it's this
105:26 - this part and by the way the debug the
105:29 - debug mode tells you the position of
105:31 - each game object and also the uh the tag
105:35 - for for example this is a platform this
105:37 - is the exit
105:39 - and I think that's it and this is the
105:42 - inhale Zone this is the player
105:46 - Etc okay now that we have something like
105:50 - that we have the uncollided end which
105:53 - also exists so as soon as the Collision
105:55 - is over maybe because the enemy moved
105:58 - away or the player moved away then we
106:00 - said the is inhalable to false so that
106:04 - the player could not inhale someone not
106:07 - in inside of the inhale
106:09 - Zone finally we have also the enemy on
106:12 - collide with a shooting star this is
106:14 - where the shooting star becomes useful
106:15 - and we run the following function what
106:17 - is really handy with oncolite is that it
106:19 - provides you the game object that is the
106:22 - tagged here so it it pulls it out for
106:24 - you and you can have access to it so
106:26 - here I can just do destroy the enemy and
106:28 - then destroy the shooting star um one
106:31 - thing I want to make sure though is in
106:33 - set controls maybe I wrote destruction
106:36 - logic here uh where is it where is
106:40 - it
106:43 - here okay I wrote for the platform here
106:46 - so if the platform collides with the
106:49 - shooting star then the shooting star is
106:51 - destroyed but this is a different k that
106:53 - we have here in make inhalable is if the
106:56 - enemy hits collides with the shooting
106:58 - star we need to destroy both the enemy
107:00 - and the shooting star that is here
107:02 - provided here and then here I use the
107:05 - player ref to get the player so the same
107:08 - way I did it earlier on with uh some
107:10 - another game object I don't remember and
107:13 - then here on update runs every run
107:16 - register an event that runs every frame
107:18 - as long as the game object
107:19 - exists if the player ref so if the
107:22 - player is inhaling and the enemy is
107:25 - inhalable that means we can actually do
107:28 - the the inhaling and then here if the
107:31 - the direction is to the right that means
107:34 - we're going to make the enemy move
107:35 - towards minus 800 so to the left with a
107:40 - a velocity a x velocity of -
107:44 - 800 and if it's not the case then we do
107:47 - that we assume that it is to the left
107:49 - side and then we make the character the
107:52 - the the enemy inhaled a move to the
107:56 - actually it's the contrary so if
107:59 - the if the direction of the players to
108:01 - the right we move to the left the enemy
108:03 - mooved to the left otherwise it's the
108:08 - reverse and that's basically it and then
108:10 - now here when I commented out make
108:13 - inhalable I can just comment this back
108:17 - in and then yep that's it now let's
108:21 - write in main.ts the logic for that so
108:24 - right below where we wrote the logic for
108:27 - the player let's do it let's do the same
108:30 - for the flame enemy and it's going to be
108:33 - very simple we just need a for
108:35 - Loop and here I'm just going to import
108:39 - here and save of course so now const
108:42 - flame of level one spawn points.
108:46 - flame and then it gives you all the
108:49 - flame characters uh mobs
108:53 - and then you can just display them like
108:55 - that create them and that's
108:57 - it okay now if I look at the result make
109:02 - flame enemies is not defined
109:04 - really maybe I did not uh make flame
109:08 - enemy is defined maybe the import wasn't
109:14 - right what do you mean it's not
109:18 - defined um did I use the proper tag
109:26 - let's look at here we have flame if I
109:29 - look at level one we have flame flame
109:32 - flame flame everything seems to be
109:36 - correct so why it's not working let's
109:39 - look at okay it's working it's just uh
109:41 - it didn't refresh soon enough all right
109:45 - so as you can see I can swallow and then
109:47 - I can shoot I can swallow oops I took
109:51 - damage and then I can shoot and that's
109:55 - basically the
109:57 - game everything from this point now is
110:00 - just Improvement
110:01 - and increasing the scope so here in
110:06 - entities let's write the code for the
110:09 - guy
110:11 - enemy I'm just going to copy and paste
110:16 - it so yeah so let me just uh there's
110:20 - still some explaining to do it's not
110:22 - exact the same thing but it's going to
110:24 - be mostly similar so here I paste it and
110:28 - then let's go through it together so we
110:30 - have the make guy enemy function takes
110:33 - in the same params as make flame enemy
110:35 - uh basically the same components just
110:37 - the different animations and for the
110:40 - state it's okay here I used is an
110:43 - inhalable I added it to make flame enemy
110:47 - uh to the guy but not here so what we
110:49 - could do is just
110:54 - um let's add let's add it you know just
110:57 - to make things
111:00 - correct so I'm going to add
111:02 - is
111:05 - inhalable going I set it to True uh to
111:08 - false by
111:11 - default and here we
111:13 - go okay so the state machine here is
111:16 - going to contain more States it's going
111:17 - to take um actually this jump I did not
111:20 - implement it I wanted to the character
111:23 - to jump after moving left to right you
111:25 - can do that on your own but that's it
111:29 - has three states idle left and right and
111:31 - it start at idle so at the idle State
111:35 - same thing we wait and then we go to the
111:37 - left State we flip X false we set it to
111:39 - false in case it were flipped to the
111:42 - right which does occur when the right
111:46 - here using right when going to the right
111:49 - and then we wait 2 seconds before going
111:52 - going to the opposite State and while
111:55 - it's doing this while we're currently in
111:57 - the left State then we move to the left
112:02 - at a certain speed defined
112:05 - here and this is the same logic but
112:08 - duplicated and just tweaked so that it's
112:10 - the same for the right now we flip X to
112:13 - to being true because you know the the
112:15 - Sprite here the guy is is U facing left
112:20 - and Toad the right and then here here we
112:22 - move with a positive value instead of a
112:24 - negative value now if I go back to
112:28 - main.ts and I go back
112:32 - here we it's another for Loop same
112:36 - logic import this if not already save
112:40 - and that's it now The Last Enemy is
112:43 - going to be a bit different the bird
112:45 - enemy it's not going to have an AI
112:47 - really it's just going to move into a
112:49 - direction and that's it and it's going
112:52 - to spawn on
112:53 - continuously so I'm going to remove this
112:56 - not remove it I mean collapse
112:58 - it and let's write the last function for
113:04 - the enemies and then we're basically
113:08 - done with this so
113:11 - here I forgot to have the closing
113:15 - function uh the closing bracket the
113:17 - function sorry okay so we have make bird
113:20 - enemy takes this time around four perams
113:23 - instead of three only difference is the
113:26 - speed because it's going to
113:27 - vary each time we create a
113:30 - bird so here we have a bird in me
113:33 - basically the same thing and then is
113:36 - static being true now
113:39 - this it isn't necessary to have it to be
113:42 - static so let's remove
113:45 - that and it's going to move to the left
113:48 - by default at a certain speed that is
113:49 - defined by here and then we have the
113:51 - offscreen component and this is
113:53 - something very interesting if you're
113:55 - making planning on making a more uh more
113:59 - expanded game is that you want things to
114:03 - not render when they're offc screen at a
114:06 - certain point of course here if the
114:09 - distance from the the viewport is higher
114:12 - than 400 or equal then we destroy the
114:16 - bird because we just want birds that
114:18 - comes from the right and goes to the
114:20 - left indefinitely and for all those
114:22 - birds that were go were to the left then
114:27 - at some point we want to destroy them to
114:28 - free space I guess so as to our game not
114:32 - to coll have a frame rate that collapse
114:35 - and overwhelm our our our web browser I
114:40 - guess okay so we make it inhalable the
114:45 - the bird of course and then we return
114:46 - the bird and now what changes is here
114:50 - instead of having a simple for Loop
114:52 - we're going to have a a for loop as well
114:55 - and then here of course import make bird
114:58 - enemy and here we're going to use the
115:00 - loop function so here for bird in level
115:03 - one spawn Birds we have here a constant
115:07 - that defines the possible speeds we want
115:09 - to have 100 200 300 and then we use the
115:12 - loop function from Kaboom to basically
115:16 - Loop every 10 second it this will run so
115:20 - it's a clean Syntax for set interval if
115:25 - you're familiar with the JavaScript
115:26 - function for that now make bird and me
115:30 - is going to take in a random element
115:33 - from here so it's going to randomly pick
115:36 - either 100 200 or 300 by by using this
115:40 - logic so this is a very a common piece
115:42 - of code you see online where you do the
115:44 - math random times the length of the
115:46 - array then you floor it and this gives
115:48 - you an element within the array Is
115:51 - Random
115:53 - and that's it I think we have finished
115:55 - so if I go back to the
115:58 - browser you can see the guy is
116:01 - walking and if I were to just shoot now
116:06 - you see that they didn't
116:08 - appear okay now I understand why I had
116:12 - the his body static because it's
116:14 - affected by gravity so if I come here so
116:18 - if you're far enough away you're going
116:20 - to see the star otherwise if you're too
116:22 - close close to an
116:23 - enemy and you shoot the star it's going
116:26 - to disappear the star is both the star
116:28 - and the and the enem is going to
116:31 - disappear too fast I think and if you
116:33 - are to do if you want more better
116:36 - feedback a better feedback loop for the
116:38 - player I think it's be best to change
116:41 - this so as you saw the birds are just
116:44 - falling down and that's because we
116:46 - remove the is static and we don't want
116:48 - that after all so it makes sense to have
116:52 - here is static so that it's not affected
116:55 - by gravity the the birds now if I go and
116:58 - I
116:59 - look at the birds you can see they're
117:01 - coming in and I can shoot them
117:06 - and here we
117:08 - go now here it
117:12 - is and then of course there's no level
117:15 - two for now and you know what I think
117:17 - I'm not going to implement the level two
117:19 - I think try it out on your own try to
117:24 - create a second layout use the thing i'
117:27 - I've explained here and do the
117:29 - transition
117:31 - between yeah I think it's best and of
117:33 - course you can reference the the
117:37 - original source code I have the Gib Hub
117:40 - repo feel free to download it look into
117:43 - it Etc so yeah I think I'm going to end
117:46 - the tutorial here just not to make it
117:48 - too long and of course the concepts I I
117:51 - don't want to rehash the same Concepts
117:53 - all the time but I hope this tutorial
117:57 - really was clear that you understood how
118:00 - to make games using typescript and
118:02 - Kaboom JS so yeah thanks for watching
118:05 - And subscribe for more content so is it
118:08 - running at 60 FPS it is all right thanks
118:11 - for watching bye all right so I forgot a
118:13 - very important part of the tutorial
118:15 - which is how can you actually publish
118:17 - your game so when you're using a tool
118:20 - like vit like we did in the Kirby
118:23 - tutorial you need to use uh you need to
118:25 - create a vit vit V vitc
118:34 - config.inc from vit and then export
118:37 - default this and then here you need to
118:39 - specify those three Pro uh those two
118:41 - properties so the base need to be do
118:45 - slash otherwise when you're going to do
118:48 - npm run build uh you're going to get
118:51 - some that won't
118:53 - work H so if you open this using for
118:55 - example live server what's in the this
118:57 - folder then it's going to be um how how
119:01 - do I say it you you're going to get an
119:03 - error now you need also to disable the
119:06 - minification in vit uh this is an issue
119:10 - with Kaboom ja specifically I don't know
119:12 - in the future if it's going to still be
119:14 - an issue so try it without and with so
119:17 - once you have done this configuration in
119:19 - V.C
119:21 - config.sys at the root level of your
119:23 - project what you should do is just run
119:25 - npm run build so npm
119:30 - run run
119:34 - build and then it's going to run your
119:37 - compile your typescript code Etc so if
119:39 - you then you should see a disc folder
119:42 - appearing and this is the folder you
119:44 - need to zip you need to zip this and
119:46 - then you can put it on itch.io for
119:48 - example so here if I right click and
119:51 - open it with live server just to test
119:53 - out that things are working you can see
119:56 - that the game is actually working all
119:58 - right that was a little bonus that I
120:01 - forgot to include uh so hope you're
120:03 - still watching at this point thanks for
120:06 - watching bye

Cleaned transcript:

improve your typescript skills by building a fun Kirby game clone JS Legend teaches this game dep course and he'll teach you how to use Kaboom JS to create a 2d platformer game based on the classic video game hi everyone welcome to this new tutorial today we will be building a Kirby like platformer using typescript and the Kaboom Jaz Library so Kaboom Jaz is a library for making games and it can be used with typescript and here I'm just showcasing the project we're going to build so here it's a Kirby like character that can swallow enemies and shoot stars on once uh it is swallowed and then here you have a beautiful level layout by the way I made all the assets myself and then when you get hit like three times you respond to the original position and that's basically it so let's jump right into making a game like that what you're going to need for this tutorial is first of all I assume a basic understanding of typescript so maybe brush up on typescript you know just watch a tutorial or something before following this tutorial and I'm going to also use node so you need to be familiar with node so here I'm going to open up a terminal window and I'm going to set up the project differently than what you're used to if you're watching my if you have watched my previous tutorial tutorials sorry is that usually I would need to use index.html Etc and then paste the links to the libraries or use JavaScript modules here we're going to use a bundler it's called vit so I'm going to do npm run uh not npm npm create at vit uh not create vit at latest and then dot so that we we specify that we want the project to be scaffolded inside the current folder so by the way I'm using VSS code for this tutorial I recommend that you use it as well you can install it Etc now if you're familiar with typescript you're probably using uh vs code already so I'm just going to go over so after having done npm create V at latest we're going to select the vanilla template and then the typescript template and then you should have the following files now we're going to delete v.svg we don't need that also we're going to delete everything that is within the Source folder but we're going to keep the source folder and then here I think yep here it doesn't matter really you can just leave it as is it doesn't matter at all so let's get our assets so you will find the Assets in the description and yeah so it's basically just one file this file contains everything we need by the way during the tutorial we will be drawing our map using an an external editor called child and then we will uh basically pass this and for the this export to our JavaScript to take care of drawing so I see that the The Source folder is gone so we going to have to recreate it here we go so now what I'm going to do here is I'm going to create all the files we're going to need for this project right from the getgo so that it's going to be easy to follow so we're going to need a constant. TS file this for a constant we're going to need a entities. TS file this is going to be the file used to um contain the logic for our players our mobs enemies Etc we're going to also have a kaboom cx. TS which is where we're going to initialize the Kaboom library and export its context and then use that elsewhere we're going to also have a main.ts of course that's the entry point of our project we're going to need a state. TS to hold uh General Global state of the game so this is useful to know when to move on to the next scene for example and then finally we have the utils um UIL is just going to contain one thing I think just related to making the map basically all right so let's go to Main and before doing all of that I forgot we need to do npm install which is going to install the dependencies but we actually I should have done any npm install Kaboom as well so do this and this is going to put Kaboom accessible in your project so once you have this we can basically uh going to need the terminal to start a server in a moment but yeah that's basically it now here let's import Kaboom from Kaboom this how you import Kaboom here and then uh actually it's not here at all we're going to use the going to go to the Kaboom context and do this here so import Kaboom from Kaboom once this is done we're going to go to going to create our context so basically it's a way to initialize Kaboom so I'm going to export K which is going to be the Kaboom context we're going to use this constant everywhere when we need to use kabooma related functions and functionality Okay so to initialize Kaboom you just call the Kaboom function and pass in an object which going to have a bunch of um how do I say options so first let's specify a width let's start with 256 pixels and a height of 144 uh later on going to this is the resolution of the Game Boy but wider so it fits within a 16 by9 ratio we're going to set the letter box option to being true that means that uh basically our canvas is going to scale regardless of the um of the uh of the screen size basically and while keeping the aspect ratio and we're also going to set the global property to being false the reason we want to set the global property to being false is that we want to only be able to use Kaboom related functions from this constant that's why you need to set it to false now in our constants TS file here we're going to create one constant reles the scale of the game because the current resolution is too small and it's also going going to act as a workaround because in kabon Jaz there is a bug an issue where pixels sometimes they don't get drawn right so you will have let's say we have a Sprite uh maybe to illustrate I'm just going to pull this out so here our Kirby like character for example you will have it drawn where you will have the image the Sprite will draw all right but one pixel is wider or smaller than other pixel and to fix this the workaround I've found is to set a scale to a value and then go to the Kaboom context and then first of all add the scale property and here first of uh let's import import let's import the scale constant and then by JavaScript you know that you can if you have a property that has the same name you don't have to do scale scale like that so you can just do it like this it's a short hand so the scale is the constant set to four this is what looked good but also you need to multiply by four here this is a a weird workaround I found but it works so yeah and so I recommend just using it for now if you found a way to get around this issue then feel free to add uh a comment in the comment section and share it with us okay so now we have our context that's great now let's go back to main and in main we're going to have our I'm going to import first our context import k from the Kaboom context we just created and then here we're going to have to load our Sprites okay so the way we're going to load our assets going to be a bit different from other projects we've made on the channel I'm going to create an async function I'm going to call it game setup now for now let's me let me reduce this let me remove that okay so we have the game set up and in there we're going to call all all over our logic and afterwards we call game setup here the reason we're going to do this is because we want going to want to load the asset assets once and when the player dies we don't need to refetch the map data we don't need to refetch the the the assets or something like that so to avoid actually this is really to avoid having to refetch the map data coming from tiled which is going to be the editor we're going to use to draw our maps and it exports to a Json file and we don't want to every time the player dies to redo the fetch logic to get the level layout and then redisplay it Etc so by just having everything done within a a a sync function where we can use the await keyword to wait for the map to be map layout to be extracted before moving on this is going to be really helpful in not having to repeat this logic so for importing the Sprites really I'm just going to copy and paste because this is logic that you just have to to I'm going to expl it of course but it's a bit tedious and not no new Concepts or anything like that is really present so I'm just going to do um explain what everything is first so here by using the K which contains all Kaboom functions and methods we can use we can use the load Sprite method this is how you load Sprites in Kaboom and by the way because you're using a bundler like V or or any other bundler you're going to have this uh some info on how to use the functions you're using and examples so that's pretty handy so the first key the first Pam is the name of the Sprite how you want it to be referenced in your project the second one is of course the path to the the project and here the path is just do/ Cirby like PNG even though we're putting our Assets in the public folder and the reason for this is simply because the vit is going to make sure that if you put this uh the the the path here is going to append or make sure that it it reference the public what's outside as well so this is something specific to V I don't know if other bundlers do this so you don't have to do dot SLU Cirby like PNG and then we have a slice n and slice 10 and the way to explain this is how to slice your image because our image our Sprite has much more than a single spritey within it so it's a tile set basically and here you can see that we we have one uh every every Sprite is drawn as a 16 by 16 has a resolution of 16 x 16 that means that we have 1 2 3 4 5 6 7 8 nine different Sprites on the x axis and that's why if I go to main.ts uh yeah slice X is going to be nine because we have nine Sprites nine yeah in the image and then here for the uh vertical axis we have 10 so you can just count them manually but I think it's obvious and now here is where we Define the various animations basically you're telling Kaboom wh which key corresponds to which uh thing you want to display in this image so for example for curb Idol so the the main character is called curb so it's just a it's a Cirby like it's not that original of a name but you know it's just for a tutorial in the end so curb in the idol is a name I've decided to name this animation which only contains one frame and the first frame remember that it starts from zero so 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Etc so at frame zero we have this idle Sprite so this is the idol Sprite we're going to use and we're going to use this name to refer to it for Kirby inhaling so as you know Kirby can inhale enemies well it's the same thing it's just a single Sprite and it's the Sprite at index one 01 and then curb full is when yeah so I I guess you get the point and then here when you want to have an animation that has more than just a single frame you use an object like this where you specify a couple of keys the first one is the from Key and you you basically telling Kaboom at which frame to start the animation here from frame three it's going to be this inhale effect so this thing and just to put it in action just to show it to you all right so just to so show you the Kirby the curb inhale animation it's this thing when you're inhaling you have a couple of pixels that just seems to give the effect that there is some inhaling going on here we go so now if I go back and go back to main.ts so from frame 3 to 8 and then at a speed of 15 frames per second this what looked good and I want this animation to Loop so you can decide if you want the animation to just play once or to Loop forever and we want we want it to Loop until we just decide to stop it so that's why I used the loop property as being true shooting star it's the the star here that you that the player shoots once they are full and basically it's the same thing the same logic for the various other entities so copy the code if you haven't already or you can pause here so this uh software is called tiled and it's used to draw maps and here is a map I've drawn for the um the first level and I have another one for the second level so the way I'm going to go about it is I'm going to to teach you how to use til for the first level and then for the second level we're just going to use what I've already had and this time around it's going to be different uh we're going to export the way we're going to use tile is going to be slightly different from the previous tutorials so let's let's jump right into it so first of all install tiled if not already a link should be in the description now there's one thing you need to do because if you're using a wide a big monitor then everything should probably look very small so to fix this you go to edit preferences and then to themes and then you click you check mark the use custom interface font and then you can here select the font size you want and this way it's going to make everything much more visible now uh I'm I'm going to keep this as a reference as I draw the level because otherwise it's going to be complicated so I'm going to create a new map by going to file new map and then you decide how many tiles you want and the width and height of each tiles so here let's start with I think 30 by 30 um you know what I'm just going to look at the current map and see how many tiles we have it's a 27 by 20 tile so let's keep this so here new new map 27 by 20 so we can have exactly the same layout and of course every tile is going to be a 16 by 16 pixels and here don't touch anything it's on necessary all right we have our tiles here or actually we have our our map not the tiles we need to draw to draw in so first of all we need to import a new tile set and the way I'm going to do this is you specify the source so basically browse to where you put the Kirby like PNG in the uh public folder okay so I have done this so this is the path for me yours should be the same starting from here and now 16 by 16 pixels everything is all right and then click okay now once you have this you can use the control and mouse wheel to zoom in and zoom out so the only thing left is to start creating our V various layers and placing things so that's uh of course save so the way you save you you do save as I named it level. Json and I've S I saved it as a level devil 1. Json in the public folder of our project so I just go here and I click so yeah this was a mistake for me I just uh put it twice so I'm just going to delete this but you should have it here so once you have it here H we're ready to start working all right so now it's time for drawing so if I look at my reference we have the background as the lowest layer so background and what this is going to contain so just make things easy for me I'm going going to make everything nonvisible and here we can see the layout so basically one two and then okay so three 3 by two okay so I go here I'm going to select this three by two so they should be here yep and then one 2 three one two and three I'm just going to zoom in with the control and the mouse wheel so you can see what I'm drawing so basically you select tiles like this and if you do control and select you can Al and click you can select more than once more than one tile you can have something like that and then here for this I'm just going to copy so two to the side here we go and then just try till the end doesn't matter really all that much by the way always save while doing while doing this and then another Hill so I'm just going to copy those two by the way you don't need to do control you can just click and drag and you can select more than one and here you going to have it have a big map so you know what I'm just I'm not going to worry about having it exactly anyway so this is just to show you after afterwards I'm probably just going to I'm going to probably use the same map that you have here but for the level two as I said I'm just going to use what I already had so here um okay so this looks like this doesn't have to be exactly the same otherwise we're just wasting time then you have like that then maybe this like that and a final one here all right so this is our background layer we're also going to need to add to the background layer some tiles like this you're going to see what they serve what's their purpose but this is really something optional so I'm just going to create a new layer so by the way by the way in Til There are multiple types of layer you have the image layer if you want to put an image as a full thing but you have the tile layer for tiles the object layers object type layers are for uh boundaries and spawn points so where to put your characters away for you to know this and let's create another tile layer and this second one is going to be the clouds so clouds here we go and then once you have the clouds I'm just going to select the full Cloud Sprites and just start putting them here as you can see they can overlay on top so just put to a random amount it doesn't matter save of course as you do this now the next layer is going to be the platforms so it's a tile layer as well platforms or platform did I call it platforms all right so for the platforms let's not stray a lot from the layout so that's the level okay so I'm going to use this these two oops these two uh wait a minute no that's that doesn't work so oops where should I put this okay okay here and then I'm going to expand this like that I'm going to put this like that here we go so really not much to explain here just draw draw whatever layout you want then you we're going to need certain structures though just so we can have the same thing but this is not something I plan uh I draw it on paper but I don't think it's worth you know copying exactly what I'm doing just use the proper tiles explore around Etc and then here I'm just going to have a platform here we go and I'm going to expand that further and then like this I think that's it and we need another structure that is similar so let's have this here expand it downward and then couple tiles here uh how many tiles is there five tiles 1 two 3 four and file five and I think that's uh basically it we're almost done oops doesn't matter because you can just draw over it and it will replace the tile okay so we have this let's put a sign post here to signify the beginning of a level let's um put the exit door whoops here and I think a couple of grass here uh we need to extend the background so in the background I'm going to need this fix and this make sure to change the layer of course all right so I think we have our level and then of course in still in the background layer we can add this down uh for the rest of the the color the the full background going to add this using Kaboom instead it's going to be more performant actually it doesn't really matter in the end but I think it's better to do it this way because the way I'm going to use tile today is going to be very different and basically just going to take the image and just draw use the Json to draw the boundaries on top so we still instead of drawing each tiles in Kaboom we're just going to take a PNG so here you can convert as a PNG it's going to be very simple okay so now we have this it's time to place our various colliders so I'm going to create a new layer on top an object layer this time around I'm going to call it colliders and now here uh the way you draw colliders by using this Square this rectangle on top here and then here's an example you drag Ah that's a that's a mistake you drag ah come on what's so basically just draw like that so you drag and drop various squares rectangles sorry and this is going to Define what is collidable and what isn't and then here we go so once you have done this we're done with the collider layer and now it's time for the um the spawn points so for the spawn points it's also going to be an object layer and I think I call it spawn points okay so I'm just going to rename by the way you can rename by just double clicking on the layer name so spawn points and now what's going to happen here is I'm going to use a pin instead so you see the pin icon use that and let's put our kir like character here so let's put it here where the sign Point sign post is and here you select a name and I'm going to call it uh player this is how we're going to differentiate between all the different mobs Etc so player spawns here the flame type mob are going to spawn spawn here so flame oops I created two pins be careful not to create pins by accident because you can so to select one you use this button here then you click and then you if you do if you have the pin selected and then you try to select another one it's just going to add another one we don't want that so A Flame character is going to be here and here flame here we go and then I think that's it and uh we have our birds so let's put two I wonder yeah it doesn't matter the position you know so I'm going to select here C bird and then bird and I think we missed the guy enemy so the guy enemy is this one I'm going to uh let's put it let's put him here I'm going to call it guy all right you have everything done so save and now we're ready uh whoops I created a unnecessary spawn point so we have our spawn points which DET terms where the player spawns where the flame spawn where the guy spawns where where the birds spawn I think the birds are spawning a bit too far so let's bring them down a bit so they can have a chance to hit the player at at all so here here it is like that all right so we have everything ready so for the exporting process you can just use the Json as is but for the image we need to hide the spawn points hide the colliders and then go to file and then export as image and then it's going to tell you the path and only include visible layers and everything else should be unchecked so now export now you could have drawn decided on the background color and included it but let's not worry about this so export that and then now if we go back to our editor you should have the level displayed like this so you can have the level as a single image and this is more performant or Kaboom to only have a single image to display that is relatively small and then scaled up than having to draw each tiles using Game objects there are ways around it so you could use a UV quad texture but this is more advanced so I recommend using this method it seems very simple and can have bigger much more bigger Maps than you could previously with boom Jazz all right now that we have this uh let's go back to main and import the the Sprite so k. load Sprite we need the level going to call it level one and it's going to refer to the level one.png Sprite uh image that we had okay let's create our scenes we're going to have a uh the way you create scenes in kaboom J is by using the scene function you decide on a name and you pass this as a first param level one and you can have here we're going to use an async function going to explain later on why and then actually do we need an async function here I don't think we need it uh we actually don't let's just have a a normal error function that is going to contain the logic that is going to be executed when we go to this scene so by default uh you have to specify a default scene and you can do this by simply calling K.O and the name of the scene level one to go to the that scene okay once we have done that we can write our logic from within so first of all let's set the gravity to being of 2,100 this is what looked good it felt good to play and then here we're going to create a background for a game now here I think we could just um put that logic outside actually we're going to have to repeat it because each time for each scene the background changes um because there is actually a set background function in Kaboom J just set the background for all everything the issue with it is that instead of having white bars here it's going to just use the same color of the background and we don't want that we really really don't so that's why um yeah otherwise we will confuse the the player on where is the actual limit of the the level for example so here let's create a our first game object in this tutorial so a game object in Kaboom jazz is everything that can be a Sprite player Etc so you in Kaboom JZ you create game objects that use certain components those components come from Kaboom JS you can Define your own components as well and depending on which components you add in to this array uh your game object will have different uh properties and methods that are usable on it so I think this design is really interesting and I haven't seen it elsewhere I think that's what is called an entity component system but I haven't had experience with any other one if uh so if you know uh if this is actually the entity component system and if other um libraries in other languages use it feel free to talk to say it in the comments I'm curious I want to explore it more so we're going to use the rect component allows us to draw a rectangle by we passing the width and the height we can get the width and the height by calling the width and the height method of the canvas so this we want the rectangle to actually fill the full canvas so that uh it acts basically as a background then for the color I'm going to use the color component and in there we're going to call the color class I guess and use the uh from hex method so it's probably an abstract class and pass in the value for the background color and here I just gone into a Sprite where I've drawn the Sprite and just took the color palette so the color for the background is this and uh wait wait a minute I need to add another component I'm going to add fixed component this is useful later on uh it's going to make sure that this game object is not affected by the camera and we want we don't want it to be affected by the camera otherwise if the camera removes then the the the rectangle will no longer faill the whole screen because it's going to be positioned to the left as the player goes to the right and the camera follows the player to the right all right we have everything we needed so just uh to run the project you do npm runev and then click on the link and then you have just an empty uh background all right so now let's write the logic for making the maps so for loading the maps and displaying them so what I'm going to do is I'm going to write this code in the utils.py let's go over it so first of all we're going to need the actually don't need the context here uh what we're going to need is to import the scale constant it's we're going to need to have this everywhere basically uh as I explained is to prevent pixeling the pixels to have two pixels that aren't drawn that don't take the same space it's very weird a very weird effect but it seems to be happening in Kaboom Jaz if you don't for some reason sometimes so that's the only fix I found for it so I'm going to export a function an S sync function it's a it's kind of required because we're going to use Fetch and we're going to call this make map it's going to take as the first Pam the Kaboom context so the typing is provided by Kaboom so all these things are going to also come from Kaboom and that's great and the name of the map is it's going to be a string it's also going to be the the path so it's going to be used to find the path of the level so the first thing we need is to have a constant that will hold the maybe I should increase the font size by the way here we go uh okay so we going to need the um to hold the map data within the map data constant here and we're going to use await await and then fetch which is going to fetch the the Json so here we're going to use a template string so dollar name which is the name of the map. Json and then at the outside. Json to have it as a Json so you could have written this line in multiple um in multiple lines I assume that you know what fetch is and how to use it with syn we so I'm not going to spend some times some time here if you aren't familiar look at my previous tutorials or just search online I think it's going to make a better explanation so here we're going to use the key uh the Kaboom function to make a game object so in Kaboom JZ you can add a game object to the scene which uh basically implies that you have to create it or you can make it and then you can pass what you have made into the ad function later on and this is going to add it to the scene and basically draw it so here because we're making this a utility function we're going to first make the map once the map is made we're going to pass it to the main which is going to call the ad function on it so make really works the same way as ADD it's just that it creates the game object but does not display it so here we're going to use the Sprite component and this is where you can Define what Sprite you want and here because remember in main.ts we defined this Sprite as being level1 which is going to correspond to level.png and here we have the Json file for it level1 Json which we get from here is going to give us the map data so if I look at the Json export you can see that you have layers and each layers has a data property if it's a a tile layer or an objects property if it's a um if it's a object layer which gives us X and Y coordinates you can use all right so here kme K Sprite Etc and K scale it's the scale component we're we going to use the scale so the scale of the the map so the Sprite uh accordingly we're going to also use the positional component so this is when you want to set the position of a character you can use or a game object you use a position component it it takes in two values but you can pass in only one if if it's this same value for both X and Y and here for now we just use the positional value and put it at 0 0 so that the map is drawn from the from 0 0 so x coordinate 0 y coordinate Z okay and now we're going to have to get the spawn points so here the spawn points are going to be uh X and Y coordinates they're going to the find what we need uh where to place the various enemies players and Etc and for now it's going to be an empty object because we're going to get this data from the map data but just get what we need and store it here so the typing for this is going to be an object of course but first we need to Define what the type of the key is going to be so the key is going to be a string and the value associated with it is going to be another object which is of the type number and Y also of the type number this is going to make sense in a moment all right so now let's iterate through the map itself map data so for that I'm going to create a for Loop const layer of map data. layers and if you've seen earlier on in the level one export you can see that we have this layer property that contains an array that contains all of our layers okay now what now that we have this done we're going to Simply have an if statement that checks the name of the layer so if the name of the layer is colliders we're going to Simply have another full loop cons collider of layer. objects so here basically as I told you if the type of the layer is a tile layer it's going to have the data property which is an array that tells us which tile to draw Etc we don't need this for this project because we have already everything drawn as a single PNG we just need to display that Sprite but for colliders for object type you have this objects property instead of the data property which is an array containing the list of objects that is in this layer which contains also the X and Y coordinates for each of those objects okay so now here for collider of so by using layer. name each layer has a name and this how we can differentiate them really easily so for objects which is going to be an array so for each element of that array so here the I'm just going to call it Collider we're going to add to the map so map was created as a game object by using the make it it isn't displayed yet but one thing in Kaboom J you can have children game objects and this is going to be handy here because we want to add to the map the the various colliders so the colliders are going to be game objects as well here you canot use the make function you can cannot do I don't think you can do this so you need to use the add function to add it as a child to the map and then once map is going to be called with the ad function from Kaboom then it's going to also draw the children of that game object so to create a hitbox we going to use the area component that defines a hitbox for you automatically but you can specify a sh a specific shape so here the shape I'm going to use new K rect Constructor and it takes in as the first pram the position relative to the game object it's a vector to and here it's just going to be 0 0 so a single value is enough now then you need to specify the collider the width and the height of that rectangle and this is provided in the uh tile Port if you look at the export here you can see that for this object we have the width and the height properties that's very handy because we can now really know where to put those boundaries okay so we also want to add another property inside of the uh area component there's this thing called Collision ignore and we want basically you pass in a tag and uh is going to know if if Collision should be ignored with a specific type of game objects so game objects can contain tags we haven't covered this yet but let's add them those are arbitrary names that I have defined that there is this platform tag and the exit tag which is for the exit door it doesn't really for now it's not created anywhere but it's going to allow us to differentiate our Behavior so just to explain here we're going to have a Turner restatement which is a basically condensed if statement if the collider name is not the actually I forgot to do this in til so let's go back to til so here in the our collider I forgot the collider for the exit so here I'm going to draw whoops not here so here select the collider you can make everything visible it doesn't matter and then draw this add at its name the exit which is going to allow us to know that this boundary corresponds to the exit of the level save and then if you go back to til if the collider name so now if I go here I can see that there is one of them that is going to contain the exit name so if the collider name is the exit is the exit uh is not the exit basically is not the exit we're going to add the component called B body and in Kaboom JZ this component allows us to have collisions affected by yeah collisions and if you specify within it that it is a static body is static and you set it to true then the the current game object here the child game object is going to be remain static and so that means that once the player uh collides with them it's not going to move so it's really useful for platforms and then here I put it null the reason I'm doing null here uh oops it's a question mark so the way it works is that if this condition is uh true then you go here if it's not true it's null that means we add nothing no components to our list it's going to add no basic and which does nothing here regardless of the situation we Define the the position and it's just going to be collider X collider y nothing fancy and uh that's uh basically it right and finally a last thing this is where we add the tag actually so if the collider name is not equal to exit then this current game object that is being this collider that is being being added to the map is going to have the tag platform so the way you create tags in Kaboom is just a string that you attach that you add to your array of components and the way it's useful is it's useful because later on you can have event handlers and you just listen on a tag to know if this game object has collided or a class of g a group of game object game objects have collided with another otherwise we okay so if the collider name is not equal to exit and don't forget the comma here we give the game object the platform property uh not property tag so okay just to recap if the collider name is not the exit that means that we can give the tag the platform tag to the current game object Cur current collider we created as as a game object otherwise we can give exit tag and this is going to be y later on really handy okay now that we have this I think we have everything we need and uh yeah so we can continue here so if after doing all of that so it was the collider actually continue can be outside of the for Loop and otherwise it's useless so here continue so if the four Loop okay so if the first if statement is true there's no point in going further we just move to the next iteration the next uh uh layer and now here if the layer. name is the spawn points this is where we're going to have a for Loop const spawn point of layer doobs for that specific layer and then and we're simply going to have another if statement if the spawn point if the spawn points um object we created here has has a spawn point. name okay so basically the way we're doing this is that if the the the property the spawn point name is already defined so the spawn point name is going to be the name here so player we're going to have an object that is going to have all the keys so this point points you can use the key for example player and it's going to give you the position of the player can you use the key guy is going to be the the position of the guy mob and we're making this and here this first if statement checks if it already exists in case it already exists we're going to Simply add to the the spawn points so spawn point so that assumes that there is an array we're going to create we going to write the condition below of if the spawn points uh for the specific key does so if the key doesn't exist in the specific uh in in the spawn points object then we're going to just create an empty going to create an array and then in that array we're going to put the uh the position because we can have more than a single flame guy a single guy mob or a single bird this allows us to be flexible so if spawn point dot uh things going to make make sense hopefully in a moment I'm going to push to that array that we assume that there is an array with X spawn point dox Y is going to be spawn point doy and then we're going to continue to the next iteration because there is no point in going further now if if the the key did not exist that mean it's the first time we going to have to create it so we're going to do this spawn point spawn point sorry and then spawn point. name equal an array X is going to be spawn point dox Y is going to be spawn point doy and here here it makes all the difference it's because we created a what's the issue ah we need to um uh what did I miss did I miss something um um okay so we have spawn point. name and then we push and then push does not exist on the type I messed up I messed up in the typing gear it's an array okay so so it's an array of objects like this you need to add this bracket so now the typing should work okay we have everything we need so just to recap again sorry if it's getting repetitive if the key exists already in the SP points object then we just add to the currently existing array that we assume exist if it wasn't the case then we create that array and P pass in the first uh the first uh member of that uh spawn point name so yeah okay we have everything uh we need and then finally at the end so right below here we're going to return two things we're going to return return the map and the spawn points object those two things are very important and that's it so we can go back to main.ts and right before we enter the scene so after having loaded the Sprite we're going to call um yeah I'm going to call map so the map here is going to be called level layout and the spawn point spawn points going to be the level one spawn point and it's going to be getting this from await that's why a sync was needed and then make map it's going to import this automatically we need to pass in the context and the name which is level1 now one thing I want to cover is this uh you might not be familiar with this notation what it does is it renames the map and spawn points properties to being level one layout and level one spawn points this is going to be handy because when we're going to have to have two levels we're going to have level two layout level two spawn points and because it always the make map function always returns a map and spawn point properties if we were to keep the same names it would make things uh difficult for us so that's a a JavaScript syntax I don't think it's very common I haven't seen this much beforehand so in case you were like me and and you didn't know what this me meant yeah you now you know all right so let's draw our map so right below in the scene you can do k. add and just pass in the level one layout as I explained and this should draw the map the the image so let's look at the result voila you can see it drawn but um you know you can't see the can't see it fully for now but it works all right so before moving on let's uh actually write everything we need for the player the mobs Etc and then then we're going to come back here to main.ts and add them with the spawn points Etc so to do something like that go to entities. TS and let's write the logic so let's first write a function that is going to be responsible for creating our game object for the player to do something like that same pattern first we pass in the context it's going to be a kaboom context so Kaboom Kaboom context so the typing comes from Kaboom as well that's pretty handy then what we're going to need is to specify a position X which is going to be a number a position Y which is also going to be a number once we have all of this oh well my my my L uh yeah so now we're going to create a constant within call it player and call the K make function that I explained earlier on and here we're going to have a couple of components just to make things fast I'm going to copy and paste it copy and paste everything we need here and then go over line by line so of course we need the scale so import this from from this uh constants like that okay so what do we have here we have the Sprite component that uses the asset Sprites if we go here we named all of these assets and then here optionally the Sprite component can take a second param which is an object and you can in that object specify the anim property and specify which animation you want to play by default and we want to play the curb idle which is you know the name of the character it's frame zero then we create an area component uh we use the area component to create a hitbox with the following shape it's a rectangle with a width of eight and a height of 10 and here it's going to be positioned at x value 4 and Y value 5.9 relative to the Sprite this is so the character doesn't look like it's sinking in the platform you we you need to um put the hitbox in such a way that it's going to make the the character look all right as if it's on the platform normally uh this is a bit hard to explain uh without uh visuals so let's first write this out and then while you're going to open the debug mode you're going to see everything everything is going to make sense k. body here component so that uh the player can be collide with others other game objects and and be affected by gravity uh the position is going to be the position X past here but we need to multiply by the scale and the position y as well we need to also multiply it by the scale so that it is placed at the right position a scale component that calls the scale constant uh this is to scale the Sprite and uh yeah so scale the Sprite so the the the the character takes the correct amount of space uh the double jump um component is something from Kaboom that you can specify a double jump and how much jumps you want to allow so 10 jumps so that it looks like the the floating from Kirby but it's not unlimited and it's very easy you just use that component it's for free so we don't have to write extra code to implement the feature of floating so that's really great the health component allows us to specify some health value and then you can use the HP function method and the HT function to know and the heel function as well to heal the life points Etc so this is something that is handy in Kaboom JZ and the opacity is going to be set to one we use the opacity component uh setting it to one means that it's fully visible this is going to be useful when the player is going to get hit we're going to temporarily reduce the opacity to zero so that it looks like it's flashing and here this is some A New Concept whoops is that in Kaboom JS you can pass objects as uh as well as your components so objects going to contain properties that going to be accessible immediately from within the game object so if you do player dot you can access the speed direction is inhaling and is full those are arbitrary properties that I needed for the game so the speed is to really control the speed the direction for where the the Sprite is looking it's going to be used for that is inhaling is going to be a Boolean and is full as well that are going to be used to know when to allow for uh certain uh for the enemy to be swallow swallowed or not or inhaled Etc and finally the player tag is going to be useful I think I'm using it later on to to do the on collision logic to know if it collides with an enemy what to do what we need to do though right after I'm going to use player.on Collide method that is available if you use the body component in the I think the area component and then as the first param you specify the tag of the other game object you want to test collisions with or listen to collisions with and it's going to be the enemy we haven't created any enemies yet that's normal and when we're going to do it we're going to add the uh the enemy basically uh the enemy tag to the to th those game objects now here the assing function we're going to need an async function for multiple reasons uh mainly I think uh actually do we actually need a sync function here yeah we're going to need it because we're going need to F to make the player Flash and back and forth and we going to use a tween for that and it's much it gives us much more cleaner code if you we use the tween the await uh syntax and here what's handy with the on Collide is that you can have the enemy game object passed into to your function here so the second function is what runs when there is an actual collisions With the Enemy so if you have here I think enemy and then here we're going to type it as a game object and here we need to import a quick fix import this type from Kaboom and yeah so we are ready to write the the content of it so if so here again I'm just going to go faster so here is the first if statement if the player is inhaling and the enemy is inhalable you're going to see this is going to be a property we're going to create later on when we going to create the enemies then what we do is we set the inhaling to being false we destroy the enemy that means that the player inhaled the enemy so much that they it collided with the player and that means that means it's swallowed so we can destroy the Enemy by calling the destroy Kaboom function where you pass in a game object to be destroyed and then player is full is going to be true and this is going to allow us to play another animation and the one where the the Kirby Kirby like character is seen as full and also is going to allow us to know if the player can now shoot a star the second if statement we're going to need comes right after and it's going to be this thing um now here Global game State we haven't created this for now so let's replace this with level go to level two for now we haven't even like put I created the level two as well I'm going to use the original what I've already had in the original code base to go faster because I think you get the point so if the player HP so HP is a method that is available since we have used the health component in when creating the player object and if it's zero that means the the player is dead so in the case we it was inhaling or the enemy was and the enemy was inhalable we would return early here so the the enemy would be destroyed but this is when the character the player hits the Enemy by accident or the enemy jumps on the player or something like that then if the HP is zero then we destroy the player and then we go back to actually we should go back to level one because we respawn so we go back to the current level and then we return early and then regardless uh so if if this continues that means that the player HP isn't uh equal to zero that means we need to hurt give damage to the player so by using the hurt function it's going to reduce one HP by default and then you can specify a number if you want to reduce more or less and then here is the logic that we're going to use for uh making the player flash uh blink we're going to use a first a tween so a tween allows you to change gradually a value from one value to another and here we're going to use await because we want the tween to be completed before we move on to the next tween so here what this tween is going to do is it's going to take the opacity of the player the initial opacity and the target value is going to be zero and the time we want to give to the tween to basically transition the player opacity from one to Z so because currently it's one it's going to be done in 0.5 seconds and this is the function that does the job basically of grad so every I think frame it gives you a new value and this value is set as the opacity so for example it's going to go from one uh 0.9 0.7 0.8 uh no 0.7 0.5 Etc until zero and this is where you assign it this value to the new value of opacity can do this do opacity and then finally the last progam is what is the rate of change so it's going to follow a linear function so it's going to be done linearly and here once this is done because we have an await because this is asynchronous by default so if you were to not use the await you could call this and then the code is going to continue to execute while this is still running so to avoid this we first await that the tween is done so we have our opacity that goes from one to zero and then once this is done we have our opacity going from zero to one so this is going to give you the blinking effect so that's basically it now we have finished the on Collide logic here for now we're going to have to come back here later on to change uh here to not hardcode this but for now it's fine now what comes next is another uncollided but this time around with the exit and this is the exit door we have created the exit collider and here it's going to again I'm going to replace this it's going to go to the next scene so on collide with the exit we just use the go function from Kaboom to go to another scene and by passing it the name and then now it's time to do the whole inhaling mechanic so to uh do this what we need to do is create our inhaling effect so this is the the sprite animation that you saw earlier on that gives the impression that the Kirby character is swallowing something and inhaling something and it's a game object that uses the AET Sprite but the specific curb inhale effect animation as default it has a position a scale the same scale and the opacity initially is zero and we give it a tag what we're going to do is that this animation is always playing but we just tweak when it is visible or not depending on the situation depending on the player input and then here what comes after is the inhale Zone the inhale zone is a hit box that is not visible it just contains an area component with a given shape which is going to be a rectangle and what this inhale Zone does it will allow us to know U when the player can actually swallow an enemy and here again we give it a tag those are going to come uh later on we keep an empty position here because we're going to decide on the position depending on the direction of the player and this is what this next bit of logic does so here so here we have an inhale Zone onupdate function so you can use the onupdate method on every game object and it's even a function that is can can be called independently what it does it it runs it registered an event that runs every frame as long as the game object exists in this particular form and what it does is that if the if the player direction is to the left we need to place the inhale Zone to be Min 4 to 8 and because remember that the inhale Zone and the yeah just the inhale zone is a CH is a child yeah is a child so because the inhale zone is a child of the player that means the position here that is specified here is relative to the player to the parent that's that's why it's going to be minus 14 plus the position of the of the the player which is the parent but we don't need to worry about that and here we can specify the position we can replace the position by doing equal and then passing in a vector 2 which is just an X and Y a a data structure for having X and Y values and a single structure yeah this is offered by Kaboom but it's a pretty standard in game development here the inhale effect position we're also going to Mo modify it but because the reason here is that the the inhale effect is not a child of the player and the reason for this is simply because uh we need to be able to make it to hide it or not and it seems that in kabum Jaz you cannot hide a child so reduce the opacity of the child without reducing the opacity of the parent so that's why I need to manually do a player position x minus a certain Val value and player position y plus a certain value to get the actual position I want the inhale effect to be in when the player is facing left and it y say yeah uh in inhale effect uh we need to flip X so the animation by default is drawn a from the right side so if you look at it here from the actually it's from the left side but we need to specify wait a minute so it's it's bit hard to explain but basically we need to flip the animation so if it's uh on the left side we need to flip it to being true and on the other end which is basically logic that comes after here we just do false so so that it goes to the the other direction or the default Direction which is the from the right the swallowing is from the right or the left I don't remember actually and then finally those are the last portion of code we need for the player here again I'm going to avoid this for now let's put level respawn at level one so here an on another on update but this time for the player specifically uh if the player position. Y is superior to 2,000 that means uh in the canvas the more you go down the higher the value of y so here what it essentially is doing is that if the player Falls and exceeds this value then we respond the player so basically it is considered dead we respond the player by just going back to the scene which resets everything the state of everything so we don't have to worry about resetting Val uh Health Etc so it does this automatically and then finally we return the player in the the function make player so this is how we get a player and I think we're ready to just test it out to see if uh what happens so in the main right below here right below the ad let's create our curb character here's the code for it so here we call this I'm going to import don't forget to import it and then you pass in the K and then level one point points player use the player key and then there's only one player so it's going to be at index zero because if you remember uh the spawn points are for each key it's an array even if there is only one because there is the case where there is more than one so instead of having to check when it's an array or not we just assume that it's an array all the way and if you know that there's only one player you just do a zero uh pass the index zero and it's going to give you just the the single player position X and Y now for the actually we should have set the controls but let's do that later now here let's add the curb corrector to the scene because remember in make player we just use the make Kaboom function not the ADD and let's write some Logic for the camera so the camera is really automatic in Kaboom J you there's only a few things you can do uh so you don't have to write a lot of logic in the sense that sense so here you can specify the scaling of the camera so we want to have it at 0.7 this is what looked good for both X and Y coordinates so here it's either either you repeat actually in the end it's the same so you could have decided to write 0.7 by 0.7 which is actually shorter to write and then for the on update function this is an on update that is General so if you see here register an events that runs every frame not until the the object is destroyed because it's not attached to any object and here we're just going to make the charact the camera follow the player in a certain way so if the the position of the curb character the player curb. p.x this is how you access the position is inferior to the level one layout. p.x so the um basically where the level start plus 432 pixels this is what look good as long as it's inferior to that we want the camera so by using the Campa method uh function to be set at the camera the curb pos. X plus 500 and then at the height of 800 so the the y coordinate of 800 this is going to allow the camera to follow the player along a certain point and not exceed that point uh because if it exceeds that point then you're going to see the end of the level or basically way for you to avoid having to show more than what you want to show in the level so if you're at the end of the level you don't want to the player to to look very far to the right for example and here we add the position of the player plus 500 so that the camera is really the player is going to find themselves to the left side of the screen and they're going to be more space available on the right side so that the player can see further along this is something that uh it's really handy especially if you're making a Sonic type game because you want the player to be able to see uh as as far as possible for this type of platform it's not that necessary but I thought it looked better so now let's look at the result I'm curious to see if there's anything is anything going to change all right we can see our level but now we don't have the movement control uh movement controls and this is what we're going to deal with in an instant okay so now that we have the camera working and the character being displayed I think it's best to just uh start working on implementing the player controls so that we can truly see if the camera is actually working so by player controls I mean all the mechanics of the Kirby so moving swallowing floating Etc to do something like that I'm going to go to the entities folder uh file sorry not folder and in there we're going to create a function right below so this function is going to be called export function set controls and it's going to take two things the context as always but it will also talk uh take the player object now here I could have simply gone with the game object here as the typing but we want it to be specifically for the player so this is where a new type we're going to create a new type so the way you can go about creating types is either you create them all in a folder in a specific file and then you pull them out from there or you create them where we need them and really here in this project the the current state of the project I might expand the game later on but on my own but for the tutorial uh really we're not going to export any typing really there's only this type and you could have decided not to use it but I think it's it's best pra like it's a best practice to create a specific type for the player because there are some behaviors like you're expecting that the game object past here in the set controls function is going to have some components uh some some necessary components so the way you type uh a game object in Kaboom Jaz you can take the default game object type and then add to it here the various components you need so we want the following so I'm just going to copy and paste it and then talk over the content so this is going to go much F faster so here is the typing definition now all of these need to be imported from Kaboom so update import from kboom uh I should have just clicked here and I'll add all missing Imports all right so to explain so the player game object is a is a type that is a game object that has the Sprite comp component the area component the body component the positional component the scale component the double jump component the health component and the opacity component and it has the following properties the speed the direction is inhaling and is full Boolean and this in make player you can see that those are were the properties here so the goal of this is that if so somehow you were to use this set controls on a mob for example which is just a regular game object then you would have squiggly lines and typescript will tell you that hey you're not entering the correct type so I'm just going to put player game object here and now let's write the body of this set controls function so let's do that give me a second okay so first of all what we need is actually um I need a reference to the inhale effect that we had so I'm going to create a constant called inhale effect ref which is this uh here in the original code base that we had and this is a way to to neatly get any game object you need is you pass in the tag to the get function from Kaboom here inhale effect and it will return an array containing all the game objects that have this tag so here we only have we're expecting one so I'm just going to take the one at index zero this is going to be useful because here in the controls in the input is where we're going to decide whatever or not to show the inhale effect of the Kirby like character so really we need to start coding the player movement the way you do this in Kaboom is by using the Onkey down function and it passes to you the key that is being pressed so here I could just have a switch case statement so switch K here key here you could have left it as an if but it's more concise to use a switch case statement it's a matter of preference so also sometimes it's clearer to just use if statements so for the left case we're going to first set the direction of the player like this since we uh previously decided that those are the properties we we needed and because we created them we added them here they are available to be modified in red here and as long as you have access to the game object for the player so here we're going to change it to left or set it to left regardless of what the previous Direction was we're going to flip the player horizontally by using the flip X property this is offered by Kaboom if your game object has a Sprite uh users the Sprite component so we're going to have true set it to True here regardless and then finally to move the player it's in kabj it's really simple you call the move function and passes in a velocity an x velocity or a y velocity here we just pass in the player speed and Y velocity is zero so the player is going to move here to the right but you have to do minus to get to the left this is very simple and then you of course you have to break otherwise the other cases are going to run this is something like in JavaScript I don't think in other programming language it's the case now we have the right case and it's basically going to be the same thing so I'm just going to copy and paste but just different values here and then after that we have the Zed case uh the the case z when the player presses the Z key this is where we're going to uh basically make the character inhale so simply within this we're going to have an if statement if the player is full then we need to play the the curb full animation curb full animation once this is played or is playing we can show the inhale effect uh no actually hide the inhale effect by setting the opacity of the inhale effect ref to zero if it were visible and then we break here and then in here and then right below we we are still in the Z case if that was not true so the player was not full that means it's time to let the player inhale so is inhaling is going to be set to true and then we're going to play by calling the play function the curb oops curb inhaling that's the name of the animation and we're going to show the opacity so uh we're going to set the opacity to one so that we can show the inhale effect so now that we have this we simp we can break for real as well here and then we need to when using a switch case statement to have the default which is going to be empty in this case so now we should be able to move left and right let's let's look at it so if I use if I maybe should refresh the page oh I haven't called it so so it's it's not going to work so if I go to main.ts and I go right be before adding it to the scene that's called the set controls function it should be imported automatically and pass in the curb character uh of course the context first as well now if we look at the result I should be able to move and then when I press uh Zed I'm making the sound effect but but for now you see that even if I left um I stopped pressing the key Zed key the animation is still going on because we need to have a Handler that checks when we release a key as well and by the way if you press F1 you can see the various collisions here so yeah let's go back to the code base let's go back to the entities code and here I'm just going to collapse the Onkey down function now Onkey press this let's implement the jumping first I think and then we'll go we'll go with the the Onkey release so here same logic we pass in the key oops not page transition you know what I'm just going to copy the code just to be fast and then talk over it maybe I should start just doing that for all tutorials so key on key press we have the key here here uh this feels like unnecessary code you could have just have a simple if statement I'm going to leave it though in case you want to make multiple allow multiple characters to be used for jumping and here we can use the double job double jump method and the reason we can use that is because we used when defining the player game object the double jump component so this is what allows the Kirby like character to float to jump 10 times basically okay now here it's time to do the on key release so on key release here we go and then again here it's a switch statement I don't remember if it's going to be that much useful it's a single case you know what just to make the code better you know if key equal equal x let's remove all this unnecessary stuff let's not over optimize or yeah and even this is not necessary and then I of course need to remove that for the the linting the the formatting sorry to work so here if the key you do this actually um yeah anyway yeah there could be say that the switch case statement syntax is not that uh concise so yeah okay so on the on key release we have the key and then here I'm going to use a if statement instead of a a switch ke again and here if the Z key is pressed we're going to do a bunch of stuff so here if the Z key is pressed and we have another if statement usually I don't like that having a multiple ifs within let's keep it as is for now and I'm going to see if if it makes the code any more difficult to understand or if it can be improved later on so if the player is full we do something so we need to play the curb curb inhaling so the reason we're playing the curb inhaling animation when the key Z the Z key is released if the player if the player was full that mean they swallowed an enemy is because the animation so the image for both uh swallowing inhaling and um say shooting or spitting out the enemy the the star is going to be the same I thought it would work for both cases so that's why it's playing this animation here okay now let's do a const here and call it shooting star and this is going to be a game object that basically the projectile the star we're going to create it it's a disposable game object we just created here and we write everything we need for it here no need for mod rizing though uh if you if you were to expand this game and maybe make you know what what a good exercise you could do with this is try to make the C implement the copy abilities of Kirby so Kirby in except for the first game not only can he inhale enemies and throw stars and stuff like that but can inhale enemies and then use their powers so become a fire Kirby Etc okay so for shooting stars uh yeah we just going to need a to use the Sprite component and here the animation we're going to specify is shooting star I think we already defined it earlier on and we can also set the flip value so the direction from which you want the animation to play Within the second param because this is very disposable and we want need to change the direction afterwards because what happens is the projectile is uh shot and then it just goes to the and as soon as it either hits an enemy or a wall it will destroy itself so here we can do a simple depending on the player direction if the player direction is equal to right then this expression will evaluate to true and if it evaluates to true that means we need to flip X so that mean we're going to flip the start to be at the right direction because by default it is uh to the left like that and that's basically it I think yep now we can continue on so k. area here going to have a shape now here you can tweak these values so I'm just going to copy over the code that we need uh if it's at all possible uh let me just copy the whole thing so I'm going to copy the just the rest of the the code for this game object and I'm just going to go over it so here we have a specific shape which is a rectangle with this offset and then 6X six Etc by the way if we look at the the output and I press the F1 key you can see the the Box the hit box for the Cur Kirby like character so here and uh depending on how you position the Sprite I made sure to position the Sprite a bit above that's why the offset here was a certain value I think it was where it was where it was 4X 5.9 play with those values and you're going to see what happens and get a better understanding than me trying to explain it to you with words okay so we have the shap the the shape of the hitbox defined here then for the position it depends if the player direction is to the left then the player position. X is going to be minus um yeah we're going to take the player position to the we're going to take the X position of the player and do minus 80 otherwise if it's to the right plus 80 and this is so that uh when you shoot from the left and the right it corresponds you know because the the star is mirrored and it's going to go in a different direction so play with those values you're going to understand here for the Y there isn't much difference between either right or left Direction so it basically this what looked good taking the player position the white position of the player and then adding it five to it uh you can play with those values if you'd like and then of course we need the scale component as I started this game uh because as I said the pixels aren't going to be drawn properly where one pixel takes one pixel space but a second pixel can take uh 1.5 and this Distortion is a bug in Kaboom JS and the way to fix it I found is this it doesn't happen always so I think it depends on your resolution so if you were to make a game that is of a higher resolution you wouldn't have this issue I didn't have this issue very much before so it really depends on the resolution you pick it seems and then here depending on the direction we can use the move component the move component will just move the Sprite the the game object towards a Direction so that's the first paramet if you hover over it you can have a direction it's either a number or a vector to and here I'm just using the constants provided by Kaboom which is the left and right direction so if the player direction is to the left that means we need to make the star the shooting star move to the left otherwise we need to make the shooting star move to the right and then we add the shooting star tag here so that we can later on have a not later on just right now basically I'm just going to copy and paste it as well so right outside of this definition I'm going to have this on cied event listener uh that um actually yeah this this tag is going to be useful I think later on for other other things other event listeners because we don't need the tag because we already have a reference to the shooting star here so if the shooting star un collide with the platform tag so with any game object that has the platform tag then k. destroy is using the Kaboom function to destroy the shooting star so that's basically it and then here it's done and then finally what is needed is simply to put the player is full back to being false since we since the Kirby like character has just shooted the star so that they should be able now to uh swallow someone else another enemy and then you we're going to use the wait function from Kaboom that is going to wait one second before um making the player play the idol uh the curb Idol animation curb idle animation here we go here in case you didn't see it here it is so this is a kaboom JS function to do that and then we return early the reason we return early is that if we don't do this we can just go here and just set the inhale effect ref of the opacity to zero the reason we're going set it to zero is because now the Kirby like corrector has done inhaling so we don't want to show the inhale effect and then we set player is inhaling to being false as well because they're no longer inhaling anything and then we put the player back to idle that was the case if the um that was the case if the player was not full initially so can we can we make this better by removing this if statement I think we could have this as a second condition and then no I think it's best to just keep it as is by the way the source code is dis is available in the comment SE um not in the description so feel free to refer to that if you want okay uh I think our code is done for this so let's try it out let's try the output so I can jump I can inhale and then when I stop pressing it stops and then you can see the inhale Zone in the headbox so looks nice and then if I just go here there's no level two for now okay our game is is working and one thing about the camera I said that it follows you up until a certain point and then it stops here oops okay and then one thing I noticed is that we don't see the little thing here at the bottom so if I go back to main.ts and maybe instead of this I put 900 here uh you see this I wanted to see that so maybe 850 is going to be a good value but then again this is due to the specific map we we drew together instead of the original map from the the uh the original source code I made yeah maybe a bit more 70 should be fine does it work okay it seems to look good okay now it's time to work on making the enemies inhalable but before doing any of that we should uh probably probably write the code for the enemies so I'm going to go back to entities I'm going to collapse this as well let's write another function for making the flame enemies and to go fast this time around I'm going to just copy and and talk over it I think it's going to be better so here it is ah but it expect the anyway yeah let's forget this for now okay so we have this function called make flame enemy and it's going to be the flame NPC here uh enemy so to make this we need the context we need the a position X and Y position then we use the same thing but this time around I um I use the add function that might be uh because we just created immediately I don't think it's that big of a deal anyway uh doesn't matter for this game it doesn't matter if you use make or add just that if you use make you have to use add later in main.ts so here we have a flame character basically we set the animation we set the scale we set the position which needs to be according to the scale so that's why we multiply by the scale then we have the area which is the headbox for it and then the Collision ignore which is it needs to ignore collisions with other enemies the reason for that is and we use the enemy tag here the the reason for that is that for example the bird is flying on top and then the the flame is going to jump and we don't want both to collide we want both to continue doing their thing without any collisions so that's why we ignore the Collision if it does occur so it has no effect on the game we use the body component and then the state this is something new because we're going to define the AI from for this little Flame character and the way you do that is using a state machine and a state machine contains basically different states and then for each States you for each state you need to define the behavior and the what happens what makes it go to another state and what happens when it enters the state and what happens when it remains within the state so here the state component kabon JZ takes a default State and the list of all possible States here I've have the my state machine as being two states Idol and jump and we start with the idol and here finally we have the just add the the enemy tag and this is going to be useful for both this so that the enemy can ignore collisions with other enemies so for example two Flame character if they were to collide together we don't want them to have any effect so we don't have we don't want them to push it push uh to push each each other and it could be fun and weird to not have to have enemies being able to collide with each other Etc but it creates too much unpredictability all right so how do we Define the state so here once you have used the state component you use the on State under function to Define for this state what happens what is run when we enter the idol State and here I just use the Kaboom weight function but this time using the await keyword this is just so we have it as uh we have it sequentially so the weight is asynchronous by default that means if you don't put the await keyword it's going to run and the code the rest of the JavaScript code is going to run after it as well while by using the await keyword what it means is that we wait one second before moving on here so that's why I wanted this await here so that I don't I don't want the to move on to another state before we have waited 1 second so once we wait 1 second we enter the jump State once we arrive in the jump State we Define here what we do in that case so on state enter jump we just make the player uh the not the player the flame jump and we can use the jump function provided by Kaboom if your game object uses the body component and here we specify a jump Force this is just how how so like the name it's the force of the jump and it can it can be tweaked and I think 1,000 was the value that looked best and then finally once this is done there is another thing you can Define for a same state it's called on state update and here as it says register an event that runs every frame when in a specific state so while we are in the jump State we want to run the following so if the flame is grounded this this is a function method provided by Kaboom if you use the body component so want uh yeah so it basically checks for you if the flame is on the ground on a platform and if it's the case then we can just enter the state Idol again and basically this is a simple AI so just to make things clear uh what what this AI does is just it waits one second it jumps once it hits back the ground it enters back into the idle State Waits one second and then jump again Etc so it's not something fancy but yeah it it's a it's an obstacle I guess and then we return of course the flame and then we return of course the flame game object now let's make this make inhalable function that is going to be applied to All Enemies so right below set controls I'm going to again copy and paste the code for it and then go and explain it I think it's going to make much better explanation so I don't have to focus on typing while explaining and I don't waste time typing while while I could be explaining okay so here make inhalable this is the function takes the Kaboom context and a enemy which is just a game object so here we specify a bunch of on Collide event listener so when the enemy collides with the inhale Zone by using it stag we make the enemy is inhalable equal to true now here didn't exist before so not only you can create properties so you can create properties on the Fly for a game object and maybe it would have been better if here in the game object you want to create you create the property first instead of just relying on this but for this tutorial I think it's fine so if the UN Collide yeah so if if the enemy collides with the inhale Zone then we said is inhalable inhalable true so the inhale zone is this in the game when I press F1 it's this this part and by the way the debug the debug mode tells you the position of each game object and also the uh the tag for for example this is a platform this is the exit and I think that's it and this is the inhale Zone this is the player Etc okay now that we have something like that we have the uncollided end which also exists so as soon as the Collision is over maybe because the enemy moved away or the player moved away then we said the is inhalable to false so that the player could not inhale someone not in inside of the inhale Zone finally we have also the enemy on collide with a shooting star this is where the shooting star becomes useful and we run the following function what is really handy with oncolite is that it provides you the game object that is the tagged here so it it pulls it out for you and you can have access to it so here I can just do destroy the enemy and then destroy the shooting star um one thing I want to make sure though is in set controls maybe I wrote destruction logic here uh where is it where is it here okay I wrote for the platform here so if the platform collides with the shooting star then the shooting star is destroyed but this is a different k that we have here in make inhalable is if the enemy hits collides with the shooting star we need to destroy both the enemy and the shooting star that is here provided here and then here I use the player ref to get the player so the same way I did it earlier on with uh some another game object I don't remember and then here on update runs every run register an event that runs every frame as long as the game object exists if the player ref so if the player is inhaling and the enemy is inhalable that means we can actually do the the inhaling and then here if the the direction is to the right that means we're going to make the enemy move towards minus 800 so to the left with a a velocity a x velocity of 800 and if it's not the case then we do that we assume that it is to the left side and then we make the character the the the enemy inhaled a move to the actually it's the contrary so if the if the direction of the players to the right we move to the left the enemy mooved to the left otherwise it's the reverse and that's basically it and then now here when I commented out make inhalable I can just comment this back in and then yep that's it now let's write in main.ts the logic for that so right below where we wrote the logic for the player let's do it let's do the same for the flame enemy and it's going to be very simple we just need a for Loop and here I'm just going to import here and save of course so now const flame of level one spawn points. flame and then it gives you all the flame characters uh mobs and then you can just display them like that create them and that's it okay now if I look at the result make flame enemies is not defined really maybe I did not uh make flame enemy is defined maybe the import wasn't right what do you mean it's not defined um did I use the proper tag let's look at here we have flame if I look at level one we have flame flame flame flame everything seems to be correct so why it's not working let's look at okay it's working it's just uh it didn't refresh soon enough all right so as you can see I can swallow and then I can shoot I can swallow oops I took damage and then I can shoot and that's basically the game everything from this point now is just Improvement and increasing the scope so here in entities let's write the code for the guy enemy I'm just going to copy and paste it so yeah so let me just uh there's still some explaining to do it's not exact the same thing but it's going to be mostly similar so here I paste it and then let's go through it together so we have the make guy enemy function takes in the same params as make flame enemy uh basically the same components just the different animations and for the state it's okay here I used is an inhalable I added it to make flame enemy uh to the guy but not here so what we could do is just um let's add let's add it you know just to make things correct so I'm going to add is inhalable going I set it to True uh to false by default and here we go okay so the state machine here is going to contain more States it's going to take um actually this jump I did not implement it I wanted to the character to jump after moving left to right you can do that on your own but that's it has three states idle left and right and it start at idle so at the idle State same thing we wait and then we go to the left State we flip X false we set it to false in case it were flipped to the right which does occur when the right here using right when going to the right and then we wait 2 seconds before going going to the opposite State and while it's doing this while we're currently in the left State then we move to the left at a certain speed defined here and this is the same logic but duplicated and just tweaked so that it's the same for the right now we flip X to to being true because you know the the Sprite here the guy is is U facing left and Toad the right and then here here we move with a positive value instead of a negative value now if I go back to main.ts and I go back here we it's another for Loop same logic import this if not already save and that's it now The Last Enemy is going to be a bit different the bird enemy it's not going to have an AI really it's just going to move into a direction and that's it and it's going to spawn on continuously so I'm going to remove this not remove it I mean collapse it and let's write the last function for the enemies and then we're basically done with this so here I forgot to have the closing function uh the closing bracket the function sorry okay so we have make bird enemy takes this time around four perams instead of three only difference is the speed because it's going to vary each time we create a bird so here we have a bird in me basically the same thing and then is static being true now this it isn't necessary to have it to be static so let's remove that and it's going to move to the left by default at a certain speed that is defined by here and then we have the offscreen component and this is something very interesting if you're making planning on making a more uh more expanded game is that you want things to not render when they're offc screen at a certain point of course here if the distance from the the viewport is higher than 400 or equal then we destroy the bird because we just want birds that comes from the right and goes to the left indefinitely and for all those birds that were go were to the left then at some point we want to destroy them to free space I guess so as to our game not to coll have a frame rate that collapse and overwhelm our our our web browser I guess okay so we make it inhalable the the bird of course and then we return the bird and now what changes is here instead of having a simple for Loop we're going to have a a for loop as well and then here of course import make bird enemy and here we're going to use the loop function so here for bird in level one spawn Birds we have here a constant that defines the possible speeds we want to have 100 200 300 and then we use the loop function from Kaboom to basically Loop every 10 second it this will run so it's a clean Syntax for set interval if you're familiar with the JavaScript function for that now make bird and me is going to take in a random element from here so it's going to randomly pick either 100 200 or 300 by by using this logic so this is a very a common piece of code you see online where you do the math random times the length of the array then you floor it and this gives you an element within the array Is Random and that's it I think we have finished so if I go back to the browser you can see the guy is walking and if I were to just shoot now you see that they didn't appear okay now I understand why I had the his body static because it's affected by gravity so if I come here so if you're far enough away you're going to see the star otherwise if you're too close close to an enemy and you shoot the star it's going to disappear the star is both the star and the and the enem is going to disappear too fast I think and if you are to do if you want more better feedback a better feedback loop for the player I think it's be best to change this so as you saw the birds are just falling down and that's because we remove the is static and we don't want that after all so it makes sense to have here is static so that it's not affected by gravity the the birds now if I go and I look at the birds you can see they're coming in and I can shoot them and here we go now here it is and then of course there's no level two for now and you know what I think I'm not going to implement the level two I think try it out on your own try to create a second layout use the thing i' I've explained here and do the transition between yeah I think it's best and of course you can reference the the original source code I have the Gib Hub repo feel free to download it look into it Etc so yeah I think I'm going to end the tutorial here just not to make it too long and of course the concepts I I don't want to rehash the same Concepts all the time but I hope this tutorial really was clear that you understood how to make games using typescript and Kaboom JS so yeah thanks for watching And subscribe for more content so is it running at 60 FPS it is all right thanks for watching bye all right so I forgot a very important part of the tutorial which is how can you actually publish your game so when you're using a tool like vit like we did in the Kirby tutorial you need to use uh you need to create a vit vit V vitc config.inc from vit and then export default this and then here you need to specify those three Pro uh those two properties so the base need to be do slash otherwise when you're going to do npm run build uh you're going to get some that won't work H so if you open this using for example live server what's in the this folder then it's going to be um how how do I say it you you're going to get an error now you need also to disable the minification in vit uh this is an issue with Kaboom ja specifically I don't know in the future if it's going to still be an issue so try it without and with so once you have done this configuration in V.C config.sys at the root level of your project what you should do is just run npm run build so npm run run build and then it's going to run your compile your typescript code Etc so if you then you should see a disc folder appearing and this is the folder you need to zip you need to zip this and then you can put it on itch.io for example so here if I right click and open it with live server just to test out that things are working you can see that the game is actually working all right that was a little bonus that I forgot to include uh so hope you're still watching at this point thanks for watching bye
