00:00 - Hey everyone.
My name is Mikaela Caron.
00:02 - I'm a full time iOS developer and recently
I've been learning Vapor,
00:05 - so I'm excited to show you how you
can use Vapor to build your own API.
00:09 - So if you go to Vapor Xcode,
let's learn like what is Vapor?
00:13 - It is a web framework so you can use Swift
to build the website back end of your iOS
00:19 - app rather than using something
like NodeJS or Express JS.
00:23 - So let's get started installing it.
00:25 - First we need to install Homebrew.
00:28 - Homebrew is a package manager for macOS,
00:32 - so scroll down to Homebrew and then
the website is Brew sh that will be
00:37 - in the links below
and just copy this and paste it into your
00:42 - terminal, but I already have it, so I'm
not going to put that there right now.
00:49 - Next we need to install Vapor.
00:51 - So when you're on the main Vapor
website here click on Docs
00:58 - and then install macOS and then
that will bring you to this page.
01:04 - So first you need to download Xcode if you
01:06 - don't already have that
and then go down to Brew.
01:11 - Install Vapor.
01:12 - So copy this and again paste it into your
01:15 - terminal and that'll take
a second to download.
01:18 - So to double check that you have
everything installed, you type Vapor
01:24 - help and then you'll see this like
list of commands that you can run.
01:30 - We are also going to be using Postman, so
Postman can help you test the API side.
01:35 - So our Vapor API without needing like
the iOS app fully functioning yet.
01:40 - So go to postman dot.
01:41 - Com to their downloads page
and click on download the app.
01:46 - Lastly, we will install Azure Data Studio.
01:49 - So Azure Data Studio is basically a Gui
01:52 - that we will be using to read from our
database, so we can read the data in our
01:56 - database without needing the API
and without needing the iOS app.
02:01 - So this is the Microsoft product,
02:03 - but scroll down to macOS, download
the Zip file and also note right here.
02:09 - It is not compatible with Arm
02:10 - architecture, meaning it's not fully
compatible with the M one MacBook.
02:15 - So you may need to use like Rosetta or
02:17 - something to open it and download
and make everything work properly.
02:23 - Otherwise you can use this application
called Dbever to look at the database.
02:27 - I didn't want to use this one because I
think it's uglier,
02:30 - but you can use this one to download
it or to view the database.
02:36 - And lastly we will be using Docker.
02:40 - So go to Docker.
02:41 - Com and go to their downloads again
and then download Docker desktop and make
02:46 - sure again you choose the right one
for the operating system that you're on.
02:49 - And after you do that
02:52 - open Azure Data Studio
so it'll look like this and you can see
02:57 - it's an open source Microsoft product,
so it looks very similar to Vs code.
03:02 - So click on this button and Chris like the
packages and extensions that you can do.
03:07 - So just search Postgres SQL and this is
the one by Microsoft and make sure
03:13 - to click install which Mine says
uninstall because I already have it.
03:17 - But click on install and then that'll help
03:19 - us because this is the type
of database we will be using.
03:23 - So once we have all of that,
03:26 - let's go and create our new project
so you can see the commands here.
03:30 - Tell us what we need to type.
03:32 - So we need to type paper new to
generate a new application here
03:40 - and we will call this
03:46 - Ytvaper API.
03:48 - So hit enter and it'll start
creating our new project.
03:51 - So do we want to use fluent fluent is what
03:53 - is called an Orm which is
an object relational Mapper.
03:57 - And we will be using that in this project.
03:59 - So type Y and then hit enter
what type of database do we want to use?
04:04 - So we will be using Postgres for this.
04:08 - And then do we want to use a leaf?
04:10 - We are not going to be using that for this
04:11 - project, but it's a templating language
like for making some of the website.
04:17 - So you'll see it ran.
04:19 - If we make this a little bit bigger, it
generated all the files that we needed.
04:23 - It automatically creates a Git repository
for us and creates our own commit,
04:27 - so we don't actually need
to go through those steps.
04:31 - Here's the pretty little water droplet,
and then CD Ytvaporapi.
04:37 - So that is our project.
04:41 - And then we use Vapor Xcode
to open the project index code.
04:44 - So we CD into our project directory,
and then I do have an extension on here.
04:49 - So that's why Mine may look
a little bit different right here.
04:53 - And then we type a vapor code
crew the project.
04:58 - So the first time that we
opened our project here,
05:02 - I'll put that down there
05:04 - it is going and getting all
05:06 - of the different packages
so you can see right here.
05:08 - It's Loading and fetching everything.
05:11 - So we have to wait for this to finish.
05:13 - And while we're waiting for that,
so what we're going to be making is
05:18 - the back end for an iOS app
that will then talk to a database.
05:22 - So the four database operations are
create, read, update and delete.
05:27 - So what that means create is
adding new data to the database.
05:30 - Read is reading the data
from the database.
05:33 - Update is updating any data that's already
05:36 - in the database, and then
delete is deleting it.
05:38 - So when we write to the database,
we're performing these three operations.
05:42 - So we'll be doing create so that's
05:45 - creating some data on the iOS app,
sending the data to our server
05:49 - to the Vapor API and then that sends
it and saves it to the database.
05:54 - And then when we update and delete that's
05:56 - again an operation coming from the iOS app
telling the API to do something,
06:00 - the API taking that and doing
something to the database.
06:03 - And then when we go to read
06:04 - from the database, it starts
with the iOS app asking for data.
06:08 - It goes to the API or the server
06:10 - that tells it, hey,
this is what data we need,
06:13 - and then it translates it and grabs
that data from the database.
06:16 - So the database takes that data.
06:18 - It gives it back to our server
and then sends it back to the iOS app.
06:21 - So we had to download Homebrew,
06:23 - which is a package manager that we had
to use to download everything else.
06:27 - And we had to download postman postman
06:29 - allows us to test the API without actually
needing to create the iOS app first.
06:34 - And with the database we are going to be
using Azure Data Studio or possibly
06:39 - Dbever, if that's the one
that you had to download.
06:43 - And that allows us to look at the data
06:45 - directly in the database
without having to use our API.
06:50 - So first things first.
06:51 - Let's run the project.
06:53 - So we click Command R.
06:56 - Like any other iOS project,
06:57 - it starts to build a project and make sure
the scheme that's selected is my Mac,
07:03 - and now we get to wait for it to build.
07:07 - You can see these are all the different
packages that are inside of our Xcode
07:10 - project, and these are all the different
things that Vapor needs to be able to run.
07:15 - Okay, after running your project,
07:17 - it may take a while to build on the very
first try, but you'll get this warning
07:21 - saying no custom working
directory set for the scheme.
07:24 - This is because by default it tries to run
07:27 - your application from
the Derive Data folder.
07:30 - Close that from Derive data,
but that's not what we want.
07:33 - We want it to run within this scope.
07:37 - So if we stop our application,
07:40 - click on this button
and then click Edit Scheme
07:46 - from here.
07:47 - Go to make sure you're selected
on Run and then go to Options.
07:51 - We want to check use Custom
working directory from here.
07:56 - Click on the little file folder
and then go and find your project.
08:00 - So find the project
in Finder and then click choose.
08:05 - So make sure you select your folder
08:09 - and just click close.
08:11 - And now when we run our project again,
08:14 - it should build faster this time because
it's not the first time we're building
08:18 - the project and we won't
get that warning anymore.
08:22 - Okay, so you may get this prompt says Run
would like to access your documents folder
08:26 - or this is wherever you
ended up saving it.
08:28 - Just click on.
Okay, you may also get this error.
08:32 - So this is warning like address
already in use for some reason.
08:37 - Every so often it doesn't fully detach
08:40 - from the process when you're
running your application.
08:43 - So what we need to do here is type
08:52 - Lsofi80.
08:57 - 80.
Which
08:59 - that's the part that we're trying to use
09:02 - Port 8080 and this says
it's already in use.
09:08 - So if we do this, we'll
see something like this.
09:11 - So Localhost is already using this.
09:14 - What we need is this number PID.
09:25 - So don't mind this.
09:26 - This is part of my terminal.
09:28 - I have like extensions on mine, but type
kill nine and then that PID number.
09:35 - And when you do that, typing the first
command again, we don't get anything.
09:40 - So if we stop our application and run it
again, everything should run like normal.
09:47 - So here we go.
We said server starting on http.
09:52 - 1270, 180 80.
09:56 - So if we open postman
09:59 - right here and go to that address,
if we click, send
10:06 - it's, sending the request and we get back,
it works, which is great.
10:09 - It's exactly what we want to see.
10:11 - And then also by default, another route
which we'll learn about is in there.
10:16 - So if we click send on Hello,
it says Hello world.
10:21 - So that is exactly what we want to see.
10:23 - And we know our project is working.
10:27 - And then you can see
in the debug log here.
10:29 - The first thing we did
was the root directory.
10:32 - So that's where we just went to this
address with no extension or route on it.
10:38 - And then that's just the request ID.
10:40 - And then we went to slash Hello and we can
10:41 - just see both of those
requests that we made.
10:45 - So let's look into the file structure.
10:50 - Let's first look at package Swift.
10:53 - So Package Swift is our package manifest
10:56 - for SPM, which is Swift package manager,
and Vapor heavily uses that.
11:00 - So you can see right here.
11:02 - We have a little package.
11:03 - And then if you actually look
11:05 - at the contents of
this directory for our project,
11:11 - we actually don't have
an Xcode project file.
11:14 - That's because this is like a package.
11:17 - You can see we're using Vapor right here.
We are using fluent.
11:20 - So we said that at the beginning
and we are also using Postgres.
11:26 - So if we open up sources sources is
where all of our code is going to live,
11:31 - and we look at controllers by default.
11:34 - It gives us a to do controller
11:38 - by default.
It gives us a Todo application.
11:41 - So here this is where we can group logic
11:44 - inside of controllers rather than
putting it all on a single file.
11:48 - Migrations are used with the database.
11:50 - So we'll be making what are
called database migrations.
11:53 - And this is things like preparing our
11:55 - database, meaning creating
new tables in our database.
12:00 - We have our model.
12:01 - So this is what models the data
that's in our database.
12:04 - And we can use these
within our application.
12:07 - And we have the configure function.
12:09 - So this just has one function in here and
it configures the database we'll be using.
12:17 - It adds our migration and it runs
the routes function and then routes
12:21 - function is where all of our routes are so
different endpoints that that will be hit.
12:25 - We will be requesting
from with our iOS application.
12:29 - So we saw first the get route
12:34 - right here.
12:37 - We just hit this basic
1270 one at Port 8080.
12:42 - It returned.
It works.
12:44 - And then when we did Hello right here,
it returned Hello world.
12:48 - So these are the different
endpoints that our API has.
12:52 - And then here's the to do controller
12:54 - because the controllers
have their own routes.
12:57 - Instead the run folder.
12:59 - This contains the code that we need to get
13:01 - our application up and running
so you can see right here.
13:04 - It calls the configure function
that we defined right there.
13:09 - Instead of tests.
13:10 - By default, Vapor gives us
a unit test that we can use.
13:15 - So the unit test right here
is starting the application.
13:18 - We are going to the route Hello.
13:20 - And then we want to assert that this says
okay, and it gives us back Hello world.
13:25 - We will not be going into unit testing
13:27 - for this series, so we have
a Docker compose file.
13:30 - This is used to create
a multi Docker application.
13:33 - So this configures our API to run and
for the database to run in Docker file.
13:39 - This is what is used to actually create
13:41 - a Docker image, and I honestly don't know
everything that's in both of these files,
13:45 - but we will get into that
a little bit later too.
13:48 - And last is package resolved.
13:51 - These are the exact versions
13:54 - of the packages that are inside of our
project that are defined in Package Swift.
13:58 - So if somebody were to download and clone
14:00 - your application from like GitHub,
they'll use these exact versions.
14:06 - Unless you go and ask
to update the packages.
14:10 - That is the end of this lesson.
14:12 - We installed all the tools that we'll need
14:14 - for creating our Vapor API
with our iOS app.
14:17 - We had to install Homebrew,
which is a package manager for macOS.
14:21 - We installed Vapor, we installed
Postman and Azure Data Studio.
14:26 - We created a project and ran it
for the first time,
14:29 - and we used Postman to hit the default
route and the Hello route.
14:33 - So this is the first video
that I've ever recorded on YouTube.
14:36 - So let me know how I did in the comments
14:37 - and if you have any suggestions,
I will see you in the next part
14:42 - for this video, I'll show you how to use
Vapor to create tables, use migrations,
14:47 - and how to read and write
data to the database.
14:49 - For this example, we are going to make
a list of songs to read and write.
14:54 - Hey everybody, my name is Mikayla Karen.
14:56 - I am a full time iOS developer,
and recently I've started learning Vapor,
15:00 - so I'm excited to show you how you
can use Vapor to build your own API.
15:03 - Okay, so here we are
in our project directory.
15:05 - When I type LS for list,
you can see all the different files
15:08 - that we have so we can open
this by typing Vapor Xcode,
15:15 - and then you see it says
Opening project in Xcode.
15:18 - Okay, you can see when we open our
15:21 - project, you have all of the
packages starting to load.
15:24 - So all of the packages,
these are all the ones that we need
15:26 - for our project and Xcode is going
and fetching everything for us.
15:31 - The first thing we'll learn
about are what our routes.
15:34 - So we looked at that briefly
through the last project.
15:37 - Or when we built the project for the first
15:39 - time, we open up this routes file
and we see app yet, and it returns.
15:45 - It works and then app yet.
15:47 - Hello returns Hello World.
15:49 - So if we open postman
15:53 - and you may not see these,
15:54 - I just added these because
we will be using them later.
15:56 - But if you just click on the little
plus here, it might be over there.
16:00 - You can create a new request,
16:03 - so we will request from
this after we run it, which
16:10 - we'll have to wait for mine to finish
building for the first time.
16:13 - So you can see it's still
fetching everything.
16:16 - But what we're going to do is we'll see
16:18 - that when we just hit the base route,
it returns, it works.
16:22 - But then if we hit the base route
16:23 - Helloworld or Hello,
it gives us Hello world.
16:27 - And so this is our route.
16:29 - Really.
16:31 - But when we open the project for the first
16:33 - time, we actually have
a bunch of files here.
16:37 - And this is a to do controller create
to do a model called to do because
16:41 - by default, Xcode gives you a to do
project to start everything.
16:47 - Let's type this.
16:52 - Let's go to this.
16:53 - So we'll end up using songs, but right now
we just hit the base route.
16:57 - So Chris is the root route and wait
for my project to finish building.
17:06 - Okay, let's go ahead and build
our project for the first time.
17:09 - So we click command R
17:12 - and make sure the scheme
that's selected says my Mac.
17:19 - Okay, here we go.
Okay.
17:21 - So when you run the project,
17:22 - sometimes you'll get this run would like
to access your documents folder,
17:26 - or this might be wherever you
ended up saving it, just click on.
17:29 - Okay,
17:31 - then we see notice starting
server on 127 one at Port 80 80.
17:38 - So right here I type in that exact URL,
17:40 - and when we hit send
on the root directory,
17:46 - we have our request sending.
17:47 - When we get back, it works
and we can see right here.
17:50 - That's exactly what we wanted back.
17:53 - Then we do Hello.
17:54 - So the slash helloroot
17:58 - and we click send
18:00 - and we get back Hello World because
that's what we Typed right here.
18:04 - So we can see that down here.
18:06 - So we went to the root directory first and
then Hello, not directory, but root next.
18:13 - And then we have this controller.
18:15 - So let's go ahead and delete all of the
controllers and everything that comes
18:22 - default with the project
because we don't need that.
18:25 - So we just click on stop
and then we'll see down here.
18:30 - Eventually, once my computer gets there,
it says it stopped it.
18:33 - And then this is the message
that will sometimes come up.
18:37 - So when we try to start this again,
18:39 - it might give us that weird error
where we have to do like, Lsofi 80.
18:44 - 80 and like, kill that one process.
We'll get to that though.
18:48 - But let's go ahead and delete
this to do controller.
18:51 - So just click on it.
18:52 - Click delete, move to trash and let's
go ahead and delete everything else.
18:57 - So create the to do delete that one
move to trash.
19:06 - Delete the to do model.
19:08 - We don't need that.
19:11 - And we can take out
19:14 - that line and it says can't
find it because it's not there.
19:18 - And then inside of Configure,
we can take out this migration
19:23 - thing here, which we're going to add
it back with our own information,
19:29 - so we can keep these routes here because
it doesn't hurt anything to have them.
19:33 - But we are going to make
our own controller.
19:36 - So we all write our own routes inside
19:38 - of the controller rather than writing them
right here, because if you have a big
19:41 - application, it'll start
to get very crowded.
19:44 - Let's go ahead and click on this
and then do command in or file new.
19:48 - To create a new Swift file,
we'll add a Swift file, so we click next.
19:55 - You see Xcode kind of does this rather
than what it does with an iOS project.
19:59 - You can immediately type
the file name here.
20:01 - So we will call this the Song controller,
20:06 - because this project will be about adding
20:08 - songs to a database you
can see with vapor.
20:11 - It sometimes does this incorrectly.
20:13 - So we have the song Uiviewcontroller,
but it didn't rename this part
20:18 - of the file by default like it
does when we do iOS projects.
20:24 - So we will just change it right there.
20:27 - And before we get into this part,
20:29 - actually, let's go ahead and create our
migration, and I'll explain what that is.
20:36 - So let's name the migration
createsongs So file new Swift file,
20:43 - and we will call this
songs and rename this part again.
20:55 - Okay.
20:56 - So first, what are migrations migrations
are used when creating our database?
21:01 - So when you think we have version control
21:03 - within our Xcode project,
when we type new lines and change
21:06 - the code, we use Git to tell us what have
we changed and we can revert back
21:10 - to certain points in time
for migrations with the database.
21:15 - For a database, we use migrations
to do that, as opposed to using Git.
21:21 - So we need to first import Fluent
21:25 - and Fluent is a framework that's actually
21:27 - an Orm so that's an object relational
Mapper or object relational mapping.
21:32 - And we will use that for the migration.
21:34 - So the migration will then track
21:36 - the differences between our database
for things that we add.
21:41 - So first let's create a struct
21:45 - called Create Songs,
21:48 - and it will inherit from migration.
21:51 - So you can see it says fluent.
21:52 - Migration can handle database migrations,
21:54 - which include adding new tables
or changing existing tables.
21:58 - So this is pretty much like Git.
21:59 - It's tracking all of our changes.
22:01 - But instead of for our code,
it's for our database.
22:05 - It will try to build,
and I think it'll tell us
22:08 - there is an error.
22:12 - So when we build our project,
22:14 - it will give us this error that we do
not conform to the protocol migration.
22:18 - So if we add the protocol stubs,
it gives us these two functions.
22:23 - So we said migrations track changes.
So prepare.
22:26 - These are the changes we want
to make and then revert.
22:29 - This is what do we do if we
wanted to revert those changes,
22:33 - let's get rid of the code completion.
22:35 - And the first thing that we're going to do
is we will use this to create our table.
22:39 - Our table is going to be called songs.
22:41 - So we want to return from this
22:45 - and we want to use the database
that we're using so database
22:50 - schema.
22:52 - And we want to call this song.
22:53 - So this is the name of our table.
22:57 - And what does our table have?
22:59 - So tables have columns,
and they have rows.
23:01 - So rows are all of our data.
23:03 - And then columns are
the different properties of our data.
23:07 - So we want an ID property,
23:10 - and we want a field.
23:12 - So the field we want to actually,
that's not the right initializer.
23:21 - Yeah, we'll use this one,
but we're only going to use part of it.
23:24 - So we want to
give it a column name of title.
23:31 - Then what type it is?
23:33 - It is a string.
23:37 - We want to create a new field.
23:38 - We want to give it the name of title,
and it will be of type string.
23:42 - And then we want to make
this field required.
23:48 - And then here we want to create this.
23:50 - So this means we have
a table called songs.
23:53 - It has a column called ID
and a column called title.
23:57 - And then we want to go ahead
and create this table.
24:00 - And that's what all of this means.
24:02 - Now on the other side of reverting,
24:04 - if we want to revert all of the changes
that we made in prepare, we have to do
24:21 - revertinghere.
24:24 - So we create the table with these kind
24:26 - of fields, and then to revert that change,
we just delete the table completely.
24:32 - So this is our migration that we
will make for our songs table.
24:37 - Now how do we represent
the data that's in this table?
24:41 - We have to create a model for that.
24:42 - So if we go to the Models folder
24:45 - command n for a new file,
want to make a new Swift file,
24:51 - we will name this song.
25:09 - We need to import two things.
25:10 - We will need fluent.
25:19 - It's going to conform to model
25:23 - and content.
25:24 - So think of it like a normal class
that would make within an iOS project.
25:29 - This is how we want to represent our data.
25:31 - But because we are using fluent,
25:33 - this is how you're going to query
the data from the database.
25:36 - We need to first say static.
25:38 - Let
25:44 - schema equals songs.
25:45 - So this is what schema
are we talking about?
25:48 - Meaning what table are we talking about?
25:50 - So this class will
represent the songs table.
25:55 - And then what is in this table?
25:56 - We have
25:59 - an ID property
26:05 - and a title property,
but we can't have only this.
26:08 - We need to add a couple of things on this
26:10 - to help with fluent and recognize
everything that's in the table.
26:26 - When we add Chris on top of it,
it's telling fluent that this property
26:32 - of ID matches the ID property within our
table, and then the field that we were
26:38 - talking about when we look
at the migrations matches.
26:41 - Now our property called title,
and we need to make our initializers.
26:48 - So we'll first have an empty initializer
26:52 - and then one with all of our properties.
27:16 - Okay.
So here we have our two initializers.
27:18 - One will just be empty,
27:19 - meaning it doesn't accept anything
meaning it will have both of these.
27:23 - But then one that will set the ID
property to null and then the title.
27:27 - And then here we are setting
these two properties.
27:30 - So our song class represents our
data inside of our database,
27:35 - which here is our table,
27:38 - our table called songs,
and it has the ID and title properties.
27:41 - And then we can see our
model that we have song.
27:45 - It uses the table songs,
and we have our ID and title properties.
27:51 - So let's go ahead and add
data to our database.
27:56 - So we will do that with the song
controller, as opposed to using
28:00 - routes in this file and making
the route file get very long.
28:03 - We'll separate our logic
into this controller.
28:07 - So this will be a struct
called song controller,
28:18 - and you can see it automatically added
28:20 - vapor, because that's what we
need for this route collection.
28:23 - We'll also need fluent
instead of foundation.
28:27 - So our route collection.
28:30 - This is what is used because a controller
is really just kind of a collection
28:34 - of different routes
and different functionality.
28:37 - So when we try to build this,
we will see that it again fails and tells
28:42 - us we need to conform to route collection,
and we currently don't.
28:46 - Okay, so after it builds,
28:47 - we can see that it fails
and we want to add the protocol stub.
28:51 - Let's go ahead and click fix, and we
just need this one function called boot.
28:56 - So kind of think of it
like an init function.
28:59 - This is the first function that runs.
29:01 - So what we want to put in here.
29:17 - Okay.
29:18 - So first let's type letsongswell
routes groupedsongs.
29:22 - So what this is saying is when we go to
29:26 - the root route,
so 1270 one and then dostongs everything
29:35 - that is then grouped under
this will go to that.
29:37 - So to make that more clear,
make a new function.
29:43 - Okay.
So to make this more clear when we go
29:46 - to the routethsongs, we then use
thissongs get and then use index.
29:53 - Meaning when we go to songs,
we want to use this function.
29:58 - So you can see that's similar
to when we do app get.
30:01 - Hello.
30:02 - It has the functionality right here.
30:04 - But because we are grouping it within
30:06 - the songs controller, when we go to
Slashsongs, we want to group everything.
30:11 - Then instead of app yet we have songs yet,
and we are using the index
30:17 - so that will look like
30:20 - Chris one.
30:25 - So we will go to the root route,
then dotheroutesongs.
30:31 - And that's what we are making right here.
30:33 - So that's what this one means.
30:35 - So let's write the code for what
happens when we do this.
30:39 - So this is all we need.
30:41 - So we return songs query, which Chris
means this is referring to our song.
30:48 - Right here our model.
30:50 - So because we are using fluent fluent is
what is actually doing all
30:54 - of the functionality to go
and talk to our database.
30:59 - So we do songs query,
31:00 - meaning we want to go get data
you want to do on the request DB.
31:04 - So this is our request,
which is what it's called when you say hit
31:08 - the database or hit an API,
it usually means make a request.
31:12 - So this is called a request DB.
31:14 - So we want to use the database that we
have, like within our project.
31:17 - And then we do all because we want to get
31:20 - everything back what this means when we do
all we want to return everything
31:24 - that comes back from this query, and that
will come back as an array of song items.
31:30 - But before we can do this,
we haven't actually created the database.
31:34 - So when we can see in this configure file
31:38 - here, this is creating our database.
31:40 - It's a Postgres database.
31:42 - And then this is trying to get
an environment variable for our host,
31:45 - the Port username password,
and then the database name.
31:49 - But instead of making an environment file
31:51 - right now, if it can't find that,
it'll just use this uses Nilco Lessing,
31:56 - and we'll use whatever is
given here by default.
31:59 - So by default, our database host is
32:01 - localhost the vapor password,
and then the username,
32:05 - and then the password is right here,
which these are generic.
32:08 - So this is not what you actually you don't
32:11 - want to hard code any
of these values in your code.
32:14 - That's why right here it goes
32:15 - to an environment file,
which will end up creating glitter.
32:18 - And then right here you could see that we
32:21 - did delete the
migration for creating that to do,
32:25 - because we don't want to create
to dos in our project.
32:27 - We want to create songs,
32:29 - but we do need this migration
similar to this for creating songs.
32:35 - We want to create our song table.
32:39 - So if we go into configure,
32:42 - we type app migrations.
Okay.
32:46 - So we have Typed app migrations add
createsongs because we want to add our
32:52 - createsongsmigration to all
of the migrations like list of them.
32:57 - And then right here we do
tryapp automigrate wave.
33:01 - So this means all
the migrations that we have.
33:03 - We want to actually run them, and that
will go and create our database for us.
33:09 - And then it will wait for this
to complete before doing everything else.
33:14 - Okay.
33:15 - And before we can run the project,
we created our stock controller,
33:19 - but we haven't actually added
that to the routes file.
33:22 - So our only routes in the project right
now are this route one and Hello,
33:28 - let's go and add our song controller.
33:33 - So we type, try app register collection,
33:37 - and then we want to pass in our
song collection or song controller.
33:41 - Sorry.
33:42 - And we can see it conforms
to route collection.
33:46 - So that's saying right here we are adding
33:48 - the song controller,
which conforms to collection.
33:50 - So this is the type of collection.
33:53 - Now, when we run our project,
it will first go back to configure it'll.
33:59 - First create our database for us, and then
34:02 - right here it'll create the songs table
that we have using the migrations.
34:07 - And then lastly, it will try
to run this function routes.
34:10 - If we go here that function,
34:13 - it'll register these two routes,
which we won't really use.
34:15 - But then here it'll register our song
controller inside of song controller.
34:21 - We have a route called Flashsongs,
34:24 - and then here we have the ability
to read all of the different songs.
34:34 - So this is the slashsongs route.
34:38 - So if we go ahead and run this,
nothing will really happen because we
34:43 - don't have anything in our database,
but we can still run it anyways.
34:52 - I must type that.
34:53 - So we'll stop this and not run it.
35:03 - Okay.
So in mind, we can see that we got
35:05 - the same error that the connection
needs were set and connection refused.
35:09 - Okay, so what this actually means?
35:13 - An X could eventually show me
like it can't do something.
35:16 - What this meant was that our database,
it says connection refused.
35:21 - So what are we connecting to?
35:24 - It cannot connect to the database because
the database is actually not running yet
35:30 - what we need to do.
35:31 - So if you click command tab
on our terminal here,
35:35 - it opens a new terminal window, basically,
but within the same directory.
35:43 - So we're still in the same place.
35:46 - So let's go ahead and stop that.
35:50 - Eventually it'll stop.
35:51 - What we need to do is run our database
because it's actually not running.
35:56 - What Vapor does is with an Xcode.
35:59 - It kind of just only runs the application,
the API sort of side.
36:02 - It doesn't really run the database.
36:05 - When we look at our Docker compose file,
36:07 - we can see here we can start the app
and we can start the database separately.
36:13 - So let's do that.
36:14 - We need to start the database with Docker.
36:17 - And if you get
36:20 - close this
36:23 - and you try to start the database.
36:25 - So if we do
36:29 - dockercomposeupdb,
which this does have a hyphen,
36:32 - but I've Typed it without a hyphen,
and it works just fine too.
36:36 - So if we type Docker,
compose UPDB, hit, enter
36:41 - it's trying to start the database.
36:43 - But if you get back this error of error
36:46 - response from Damon,
that just means that Docker is not
36:49 - running, and that's
what I had just closed.
36:52 - So you need to type in Docker.
36:54 - So it will try to open the Docker app.
36:57 - If you hit enter,
36:58 - you'll see up here the little Docker
whale is trying to get up and running.
37:03 - So it says Docker desktop is starting
and let's wait for it to boot up.
37:09 - So this is the desktop application.
37:11 - It'll say Docker engine is starting.
37:14 - Once Docker started up,
37:15 - you may see this that says nothing is
running or you don't have anything here or
37:20 - have like, one of those tip kind
of prompts, but this one was actually
37:24 - from the testing the API, but we can
close this or you can leave it open.
37:28 - It doesn't really matter.
37:33 - Let's go back here
and type the same thing.
37:35 - Dockercomposeupdp
37:38 - we hit enter.
37:40 - Now you can see it's
starting to do something.
37:42 - So what it's doing is creating our
database for us within a Docker container,
37:49 - and it's doing this by using our
Docker file here in Docker compose.
37:55 - So now if you still have the Docker
37:57 - desktop application open, you can see
YT vapor API that is right here.
38:04 - That is the name of our project,
38:05 - and we are actually running it
from the command line here,
38:08 - as opposed to running it just
through the GUI application.
38:11 - You can expand this and see here is our
38:14 - database, and it's just called
DB One, and it is of type.
38:17 - It's a Postgres database.
38:19 - So now that everything is running now,
let's see if we run our API.
38:24 - We should not get a connection.
38:25 - Refused
38:28 - because our API was trying to connect
38:30 - to our database, but the database
was not actually up and running yet.
38:34 - Okay, on mine, we saw this
address already in use.
38:38 - So that's a different error that goes back
to that weird command that we have to type
38:43 - in the command line, because sometimes
Xcode doesn't fully detach the process.
38:48 - So if we go back to our first
terminal tab here and type Lsoft,
38:58 - it shows us all of these
things that are running.
39:02 - So to know which one to actually close,
it's usually the one that says local host.
39:09 - I'm not sure why that actually
39:11 - appeared in mine,
but typically what we'll do is delete
39:16 - the one that says something about
localhost and we can delete this one.
39:21 - This is postman because I think this is
39:23 - the one that the database is running on,
but apparently it froze mine.
39:33 - So if we click command T
to try to open a new tab,
39:38 - close that type
39:43 - Lsofi 80 80 and don't have any spaces,
39:48 - it comes up with the same things
39:58 - we'll do kill nine
and then the PID number.
40:07 - I don't know.
40:11 - Okay, so if we look at this,
it still says something is running.
40:15 - Let's try to kill that one as well.
40:23 - And if we type LSOs, okay,
now we don't have anything going.
40:28 - So now let's try to run our project again.
40:31 - Okay, here we go.
40:32 - Now we have server starting
on our root computer,
40:38 - but we can't really see anything.
40:40 - Let's open postman.
40:44 - Okay, we have open postman,
40:46 - and if we try to hit the new route that we
just created for getting all the songs.
40:51 - So this was me.
I saved
40:55 - this request within postman.
40:57 - You can do this all without
signing up for an account.
40:59 - If we try to click send,
41:01 - we get back an empty
array and it says 200.
41:05 - Okay, and that's exactly what we want.
41:06 - A 200 response is a good response,
and then we can see we hit the slashsongs
41:13 - route, but it says empty array because we
haven't added anything to our database.
41:19 - If we want to look further into this,
let's open up Azure Data Studio.
41:24 - So this was another one of the
applications that we had to download.
41:27 - And with Azure Data Studio,
41:29 - we can then look at our data in the
database directly without using the API.
41:34 - So to do that first,
we need to add location.
41:37 - Sorry, add a connection
41:40 - and we are not using Microsoft SQL Server.
41:42 - We are using Postgres SQL
and we have that option because
41:47 - cancel when we downloaded the extensions.
41:51 - We downloaded the extension Postgres
41:54 - so we can go to add connection
41:57 - PostgreSQL.
41:59 - So the server name is
42:05 - localhost
42:08 - because in configure right here
the database host is called localhost.
42:14 - So database host and server
name are like the same thing.
42:17 - We want to use password.
42:19 - We don't have Azure active directory,
42:21 - and then the username here we are using
Vapor Username and Vapor password.
42:31 - You can click remember
password if you want.
42:34 - It doesn't really matter.
42:38 - And we want to use Vapor database
42:41 - because that is the one
that our configuration uses.
42:46 - We can give us a name.
42:48 - It doesn't really matter.
42:52 - It database and we click connect.
Okay.
42:56 - So here we can see that the connection is
live because it has a little green dot.
43:00 - If we click on songs and just right
click and then do Select Top 1000.
43:05 - This runs this query of select
ID and select title from songs.
43:10 - And we have nothing here because there's
43:12 - nothing in our database,
but we can see fluent migrations if we
43:15 - right click this one
and click Select Top 1000.
43:20 - This shows us that the migration that we
43:23 - ran is called Createsongs,
and then this is the first one that ran
43:26 - and this is the day
and time that we ran this.
43:29 - So this is like our get commits.
43:31 - It has a record of all the different
43:33 - things that have happened,
all the different migrations.
43:36 - And we can see here.
43:37 - We don't have any data in our
database at the moment.
43:40 - So let's create a new route that allows us
43:42 - to add data because what we have so
far is just allowing us to get data.
43:47 - Okay.
43:47 - So we stopped the project and we
want to make a new route.
43:51 - So we need to make a new function.
43:53 - We are going to make
a function called Create,
44:11 - so our function takes in a request.
44:14 - All of them will take in a request because
44:15 - that is the request coming from Postman
and the request coming from the iOS app.
44:22 - And then I haven't really
talked about this.
44:24 - It's called Eventloop Future.
44:26 - So this has to do with what is
called futures and promises.
44:29 - So it's all about asynchronous code.
44:31 - And note these tutorials are before Vapor
44:34 - has integrated Async await,
which is the brand new Swift I believe,
44:38 - 5.5 functionality that is in iOS,
and we will be using that with the iOS
44:44 - app, but it has not been merged
into Vapor's framework just yet.
44:49 - And then right here we
will return Http status.
44:52 - So the status is like when we
looked at postman just moved.
44:59 - This is the status.
45:01 - So $200 means something good happened.
45:04 - So we will return a status whether or not
45:07 - we were able to successfully
create a song.
45:12 - So let's write the code for this.
45:18 - Okay.
45:19 - What we wrote here is letsongals
tryrequest content decode.
45:25 - So when we have this request,
45:28 - we are going to be decoding
the content into a type of song self.
45:32 - So that's like when we do JSON decoding
45:34 - in iOS, this is pretty much the exact same
thing, and we will decode our song type
45:40 - and we save it into a
variable called song.
45:42 - And then we will save
that to our database.
45:45 - So that is using song save.
45:47 - And we can use this because our model song
is a part of fluent.
45:53 - So it has these functions inherently
that it can use to talk to the database.
45:58 - So we save our song to our database.
46:02 - And then if that goes well,
we transform it to okay.
46:05 - Meaning everything went well
46:08 - in the response from this entire request
is going to be okay if it worked.
46:15 - So let's go ahead and run this.
46:18 - But actually before we run it,
we have to add this to this boot function
46:23 - because we have added the get for the
index, but we need to add the create.
46:35 - So instead of get, we are using Post
and these are different http methods.
46:40 - Get is usually for getting data,
and post is usually for sending data.
46:44 - So we do songs post,
46:46 - and that allows us to make a post
request rather than a get request.
46:51 - Let's go ahead and run this
and bring postman back up.
46:56 - We have a lot of windows so you can
see when we did the Get request.
47:00 - The request type is get when we
hit the songs API or the route.
47:07 - But if we use a post
47:10 - request, we change this from Get to post
and then you can see the request.
47:16 - The URL is the exact same.
47:20 - So that was me testing one.
47:22 - But here what we need to do first is
so you won't see this initially.
47:27 - It might be on like params.
47:30 - Go to the body tab here and make sure you
47:34 - click on Raw and then select JSON
for the type of this body,
47:39 - and we will use a title because that is
one of the properties of our song model.
47:44 - We have an ID and a title, but we
don't need to create the ID ourselves.
47:48 - The database will do that for us.
47:51 - Okay, this is the vapor
like pop up that comes up.
47:53 - Just click.
Okay.
47:55 - And then our Vapor API is now up
47:57 - and running in postman, let's add
a new song, add a song called Money,
48:06 - and if we click send,
48:10 - we get back a status of 200.
Okay.
48:13 - And you can see we made a post request
to the routethsongs,
48:18 - but we can actually see the data,
but we can if we now use our other route
48:23 - that we had for getting all of the songs,
so you can see it says it's a get request,
48:28 - not a post request,
and we don't have anything in the body
48:31 - because we're not sending
anything over to the API.
48:33 - We're just sending our
request to get back data.
48:38 - So if we click Send
48:41 - now we have data coming back so you can
48:44 - see the ID that was created,
which was that UUID.
48:47 - And then the title is Money.
48:49 - So
48:51 - that is the song that we just added.
48:53 - We used our API right here for a get
and a post request to the route songs,
48:59 - and now we have created new data
and we have read that data.
49:03 - We can also look at our Azure Data studio,
and we can query our database directly.
49:09 - So if we click run after we run our query,
we can see the same ID number,
49:18 - and then the title is Money because that's
the one item that we have in our database.
49:22 - So this allows us to look at our database
49:24 - directly rather than using our API
here to query the data itself.
49:32 - Okay.
And then that's pretty much it.
49:34 - We have created two different routes
49:36 - that allow us to read
data and create new data.
49:41 - So here I will actually add
49:45 - this is a get request
to the Songs route and this one
49:54 - and this one is the post request
49:56 - to the Songs route,
and we can see that here we use Get.
50:02 - So let's stop the project from running.
50:08 - And then down here where we had our
50:12 - we can see everything
where we had Docker running.
50:15 - If we click Control C
50:18 - that will stop the container completely,
you shouldn't just close this window.
50:23 - You should just cancels
it gracefully to stop it.
50:28 - And then if we look in Docker desktop,
we can see that it's not running anymore.
50:34 - Let's exit out of that.
50:38 - And then that's all we have
to do on the API side.
50:41 - We have created our table using
50:43 - migrations, and we learned that migrations
are like Git, but for our database we
50:48 - created two routes,
one to read data and one to write data,
50:52 - and we are writing and reading
a list of song titles.
50:55 - Lastly, we used Postman
and Azure Data Studio so we can look
50:59 - at the data in our database and test our
API without needing to write the iOS app.
51:04 - First,
51:06 - in this video, I'll show you how to create
a Swift UI app that uses our custom vapor
51:11 - back end API to read
and write data to a database.
51:14 - Hey, everyone, my name is Mikayla Karen.
51:16 - I'm a full time iOS developer,
and recently I've been learning Vapor.
51:19 - So I'm excited to share with you how you
51:21 - can use Vapor to make
your own API back end.
51:25 - Okay.
Now let's create the iOS application.
51:28 - So just go to Xcode
and do file new project.
51:31 - Then here make sure you select
iOS and then click on app
51:37 - and we will call Chris Ytvaporios app.
51:46 - We will change this.
51:47 - So it is in Swift UI and this is Xcode 13.
51:51 - So this is what it looks like.
51:54 - You don't have to select life cycle.
51:56 - I don't think anymore.
51:57 - So this is that and then click on next.
52:00 - But go ahead and find where you want
to save your project and click on create.
52:06 - Okay.
Our project is created.
52:10 - Let's go ahead and run it.
52:13 - We're just going to use
the simulator rather than my phone.
52:19 - So we have created our project and then
we built it for the first time.
52:23 - So we know everything's working.
52:26 - I'll keep that up and you
can turn on the preview.
52:30 - I don't use it that often,
but we can put it there.
52:34 - But let's go ahead and make
our file structure.
52:37 - So we will be using MVVM,
which is model view view model.
52:40 - So let's go ahead.
52:41 - Right click here and click on new group.
52:45 - So we have models.
52:50 - Come on.
52:54 - We have view models.
52:58 - I don't know why mine's doing that
MVV and then M
53:12 - models, V models.
53:16 - And I like to put these in alphabetical
order just because I think it's easier.
53:21 - So move that one up here and we will
also create one called utilities.
53:29 - And then I'll put that one down below.
Okay.
53:32 - First thing we are going to do is change
53:34 - the ContentView instead
of being called ContentView.
53:37 - We're going to call it song list.
53:40 - So we right click on that
and click on refactor
53:44 - and rename.
53:45 - You want to click the plus here.
53:47 - So it renames the comma itself and you can
see it's going to rename the file too.
53:53 - So now we have a song list.
53:56 - And then let's go ahead
and drop this into the views
54:02 - and just expand all these.
54:04 - And first thing we need to do is create
54:06 - our model because we have
to model our data somehow.
54:10 - So we do file new file.
54:15 - We want to make a Swift file.
54:18 - Okay, let's call this song or just song
54:23 - and create a structure for the song
that we made in our API project.
54:36 - We will make it conformed to
identifiable and quotable.
54:40 - So the codeable so we can decode
and encode everything and identifiable is
54:45 - because it has an ID and we will
be using a list in Swift UI.
55:01 - There we go.
55:02 - So that will go away because it now
conforms because we have an ID property.
55:06 - Okay, let's make our song list.
55:10 - Open up song list here.
55:12 - Maybe one day the preview will work.
55:15 - But let's go ahead and make the list.
55:18 - So we are repo in a navigation view,
55:26 - make our list.
55:27 - And then we need our data to be
represented somehow like an array.
55:32 - So let's go ahead and also
have a view model for this.
55:36 - So we right click View models.
55:38 - New file.
55:40 - Want to Swift file,
55:44 - and I will call it Song List view model.
55:47 - Make sure that is checked down here.
55:49 - Click create.
55:51 - Let's go ahead and create
56:07 - just an array in here.
56:17 - So we have just our songs array and it's
an empty array and it's a published value.
56:23 - So if we go back here to Song list,
56:48 - we have a review model.
56:50 - Is this ever going to build?
56:52 - Oh my goodness.
56:54 - Okay, we are making a list and we want
56:57 - to iterate through all the objects within
our Songs array inside of our view model.
57:01 - So let's type a four each loop
57:13 - and I will make this smaller
57:51 - inside of our list.
57:52 - We are going to have
just instead of a label.
57:55 - We're just going to use a button because
57:57 - we will make it so you
can tap on every row.
58:02 - I just have the text as the song's title.
58:05 - And then we set this to font three,
58:07 - and then the foreground color is label,
which is a systematic color.
58:11 - So when it switches from light mode
to dark mode, it'll automatically switch
58:14 - and we don't have to manually
say what the color should be,
58:32 - and we will add
a navigation title as well.
58:36 - So we don't see any data because
we don't have any in the preview.
58:41 - Okay, so let's fetch
some data from our API.
58:45 - So in our view model, we will
need a way to get that data.
58:49 - Let's create a function called fetchsongs.
59:03 - Okay, so we will be using async await
for this, which is only available.
59:07 - So right here you can see concurrency
is only available in 150 or newer.
59:13 - So let's open the side
panel back up again.
59:16 - So I did that with command
zero and click on our project.
59:19 - And let's set the minimum target to 150.
59:22 - So we don't get that warning
59:25 - 150 right there
when that target is selected,
59:29 - and then make sure it says
150 for that one as well.
59:32 - You can see these two different targets,
59:34 - rolled the target in the project,
and there we go.
59:37 - So reset that and save it.
Close this.
59:43 - And if we build project again,
this little warning should go away.
59:48 - Okay, our project says build succeeded.
So we're good.
59:51 - And then that warning
doesn't come up anymore.
59:55 - To fetch our data.
59:56 - We first need to say what
URL it's coming from.
59:58 - So in our API we had URL was 1270 one,
but that's not really a real address.
60:07 - That is just the name of our computer,
which is also called localhost.
60:11 - But everybody's computer is called local
host, so we can't just hit that URL.
60:16 - So we'll solve that in just a second.
But before we do that,
60:19 - let's first create the code that will
actually go about fetching the data.
60:23 - So what we're going to be doing is
making a single ten called Http client.
60:28 - So go ahead and click on utilities
and create another new file.
60:33 - I'll make it a Swift file,
60:38 - write http client and hit.
60:40 - Okay,
61:02 - so this is what makes it a single ten.
61:06 - We don't have an initializer so you can't
initialize this object,
61:09 - but we can access it through this
shared property that we created.
61:13 - And then that is what accesses all of
the different properties and functions.
61:18 - So we want to fetch data.
61:20 - Let's go ahead and make
a function called fetch.
61:37 - As.
You can see, this is a generic function.
61:40 - So what we are going to be doing is making
61:42 - our http client generic,
so that really it could be adopted.
61:46 - You could copy this code and drop it
61:48 - into any project that you
have that makes http request.
61:51 - So the generic means
this is the value or the property
61:56 - that we're using called tea,
and it just needs to conform to codeable.
62:01 - And then what we return is our object,
which is an array of T objects.
62:06 - And for us it will be the song model.
62:10 - But again, you could drop this code
into any project and it would work.
62:14 - So how do we do this with async await?
62:16 - We first need to make the request
for fetching data.
62:39 - So this is the async version
of the shared data task.
62:45 - And when we use async await because this
62:48 - is an asynchronous function,
we have to have the await in front of it.
62:51 - Meaning wait for this to finish.
62:53 - And don't worry about this.
62:55 - It'll go away in just a minute.
63:13 - And here we are going to check that our
response first is an http URL response,
63:21 - and then this property or type has
a property on it called status code.
63:26 - And we want to make sure that's 200
63:28 - because 200 means it was a good response,
and then we're going to throw an error.
63:32 - So first let's make the kinds
of errors that we'll be throwing.
63:37 - Put that right up here.
63:57 - These are different types of errors.
63:59 - So if we get to this point,
64:05 - we know that it was a bad response back if
it was anything other than 200,
64:10 - and now we need to Xcode the data
and put it into whatever type T is
64:43 - here.
64:43 - We have an object and we are going
to decode it using a JSON decoder,
64:47 - and it will be of type T,
and it's an array of those objects,
64:52 - and we are decoding the data
that is right there.
64:55 - And then if that doesn't work,
we will throw the error decoding data,
65:05 - and then we will return the object.
65:08 - That's what's returned out of this.
65:09 - So let's go ahead and build the project.
65:21 - Okay.
65:21 - If we build the project,
it succeeds right here.
65:23 - I had accidentally Typed data, not data,
or I Typed data task rather than data.
65:29 - So this is the asynchronous one and you
65:31 - can tell when you command click
on it and it goes to QuickHelp.
65:35 - You can see it has the word async in it,
65:38 - and it tells you it retrieves content
from a URL and delivers the data
65:42 - asynchronously that's
exactly what we want.
65:46 - So how do we go about using this function?
65:49 - We're going to be using it inside of our
song list ViewModel to fetch objects.
65:54 - So the first thing we need
to do is define our URL.
65:58 - So to do that, we are going
to create a constant file.
66:01 - So this URL won't really ever change.
66:03 - It is going to change when we're
doing the development work.
66:06 - But the actual URL that ends up being
66:08 - deployed in the final video,
it won't change.
66:12 - So let's go ahead and make
a constants file for that.
66:14 - So we create a new file
in our utilities folder.
66:20 - Create constants Swift,
and I like to put these in alphabetical
66:25 - order sometimes,
and we will create an enum,
66:35 - so it will look like this.
66:36 - We will fill in the rest
of this in just a minute.
66:39 - But for now, this is all we need.
66:42 - And let's also create an enum.
66:50 - So this is our endpoint.
66:52 - We only have one because we're only
66:54 - reading and writing
to that one songs endpoint.
66:57 - So we just call the songs and in doing it
like this, making enum with a static
67:01 - variable, which is actually a constant,
but there's still a variable.
67:06 - But the static variable allows us
to use this in a type safe way.
67:10 - So in case we ever accidentally wrote song
instead of songs, every time you type this
67:15 - endpoint, you basically won't be able
to do that with this endpoint or with this
67:21 - object because it will
be completely Typesafe.
67:25 - So let's go here and see how we do that.
67:27 - Let's create a URL.
67:39 - So this is just a string.
67:41 - So we have constants baseurl,
67:43 - so that's the URL we will fill
in right here and then plus endpoints
67:50 - endpoints songs, and we
will put a slash at this.
67:55 - So it'll be something like
68:05 - it will look something like this actually.
68:08 - So this is what is called the base URL,
68:10 - and then the endpoints are
whatever as after this.
68:15 - So if we go here.
68:17 - Yeah, that's fine.
68:19 - This is just telling us that we
haven't used this variable yet.
68:23 - So it wants to put an underscore,
but we will use it.
68:25 - This is a string too.
68:27 - So let's create the actual
URL object itself
68:45 - here.
68:46 - We have a guard because we want to make
sure that this URL is for sure a value,
68:51 - and that it doesn't throw, because if you
look at the signature of this function,
68:58 - that's just a structure actual function.
69:01 - Can we go to that?
69:03 - Open up the developer, Doc.
Oh yeah.
69:07 - That's just initializing in the URL,
but it does throw
69:14 - right here.
69:15 - It creates a URL instance, but with the
question Mark means it might be optional.
69:19 - So that means if it can't create a URL,
then the value would be nil here.
69:25 - If there's any illegal characters,
it would be nil.
69:29 - So using guard, we want to make sure
that this definitely has a value in it.
69:33 - Otherwise we want to throw
the error bad URL.
69:37 - So let's use this.
69:38 - We will create a variable
called Song response.
69:59 - So this is how we use our
async await function.
70:05 - So here's our Singleton http client
70:07 - shared, and we are using this fetch
function, and we're passing in the URL
70:13 - that we created right here.
70:15 - And what's returned from this
is an array right here.
70:19 - It said an array of T,
70:21 - but with this we are specifically saying
it'll be an array of song objects.
70:26 - And once we have all of our song objects,
70:29 - we want to set that into our
variable right there.
70:43 - And we have to do this on the main queue
70:45 - because that will update
this variable with Swift UI.
70:48 - It will know to refresh the view.
70:50 - So this is something that must
happen on the main thread
70:55 - and then that's it.
70:56 - So we can go ahead and build the project
and everything should build.
71:01 - But we can't actually reach our data just
71:04 - yet from our API because for one,
we don't have a URL filled in.
71:09 - Okay, we have built succeeded,
and we don't have a real URL here.
71:16 - Let's first CD into our API project.
71:25 - This is what mine is called it's
71:27 - the Ytvaper API, and this
is just the branch name.
71:31 - If you saw this before,
71:32 - I broke up all of the files of the project
into different branches so you can look
71:37 - at a specific branch to see all the code
for that specific
71:41 - lesson rather than having multiple
repositories for each lesson.
71:45 - And we need to run our database.
71:51 - We need to run our database with Docker.
71:53 - Okay, the first thing we need to do is we
need to run our database with Docker,
71:57 - and we need to run our API so
we could write Docker, compose
72:02 - up DB and run it from the command line.
72:04 - Or the other way is we can use
the Docker desktop application.
72:09 - So if you open up the container that we
72:12 - have here and that is the database,
you can just hit play or start.
72:17 - Okay, we have it up and running.
72:18 - And if we just click on this row,
72:21 - we'll see the same kind of output
that came in when we were on terminal.
72:25 - So this is just another way
to run the Docker container.
72:30 - So we have our database running right now.
72:32 - But we need to run our project.
72:34 - We could go ahead and run it via Xcode, or
72:38 - we can just run it
on the terminal as well.
72:42 - So if you type the command vapor run
72:43 - and hit enter that is building
our project and running it.
72:48 - So that will build our project and run it
72:50 - all in the terminal rather than running it
in Xcode, and you can see it's going
72:55 - and fetching all of those
different packages that we have.
72:58 - And this is the first time I'm
running it through terminal.
73:01 - So this may take a while.
73:07 - Here it goes, here it goes.
73:11 - And it says already in use.
73:13 - Okay, mine came up with that error again.
73:16 - That address is already in use.
73:18 - So we need to fix that
by running the command
73:24 - Lsofi 80 80, and we can
see postman is using that.
73:33 - But that one killed postman last time.
73:35 - So let's use this PID.
73:40 - So kill nine.
73:42 - Then the PID number hit enter
73:47 - and then else off and that's gone now.
73:50 - So let's type vapor, run
73:55 - enter and then now the project should try
73:58 - to build again and run all in the terminal
rather than running it from Xcode.
74:05 - We wait again.
Okay.
74:06 - Cool.
So everything worked.
74:08 - But again we cannot hit 127 one at because
everybody's computer will say that.
74:16 - So it's literally not possible.
74:18 - That's just what the computer is called.
74:20 - So the URL we are going to use,
74:23 - we need to open up a new terminal
tab so we can't use this URL.
74:28 - But we do need this actually up
74:29 - and running because this is our API, and
basically it's like it's on right now.
74:34 - But we need something to bridge the gap
from the iOS app to go to our API.
74:39 - So for that, we need a new tool that I
74:42 - forgot to download
initially called in Grok.
74:45 - So it says it right here public URLs
74:47 - for exposing your web URL or whatever
that said for exposing your computer.
74:53 - So go ahead and just click
on this download button.
74:57 - You don't actually need to sign up
74:58 - for an account, even though
it does tell you to do that.
75:02 - Just click on download and it will
download a file called Ingrock for you.
75:07 - So I don't follow this.
75:09 - I tried to and it did not work
on my computer to unzip it.
75:14 - And again, we don't have
to create an account either.
75:17 - We can kind of just use it immediately.
Okay.
75:20 - So once we have that downloaded,
open up our new tab and terminal.
75:25 - Just typing CD and hitting enter
will give us our root directory,
75:30 - and mine went to the downloads folder.
75:33 - So when we type LS, we see our
file called Ingrock sitting here.
75:37 - So to use it, we do ingrock.
75:51 - We type ingrock http.
80.
75:54 - 80.
75:54 - So what we're going to be doing is
like opening a Port on our computer.
75:58 - And this is the Port that we want to use,
which is the one that our API is using.
76:04 - So when we hit enter on this,
we can see it brings up this window
76:10 - here is like this word forwarding
and this URL right here.
76:15 - So make sure to grab the one that's https
76:18 - and you can see this URL will
reroute to localhost 80.
76:23 - 80, which 1270 one is
the same thing as localhost.
76:29 - So for the URL in our constants file,
76:33 - we want to put the same thing and don't
forget to have the slash right there.
76:38 - So when we hit our API and it says it
right there too, when we hit the API,
76:44 - we'll use this URL,
which that will go to Ingrock.
76:48 - And Ingrock understands that then
76:50 - that will forward to our personal
computer that says localhost 8080.
76:55 - So let's go ahead and run the iOS project.
Okay.
77:01 - And we can see nothing happened.
77:03 - And the reason for that is because
we never call our function.
77:08 - So you have to call the function
for the function to actually work.
77:11 - And you see this output right
here about the navigation title.
77:16 - This is some just weird
thing with Swift UI.
77:19 - It has all these constraint
errors for this title.
77:22 - So if you remove that, that will go away.
77:26 - But again, we need to call our function
77:28 - Fetch Songs for it to actually
go out and fetch new songs.
77:33 - If we go back to our song list,
we want to add a modifier
77:39 - to our navigation view.
77:40 - So I'm going to close this
so you can either grab it right here
77:44 - and swipe it away or click on this button,
and then it hides and shows the canvas.
77:50 - So we want to add a modifier
to the navigation view
77:58 - called on Appear.
77:59 - And from here we want to call our function
in the view model called Fetch Songs.
78:06 - So we can't just call it
directly like this because
78:17 - we will get an error.
78:18 - First telling us we need this is an ASIC
78:20 - function, and this function
doesn't support concurrency.
78:25 - So it's the on a peer function
that doesn't inherently use concurrency.
78:30 - Also, there's like four errors on this.
78:32 - And then the other thing is telling us
78:34 - this can throw and it's
not marked with a try.
78:37 - So if we look at the function here
78:39 - for one, it is async and two
the function actually throws.
78:42 - So right here it would throw an error.
78:46 - So when we use throws,
78:49 - we need the keyword try in front of it,
and then we have the other keyword await,
78:55 - which goes hand in hand
with using async await.
78:58 - That's the pattern for concurrency code.
79:01 - And then this is the error that's again
telling us that the function does not
79:05 - inherently use asynchronous code
like we have it written right here.
79:11 - So to fix that we can put this inside
79:19 - of a new task, and this task is
asynchronous.
79:24 - So if we look at the quick help for here
a unit of Asynchronous work.
79:30 - So now if we build a project,
79:32 - this should build and be fine with command
B and there we have build succeeded.
79:38 - But this function can still throw
79:41 - an error, and we kind of don't
handle that immediately right here.
79:45 - So let's wrap this in a due catch block.
79:57 - Okay.
79:58 - We have wrapped our ViewModel fetchsongs
inside of this do catch block.
80:04 - So in case this ends up throwing an error
80:06 - instead of doing nothing with it,
we will print out the error.
80:10 - So this is just printing the word error.
80:11 - And then this is the error that's actually
caught that's thrown from this function.
80:16 - And then I use emojis in my code a lot.
80:18 - Just because it helps you see everything
in the debug log down here,
80:22 - especially when you have all this
constraint kind of stuff,
80:24 - you can just throw in an emoji
and then see it very quickly.
80:29 - Now that we have that we still have this
80:32 - running and you can see it only
says an hour of 54 minutes left.
80:35 - So after that time is over,
this URL doesn't work anymore.
80:39 - So that's why we can
use it for development.
80:40 - But that's not what you
end up using long term.
80:43 - Let's run our project now
80:47 - and we should see
it actually going and fetching the data
80:51 - from our database, which is
just that single row of data.
80:54 - I believe the song says money.
80:57 - Okay, the project built
and we can see on the right.
81:00 - We have our one thing
in the database that says Money.
81:04 - So we have two outputs down here.
81:06 - The first one is in Grok.
81:08 - We can see that we did a get request
81:10 - to our songs endpoint,
and it came back with 200.
81:13 - Okay.
81:14 - And if we look at the vapor output when we
did vapor run, we can see almost the same
81:20 - thing that we did a get request
to the slashsongs endpoint,
81:25 - and that's about it.
81:26 - We don't actually see that it said 200,
81:29 - but we know that it works because the data
81:32 - shows up here and we didn't
get an error thrown.
81:34 - So now that we can see data,
let's add new data to our database,
81:39 - but through the iOS app,
let's stop the project
81:44 - and we can leave this running right now.
81:47 - So we want to add a new project by tapping
81:50 - a button in the top right
in the navigation bar.
81:52 - So let's add that with a toolbar.
81:57 - So we add this to the list property
82:00 - here rather than to the navigation view.
82:31 - Okay, so right here we want
to have a label called Adsong.
82:35 - So if we look at this actually,
82:36 - we could try to look it in the canvas,
see if it works.
82:39 - The canvas doesn't work.
82:40 - Usually it struggles a little bit,
as opposed to running the app all the time
82:45 - in the simulator, because I do UIKit
way more than I do Swift UI still.
82:49 - And so I'm still used to just
always running it in the simulator.
82:54 - My computer is a little slow, so
82:57 - sometimes work sometimes doesn't.
82:59 - But we should have a button in the top.
Right.
83:01 - That is just the system
image of Plus Circle.
83:05 - So system image that is from here.
83:08 - So there's an app called SF Symbols,
and you can go and download that.
83:12 - I will have the link in the description
below, and we would use the one I
83:16 - Typed Plus here and you have all of these
different images that you can use.
83:21 - So if you right, click it and then
83:26 - I don't know why we can't copy,
but the image name is whatever's down here
83:31 - I'm using plus CircleCI, which is
somewhere around here.
83:36 - I found it earlier, but
you can use one of these as system images
83:42 - in your code, and then these are just
a ton of ones that Apple just gives you.
83:46 - So we are using plus circle,
and I used a label
83:51 - rather than just an image with a system
name because this is more accessible.
83:55 - So if somebody was using voiceover,
83:57 - this would say add song instead
of just the words plus circle on it.
84:01 - And then you can see the database was hit
a couple more times when we were running
84:05 - this preview, but when we click the plus,
we want a modal sheet to come up.
84:11 - So let's build that part of it.
84:13 - So we are going to use the dot sheet
84:15 - modifier and put that
on the navigation view.
84:18 - So let's put it right
here before on appear.
84:22 - So an action sheet is what comes up where
it has those options at the bottom.
84:26 - But we just want to use a normal sheet.
84:28 - I'm not sure why my Xcode
doesn't remember what that is.
84:32 - We are going to be using this one
84:34 - that says binding identifiable
rather than just
84:39 - presented, which is just a boolean
because the sheet that we're using we will
84:44 - use the sheet for both
adding and updating values.
84:48 - So we need a variable that we'll use here
84:50 - and we do want to do something
for the on dismiss.
84:55 - So first before you fill any of this out,
what variable are we going to bind to?
85:00 - We are going to make a new enemy type.
85:03 - So let's click plus and then new file
85:08 - and utilities and it will be
a switch file called modal type.
85:23 - Okay, we have created a new enum
that conforms to identifiable.
85:28 - So in order to conform to identifiable,
it needs to have an ID.
85:32 - So here we are just creating a computer
property and switching on our self.
85:36 - Depending on if the case is add or update,
85:39 - we are just returning the ID
of a string just called add or update.
85:43 - Then our two cases are add and update
85:46 - and update has an associated
value of type song.
85:50 - We'll see about using that later.
85:53 - So for now we have our modal type.
85:56 - So inside of our view model
inside of song list,
86:02 - we need to have a variable
right here that we'll be using.
86:16 - So we create a new variable called modal,
and it's of type modal type and we will
86:21 - set it by default is nil because
no sheet will be showing.
86:26 - And then that's because we
haven't touched anything.
86:28 - Here
86:31 - we type modal because that's
the variable that we want to use.
86:39 - We will fill that in a little bit later
86:44 - and for content, I don't like
the way it looks right here.
86:47 - So we will take off just by default.
86:50 - I don't like what the autocomplete does,
so we will take off
86:54 - that part.
87:12 - This is the ContentView
part of that closure.
87:14 - I just didn't like the way the auto
87:16 - completes to look like that and what
we're doing right now.
87:19 - This doesn't work because we
need to fill something in.
87:21 - But what we are doing right now is we have
87:24 - our modal type, and then we are switching
on what that modal is whether Ad or update
87:28 - was selected and we want
to show a different view.
87:31 - So we haven't actually created that yet.
87:33 - So let's go ahead and do that.
87:35 - So let's create a new view
and it will be a Swift UI view.
87:41 - Let's call it Add Update song.
87:45 - Inside of this, we can do two things.
87:47 - We'll either be adding a new song
or we will be updating a song.
87:51 - So what will we be displaying? We are
going to just put a V stack on the screen
88:04 - that will have a text field property so we
88:06 - can type something and it
will have a button.
88:22 - So our Ad update song also needs its own
88:25 - view model that we will use to fill
in some of these things here.
88:29 - So let's create that view model.
88:30 - Now do command n on our view
models using a Swift file.
88:41 - Add updatesong ViewModel
88:58 - and our view model will conform
89:00 - to observable object because
it will be a view model.
89:04 - We'll wrap it in a property wrapper
89:07 - on the view, but the first thing
we need is a published property,
89:19 - and it will be an empty string.
89:21 - So that's what we will use
for a text field over here.
89:48 - Yes.
Okay.
89:49 - So we have our view model and it
has a property called song title.
89:54 - And then this is what's shown in the text
89:56 - field before we type anything
and it will just say song title on.
90:00 - This will add a little bit of styling,
so it doesn't look weird.
90:16 - So here at the text field style will be
90:18 - a rounded border, so that will literally
just put like a Gray border around it
90:22 - and then add some padding,
so it's not right up against the side.
90:26 - Let's fix this down here
90:33 - by just creating a new view model.
90:35 - But what do we want our button to say?
90:37 - So our button is either going to say add
or it's going to say update,
90:41 - depending on what this model is doing,
which will happen over here.
90:47 - Okay.
So let's first make our view model.
90:51 - So we will make the view model.
90:53 - It's going to have a couple
of properties on it,
90:58 - which will be a Uuid.
91:00 - So the song ID.
91:02 - This will have a song ID if it's
the update, meaning we're passing the song
91:06 - over to this view and it
won't have a song ID
91:10 - if we're adding a new song because we
haven't Typed anything in there yet.
91:15 - So we'll use the property VAR
91:19 - is updating to know whether or not
91:23 - this view is in the updating
state or if it's in the ad state.
91:32 - So when we type song ID
is not equal to Nil.
91:35 - Well, if the song ID is not nil,
then that means we are updating,
91:38 - so is updating would be true,
and then vice versa.
91:43 - And then I talked about over here.
91:46 - We don't know what we're going to write
91:47 - for the title of our button if it's
going to say add or update song.
91:51 - So we'll create another
computer property for that.
92:12 - So here we have.
92:14 - We're checking again if the song
ID is not equal to Nil.
92:17 - If it's not nil, then we
will say update song.
92:20 - We are using a ternary operator here.
92:22 - So then if
92:25 - this statement is false,
we'll say Add song.
92:29 - So UIButton title.
92:30 - We can then copy this
and put that in as text right here.
92:40 - Let's create a blank initializer,
92:46 - and we will also have an initializer.
93:09 - And then we have another
initializer with our current song.
93:13 - There you go.
93:14 - We have another initializer that says
that Intake is a current song,
93:18 - and we set the two properties
song ID and song title.
93:21 - But if we don't have a current song,
that means we're adding a new one.
93:23 - So right here it doesn't
take any properties.
93:26 - And this is fine to do,
93:28 - because every property we have in here
will have a default value of some sort.
93:33 - So this one is an empty string.
93:34 - That one would be nil.
93:36 - This one could be true or
false depending on that.
93:38 - And then again, this one is
one of those two values.
93:43 - So we want to add a new song.
93:46 - So let's create a function to do that
93:55 - the code for adding a song is going
93:56 - to look very similar to the code
that we just wrote for fetching a song,
94:04 - and we can actually go and probably
copy majority of this.
94:09 - So we can copy this part because
we'll be doing the same thing.
94:13 - We have to create our URL,
and then we will use the base URL
94:17 - from constants and we're
using the same song endpoint.
94:22 - But what we are doing is we are sending
94:24 - a song to the database to the API,
so we have to create that song property.
94:40 - So here what we're doing
is creating a new song.
94:42 - It does not have an ID yet because we
94:45 - don't assign one within the iOS app,
and then we're using the song title.
94:49 - So that is whatever ended up
being Typed into the text field.
94:53 - In the view.
94:55 - Now we need to actually make the URL.
94:57 - We need to make the URL request,
so we don't do that here.
95:02 - We do that inside of our http client.
95:05 - So we have to make a new function
because we're not fetching data.
95:08 - We are sending data.
95:11 - So we'll make a new
function called send data.
95:35 - We'll close that there so
we can see the whole line.
95:39 - So because we're using generics again,
95:41 - we have our type T,
which conforms to codable.
95:48 - There we go.
And then we are sending it to this URL.
95:53 - I cannot type object.
95:55 - The object that we're using is of type T
95:58 - and then Http method, which we'll look
into, and then that will be a string.
96:04 - So the first thing we do is we
have a couple Http methods.
96:08 - We have seen two so far.
96:10 - We saw get and then post.
96:13 - So let's define those up here.
96:15 - And again, this is all
to make it type safe.
96:18 - So in case we accidentally spell post
wrong, it won't break all of our code.
96:29 - So this is an enum with a raw value.
96:37 - So we've used post and get and we have not
96:40 - yet used put and delete,
but we will get to those.
96:43 - And then with the raw value of string, the
raw value will just be the case itself.
96:48 - We also need to add a few other things,
and this goes with the URL request.
97:22 - So we'll look at Chris a little bit later
97:25 - when we kind of see it more in postman
or I can open that now too.
97:30 - I already have that.
97:31 - So in postman when we did a create song,
when we added a new song,
97:38 - we didn't look at these headers,
but this is what we're doing right here.
97:41 - So that said Http header.
97:44 - We added by default.
97:46 - It adds a header called content type,
and we set it to applicationjson.
97:50 - So that's what these two
things are used for.
97:55 - And then that basically just tells
97:57 - the request what kind
of data are we sending over.
98:01 - Let's go down to send data
and make our URL request.
98:08 - So here we are making our request.
98:11 - And what we saw in postman.
98:17 - I forgot to add the actual name URL here.
98:22 - So what we added was this is
the application JSON part of the header.
98:28 - And then this tells you for header
field in the field was content type.
98:34 - So we see the same thing in postman
98:39 - the key in value, which is sort
of the same thing is content type.
98:43 - And then we have application JSON.
98:45 - Everything else are like defaults.
98:48 - So that's why it says
auto generated headers.
98:51 - So we've added that to what kind of data
98:54 - we're looking tell the request what
kind of data we're looking for.
98:57 - I'm just going to hit enter there
to make this a little shorter.
99:01 - And lastly, we have
to send the data along.
99:03 - So we want to send data to our server.
99:17 - So here we have an HTT body and we want
99:20 - to encode our data from our object,
and then we encode it as JSON.
99:26 - So that's why when we went to send data,
we had the body property,
99:30 - and then this is our JSON object with a
key of title and then the value of money.
99:36 - And right here we're telling it it's JSON.
99:39 - Now we actually need to make the request.
99:45 - So here we are doing the exact
same thing as we did
99:50 - at this part inside of the fetch function.
99:53 - So this is the same thing.
99:55 - Except we are passing a request
rather than passing a URL,
100:00 - and we put an underscore here because we
don't really care about the data that's
100:03 - coming back because we don't
actually have any data coming back.
100:06 - We are responding to the request
with just a response.
100:11 - So that's what this value is.
100:14 - And then for those of you who don't know
this is a tuple or tuple,
100:17 - I don't really know how it's pronounced,
and it allows you to kind of have two
100:22 - values that are returned out of a function
rather than just returning a single value.
100:27 - This is like a comma
separated list of values.
100:30 - So we have data and response.
And then again,
100:32 - we are checking the response that it is
of this type, and the status code is 200.
100:37 - Because if it's not 200, that means that
it didn't go okay or it didn't go well.
100:41 - And it failed.
100:43 - So now that we've created our Http client,
now let's go and use the client
100:51 - in our view model here.
101:03 - So what do we want to send?
We want to send the URL.
101:10 - You can see it says encoded and decoded
101:14 - by default, because right here we
say that T is of type codable.
101:18 - And if you click on this
and click Quick help.
101:21 - So command click on this.
101:23 - Codable is actually a type alias
for decodable and encoded.
101:29 - So we want to pass our object of song
an Http method that we want to use instead
101:35 - of just typing posts directly here
we will use our enum
101:46 - and use the post and raw value.
101:50 - So I'm going to hit enter
on this just to make it easier to read.
101:55 - And then that's all we have
to do to add a new song.
101:58 - So now we need to call
our addsong ibaction.
102:01 - But to do that, we can't just
call that directly in our button.
102:05 - We Xcode for now, which I might do.
102:09 - Actually, it's for the view model.
102:11 - So we need
102:15 - ViewModel add song.
102:17 - We cannot just call ViewModel add song.
102:20 - We could, but we're using
this for both add and update.
102:23 - So we kind of have to have something here
that decides are we adding or updating?
102:27 - And depending on that,
we perform the right ibaction.
102:30 - So inside of our view model,
102:34 - this is part of the view model.
There we go.
102:39 - That one error should go away.
102:41 - But we have had updates song.
102:43 - So we have adding a song.
102:45 - But yeah, we need to decide
are we adding or updating?
102:59 - So here we're calling this
and it's an async function.
103:04 - So we need to put it inside of a task.
103:08 - So how do we decide if
we're adding or updating?
103:11 - We created a property up here called is
103:13 - updating, and we can use that
in our if statement.
103:19 - And by default if you don't type
anything like equal equal true.
103:23 - By default it says
103:25 - if this is equal to true,
which is the best way when using boolean.
103:30 - So if we are updating, if that's true,
103:32 - we want to update the song,
but we haven't done anything here.
103:35 - So let's put a comment
103:39 - updatesong function
103:41 - else
103:48 - we want to call our function add song.
103:51 - And again, this is an async
thing that throws.
103:55 - So we actually need to put
103:59 - try a weight on top of it or before it,
and we want to handle what happens.
104:06 - So we want to put all of this
inside of a do catch block.
104:10 - If
104:12 - there were to be an error,
we want the function to throw and actually
104:15 - handle the error as opposed
to having it just sort of disappear.
104:23 - So here we do that.
104:24 - And then I added a completion handler
on here because after everything has been
104:29 - performed, so we go to right
before the end of our task.
104:35 - I want to call our completion handler,
104:37 - because when we call this function when we
add something new to our database,
104:41 - we want to wait until this action
completes before we do something else,
104:45 - like updating our view for updating
the new song in our list.
104:50 - So we have all of this here.
104:52 - So now we can call this inside
104:56 - of our UIButton.
105:03 - We have our add update action.
105:05 - So after we have done the action of adding
105:08 - or updating, we want to close
the view, which is one thing.
105:12 - So to do that, we first need
to add an environment variable,
105:43 - and this is how we can
dismiss this view after
105:48 - our
105:50 - song has been added.
105:52 - So once we do that, we can go back to song
105:55 - list, and now we can call
the right thing here.
106:01 - So when we're right here we want to show
106:06 - add update song
106:11 - here.
106:12 - Now we're presenting the same view,
except when we do add song,
106:16 - we give a view model with nothing inside
of it because there is not a song yet,
106:20 - whereas when we do update song,
we are using this variable of song to then
106:25 - pass to the view model so it knows what
song we are then going to update
106:30 - and we have this on dismiss code here
because at the point of after we
106:35 - presented the model,
type something in clicked on the button.
106:39 - The view is then dismissed and we want
106:41 - to then update our view here to show
the new song inside of that list.
106:48 - Let's do that with our function of fetch.
107:18 - Okay, so we have
107:21 - ran the function inside of our task block
because this is an Asynch await function
107:25 - or it's an asynchronous function and we
are calling ViewModel fetchsongs to fetch
107:30 - new songs after the sheet has dismissed
to get updates from our database.
107:35 - Then we put this inside of a new catch
107:37 - again to handle the error
if it comes back.
107:40 - So we built the app and ran it.
107:42 - So now we should be able to click on run.
107:46 - We should be able to type in new songs
107:48 - to add to our database and also read
all the songs from the database.
107:53 - Bad access. What is that about?
108:00 - So I'm going to clean the project and then
108:02 - build it again because I'm not sure
why that came up.
108:07 - So you clean your project
with commandshiftk.
108:11 - Okay, our project built and we can see
108:13 - that we have a new request here through
the songs endpoint because that's what
108:17 - runs when we loaded for the first
time in this dot on appear.
108:21 - Let's click on the plus
108:26 - and I did not connect it because you need
108:28 - to call the function
and not just print add song.
108:32 - Where did I do that?
Right here.
108:41 - So we want to type modal equals add
108:44 - because our sheet is bound to this modal
property, and when we click on add song,
108:51 - we want it to present the ad
sheet, not the update one.
108:55 - So let's stop it and run it again.
108:58 - We see a new request here for the songs
endpoint and we see a new one right here
109:03 - because that's what we did
when we got all the songs.
109:06 - Now we click on the plus here and we see
109:09 - our modal pop up with the text
field on the button.
109:12 - So what song do we want to add?
109:14 - Let's add
109:18 - the year by the Jonas Brothers.
109:20 - So if we type that and click on add,
109:25 - we saw the modal go away and we
saw our data update right here.
109:30 - You can see in our logs.
109:33 - We did get songs first.
109:35 - That wasn't the first thing.
Yeah, it was.
109:38 - We did get songs when the view
loaded for the very first time.
109:42 - We did a post to create our new song,
109:45 - and then we did get songs again so
that we can update our initial list
109:50 - and there we go.
109:51 - We have successfully created new
items and put that in the database.
109:56 - And also
109:58 - we have read data from the database
to view in our iOS app.
110:02 - So to stop everything,
110:03 - we can stop the project and to get out
of this, you type Control C
110:08 - to stop our Vapor API from running,
and then to stop in Grok from running.
110:13 - You type control C as well, and it'll
just go back to your downloads folder.
110:23 - That was a lot of code.
110:25 - What we did was create our folder
structure using MVVM model view model.
110:30 - We created network request using the new
110:32 - Async await syntax with Swift 5.5. We made
it generic so that we could drop this code
110:38 - into any other project that we
wanted to that uses network request.
110:42 - Lastly, we used in Grok to connect
our iOS app to our local vapor API.
110:48 - In this video I'll show you how to create
110:50 - two new routes in our Vapourapi to update
and delete data in our database.
110:54 - We will then call those two
routes from the Swift UI iOS app.
110:58 - Let's get started.
111:00 - We are going to make
the update and delete routes.
111:04 - So let's first make
a new function function.
111:15 - Oh my gosh.
111:18 - Okay, update.
111:20 - We will have a request that throws
like the rest of them.
111:30 - We'll make a function called update and it
111:33 - looks similar to the rest of them
and it will return an event loop future
111:41 - and it will return an Http
status similar to the request.
111:46 - So if it works will return.
Okay.
111:48 - Otherwise it will return
some kind of error.
111:51 - So the first thing we do when we get
an update, we are going to be sending data
111:54 - over from the iOS app from postman about
the song that we are updating.
112:00 - So we have to first decode the song
112:02 - similar to how we do it
with the post request.
112:05 - So I'll just copy this
because it's the same.
112:09 - And then I'll also add a comment.
112:16 - So this is what the route
is going to look like.
112:18 - It'll be a put request because that is
what it looks like when we do an update,
112:23 - that's the request type and what we do
when we do an update is we first look
112:28 - to see can we find the song
that we are going to update?
112:32 - And then we will update the data itself.
112:39 - What we do here is we first
query to find the song.
112:42 - So can we find the song that we give
it from postman or from our iOS app?
112:48 - And so we look for the
song based on its ID.
112:51 - And if we cannot find it,
we will then grow abort not found,
112:56 - which is a 404 error and unwrap
it's unwrap or meaning.
113:01 - Can we unwrap this value because
this returns an optional?
113:05 - If we look at find.
113:07 - If we click command,
click on that and then click quick help.
113:12 - We see it returns an optional.
113:15 - So if we cannot unwrap this so unwrap or
113:19 - we can't we will return
four or four not found.
113:22 - But if we can, we continue
and we will flat map this.
113:25 - So the first thing we do is
113:28 - take the value and basically set because
there's like a pretend value here.
113:32 - We set the value of the title
property equal to our new song title.
113:36 - So that is the song here.
113:39 - And then what we do is we return
the instance of updating it.
113:43 - So we take this new song
and update it on the database.
113:47 - And this update function really
is kind of just like saving it.
113:50 - So if we come and click on that, that
doesn't give us any useful information.
113:55 - But really what we're doing is updating
the value within the database for this one
114:01 - song, and if that all works out,
okay, we transform it to okay.
114:06 - And then let's write
the delete function as well.
114:12 - So this is our delete.
114:14 - And actually I messed
up the comment up here.
114:17 - It won't besongsomething it'll just be
the slashsons route.
114:23 - And then this
114:25 - is what this route will look like.
114:27 - So for delete, it will be
a delete kind of request.
114:30 - And we'll see that in postman in a minute
and the route will look likesongid.
114:36 - And that's that UU ID that we
have for our song model.
114:39 - So what we do with the delete function is
we first use our song model,
114:44 - and we're using fluent to do this finding
and basically querying our database.
114:48 - So we do find and then we get the request
parameters and we called it song ID.
114:54 - So that's what this part will look like.
114:56 - So it'll besongs.
114:58 - And then that long ID
number from our database.
115:01 - We find it in this database.
115:04 - And then again, we unwrap
the value if we have it.
115:07 - Otherwise we're going
to throw a four or four.
115:09 - And what we do is a flat map.
115:11 - And we dot delete for this database.
115:14 - And we're deleting that song
from the database.
115:17 - And then this is again a fluent function
because we're using our song fluent model.
115:23 - And if everything goes well with that,
we go ahead and transform it to OK.
115:29 - So let's go ahead and run this.
115:31 - But first we have to make
sure the database is running.
115:34 - So I'll use the Docker desktop application
115:38 - rather than the terminal.
115:39 - So that was my testing one.
115:41 - Here is our actual API that's running.
115:44 - And then that is the database.
115:45 - So let's go ahead and just
click run or start.
115:50 - And then this is now starting up this
container and we can click on this row
115:56 - to see the terminal information as if we
ran it from the terminal down here and it
116:01 - says it's starting and we can check if
this is working using Azure Data Studio.
116:06 - Let's go ahead and open that.
116:10 - So we have Azure Data Studio.
116:12 - We're on the welcome page because we've
already connected to this database.
116:16 - We can see it in the
connections over here.
116:19 - But if we go and just double click on it.
116:21 - It brings up that list as if we were
connecting to a new server,
116:24 - but we have all the information
here because it saved it.
116:26 - I didn't check remember password,
so it doesn't have it Typed.
116:29 - It doesn't have it auto filled in here.
116:32 - But if I go ahead and type it
116:37 - and click on connect.
116:39 - So now we have a green dot here,
meaning we're actually connected to it.
116:44 - We should see something.
116:49 - There we go.
Took forever to load.
116:53 - Okay, so we have a green dot, so we're
connected and I double clicked on this.
116:58 - Usually it shows a list down here.
117:00 - I think mine still might be Loading,
117:01 - but we can go ahead and still click
on the Songs table and click Select Top
117:06 - 1000, but we know because we
can connect to the database.
117:09 - We know it's already up
and running with Docker.
117:11 - Otherwise we wouldn't have
been able to connect at all.
117:13 - So we see our two songs
that we have in here.
117:16 - Let's go ahead and now run our API,
117:20 - so we just go ahead and click the run
button within Xcode,
117:24 - and we will need to grab a postman
as well to make our request.
117:33 - This build failed because we did not call
117:36 - the function because you have to call the
function to be able to use the function.
117:41 - So we added our two routes
update and delete down here.
117:45 - But what we didn't do up at the top is
117:47 - actually put them in our boot
function so that we can use them.
117:56 - So there's another operation called
117:58 - Songstot put, and this is using our
routesongs, so it groups that route right
118:04 - here and then we have get and posts,
but we also need to add the put,
118:08 - and then lastly, with the update,
it looks a little different.
118:13 - There we go.
Okay.
118:14 - I think those probably should be syntax
118:16 - highlighted, but my computer just doesn't
know how to do that,
118:21 - but we have our Songstock group,
and we are grouping anything that has this
118:26 - ID on it, and we're going
to call the delete function.
118:29 - So what that is it will look like Song ID.
118:35 - And then this is what that song ID is so
118:38 - that this string is the same between these
two and what it looks like when we
118:44 - actually use it within postman,
it will look something like this is we
118:48 - have our URL, the route songs, and then
this is the ID that's in our database.
118:56 - So that is finally calling
our two functions.
118:59 - So we are calling to use Song delete,
119:01 - and we want to use our delete
function that we have down there.
119:04 - And then when we do a put request,
we use the update function right here.
119:10 - So we should be able to run this now
and that should go away.
119:17 - We still failed.
119:18 - Oh,
119:20 - I spelled parameters wrong.
119:22 - Okay, now let's run it again.
119:28 - This dialog comes up, click on.
119:30 - Okay,
119:33 - and our server is starting.
119:35 - So that is good.
119:37 - So let's test our update function first.
119:40 - So I have all these tabs because I've been
adding them and trying everything out.
119:45 - But we go ahead and you can click on a new
119:48 - tab or just use the one
that you've been using.
119:51 - So we need to change our request type
119:54 - from Get or post and change it to put
because we're doing an update.
119:58 - So we have our URL right here.
120:01 - We have our songs route,
and then we click on the body properties,
120:06 - and we want to change this to Raw
and then change the type to JSON.
120:12 - So we type out our JSON model,
which is just the title and the ID.
120:16 - So let's update one of these values so we
120:19 - will need the ID and we'll need
the title that we want to change it to.
120:24 - So if we click on this row and just click
120:27 - command C for copy, and we fill
that in right here for the ID property.
120:34 - And then right now it says year 3000,
but we can change it to anything else.
120:39 - So let's change this from year 3000 to two
year
120:44 - thousand and 21, which is almost over.
120:46 - So let's change it to year 2022.
120:49 - So that's in the future or if you're
120:51 - watching this in the future,
it's now in the past.
120:54 - So if we change this,
let's go ahead and send our request.
120:59 - Okay.
121:00 - We sent our request and it
gives us back status 200.
121:03 - Okay, so that's good.
121:04 - That means we did the right thing
and everything worked because right here
121:09 - we tell it to transform everything
to okay, if everything else was good
121:13 - and we can confirm that this worked
by going down to Azure Data Studio.
121:18 - So we click on Run and we see
our data down here for this ID.
121:22 - We change the title to year 2022
instead of being year 3000.
121:27 - So we know our update function worked.
121:30 - So now let's test our delete function.
121:33 - So we go back to Postman
and I have a new tab called Delete.
121:37 - But all this is doing is really
just changing the type to Delete.
121:42 - But for this one,
we do not need a body property.
121:44 - So if you're using the same one,
go ahead and select none here or just make
121:49 - a new tab and it resets
sort of everything.
121:52 - So this is an old ID I was using.
121:55 - But let's go ahead
and use one of these ID.
121:58 - So let's say we don't
want your 2022 anymore.
122:02 - So copy the ID,
122:03 - go back into Postman and just paste
it into this URL and let's hit send.
122:12 - We got back 200.
122:13 - Okay, so that's good.
122:14 - And we see in Vapor,
122:16 - there was our Put request, and here is
our delete, and we know how we coded it.
122:22 - If we got back 200, that means everything
was good and it was able to delete that.
122:26 - So let's go back to our Vapor database.
122:29 - Click on Run again.
122:31 - The only song that's left in our database
122:34 - is the money song, and the year
2022 is now completely gone.
122:38 - So that part works.
122:40 - We have our API done.
122:42 - So we have our two new requests for update
and delete, and then we have verified
122:47 - that using Postman and Azure Data Studio
to check everything is working.
122:52 - Now let's go and write this
functionality in the iOS app.
122:57 - Let's make the iOS app.
122:59 - So first we want to update a song.
123:02 - So to do that,
123:05 - let's first run the project to see what it
looks like, and we don't have anything
123:09 - because we need to start in Grok,
and that's not from our iOS app.
123:14 - That is from the API side.
123:19 - So we can run in graph in another tab or
123:23 - I'll just open it into a
different window over here.
123:28 - We are running the API on the left and we
123:30 - need to run in Grock, which I
run from the downloads folder.
123:36 - So CD just goes back to our root directory
and then I want to go to downloads
123:41 - inside of here.
We have ingrock, so I do
123:48 - ingrock 8080, which starts up in Grok
and we need to take this URL.
123:57 - Copy that and put it
into our constants file.
124:01 - Okay, let's paste this here
124:06 - because we're still committing this.
124:07 - It looks like we're changing it,
which is fine, but we need that URL there
124:12 - and we need to stop this
from running and run it again.
124:18 - We should see our two values
that we saw that we saved earlier.
124:25 - I ran the project, but I forgot
124:29 - to add a slash onto it because
you can see the URL right here.
124:34 - There's no slash before we
have the slashsongs route.
124:38 - So I need to stop this and run it again.
124:42 - We ran our project.
124:43 - We can see we do one get request and it
124:46 - turns back a 200 and we see
it in our terminal over here.
124:51 - So we know we are reading something,
124:53 - but when we want to update a song,
we had add or update song view
124:59 - and this is presented if we
look at our song list here.
125:06 - This is presented when we tap on it.
125:09 - So actually right now
it'll just say selected.
125:11 - So if we go and just click tap on money,
125:16 - it just says selected,
which is not what we want.
125:18 - Now we want to show this and update it,
but we want to show not the add modal.
125:25 - We want to show the update modal.
125:28 - We did a lot of that set
up in the last video.
125:31 - So let's change this.
125:33 - We want to change the modal
property from add.
125:39 - Modal equals
125:42 - update, and this will change Chris
property that our sheet is viewing here.
125:49 - This was the on dismiss it's right here.
We do a switch.
125:52 - If it is update,
125:54 - we present the add updatesong view
and we give it the current song.
125:59 - So let's go and run this
and see if our view pops up.
126:09 - I think that's what
autocomplete is telling me.
126:13 - Modal needs a song.
126:14 - So we see the song right here because we
126:18 - have to tell the next modal that's going
to come up what song we want to update,
126:22 - and then that is this song
for whichever one is actually selected.
126:29 - We run this and we see in the simulator.
126:31 - If we tap on money,
we see almost everything is working.
126:35 - It fills in the word money,
126:36 - and we have update song here and we see it
says update rather than saying add because
126:41 - it's presenting the right type of modal
for which state that we want to use.
126:47 - But we need to write our update function.
126:50 - So let's go into the view model of Add
updatesong, and we already wrote it here
126:56 - commented out because we knew we were
going to put the update song function
127:01 - here, but we haven't actually
made the function yet.
127:03 - So let's go and make it.
127:06 - Let's just put it right above here.
127:09 - Technically, personally,
what I would do is move this one up,
127:15 - move this one up here.
127:16 - So you would have the add update action
127:18 - would be called and below it,
the two functions that are called inside
127:22 - of it would be below,
but it doesn't really matter what order.
127:26 - Let's type our function.
127:40 - Okay, this is our update method.
128:00 - Okay.
128:01 - Our update song method looks like this.
128:03 - We are creating our URL
similar to how we did
128:08 - in the one up here.
128:09 - And then we're doing the exact same thing
right here as we are making our URL
128:14 - into an URL object,
and then we have our song to update.
128:18 - So this would be the song right here.
128:21 - So we give it the song ID,
which is passed over from the last view.
128:25 - When we are passing where did it go?
128:28 - Song list
128:30 - right here.
128:31 - When we pass Chris song over,
it has an ID and it has a song title.
128:37 - So here's the song ID that gets passed
128:39 - over and then song title whatever is
Typed into that song title text box.
128:44 - And we can see that if we go
to the actual add song view,
128:49 - it's the song title right there.
128:52 - So we take that we make
it into a song object.
128:55 - And we already have created
this send data function.
128:59 - So we know if we look at our client
129:02 - send data, it is using whichever
method that we specify.
129:08 - So back there we saw we did the put
129:10 - method, and here we're just passing
the JSON over, which is what we want.
129:17 - So we already wrote
the ibaction that we have.
129:19 - All we had to do is implement
this function in a different way.
129:22 - So we implemented this in almost the exact
same way as we do an ad right here.
129:28 - But instead of using a post and creating
a new song, we use a put method.
129:36 - So let's try that.
129:37 - Now what is this complaining about?
129:41 - Again, we need to Mark this with try await
129:44 - because this function uses
the async await pattern,
129:50 - and that should go away.
129:52 - So it uses async await.
129:54 - So we need to tell this
function to use it in that way.
129:59 - Let's go ahead and rerun this.
130:02 - So we have the song called Money.
130:04 - What is a different song title?
130:07 - Let's change this completely to
130:18 - let's change it to how you like that
130:22 - because you can see I like the
was that the band?
130:27 - Yeah, black Pink, and they've been
stuck in my head for a while.
130:29 - So we'll change it to this.
130:31 - And if we click update song,
130:34 - we see it updates and how you like that is
130:36 - now here rather than the song Money
and we can even further conform.
130:43 - Confirm that if we go to
130:47 - Azure Data Studio, which I closed,
so we have to open it again
130:52 - and check the database to see if it says
130:55 - how you like that instead of saying Money
as the one record that is in there.
131:00 - So I'll go and connect to it and I didn't
131:02 - click remember password,
so I have to type it again.
131:08 - Click on Connect.
131:17 - So once we load our database,
131:19 - we see the one record and the only
thing that's here is how you like that.
131:23 - So if we go to add a new song,
just click on the add button and type
131:27 - in a new song, we'll call this
one Money and click on Add song.
131:33 - Now we see both of them here.
131:34 - So if we go back to Azure Data Studio
and click on Run again
131:39 - or I might just close this and open it
again because mine is having issues.
131:44 - Now we have both of our songs
and they have two different IDs.
131:48 - So we know both of those are working
131:49 - and we know the read function works
because we see them in the list.
131:54 - So that's all we had
to do to update the song.
131:56 - We just had to add this one function
because all of the work that we did
131:59 - in that last lesson
set everything up for this one.
132:03 - So let's go now and create
the delete function.
132:07 - So let's stop the app and I'll
just move this out of the way.
132:12 - We need to go to the song list
132:16 - and we are going to add a delete
modifier on this for each loop.
132:20 - So first let's actually write the function
132:23 - and we will write that
within our view model.
132:26 - So let's open the song list ViewModel.
132:30 - And instead of fetch songs,
let's make a new function for deleting.
132:34 - So what we are going to do is use
the delete function where it looks like
132:40 - right here on delete and then perform
something that takes in an index set.
132:46 - So ours will be ViewModel delete.
132:49 - But let's actually write that.
132:56 - Okay.
We have almost written everything.
132:59 - So we have offsets and that's part of an
index set or the type of it is index set.
133:07 - And if we click on the quick help here,
133:09 - it shows us that this is a range,
because really, you can kind of delete
133:14 - multiple things at once
when you use index sets.
133:16 - So what we're doing here.
133:18 - Is iterating through all of the index
133:20 - sets? And actually this
needs to go inside of here.
133:28 - Now we are
133:31 - going to iterate through every index set
133:34 - and delete each one in case there are
multiple how we are going to code it is
133:39 - there won't be multiple at once, but this
gives you the ability to do it that way.
133:44 - And then you can see we actually need
133:46 - to make a new function for deleting
because we can't use let me delete those.
133:52 - We can't use the ones that we've already
written because we have written fetch
133:55 - and we have written send data,
and neither of those do a delete.
134:00 - So we do need to make that new function
134:02 - within our http client
so we can use it here.
134:07 - And then this function delete
gets used inside of song list.
134:13 - Actually, it's ViewModel,
134:17 - and we don't actually need the app or
the parentheses just because we're passing
134:23 - this function itself and it has the same
signature that this was expecting.
134:26 - So we don't need to type
the little extra characters there.
134:30 - But we do still need to make our delete
function within our http client.
134:41 - So here is our delete function.
134:43 - We make a new URL request object,
we make a new URL request object,
134:49 - and we set the method to delete,
and we define those methods up above.
134:54 - We use the new URL session shared
data instead of data task.
134:58 - This is the new async one and we give it
135:00 - a request and we are getting
back data in response.
135:03 - But how we have it coded,
we're not actually getting back data
135:06 - because we kind of don't
care what we get back.
135:08 - We just want back a response.
135:10 - So we're putting an underscore here
and then this is a tuple or a tuple.
135:16 - I don't really know how it's pronounced.
135:18 - So that's the object
that we're getting back.
135:20 - So we care about the response.
135:22 - So we have an underscore for the data,
135:24 - and then we take the response and try
to cast it as an http URL response.
135:30 - And if that all works,
we see if the status quo is equal to 200,
135:34 - and then if that is all good,
then this function is like over.
135:38 - Otherwise it would throw
an error that says bad response.
135:42 - So if we go back to our song list view
135:44 - model and try to use this,
we should now get autocomplete.
135:49 - Here we go delete at ID.
135:51 - So we have the ID that we defined above
for the song ID, and then the URL is
136:01 - the URL that we defined here.
136:02 - So here this is putting
everything all together.
136:06 - Otherwise we could have made first a URL
136:08 - string variable and then
added this together.
136:11 - But just in this part I decided to put it
136:13 - all on one line,
so we have that and that should be it.
136:19 - And we can see in our song list on delete.
136:22 - When that action happens,
136:23 - we are performing our delete
function inside of this View model.
136:27 - So it's calling here.
136:29 - So let's go ahead and run the project
and bring over Azure Data Studio.
136:35 - Okay.
136:35 - We have our two songs here
and let's just add a third.
136:41 - Just so we have kind of a few.
136:45 - They have a song called Today.
136:47 - So I'll click on Add song.
136:48 - And so now we have our three songs,
but say we don't like how you like that.
136:53 - So if we do the swipe action of Swiping
136:55 - left, that automatically comes because we
define this on delete action here.
137:01 - So that just works automatically.
137:03 - So we have slide here tells us delete,
you click on delete and it's still there.
137:08 - Oh, I know why it's there,
but I believe if we check our database.
137:15 - Okay.
So it has gone from our database,
137:17 - but it's still in the app that happened
because we did go about deleting it
137:22 - from the database, and we saw
that that happens right here.
137:27 - So we know our Http client is working.
137:30 - What we did not do is inside
of this whole delete function.
137:36 - We use offsets and deleted that.
137:39 - So we did this functionality all worked.
137:42 - But what we did not do was delete
it from our array of songs.
137:46 - So our View model has all of our songs
here, and we didn't delete it out of this.
137:52 - So we need to just call
137:56 - songs that remove
137:58 - an offset and pass in
the variable offsets.
138:03 - So let's stop this.
138:05 - So basically the array
was still in memory.
138:08 - So that's why it came back,
even though in reality it wasn't there.
138:13 - Let's try to run this
again and see if it works.
138:16 - So if we go to add a new song,
138:20 - there's a song called Kill This Love.
138:22 - So if we add this song,
so now we have our three songs here.
138:26 - But let's say we want to delete stay
138:30 - there we go now.
138:31 - That is deleted.
138:32 - And what we should see here is
just Money and Kill Chris Love.
138:36 - So I'm going to close this tab and open it
138:38 - again because I think
mine is having an issue.
138:41 - And there we go.
We just see these two songs.
138:44 - So there are the UIDs and the two songs
that we have and that we see in our app,
138:50 - and that is it.
138:52 - We are able to successfully update
these songs and delete them.
138:56 - And in total, we can do all four options
138:58 - of crud of create, read,
update and delete.
139:04 - And there we go.
139:05 - We have made two new routes to update
139:07 - and delete data with our Vapor API,
and we use those routes in our iOS app.
139:12 - Hey, everyone, my name is Mikaela Karen.
139:14 - I am a full time iOS developer,
and recently I've been learning Vapor,
139:18 - so I'm excited to share with you how we
have finished building our Vapor API
139:22 - and how we can take that and actually
deploy it to the real world so anybody can
139:26 - use it and how we can
use it from our iOS app.
139:29 - Let's get started first thing we
need to do is install Heroku.
139:34 - So we are going to use Homebrew
like we have for vapor.
139:37 - So just type brew install
139:40 - Heroku and then just hit enter.
139:44 - Mine is already installed.
139:46 - But every time you try to install
something new, it will try to update
139:49 - Homebrew if it hasn't
been updated in a while.
139:52 - So mine is fine.
139:53 - And then it's telling me a warning
139:55 - that it's already installed and up to date
and then just tells you that if you want
139:59 - to reinstall it, that's the command
you write, but we have that installed.
140:02 - So that's good.
140:03 - And second thing we need
to do is make a new account.
140:07 - So let's do that right now.
140:09 - So go to sign up Heroku.
140:11 - Com and we're just taken to the sign
up page and let's type in my name,
140:24 - type in your email.
140:26 - You don't really need a company name role.
140:30 - I'm a professional developer, so we'll
put that I don't think it really matters.
140:34 - And then primary country.
140:36 - I'm in the United States and primary
140:37 - development language is I use another
language because Swift sadly isn't here.
140:45 - So just check.
I'm not a robot unless you are.
140:50 - Yes, I spelled everything right.
Okay.
140:53 - Click create free account,
and now I need to go check
140:58 - that the address is correct
and you'll get an email about that.
141:02 - Okay.
So the email that you're going to get will
141:04 - just direct you to this link
to actually input a password.
141:09 - So type in whatever password you want.
141:11 - Make sure it meets those minimums
and click set password and login.
141:16 - Then we can close the other window here.
Okay.
141:20 - It tells me my new account is all set up,
so we'll just click to proceed
141:26 - page not found.
Okay.
141:29 - I think it did this to me when
I tried it the first time too.
141:33 - So if we just go to Heroku.
141:35 - Com.
141:37 - Yeah, it looks like we're good
because it let me sign in.
141:40 - It has my name, has my email
and we're fine.
141:44 - Okay.
Wants us to accept terms of service.
141:47 - I click accept, and then we're
brought to this main page.
141:53 - So what we are going to do,
141:54 - we are going to deploy our API to Heroku
and we do part of that using the GUI.
142:00 - So the graphical user interface.
142:01 - So that's just the website and then part
142:04 - of it we are going to do from the command
line for our project here.
142:08 - So the first thing we are going to do,
let's set up our command line.
142:12 - So what we want to do after we've
installed it correctly,
142:15 - I click command K all the time
and that's what clears the terminal.
142:19 - We want to type Heroku login,
142:23 - and what this will do,
142:24 - we'll press any key to open up
a browser or login or Q to exit.
142:28 - So I'll just press the space bar
142:31 - and then we see it automatically opens
142:33 - my browser and tells me,
hey, do you want to log in?
142:36 - So I'll just click on login.
142:39 - We will do that later.
142:41 - We don't need that right now,
142:44 - and it says we're good.
142:45 - So it says we can close this page
and return back to your CLI.
142:48 - So CLI is command line interface.
142:51 - If you didn't know that just
means your terminal.
142:53 - And then we see right here.
142:56 - This is it tried to open a web
browser in case it didn't work.
142:59 - It says logging in and done
because we did it.
143:01 - And then we are logged in as.
143:03 - And then that's my email and you
143:05 - can verify this with Heroku author.
143:14 - This is like just part of a plugin
that I have on my computer.
143:17 - So you pretty much won't see that unless
you have the exact same plugin.
143:22 - Click Heroku off.
Who am I?
143:23 - We just see my email come up because
143:25 - that's just the email
that we're signed in as.
143:28 - Let's create our app within
Heroku on the web now.
143:31 - So let's just click on this button here
143:33 - that says Create new app, or you could
click from here for Create new app.
143:38 - But this is already here
because it's the welcome page.
143:40 - So what do we want to call this?
143:43 - Let's call it CWC.
143:50 - Must start with a lower case.
143:51 - That's interesting.
143:53 - So that popped up because I have CWC
143:56 - automatically as like a keyboard shortcut
to show like code with Chris because I
144:00 - type it so often, but we'll
just keep it like this.
144:02 - Cwc vaporapi.
144:04 - I'm in the United States and then we'll
144:07 - just click on Create app
and then this is the main page.
144:12 - So part of this, we won't use a pipeline
144:14 - for this right now and then
the deployment method.
144:17 - We're just going to use
the Heroku Git CLI.
144:21 - And then here it gives us
the instructions deploy using Heroku
144:27 - get.
144:29 - We have done this stuff already.
144:31 - And right now here we are.
144:33 - We are in our project directory.
144:35 - So that's why it says ytvaporapi on mine.
144:38 - And that's also part of a plugin
that I have downloaded
144:43 - and it wants us to CD into our
project and type get in it.
144:48 - But we don't need to do
that because our project is
144:53 - already uses Git.
144:54 - So the only thing we need to do is
actually copy this,
144:58 - which says Heroku, which is part of the
Heroku command from what we downloaded.
145:02 - And then we're using Git.
145:03 - We're adding a remote and it's going to be
145:06 - called CWC Vapor API, which is what
we call our entire application.
145:12 - So we just copy that and paste it.
Here.
145:15 - We hit enter and it shows us set
get Remote Heroku to that link.
145:20 - And what that really means
is we added a new remote.
145:23 - So if we type get remote V,
I have two remotes here.
145:27 - So here is the origin
remote that I called it.
145:30 - And then this is the one on GitHub
where you can find all of the code.
145:33 - But then we added a new
remote called it Heroku.
145:37 - And then this is the link for it.
145:41 - So before we deploy this application,
145:44 - we want to set what is called a build
pack before we go and deploy it.
145:48 - So a build pack is really just a script
that runs before the app is deployed.
145:53 - So what we want to do is
type Heroku build pack.
145:58 - Set Vapor vapor because this
is a vapor application.
146:01 - We want everything that comes
146:03 - with the dependencies of Vapor to install
before everything is deployed.
146:07 - So we just type this command hit enter.
146:11 - Okay, after we hit enter,
we can see it says Build pack is set.
146:14 - Next release for our app,
we'll use Vapor Vapor and then run this
146:20 - to push the new release
using this build pack.
146:23 - So that is the command we're going to end
up using and you can see it's just Git
146:27 - push Heroku main, which is the same as if
you are pushing to GitHub where you would
146:32 - write like Origin main or
Origin feature branch.
146:34 - It's the exact same thing.
146:37 - But we do have a couple of things
we need to set up 1st 1st.
146:39 - So we need to tell it what
Swift version we want to use.
146:44 - So we can do that with this command
146:47 - of Echo five, two, one,
and then this little carrot.
146:52 - It's a great advanced sign Swift version.
146:55 - So what this will do?
146:57 - It will make a new file
called Swift version.
146:59 - And inside of that file, it will just
have these words five, two, one.
147:05 - So if we hit enter on that,
147:06 - you see this old lightning Bolt come up
on mine because of the extension that I
147:10 - have, and it just means
that we've changed something.
147:12 - So when you type get status and hit enter,
147:15 - you can see that we've added
a new file called Swift version.
147:21 - I don't actually know what Cat stands for.
147:23 - Honestly, I'd have to look it up.
147:25 - But what we do here is this is just
printing out the contents of this file.
147:30 - So when I type Cat Swift version,
147:33 - we just see that it's a file
and the Swift version is five two, one.
147:37 - That's all it is.
That's what's inside of that file itself.
147:40 - So we have that.
But we have to add one more thing.
147:45 - Heroku uses a thing called a Proc file,
147:47 - and it just tells the app
what it needs to look for.
147:51 - So we write that with this command.
147:54 - So Echo again, and then
all of this comes with it.
148:00 - And it's just telling it where
to put the file and what Port.
148:03 - And then it's creating.
148:06 - All of this will be inside of a new
file just called Proc file.
148:11 - So if we hit enter, it does that.
148:14 - And then if we type get status,
we can see our two new files that we have.
148:19 - So we want to commit these files because
148:21 - they have to be there when
we deploy everything.
148:23 - So let's type get add
and that will add our two files.
148:28 - So if we hit enter
and type get status again,
148:31 - we can see it changed from untracked
files to changes to be committed.
148:37 - And let's go ahead and commit these.
148:38 - So we'll just type get commitment and
148:46 - we'll make a message,
add Heroku build files,
148:50 - and now we can go ahead and deploy it.
148:53 - So we will type
148:56 - get push.
148:58 - Heroku and I have not tested this.
149:02 - So we will see typically you'll type get
149:05 - push, Heroku, Master or Main because
that's the main branch that you have,
149:09 - and you'll typically only
have one branch within your
149:14 - not one branch within your project,
but you may have one branch that you're
149:18 - using for deployment,
so you would use that one.
149:20 - But because I've split everything up
in lessons, I'm going to type lesson five
149:26 - because that's the one that's
ready for us to actually deploy.
149:30 - And let's see how this goes
because I do not know.
149:35 - Okay, there we go.
149:36 - It worked.
149:38 - It created a new branch
called lesson five.
149:41 - Let's see if we look at Heroku
and refresh this page.
149:46 - Did anything happen?
149:53 - It has not.
149:59 - Okay.
149:59 - Looking at the docs
to actually deploy code.
150:02 - It does say that the branch
name has to be Master or main.
150:07 - Otherwise, if we push to a different
branch, it really will not matter at all.
150:13 - So because I have this less than five
branch, it kind of doesn't matter.
150:16 - So let me make a new branch
150:20 - and I will call it Main,
and I'm branching from my Lesson five
150:24 - branch, which has that new
commit with our new build files.
150:29 - So let me type get check out
to check out the new branch.
150:33 - So now I have a new branch called Main
and I will type get push, not origin.
150:38 - We're going to go to Heroku
and then maintain hit enter.
150:45 - There we go.
150:46 - Okay.
Now it failed.
150:48 - When did it fail?
150:51 - So after some troubleshooting and then
150:53 - this is my testing repo where
I've done everything before.
150:58 - It was because
151:02 - the Swift version file that we
created needed to be 5.5.
151:06 - I don't actually remember changing it,
151:08 - but it has to be 5.5 instead of what we
Typed originally,
151:12 - which was 5.2 .1. So then once you
successfully deploy it and you have
151:18 - to deploy it on the main branch,
so it has to be either Main or Master.
151:21 - It can't be what I was doing,
151:23 - which was I called it lesson five because
that's how I broke up the whole course.
151:28 - So once I switched to the main branch
and then changed that to version 5.5
151:33 - rather than 5.2 .1 we're Apple to deploy
and you can see what's going
151:38 - on in terminal right now is
everything trying to deploy.
151:41 - So you can see over in the website
151:47 - that was me troubleshooting.
151:48 - You can see build progress
151:51 - and whatever is happening here is actually
151:53 - the same thing that's
happening in our terminal.
151:56 - So we can wait for this to finish.
152:06 - Here we go.
More compiling.
152:12 - I'll sell for Rubik's Cube
while we're waiting.
152:24 - I'm still not doing it right.
152:38 - How to do this for a minute.
152:41 - Okay.
We have successfully deployed everything,
152:45 - so you can see all the build
files right there.
152:48 - Or you can see the View build blog right
here, which show you the same thing
152:52 - that happened in the terminal,
and then in the end it shows you it
152:55 - created a new branch called Main,
and then it's been deployed.
153:00 - And what we have to do after doing that,
153:02 - we need to add a server basically so
that our application can go somewhere.
153:09 - So we do that using Heroku Psscaleweb
equals one and you'll see this appear.
153:16 - So once we hit enter on this and it runs,
you will see this and it'll say done.
153:22 - So if we go back to the web interface
and we refresh it, we will see something.
153:28 - Now we see this that we had from our Proc
file, so I don't know exactly what this
153:34 - is, but it's needed to get
everything running.
153:37 - So we have that and we
can see we deployed.
153:40 - This is our commit hash.
153:42 - So if we were to type get log one,
which only shows us one in our log,
153:49 - the beginning of this commit hash
matches what is right there.
153:55 - And that was my last commit
was updating that version.
153:58 - So we have that.
153:59 - And now it's completely deployed.
154:01 - So we could use Postman,
154:04 - which let me open that up and we
could then hit our API already.
154:09 - Everything's running,
but we haven't yet set up the database.
154:14 - So our app is fully deployed right now.
154:17 - So if we go to settings,
it tells us this is the name of our app.
154:22 - We are using Swift and
that's the get URL that we have.
154:29 - We scroll down a little bit more.
154:31 - We find this too much.
154:34 - We find this add domains.
154:36 - So you could configure this to use your
own custom domain like codewithchris.
154:40 - Com.
If you wanted to make the API
154:42 - from a domain like that,
you would have to configure it.
154:45 - But here is our API
for the built in domain.
154:49 - So when we use CWC vaporapi,
154:52 - that is the name of our application,
and then the subdomain is herokuapp.
154:57 - Com.
154:58 - So if we just put that
directly into postman
155:03 - and hit send without adding any kind
155:05 - of route, we get back 503 service
unavailable, which is not good.
155:15 - If we go to this in the web browser and
hit this, it gives us application error.
155:20 - So you can see this is application error,
and it's telling us an error occurred.
155:25 - And that's how we view the logs,
which we'll look at.
155:27 - But we also see when
we do this in postman.
155:30 - This is the HTML that came back
155:33 - for that web page because just
basic like going to a website.
155:37 - You are doing a get request.
155:38 - So if we see down here
we'll see the same thing.
155:41 - It's showing us whatever this web page is.
155:45 - And I guarantee if we command click,
we'll see the exact same thing.
155:51 - It takes us to the same error page,
because here the URL is our project URL
155:58 - and it's showing you it's making an iframe
which is just like embedding a website.
156:02 - And what it's embedding is this
like application error website.
156:05 - So when we go directly to that,
we see the exact same thing.
156:09 - So let's see what the error is.
156:10 - Let's type Heroku logs,
156:15 - tail and hit enter.
156:18 - What does this tell us?
156:20 - So you can see it gives us an ongoing log,
as in it doesn't stop.
156:24 - So we would have to hit
control C to get it to stop.
156:27 - But let me see if I can make this bigger.
156:31 - So it's kind of not all one.
156:35 - So if we try to go to our
application and hit enter,
156:39 - we see a new status appear
and it says app crashed.
156:43 - So part of what is happening when
we go to configure our application.
156:47 - So if we look at our configure code
156:51 - right here, it's trying to create
migrations and set up our database,
156:55 - but we haven't done anything in Heroku
to actually set that up yet.
156:59 - So that's part of why it's failing.
157:01 - I believe
157:03 - so we will do that the rest of that.
157:06 - And then we'll go back and try to see if
we can hit our main routes, which
157:11 - we didn't take out the Hello
and the root route these two.
157:16 - So that's what I was trying to hit
first was to return it works.
157:19 - And then let's try to hit Hello
and see if anything happens,
157:25 - so they still give us 503 unavailable.
157:28 - And then we can see
in the error down here.
157:30 - It tells us App crashed and you can
see we tried to hit the Hello route.
157:36 - Okay, let's set up the database
and then go back and try this again.
157:41 - So to get out of this, we type control C
157:44 - and then now we're no longer live
monitoring the logs and I don't like this
157:49 - being gigantic, so we're going
to make it smaller again.
157:55 - Let's go and add our database.
158:00 - What we want to do is go to the overview
tab and installed add ons where you're
158:05 - going to add a new one
and we will search for Postgres
158:10 - because that's the type
of database we want to use.
158:13 - So we want to do Heroku Postgres.
158:15 - Click on that one and we want to use
158:18 - the Hobby Dev one,
which is free as opposed to paying a ton
158:22 - of money for it, because we don't
need any of that right now.
158:26 - So we have the Hobby version
and click Submit order form
158:33 - here.
We can see that it's been added,
158:36 - and I believe this is the command we could
have Typed into the command line to do
158:40 - this as well rather than
doing it from the website.
158:43 - But the website is pretty easy.
158:44 - So that's why I did it that way.
158:46 - So we have our database and we can click
158:49 - this Heroku Postgres right here,
which opens up a new window and it takes
158:54 - us to a new part of the website that tells
us about the data and the database.
158:58 - So this is fetching everything and we can
159:01 - see we don't have any rows in our
database because we just created it.
159:04 - So basically it exists as a database,
159:07 - but we haven't added any of our
tables and any of our migrations.
159:11 - So when we go to migrations to create
159:14 - songs, here's our songs table
and we haven't ran any of this yet.
159:19 - So what we need to do is
159:23 - go back here.
159:24 - We need to change our code because how it
159:28 - works right here,
it doesn't actually work.
159:30 - And if we go and look at the
159:32 - Vapor documentation, which is
mostly what I'm following here.
159:36 - If you go to Docs vapor codes and you
159:40 - click on the side,
there is this whole menu and you go down
159:44 - to deploy and go to Heroku,
you get to this page and we are way down
159:49 - at the bottom for
almost everything running.
159:53 - It's telling us to change the code to look
something like this for getting our
160:01 - environment URL,
which is the database URL.
160:05 - So
160:07 - actually I'll keep this
right here for a minute.
160:10 - When we were looking at this here we are
160:12 - getting our environment database host
and database username password because
160:17 - these are the values it's using Vapor
password and Vapor username
160:22 - because it could not find an environment
variable because we never added any.
160:27 - But we still need like
a URL and a database host.
160:31 - So like where does the database live?
160:33 - We have to tell our app that in some way.
160:36 - So what we are going to do is it's
going to look for a database URL.
160:40 - But again, this is not a value.
160:42 - We want to hard Xcode and it even tells
160:44 - you if we type Heroku config,
it tells us how to access the database
160:52 - and they called their app.
160:55 - Today I learned ours is
called CWC vaporapi.
160:58 - It gives us this URL to use
to connect to the database.
161:02 - But here in the docs it tells you don't
ever hard code this because Heroku rotates
161:07 - through these URLs because it might change
because for whatever reason
161:12 - and because of that, we can't use
a hard coded value for anything.
161:15 - We are going to be using
a database configuration.
161:19 - So if we look at the Heroku app,
go down to Settings
161:25 - reveal config VARs.
161:27 - So we go to database VARs
and then config VARs.
161:31 - We can see the database URL
that Heroku is storing is right here.
161:35 - So this is the one that it will use.
161:37 - We need to tell our app now
to look for this value.
161:44 - Let's keep it on that and let's go
and change the code to do this.
161:51 - The next step it's telling us within
the Docs is mostly what I'm following
161:55 - along with is to add the database URL
and make a Postgres configuration
162:01 - with both of these.
162:02 - And I tried to type this code and it
does not work or did not work for me.
162:07 - So you can try to type this and deploy
again and see if that worked.
162:10 - But here is the code change that really
actually worked on my machine.
162:15 - So what we wanted to do was first
check if we have that database URL.
162:22 - So what we are doing here is
162:31 - first we are going to make a URL string
162:35 - from this database URL in the environment
variable, which will look
162:38 - for the environment variable
we saw over here in settings
162:44 - this config variable.
162:47 - And then we are going to make a Postgres
162:49 - configuration because that's
the type of database that we used.
162:52 - And then all of this will
be in this if statement.
162:55 - Otherwise we'll set it up like this,
162:58 - which is how we've done it on our
local computer and everything worked.
163:01 - So we have our Postgres configuration,
163:04 - and we also need to make something
called a TLS configuration.
163:11 - So we have made our postcard configuration
for our database,
163:14 - and we are going to configure
the database using this database URL.
163:19 - And then we make a TLS configuration
and let me double check that.
163:24 - That is right.
163:25 - Make client configuration.
Yeah.
163:29 - So we make the TLS configuration and it
163:31 - says make client config, and we set
the TLS certificate verification to none.
163:37 - I honestly don't really know what this is.
163:39 - Tls is part of like the Internet.
163:41 - It's a transport layer.
163:44 - And then we set our Postgres config
to use our TLS configuration.
163:50 - And then lastly, we do app databases use,
which is almost exactly the same as this
163:56 - rather than hard coding
everything, though.
163:58 - We are using Postgres,
164:00 - and we are using our Postgres
configuration to set everything up.
164:04 - And then this is just the name of our
database because you can have multiple
164:09 - databases within an application,
but we are only using one.
164:13 - So that's what setting
up right here is doing.
164:16 - And lastly,
we have this try auto migrate line right
164:22 - here, because when we ran our application
for the first time,
164:26 - we wanted the migrations to run and for
the app to basically not work unless
164:32 - basically make the app not
work until the migrations ran.
164:35 - But that's not what we
want to do within Heroku.
164:38 - We want it to still run,
and we only want to run these,
164:43 - like in development, and we can write
a command to run it within Heroku.
164:48 - So what we are going to do
is change this to be
164:54 - we are going to change this
to make an if statement.
164:56 - So if our app is in development mode or
development environment meaning on our
165:02 - computer, then we want
to run the migrations.
165:05 - Otherwise they won't run.
165:06 - And we are going to just run
it from the command line.
165:09 - So we've made all these changes.
165:11 - Let's commit these changes.
165:14 - So if we type get status
165:17 - if I can spell which I can't
165:20 - there we go get status.
165:22 - We see we changed our configure
method, which is correct.
165:33 - So I'm making a new message called
update config for database.
165:36 - And when I do am that allows me to add
165:40 - whatever here was ever ready to be
committed and write the message
165:45 - at the same time rather than just
writing get add and then get commit.
165:51 - So we have committed that.
165:53 - Let's go and push these changes to Heroku.
165:56 - So we type get push
165:59 - Heroku main and this will
deploy to Heroku again.
166:04 - So when I hit enter on that,
you can see it's starting to build again.
166:08 - We go to overview.
166:10 - We can see what we've
done here is we deployed.
166:14 - We created the new database,
we set up the database URL,
166:19 - and then that's just what it sort of does
automatically when we made the database.
166:23 - And then right here because we tried
166:25 - to push, you can see now it's going
and building the project again.
166:29 - So let's wait for that to build.
166:32 - After we built everything,
it has been fully deployed so we can see
166:36 - right here and then it's
deployed our new commit.
166:41 - And so if I click on this,
it'll take me to this Heroku data tab
166:45 - because I've already clicked on it
and we should be able to refresh it.
166:51 - And it doesn't look any different right
166:53 - now because we haven't ran our
migrations just yet either.
166:57 - So if we look at data clips,
166:59 - this allows us to create new queries
that we can run on our database from
167:05 - this interface, as opposed
to connecting to it from Data grip.
167:18 - If we try to do Select Star from Songs,
167:20 - it won't work because the songs
table still doesn't exist yet.
167:29 - We need to give up a title.
167:30 - And then if we click
Save and Run, I think.
167:33 - Yeah, it tells us Songs doesn't exist.
167:35 - That's because we have now,
like configured our application to run
167:40 - and use our new database URL, but we still
haven't ran the migrations themselves.
167:47 - So to do that, we need to
167:51 - use this one Heroku run, run migrate
environment production.
167:57 - So Run is by default the name right
here of what it calls our application.
168:04 - Oh no, it's in the package.
168:05 - That's where it's at.
168:07 - So here it's.
168:08 - Our app name is called App, and then
the target is called Run by default.
168:13 - So that's why it says Run run.
168:16 - So if we type this and hit enter,
Chris is going and running our migration.
168:22 - So I'm not sure if anything shows
up in this latest activity.
168:25 - I don't think it does.
168:32 - Yeah, nothing shows up there,
but we can see right here.
168:34 - Something is happening.
168:35 - It says we wanted to run our migrations
168:37 - on our new app, and then it asks us,
do we want to run this migration,
168:43 - which is app createsongs because right
here that's what we call the migration.
168:47 - So we say yes with a Y and enter and it
168:51 - tells us migration successful,
which is awesome.
168:54 - So now when we go to Data,
168:56 - which is again, we get to it by clicking
on Heroku Postgres or you could go
169:01 - to Resources and then
click on it right there.
169:05 - I just like the overview page.
169:07 - We get to this.
169:08 - And if we go here and try to run it again,
which I'm not sure why.
169:13 - It always makes you click like save
and run as opposed to just run.
169:18 - I don't know.
169:20 - I think you can just run it.
169:23 - I've always had to click save and run.
169:25 - Yeah, because it just doesn't do it
again, which is weird.
169:30 - So click save and run.
169:33 - We get back nothing because
not the database.
169:38 - The table itself exists,
169:40 - but there's no data in it yet
because we haven't added anything.
169:45 - Does that show us anything?
169:46 - No.
169:48 - So now if we go back to postman,
let's try to hit our base URL so
169:57 - we can use again.
169:58 - This is the error that showed
us originally, which is Heroku.
170:07 - We can see the logs for what's happened.
170:09 - So we'll keep that up as well.
170:12 - While that is running,
170:14 - if we go to configure two routes,
we have our two routes of it works.
170:21 - And Hello.
170:22 - So let's try to hit the base route
that has nothing and we should get back.
170:25 - It works.
170:29 - Okay, we got back.
It works.
170:31 - So we got 200.
Okay.
170:32 - It says it works, which is awesome.
170:35 - And then we see here we got back the root
170:38 - path, which is also a get request,
and it's just a flash.
170:41 - And that's the request ID.
170:45 - That's the web one and that's it.
170:47 - So it didn't show us an error,
which is amazing.
170:51 - And if we try to go to Hello, we hit this,
170:56 - we get back Hello world, because
that's what we have Typed right here.
171:01 - Now the moment of truth.
171:02 - Let's go to our slashsongs endpoint.
171:08 - So we get back an empty array,
171:10 - which is good because we don't
have anything in our database yet.
171:14 - So that's exactly what we want back.
171:16 - And we got back a 200,
which is also a good thing.
171:19 - So I have this other tab for new songs,
and what we do is let me copy this JSON
171:26 - and go back to the tab
that has the actual URL in it.
171:30 - Let's add a new body.
171:32 - I already have it here and we have a song
171:34 - just called Money, and we change the body
from none to raw and change it to JSON.
171:40 - And if we click send,
171:44 - it got back 200.
Okay.
171:45 - Which is good.
Oh, wait.
171:47 - I have to change this to post that's.
171:49 - Whysend post.
171:51 - There we go.
171:52 - So we still got back to 200,
which is a good thing.
171:56 - If we go and change this to a get request
171:58 - now and hit send, we should get
back our one row that says Money.
172:03 - So there we go.
We got that back.
172:05 - And that's the new song
that we just posted.
172:08 - So when we go to this
data clips tab again,
172:12 - I don't know why we have
to do save and run.
172:14 - I don't know where the button
is to actually just run.
172:16 - It like normal.
172:17 - I think there was a refresh somewhere
but we click save and run.
172:23 - And here we go.
172:24 - This is our table with the ID
172:26 - and the title, and we have our
one song called Money in here.
172:31 - So that is great.
172:33 - That's exactly what we want.
172:34 - So we know at least it is reading
data and we are sending data.
172:38 - So let's try to do an update.
172:40 - So if we do an update,
we need this ID number.
172:47 - No, we don't.
We just do a normal put request.
172:50 - That's what it is,
172:54 - right?
I don't remember.
172:56 - Let me look, I don't remember.
172:59 - We do a put request and we
decode the whole thing.
173:02 - Okay.
So we do need this whole object
173:06 - so it would look like this.
173:08 - But instead of money, we want to do
173:12 - how you like that?
173:16 - And we change it to put.
173:17 - And if we hit send,
173:21 - we got back 200.
Okay.
173:23 - Which is good.
173:24 - And is there a refresh button here?
173:27 - I could have sworn there was,
173:29 - but I can't find it.
173:32 - So I just had a semicolon
hit Save and Run,
173:37 - and there we go.
173:38 - Our one row in here says how you like
173:40 - that for the same ID number
as this one, which is good.
173:44 - So we were able to update
and let's add one more song to it.
173:48 - So let's just add a new song.
173:57 - We'll just add another song
called Lovesit Girls Hit Send.
174:01 - No, that's put.
Okay.
174:03 - So because I tried to do a post request or
174:05 - I meant to do a post request,
but I didn't change this.
174:08 - So it said put,
174:11 - it just came back four or four
because it couldn't find one
174:16 - right here.
174:17 - It tried to look for that song right here
from the ID, but we didn't give it any.
174:22 - So it came back for a four.
So we know that's working.
174:24 - So that's good.
174:25 - So let's change this to a post
to add this new song.
174:29 - Messed up the bracket.
That's fine.
174:32 - Click send.
174:34 - We got back 200.
So that's good.
174:36 - And if we go to our data right here,
save and run, we should have two songs.
174:44 - And then let's check delete.
174:45 - So we want to delete
by thesongid so we know the ID.
174:54 - Let's delete how you like that.
174:55 - So copy this whole ID.
174:58 - And technically, we don't need the body
here, but we could erase it or keep it.
175:03 - It kind of doesn't matter.
175:06 - We'll just keep it there.
175:07 - And then we do slash the ID number,
175:11 - the UID, and we change this
to a delete request and hit send.
175:17 - It came back 200.
So that's good.
175:19 - So now let's look at it
and click Save and run.
175:25 - And there we go.
We only have the one property.
175:27 - So we know all of our
operations are working.
175:30 - So that is a good thing.
175:32 - Lastly, we need to use this for our own
application and to do that,
175:38 - all we need to do is open our iOS app,
click Control C to close this.
175:44 - And I'm going to open the iOS app.
175:46 - So that was
175:52 - in the folder above and then
I put it right here.
175:55 - I still have it on less than four.
175:56 - So I need to make a new branch.
176:09 - So let's open our project and Xcdspace
that would open an Xcode project if you
176:16 - have like, an Xcode project file within
whatever directory that you're in.
176:21 - Okay, so we have opened our iOS project.
176:24 - Let me close postman because we don't need
it anymore because we've confirmed
176:27 - everything works and all we need to do for
our iOS app is go to the constant file.
176:34 - And instead of using our ingrocke URL, we
want to use the one for our application.
176:41 - So let's go to the Heroku app,
click on settings
176:48 - and scroll down to domains.
176:52 - We want to copy this URL
176:59 - and paste that right here and make sure
you still have one slash at the end.
177:05 - So if we do that and let's change this
from my cell phone to the simulator
177:11 - and click on Run.
177:13 - The first thing we should see is the one
song that we have called Love Sick Girls.
177:19 - So let's refresh this or run it.
177:21 - So Commandr
177:24 - and wait for my simulator to come up.
177:27 - And once our project runs,
177:30 - we see our songs Love Sick Girls
that's here, which is amazing.
177:36 - That means we successfully read from our
database that's hosted with Heroku.
177:41 - So let's edit this and change it to
Pretty Savage and click on Update.
177:51 - We see our song appears properly here,
177:53 - but we can double check by looking at
the database within Heroku Save and run,
178:00 - and now it's Pretty Savage.
178:02 - So let's go and add a new song.
178:04 - So we've tested read, we've tested update.
178:07 - Let's create a new one.
178:10 - Click on Add song.
178:14 - They have a song called Whistle.
178:15 - So let's just type that click on Add song.
178:19 - We see both of them here and double check
178:22 - again with our database
in Heroku Save and run.
178:27 - And there we go.
178:28 - We have those two songs
and let's then delete one.
178:32 - So delete Pretty Savage delete.
178:34 - We only have our one song here.
178:36 - And if we refresh our database
on this side, there we go.
178:41 - We only have one song left,
and that is it.
178:45 - We have fully deployed our Vapor API
with Heroku and our Postgres database.
178:51 - Then we use that instance
within our Swift UI iOS app.
178:54 - So during this lesson we
created a new Heroku account.
178:58 - We installed Heroku via Homebrew on our
179:01 - computer and we configured it within
the terminal to use our new account.
179:05 - We created a new Heroku app within
the website and then configured that app.
179:11 - And lastly we set up our database to use
Heroku Postgres database,
179:17 - and we ran the migrations so that our app
had our brand new table that we made.
179:22 - And finally we configured our Swift UI app
179:25 - to use our brand new Heroku
instance running up in the cloud.
179:29 - So if you liked this video series
on paper, be sure to like and subscribe
179:32 - and Let Me Know How I Did on my Very
first YouTube tutorial series.