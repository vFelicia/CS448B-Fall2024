00:00 - hello and welcome in this first lesson I
00:02 - want to answer the question what is
00:03 - Swift ey but I also want to make sure
00:06 - that you're very clear on how Swift UI
00:08 - compares with UIKit which is how we used
00:11 - to do things and how we used to build
00:13 - user interfaces before Swift UI I'm also
00:16 - going to go over the advantages of Swift
00:18 - UI and also its current limitations
00:21 - don't worry though this video isn't
00:22 - going to be all talk I'll show you
00:24 - practical examples and we'll also get
00:26 - into Xcode 11 and I'll walk you through
00:28 - how to build a demo Swift UI project so
00:32 - you can get your feet wet all right
00:33 - let's get started hi my name is Chris
00:41 - and this is the first time you're here
00:42 - welcome to code with Chris where we
00:44 - teach beginners how to make apps now
00:46 - before we dive in I have a quick
00:47 - question for you when do you find time
00:50 - for learning new things this is
00:51 - especially relevant for me right now
00:53 - because I'm spending a lot of time
00:54 - learning Swift UI and personally for me
00:57 - I find mornings to be best so let me
01:00 - know how you learn best when you find
01:02 - time to do that in the comments section
01:04 - below and if you wouldn't mind on your
01:05 - way down there please give this video a
01:07 - quick like I really really appreciate it
01:09 - it really helps with the YouTube
01:11 - algorithm and getting more eyeballs on
01:13 - this video so I really really appreciate
01:14 - it thank you so much alright with that
01:16 - said let's talk Swift UI to understand
01:19 - swift UI and fully appreciate how much
01:21 - easier it makes building user interfaces
01:24 - let's compare to how we used to build
01:26 - user interfaces with UI kit using UI kit
01:29 - we're able to use code to build the UI
01:32 - programmatically but we have to be very
01:34 - literal and precise about exactly what
01:36 - happens for example let's say we wanted
01:39 - to put a text label in the center of the
01:41 - screen here's how that would look if we
01:43 - did it programmatically with UI kit all
01:45 - right so the first thing we're going to
01:47 - do is we're gonna create a label element
01:49 - to add to the view so let's add a common
01:52 - here and I'm gonna declare a new
01:54 - constant we'll just call it label and
01:57 - we're gonna create a new UI label
01:59 - element and assign it to this constant
02:01 - next we are going to set the text to
02:04 - hello and then we're also going to set
02:07 - this property called translates our
02:10 - oversizing mask and
02:11 - constraints to false and if you're not
02:14 - sure what the auto-resize a mask is it's
02:17 - something from an old layout system
02:19 - before Auto layout that worked on
02:21 - something called struts and Springs
02:23 - where you describe which sides or edges
02:26 - the element should hug and how it should
02:29 - compact and expand depending on how much
02:32 - space there was and when Auto layout was
02:35 - introduced we then we were able to
02:37 - specify the rules which we call
02:39 - constraints on how to size and position
02:42 - things and so what it would do it it
02:44 - would try to change that Auto resize a
02:46 - mask and translate it into Auto layout
02:49 - constraints if we don't set this to
02:51 - false it's going to try to create by
02:54 - default these constraints for us which
02:57 - will interfere with the exact
02:58 - positioning and sizing that we want to
03:00 - achieve so we have to remember to set
03:02 - this to false okay so what we also have
03:06 - to do is remember to add this label to
03:10 - the actual view because if we don't the
03:13 - label is actually not visible and it's
03:16 - not in the view hierarchy so we're gonna
03:19 - say view dot add a sub view and we're
03:22 - gonna add the label and now the label is
03:24 - on the view and there is no positioning
03:28 - for it yet so it might not even be
03:30 - visible so here we got to create some
03:32 - constraints which is going to describe
03:35 - how to position this label inside of
03:37 - that view so we're going to Center it on
03:39 - the screen I'm going to create two
03:41 - constraints I'm gonna just create this
03:44 - first one and I'm going to assign it to
03:47 - a constant called center X all right so
03:50 - when you're specifying a constraint
03:52 - you're basically relating two things
03:54 - together so we're going to relate our
03:56 - label to the view and we're going to
03:59 - make them both have equal Center X's and
04:03 - that is basically centering it
04:04 - horizontally and so we want the label to
04:08 - be in the middle of the view so the
04:10 - first item is labeled the attribute that
04:13 - we want to define this constraint for is
04:17 - the center X and that's basically the
04:20 - center point of the
04:22 - we're going to relate it by equal and to
04:26 - which item we're going to relate the
04:27 - label to the route view remember so
04:29 - we're going to specify the view and we
04:32 - are going to relate it to the center X
04:34 - attribute of that view multipliers one
04:38 - and constant is zero and the multiplier
04:40 - constant just lets us exactly what they
04:44 - mean to specify either a slight offset
04:47 - with the constant or a multiple with the
04:50 - multiplier right there okay so now we've
04:52 - got to do the same thing but for the y
04:54 - axis and this is going to center it
04:56 - vertically rather than just typing all
04:59 - of that out again I'm just gonna copy
05:01 - and paste this guy and just change the
05:02 - center X to Center Y so now we're
05:05 - relating whoops moving too fast there
05:08 - now we're still relating the label right
05:12 - to the view except we're making both of
05:14 - them have the same center Y and then
05:18 - lastly don't forget to add these two
05:20 - constraints to the view and this is one
05:24 - distinction that also a lot of beginners
05:27 - have trouble with is that let me just
05:30 - finish this before I explain it so I'm
05:33 - going to add the center X and center Y
05:35 - constraints to the view now the thing
05:39 - that confuses beginners sometimes is
05:41 - that in order to position the label you
05:44 - actually have to add the constraints to
05:47 - its parent container which is the view
05:49 - because the the label is inside of the
05:51 - view right however if you're specifying
05:54 - sizing constraints for the label then
05:57 - you're going to be adding those
05:58 - constraints to the actual element so you
06:01 - would add it to the label positioning
06:04 - ones go in the parent container
06:06 - whereas sizing ones go on the actual
06:09 - element so that's one distinction that
06:10 - you have to do otherwise it's not going
06:13 - to work so let me just run this and you
06:15 - can take a look at what we get so we did
06:18 - all of that typing just to put a Hello
06:21 - label in the center of the screen and
06:23 - the other thing is that the order of
06:27 - your code statements here actually
06:29 - matter because for example in this line
06:32 - of code we added the label into the view
06:34 - but if
06:35 - took this line out let's say we forgot
06:38 - to add it all together this would crash
06:40 - because you're trying to relate to items
06:43 - like the view and the label where one of
06:46 - the elements is actually not in the view
06:48 - so you're not able to draw that
06:49 - relationship right
06:51 - also if you had remembered to add the
06:56 - label to the view but you added it down
06:58 - here again it would crash because this
07:00 - line of code right is actually applying
07:03 - the constraints and because the Train
07:06 - says looking for the label but the label
07:07 - isn't in the view so you actually have
07:10 - to make sure that the label is in the
07:12 - view up here before you try to you know
07:15 - add any sort of positioning constraints
07:18 - for that element so these are all things
07:20 - that can actually go wrong so that's
07:23 - programmatic UI and UI kit but that's
07:25 - not the only way you can build user
07:27 - interfaces with UI kit you can also use
07:29 - interface builder and storyboards and
07:31 - here's how that would look like so to
07:34 - achieve the label in the center of the
07:36 - screen using storyboards what we're
07:38 - going to first do is open up the object
07:40 - library up here and then we're going to
07:42 - search for label and then we're gonna
07:45 - drag it and drop it into our view right
07:47 - there so we've got our label on the
07:50 - screen however it's not positioned at
07:53 - all we have to add some constraints to
07:55 - it so make sure that you have your label
07:57 - highlighted and then open up this add
07:59 - constraints menu and actually we want
08:02 - this alignment constraints menu beside
08:05 - it instead you're gonna want to check
08:08 - off horizontally and vertically in
08:10 - container and then say add these two
08:12 - constraints and just like that we've got
08:14 - the label in the center of the screen
08:16 - the last thing to do is to change its
08:18 - text so highlight the label here in the
08:20 - document outline and then let's type
08:23 - hello and let's run our app and then
08:27 - we're gonna see it in the simulator with
08:30 - the label in the center of the screen
08:31 - now that might have seemed easier and
08:34 - faster versus programmatic UI but using
08:37 - storyboards brings about its own set of
08:39 - challenges I have an entire video
08:41 - comparing the programmatic UI approach
08:43 - with the storyboards approach right
08:45 - there however whether you're using
08:47 - storyboards or no
08:49 - using uikit requires you to be very
08:52 - explicit and precise about exactly what
08:55 - you want the layout system to do this is
08:57 - known as building your UI imperative lis
08:59 - this is very different from Swift UI
09:01 - which is a declarative framework now
09:04 - let's take a look at what that means
09:05 - with Swift UI you don't have to specify
09:07 - every single little detail because the
09:09 - system handles a lot of that grunt work
09:12 - for you you simply have to describe to
09:14 - the layout system what you want and
09:16 - it'll go and do that for you
09:18 - in the WWDC video describing and
09:21 - introducing Swift UI they used a great
09:24 - analogy that I still use today to
09:26 - describe the difference between Swift UI
09:28 - and UI kit UI kit is like you talking to
09:31 - a friend through the phone and giving
09:33 - him very precise and explicit
09:35 - instructions about how to make an
09:37 - avocado toast properly whereas Swift UI
09:40 - is like you telling an avocado toast
09:43 - expert what you would like and then just
09:45 - having the expert go and do it for you
09:47 - with Swift UI you don't need to worry
09:49 - about every single little detail such as
09:51 - whether or not the button is added to
09:53 - the view let's use our previous example
09:56 - about putting the label in the center of
09:57 - the screen and let's see how much easier
09:59 - it is to do with Swift UI now here what
10:03 - I've got is a default just out of the
10:06 - box Swift UI project and what we want to
10:09 - do is put a label in on the center of
10:11 - the screen however the default project
10:14 - that you get start with is already a
10:17 - label in the center of the screen so
10:19 - before we dive into how we create that
10:21 - let me just give you a quick walkthrough
10:22 - of how you create user interfaces inside
10:26 - Swift UI
10:27 - basically you're writing code on the
10:30 - left hand side here and on the right
10:31 - hand side you get a preview now you can
10:34 - also launch it in the simulator to see
10:36 - what your UI looks like but this preview
10:38 - is pretty handy so let's dive into the
10:41 - code here this text element is all you
10:46 - need to write in order to have this
10:48 - label in the center of the screen and
10:50 - just to make it the same as you know all
10:52 - of our other demos we're just gonna have
10:54 - hello so there you see it if I run the
10:58 - project you're gonna see that we get the
11:01 - same thing with our
11:02 - two demos using storyboards with UI kit
11:06 - and also programmatic UI with UI kit
11:09 - see now the notice that I didn't have to
11:12 - add any constraints I didn't have to
11:14 - tell the system to put the text in the
11:16 - middle of the screen all I indicated
11:18 - here was that I wanted a label that said
11:21 - hello and the layout system
11:23 - automatically made some assumptions of
11:26 - where I wanted to position it
11:27 - I could manually add some rules or
11:31 - specify where I wanted to position and
11:34 - maybe I want to add margin here or that
11:36 - side you know some padding or I wanted
11:39 - to push it all the way to the top of the
11:41 - screen but because I didn't specify any
11:44 - of that stuff it made an assumption that
11:47 - I wanted it in the center of the screen
11:48 - which is logical to me and that's what
11:51 - it did you see what a difference that is
11:53 - compared to UI kit so which is better
11:56 - and why would we want to use swift UI
11:58 - well let's just get one thing straight
12:00 - right off the bat apple says Swift UI is
12:03 - the future of iOS app development and
12:05 - that's that you either get on the train
12:08 - or you don't same thing happened with
12:10 - Objective C and Swift now you might
12:12 - argue that Objective C can still be used
12:15 - today but you have to agree with me when
12:17 - I say the large majority of people have
12:19 - either started with Swift or they
12:21 - converted to Swift and they love it and
12:24 - I predict the same thing is going to
12:25 - happen with Swift UI and UI kit even
12:28 - though it might take a couple of years
12:30 - luckily for us and for future iOS
12:32 - developers Swift UI does seem like the
12:35 - way to go and I'm excited to go all-in
12:37 - however there are a couple of things
12:39 - that are preventing me from doing that
12:41 - right now though
12:42 - number one Swift UI apps can only be run
12:45 - on iOS 13 and above now that is kind of
12:49 - a problem now because not everybody is
12:50 - on iOS 13 however as time goes on and
12:53 - they release iOS 14 15 16 everyone's
12:56 - going to be upgrading and this is going
12:58 - to be a non-issue another problem that
13:01 - is going to be solved by time as well is
13:04 - that right now Swift UI doesn't come
13:06 - with as many out-of-the-box controls as
13:09 - we're used to with UI kit a lot of the
13:11 - major and useful and common ones are
13:13 - there right now
13:13 - but there are also a lot of third party
13:17 - controls and libraries for uikit that
13:20 - right now just aren't available in swift
13:23 - UI this makes it hard to go all in a
13:25 - hundred percent Swift UI but luckily we
13:28 - don't have to because you can actually
13:30 - use UI kit controls on top of a swift UI
13:32 - app so I think for now that's the way to
13:36 - go
13:36 - Swift UI is still in its infancy it's
13:38 - going to take a few years for it to
13:40 - mature but there's no time like the
13:41 - present to get a head start and start
13:43 - learning it now now let's dive into
13:46 - Xcode 11 and see how you can start
13:47 - building a swift UI app all right now
13:50 - let's start a brand new Xcode 11 project
13:52 - so I can walk you through how to start a
13:55 - new swift wide project as well as some
13:57 - of the different parts of the Xcode user
14:00 - interface that has to do with working in
14:02 - Swift UI alright so let's go ahead and
14:05 - create a new Xcode project we're going
14:07 - to choose a single View application and
14:08 - what's going to matter is what you
14:11 - select down here for a user interface
14:13 - make sure it's set to Swift UI if that's
14:16 - what you want to work with or set the
14:19 - storyboard if you want to work with UI
14:20 - kit all right so let's indicate that
14:22 - this is just a test I'm just gonna call
14:25 - this with UI test you can put anything
14:28 - for these other properties make sure
14:30 - that the language is set to Swift leave
14:32 - these unchecked and go ahead and click
14:34 - Next and let's just save it so it's
14:38 - going to create that project there and
14:40 - before we dive into this content view
14:43 - that Swift let's take a look at what we
14:45 - have on the left-hand side now if you're
14:47 - coming from working with UI kit and
14:50 - storyboards and stuff like that in Xcode
14:52 - 10 or 9 then you will notice that
14:55 - instead of just an app delegate we also
14:57 - have a scene delegate now essentially
15:00 - the responsibilities that the app
15:03 - delegate was taking care of has been
15:04 - split into both an app delegate and the
15:06 - scene delegate and the reason for that
15:09 - is because with iOS 13 and now the iPads
15:12 - getting bigger there is multiple windows
15:15 - support and that means that potentially
15:17 - your app could be running multiple
15:19 - instances of itself simultaneously so
15:22 - the app delegate is still in charge of
15:24 - the overall app life
15:26 - however the scene delegate handles all
15:29 - of these different windows potentially
15:31 - you know two different windows housing
15:33 - your app simultaneously
15:35 - next up you'll notice that we have much
15:38 - of the same elements that other files I
15:42 - mean you have the asset library you have
15:43 - the launch screen you have the
15:45 - info.plist but we don't have a view
15:48 - controller anymore what we have is a
15:51 - Content view and this file is basically
15:55 - where you're going to specify your user
15:57 - interface for a single screen in your
16:01 - app so let's take a look at the code
16:03 - inside of this content view you can see
16:06 - that you kind of have two different
16:07 - struts here right and then on the
16:09 - right-hand side you should see this
16:11 - preview pane if you don't let me just
16:13 - first go through how you hide and show
16:16 - this preview pane because it's actually
16:18 - very useful so you might have something
16:20 - that looks like this where it's just the
16:22 - code editor but if you click this editor
16:26 - options button here you're gonna see
16:28 - that you can select canvas so this is
16:31 - your preview canvas it actually gives
16:33 - you a preview of what your user
16:35 - interface looks like on this side so if
16:38 - you click resume what it's going to do
16:40 - behind the scenes is it's going to
16:42 - launch a simulator it's going to compile
16:44 - that code that you have and it's going
16:46 - to show you what that preview is now
16:48 - what's really cool is that you can
16:51 - change this preview to show you what you
16:55 - need
16:55 - by default you know you get this device
16:58 - frame here and yet your UI here but
17:00 - what's actually happening is this block
17:03 - of code here called content view
17:05 - previews this code is what is generating
17:09 - the preview here on the right-hand side
17:11 - it's just for development and debugging
17:13 - purposes this code that I have
17:16 - highlighted here doesn't affect your
17:18 - production app it doesn't affect the
17:20 - functionality of your app it's just for
17:22 - generating previews here on the
17:24 - right-hand side if you wanted to see two
17:26 - of these guys you could create another
17:28 - instance of the content view and put it
17:30 - in a vertical stack or something like
17:33 - that so you can have one on top of each
17:35 - other or you can
17:36 - does device frame maybe you want to see
17:38 - it in an iPhone 6 for some reason or you
17:42 - want to see a landscape orientation you
17:44 - can add all sorts of modifiers or maybe
17:47 - you want to zoom in and you only want to
17:49 - look at a specific element on your
17:52 - screen you could do that as well
17:55 - so this chunk of code right here is to
17:58 - modify your preview on the right hand
18:01 - side this struct here this is your
18:03 - actual user interface code and you can
18:07 - see here that this class is called or
18:11 - structures called content view and it
18:13 - returns a view and then you have a body
18:15 - property that returns to some of you now
18:18 - some view just means that it could be
18:21 - any type of view because it doesn't know
18:23 - what your view is going to be but it at
18:26 - the end of the day it's still going to
18:27 - be a subclass of view and then in here
18:31 - you have your various user interface
18:34 - elements now right here we only have a
18:37 - text label but what you can actually do
18:40 - is open up the object library and you
18:43 - can as long as you're in this tab right
18:45 - here because there's a couple of
18:46 - different ones as long as you're on this
18:48 - one you can actually drag the different
18:51 - elements as code into here now we're
18:56 - going to get into different elements and
18:59 - different layout containers in the next
19:01 - lesson so for now we're not going to
19:03 - dive too deeply into these different
19:06 - elements because I just want to give you
19:08 - an overall feel of how the user
19:10 - interface looks like for Xcode 11 and
19:13 - Swift ey now you can see here that as
19:16 - soon as I change something it said that
19:19 - the automatic preview updating is paused
19:21 - so it's not reflecting automatically
19:24 - what I type here all right when it maybe
19:28 - I make a change there if it's not
19:30 - updating here on the right-hand side all
19:32 - you need to do is click resume and
19:33 - that's going to recompile the code and
19:36 - then you're going to get an updated
19:37 - preview on the right-hand side the other
19:40 - thing you can do is also preview on your
19:43 - device that's what this button down here
19:44 - is for or you can do something called a
19:47 - live preview if you click that
19:50 - this is going to be constantly
19:52 - monitoring the changes that you make on
19:53 - this side so that when you make a change
19:56 - here it slows down a little bit but it
19:59 - detects the changes and it shows you the
20:02 - live changes here on the preview pane
20:04 - without you having to go hit resume all
20:07 - the time you can see here it takes a
20:09 - while for it to happen so you might not
20:11 - want to have that on all the time
20:13 - especially if you're into a long session
20:15 - of coding before you actually want to
20:18 - generate another preview or update the
20:20 - preview now there are some other
20:23 - interesting things you can do here on
20:24 - the right-hand side of the screen so you
20:29 - can actually modify things from this
20:31 - side it's not just editing the code on
20:33 - the left-hand side for example if I hold
20:35 - down command and I click this let's just
20:38 - get out of live preview first I can stop
20:40 - that if I hold down command and I click
20:42 - this guy you can see that I can do
20:46 - different things with it and we'll get
20:48 - into what these different elements are I
20:50 - just want you to know that you can
20:52 - interact with the preview pane in order
20:55 - to modify the code on this side so
20:58 - that's pretty cool
20:59 - you can still build your UI visually at
21:02 - least a bit of it and then these
21:05 - modifiers here see I've selected that
21:08 - text element and I can change the font I
21:11 - can change alignment and I can change
21:13 - padding and when I change these things
21:15 - in this sort of visual way it actually
21:18 - changes the code right so you have an
21:21 - option of how you want to edit and build
21:25 - your UI so you know I can specify
21:28 - numbers here and you can see here it's
21:29 - changing the code now if you know if
21:32 - you're very well-versed with the Swift
21:34 - UI code and syntax and you've been
21:36 - working with it a long time obviously
21:37 - it's going to be a lot faster for you
21:39 - just to type it all out but you know
21:43 - it's it's really cool to be able to do
21:45 - it visually as well so that you can see
21:48 - how it effects the code and like you saw
21:51 - before you can actually drag these
21:53 - elements straight into the code like
21:56 - this so I think it's really really
22:00 - awesome so I hope that gave you a good
22:02 - feel for
22:04 - Xcode 11 working on a swift UI project
22:07 - and where all of the different things
22:09 - are if you have time I'd highly
22:11 - recommend you to fire up Xcode 11
22:13 - yourself start a brand new at Swift ey
22:15 - project just like we've done here and
22:16 - just fit all around in the next lesson
22:19 - I'm going to introduce you to a few more
22:21 - Swift UI elements so we can start
22:23 - building some cool layouts
22:27 - hello and welcome in this lesson I'm
22:29 - going to show you how to use a few more
22:31 - user interface controls and layout
22:32 - containers so that we can actually build
22:35 - a user interface
22:36 - all right let's dive right in so here
22:38 - I've got a basic swift UI project let's
22:41 - first go through the image element and
22:43 - this is what you use to display image
22:45 - assets in your project let's go ahead
22:48 - and add some to our asset library so go
22:50 - ahead and click that if you have your
22:52 - own images you can go ahead and add that
22:54 - if you don't check in this description
22:57 - below to grab these images which I have
22:59 - right here I'm gonna go ahead and click
23:03 - drag them all like that so it's just an
23:05 - apple a doughnut and a lemon and take
23:08 - note of the asset names all lowercase
23:10 - both doughnut and lemon because we're
23:13 - going to need to refer to these asset
23:15 - names and we're gonna change this text
23:18 - label element actually we're just going
23:20 - to erase this right now and we're gonna
23:23 - add an image element and there are a
23:26 - couple of different initializers you can
23:29 - use the one we're going to do here is
23:31 - called name and you just pass in a
23:33 - string indicating the name of the image
23:35 - asset that you want so we can do apple
23:39 - let's go ahead and hit resume there so
23:42 - that is how easy it is to display an
23:45 - image asset on the screen let's go ahead
23:47 - and change it and there you get a donut
23:52 - now let's take a look at the button
23:53 - element because you do want to add some
23:55 - user interaction to your app let's go
23:57 - ahead and delete that and let's create a
24:00 - button now this button initializer has a
24:04 - couple of parameters which you have to
24:05 - add two actually so one is action this
24:08 - block of code that you're gonna add in
24:10 - here will indicate what the button does
24:12 - when it gets tapped in the label right
24:15 - here this block of code is going to
24:18 - describe what the button looks like so
24:21 - you can put a text label in there to
24:22 - represent the button you can put an
24:24 - image or anything you'd like there so
24:27 - let's go ahead and open up the action
24:29 - and for this we're not going to go into
24:31 - how to write code for the button action
24:35 - just yet because that's going to come a
24:37 - couple of lessons later but for the
24:39 - label
24:40 - what we're gonna want to do and it
24:42 - actually just takes that it takes that
24:45 - parameter out and opens up a trailing
24:47 - closure inside this trailing closure you
24:50 - can actually put different elements that
24:52 - you'd like for example I want to put a
24:56 - text label that's one that simulator and
25:00 - then you get a button that has this text
25:03 - label as the button or you can put an
25:05 - image like let's say that donut that we
25:08 - had so let's go ahead and do that and
25:13 - you're gonna see a donut for the button
25:14 - now it's all blue its tinted blue
25:18 - because that's actually the default
25:21 - I guess tint or foreground color for
25:23 - buttons if you are going to use an image
25:26 - as a button then you actually have to
25:29 - set a rendering mode modifier here and
25:34 - we're gonna get into modifiers in the
25:35 - next lesson but right here is kind of a
25:37 - little preview of that so we're gonna
25:41 - select original and modifiers just very
25:43 - quickly is something that you can use to
25:46 - change the look behavior or the position
25:50 - the placement of the element essentially
25:52 - it modifies the element I don't want to
25:54 - get too much into it because we're going
25:55 - to cover it in the next lesson so then
25:57 - this is how you're going to use an image
25:59 - as a clickable button now you'll notice
26:02 - that every time I'm showing you an
26:04 - element I am deleting the existing one
26:07 - and adding a different one and the
26:09 - reason for that is because if you try to
26:12 - add two elements onto your user
26:17 - interface like this you try and run it
26:20 - you're going to get an error because
26:21 - this body right here it expects a single
26:25 - view back now the way you're going to
26:28 - have multiple elements in your user
26:30 - interface is that you're going to have
26:32 - to use layout containers to group these
26:34 - different elements together and have a
26:37 - single root element that satisfies this
26:41 - return type right here so let's go ahead
26:43 - and talk about our first layout
26:45 - container which is something called AV
26:47 - stack and if you used stack views before
26:50 - in UI kit this is exactly what ad stack
26:53 - is and Beast
26:54 - for vertical so let's declare a new V
26:57 - stack and actually I'm not gonna declare
27:02 - it this way I am going to create a new V
27:04 - stack object so that I can show you what
27:07 - sort of parameters you can pass in so
27:09 - for example you can pass in an alignment
27:12 - by default everything inside the V stack
27:14 - will be aligned to the center so I'm
27:18 - just gonna go ahead and hit I'm just
27:21 - going to do Center and spacing allows
27:23 - you to indicate how much space you want
27:25 - to put between all of the elements
27:27 - inside of the V stack so maybe by
27:29 - default put 10 20 and then the content
27:33 - here this closure if you open it up its
27:35 - gonna turn it into a trailing closure
27:37 - and take it out of the parameter list in
27:39 - here
27:40 - you're gonna put all the elements you
27:41 - want to stack together so I'm gonna go
27:44 - ahead and take my button and my text
27:46 - label and put them in there and then
27:49 - we're just going to wait for that to
27:51 - update so here you can see I now I can
27:54 - put multiple elements onto the view I've
27:57 - got the text element here and I've got
27:59 - the button which is a really bad button
28:02 - because you can't even tell it's a
28:03 - button but I've got two elements on the
28:06 - screen and they're stacked one on top of
28:08 - another
28:08 - and that's what the V stack helps you
28:10 - with now if you don't need to specify in
28:13 - an alignment then you can and you don't
28:15 - need to specify spacing you can go ahead
28:18 - and actually just get rid of those those
28:20 - are optional parameters and you can just
28:22 - have the stack and then you can have the
28:25 - opening curly bracket and the closing
28:27 - curly bracket and then all of your
28:29 - elements inside and you can actually
28:31 - stack more things if you'd like so the
28:34 - other one which we we talked about was
28:37 - an image right and this is going to make
28:42 - it even more confusing because now you
28:44 - can't tell which one's a button and
28:48 - which one's just an image but this is
28:51 - just for example purposes
28:52 - now another one we have another layout
28:55 - container that we have is called the H
28:57 - stack and you guess that H stands for
28:59 - horizontal so now you can see
29:01 - automatically everything is side-by-side
29:04 - and again it has the same parameter list
29:07 - you can
29:08 - align things by default to the center
29:10 - but you can align it to the top or the
29:12 - bottom and you can also specify spacing
29:15 - now one thing I do want to point out is
29:18 - that even if we specify a parameter
29:21 - let's say top and let's say the spacing
29:26 - is 20 and the content parameter we
29:29 - already have which is right here even if
29:33 - I did that you can see that the text
29:35 - label now gets aligned to the top but if
29:39 - you were expecting everything to get
29:41 - pushed up to the very top you would be
29:43 - mistaken because the height of the stack
29:46 - view or even the general size of that I
29:49 - just said stack you didn't die the H
29:52 - stack the size of that it is only as big
29:56 - as it needs to be to accommodate the
29:59 - elements inside of it it's not going to
30:00 - take up all of the space on the screen
30:03 - on its own if you wanted to do that you
30:05 - can use another element called a spacer
30:08 - and this element is simply to take up as
30:12 - much space as it can now if I wanted to
30:15 - push my each stack elements here all the
30:18 - way to the top I don't add a spacer
30:21 - inside my H stack because remember
30:24 - inside an H stack everything is
30:26 - side-by-side so my spacer would just
30:28 - simply push everything off to the left
30:31 - there if I wanted to push everything to
30:33 - the top I would actually have to put a
30:35 - spacer underneath my H stack to take up
30:38 - all of that space so the way I'm going
30:42 - to do that is I'm gonna add the spacer
30:44 - element first and it simply looks like
30:47 - that but I'm gonna get an error now
30:49 - because again now I have to route views
30:52 - right I have an H stack and I have a
30:54 - spacer and this is expecting a single
30:56 - view well the easy way to fix this is to
30:59 - wrap everything in a V stack like that
31:05 - alright so opening bracket there I
31:07 - should I'll do it this way so it's a
31:09 - little bit easier to follow and I'll cut
31:12 - all of that and put it inside my V stack
31:15 - see then everything gets pushed up
31:17 - because here we have my H stack
31:21 - right as the first element in my visa
31:23 - and then the spacer literally just
31:25 - consumes all of the space that it can
31:28 - and so my V stack now I've got it
31:30 - highlighted you can see it as this blue
31:33 - outline it takes up all of the space now
31:36 - similarly my H stack is centered it only
31:38 - goes from here to here if I wanted to
31:42 - let's say push everything to the left
31:46 - hand side I could add a spacer inside my
31:48 - H stack so let's put it to the right of
31:52 - the button and once it updates you're
31:58 - gonna see my spacer is here it takes up
32:01 - all of the space that's available and
32:03 - pushes everything to the left now one
32:07 - thing I do want to mention about the
32:08 - spacer element is that it shares the
32:10 - space with other spacer elements in the
32:13 - same layout container so let me give you
32:17 - a quick example of this I'm just gonna
32:19 - get rid of all of this first I'm gonna
32:21 - put a text element and I'm just gonna
32:23 - say hello alright so if I just update
32:28 - that you can see hello and let's say I
32:31 - wrap it in the V stack and then I put
32:37 - another hello element and let's just
32:40 - have three so you can see that my V
32:43 - stack is right there in the center of
32:45 - the screen
32:46 - it's vertically and horizontally
32:47 - centered and it's got three hello text
32:51 - elements inside there see if I add a
32:53 - spacer at the bottom what do you think
32:56 - would happen right it would take up all
32:58 - of its space thereby pushing all of
33:00 - those elements at the top what would
33:02 - happen if I add a spacer at the top here
33:06 - well this space would actually be
33:10 - divided evenly between the two spacers
33:12 - because they're both competing to take
33:14 - up all the space so they both get equal
33:16 - amounts now I can add another spacer
33:19 - here and now I have three spacers and
33:22 - you can see that the spacers actually
33:24 - consume the same amount of space so this
33:27 - one here this one here and this one here
33:30 - now if I add a fourth one they all
33:34 - consume
33:35 - equal spaces so this can be a neat way
33:38 - to Center elements and make sure that
33:42 - that they're spread out evenly and that
33:44 - things look really nice and proper now
33:46 - before I leave you with a quick exercise
33:48 - I want to show you one more layout
33:50 - container and that is the Z stack or Zed
33:52 - stack as we say here in Canada so I'm
33:55 - gonna change this v28 set and now it
33:59 - looks like all of our elements are gone
34:02 - well actually what a Zed stack does is
34:04 - that it puts elements on top of each
34:07 - other so if I change the text you're
34:10 - going to be able to see this reflected
34:13 - let's see this is the very back this is
34:17 - the middle and you can see it's 30 get
34:19 - jumbled and this is the front so you can
34:21 - see things are just laid out one on top
34:25 - of the other so this is what Zed stack
34:29 - is for it's good for putting let's say a
34:32 - background and then elements on top of a
34:34 - background right I could change this
34:36 - very back label to an image and let's
34:40 - say this week is gonna be the lemon and
34:43 - then it that way it's I feel a little
34:46 - easier to illustrate for you let's say I
34:49 - have the Apple in the middle and let's
34:51 - say I have the donut in the front so you
34:54 - can actually see that the things are
34:56 - stacked on top of each other now oh I
34:59 - forgot to change this to an image
35:01 - element there we go so the sad stack is
35:05 - really great like I said for putting an
35:07 - image as a background and then having
35:09 - elements on top or some graphic elements
35:11 - inside of your app might be comprised of
35:14 - several smaller image assets and you can
35:16 - use those adds back to stack them
35:18 - together to create the overall look and
35:20 - feel that you're looking for all right
35:22 - now that you'll know about these several
35:23 - layout containers and elements I'm gonna
35:25 - give you a quick exercise for you to try
35:27 - to achieve all right so here's the
35:30 - exercise it doesn't matter what graphic
35:32 - images you used but I want you to create
35:35 - a three by three grid with everything
35:37 - evenly spaced so you'll notice that
35:39 - every single row there is equal space in
35:43 - between each row as well as from the
35:47 - bottom of the screen and
35:48 - the top of the screen and also for each
35:50 - row every single element has equal space
35:53 - in between them here from the left edge
35:55 - between these elements right here and
35:58 - also from the right edge I highly
36:00 - encourage you to try it out it's going
36:02 - to reinforce what you learned in this
36:03 - lesson
36:04 - in the next lesson I'll show you how to
36:07 - use modifiers to well modify the
36:10 - behavior appearance and position of your
36:12 - elements
36:15 - hello and welcome in this lesson I'll
36:17 - show you how to use modifiers on your
36:19 - elements so that you can really
36:20 - fine-tune how your layout looks and
36:22 - behaves alright let's do it now here
36:25 - I've got a basic swift UI Xcode project
36:28 - with a single text element saying modify
36:31 - me I'm going to change the appearance
36:33 - behavior and layout of this text element
36:35 - to demonstrate how modifiers work now
36:38 - there are actually two different ways we
36:40 - can go about adding modifiers to this
36:42 - text element number one is by directly
36:45 - typing in the code into the code editor
36:47 - on the left hand side but number two
36:49 - which is the way that I'm going to show
36:51 - you first is to do it visually through
36:54 - the Xcode interface and the reason why
36:56 - I'm going to show you this way first is
36:58 - because by doing it visually through
37:00 - Xcode it's actually going to generate
37:02 - the code and update the code editor and
37:04 - then we can go and talk about that code
37:06 - and then later on I'll show you how to
37:08 - just type it in directly alright so what
37:11 - we're going to do here is on the
37:14 - right-hand side open up the inspector
37:16 - pane if you don't have it this button
37:18 - here oh and one thing to note is that in
37:20 - order to do it visually through Xcode
37:23 - you have to be able to see this canvas
37:26 - which means that you need to be running
37:28 - Mac OS catallena or above so if you can
37:32 - see this preview then you're gonna be
37:34 - able to do it visually if not then just
37:36 - sit back take a look at what I'm doing
37:38 - and as soon as I start doing it through
37:41 - the code by typing it out you'll be able
37:43 - to follow along as well alright so let's
37:46 - go ahead and select the text element
37:48 - here and then in the inspector pane
37:50 - under this attributes inspector you're
37:52 - going to see all of these different
37:53 - attributes that you can modify on this
37:56 - text element this is very much like
37:58 - using uikit and storyboards right
38:00 - alright so we're gonna select modify me
38:03 - this text element here first we're going
38:05 - to change the weight I'm gonna change it
38:07 - to heavy and you'll instantly see it
38:09 - reflected in the preview but also the
38:12 - code has changed in the code editor all
38:14 - right so let's just quickly take a look
38:16 - at what happened there and it actually
38:19 - put it on a second line but if I were to
38:22 - just you know close that do that
38:27 - it starts to look very familiar right it
38:29 - looks like you're calling a method on
38:31 - the text object or a text element which
38:34 - is exactly what you're doing you're
38:36 - calling this font weight method on it
38:39 - intercepts a single parameter indicating
38:41 - the actual weight and we're passing in
38:43 - heavy so that's essentially what a
38:45 - modifier is you're just calling a method
38:48 - on the Swift UI element and the reason
38:51 - they put it on the second line like that
38:53 - is because as soon as you chain together
38:57 - more and more modifiers it's going to
39:00 - get really messy if it's just in one
39:02 - line which I'll show you in a second
39:04 - and that also alludes to my second point
39:07 - is chaining together modifiers how do
39:11 - you modify this text element a bit more
39:15 - let's show the canvas and let's show the
39:19 - inspector and let's try to add another
39:22 - modifier to this element so click on
39:24 - this guy let's change the color to
39:26 - purple
39:26 - I mean she's purple there and it's
39:29 - changed the code again and you'll see it
39:31 - reflected right there but let's just
39:34 - take a look at that so you can see how
39:37 - this list is neat and tidy right I can
39:39 - clearly tell that that's a text element
39:41 - we've modified it in terms of the font
39:44 - weight and then we've called another
39:45 - modifier to change the foreground color
39:48 - if it was all in one line you can see
39:51 - what a mess that looks like it's really
39:54 - hard to make out what sort of
39:56 - modifications you've done on it right so
39:58 - that's why you should indent it right
40:02 - before the dot in this dot notation and
40:05 - then you're going to get a nice list of
40:07 - modifiers all right
40:08 - so and one thing to note is that if you
40:12 - were to do this programmatically you
40:15 - would essentially be typing it out right
40:17 - so you would instead be doing this font
40:21 - weight and then you'd put in heavy and
40:24 - you'd hit enter and then you'd go
40:26 - foreground color dot purple that's going
40:31 - to give you the exact same result I just
40:34 - wanted to show you doing it visually now
40:39 - we've
40:40 - fight the appearance of the text element
40:42 - but I alluded to modifiers being able to
40:44 - change the behavior and also the layout
40:47 - of the swift UI elements as well right
40:50 - so I'm going to show you that let's
40:52 - change the behavior of this text element
40:54 - let's let's you know what because it's
40:57 - only a single line it's kind of hard to
40:59 - see but I will centre align this text
41:01 - and it's added a modifier called
41:03 - multi-line text alignment and passed and
41:06 - centered so that's gonna if I had more
41:08 - text it would be centering that text
41:11 - maybe if I just add a little bit more
41:14 - you can see that right centering that
41:17 - text all right now in terms of changing
41:20 - the layout you know one thing you can do
41:23 - is add padding let's say you wanted to
41:25 - add some padding to the left and right
41:27 - side so there is a modifier for that
41:30 - let's do it visually first and you can
41:32 - see what the code looks like I'm going
41:34 - to enable left padding and right padding
41:37 - and you can see that the padding
41:41 - actually that's not the best example so
41:43 - why don't we just do left first so you
41:46 - can see that it's called a padding
41:49 - modifier and it's passed in the leading
41:51 - edge because that's what I want a pad
41:53 - and by default it pads it by 20 points
41:55 - so you don't need to pass in any
41:57 - parameter but if you want it to padded
41:59 - by a specific amount right let's say I
42:01 - wanted to pad it by 50 like that you can
42:04 - see that it does accept the second
42:06 - parameter indicating how much you want
42:08 - to pad it by and if you wanted to pad a
42:10 - couple of different edges you can let's
42:13 - say do the top as well and now instead
42:15 - of just passing and leading you're
42:17 - passing in an array with all of the
42:20 - edges that you want to add this 50-point
42:23 - padding to so you could see that now
42:25 - what was interesting is that when I did
42:28 - just left and right
42:30 - it changed the parameter to horizontal
42:31 - meaning I guess that's just a default
42:34 - that includes left and right all right
42:37 - so now you might be wondering you know
42:39 - modifiers are great but if the modifier
42:41 - like are these all the modifiers that I
42:43 - can add to the text element and the
42:45 - answer is no there's actually a lot of
42:48 - modifiers that you can add to a lot of
42:51 - different swift UI elements some are
42:53 - unique to the
42:54 - but some are common to all views which
42:58 - is essentially what a swift UI element
43:00 - is if you hit this drop down here you
43:02 - can just look at all of the different
43:05 - modifiers the ways that you can change
43:07 - the look the behavior in the layout of
43:10 - the element now the more you use these
43:14 - the more you're just going to know it by
43:16 - heart so if you want to do something
43:18 - with the element you're not sure how to
43:21 - do it I would look through this modifier
43:22 - list first and see if there's one that
43:25 - looks like something that you need play
43:28 - around with it and and then over time
43:30 - you will know what's available there's
43:33 - no point in trying to memorize this or
43:34 - anything like that alright so what we're
43:37 - gonna do now is I'm going to show you a
43:38 - little bit of a more practical example
43:40 - I'm gonna delete this element and I'm
43:44 - gonna add an image and we're going to
43:45 - add some modifications to it to make it
43:47 - look more like the stuff that you see in
43:50 - apps these days so let's actually before
43:52 - we delete this text element let's go
43:54 - ahead and add an image asset into our
43:56 - project now I've already got an image
43:58 - asset prepared and you can find it in
44:01 - the the resources for this project it's
44:06 - one of the welcome lessons that links to
44:08 - the folder where you can download all of
44:10 - the code and assets and stuff like that
44:12 - you're going to find this pink building
44:14 - asset under this lesson now you don't
44:16 - have to use this you can use any image
44:18 - you want there are no size restrictions
44:20 - or whatnot it's just the demonstration
44:22 - so I'm gonna go ahead and add this pink
44:25 - building to my asset library and I'm
44:27 - gonna go back to my content view now and
44:29 - I'm going to just delete the text and
44:32 - add an image element and pass in a pink
44:37 - building
44:38 - let's hit resume so we can take a look
44:41 - at the actual photo and there it is
44:45 - now this is actually a small window of
44:48 - the larger image because Swift UI
44:50 - doesn't assume that I want to fit the
44:52 - image into the view so it displays the
44:55 - image at its native size centering it
44:58 - now those are the assumptions that it's
45:00 - made but if I want it to fit the image
45:03 - into the view I can add a modifier to
45:06 - the image
45:07 - called resizable now this one you're
45:10 - probably going to be using a lot and by
45:12 - calling this modifier on an image
45:15 - element it lets the layout system know
45:17 - that you're ok with having that image
45:19 - resized now by default the aspect ratio
45:24 - is maintained so it it maintains the
45:27 - aspect ratio and it tries to fit that
45:29 - image within the view without scaling it
45:33 - but what if I wanted to let's say
45:35 - stretch this image and use it as a
45:37 - background well I can do that
45:39 - first I'm going to call another modifier
45:42 - called ignore safe area and the safe
45:47 - area just for review because you learned
45:50 - this in my beginner series and stuff
45:53 - like that is this area here this is
45:56 - called well the safe area is where you
46:00 - see the image and now the not safe area
46:02 - I guess would be all of the white parts
46:04 - and the not safe area is are basically
46:08 - places where potentially it could get
46:10 - covered or it could get blocked or there
46:12 - could be text overlaying it so you don't
46:15 - want to put elements there but for a
46:16 - background image you might want to so
46:18 - there is a modifier called ignore well
46:21 - edges ignore safe area and then you pass
46:23 - it in all the edges that you want to
46:25 - ignore the safe area for so when you do
46:28 - that it just you can see the image go
46:31 - into the safe area now now just in case
46:35 - you do want to change the aspect ratio
46:36 - I'll show you another modifier called
46:39 - you guessed it aspect ratio and the
46:43 - content mode you can set it to fill or
46:45 - fit by default it is set to fit and
46:48 - basically that means to maintain the
46:50 - aspect ratio but still fit the image
46:55 - inside the view fill will make sure it
46:58 - tries to cover all of the space while
47:00 - still trying to maintain that aspect
47:02 - ratio all right so what I actually
47:05 - wanted to do with this image though I'm
47:08 - just gonna go back here I wanted to make
47:10 - it sort of like a floating card because
47:12 - you see a lot of images like that these
47:14 - days so what I'm going to start by doing
47:17 - is just adding padding so instead of
47:20 - specifying in sets
47:21 - specify how much padding I want I'm
47:23 - simply going to be calling padding when
47:25 - you just call the padding modifier
47:28 - without passing any parameters in it
47:30 - assumes that you want padding on all of
47:32 - the edges at 20 points so that's what
47:35 - it's giving me right here and then next
47:38 - I am going to next I'm going to actually
47:42 - organize my modifier list because I'm
47:44 - going to be adding a lot they hit enter
47:46 - I'm going to add a second one and I'm
47:48 - gonna call corner radius this modifier
47:51 - will give me rounded corners and I get
47:53 - to pass in what sort of degree of
47:56 - rounding that I want now take a look at
47:59 - this I called this corner radius right
48:01 - expecting some sort of rounded corner
48:05 - but clearly it's not working and I know
48:07 - my view has been updated because there
48:10 - is no question here asking me if I want
48:13 - to resume the preview so this is the
48:15 - latest state but where are my rounded
48:17 - corners so this part is really
48:19 - interesting because the order of the
48:23 - modifiers that I have added actually
48:25 - matters and that is what the problem is
48:28 - right now you see let me rearrange this
48:32 - if I add the corner radius here and then
48:38 - I add the padding you can see that I get
48:41 - the result that I want so what's going
48:43 - on here let's let's illustrate the order
48:47 - actually matters so here I've removed
48:50 - the padding and I've applied the corner
48:52 - radius right so you get this sort of
48:54 - result and then you're adding the
48:56 - padding on top of that result all right
49:00 - and it pads it but what about the other
49:02 - way around like what we did if I did
49:05 - padding first I get that padded image
49:10 - but then when I add the corner radius
49:15 - like that it's actually applying the
49:19 - corner radius to that part right which
49:22 - essentially is just my padding so it's
49:25 - adding the corner radius to my padding
49:26 - that's why you don't see the actual
49:28 - image here having rounded corners so
49:31 - take note that the order you apply these
49:34 - modifiers
49:35 - in it actually matters so what I
49:38 - actually want to do is to do that so
49:43 - apply my corner radius first and then
49:45 - add padding to the whole thing and then
49:47 - to take it a step further I want to add
49:49 - some shadow some drop shadow to this
49:52 - image and with swift UI is really easy
49:54 - because there is a shadow modifier all I
50:01 - have to do is do that you can see a
50:03 - slight shadow being cast under my image
50:06 - is pretty diffused but there it is there
50:10 - well maybe if I didn't set the radius so
50:13 - much I would see a little bit more of it
50:14 - all right there we go
50:16 - next up I'm also going to put it in a V
50:21 - stack and let's put the text right under
50:23 - it it's gonna have my text element this
50:27 - pink building is totally amazing
50:31 - and we're gonna add some modifiers to
50:35 - this guy so much like before we had the
50:39 - heavy font weight or we're also going to
50:43 - have the foreground color and let this
50:47 - time let's choose pink and we're also
50:50 - going to set the font itself and I'm
50:56 - going to change the font to these are
51:01 - some of the presets I can do a large
51:03 - title type of text so you could do that
51:06 - and then you can do alignment multi-line
51:11 - text alignment and I can Center that and
51:14 - then lastly I can do a shadow I want to
51:17 - show you a different shadow method see
51:20 - this one where you can set the shadow
51:21 - color and you can also set you can
51:25 - control it a little bit more so you can
51:27 - control which way the shadow is going so
51:29 - I'm going to say the the color is going
51:31 - to be red the radius is going to be I'm
51:34 - gonna use a really tight radius so it
51:36 - looks like I'll show you what it looks
51:38 - like so it's not diffuse ah that's
51:41 - really hard to read okay let's just use
51:44 - black alright so it looks something like
51:46 - that so by having a really
51:49 - hi radius it's not diffused it just
51:52 - doesn't look like it's a blur shadow
51:55 - it's a really sharp shadow yeah all
52:00 - right so now that I've showed you some
52:03 - modifiers and how easy it is to use I
52:04 - have a challenge for you now if you look
52:07 - under the challenge folder in the
52:09 - resources for this lesson you're going
52:11 - to see that you have all of the assets
52:12 - that you need to try to recreate this
52:15 - layout now just to give you a hint
52:16 - you're going to need to use what you've
52:18 - learned in this lesson as well as the
52:20 - previous lessons on layout containers
52:22 - and those sorts of elements there in
52:25 - order to achieve this effect I highly
52:27 - recommend that you try it out because
52:28 - it's really going to give you that extra
52:30 - practice and solidify your understanding
52:33 - of modifiers all right in this lesson
52:35 - you'll learn that each Swift UI element
52:37 - can be configured by calling methods on
52:39 - them you can do this to change how they
52:41 - behave how they look and also how they
52:44 - are positioned in the next lesson we'll
52:47 - talk about what state properties are and
52:49 - how your UI can automatically change and
52:51 - adapt according to what the state
52:54 - properties values are all right I'll see
52:56 - you in the next lesson
52:59 - hello and welcome in this lesson I'm
53:01 - going to teach you all about state
53:03 - properties and how to use them so that
53:05 - when the values in these state
53:07 - properties change your apps user
53:09 - interface will adapt and change and
53:11 - update automatically all right let's
53:13 - dive in state is a very easy concept to
53:16 - understand essentially it's a piece of
53:18 - data that the user interface depends on
53:20 - let's say you're looking at a photo and
53:22 - this app has the ability to heart a
53:24 - photo that you like so you might have a
53:26 - state property that keeps track of
53:28 - whether this photo is hearted or not by
53:30 - the user if the state is set to false
53:33 - then the user interface will display an
53:35 - empty heart if the state is set to true
53:37 - then the UI will display a filled heart
53:40 - so let's go into Xcode now and I'll show
53:42 - you how easy it is to implement this now
53:45 - here we have the Swift UI project from
53:47 - the previous lesson and we're gonna
53:49 - build upon this to demonstrate state
53:51 - properties if you didn't build this
53:53 - project from the previous lesson not to
53:55 - worry you can find this starter project
53:57 - in the resources for this lesson however
54:00 - if you did build this project from
54:02 - lesson 3 then you can go ahead feel free
54:05 - to use yours let's describe what we're
54:07 - gonna do in terms of state properties
54:09 - here so I'm gonna put a heart button
54:12 - here between the image and the text that
54:15 - the user can tap on to toggle whether
54:17 - they like this photo or not and
54:20 - depending on that state we're gonna have
54:22 - that heart icon change to a filled heart
54:24 - or an empty heart to reflect that status
54:27 - and we're also going to have a count in
54:30 - in terms of the number of likes or
54:33 - hearts now let's start by adding the
54:37 - heart icon in between this pink building
54:39 - image and the text so here I've got my V
54:42 - stack and I'm gonna do that right here
54:44 - now rather than adding my own image
54:46 - assets for the heart we can use
54:49 - something called SF symbols without
54:51 - getting too much into it because I want
54:52 - to dive deeper into it in the next
54:54 - lesson I'll just say that SF symbols is
54:57 - a collection of icons and symbols that
55:00 - you can use it comes packaged with iOS
55:03 - 13 and
55:04 - you can just use them they're very
55:06 - helpful so let me you gotta take it at
55:08 - face value here and just copy what I do
55:10 - in the next lesson I'll dive a little
55:12 - deeper into how you use them and what
55:14 - they are and what you can do with them
55:15 - alright so you start with an image but
55:19 - we're gonna use the system name or named
55:22 - system name initializer and we're gonna
55:26 - pass in the name of the symbol so I'm
55:28 - just gonna say Hart and you're instantly
55:30 - going to see that heart icon there
55:32 - that's just part of the system I didn't
55:35 - have to add that as an asset now there's
55:37 - a different one called heart fill and
55:40 - it's essentially the same icon but
55:42 - filled in now this is just a static
55:45 - image icon right here we want to make
55:48 - this dependent on some sort of state
55:49 - right so let's go ahead and declare our
55:51 - first state property we're gonna do it
55:54 - right under this content view struck
55:56 - here before the body and the magical
55:59 - keyword we use is at capital S state and
56:02 - that's going to indicate a new state
56:05 - property use the VAR keyword just like a
56:08 - normal property and you give it a name
56:10 - I'm gonna call this is hearted and I'm
56:13 - going to set it to false now one thing
56:16 - that you want to do it's a recommended
56:18 - practice is actually to make it a
56:20 - private property and the reason for this
56:23 - is because state properties are really
56:25 - meant to describe the state of this
56:28 - particular view which is content view if
56:31 - you have a piece of data or a property
56:34 - which you want multiple views to depend
56:37 - on there are other mechanisms to do that
56:40 - that wouldn't be using a state property
56:42 - so we can get into those later on in the
56:45 - series but for now we're looking at
56:48 - state properties and the reason why we
56:50 - make it private is just to reinforce the
56:53 - fact that it's only accessible by
56:55 - content view and that's what happens
56:57 - when you use this private key word
56:59 - access modifier so that's why we put
57:03 - private there just to reinforce that all
57:06 - right so what were we doing here okay so
57:08 - we've declared our state property is
57:10 - hearted and we're gonna make it this
57:12 - icon depend on that very simply we're
57:15 - just going to use an if
57:16 - it is hearted you know it's true then
57:20 - we're gonna display this heart let's see
57:24 - what happens here because it is set to
57:25 - false so this is not going to trigger if
57:29 - you hit resume you'll see that it
57:35 - disappears because this is false so it's
57:39 - not gonna happen have this image element
57:41 - here but if I add an else clause and I
57:46 - show an empty heart instead when that is
57:54 - false then we're gonna see an empty
57:59 - heart right because this state is false
58:02 - right so it's going into this branch and
58:05 - showing this so let me set this to true
58:07 - and resume it and it is filled in now
58:16 - that's not too amazing alright because
58:18 - I'm manually changing the stay here
58:20 - through code it's basically just
58:23 - toggling between these two branches of
58:25 - the if statement but however let's say
58:28 - we change that heart into a button I'm
58:31 - going to declare a new button so let's
58:33 - go ahead and do that and for the action
58:38 - we are going to toggle the is hearted
58:41 - property when you call the toggle method
58:47 - in case you haven't used this it just
58:48 - toggles it between true or false so it
58:51 - changes that state now for the label
58:54 - here I'm gonna get rid of this and for
58:58 - the label of the button it's just going
59:01 - to be this code right here so the the
59:04 - actual image of the button is going to
59:06 - depend on the state all right so now let
59:10 - me just run this project so that we can
59:12 - play around with it in the simulator
59:15 - another thing you can do is actually use
59:17 - the live preview but I'm already
59:19 - building it right there
59:24 - all right so we've got our UI here it is
59:26 - hearted if I tap on it it toggles the
59:29 - state property is harder to false and
59:32 - this image of the button is going to
59:35 - change by itself see I didn't have to
59:39 - manually tell the button to change its
59:41 - image all I had to do was toggle the
59:44 - state hit it again it toggles the state
59:49 - and the image of the button changes
59:51 - automatically now this is one
59:54 - illustration of using state as a boolean
59:58 - but state can also be an integer it can
60:02 - it can be anything so I'm going to show
60:05 - you another an example of a state and
60:09 - I'm gonna call this num hearts I'm gonna
60:14 - make this 999 and I'll set this back to
60:19 - false okay so the now we're using state
60:23 - as an integer and so what I want to do
60:26 - is show the count beside the heart and
60:31 - we're gonna do here is we're gonna
60:33 - declare a horizontal stack I'm gonna put
60:37 - the button inside of it and then we're
60:41 - also going to have the count so I'm
60:43 - gonna have a text which is going to be
60:46 - the num hearts the problem is that num
60:51 - hearts is an integer and in order to
60:53 - display it inside a text element I'm
60:55 - gonna have to convert it to a string so
60:57 - let's go ahead and create a string from
61:00 - that and I'm gonna hit resume and we
61:05 - should see the label right beside it all
61:09 - right let me just try running this
61:11 - project all right so I've got nine nine
61:16 - nine nothing happens
61:18 - obviously because we haven't added the
61:20 - code yet but what if I add the code to
61:23 - increase or decrease the count
61:25 - whenever I toggle it so I'm going to
61:28 - change that code right here so when I
61:30 - toggle it I'm gonna add some additional
61:33 - code I'm and it's starting to look
61:35 - pretty messy so actually I'm
61:36 - just gonna reinvent everything I'm gonna
61:38 - select everything go into editor go into
61:41 - structure and hit re indent if you
61:44 - didn't know about this this is the
61:45 - shortcut key or the menu item tap on
61:47 - that is just going to make everything
61:49 - nice and tidy for you all right now
61:51 - we're going to say you know if self is
61:54 - hearted then we are going to say num
61:58 - hearts is plus equal one it's going to
62:01 - add one to the number of hearts else
62:05 - we're gonna minus one and the reason for
62:09 - that is because you are unharmed so
62:14 - you're removing you're removing a vote
62:20 - essentially so let me run this project
62:25 - again in the simulator alright so when I
62:31 - tap on this now it's actually going to
62:33 - toggle this to true and it's going to
62:36 - increase that number of hearts to a
62:39 - thousand and we're gonna see that this
62:42 - text increases automatically in UIKit in
62:46 - order to do this I would have had to set
62:50 - the text property of this label to a
62:55 - thousand you know to the updated camp
62:57 - but in Swift UI because we're using
62:59 - state properties all I need to do is
63:01 - update the property and all of the
63:04 - pieces of the UI that depend on those
63:06 - property that are listening to changes
63:09 - for those properties they just update
63:11 - themselves automatically that's how
63:13 - great and easy that is to do now I have
63:16 - a challenge for you guys and that is to
63:19 - change this text down here if the image
63:23 - is hearted then I want you to just have
63:26 - this amazing text that we have here but
63:29 - if it is not hearted that I want you to
63:32 - use some basic text or some very sad
63:35 - pathetic looking text use some small
63:37 - font or something like that but if it's
63:40 - hearted then we're gonna make this bold
63:42 - pink and amazing like I think this is
63:45 - pretty pink bold and amazing but you can
63:46 - make it even more
63:47 - if you'd like just to get some extra
63:49 - practice in with using state properties
63:53 - so in this lesson you'll learn all about
63:55 - state properties and how you can have
63:56 - your user interface update automatically
63:59 - when the values change in the next
64:01 - lesson I'll show you what sf symbols are
64:03 - and some of the cool things that you can
64:05 - do with them
64:05 - thanks for watching and I'll see you in
64:07 - the next lesson
64:10 - hello and welcome in this lesson we're
64:12 - going to talk about SF symbols a large
64:14 - collection of system icons that you can
64:16 - use in your iOS 13 apps not only are
64:20 - they very handy they also come with a
64:22 - lot of additional benefits which I'll
64:24 - demonstrate for you in this video all
64:26 - right stay tuned
64:27 - so here I have a basic swift UI Xcode
64:31 - project and all I have is an H stack
64:34 - with an image and text element inside of
64:36 - it
64:36 - the text says like and the image is one
64:40 - of a heart now keep in mind that I don't
64:42 - actually have an image asset of a heart
64:45 - in my asset library in this project
64:47 - instead I'm using the SF symbols icon
64:51 - framework which I alluded to in the
64:53 - previous lesson so let's take a look at
64:55 - the Apple human interface guidelines I'm
64:58 - just going to pull that up right here
64:59 - and take a look at what exactly are
65:01 - these symbols so SF symbols are a set of
65:05 - 1500 icons and symbols that you can use
65:08 - in your iOS 13 apps now Apple design
65:12 - these symbols to play really nicely with
65:14 - the San Francisco system font if you're
65:17 - unfamiliar with what this font is it's
65:20 - essentially the default font that you
65:22 - use in your app so if you're not using
65:23 - any sort of custom font then you are
65:26 - using the San Francisco font and as you
65:28 - can see using an SF symbol alongside
65:31 - that font looks really neat and tidy
65:33 - everything's aligned and arranged nicely
65:35 - whereas if you had supplied your own
65:38 - heart image you might have to play
65:40 - around with the sizing and alignment
65:42 - just to get it to look in line with the
65:44 - text so the other thing that is a huge
65:48 - benefit to using SF symbols is that it
65:51 - behaves like a font as you can see here
65:54 - for each of these symbols there are
65:56 - different weights like ultra light thin
65:58 - light regular all the way to black
65:59 - there's different like line thicknesses
66:02 - and sizes as well and these symbols are
66:06 - vector based which means that no matter
66:08 - how large or small you scale them
66:11 - they're going to be really sharp and the
66:13 - fidelity is going to be consistent just
66:16 - like the font so let me go back into
66:18 - Xcode and demonstrate for you
66:20 - so you can visibly see some of those
66:22 - benefits
66:23 - I'm talking about so for example if I
66:25 - want to change the the font that I have
66:28 - and I want to add a font modifier maybe
66:30 - I want to do a large title type of font
66:33 - as you can see it changes the text
66:35 - element as I expected but it also
66:37 - changed that image element that SF
66:41 - symbol had I used my own supplied image
66:44 - graphic that wouldn't have done anything
66:47 - this modifier I mean or let's say I want
66:51 - red font red text if I change the
66:57 - foreground color to red that affects my
66:59 - SF symbol as well so that's really nice
67:02 - and then for my next demonstration let
67:05 - me just remove this red color because I
67:07 - mean you're going to be able to see a
67:09 - lot more clearly and then I'm going to
67:12 - run this app in the simulator let me
67:15 - just bring that over here and I'm not
67:19 - sure if you knew about this in Xcode 11
67:22 - but there is a menu that you can bring
67:24 - up by clicking this button called
67:25 - environment overrides and this allows
67:29 - you to test your UI and test your app
67:31 - under different device specific
67:34 - conditions so things like whether or not
67:36 - the user is using dark mode or light
67:38 - mode what kind of dynamic type
67:42 - magnification are they using maybe they
67:44 - can't see the text very well so they
67:46 - have upped the magnification or the font
67:49 - size and also these different
67:51 - accessibility options you can see how
67:54 - your app plays nicely or not so nicely
67:57 - with them turned on so why don't we go
67:59 - ahead and try to turn on dark mode oops
68:02 - there we go now as you can see the text
68:06 - element changed to white because
68:08 - obviously black text on a dark mode you
68:11 - wouldn't be able to read it but what I
68:12 - didn't expect was that the SF symbol
68:15 - also turned light if you were to use
68:18 - your own supplied image or graphic asset
68:21 - you would have had to supply to one for
68:24 - the light mode and one for dark mode and
68:25 - then there's a way for you to configure
68:27 - it inside the asset library to tell the
68:30 - system which version to use for a dark
68:33 - mode and which version to use for light
68:34 - mode but if you're using an SF
68:36 - symbolize we're using here you don't
68:38 - have to specify any of that because it
68:40 - behaves like a font so you kind of get
68:42 - this for free which is really nice the
68:44 - next thing is that you have dynamic type
68:47 - so some people might have this huge
68:50 - magnification on to make sure that they
68:52 - can read the text your SF symbol scales
68:55 - with that so you can see that with an
68:58 - image not so much and then same thing
69:02 - with these accessibility options
69:03 - anything that you would expect to happen
69:05 - to your font you know your symbol will
69:07 - also play nicely with that so that is
69:10 - awesome and there are 1500 of these
69:13 - symbols for you to use and if that
69:15 - weren't enough Apple has said that you
69:18 - can actually export these symbols and
69:20 - customize them to your own so let me
69:23 - show you where we can browse these
69:25 - symbols and how you can export one to
69:27 - configure it or to modify it to your
69:30 - needs and to your liking so here is a
69:33 - link to the SF symbols app I've got it
69:36 - open right here actually it's a Mac OS
69:37 - app which allows you to browse all of
69:41 - the different symbols that are available
69:43 - in this framework and you can also
69:46 - choose the waiting and stuff like that
69:48 - and it's it's a nice way to browse all
69:51 - of the icons essentially and the way you
69:53 - use them is you take note of this name
69:55 - and all you have to do is specify this
69:58 - name let's say this one Mike dot circle
70:01 - dot fill and use the system name
70:04 - initializer for the image element and
70:06 - just pass that in hello is that again
70:09 - Mike Haddad circle dot fill and let's
70:12 - take a look at that alright so there you
70:19 - go that's how easy it is to use if you
70:22 - wanted to export one of these icons and
70:24 - use them as a template to build off of
70:26 - you can also do that so just highlight
70:30 - the one that you want let's say Mike go
70:32 - up to edit
70:32 - sorry file and export custom symbol
70:36 - template the shortcut key is command E
70:38 - so when you do that it's going to
70:41 - produce an SVG file for you which is a
70:44 - standard vector-based graphics file then
70:48 - you can save it somewhere
70:49 - and you can import that into your
70:51 - favorite vector-based graphics software
70:54 - such as adobe illustrator or sketch or
70:57 - what I like to use figma because it's
70:59 - free to use and get started with so
71:01 - that's what I'm going to show you here I
71:03 - have figma open I'm just going to drag
71:06 - and drop that Mike SVG file into here
71:09 - and then you can see all of the
71:12 - different weights so it might be hard to
71:15 - read for you here there's thin all the
71:18 - way light regular medium semi bold bold
71:20 - and then there's different sizes as well
71:23 - here and then down here in the lower
71:26 - left-hand corner there are some
71:28 - instructions and some some guides and
71:35 - that's how you can customize these well
71:38 - this is granted if you know how to work
71:40 - with vectors and to edit vectors right
71:44 - so that is another learning curve but
71:46 - for let's say a designer that knows how
71:48 - to create their own icons and modify
71:51 - vectors then this would be great for
71:55 - them now there are a set of icons that
71:59 - Apple has said you should not touch and
72:01 - you should use as is so if we go back to
72:03 - the human interface guidelines and you
72:06 - scroll down these symbols are for use as
72:08 - is and these symbols mostly have to do
72:10 - with Apple brands so they are they don't
72:15 - want you to tamper with brand logos or
72:18 - brand iconography which is
72:19 - understandable so you have things like
72:21 - airplay AR KITT iCloud FaceTime face ID
72:26 - stuff like that for these symbols you
72:28 - want to use them as they are for
72:30 - anything else it's fair game for you to
72:32 - export modify customize to your liking
72:36 - and use now before we enough this video
72:39 - there are a couple of resources I do
72:40 - want to mention that might make your
72:42 - life easier so this one is called SF
72:46 - symbols calm it's not by Apple it's made
72:49 - by a developer named Noah and it's a
72:52 - very easy way for you to find an icon
72:55 - that you need in case you don't have the
72:57 - mac app installed and let me just show
73:00 - you how that works so let's say
73:02 - I'm searching for that that looks like
73:06 - or sounds like the one that I need copy
73:08 - it and then simply paste it in here and
73:13 - just like that very easy so this is very
73:17 - handy there's another article from a
73:22 - Vanderley on SF symbols that helped me
73:24 - out when I was learning this and this is
73:26 - very handy to go through if you'd like
73:29 - to do that so yeah I would highly
73:31 - recommend that you use SF symbols where
73:33 - you can especially for places like
73:35 - beside button text or in buttons in menu
73:38 - buttons even in tab bars those are all
73:42 - great places to use sf symbols but keep
73:45 - in mind that the use of SS symbols there
73:47 - are some restrictions and maybe I should
73:50 - have mentioned this up front but it says
73:53 - here that you can't use SF symbols in
73:57 - your app icons logos or any other
74:01 - trademark related use however I think
74:04 - using them inside of your app is fair
74:06 - game so in this lesson you'll learn all
74:09 - about SF symbols and how you can
74:11 - incorporate them into your app in the
74:13 - next lesson we're going to start
74:14 - building our first swift UI app together
74:16 - a slot machine alright thanks for
74:18 - watching and I'll see you in the next
74:20 - lesson
74:23 - hello and welcome in today's video
74:25 - you'll use everything you've learned
74:27 - about so if you Y up to this point to
74:29 - build this Lots app believe it or not by
74:32 - the end of this video you'll have this
74:33 - app up and running all right let's do
74:35 - this alright guys here we go this is so
74:38 - exciting let's start our brand new Xcode
74:41 - project here and we're going to choose
74:44 - single View application and for the
74:47 - product name I'm gonna just call it a
74:49 - slots demo you can follow the rest of
74:52 - these settings but just make sure that
74:54 - your language is set to Swift and your
74:56 - user interface most importantly is set
74:58 - to Swift UI because that's why we're
75:00 - here
75:01 - you cannot be the rest of the settings
75:03 - as I have it here and let me just choose
75:06 - a place to save this I'm just going to
75:07 - save it on my desktop along with all of
75:09 - the other folders the billion folders
75:12 - that I have I also took a screenshot and
75:16 - while that's kind of starting up I want
75:20 - to talk about how this UI is constructed
75:22 - so the screenshot I took of the finished
75:25 - product and what's happening here you
75:27 - might think that this is a graphic
75:30 - background but it's actually not and I
75:32 - just noticed that this is kind of cut
75:34 - off here what's actually happening back
75:36 - there are two rectangles one obviously
75:39 - covers the whole screen that's the
75:42 - deeper yellow and then there's another
75:43 - rectangle on top of a lighter yellow
75:45 - that is rotated on an angle so the only
75:49 - graphic images in this app are these
75:52 - Apple icons and the cherry icons and the
75:54 - star icons
75:55 - this is actually an SF symbol which you
75:58 - learned about previously and those are
76:01 - yeah these are the only images these
76:04 - slots icons so why don't we start by
76:08 - adding those icons to our image assets
76:11 - I'm just gonna leave this screenshot
76:12 - right here so we can take a look at it
76:15 - when we need to so if you check in the
76:18 - description below this video you'll find
76:20 - the image assets that you can download
76:22 - so let's go ahead into the asset library
76:25 - and just go ahead and drag all of them
76:28 - there now I'm gonna actually rename some
76:30 - of these to cherry and
76:36 - star alright and next let's go into the
76:41 - content view and start building out our
76:44 - UI and let me describe to you kind of
76:49 - the main layout containers that we have
76:51 - so in order to have elements stack one
76:54 - on top of each other we use a said stack
76:57 - or a Z stack as you might call it so
77:00 - that's how we're getting the two
77:02 - rectangles for the background stacking
77:04 - on top of each other and then on top of
77:06 - that background we have a V stack which
77:09 - contains all of our main user interface
77:12 - elements so in that V stack we have this
77:16 - title which is essentially just an H
77:19 - stack a horizontal stack with an SF
77:23 - symbol text label and then another SF
77:26 - symbol and then this is a text label
77:30 - with just a rounded background color and
77:33 - here we have an H stack with three
77:36 - images and then finally we have a button
77:39 - down here and that all of those elements
77:41 - I just described are in a V stack
77:43 - sitting on top of the background so why
77:47 - don't we go and construct that so I mean
77:49 - I get rid of this text label right here
77:53 - and I'm going to create a stack I'm
77:58 - gonna call it as that stack whether you
78:01 - this is I'm Canadian in case you didn't
78:04 - know so I'm gonna create a rectangle
78:06 - right there let's that doesn't have any
78:08 - color we probably won't even see it so
78:11 - why don't we there we go
78:13 - I had a foreground color now for the
78:15 - actual color I am gonna create a new
78:20 - color and I'm going to specify the red
78:23 - green in the blue because I did this in
78:25 - figma where I picked a specific color
78:29 - and then you can kind of see the
78:30 - red-green-blue breakdown and so I'm
78:32 - gonna specify those values but I can't
78:34 - remember it off the top of my head but I
78:35 - have them written here so for red I have
78:39 - 200 for green I had 143 and for blue I
78:45 - had 32
78:48 - so there we go there's our rectangle and
78:51 - we also want it to go to all the edges
78:55 - ignoring the safe area right so I'm
78:58 - going to say edges ignoring safe area
79:00 - and I'm gonna pass in all because I want
79:04 - it in all directions so there we go we
79:06 - have our first background now let's add
79:09 - a comment here first and I'm not really
79:16 - not liking the way that that's looking
79:19 - so just looks ok let me just go up here
79:23 - a structure and read and dent everything
79:27 - like that so it looks neat and tidy so
79:30 - let's do another rectangle and this one
79:34 - is going to be again the foreground
79:37 - color this one I also have a specific
79:40 - color so I'm gonna specify that and for
79:45 - this one the red is 2 to 8 the green is
79:50 - 195 and the blue is the 76 all right and
80:03 - I'm going to rotate it rotation effect
80:08 - and I'm gonna specify an angle so let
80:13 - create a new angle object and pass in 45
80:18 - and then I'm going to specify ignore
80:23 - edges so it goes all the way to the end
80:28 - there we go
80:32 - all right so that's our background now
80:35 - we have our V stack right our main V
80:39 - stack that contains all the elements
80:41 - sitting on top of that background so as
80:43 - I described here in the first element in
80:48 - the side that V stack that is actually
80:50 - an H stack containing the star the text
80:54 - and another star so let's go and add our
80:57 - H stack here and I'm just going to add a
81:02 - title and then this is going to be like
81:07 - credits counter alright so let's do this
81:11 - first H stack what do we have we have an
81:14 - image and inside we actually have an SF
81:20 - symbol so let's fire up the SF symbols
81:25 - app and what I want to do a star so this
81:32 - is the one I chose star dot fill and so
81:34 - I'm going to close that and we're gonna
81:36 - use that star dot fill and it's blocked
81:39 - by default but I decide to set a
81:44 - foreground color of yellow so there's
81:47 - that image it's small now but we're
81:49 - gonna make it a little bigger in a
81:50 - second all right so I'm gonna copy this
81:52 - and paste it and in between there I'm
81:55 - gonna put a text label so this guy just
81:59 - said Swift UI slots now I made this fun
82:05 - bold so let me just see exactly yeah I
82:09 - did font weight of bold and foreground
82:11 - color of white so I used font weight and
82:15 - I passed it in bold but you can actually
82:18 - maybe just call bold like that
82:20 - that's cool foreground color and then
82:23 - let's do white
82:25 - so I guess bold has its own modifier but
82:29 - you could also do it like this where you
82:33 - pass in a font weight and then you can
82:34 - choose bold there's a couple more
82:35 - options here but I wonder if like heavy
82:37 - and black and light have their own
82:39 - modifiers too let's just double check
82:44 - light i guess cuz bold is so common that
82:48 - has its own modifier whereas if you
82:51 - wanted to use black or heavy or light or
82:52 - the other font weights you're gonna have
82:54 - to use the font weight modifier and pass
82:56 - in that specific one alright that's cool
82:59 - and then in order to make it bigger I
83:02 - added a scale effect of two alright so
83:10 - now it's looking a little bear it's in
83:11 - the center which is fine as we add more
83:13 - elements into our V stack that's it's
83:16 - gonna space out and then we're gonna
83:17 - take a look at adjusting all the spacing
83:20 - at the end let's just focus on adding
83:22 - all of our elements so the credits
83:24 - counter that's this guy right here so
83:26 - that was just another text label and for
83:30 - now we can just hard code this text here
83:34 - and we're going to make this an actual
83:38 - property or state property later so for
83:42 - this text I set the foreground color to
83:44 - black and I also set a background color
83:50 - now this background color I set to white
83:54 - but I also added a slight opacity to it
83:58 - so I actually only have to just take a
84:01 - look at what we've got here okay so
84:05 - we've got the white background okay and
84:07 - then I set an opacity on this of 0.5 and
84:14 - you see how closely it's hugging the
84:16 - text let me just zoom in a little bit
84:18 - like that so what you can do is you can
84:21 - add padding but here here's a good point
84:25 - to illustrate the order of how things go
84:29 - so I'm going to say all edges use the
84:33 - padding modifier and I'm gonna give it a
84:35 - padding of 10 so you can see that you
84:38 - know this blue outline is my text label
84:40 - and it indeed added padding but the
84:42 - background itself is still pretty small
84:45 - so what I needed to do instead is first
84:48 - apply the padding and then apply the
84:50 - background color to the whole thing and
84:52 - if I change the order like that you'll
84:54 - see that then I get the desired effect
84:56 - and then finally I added a corner radius
84:59 - of 20 and that's gonna give me that look
85:04 - right there like that all right next up
85:07 - is the main course here the three cards
85:12 - so I'm going to this was an H stack
85:20 - horizontal stack containing three images
85:22 - so we've got the first image and again
85:26 - I'm just going to hard-code the image
85:28 - here so we've got our first image here
85:31 - I'm gonna add the resizable modifier so
85:34 - I can resize this and I've shown you
85:36 - this in previous lessons in this Swift
85:39 - dy series before I'm also going to make
85:42 - sure that the aspect ratio is 1 and for
85:47 - the content mode I want it to fit
85:49 - instead of fill so it's really big now
85:52 - but we're going to add a couple more so
85:55 - let's add a background again I'm going
85:59 - to add a white background with a slight
86:01 - opacity 0.5 and finally I'm going to
86:06 - round the corner 20 so we get a sort of
86:10 - card like effect now let me just indent
86:14 - all of these things being very careful
86:17 - [Music]
86:19 - oops that was yeah there we go
86:41 - just want to make sure that that looks
86:43 - right there we go
86:46 - all right so we've got our image there
86:50 - and I'm gonna just copy and paste this
86:52 - so I need to mention here that in swift
86:57 - UI one of the guiding principles for
86:59 - view composition is actually breaking
87:02 - down elements into smaller reusable
87:05 - views and so I'm not gonna do this in
87:08 - this video because I just want to get
87:10 - this up and running in the next lesson
87:13 - I'm gonna show you and explain some of
87:15 - the guiding principles the one I just
87:18 - mentioned about view building and
87:19 - breaking down your views into reusable
87:21 - views as well as how dataflow is
87:24 - supposed to work in the swift UI and
87:25 - then we're going to come back to this
87:27 - slots app and we are going to apply
87:29 - those principles and improve the code
87:31 - refactor the code so right now I'm just
87:33 - going to copy and paste this three times
87:34 - just to make things really really simple
87:38 - so we can actually finish this app in
87:40 - one video now I'm going to add a spacer
87:42 - on the left and right of this H stack so
87:46 - that it's gonna create some space there
87:48 - and I could put spacers in between these
87:51 - images as well but it looks like you
87:54 - know they're together and I on a water
87:57 - screen I don't want them you know to fly
87:59 - apart because the spacers will take up
88:01 - an equal amount of space instead I'll
88:04 - just have margins on the left and right
88:07 - but keeping the three cards together
88:10 - okay so we've got our cards here and
88:12 - what's left is this button so we've got
88:16 - our cards this is the H stack and this
88:19 - is the button so let's create a button
88:21 - element here so we've got our button and
88:26 - where's my autocomplete there we go so
88:31 - we've got action and we've got the label
88:33 - so for the action I am actually going to
88:37 - just not fill that out yet for the label
88:40 - that's going to be a textile
88:43 - so I mean just the button I'm just gonna
88:45 - put to do and then here the actual
88:49 - visual representation of the button is a
88:51 - text field that says spin and let's add
88:54 - some styling to that so we've got bold
88:57 - and we've got a foreground color of
89:01 - white this is double check
89:04 - yeah with white and we have this pink we
89:07 - have a background color of pink
89:15 - I think the pink yeah okay and again I'm
89:21 - gonna add some padding to it but we got
89:23 - to do it before we set the background so
89:26 - you're gonna add some padding to all
89:29 - edges with the ten so see if it can
89:35 - actually reflect that all right I might
89:39 - have messed that up but let's take a
89:45 - look look let's actually run this in the
89:46 - simulator and see if the bill failed I
89:50 - might actually have to do something in
89:53 - here okay
90:01 - I think I messed up my let me just get
90:09 - rid of that button I think I messed up
90:10 - my curly brackets so you know it's
90:14 - actually launching all right so that
90:21 - looks good let's put our button back all
90:26 - right up here let's declare some stuff
90:32 - so we have accredits right private VAR
90:41 - credits equals a thousand so we can
90:45 - start off with that and I do want this
90:47 - to be a state property because we're
90:49 - going to be deducting credits and I
90:51 - wanted to appear automatically so in
90:55 - here I'm gonna erase that hard-coded
90:58 - text and I'm going to put credits and I
91:02 - do have to convert it to a string
91:04 - because this is an int all right you see
91:08 - that so I'm going to do that right there
91:11 - and now I just want to see if I can say
91:15 - self dot credits plus equal one just
91:19 - want to put some code in there and see
91:22 - if that's what was missing oh sorry it's
91:29 - this it's this right here background I
91:32 - have to specify that it's a color pink
91:34 - because this expects a color already but
91:37 - the background expects any this could be
91:39 - anything you could be putting an image
91:41 - in there or anything so I guess I have
91:42 - to specify it like that alright so going
91:45 - back to customizing our button here
91:48 - first so we have a padding of ten right
91:54 - here and then we set a background but to
91:56 - me it doesn't really look like
91:58 - let me just update this UI there we go
92:02 - that's what I expected
92:03 - now I wanted to add some extra padding
92:06 - to the left and right so after I added
92:08 - padding of ten to all sides I'm going to
92:11 - specify padding again but this time
92:15 - I'm going to specify eight just the left
92:18 - and the right like trailing and leading
92:20 - so let me specify an array and I'm gonna
92:23 - put leading in there comma trailing and
92:26 - the length of that is gonna be 30 so
92:29 - that's gonna be give me a bigger button
92:30 - and then I'm going to set the corner
92:33 - radius to 20 again so that gives me that
92:39 - look
92:39 - now we probably want to add our spacers
92:42 - now because we have all of our elements
92:44 - so I'm going to add a spacer in between
92:47 - here and between here and in between
92:49 - here and also probably at the top in the
92:53 - bottom space right there at the bottom
93:00 - got a spacer in between the button and
93:02 - there got a spacer in between the cards
93:05 - and the credit counter and then another
93:07 - spacer between the credits counter in
93:09 - the title and then I could put a spacer
93:13 - there as well so there in this app I
93:16 - actually used padding instead of a
93:18 - spacer up here but right now on the whim
93:23 - I'm deciding to use that it's just fun
93:27 - okay cool so now all we have left to do
93:31 - is when they hit spin we're gonna write
93:34 - the code here to change the images but
93:37 - there are a couple of steps we have to
93:39 - do before this because here we
93:41 - hard-coded the images right so we're not
93:44 - going to be able to change them unless
93:46 - we make them state properties as well so
93:50 - let's first start by declaring an array
93:52 - of the different asset names so I have
93:56 - private of our symbols equals we have
94:01 - Apple we have star and we have cherry
94:06 - and the second of all this is going to
94:09 - actually be a state property we're gonna
94:11 - have an array containing or representing
94:18 - the data representing which icon these
94:24 - these reels took so you know this could
94:29 - be from 0 to 2 right so 0 would be Apple
94:32 - one would be star and 2 would be cherry
94:36 - so this array this numbers array
94:39 - represents the state of what symbols
94:42 - these guys are so what we're going to do
94:44 - is when the user hits spin we're going
94:47 - to randomize a number from the between 0
94:50 - to 2 representing one of these symbols
94:52 - and we're going to place it into you
94:56 - know these slots are representing these
94:57 - three cards here and for the images for
95:01 - the image elements here right instead of
95:04 - specifying Apple what we're going to
95:06 - specify is the symbol array right
95:11 - symbols and inside we're gonna specify
95:18 - since this is the first image this would
95:21 - represent alright let me just type this
95:27 - out first numbers okay so this is the
95:33 - first image right so numbers 0 is is the
95:39 - the value that represents that cart
95:42 - right this is going to be index 1 and
95:45 - this will be index this guy's going to
95:47 - be index to this guy's gonna be index 1
95:49 - and this one's gonna be index 0 so
95:52 - essentially instead of doing that we are
95:57 - going to
96:04 - do that okay so hopefully this makes
96:12 - sense to you so for example right now
96:15 - it's still showing apples because you
96:18 - know the numbers are all zeroes but
96:19 - let's say we randomized it and we get
96:21 - one for this we get two for that and we
96:23 - get zero for that so if we resume it
96:26 - again now you're gonna see them
96:28 - different the reason for this is because
96:32 - this one is reading one so it's gonna
96:35 - grab that symbol and this one is two so
96:41 - that's going to be zero one and two so
96:43 - it's gonna grab that image and finally
96:45 - at that position we still have zero and
96:47 - zero at that index we get the Apple
96:49 - image so that's what we're going to do
96:52 - here so inside the button action we're
96:56 - gonna randomize a different number for
96:59 - each of these indexes in the numbers
97:02 - array so we're gonna do self-thought
97:05 - numbers 0 is equal to int dot random and
97:12 - where's my autocomplete there we go
97:14 - so we're gonna randomized between 0 to
97:18 - the number of symbols that we have minus
97:22 - 1 and that's going to give us 0 to 2 all
97:34 - right we're gonna do the same thing for
97:40 - number one and number two so even just
97:46 - doing this we can go ahead and run our
97:49 - app and take a look at these guys are
97:53 - randomizing because we should be able to
97:56 - see our UI update automatically remember
98:02 - that number says a state property right
98:04 - so when we're changing these indexes the
98:06 - value inside these indexes the UI is
98:09 - going to see that change and it's going
98:11 - to automatically update what image those
98:16 - image elements are displaying okay next
98:19 - up change the images we're going to
98:27 - check check winnings and let's declare
98:34 - another one up here another property
98:37 - here for the bet amount and we'll say
98:40 - five each time they spin we'll take away
98:42 - five credits and if they win if they get
98:46 - a match we're going to give them let's
98:51 - say ten times their bet so here we're
98:55 - going to check winnings and all we have
98:56 - to do here is just say if you know self
99:00 - thought numbers zero is the same thing
99:04 - as numbers one and self thought numbers
99:10 - you know if the second one is equal to
99:13 - the third one then all of them are
99:17 - essentially the same one so we can say
99:24 - self dot credits equals plus equals that
99:29 - amount times ten
99:35 - else self-thought credits
99:40 - - equal vet amount - oops I forgot the
99:47 - self keyword there as well all right so
99:51 - let's take a look and see if this works
99:56 - yeah so we can see it deducting here and
100:01 - when we can finally get a match this is
100:07 - why you shouldn't gamble oh there we go
100:14 - I don't even know I guess we could add a
100:18 - label to just say what the status is but
100:21 - this is where I'm going to leave things
100:23 - here because we have a working slots app
100:26 - in the next video we're gonna talk about
100:29 - some of the core guiding principles in
100:31 - Swift UI and then we're going to come
100:33 - back and improve this app so in this
100:35 - single video you built a working Swift
100:37 - UI app isn't that amazing however I did
100:40 - mention that there are improvements that
100:42 - we could make to this app structurally
100:43 - to enable us to build upon it and take
100:46 - it even further in future videos in the
100:49 - next lesson I'll tell you about two of
100:50 - the most important guiding principles
100:52 - when it comes to Swift UI regarding data
100:55 - flow and view composition after that
100:57 - we're gonna come back to the slots app
100:59 - and make those structural improvements
101:01 - that I talked about thanks for watching
101:03 - and I'll see you in the next lesson
101:06 - hello and welcome let's talk about two
101:09 - very important principles in swift UI
101:11 - data flow and view composition let's
101:15 - start with views so what is a view a
101:17 - view defines a piece of UI there are
101:20 - kind of like the basic building blocks
101:22 - and just like Lego you want to build a
101:25 - bigger view out of smaller single
101:28 - purpose views this makes it easier to
101:30 - understand and easier to maintain over
101:32 - time as well so let's use an example to
101:35 - illustrate let's say you have a view
101:37 - that represents a color picker and it
101:39 - looks something like this and because
101:41 - you know that it's a best practice to
101:43 - break down a view into reusable parts
101:45 - you decide to create a smaller view that
101:47 - represents the slider now you can reuse
101:50 - that slider view three times in your
101:52 - color picker view pretty easy to
101:54 - understand right it's all about reuse
101:56 - let's talk about dataflow now now if you
101:59 - came from working with UI kit you might
102:02 - have noticed that we don't have a view
102:03 - controller anymore to understand why
102:05 - there's no view controller in Swift UI
102:07 - let's take a look at what the view
102:09 - controller was used for with UI kit the
102:12 - view controller managed the data flow
102:14 - between your model and your view it was
102:16 - responsible for updating your UI
102:18 - whenever the data in your model changed
102:20 - for example let's say you have a
102:22 - contacts app and once the data model
102:25 - finishes loading the contacts the view
102:27 - controller takes the data and
102:28 - manipulates the UI to show the data
102:30 - conversely the view controller was also
102:32 - responsible for handling user
102:34 - interaction in the view and changing the
102:36 - data based on those interactions using
102:39 - the same example let's say that the user
102:40 - deletes a contact from the UI then the
102:43 - view controller would have to let the
102:44 - data model know to remove that contact
102:47 - this is the way we've been used to doing
102:49 - things but there's a lot of code that
102:51 - you have to write in order to make all
102:53 - of this happen so in Swift UI things are
102:56 - a lot easier for us the view controller
102:58 - is removed and instead of having to
102:59 - write all this code to manage the data
103:02 - flow instead we bind the data in our
103:04 - model directly to our UI we don't have
103:07 - to write any code to do this and this
103:08 - way whenever the data in the model
103:10 - changes the UI will notice and update
103:13 - itself accordingly this diagram from
103:15 - WWDC shows clearly how the data flow in
103:19 - Swift UI works
103:20 - now let's say the user makes a change
103:22 - from the UI for example delete the
103:24 - contact because your view is written in
103:26 - code you can have code in your view that
103:29 - handles that user interaction and goes
103:31 - to update the data in your model to
103:33 - remove that contact the UI will notice
103:36 - that the data has changed and will
103:37 - update itself automatically so this loop
103:40 - eliminates a lot of the coding that we
103:42 - had to do previously inside the view
103:44 - controller the next question is how does
103:46 - Swift UI achieve this sort of data flow
103:49 - that we see in this diagram without a
103:51 - view controller
103:52 - well Swift UI has several different ways
103:55 - for now I want to talk about state and
103:58 - binding and when you should use each of
104:00 - them you've already seen what a state
104:03 - property is in previous lessons you can
104:05 - bind the state property to a piece of UI
104:07 - and have the UI update itself
104:09 - automatically as the data in that state
104:11 - property changes but how does this work
104:14 - if we try to break up the view as a
104:17 - composition of smaller views after all
104:19 - that's one of the guiding principles we
104:21 - talked about in the first part of this
104:23 - lesson so let's use our color picker
104:26 - example from earlier
104:28 - let me quickly point out what data these
104:31 - views need in order to display the UI
104:34 - the color picker has the color square
104:36 - and in order for us to display that we
104:39 - need to know that different amounts of
104:40 - red blue and green however each of our
104:43 - three slider views also needs to know
104:45 - the amount of red blue and green
104:47 - respectively now let's take a look at
104:49 - this view in code form so that we can
104:52 - clearly see where to put the state
104:54 - properties and bindings to make the data
104:56 - power the UI since you've only learned
104:59 - about state properties let's use that
105:01 - for everything we said the color picker
105:03 - view needs to know the amounts of red
105:05 - green and blue so we'll have state
105:07 - properties there then each slider View
105:09 - also needs to know their own amount of
105:12 - red green and blue so we'll have a state
105:14 - property in the slider view this state
105:17 - property will be bound to the slider
105:19 - element and text label so if the user
105:22 - uses the slider it'll update the value
105:24 - in the state property which results in
105:26 - the text label being updated there's a
105:29 - problem with this picture though since
105:30 - each slider view is tracking its own
105:32 - color value independent
105:34 - we've essentially duplicated the data
105:36 - and we're now tracking the value of each
105:39 - color in two places furthermore how is
105:42 - the color picker going to know about the
105:44 - data changes in the slider views because
105:47 - it has a color square that it needs to
105:49 - update
105:49 - so this is where bindings really come in
105:52 - handy we can have a binding that reads
105:54 - and writes to and from a state property
105:56 - and then we can pass that binding into a
105:58 - subview for them to use let me
106:00 - demonstrate
106:01 - so here I've got the color picker view
106:03 - project and we're going to break it down
106:06 - into smaller views and I'm also going to
106:08 - show you how to use bindings as well so
106:12 - just to quickly run this for you so you
106:14 - get an idea of how it works we have
106:17 - three sliders you can adjust the levels
106:20 - of red green and blue and as you can see
106:24 - from here there's a V stack there's a
106:26 - rectangle representing the color square
106:30 - and then we have three sliders also take
106:32 - note that we have three state properties
106:35 - up here representing the amount of red
106:37 - green and blue and the rectangle his
106:41 - foreground color is is reading from
106:43 - those state properties red green and
106:46 - blue and so are the sliders the sliders
106:49 - are bound to red green and blue and
106:50 - that's why adjusting them affects the
106:52 - state property which affects the
106:54 - foreground color now if we were to
106:56 - follow that first principle we talked
106:58 - about in terms of view composition
107:00 - looking at these three sliders they look
107:02 - very similar they would be a perfect
107:04 - control to abstract into a smaller view
107:08 - right so that's exactly what we're going
107:10 - to do right here let's stop this and
107:12 - then we're going to create a new file
107:14 - and we're gonna choose UI swift UI view
107:20 - and I'm just gonna call this a slider
107:23 - view so it starts off with a text field
107:27 - sort of text element and we're gonna go
107:30 - back to content view and I'm just gonna
107:32 - take one of these sliders I'm gonna copy
107:35 - it and I am going to paste it in there
107:39 - now because this used to be inside a big
107:43 - view stack or V stack it's no longer
107:47 - inside Avista
107:48 - so we have to and declare a V stack
107:53 - there and we'll put the slider and the
107:55 - text element inside furthermore we no
107:58 - longer have this binding and this label
108:01 - needs to be dynamic as well if we're
108:03 - gonna reuse this slider element so up
108:06 - here I'm going to declare first of all a
108:09 - a text property actually a string
108:13 - property and I'm going to actually I'm
108:17 - not going to initialize it because I
108:18 - want the the color picker view the past
108:21 - in the text to use so instead I'm just
108:23 - gonna call it label I'm gonna make it a
108:25 - string and I'm gonna leave it
108:28 - uninitialized and then for the text here
108:31 - we are going to insert that label
108:35 - property now as for the binding for the
108:39 - value what we're going to do is use the
108:42 - at binding property wrapper and we are
108:46 - going to declare it as far let's call it
108:50 - value and the type is double now in here
108:57 - in the slider I can bind to I can pass
109:01 - in that binding value right and then in
109:05 - here instead of showing red we're gonna
109:08 - show value as a number now these two are
109:12 - going to get passed in when we create
109:14 - instances of the slider view in the
109:17 - color picker as you'll soon see
109:18 - but first let's fix one thing in here
109:21 - this is the preview we can't see
109:24 - anything on the right here because it's
109:26 - missing initialization parameters so
109:29 - let's go ahead and do that so that's
109:32 - what we have to pass it and we have to
109:33 - pass in a binding and we have to pass in
109:36 - a label which is just the string now you
109:39 - since we don't really have a binding to
109:41 - pass in right here what we can do is we
109:44 - can do binding dot constant and just
109:49 - pass that in as a constant value it's
109:52 - not a real binding per se but for the
109:56 - purpose of this preview it works
109:58 - brilliantly so for the label I'm just
110:01 - going to call
110:01 - label and then let's hit resume here
110:04 - let's see if we can preview something
110:06 - there we go so there is our label and it
110:12 - reaches all the way to the edges we're
110:14 - not going to add padding to this V stack
110:16 - here because inside the content view in
110:18 - this bigger V stack we already have
110:20 - padding as you can see here on the left
110:22 - and right so just to make it look
110:25 - prettier in the preview I'm going to add
110:27 - the padding to the preview so this
110:29 - doesn't affect the actual app it's just
110:32 - so that we can see an accurate
110:35 - representation of what that looks like
110:37 - and now we can go back to the picker
110:41 - view and instead of having these slider
110:44 - and text elements we can remove it and
110:47 - replace it with our new a specialized
110:51 - view so there's our slider view and we
110:54 - have the pass in a binding and a label
110:56 - so for the binding that's what we want
110:58 - to pass in a binding to that state
111:00 - property so we're gonna use the dollar
111:04 - sign read and the label is just gonna be
111:07 - read right and we're gonna copy that and
111:10 - replace this slider and instead this is
111:12 - going to be dollar sign green and this
111:15 - is going to be green as well and then as
111:17 - you can see it's actually changing it in
111:20 - the preview this is going to be blue and
111:25 - this is going to be blue as well so now
111:29 - let's run our project and just make sure
111:33 - everything is connected and it works so
111:35 - as you can see there's red there's green
111:38 - and there's blue not just like that
111:40 - you've seen a demonstration of us
111:42 - breaking down a more complex view into
111:44 - smaller reusable views as we've done
111:47 - here and you've also seen an example of
111:50 - using bindings you see the color picker
111:53 - view that we have here owns the state
111:57 - properties for red green and blue so
112:00 - it's the source of truth and we are
112:01 - passing in a binding to those state
112:04 - properties into our slider view so that
112:06 - the slider view can both read and write
112:08 - to the state properties up here as you
112:12 - can see a binding provides two-way
112:14 - communication
112:15 - the slider view can read the value of
112:17 - the state property in the color picker
112:19 - view and it can also manipulate the
112:21 - value of that state property through the
112:23 - binding but a key difference is that the
112:25 - color picker owns the data because the
112:28 - state property is declared in the color
112:29 - picker view we're no longer keeping two
112:32 - copies of the same data the color picker
112:34 - view is the source of truth when it
112:36 - comes to the values of red blue and
112:38 - green and you'll hear this term a lot in
112:41 - swift UI source of truth it refers to
112:44 - who owns the data because you want to
112:46 - avoid two views both having state
112:48 - properties representing the same data
112:50 - instead you should think about who
112:53 - should actually own the data aka the
112:55 - source of truth and have the other views
112:57 - use bindings instead in the next lesson
113:00 - we're going to apply these principles to
113:02 - our slots app all right I'll see you
113:04 - there
113:06 - hey code crew in the last Swift ey
113:09 - lesson you learned about composing
113:10 - complex views using smaller single
113:13 - purpose views and you also learned about
113:15 - data flow using state and binding
113:17 - properties well in this video we're
113:20 - gonna take a look at the slots app that
113:21 - we built and we're gonna see how we can
113:23 - apply these two principles to improve
113:26 - that app alright let's dive in so here
113:29 - we have the slots UI app that we built
113:31 - together a couple of lessons ago and
113:33 - again if you've missed that lesson you
113:36 - can definitely check out the playlist in
113:38 - the link in the description below to
113:40 - follow the series from the start alright
113:43 - so the first thing we're gonna take a
113:44 - look at is what makes sense to break out
113:47 - into its smaller single purpose view and
113:50 - what I like to look for is anything that
113:54 - I tend to have to repeat in the UI so if
113:57 - you've got the same sort of button in a
114:00 - couple of different places or maybe the
114:02 - same type of image element like we do
114:05 - here I mean rather than having this code
114:08 - repeated three times like we have right
114:10 - now we can abstract that card out into
114:13 - its own card view you know its own
114:15 - single purpose of view and then create
114:18 - three instances of that instead just
114:20 - like in the last lesson when we talked
114:22 - about the color sliders so here you can
114:25 - see the code for these three cards we've
114:27 - got these three images they're virtually
114:29 - the same code except for you know what
114:34 - icon gets displayed but we can always
114:36 - use the what we learn about dataflow
114:40 - right you state properties and bindings
114:42 - and pass that data in and the other
114:45 - thing that's good about abstracting this
114:48 - into its a single view is that you know
114:50 - if I wanted to change the look and feel
114:51 - of the cards you can see this code is
114:53 - repeated three times if I wanted to
114:55 - change the corner radius or the
114:58 - background color a little bit I'd have
115:00 - to change it three times but if I
115:03 - abstracted out into a single card view
115:05 - and then just use it three times then I
115:07 - only have to change at one place so it
115:09 - makes maintenance easier so let's go
115:11 - ahead and just do that first before we
115:13 - even talk about dataflow so right click
115:16 - here I'm going to add a new file
115:19 - and under iOS or under user interface
115:21 - we're gonna choose Swift UI view and I'm
115:25 - gonna call this the card view because
115:27 - that kind of makes sense I'm just gonna
115:30 - move this guy up here and by default you
115:33 - get that text label saying hello world
115:35 - but we don't need that we're gonna go
115:38 - into the content view again and I'm
115:40 - there really just gonna copy this guy
115:43 - and I'm gonna paste it into here at the
115:46 - body this piece of data we don't have
115:51 - inside this card view so I'm just gonna
115:54 - hard code an image name for now just so
115:57 - we can see something on the right hand
115:59 - side so that's great
116:01 - this lets me know that this is working
116:04 - right and this preview is simply
116:08 - creating an instance of the card view
116:11 - and that's what we see so we'll take
116:13 - that and we'll go back here and I'm
116:17 - going to first remove this one let's do
116:20 - a little test and let's declare a new
116:22 - card view element here you can see that
116:25 - changed I'm gonna do the same thing
116:28 - removing that middle card and same for
116:34 - the last one and that you know just like
116:41 - that we have created a smaller single
116:44 - purpose view in the car view and we've
116:47 - composed we've used it to compose this
116:50 - kind of like bigger more complex view
116:52 - now for this simple swift UI slots app
116:56 - that that is the thing that makes sense
116:59 - to abstract out into its view if we were
117:01 - to you know reuse these other elements
117:04 - in different places if it were a more
117:06 - complex app then there are probably more
117:10 - components that I could pull out and
117:11 - make into smaller views but as it stands
117:14 - now I think that's all that makes sense
117:18 - now we run into the next problem which
117:21 - is that these cart views have a
117:24 - hard-coded Apple icon in the cards so we
117:29 - need to somehow be able to change
117:32 - icons now the consideration for the data
117:35 - flow comes into play so who should be
117:38 - the source of truth for these icons here
117:42 - just to remind you about how they get
117:44 - displayed you know we have a we have an
117:47 - ax right here called symbols and there's
117:50 - an apple star and cherry these represent
117:52 - the possible icon choices or the image
117:55 - names and we have another array called
117:59 - numbers which indicates which icon that
118:03 - card slot should be so this first index
118:07 - of the numbers array represents this
118:10 - card the middle one represents that card
118:13 - and the last index represents that card
118:15 - so depending on what number this is it's
118:19 - gonna kind of result in a different icon
118:22 - here remember in the last lesson we
118:24 - talked about source of truth you know
118:26 - the state properties so we definitely do
118:30 - not want to keep a copy of the numbers
118:33 - here in the content view and keep a copy
118:37 - of you know what individual index this
118:42 - card is also in the card view because
118:45 - that would be duplicating the data right
118:47 - and so it makes sense for me that the
118:51 - content view should be the source of
118:53 - truth and that it should be passing the
118:56 - bindings to these numbers to the card
118:59 - views itself because number one the
119:02 - content view has the logic to check for
119:04 - matches right after they hit the spin
119:07 - button we have some code right here just
119:12 - to check if the numbers you know if this
119:15 - one matches this one and if this one
119:16 - matches this one if we made the card
119:19 - view instead kind of hold its own number
119:23 - right if we had a state here and we said
119:29 - you know we made it hold its own number
119:33 - it would make it harder for us to be
119:36 - able to match to see if this card
119:38 - matches the others so that's why
119:42 - at least my thinking is that right here
119:47 - the content view should be the source of
119:48 - truth of this data and instead we should
119:50 - pass the bindings into the card views so
119:53 - that's what I'm going to try to do here
119:55 - let's hop into our card view and take a
119:58 - look at what we can do so this is the
120:01 - hard-coded string that represents the
120:03 - image so I'm going to create a binding
120:06 - for it so that it can be passed into the
120:09 - card view when it gets created instead
120:11 - of having a hard-coded string there so
120:16 - I'm gonna say binding we're going to say
120:20 - let's just call it symbol it's gonna be
120:24 - of type string I'm not gonna set it to
120:28 - anything because I want it to be passed
120:30 - in and then here instead of hard-coding
120:33 - the string I'm just gonna put symbol and
120:37 - now this preview is broken because you
120:41 - can see here you can't just create a
120:44 - card view element and expect it to be
120:46 - displayed because it needs to know which
120:50 - symbol to display right and it is
120:53 - expecting a binding to be passed in so
120:56 - if you just get rid of those parentheses
120:58 - or brackets you can see that you're
121:01 - supposed to pass in a string type
121:04 - binding so unfortunately we don't have
121:06 - any real binding to pass in to this
121:11 - preview right here but what we can do is
121:14 - pass in a temporary binding value to
121:18 - just for the purpose of the preview so
121:20 - that it can display something so the way
121:23 - you do that is you go binding dot
121:26 - constant and then you can specify a
121:29 - value so it's got to be a string so
121:32 - let's let's do cherry so then it's still
121:37 - gonna allow you to you know pass this in
121:40 - as a parameter but it's not a real
121:42 - binding you know it's just a constant
121:45 - value
121:48 - so unfortunately it's not building right
121:51 - now let's just take a look at why here
121:53 - card view type is not convertible ah
121:55 - yeah so back in the content view all of
121:59 - these are broken now as well so why
122:03 - don't I just do the same thing just so
122:05 - we can just do one thing at a time so
122:09 - let me just show you that this this
122:12 - works now we can actually see something
122:15 - before we actually use real bindings yes
122:22 - okay so there is the parameter label
122:26 - right there okay so if we go back to the
122:30 - card view now and we try to update the
122:34 - preview you can see that we see cherry
122:36 - because that's what we put right here
122:38 - all right now let's go back to the
122:40 - content view and take a look at how
122:43 - we're gonna pass in the bindings for the
122:46 - symbols alright so up here my numbers
122:56 - this is already a state property I'm
122:59 - going to change this to a state property
123:01 - as well now I'm gonna go down and
123:04 - instead of passing in a binding constant
123:08 - for a cherry right here I can pass in a
123:11 - real binding from the state properties
123:13 - up there that we declared up there so we
123:17 - have symbols and then inside here I had
123:22 - I think I called a number right so this
123:25 - would be zero all right let's just see
123:28 - if that is okay before before I do
123:32 - anything
123:33 - Oh numbers okay so it would help if I
123:36 - could remember my property names all
123:40 - right so we're gonna do the same thing
123:41 - here as well numbers 1 and this would be
123:48 - symbols
123:50 - numbers - okay so let's resume build
123:55 - succeeded and you can see that this
123:58 - reflects the indexes that we have right
124:01 - here in numbers and if I build and run
124:05 - this that I forget anything
124:08 - let's take a look alright so you can see
124:18 - everything is working perfectly here and
124:20 - we've successfully abstracted the card
124:24 - view into its own single purpose smaller
124:26 - view and we've facilitated the data flow
124:30 - where the content view is the source of
124:33 - truth for the symbols and what indexes
124:35 - those cards should be and then passing
124:40 - that into the card view element as the
124:43 - binding alright now I want to solve
124:45 - another issue here which is that it's
124:47 - really hard to detect when there is a
124:49 - match like we just had if you can't you
124:52 - can't even see it unless you notice your
124:54 - credits going up but the same time
124:56 - they're going down so it's always
124:57 - changing and this was just really hard
124:59 - to tell when you get a match and so what
125:02 - I'd like to do is change the backgrounds
125:04 - to green when there is a match and this
125:07 - is going to give us another opportunity
125:09 - to practice using state properties and
125:11 - bindings so I'm gonna create a state
125:15 - property up here for the three
125:17 - background colors for the cards just
125:19 - like we have here that represents you
125:21 - know which icons they are and then we're
125:23 - going to pass that as a binding into the
125:25 - card view here and have the background
125:29 - change when there is a match all right
125:32 - so first let's declare a new state
125:34 - property here I'm gonna call it
125:39 - backgrounds
125:42 - so I'm gonna default them to all white
125:45 - and all three slots and then let's go
125:49 - into the card view and add a binding so
125:51 - instead of just using white by default
125:54 - we're going to have that value as a
125:58 - binding and this is gonna be of type
126:03 - color and again I'm not going to assign
126:05 - anything to it here so that we are going
126:07 - to be forced to pass it in when we
126:09 - create the card view element and don't
126:11 - forget instead of hard-coding
126:14 - white we're gonna use the binding
126:17 - alright so here this preview is broken
126:20 - because now we have to pass in an extra
126:21 - binding so let's go ahead and just hit
126:23 - fix so it adds that label for us and
126:26 - then we're gonna do a binding constant
126:30 - well this is gonna be a color so let's
126:34 - just say green we'll save it and I'm
126:39 - pretty sure this preview is actually
126:42 - broken yeah because the project is
126:45 - broken right now don't forget we just
126:46 - added another binding and inside content
126:51 - view we create these three cards these
126:54 - are not valid instantiations of card
126:56 - view anymore so it expects say another
127:00 - another binding to be passed in all
127:03 - right so let's add that parameter here
127:05 - and we're gonna pass in the background
127:08 - color so backgrounds zero right this is
127:13 - a binding for the state property that we
127:17 - have up here so that's where that's
127:19 - coming from and we're gonna do the same
127:22 - thing with the second card view
127:25 - let's have that parameter and then
127:28 - backgrounds one this time
127:35 - backgrounds - okay so now everything's
127:42 - set up if we run the project now it's
127:44 - gonna be fine but however the
127:46 - backgrounds aren't going to change
127:47 - because we actually don't have any code
127:49 - to update the backgrounds state property
127:52 - so we have to update that when there is
127:54 - a match and we have to don't forget we
127:57 - have to set it back to white when the
128:00 - user spins again so right here they won
128:06 - so we're gonna update the state property
128:08 - update backgrounds to green so we're
128:14 - gonna say self-thought backgrounds
128:19 - equals color green we're going to do
128:22 - this for all three and I'm going to show
128:25 - you another way of writing these three
128:27 - statements using a map function and just
128:32 - in a second but let me just do it this
128:33 - way first that might be something you do
128:36 - know or something you don't know but
128:38 - it'll be helpful set backgrounds back to
128:45 - white here because this is where the
128:48 - user hits the spin button before we
128:51 - actually spin anything all right so we
128:56 - have when the user taps on the button we
128:59 - set it to white and then if there is a
129:01 - match we update it to green so let's run
129:05 - this project and watch our code take
129:09 - effect so it's white did you see that
129:15 - there we go so that's pretty cool
129:18 - so now let's talk about that map
129:20 - function I mentioned so the map function
129:22 - is something that you can do with a race
129:25 - when you want to do something with every
129:28 - single element of the array and it's a
129:29 - more concise way of writing it rather
129:32 - than repeating yourself three times like
129:34 - this and imagine if we had even more
129:36 - backgrounds like nine backgrounds or
129:39 - something like that then this would be
129:40 - nine lines of code so here is just
129:43 - another way to write this in case you
129:44 - don't know about the map
129:46 - function and I don't think I've really
129:47 - ever taught it in any of my other videos
129:49 - just yet
129:50 - so here's how it goes so it is a
129:53 - function that you can use with an array
129:55 - so you go dot map right and you pass in
129:59 - a closure and this is the code that you
130:03 - want to run on every single element of
130:05 - your right so you can see that there is
130:10 - this is the element this parameter here
130:14 - represents the element that is currently
130:17 - in that array slot or you know this is
130:19 - the element that you're transforming
130:21 - because we don't want to transform the
130:23 - color white like we're not gonna do
130:26 - anything with that color instead we want
130:27 - to replace it right we want to assign
130:29 - something new into that slot so we
130:31 - actually don't need this parameter so
130:33 - we're just going to replace this with an
130:37 - underscore and as for the code we simply
130:41 - write color dot white and that is
130:45 - essentially going to replace whatever
130:48 - was there and look the result of the
130:51 - call to map is unused because this
130:54 - function basically returns a new copy of
130:57 - your rate does it modify your old one so
131:00 - what we're going to do is we're going to
131:02 - assign it back to self dot backgrounds
131:04 - just create a little more space here
131:08 - there we go and so this although it's
131:14 - still three lines is a little more
131:16 - concise than writing this a little more
131:18 - elegant but I do want you to keep in
131:20 - mind that this is perfectly fine this
131:23 - really comes in handy when you have many
131:26 - elements in an array so I'm just gonna
131:29 - show you what it would look like we did
131:32 - it like this right you could do this
131:35 - with the color green down here and then
131:40 - if you're really observant you can also
131:43 - notice that we are running the same
131:46 - operation on every single element in the
131:49 - numbers array as well so we can use a
131:52 - map here so self dot numbers equals self
131:57 - dot numbers dot map
131:59 - alright let's open up that closure again
132:02 - it's gonna give me the integer currently
132:06 - which is the element in that in that
132:10 - slot we don't need it so we're gonna put
132:12 - underscore because we are assigning and
132:16 - we're just gonna run this code right
132:18 - here and it's basically basically going
132:23 - to run this code for every element in
132:25 - the array and assign it to that slot so
132:30 - get rid of this and that's that's an
132:33 - even bigger savings right like that made
132:36 - the code a lot more concise but the
132:38 - thing is for a lot of the beginners who
132:41 - are watching this I don't want to start
132:42 - doing this too much because it's kind of
132:45 - hard to know what's going on if you are
132:48 - just starting out and my primary focus
132:51 - is making sure that you understand the
132:53 - code and you can follow along in terms
132:55 - of the logic and understanding and so
132:57 - you know if if it's a lot of extra work
133:01 - like if there were nine elements and I'm
133:02 - doing the same thing to every element
133:04 - that maybe I'll I'll just mention and
133:06 - use the map again but for this I'm
133:08 - simply gonna do it the simplified not so
133:14 - not so concise way just so anybody who
133:20 - is reading this no matter kind of what
133:22 - the level even if you're just starting
133:23 - out can easily understand what we're
133:26 - doing however now you know that this map
133:28 - function exists you can add it as a tool
133:31 - to your arsenal for your Swift
133:33 - development oh yeah our slots app is
133:36 - progressing really nicely and if you're
133:38 - up for it I actually have a challenge
133:40 - for you can you add two more rows one to
133:43 - the top and one to the bottom for a
133:45 - total of nine cards and make it so that
133:48 - matches can occur horizontally on all
133:50 - three rows and also diagonally and for
133:54 - extra bonus points can you add a second
133:57 - spin button so that the user can either
133:59 - tap one of them that only checks the
134:02 - middle row for matches in the second
134:04 - button which costs five times as more
134:07 - credits or whatever amount you want but
134:09 - that second button checks for
134:11 - just on all three rows plus the
134:13 - diagonals so it's gonna cost more it's
134:15 - higher risk but a higher reward oh and I
134:18 - forgot one quick tip for the challenge
134:20 - that is actually quite crucial so in any
134:24 - of these containers like Zed stack or Z
134:27 - stack V stack or H stack any of these
134:31 - containers they can only contain a
134:33 - maximum of ten elements inside but don't
134:36 - worry you can nest it so let me just
134:38 - give you a quick example inside of this
134:41 - V stack we have a spacer that's one
134:44 - that's two that's three that's four
134:49 - that's five that's six that's seven
134:55 - that's eight and that's nine so inside
135:01 - this V stack we have nine elements
135:03 - already so you can put one more element
135:06 - and that would be 10 and that would be
135:09 - completely okay but if you try and put
135:12 - an eleventh element you're gonna see an
135:16 - error and the thing is the error message
135:18 - isn't very helpful because it's just
135:20 - gonna point to something else at least
135:22 - in this example it's not actually
135:24 - telling you what the real problem is and
135:26 - that is that our V stack has 11 elements
135:30 - so how do you how do you combat this
135:32 - well you can let's say this is one
135:36 - solution you can nest these two elements
135:40 - inside of their own V stack and although
135:43 - in this example it kind of changes the
135:45 - way things look but that's just to get
135:48 - your thinking going so just keep in mind
135:50 - that there is a 10 element limit per
135:53 - layout container and that if you
135:56 - encounter a Swift UI error and your
135:59 - preview won't work and you can't build
136:01 - your project and the error message
136:03 - doesn't really make sense just remember
136:04 - that you can double check that and as a
136:07 - solution you can nest these things
136:10 - together share a screenshot of your
136:13 - completed challenge with me on social
136:15 - media and make sure to tag me so I can
136:17 - see it and if you also want to earn a
136:19 - special forum badge for your achievement
136:21 - make sure you post your screenshot in my
136:24 - code crew for
136:25 - under this topic I'll link to that forum
136:27 - thread in the description below and if
136:29 - you need help with this challenge the
136:31 - code crew forum is going to be the place
136:33 - to go to get help from myself the team
136:35 - and other developers just like yourself
136:37 - alright thanks for watching and I'll see
136:39 - you in the next lesson
136:42 - all right so this is the solution for
136:45 - the challenge and just to recap I asked
136:47 - you guys if you could do nine cards with
136:50 - two buttons the first button spinning
136:52 - only the middle row and the other button
136:55 - spins all of the cards and matches all
136:58 - three rows plus diagonals so that's what
137:01 - we're going to do today so the first
137:03 - thing we're going to do is actually to
137:06 - increase the number of cards that we
137:08 - have and this is actually relatively
137:11 - simple so we're gonna go into I'm gonna
137:18 - go down to where the card view is I gave
137:20 - you guys a tip last time where you know
137:25 - you're not going to be able to just
137:27 - create three rows like this because
137:29 - you're gonna get an error which is not
137:33 - very helpful it tells you that there's
137:36 - an error with this corner radius
137:38 - modifier but that really isn't the case
137:40 - the problem is that in the stack view
137:42 - that we have that contains everything
137:44 - it's got more than ten elements and
137:47 - right now stack views can only have a
137:49 - max of ten in fact any sort of container
137:51 - layout element can only have up to ten
137:54 - and so what we're gonna do is in case
137:57 - these three H stacks you know these are
138:02 - our nine cards here inside its own V
138:05 - stack so I'm gonna cut all of that I'm
138:08 - gonna declare a new or write a new V
138:12 - stack there and just paste all three
138:13 - rows and we should see all the cards
138:18 - alright so that's really cool
138:20 - the next thing to do then since we have
138:23 - so many cards is to expand expand our
138:29 - numbers and backgrounds because these
138:31 - two arrays represents the different
138:35 - slots or indexes for these cards and now
138:38 - we have more than three so we need you
138:40 - know we need nine so one easy way to to
138:47 - do it is like you could you could just
138:50 - create more elements in your array
138:53 - literal like that
138:55 - but there actually is a method for
138:57 - creating a race if you want to fill it
139:00 - all with the same value and I'm gonna
139:03 - show you that in a second but let me
139:04 - just show you this way right now so
139:06 - there are six and there's nine so you
139:07 - could do it like that and you can have
139:09 - each of these indexes represent a
139:11 - different card so we're gonna erase this
139:14 - literal here and we're gonna declare a
139:18 - new array object and we're gonna use
139:21 - this initializer here it creates a new
139:24 - collection containing the specified
139:25 - number of single repeated value so the
139:28 - value is going to be we're just going to
139:31 - put 0 and the count is going to be nine
139:34 - for that and then for this one for
139:37 - backgrounds we're going to do the same
139:38 - thing alright and we're gonna use this
139:42 - repeating one and it's gonna be color
139:46 - white and again nine then we can erase
139:51 - this literal here all right so that's
139:56 - what we have and the next step is to
139:59 - update all of these card views we're
140:02 - going to pass the appropriate bindings
140:04 - in so this one is going to be at index 0
140:07 - 1 2 3 4 5 6 7 8 right I almost counted 9
140:13 - you guys probably caught that and he so
140:16 - there's 3 this one's for since 5 this
140:23 - one 6 7 and 8 and if we just update this
140:31 - where we should see all of them as
140:35 - apples right ok so now the next step is
140:40 - to take a look at our spin button here
140:42 - so what it does right here is it sets
140:47 - all the backgrounds to white and then it
140:49 - randomizes a number for the 3 cards and
140:53 - then it it checks for the winnings like
140:59 - if 0 matches 1 in 1 matches 2 then you
141:02 - know that all three match and then it
141:05 - updates the credits and then it
141:07 - that's the background to green so in the
141:11 - last lesson when I finish the slots app
141:16 - I taught you guys about the map method
141:19 - for a race and we're actually going to
141:22 - use it now because setting nine
141:25 - different backgrounds and like you know
141:29 - randomizing nine different cards and
141:31 - setting nine different backgrounds to
141:33 - green is just is too much so we're gonna
141:36 - make use of that map function here but
141:40 - before that we're gonna abstract this
141:42 - code out into its own method the reason
141:45 - being right now we've written this code
141:48 - directly in the closure for the action
141:51 - for this button but we remember we're
141:54 - gonna have a second button that is gonna
141:56 - have very similar code because that
141:58 - button is gonna set all the backgrounds
141:59 - white as well but it's gonna randomize
142:01 - all nine cards and it's gonna set the
142:04 - backgrounds to the matches to green and
142:06 - it's going to calculate the winnings as
142:08 - well so rather than repeating this code
142:11 - right for nine different cards we're
142:13 - gonna kind of abstract it out and write
142:17 - it more elegantly so what I'm gonna do
142:20 - is I'm gonna create a method right here
142:26 - right before the closing bracket of this
142:28 - body property we're going to call it
142:31 - process results alright and we're gonna
142:36 - need to know if we're processing the
142:38 - results for one spin or like the maximum
142:41 - number of spins which is like all three
142:43 - so I'm gonna have a boolean to say is
142:47 - max and this is going to be a bull all
142:50 - right let's default it to false so by
142:53 - default it's gonna be a single spin and
142:56 - I'm just going to take all of this code
143:02 - in fact all of the code for this button
143:05 - closure
143:05 - for this action and we're gonna put it
143:08 - into here and the first thing we're
143:14 - gonna do is set all of the backgrounds
143:16 - for all of the cards to white so instead
143:18 - of going you know zero to eight we're
143:21 - gonna do self thought backgrounds equals
143:25 - self thought backgrounds dot map and I'm
143:32 - going to open up that closure and we
143:35 - don't need this parameter part and we're
143:38 - just gonna return color dot white and
143:42 - just like that we've set all the
143:45 - backgrounds to white maybe I can just
143:48 - get rid of this pain right there and
143:50 - that's gonna be a little easier to see
143:56 - alright now we're going to randomize the
143:59 - images but this depends on whether we
144:01 - are doing a maxis pin or a single spin
144:04 - right so we're gonna have to we're gonna
144:06 - have to do an if statement if is max
144:11 - then spin all the cards else
144:17 - spin the middle row alright so spinning
144:21 - the middle row we're gonna have to do it
144:25 - in three statements and the middle row
144:27 - is 0 1 2 3 4 and 5 so 3 4 & 5 that's the
144:31 - middle row right so we're gonna do 3 4 &
144:35 - 5
144:35 - but for spending all the cards again we
144:38 - can use the map function here so self
144:42 - dot numbers equals self dot numbers dot
144:45 - map and we're gonna open up that closure
144:48 - remove this part because we don't need
144:50 - it and we're gonna say we're gonna
144:52 - return int on random actually I'm just
144:54 - gonna copy this because it's the same
144:57 - thing for every single element
145:01 - all right so that's spinning all the
145:04 - cards or randomizing a number for every
145:06 - single index and this is just
145:09 - randomizing four three four and five
145:12 - alright and here's checking for the
145:16 - winnings now this is also more
145:18 - complicated now because if we're
145:20 - spinning a single spin then we only
145:22 - checked the middle row but if we're
145:24 - spinning max then we got to check one
145:26 - two three and in the X right four five
145:29 - that's like five different things so
145:31 - rather than have it here I'm gonna write
145:35 - a different a different method down here
145:40 - called process process win and again
145:48 - this is going to accept a parameter is
145:50 - max we're just gonna default it to false
145:55 - okay so I'm gonna I'm gonna take this
145:59 - chunk of code right here and I'm gonna
146:01 - cut this and I'm gonna paste it in here
146:04 - right and then simply I'm going to call
146:07 - process win from here and then pass in
146:09 - is max this is from up here right so
146:16 - this method is for processing the
146:20 - results but in actuality it's like just
146:22 - to spinning all of the indexes or
146:24 - randomizing all the indexes this is for
146:27 - processing the win which is to we're
146:32 - going to check basically all of the
146:35 - matches so let's declare so with a
146:42 - single row that was easy right if it
146:46 - matches then you win if it doesn't match
146:48 - this then you lose but for a max spin
146:50 - because there are so many different
146:52 - matches that can happen you can match
146:54 - you know you can match one you can match
146:55 - two you can match all five so we need to
146:58 - keep track of how many matches you've
146:59 - made and so I'm going to create a
147:02 - variable here I'm going to call it
147:05 - matches equals zero we'll initialize it
147:08 - to zero and then what kind of keep count
147:09 - so we're going to first
147:12 - check the case where it is max equals
147:15 - false so let's say this is a single spin
147:18 - right I put this inequality here this
147:21 - means that if it's not is max then we
147:24 - are processing for a single spin so
147:32 - we've already got we've already got this
147:35 - here right except we're not checking 0 1
147:44 - & 2 were checking 3 4 & 5
147:48 - so if 3 equals 4 and 4 also equals 5
147:52 - then that means there's a single match
147:55 - and we update the backgrounds 3 4 & 5 to
148:00 - green right and 1 I would I would
148:05 - instead of doing this we're gonna update
148:08 - the number of credits at the very end
148:10 - based on how many matches there were so
148:12 - in here instead of updating this the
148:15 - credits balance here we're just going to
148:17 - say matches plus equals 1 ok so that is
148:22 - if the cases if the case is not is max
148:27 - if that's a single spin else
148:33 - processing for max the spin I'm going to
148:38 - remove this code so we don't kind of
148:39 - confuse ourselves this was the code from
148:42 - before and then you know after we
148:45 - process for max spin this is going to
148:49 - require a couple of different if
148:50 - statements right so I'm gonna I'm gonna
148:56 - shorten it after I write it this way
148:58 - just so you guys are aware but right now
149:02 - we're gonna check row by row so we're
149:03 - gonna say top row and this would be 0
149:10 - does 0 equal to 1 does 1 equals to 2 if
149:14 - so matches plus 1 and turn turn these
149:18 - cards green okay now we check middle row
149:24 - so middle rope is when you know we've
149:27 - already got the code from up here so I
149:29 - literally just pasted it here if the
149:32 - middle row matches then matches plus
149:34 - equal one this is bottom row bottom row
149:38 - is 7 6 7 8 so 6 equals the 7 and 7
149:45 - equals to 8 then we're going to update 6
149:49 - 7 & 8 to green we've got two more to do
149:54 - so diagonal diagonal top left to bottom
149:59 - right so that this would be 0 with 4
150:05 - right 0 1 2 3 4 with 4 and this would be
150:09 - 8 so 0 4 & 8
150:18 - okay and then we've also got a diagonal
150:24 - top right to bottom left and this would
150:28 - be 0 1 2 2 4 & 6 okay and finally that's
150:43 - good
150:44 - finally check matches and distribute
150:50 - credits so if matches is greater than 0
150:55 - then that means that there is there is a
150:59 - win right if else if that means if it
151:05 - comes to me here that means matches is 0
151:08 - or less than 0 which it can't be less
151:11 - than 0 so it's just 0 else if not is max
151:17 - so this is at least 1 win this is 0 wins
151:25 - single spin and then lastly its 0 wins
151:30 - max spin so if it's you know if it's
151:36 - zero wins single spin then we're going
151:39 - to do self dot credits is minus equals
151:44 - that amount so we had a bettin amount up
151:47 - here which represents how many credits
151:51 - gets spent for a single spin and I'm
151:56 - gonna do it so that for the max spin I'm
152:01 - gonna do it five times the amount of a
152:03 - single spin so it's gonna deduct 25
152:06 - credits instead alright but if you win
152:10 - then you're gonna get you're gonna get
152:13 - more credits back based on the number of
152:15 - matches you have so matches thumbs bet
152:18 - amount but you usually have to win more
152:21 - than you bet more than the amount that
152:23 - you just bet so I'm gonna say you
152:27 - you're gonna get two times back if you
152:29 - if you make a match you're gonna get two
152:31 - times back and you know multiplied by
152:33 - the number of matches you made so that's
152:36 - that's gonna be the math there and now
152:39 - let's add before we optimize this and
152:41 - kind of long chunk of code here I want
152:44 - to add a second button here just so we
152:46 - can start testing it and just making
152:48 - sure that this code is right before we
152:50 - go and shorten it so let's go back up
152:53 - here for our single spin button remember
152:56 - I had removed the action but now I can
152:59 - call process results right and is maxed
153:05 - by default is equal to false so I'm just
153:06 - gonna you know say that I process a
153:12 - single spin right and furthermore I
153:17 - actually want to put some text down here
153:19 - to say how many credits it costs so I'm
153:21 - gonna say V stack and I'm gonna put a
153:25 - text element here I'm gonna say five
153:30 - credits and I'm gonna take this button
153:35 - I'm gonna put it into this V stack like
153:37 - that and so we should see a little label
153:41 - down there that says five credits
153:43 - that's a resume all right so I spelled
153:50 - credits wrong okay I'm gonna optimize it
153:55 - a little bit so I'm gonna add some
153:57 - padding to the top let's say 10 and I'm
154:02 - also going to change the font to a like
154:07 - a caption style so it's a little smaller
154:10 - that's really small
154:13 - let's try footnote that's a little less
154:19 - slightly better if that's fine and
154:22 - instead of five I'm actually gonna sub
154:25 - in the bet amount in case we change that
154:28 - variable at the top so that's still
154:30 - going to be five all right now we are
154:33 - going to put this in an H stack because
154:36 - we have a second button remember so an H
154:39 - stack we're gonna take this button here
154:44 - we're gonna pop it in there and we're
154:48 - gonna add a second button so I'm gonna I
154:50 - just pasted it twice so now we have a
154:52 - second one this one's going to be called
154:54 - max spin the mountain of credits is
154:57 - going to be but amount times five so
155:01 - that's 25 and instead of just processing
155:04 - results we're gonna pass in true to
155:07 - indicate that this is a max spin and I'm
155:12 - going to add some spacing in between
155:13 - those two buttons so this H stack has an
155:17 - initializer this one so alignment we we
155:22 - don't need to specify that the default
155:24 - alignment is fine it's spacing right
155:26 - about 20 and this content closure is
155:28 - like I mean we already have this right
155:32 - there like this all this stuff is that
155:36 - parameter that content parameter okay so
155:39 - let's save this let's run this and see
155:41 - see how this actually works
155:52 - all right so single spin Oh match right
155:56 - away that's a win all right max spin
156:00 - cool wait that was a weird I think I saw
156:07 - a weird green pattern we might you have
156:11 - this oh wait this is a match yeah okay
156:13 - so row row diagonal
156:18 - well I still end up making money or
156:21 - losing money
156:22 - these are credits these aren't this is
156:24 - not money we are not gambling here I
156:29 - think we're going down here she is dying
156:34 - a slow death here at this point I'm
156:37 - borrowing money to gamble I mean the
156:42 - loan sharks all right this is cool so
156:45 - it's working let's optimize this code
156:47 - here because if you take a look at all
156:51 - of these parts that we have here the
156:54 - code is exactly the same but the only
156:55 - difference is that the indexes are
156:59 - different right see this code is
157:02 - checking these three indexes zero one
157:04 - and two and then setting it to green if
157:07 - it's a match that this section is
157:08 - checking three four and five so we can
157:11 - create a different a different method
157:16 - here and we're gonna call this is match
157:21 - and you're gonna have to pass in the
157:23 - three indexes so we're gonna have index
157:25 - one as an int index two as an int index
157:31 - three as an int and it's gonna return a
157:35 - bool so it's going to return false
157:39 - by you know if it reaches there but
157:42 - first it's gonna well it's basically
157:45 - going to check this if self-thought
157:49 - numbers index one
157:52 - is equal to self dot numbers index two
157:56 - and soft thought the numbers index 2 is
158:04 - equal to self tough numbers next three
158:07 - then this is considered a match and we
158:11 - return true and what we can also do is
158:15 - just also set the backgrounds to green
158:18 - as well but instead of hard-coding those
158:22 - indexes we would have index 2 and X 3
158:27 - and this is basically a repeat of this
158:31 - code I don't know why I typed it out I
158:33 - see it see I typed something wrong oh
158:38 - there should be a space right there
158:40 - all right so now we can call this is
158:43 - match method instead of all of this code
158:46 - here so for example for this one
158:49 - we're gonna call you know we can do if
158:52 - is match and pass in 3 4 & 5
158:58 - and if this is true then we can do
159:02 - matches + equals 1 right because our
159:05 - method didn't it doesn't increase the
159:07 - matches number I mean we keep track of
159:09 - this and here in the process win and
159:11 - then we can delete this whole chunk of
159:13 - code and if you want to short it if you
159:17 - want to shorten even more you can you
159:23 - know you can put it in one line like
159:25 - that
159:28 - so then this becomes you just change
159:34 - these numbers 0 1 & 2 you get rid of
159:39 - that middle row becomes 3 4 & 5 this
159:53 - becomes 6 7 & 8
160:01 - this becomes 0 4 & 8 I accidentally keep
160:10 - pressing command B that's 2 4 & 6 4 & 6
160:24 - so that actually saves a lot of code and
160:29 - you know it's gonna make updating this a
160:31 - lot easier maintaining it I mean and it
160:34 - also looks a lot better so let's just
160:37 - run it again to make sure nothing's
160:39 - broken you know what would be cool is if
160:53 - we did a jackpot type thing like if you
160:55 - get I don't know you can you can do you
161:00 - know those slot machines at least you
161:02 - know different configurations kind of
161:04 - give you like different amounts right
161:06 - now we have a standard amount just for
161:08 - three matches but if you had a couple
161:10 - more symbols in here you could do some
161:13 - maybe if you get like all cherries or
161:15 - something you just get an explosion of
161:17 - credits but anyways that does it for
161:19 - this one that's the challenge that I
161:20 - wanted to do
161:21 - I'll leave the jackpot thing to you if
161:23 - you want to implement that if you do end
161:25 - up doing that definitely shoot me a
161:28 - screenshot on Twitter Instagram tag me
161:30 - and um I'll show it off okay thanks a
161:34 - lot thanks for watching I'll see you in
161:36 - the next lesson