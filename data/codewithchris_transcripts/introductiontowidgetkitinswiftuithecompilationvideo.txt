00:00 - learn how to add a widget extension to 
an existing app including reusing service  
00:05 - classes building uis for different size classes 
and scheduling widget updates through a timeline  
00:13 - hey code crew this is floor i've been developing 
ios apps since 2016 and i've been working on many  
00:19 - different widgets over the past few months so 
i'm super excited to teach you about widget kit  
00:24 - in this series this is lesson one where i will 
show you examples for great widgets by apple  
00:30 - the current project setup and the example app 
that i have prepared for you next we will add a  
00:35 - widget extension and go through everything that 
xcode automatically generates for us let's get  
00:41 - started with some examples of grade widgets so you 
understand how all of this works how the ecosystem  
00:46 - works and how they are built up so there is this 
great article from the apple developer website  
00:52 - which is linked in the description which just 
gives a brief introduction to widget kit and i  
00:57 - just want to show you a few of the examples that 
they have on their website here they have the  
01:01 - little calendar widget they have a weather widget 
news music also for the activity app and so on  
01:12 - then there are a bit larger widgets for the 
ipad with photos and a bigger calendar view  
01:19 - but one thing that unites all of them is that they 
have at a glance information so you for example in  
01:26 - the calendar widget you only have the next two 
events showing so when you have a glance at the  
01:32 - widget you immediately know what it wants to show 
you and what information is there same for the  
01:37 - weather widget you just have a quick look at it 
and then you instantly know the temperature and  
01:42 - the current weather conditions there are also 
some more widgets that i want to show you that i  
01:46 - have personally worked on the first one is a food 
tracker app which is based around a medium sized  
01:53 - widget that you can see in the screenshot in the 
middle here and the idea is basically that you can  
01:59 - track your meals through a widget where you can 
just tap either on the healthy or on the junk  
02:04 - side of the widget the app will open up and all of 
your meals will get locked that way so there's a  
02:11 - tiny bit of interactivity here but i will tell you 
more about that in just a second and then there's  
02:16 - also another widget that i made for a swift ui jam 
a few weeks ago which is an almost fully working  
02:23 - calculator widget so we can watch the video here 
it looks just like the calculator app from your  
02:30 - iphone but then you can tap on the numbers and 
on the operators the app will briefly open up  
02:36 - close back down again and then you will see 
your calculation and the end result inside of  
02:41 - the widget i think this is very cool obviously 
this is not what apple intended widgets to be  
02:46 - but there you can just see what's possible 
with the technology so getting back to widget  
02:51 - kit itself widgets are built entirely in swift ui 
so it is not not possible to pull the ui kit for  
02:58 - example via ui view representables or your view 
controller representables currently you can only  
03:04 - use swift ui to build out the ui side so what's 
displayed inside of the widget as i said the main  
03:11 - idea is to provide at a glance information these 
are just tiny portions of the screen the widgets  
03:16 - are based on a timeline so you the developer can 
provide a timeline scheduled with timeline entries  
03:25 - that all have an associated date and some data 
associated as well so you can for example schedule  
03:32 - a timeline over the next five hours where 
at every full hour there is a timeline entry  
03:38 - and then ios or ipad os or even mac os whichever 
system your widget is running on will execute  
03:45 - that timeline and refresh the widget by itself so 
you're not guaranteed to have the widget refresh  
03:50 - at exactly the time in your timeline entries 
that you have specified but the system handles  
03:57 - it and the system also has some limitations 
for example you cannot refresh your widget  
04:03 - a few hundred times per day there are just certain 
restrictions there set by ios but most users will  
04:09 - never notice this and for most users the widgets 
will always stay up to date we will have a look  
04:14 - at the timeline the timeline entries and so on in 
partially in this but mainly in the next lesson  
04:20 - and then one last very important thing when 
talking about widgets is that you understand that  
04:26 - they are static ui so there are no animations 
there are no videos there is no navigation  
04:32 - and there are also no buttons the only dynamic 
thing that a widget can do is link into your  
04:40 - main app and pass in some data there we will have 
a look at that in the third lesson of this series  
04:47 - but until then you can just assume that a widget 
is more or less a very static view okay to get  
04:55 - us started a bit quicker i have already prepared 
a very simple example app this is a simple to-do  
05:01 - list app based on the json placeholder api you 
might have already seen the json placeholder api  
05:07 - if you want to have a more specific look at 
it it will be linked down in the description  
05:12 - it's a very generic api with some yeah as the 
name suggests placeholder json data for users for  
05:19 - posts and so on but we're just using the to do's 
route which you will also see in just a second  
05:24 - so the main app only has a single view which you 
can see here on the right hand side if i press  
05:29 - play then all of the to do's will be loaded you 
we will have a list here with the to do title  
05:37 - on the left hand side and then the statues whether 
it's completed or not on the right hand side so  
05:42 - some of these to-do's are open some of them are 
already completed and if we tap on a to-do item  
05:49 - here a little sheet will come up telling us 
the id of the to-do then once again the title  
05:55 - and whether it's open or completed and then you 
can of course dismiss the sheet like always okay  
06:01 - so let's briefly go over the content view here 
so you understand how this all was built and  
06:06 - then we will have a look at our data class or to 
do and then also our service class so first of all  
06:14 - as you can already see we have a navigation title 
here so we must also have a navigation view which  
06:19 - surrounds everything in our content view here and 
then mainly we just have this single list here  
06:26 - the rest of the code is just view modifiers but 
we mainly have the single list here iterating over  
06:33 - all of the to do's which is a state variable here 
in the beginning this is an empty array of to do  
06:40 - but later on i will show you how this gets filled 
and then inside of the list we just have a simple  
06:46 - button for every row the button action is to 
set the selected to do which is another state  
06:53 - variable to the to do of this current row so for 
example if i tap on the first one then that will  
06:59 - will be the selected to do which is used for 
our sheet here at the bottom this has the  
07:06 - item initializer where you can pass in an 
optional identifiable item in our case our  
07:13 - selected to do state and if that is not 
nil so if there is some to do selected  
07:19 - then the sheet will show up and show just a simple 
group box here i think this is not too important  
07:25 - this is just for demonstration purposes if we 
just miss the sheet again we have our list again  
07:31 - and then inside of the list button there is just 
a simple attributed string which is brand new in  
07:36 - ios 15 where you can use some parts of markdown to 
for example bold a region of text so here you can  
07:44 - see these double asterisks before and after the 
completed or open text which we just bolded as i  
07:52 - said this is attributed string stuff not important 
for this series i just wanted to include it to  
07:57 - make it look a tiny bit nicer since this is a very 
plain ui okay let's continue down so we already  
08:03 - have covered the navigation title it's just my 
to-do's and now the interesting part comes so  
08:09 - um for our to-do servers i have chosen to use 
the new script concurrency features if you want  
08:15 - to learn more about that there is also a series 
about such concurrency made by stuart lynch  
08:20 - um so it will probably also be linked down below 
you can go there after this video or if you have  
08:27 - any understanding issues then you can just 
go there and have a look at it but i think  
08:31 - it will be pretty straightforward basically what 
we're doing is we're attaching a task to the list  
08:38 - task is very similar to unappear so the code in 
here gets executed the first time that the view  
08:45 - appears but you can execute a synchronous code in 
here so we will have a look at how that works in  
08:52 - just a second but bear in mind so this task 
will get executed one time at the beginning  
08:56 - and everything in here is happening 
asynchronously in a background thread  
09:02 - or can happen in the background that can also 
happen in the main thread depending on how it  
09:06 - is scheduled internally and all that this task 
does in this case is call our to do service  
09:12 - dot get all to do's function which calls the json 
placeholder api gets back all of the to do data  
09:19 - and then puts it into our to do's state variable 
up here which will then be used inside of the list  
09:28 - okay and then the last modifier here i already 
told you about the sheet so i think this should  
09:33 - be pretty clear now let's move on into the data 
folder on the left hand side here so first of all  
09:40 - we have our struct to do it's important that 
this had this conforms to two protocols the  
09:45 - first one is decodable so we can decode it from 
json which you will see in a second in the to-do  
09:50 - service and the second protocol is identifiable 
so we can iterate over it in our swift ui list  
09:58 - this just has four very simple attributes the 
user id the id of the to do the title of the to do  
10:07 - and whether the to-do is completed or not let's 
jump real quick into the json placeholder api and  
10:14 - let's go to the endpoint that we're using which 
is slash to do's and here you can see where this  
10:20 - data is coming from so this is just a json file 
sitting on the server and there you have um all  
10:27 - of the same fields that i just showed you in our 
to-do structs so you have the user id which is an  
10:31 - integer the id which is an integer the title which 
is a string and then completed which is a boolean
10:41 - okay and then the last file that i have prepared 
is the to do service here this is just a very  
10:47 - simple helper class to fetch all of the to-do's 
from the json placeholder api since there is no  
10:53 - need to instantiate a new to-do service every 
time that we use it i just added a static shared  
11:00 - instance here so we can always just say to do 
service dot shared instead of instantiating a  
11:05 - new to do service we have our base url which is 
just the address of jsonplaceholder.typeycode.com
11:14 - and then it gets a bit more interesting 
with these three functions here  
11:18 - the first one is a very generic networking 
function that you can use in any of your  
11:23 - projects really but the important thing is that 
it is built using the swift concurrency features  
11:30 - so let's have a brief look at how that works 
so inside of the function we first have  
11:36 - or we first construct our url so when we call this 
function we pass in an endpoint for example todos  
11:44 - and then the function will generate a url for 
us so in this case it would be https colon  
11:53 - slash slash jsonplaceholder.typeycode.com slash 
and then here it would be for example to do's  
12:01 - so this will be the endpoint we constructed 
here this can fail so if in case it fails we  
12:06 - will just throw a url error of that url once 
we have our url we can use the url session  
12:14 - dot shared dot data function which is similar 
to data task or data task publisher if you were  
12:20 - using combine previously this function 
just creates a or takes the shared url  
12:26 - session goes to the url that you uh handed over 
and then fetches all of the data from that url  
12:34 - this is an asynchronous task so you have to 
wait for the results to be coming in and this  
12:42 - can actually also fail or throw an error and hence 
we need to try to await the data from this url  
12:51 - this function actually gives back both data and 
a url response so in your app you might want to  
12:58 - check the url response for the status code 
or any info that the server gave back to you  
13:03 - in our case we don't care about that so we can 
just omit the second value of the tuple here  
13:08 - the url response by using the underscore and we 
will just unpack the tuple into our data variable  
13:16 - and then the last step is pretty straightforward 
we just construct a json decoder and then we  
13:22 - decode our to do in our case from the data now 
the interesting part here is and hence the name  
13:30 - generic helper function we have some 
generics here so we have a generic type t  
13:36 - which basically means that we could use this 
fetch function to fetch any type of data  
13:41 - we could also fetch some users or whatever as 
long as that struct is decodable as the generic  
13:49 - condition here says so let's see how that works 
i have two endpoint functions basically the  
13:55 - first one is to get all to do's from the json 
placeholder which once again is asynchronous  
14:02 - and can throw arrows but this one 
will return an array of type to do  
14:07 - and this will basically just call our fetch 
function up here from the to-do's endpoint  
14:14 - so basically just the one that i showed you in 
the browser a minute ago as you've already seen  
14:19 - the fetch function is asynchronous it can throw so 
we need to try to avoid the result of the function  
14:26 - since we are using generics here we need to 
explicitly specify the type that we want to  
14:32 - get back so in this case if we want to get all to 
do's we want an array of type to do and then we  
14:39 - just return the result of the fetch function 
and then very similar for the last function  
14:46 - which is called get to do with id we can use 
this one to get the data for a specific to do  
14:53 - which we're using for the sheet for example this 
function returns a single to-do instead of an  
15:01 - array of to-do's and it's basically the exact 
same from before so we need to specify the type  
15:07 - over here since we are dealing with generics 
and then the only thing that we're changing  
15:12 - is the end point so now we're not querying for 
all to do's requiring for to do's slash our id  
15:18 - and if we look at that in the browser so 
here we have slash to do's and now we say  
15:23 - slash one for example this will give us just the 
first to-do item okay so now that you have seen  
15:30 - the sample app that i have already created for 
you let's do the last thing for this video which  
15:36 - is adding the widget extension to do that it's 
also very very simple since xcode does almost  
15:41 - everything for you you just go to file new 
target and then in here you can either scroll  
15:50 - through all of the extensions or you can just 
filter for widget extension double click it  
15:58 - then give it a name so in our case i 
will call it widget kit course widget  
16:08 - make sure to uncheck include configuration intent 
that is something that we're not doing in this  
16:13 - series configuration intent can basically be used 
for siri it can be used for the user to customize  
16:20 - your widget but this is not important for the 
series once you're done just hit the finish button
16:28 - and here you can say activate the scheme if you 
want to which what this does is basically it  
16:34 - changes the theme up here in xcode so once you 
have an extension you can select when you're  
16:40 - running your app which scheme you want 
to run so you can then either run your  
16:43 - main app in the simulator or just run 
the widget extension in your simulator  
16:49 - for now let's just say activate if 
you want to change this later on  
16:52 - you can just go up here and select either 
your main app or your widget extension  
16:59 - okay and then on the left hand side here 
you can see that a new folder was generated  
17:04 - which is called just what we entered 
into the text field if we open that up  
17:09 - there's just three files a basic info.plist 
file an asset catalog that you can use to  
17:15 - provide assets like images and then there is 
the widget kit course underscore widget file  
17:21 - this file contains all of the auto generated code 
from xcode let me go over the extension and tell  
17:28 - you a few words about each of the different 
types that got generated and actually let's  
17:33 - start at the bottom here so first of all same as 
in swift ui which i just closed there is also a  
17:40 - preview available for your widgets i'm closing 
this right now so we have a bit more space  
17:46 - by the way to open and close that canvas you 
can press command option enter and then there  
17:53 - is something that you're probably already familiar 
with if you have worked in swift ui before  
17:59 - because there is now this add main widget 
struct this is actually super similar to the  
18:06 - admain abstract in your normal app where you have 
a body in which you just present your content view  
18:13 - inside of a window group in this case but it also 
has the add main attribute which basically tells  
18:20 - the device this is the entry point to the app 
start here and then it's the exact same thing for  
18:26 - your widget this add main attribute will just tell 
the device this is the main starting point for the  
18:32 - widget called this and then you're good to go 
so of course this is not an app this is a widget  
18:39 - and it also has a body the body has the generic 
type of or the opaque type of widget configuration  
18:48 - you can have there are basically two different 
types of widget configurations the first one  
18:53 - is a static configuration which we are using in 
most widgets actually use a static configuration  
18:58 - and there is also an intent configuration which 
you can use if you want to let the user edit the  
19:04 - widget directly on the home screen not important 
for this series but just so you know there's two  
19:09 - different types of configurations and then into 
the configuration you just pass basically an  
19:15 - identifier of the widget which is defined up here 
by default this is just the name of your widget  
19:22 - extension target you can change this of course 
especially if you add multiple widgets to your  
19:28 - app later on and then into the configuration 
you also pass in a timeline provider we will  
19:34 - have a look at that in just a second inside of 
the configuration you then have your actual view  
19:39 - now this has a very long and complicated 
name we would change that also in a minute  
19:45 - and into that view you pass in your timeline 
entries if you recall in the beginning of this  
19:50 - lesson i talked to you about you can schedule a 
timeline with different timeline entries for set  
19:57 - dates which in turn contains some data that 
you can pass to your view and basically these  
20:03 - timeline entries here come from your timeline 
provider and get passed into your view over here  
20:11 - you will see this more concretely in just 
a second you can also customize your widget  
20:16 - configuration by for example giving it a display 
name which will then show up in the app library  
20:22 - and you can also give it a description 
okay let's scroll up a bit here  
20:28 - the next struct that got auto generated is the 
actual view this view gets passed in a timeline  
20:36 - entry which is that piece of data that's scheduled 
through your timeline and then this example widget  
20:43 - here that gets auto-generated just shows some text 
of the current date of the entry so nothing very  
20:50 - special here and then the entry actually doesn't 
contain any data right now we will customize this  
20:57 - in the next lesson the only important thing here 
is that your entry conforms to the timeline entry  
21:04 - protocol which requires the entry to have 
a date property and then up here the most  
21:12 - important and most interesting part of widgets 
is the timeline provider so all of this over here  
21:20 - the timeline provider is responsible for 
scheduling your timeline entries for your widget  
21:27 - over time for the next couple of hours for the 
next day or even weeks however long you want to  
21:32 - schedule it there are three main functions 
functions that you need to implement here  
21:38 - first of all the placeholder function this is 
used when the user is selecting your widget in  
21:44 - the widget gallery on their actual device then 
there is the get snapshot function which just  
21:51 - gets back the current version of the widget with 
just a simple timeline entry or just a single  
21:57 - timeline entry and then there's the get timeline 
function which you can use to schedule a timeline  
22:04 - for your widget including when it will refresh 
how often it will refresh and which data it will  
22:09 - show the very last thing for this video will be 
taking all of these different structs and moving  
22:17 - them into their own files to make it a bit easier 
to read and to understand what we're working with  
22:23 - so over here in our widget folder we will 
add a new file and call this one provider
22:32 - and now a very very crucial detail when you 
create this file is that it needs to be in the  
22:39 - widget target and not in the app target now 
you can hit create and in here let's import  
22:46 - widget kit and then let's move our provider 
our timeline provider from the generated file  
22:56 - into this new file and let's do the same 
for the simple entry and the view as well
23:05 - so create new file swift file let's 
call it simple entry make sure that the  
23:12 - widget extension is checked here hit create import 
widget kit and then copy over our simple entry
23:24 - just like this and then one last time for 
our view here so let's hit command n new file  
23:33 - let's call this widget view hit create here 
we need to import both widget kit and swift ui
23:44 - let's copy over this struct over 
here and move it into this new file  
23:53 - and then we can also command click on it and 
say rename and then rename this long name  
24:00 - to just widget view let's also remove this 
space here let's copy the name and make sure  
24:08 - that it was renamed everywhere so for example 
for some reason xcode didn't rename it over here  
24:14 - so let's get rid of these old names and 
replace them with the new shorter name  
24:20 - in this lesson you learned about what can be 
done with widgets and how they are internally  
24:24 - structured you saw that a widget is based 
on a timeline and timeline entries which  
24:30 - get displayed in a plain old swift ui view learn 
about different size classes building a widget  
24:37 - ui and deep linking into your app in this lesson 
hey code crew this is floor in the first lesson  
24:45 - of this widget kit course you learned about how 
widget kit works under the hood how widgets are  
24:50 - refreshed and everything that xcode automatically 
generates for you in lesson 2 we will have a look  
24:56 - at building uis for different size classes and 
deep linking into the main app from the widget  
25:03 - let's get right into it so we're starting in this 
lesson right where we left off in the last lesson  
25:10 - and actually we don't need the content view 
what we need is our widget definition here so  
25:16 - i already told you in the first lesson that there 
are different size classes that your widgets can  
25:20 - have so that's the first thing that we will 
have a look at in this lesson to have a look  
25:26 - at the size classes configure them and tell the 
system which size classes your widget supports  
25:31 - you can just go to your static or your intent 
configuration basically just widget configuration  
25:36 - and then there is a very simple modifier called 
supported families here you can just pass in an  
25:42 - array of all of the widget families that you 
want to support one note though is that the  
25:47 - system extra large family is only available for 
ipad apps since it cannot even fit on an iphone  
25:55 - for this lesson we will focus on system medium 
which is basically two rows of apps at full width  
26:03 - and also system large which is two which is 
four rows of app so almost the entire screen  
26:11 - taken up by that widget while we're added 
let's also change the configuration name  
26:17 - to my to-do's and let's also change the widget 
description both of these strings are shown in the  
26:26 - widget preview when the user wants 
to add a widget to their home screen  
26:29 - so for example here for a description we 
could we could say view your latest to-do's  
26:38 - just like this okay so now we have told the system 
that our widget supports both the system medium  
26:45 - and the system large widget family but now we have 
to actually implement both of these size classes  
26:52 - and what we will do is we will switch on the size 
classes that we can reach from the environment  
26:57 - and then provide different views to the widget 
based on which size class is currently selected  
27:02 - for that there is an environment value that 
we can read so just say add environment  
27:09 - and then the key path is widget family and this 
way we can basically read the size of the widget  
27:19 - and what we can now do is just switch over 
this because it's an enum you just saw us  
27:24 - set it up here in the supported families 
modifier just switch over it and then  
27:29 - present different views so here let's remove 
the text and let's say switch widget family
27:38 - and now we're only interested in two cases because 
we only support system medium and system large so  
27:44 - let's say dot system medium and let's also say 
dot system large and as always a switch must be  
27:53 - exhaustive in swift meaning that either we have to 
cover all of the cases individually or we need to  
27:59 - provide a default case in the end that should 
happen if none of the other cases holds true  
28:08 - in our case or in in a place like this the default 
case will never be executed because we told the  
28:16 - system that we only support medium and large but 
nevertheless we need to provide a default case  
28:22 - so let's just say not implemented here and then 
we can forget about this for the system medium  
28:29 - and the system large cases we will now 
implement widget uis so i will just hit  
28:36 - command n say new swift ui file and 
let's call the first one medium size view
28:46 - make sure that it's a member of the 
widget extension and not of the main app  
28:50 - hit create and then let's do 
the same with a large size view
29:01 - for both of these let's move them into a  
29:04 - group over here in the widget just so we can 
separate everything so let's call this group  
29:09 - views and in here let's move our widget view 
our large size view and our medium size view  
29:17 - okay let's close these and open them up again 
let's start with the medium size view first of all  
29:26 - we will want to receive a timeline entry the one 
that our widget view already got from the timeline  
29:34 - and we will want to forward 
that into our medium size view  
29:38 - so to work with timeline entries we need to import 
widget kit and then over here we just need to say  
29:46 - we want to take in an entry and we can either 
say provider dot entry or we can just directly  
29:52 - tell code to type which is simple entry let's 
do the exact same thing for the large size view  
29:59 - so import widget kit and then let's 
add a var entry of type simple entry  
30:10 - and actually since we're inside of widget kit we 
don't even need the previews here so we can just  
30:14 - scrap them from both of these views that 
way xcode won't complain about any issues  
30:20 - and now we can already start to add both of these 
views into our widget view so for the system  
30:26 - medium let's just say medium size view with our 
entry and then also large size view with our entry  
30:37 - okay for the medium size view we 
will now start to implement the ui  
30:41 - and for that i want to show you a pretty neat 
trick how to have at least a decently looking  
30:46 - ui up pretty quick for that we will use a group 
box with a label so a group box is basically  
30:53 - just a wrapper around a bunch of views that 
groups and up and puts them into a box with  
30:58 - some sort of grayish background and with the 
label initializer here we can pass in a label
31:06 - with a title and an image in our 
case we will use a system image  
31:11 - the title will be my to-do's and the system 
image will be list dot dash and now inside  
31:20 - of the group box we can put our actual ui 
so in our case we will have an h stack here  
31:27 - with first an image of a person for that we will 
use um the sf symbol for person let's make that  
31:35 - resizable let's make that scale to fit and let's 
also give that a foreground color of secondary so  
31:43 - um so a nice grayish touch then let's add a 
little divider so in case you didn't notice  
31:51 - you can place dividers in v6 but also in h 
stacks and if you place them in h6 then they  
31:56 - will be just a vertical line and then in here 
let's add a little v-stack where we can display  
32:05 - the contents of one of our to-do items 
let's give this a leading alignment
32:13 - like this and then in here we will have two 
text elements the first one with the to do title  
32:20 - right now we will just have some placeholder 
content here because we will fill out the  
32:25 - timeline provider in the next lesson let's 
have this text as a headline font so give  
32:32 - this the font of dot headline and then below 
our title we will have whether it is completed  
32:39 - so here i will just say completed for now we 
will fill this with a tiny bit of logic in the  
32:44 - next lesson as well and then here we'll just say 
this is a sub headline like this at the end let's  
32:52 - also add a spacer so everything is aligned 
nicely and then let's also add some padding  
32:58 - to the edge stack so nothing cuddles with 
the edges of the widget i would say okay  
33:04 - that's the medium-sized view already done for this 
episode now let's move on to the large size view
33:11 - in here let's also remove the text 
and let's replace it with a v stack
33:19 - basically what we want is we want to have kind of 
like a notepad feel to this widget you already saw  
33:25 - it in the first lesson how it will look in the 
end and let's implement that right now first of  
33:29 - all there's this little header row at the top 
i will give that a spacing of 16. and in here  
33:38 - let's add a little title called my to-dos 
then let's add the current date so date.now  
33:48 - with the format of date time this is a very handy 
text initializer here where you can pass in a  
33:56 - date and then it will be formatted nicely and 
then let's push all of that to the leading edge  
34:03 - to format this a bit nicer let's give it eight 
points of padding let's give it a blue background  
34:12 - let's give it a white foreground color to 
have a nice contrast to our blue background  
34:18 - let's clip all of this so it's handled as a 
single view because now we will apply a shadow  
34:26 - with a radius of 5 points if we were to not apply 
the clip modifier like this then the shadow would  
34:34 - be applied to each individual sub view of our age 
stack but we only want the shadow once for the  
34:40 - entire hdac so we need to clip everything into a 
single view okay next up we want to display a list  
34:48 - of all of the currently open to do's or 
all of the currently available to do's  
34:54 - for that we will create a for each 
and for now we will just feed this  
34:59 - with random numbers we will not even use 
them we will just say underscore in because  
35:06 - we don't even care about these numbers 
in the for each let's create an h stack  
35:12 - with a circle this will basically be the 
indicator if the to-do is already completed or not  
35:18 - and here actually we don't need to say id we 
need to say self as the identifier we don't want  
35:24 - the full circle we only want to stroke its border 
so we will say stroke with a line width of two  
35:32 - let's scale this a little bit with 
a frame of 30 by 30. we don't care  
35:36 - about the alignment since it's just a single 
circle and then let's overlay something here  
35:45 - we want to overlay basically a little check mark 
if the to-do is already completed so we will say  
35:51 - if true for now since all of this is just mocked 
if true we will have an image with the system name  
35:59 - of check mark okay so that's the first part of 
our rows next we want to add the to-do title
36:08 - okay and then let's push everything 
to the leading edge with a spacer  
36:13 - let's give this whole thing 
a bit of horizontal padding
36:18 - and then also add a divider underneath
36:24 - okay now that we have implemented 
both the large and medium-sized view  
36:28 - let me run them on the simulator and show 
you how they look okay so the simulator is  
36:33 - now running and you can already see our medium 
size widget here so all of this is a group box  
36:40 - up here you can see our label that we added at the 
bottom here then there's this scaled system image  
36:47 - that to do title and that it is already completed 
and if we swipe over to the next side we see a  
36:53 - tiny bit of an issue with our large size 
view and that is because we have too many  
36:59 - lines or too many cells here so let's reduce 
that to six and run it again and have a look  
37:06 - okay this is already looking a lot better so we 
have our header here the only thing that i forgot  
37:10 - to do is to add a little spacer below or for each 
so we don't have that white space at the top there  
37:17 - so let's add the spacer here let's run this 
one last time okay and there you can see  
37:25 - now the ui looks exactly how we wanted it we 
have our header here with the blue background  
37:29 - and a tiny bit of shadow at the bottom here 
if you can even notice it then we have the  
37:34 - title of my to-do's and the current date then of 
course we have our rows of our different to-do  
37:40 - items as you know all of these are mocked 
right now okay in the second part of this  
37:45 - lesson we will have a look at deep links 
so basically we want the user to be able to  
37:50 - tap somewhere on the widget and then open up 
a specific piece of information inside of the  
37:55 - app to achieve that there are a few steps that 
we need to take first of all we need to set up  
38:01 - the target url in our widgets using either 
the widget url modifier on the entire ui  
38:08 - or using specific link views for example for our 
rows here inside of the for each and then we also  
38:16 - need to handle the on open url modifier inside of 
the main app that basically handles what the app  
38:22 - displays when it gets opened through a widget 
url or any kind of deep link for that matter  
38:28 - first of all we will have a look at the widget 
url modifier because it's a tiny bit easier to use  
38:34 - for that we just have to add it as the last thing 
in our medium size view so the widget url modifier  
38:43 - which needs a url and we will construct that 
right now from a string i will tell you about  
38:49 - this once we yeah basically parse the url in the 
main app then you will see how all of this works  
38:56 - basically what i usually do as the scheme i will 
just say the app name so just my app in this case  
39:04 - colon slash slash then the different routes 
basically so here we'll have slash to do slash and  
39:13 - then the identifier of a to do which we will later 
on get dynamically from our timeline provider  
39:20 - right now i will just hard code this to be one 
okay and that's already the widget url modifier  
39:26 - this is all we have to add to our widget to open 
a specific thing inside of our app or to at least  
39:32 - tell the episode because right now the app doesn't 
handle anything befo before we do that let's have  
39:37 - a look at the link view for our large size view 
for that we will grab our entire h stack here copy  
39:46 - it and embed it in a link with a destination url 
and then as the label we will just paste back in  
39:55 - the hdac and now you can already imagine this url 
is basically the exact exact same thing as before  
40:02 - but the main difference is in the widget url 
modifier you can pass in an optional url which is  
40:09 - uh happening here because the string initializer 
always gives back an optional url but in the link  
40:16 - view you will need to pass in a non-optional 
url so we will have to false unwrap this here  
40:23 - in a real application you might not want 
to do that you might want to construct a  
40:27 - url at a different place be sure that it 
exists and then pass it into your view  
40:33 - for now in here we can basically put the exact 
same url as we had in our medium size view  
40:41 - once again this identifier here is hard coded 
right now we will replace this with the identifier  
40:46 - of that specific to-do item later on all right 
that's already everything that we need to set up  
40:53 - in our two widget views so we can close those 
up now and we have to move into our main app in  
41:00 - our content view now we will now have to add the 
unopened url modifier at the end of our content  
41:07 - view here and this basically gives us a closure 
passing in the url that the app called when it  
41:14 - was opened from a url this is basically not called 
when the app is launched regularly this is only  
41:20 - called in our case if the app is launched through 
the widget so if the user tapped on the widget  
41:26 - then this closure here will get called and now 
our task is it to parse the url make sure that  
41:33 - it's in the correct format download the data that 
we want to display and then display that data  
41:40 - so first of all let's make sure that this url is 
correct so we will have to check if the scheme  
41:47 - is correct and the scheme in our case needs to be 
my app so if we um one last time go back into one  
41:55 - of our views the scheme is basically this right 
here in a web url this would be https for example  
42:02 - next up we will have to check that the host is 
to do url.host equals to to do that's basically  
42:13 - this route that i mentioned before and then lastly 
we need to extract the identifier so let's say  
42:21 - that id equals an int from our urls path component 
number one so let's just say path components at  
42:33 - the position one and that will be the number here 
at the very end which we hard coded right now  
42:40 - but will then be filled in from our actual to-do's 
now that we have all of that um let's make sure  
42:48 - that in case any of this is um yeah is not working 
we will just return of the closure and do nothing  
42:57 - you can also print that there is an issue here 
in case you want to debug it somehow okay now  
43:04 - we have everything that we need basically that's 
just the id both of these are just arrow checks  
43:10 - now i've already told you about this in the 
first lesson we will use the get to do function  
43:17 - of our to-do servers i've told you that this 
is using the new search concurrency features  
43:22 - and that it is an asynchronous function that can 
throw errors but in the end returns us a single  
43:27 - to do with that identifier that we pass into the 
function so let's use that and since we're not  
43:34 - in an asynchronous context context we need to 
first of all create a task i already told you  
43:41 - this function can fail so we need to wrap it in 
a do catch block and then for now we will just  
43:48 - print the error but in reality you should handle 
the error in an adequate way now let's get to the  
43:59 - meat so we want to download our to-do from our um 
yeah our service so let's say let to do equals try  
44:08 - to await all of this with concurrency stuff we 
already talked about this in the first lesson if  
44:13 - you want to learn more about this just check the 
source concurrency um lessons they will be linked  
44:18 - down below so we will try to await the to do 
service we have a shared instance here the get to  
44:25 - do function with the identifier that we extracted 
out of the url here so let's just pass in that id  
44:33 - once that finishes once the await is done 
basically we need to switch back to the main queue  
44:40 - because this can happen in any queue and now we 
want to update our ui so we need to be on the main  
44:47 - queue for that and if you remember from the first 
lesson we have this state of the selected to do  
44:54 - here and if we set that to a to do then a sheet 
will be shown with information about that to do  
45:01 - so we can just say selected to do equals our to-do 
that we just loaded with our get to do function  
45:10 - okay this was a lot of talking a lot of code 
let's run it in the simulator and see how it works  
45:16 - okay so first of all let's have a quick look at 
the widget kit chorus app here okay everything  
45:22 - still looks good now let's have a look at the 
medium-sized widget remember we added the widget  
45:29 - url modifier here so you can tap anywhere inside 
of the widget then the app will open up and it  
45:35 - will tell us all of the information about the to 
do with the identifier one because that's what we  
45:41 - always passed in here as a hard-coded identifier 
and then if we close that again go to the home  
45:48 - screen and now over here in the large size widget 
you will have to have a very yeah a sharp eye here  
45:58 - if you click on the individual cells then they 
will get highlighted a tiny bit like a button and  
46:04 - the app will get open so let me click on the third 
cell here you saw there was that little subtle  
46:08 - button button click animation now the app opened 
again and we once again see information about the  
46:14 - to do number one because that's just what we hard 
coded okay so in this lesson you learned about  
46:19 - different size classes in widgets and how to show 
different ui components for those you also learned  
46:25 - about deep links using widget url link and on open 
url in the main app learn how to provide data to a  
46:34 - widget by reusing a service class from the main 
app and how to schedule that data in a timeline  
46:42 - hey code crew this is floor in this lesson we 
will finally fill up the widgets with some life  
46:48 - as we use the existing to-do service from the 
main app we will also fill out the timeline  
46:53 - provider and talk about different ways to schedule 
content for your widget so let's get right into it  
46:58 - before we can start filling out the timeline 
provider we need to do a few setup things as  
47:03 - i already mentioned we will want to reuse the to 
do service in order for us to be able to reuse the  
47:09 - to do service in our widget extension it needs 
to actually be a member of the widget target  
47:14 - right now let's open up the file inspector on the 
right hand side and then under target membership  
47:20 - you can see that the to do service is only a 
member of the main app target so let's also add  
47:25 - it to the widget extension this is one of the 
two files that we need to add the second one  
47:31 - is to do itself as you can see we will return 
arrays of to-do's and signal to do's in order  
47:37 - to do servers so we definitely also need to have 
the to-do struct inside of our widget extension  
47:43 - so let's go over to that file and make sure that 
it's also a member of the widget extension next up  
47:51 - we need to do one more setup step before we 
can implement the timeline provider and that is  
47:55 - adding the data to our timeline entry you already 
learned about the importance of the timeline entry  
48:02 - this is basically what is carried throughout the 
timeline and provided to your widget by the system  
48:07 - at the correct date with the correct information 
the date is already specified here which is a  
48:14 - requirement from the timeline entry protocol 
now let's also add the information and that's  
48:20 - the to do's that should be shown at a specific 
date in our widget so let's just add a to-do  
48:29 - array here to our simple entry now we can actually 
use this entry to schedule updates in our widget  
48:36 - using our timeline provider so we can close 
the simple entry here you can also close  
48:43 - the to-do over here as you can see now it 
doesn't compile anymore because we changed  
48:49 - the requirements for our simple entry it now needs 
a date but it also needs a to do so let's try to  
48:57 - fix all of these issues and at the same time i 
will explain you how each of these functions work  
49:03 - briefly let me explain to you the 
placeholder function and actually  
49:07 - let's not make me explain it to you let's just 
have a look at the definition oops the definition  
49:14 - of the timeline provider and then you can see 
there are very very long descriptions of each  
49:20 - of the functions for the placeholder function the 
getsnapshot function and the gettimeline function  
49:26 - the placeholder function provides a timeline entry 
representing a placeholder version of the widget  
49:32 - this is for example used when you display when 
your widget renders for the first time it can  
49:37 - also be used in a widget gallery but i think there 
they actually use the get snapshot function now so  
49:44 - basically we don't really need to care about what 
we return in the placeholder function as it's just  
49:49 - a placeholder while the actual widget is loading 
so let's add the to-do's here to our simple entry  
49:59 - and to make life easy for us let's create an 
extension on to do to create some preview or  
50:05 - some placeholder to do's with a given id so let's 
go back into the to do definition let's create an  
50:13 - extension of to do and in here let's create a 
function called placeholder that takes in an  
50:24 - id which is an integer and returns a to do 
for us and now we can use this in our um get  
50:31 - place or in our placeholder function and also in 
other places later on for example for previews  
50:37 - the function is really easy just construct a to-do 
here using any user id it's just a place how that  
50:44 - really doesn't matter what's important is that 
the id is unique because the to-do is identifiable  
50:50 - we have a list iterating or for each iterating of 
all of the to do's in our large size widget so it  
50:58 - is important that the ids are unique and that's 
why we're passing in a id here in the placeholder  
51:03 - function let's just pass that right into the to 
do for the title let's just say placeholder and  
51:09 - for completed let's just say a random boolean so 
either one or two either true or false okay now  
51:18 - that we have this placeholder function back in our 
provider we can now use that placeholder function  
51:24 - here to fill out our list of to do's let's 
make one with the id 0 and one with the id 1  
51:31 - and then that should be good in our placeholder 
function here next up is the get snapshot function  
51:38 - here we also have to create a simple entry or 
one single entry but instead of returning it like  
51:46 - we're doing in the placeholder function we need 
to call the completion handler with this entry  
51:52 - so very similar but now this can actually 
be called on your actual widget so we cannot  
51:57 - use placeholder data here anymore instead we will 
use our to do service to get all to do's for that  
52:06 - let's remove everything that is auto-generated 
here and since our to-do service uses the new  
52:12 - async await pattern let's directly start off by 
constructing a task so we can use asynchronous  
52:19 - stuff and i can already spoiler it to you we will 
also need to catch some errors so we can also  
52:25 - directly add a new catch block here now inside 
of the do block let's fetch the to-do's from our  
52:32 - to-do service so let's say let to do's equal 
try to await to do service dot shared dot get  
52:43 - all to do's you already know this we already used 
this or i already explained to you how this works  
52:51 - next up let's construct a simple entry so 
let's say let entry equals a simple entry  
52:59 - with the date of now and to do's of the to-do's 
that we just fetched here and then let's call the  
53:09 - completion handler with that timeline entry 
so let's just say completion with the entry
53:18 - in the catch case however we also want to call the 
completion block this case this time let's also  
53:26 - return some placeholder so let's just say  
53:30 - completion simple entry with the date 
of now and to do's we will just use
53:39 - placeholder zero now you can see here 
that the instance member placeholder  
53:46 - cannot be used and that's because we 
forgot to say that this is a static  
53:51 - function so we can directly call it on the type 
to do instead of a specific instantiated to do  
53:59 - now these errors should also go away 
okay awesome now the last part which  
54:05 - is also the most interesting and most 
important is the get timeline function  
54:10 - let me remove everything and then let's go through 
the function step by step so you understand how it  
54:16 - works similar to before we also have a completion 
handler but this time the completion handler  
54:22 - doesn't accept one entry it actually accepts a 
timeline of entries that timeline is a collection  
54:29 - of entries like an array but it also has a 
refresh policy that's the last thing that we will  
54:36 - handle when setting up this get timeline function 
first of all let's do the same setup as before we  
54:41 - know we're going to use the to do service so we 
will need a task we also need a do catch block  
54:49 - inside of the do block let's fetch all to do's 
once again so let's say let all to do's equal try  
54:57 - await our to-do service dot shared dot get all 
to do's this is the exact same stuff as before
55:07 - then let's actually do a little trick here  
55:10 - if you remember in our widget ui we will show a 
bunch of different to-do's in our large size view  
55:17 - this ui is meant for small amounts of data not 
for large amounts of data the ui will break if  
55:24 - you pass in let's say 50 to do's because then 
the top bar will get pushed out of the screen  
55:31 - so we will just um use the first five to do's 
that we get from the service so let's say let  
55:41 - five to do's equal an array oops an array 
of our all to do's dot prefix of the length  
55:52 - five this will give us the first five 
entries of the all to do's array that is  
56:00 - not actually returning an array it's 
returning an array slice but we need an  
56:05 - array so we will construct a new one here 
next let's also create a timeline entry  
56:13 - so we will just create a new simple entry for 
the date of now with our five to-do's in it up  
56:22 - until now this is very similar to the get snapshot 
function and actually we should probably use this  
56:27 - prefix 5 approach in the get snapshot 
function as well so let me copy it over  
56:33 - and do it like this okay to make sure that the 
get snapshot function also doesn't break the ui  
56:41 - okay so now we have our to-do's we have our 
simple entry now what we need is a timeline  
56:47 - and there are a couple of different ways to 
do this now one way is to create a bunch of  
56:53 - different entries for example for right now in 
one hour in two hours and five hours and so on  
56:59 - and pass all of them into a timeline and 
tell the timeline timeline to refresh  
57:04 - once nothing is left in it anymore so in our 
case in five hours or what we are going to do  
57:11 - construct a timeline with a single entry and tell 
it to refresh after some specific date has passed  
57:18 - the idea is basically if you have content that you 
can already schedule right now throughout the day  
57:23 - for example if you already have the users calendar 
you can schedule the whole calendar widget for the  
57:29 - whole day but if you rely on live data that 
you download from the server which is what  
57:33 - we're doing in our to-do servers then it is 
always a good idea to only schedule one or  
57:41 - two maybe three timeline entries and then force 
the timeline to refresh that way you will always  
57:47 - have the most up-to-date information so we 
will do the later we will create a timeline
57:56 - and this will accept an array of entries so 
we will just create an array with our single  
58:02 - simple entry in it and then for the policy you can 
just hit dot as this is an enum very handy you can  
58:09 - see there are three different reload policies 
the first one is at end so the timeline would  
58:15 - reload when no more entry is left the second one 
is never i think this is very safe explanatory  
58:23 - this means that the app itself 
will never reload the timeline  
58:27 - but however it will get reloaded sometimes 
for example if the user restarts their phone  
58:32 - adds or removes the widget things like that 
the system decides when the timeline is really  
58:36 - reloaded you only tell the system your preferences 
basically as the developer and then the last one  
58:43 - is after a specific date which is what we will use 
and the date that we will use is now advanced by  
58:51 - basically 60 seconds times 60 times 
30 so basically every 30 minutes  
59:02 - this timeline should get refreshed in practice 
this will probably not happen every 30 minutes  
59:08 - since timelines only get refreshed when 
the user is actually on their home screen  
59:11 - so if the user has their device in standby for a 
few hours then the widget will never get refreshed  
59:17 - and will only get refreshed once they view the 
home screen again okay and now the last thing  
59:24 - let's call the completion handler with our 
timeline again okay now in the catch block  
59:30 - we will just have our placeholder data once 
again for that let's create some timeline entries  
59:37 - this is just an array of simple entry just 
uh one for now so let's say the date is now  
59:48 - and the to do's is dot placeholder with the id 0 
just one for now doesn't really matter hopefully  
59:56 - this catch block will never take place then let's 
also create a timeline which is just a timeline  
60:05 - with the entries array and with the reload 
policy we will just copy over the one from  
60:11 - up here basically what this would mean is that 
after 30 minutes try again to build a timeline  
60:18 - okay and then let's pass the timeline to the 
completion handler as well and with that our  
60:24 - timeline provider is already done now let's use 
all of these pieces of data that we pass into the  
60:31 - simple entries inside of our actual widget views 
to do that let's go to the medium size view okay  
60:39 - in our views previously we hard coded all of 
the data like the to do title and whether it  
60:45 - was completed but also the to do id down here in 
our deep link url in the medium size view we only  
60:53 - want to show one to do so to do that let's grab 
the v stack let's cut it out and in here let's  
61:01 - say if let to do equal our entry dot to do's dot 
first we will just access the first to-do let's  
61:10 - paste back in our v-stack now in here instead of 
this hard coded string let's say to do dot title  
61:18 - and instead of the completed let's say to do dot 
completed let's use the ternary operator here so  
61:26 - let's say if the to do is completed we want to say 
completed and else we want to say that it's open  
61:34 - as this is a unwrapping of the first object it 
might be nil so there might not be any to-do's in  
61:40 - the simple entry for example because we couldn't 
fetch any from the server because we succeeded  
61:45 - to fetch from the server but the server just 
returned an empty array in this case with the  
61:50 - json placeholder api this should never happen 
but in your main app you might want to put an  
61:57 - else block here as well and then display some 
error state you could for example say couldn't  
62:02 - load to do's try again later or something like 
that okay now let's also replace the hard coded  
62:09 - id here in our widget url for that let's say entry 
dot to do's dot first dot id this is optional but  
62:20 - we can't have an option in here so we will have to 
provide an alternative basically and we will just  
62:26 - null coalesce it with zero okay that's it for the 
medium size view let's jump into the large size  
62:33 - view as well okay in the large size view now if 
you remember we had this hard coded zero through  
62:41 - six range let's get rid of that and instead let's 
say entry dot to do's we don't need to provide  
62:49 - an identifier because we did mark our to do as 
identifiable itself and does have the id property
62:59 - okay let's go top to bottom here so the first 
thing that we need to replace is the id in our  
63:04 - deep link for that we can just say to do dot 
id and we actually need to grab the to-do in in  
63:12 - our for each for that to work then we had our if 
true here this of course should mean if to do that  
63:20 - completed only then we want to show that 
little check mark on top of the circle  
63:25 - and then i want to do the title also let's 
grab that one from the actual to do okay  
63:32 - that should be it let me spin up the simulator 
and let's have a look at if everything works  
63:37 - if we can see all of the to-do's and if the 
deep links still correctly link into the app  
63:43 - okay so as you can see it doesn't quite 
compile yet and that's because we still  
63:47 - have our preview down here which doesn't 
have the updated simple entry initializer  
63:53 - so we also have to pass in some to-do's 
into our little swift ui preview here  
63:58 - and let's also just use the placeholder function 
for zero and then also another one for one  
64:05 - and i think this should be it now yep looks 
good let's compile now and see if it runs
64:18 - okay so the simulator just launched and i added 
all of the widgets first of all here you can  
64:23 - see the medium size view it fetched one of our 
to-do's and if we tap on it then the app will  
64:29 - open up and the little cheat will come up with 
some more detailed information about that to do  
64:35 - and if we go back to the home screen and move 
over then we can see our large size widget which  
64:41 - also fetched the last five to do's as we specified 
using the prefix operator and if we tap on any of  
64:48 - these to do's then the fitting section will also 
open up and show up in the sheet because we passed  
64:56 - down the correct id in the deep link this was the 
final lesson of the three-part widget kit course  
65:02 - in this series you learned all the basics 
about widget kit how it works the way updates  
65:08 - are scheduled multiple size classes reusing 
existing code and deep linking into your app