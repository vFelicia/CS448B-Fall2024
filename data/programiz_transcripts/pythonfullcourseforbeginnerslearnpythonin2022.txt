00:02 - are you new to the programming world and
00:04 - haven't done any programming before or
00:06 - have you done some programming before
00:07 - whether in python or in some other
00:09 - programming language but want to learn
00:10 - python
00:11 - if the answer is yes then this video
00:13 - series is for you what's up guys my name
00:15 - is puneet i'm the co-founder of
00:16 - programmers i am also an oracle
00:18 - certified java professional and former
00:20 - microsoft most valuable professional
00:22 - i'm delighted to be an instructor for
00:24 - this video series in this series i'll
00:26 - teach you everything you need to know to
00:28 - get started in programming with python
00:30 - step by step let's get started
00:38 - before we begin let's answer an
00:40 - important question why learn python why
00:43 - not java c c plus plus are the dozens of
00:46 - programming languages out there
00:48 - let me answer this question first from
00:50 - the perspective of a programming
00:51 - beginner python is one of the easiest
00:53 - language to learn because of its easy to
00:55 - use syntax take a look at this program
00:57 - to add two numbers written in java you
00:59 - don't need to understand it yet
01:02 - now let's see how we would write the
01:04 - same program in python
01:06 - as you can see the python code looks
01:08 - much more readable the simplicity of
01:10 - python syntax allows you to focus on the
01:13 - logic rather than focusing on syntax
01:15 - that's the reason why python is taught
01:17 - as the first programming language in
01:18 - many many universities
01:20 - another reason to learn python is
01:22 - because of its growing popularity and
01:23 - applications python is used in machine
01:26 - learning web development data analysis
01:29 - scientific research automation and many
01:31 - more python is used by many companies
01:33 - such as google facebook netflix and so
01:36 - on it is also used by thousands and
01:38 - thousands of small companies so if
01:40 - you're looking for a job in programming
01:41 - you'll find plenty of opportunities if
01:43 - you know python now let's start learning
01:45 - python but before that we need to be
01:47 - able to run python i'll use an online
01:50 - tool created by the programmers team to
01:51 - run python online for this series let me
01:54 - open my browser and i'll go to the url
01:56 - that you can see on the screen i've also
01:58 - posted the link in the description below
02:00 - we will write python in this text area
02:02 - and when i hit run it will execute that
02:05 - code it's that easy
02:06 - you can use the same tool if you want or
02:08 - you can also use a beginner friendly id
02:10 - like tony to run python on your computer
02:13 - i'll also provide a link to run python
02:15 - on tony in the description below
02:17 - now that's out of the way let's write
02:19 - our first python program we will create
02:21 - a program called hello world if you do
02:23 - not know a hello world is a simple
02:25 - program that displays hello world on the
02:27 - screen
02:28 - since it's a very simple program it is
02:30 - used to introduce a new programming
02:31 - language to beginners let's write the
02:33 - hello world program i'll type print
02:36 - parenthesis quotation marks and hello
02:39 - world and when i press run then hello
02:42 - world is printed to the screen
02:44 - before ending this video i have a pro
02:46 - tip for you the only way you can learn
02:48 - programming is by writing code
02:50 - i highly recommend you to write this
02:52 - program and run it on your own if you
02:54 - have tried writing the program and got
02:55 - the output give yourself a pat on the
02:57 - back because you have just created your
02:59 - first program in python
03:02 - if you haven't watched the previous
03:03 - video from this series i highly
03:05 - recommend you watch that first on my
03:07 - screen i have the program from the last
03:09 - video i'll go ahead and run it first
03:12 - as you can see hello world is printed
03:15 - this program is using the print function
03:17 - to print whatever is in between the
03:19 - parentheses
03:20 - in this case hello world is a string a
03:23 - string is simply a sequence of
03:25 - characters either one or many and is
03:27 - always wrapped inside quotation marks
03:29 - now let me take this upper notch and
03:31 - print another string this time i'll use
03:33 - double quotes instead of single quotes
03:35 - so i'll say print
03:37 - oops
03:38 - print
03:39 - python 3 is awesome
03:42 - and this time when i press run then as
03:44 - you can see both hello world and python
03:47 - 3 is awesome are printed
03:49 - now you can use either single or double
03:51 - quotes for strings they're basically the
03:53 - same however you cannot do something
03:55 - like this so i'll change this to single
03:57 - quote and when i press run this time
04:00 - python shows me an error you cannot mix
04:02 - and match single and double quotes
04:04 - so i'll change this back and make this
04:06 - double quote when i press run then you
04:08 - can see the same output as before
04:11 - another data type that's heavily used in
04:13 - python is the numeric data and there are
04:15 - two commonly used numeric data in python
04:17 - integers and floats the difference
04:19 - between integer and float is that
04:21 - integer is a whole number and float is a
04:23 - decimal we can use the print function to
04:26 - print integers and floats as well let me
04:28 - give you an example quickly
04:30 - so i'll say i'll remove this old code
04:32 - and i'll say print 5
04:35 - and i'll also write print
04:37 - 34.5
04:39 - when you run the code the integer 5 and
04:42 - 34.5 and the floating point number 34.5
04:45 - are printed
04:46 - one thing to remember is that if you use
04:48 - a number with quotations it's
04:49 - technically a string
04:51 - so if i surround
04:53 - five by quotes
04:54 - five here is a string and not a number
04:57 - i'll go back and remove this quotation
04:58 - marks for now
05:00 - till now we learned about strings and
05:02 - numeric data and how to print them in
05:04 - the real-world scenarios we may need to
05:06 - store and use this data in our program
05:08 - and not just print them in order to
05:10 - store data and use them later in our
05:12 - program we use something called
05:13 - variables before explaining more about
05:16 - variables let me give you an example
05:18 - so i'll remove the old code and i'll say
05:21 - city
05:23 - kathmandu
05:27 - here i've created the variable city
05:30 - and this variable stores a string data
05:32 - katmandu
05:34 - to store the data in a variable we are
05:36 - using the equals operator
05:39 - now instead of printing the string
05:40 - directly i'll print the city variable
05:43 - and see what we'll get
05:45 - so i'll say print
05:47 - city and this time when i press run
05:50 - then kathmandu is printed to the screen
05:52 - again
05:54 - this is because the city variable stores
05:56 - the string data kathmandu
05:58 - now technically speaking the city
06:00 - variable does not hold the kathmandu
06:02 - string when we write city equals
06:04 - kathmandu city is actually referring to
06:06 - the string kathmandu now storing data
06:08 - and referring to the data may seem like
06:10 - similar concepts but they are very
06:12 - different in python we will learn more
06:14 - about what referring actually means in
06:16 - detail in the future videos
06:18 - for now we'll continue to say that city
06:20 - stores kathmandu for simplicity
06:22 - now let me modify this program and
06:24 - instead of city i'll print city inside
06:27 - quotation marks and see what we get
06:30 - so i'll say city
06:32 - and this time when i press run then
06:34 - instead of kathmandu the string city is
06:36 - printed
06:37 - if i replace the quotes again
06:40 - and press run then this time again
06:41 - kathmandu is printed we can also change
06:44 - the data of variable holds after we
06:46 - print the city let me change the city to
06:48 - new york and print it again
06:50 - so i'll say city equals
06:53 - new york
06:55 - and i'll say print
06:56 - city
06:57 - now this time when i press run
07:00 - then it prints both kathmandu and new
07:02 - york let's try to understand what's
07:04 - happening here
07:05 - on line 1 when i say city equals
07:08 - kathmandu then city holds the string
07:10 - kathmandu
07:12 - on line 2 when i say print city then
07:14 - since the current value of city is
07:16 - kathmandu that's what gets printed
07:19 - on line 4 i change the value that the
07:21 - variable city is holding to new york
07:24 - on line 5 when i print city then since
07:26 - the current value of city is new york
07:29 - that's what got printed on the screen
07:31 - as you can see we can change the value
07:33 - of a variable which is why they are
07:35 - called variables i hope that makes sense
07:38 - it is also possible to assign a value of
07:40 - one variable to another let me give you
07:42 - an example so i'll remove this code and
07:45 - i'll add another variable called
07:47 - destination underscore city equals
07:52 - new york
07:53 - now let me try something different i'll
07:55 - say city
07:56 - equals destination underscore city
08:00 - and when i print city
08:02 - then you must have guessed by now when i
08:04 - press run then it prints new york not
08:07 - kathmandu this is because the value of
08:10 - now city is now the value of destination
08:12 - city which was new york
08:15 - we can also assign numeric data to
08:17 - variables in a similar way we assign
08:19 - strings to variables let's take a look
08:21 - at it
08:22 - so i'll remove this code and i'll say my
08:27 - favorite
08:28 - number
08:29 - equals 5. now let me print this quickly
08:32 - so i'll say my
08:33 - favorite
08:35 - number i'll print that now let me create
08:38 - another variable called pi and i'll say
08:40 - pi equals 3.14 and let me print pi
08:44 - and now let me do the same thing i did
08:47 - before with strings so i'll change
08:49 - my favorite
08:50 - number
08:53 - to pi and then i'll print my
08:57 - favorite number now this time when i
08:59 - press run then i get 5 3.14 and 3.14
09:04 - again
09:05 - this is because on line 2 the value of
09:07 - five my favorite number was five on line
09:10 - five the value of pi was three point one
09:12 - four and on line eight when i print my
09:15 - favorite number its value has been
09:17 - changed to the value of pi which is
09:18 - three point one four
09:21 - if you need to print more than one
09:23 - variable and data in a single print
09:25 - statement we can separate them by commas
09:27 - let's take an example
09:29 - so i can say print
09:32 - city
09:33 - and i can put a comma here and i can say
09:35 - kathmandu
09:37 - here we are printing two strings city
09:39 - and kathmandu in a single statement
09:42 - one thing to notice here is that when we
09:44 - print objects separate by commas python
09:46 - adds a space in between them by default
09:49 - so when i press run then as you can see
09:51 - it prints city and kathmandu but you can
09:54 - also see that there's a space in between
09:56 - which was not there here and here we can
09:59 - also print variables and strings in a
10:01 - single statement i'll show you an
10:03 - example
10:04 - so i'll say
10:06 - city equals
10:08 - kathmandu
10:10 - and i can say something like print
10:13 - city and instead of string kathmandu i
10:15 - can do the variable city when i press
10:18 - run then i get the same output as before
10:20 - because the value of the variable city
10:22 - which was kathmandu is replaced in the
10:24 - print
10:26 - let's try one last example
10:28 - so i'll add another variable called kfc
10:31 - underscore locations the value of which
10:33 - is 3
10:35 - and then i can say print
10:38 - city
10:40 - the variable city
10:41 - and then
10:42 - kfc
10:44 - locations
10:46 - comma kfc underscore locations
10:50 - here the city string the city variable
10:53 - the kfc location string and the kfc
10:56 - underscore locations variable are
10:57 - printed in one print statement i'll
11:00 - press run and as you can see all four
11:02 - are printed one by one and separated by
11:05 - space
11:06 - that means the comma operator can be
11:09 - used to separate not just two but any
11:11 - number of objects and python will print
11:13 - them all
11:15 - at this point we have covered all the
11:17 - basics of variables before ending this
11:19 - video let's talk about how to choose a
11:21 - good variable name
11:23 - if you have noticed in our programs we
11:25 - have used simple and descriptive
11:27 - variable names like city kfc underscore
11:30 - locations and destination underscore
11:32 - city
11:33 - we can give variables like c instead of
11:35 - city it works just fine however it is
11:38 - hard to understand what c means just by
11:40 - looking at the code so i can replace
11:42 - city by c here and here as well and i
11:45 - can run the program and i'll get the
11:46 - same output but here you can see for
11:49 - yourself that it is very confusing to
11:51 - know what c really means
11:53 - when we use good descriptive variable
11:55 - names it becomes easier to understand
11:57 - the code to make variable names
11:59 - descriptive we may need to use names
12:01 - having more than one word
12:03 - in that case you can separate the
12:05 - variable name by an underscore like
12:07 - destination underscore city in our
12:09 - program by the way there are some rules
12:11 - you need to know while creating a
12:13 - variable rule number one you cannot
12:15 - create a variable name with space in
12:17 - between like this
12:20 - you also cannot start a variable name
12:22 - with a number
12:23 - rule number three you cannot use certain
12:26 - words as a variable name
12:28 - you cannot use else as a variable name
12:30 - because else is a keyword
12:32 - these keywords have special meaning in
12:34 - python and are part of the python syntax
12:37 - we will learn more about these keywords
12:39 - as we progress through the course
12:41 - before we end this video here's a recap
12:43 - of what we learned we learned about
12:45 - three most common data types in python
12:47 - strings integers and floats a string is
12:51 - a textual data surrounded by codes
12:53 - integers and floats are numeric data
12:56 - integers are whole numbers and floats
12:58 - are decimals
13:00 - we also learned about variables
13:02 - variables allow us to store data so that
13:04 - we can use them later in the program
13:07 - it's possible to change the value a
13:09 - variable can hold
13:11 - and last but not the least we learned to
13:14 - give good descriptive names to variables
13:16 - by the way you can find all the programs
13:18 - from this video on github i've provided
13:20 - the link in the description below feel
13:22 - free to copy the programs and edit them
13:24 - as you please if you're enjoying this
13:25 - video please also check out programs pro
13:28 - where we provide tutorials along with
13:30 - quizzes and challenges which will help
13:31 - you practice and test your learning in
13:33 - real time also the course includes
13:35 - projects to give you an awesome
13:36 - experience of how programming works in
13:38 - the real world and for our youtube
13:40 - subscribers we are giving 50 off on the
13:42 - yearly plan sign up by scanning this qr
13:44 - code or use the link in the video
13:45 - description to claim your discount
13:49 - in the last video we learned to create
13:52 - variables so that we can store data and
13:54 - use them later in the program let me
13:56 - give you an example quickly so i'll go
13:58 - to my compiler and i'll say name
14:00 - equals
14:02 - felix
14:04 - and i can say print
14:05 - name
14:06 - now when i run the code as expected
14:09 - felix is printed to the screen
14:12 - now if you're a skeptic like me you must
14:14 - be thinking this is pretty useless right
14:16 - in the real world we will typically ask
14:18 - the user what the name is instead of
14:20 - putting it ourselves let's see how we
14:22 - can do that
14:23 - to take input from the user we use
14:25 - python's input function so i'll replace
14:28 - this felix by the input function
14:30 - and this time when i press run then
14:33 - python waits for me to input something
14:35 - here i'll type felix as before and when
14:38 - i press enter then i get felix back
14:41 - let's try to understand what's happening
14:43 - here when i pressed enter then whatever
14:46 - i had typed that is the string felix is
14:49 - stored in the variable name and on line
14:51 - 2 when i print name then that the value
14:54 - of that variable name which is felix is
14:56 - printed back
14:58 - this program to take input from the user
15:01 - is working correctly however we haven't
15:03 - provided any clue to the user on what to
15:06 - enter
15:07 - let's change that as we are trying to
15:09 - ask the user for their name inside the
15:12 - input function i will type
15:14 - enter
15:15 - name
15:16 - and when i press run then this time
15:19 - python gives me a hint on what to enter
15:21 - so i'll say felix as before and when i
15:24 - press enter then this string felix is
15:26 - stored in the name variable and when i
15:28 - print the name variable it gives me back
15:31 - felix again
15:32 - now instead of a string let's try to
15:34 - take a numeric input from the user this
15:36 - time let me modify this program so i'll
15:40 - replace name by number
15:42 - and obviously replace the variable names
15:44 - as well
15:47 - and now when i press run
15:49 - then this time i'll enter number five
15:52 - as expected 5 is printed back to the
15:55 - screen
15:56 - it's that easy or is it
15:59 - well the input function takes the input
16:01 - in the string form when we enter 5
16:04 - rather than the integer 5 the string 5
16:07 - is stored in the number variable
16:09 - we are getting 5 without quotations
16:11 - because the print function always hides
16:14 - the enclosing quotations when we print a
16:16 - string we can know for sure it's a
16:18 - string rather than a number by using the
16:21 - type function
16:23 - the type function returns the type of a
16:26 - variable
16:27 - inside the print function i'll wrap the
16:29 - number variable by the type function
16:32 - and this time when i press the run
16:34 - button then it says enter a number and
16:36 - when i press 5
16:37 - and press enter it says class str
16:42 - let's see what we get when we print the
16:44 - type of integers and floats i'll remove
16:47 - this code for now and i'll say number
16:49 - one
16:51 - equals
16:52 - five
16:53 - and here i'll say print type of number
16:55 - one
16:56 - let me create another variable number
16:58 - two
16:59 - and this time i'll say
17:01 - 5.5 and i'll say print number two
17:06 - now when i press run
17:08 - then it says class int and class float
17:11 - here number one is an integer and number
17:14 - two is a floating point number that is
17:16 - why when i run the code you can see that
17:18 - we get class in first which is
17:20 - representation of the type of number one
17:23 - and we get class float second which
17:25 - represents the type of number two which
17:27 - is a floating point number
17:29 - let's get back to our original code of
17:31 - taking numeric input from the user
17:36 - we still haven't solved the problem of
17:38 - taking integer and float input from the
17:40 - user
17:41 - in fact it's not possible to take
17:43 - integer and float input using the input
17:45 - function however what we can do is
17:48 - convert the string to a number after we
17:50 - take the input
17:51 - in this code after i take input from the
17:54 - user i will add a line to convert the
17:57 - string to an integer so here i'll say
18:00 - number
18:02 - equals
18:04 - integer
18:05 - number
18:06 - and now when i press run
18:07 - then it says enter a number i'll enter
18:09 - something like 5
18:11 - and it prints 5 but i have no way of
18:14 - knowing whether it is an integer or not
18:16 - so here i'll wrap this number by type
18:20 - and this time when i press run
18:22 - it says enter a number i enter 5
18:25 - and it says class integer which verifies
18:28 - that number indeed is now an integer
18:32 - in our code instead of adding this extra
18:34 - line to convert the string to an integer
18:36 - you can also do something like this
18:38 - so i'll remove this code
18:40 - and i'll add wrap this input function by
18:43 - the in function in the first line itself
18:46 - now when i press run then as usual it
18:48 - says enter a number i'll enter 5
18:50 - and the class it verifies that indeed
18:54 - the number variable is now an integer
18:56 - here we are taking input from the user
18:59 - converting it to an integer
19:02 - and then storing it in the number
19:03 - variable all at once
19:06 - we can also convert strings to floats we
19:09 - use the float function for that let me
19:11 - change this code and instead of integer
19:13 - i'll use the float function so here i'll
19:16 - replace the int function by the float
19:18 - function and when i press run then i can
19:21 - enter something like 5.5 and it says
19:24 - class float which means
19:26 - this input was converted to a float and
19:28 - that floating point number was stored in
19:30 - the number variable
19:33 - when we pass values we have taken from
19:34 - the user to int and float functions
19:37 - python tries to convert the data to its
19:39 - corresponding integers and floats
19:41 - in our programs we have converted the
19:44 - string 5 to an integer and the string
19:46 - 5.5 to a float
19:48 - these are numeric strings numbers in
19:51 - string format
19:52 - that's the reason it's possible to
19:54 - convert these strings to integers and
19:56 - floats
19:57 - however python cannot convert every
20:00 - string to numbers
20:01 - let's find out what will happen if we
20:03 - try to convert a non-numeric string to a
20:06 - number
20:07 - so here i have the same code from before
20:09 - and this time i'll press run and when it
20:12 - says enter a number i'll enter a string
20:14 - like felix
20:15 - when i press run then python tells me
20:18 - that it could not convert string to
20:20 - floor
20:22 - here python tried to convert felix to a
20:24 - floating point number but obviously it
20:26 - couldn't which makes kind of sense there
20:29 - is no way for python to know what's the
20:31 - equivalent floating point number for
20:33 - this felix string
20:35 - before we end this video here is a recap
20:38 - of what we learned we use the input
20:40 - function to take input from the user
20:42 - we can make the input function more
20:44 - descriptive by passing a string to it
20:47 - the input function always takes the
20:49 - input in the string form
20:51 - but we can convert a string to an
20:53 - integer using the int function similarly
20:56 - we can convert a string to a float using
20:58 - the float function
21:00 - if you try to convert non-numeric
21:02 - strings to integers and floats we will
21:05 - get an error by the way you can find all
21:07 - the programs from this video on github i
21:09 - posted the link in the description below
21:11 - feel free to copy the programs and edit
21:14 - them as you please
21:17 - comments are hints that we can add to
21:19 - our program to make our code easier to
21:21 - understand let's take an example
21:24 - i have this program to print a text
21:26 - entered by the user
21:28 - to make this program a bit more readable
21:31 - i can add a comment like this so i'll
21:33 - say
21:37 - program to take the
21:42 - user's input this line that starts with
21:46 - the hash symbol is a comment
21:48 - we added this line with the sole purpose
21:50 - of making sure that anyone who reads our
21:53 - code understands what's going on however
21:56 - python completely ignores them we can
21:58 - also place comments after the code like
22:01 - this
22:02 - so i can say
22:06 - take
22:06 - input
22:08 - and then i can say
22:10 - print the name
22:12 - variable
22:16 - let me run this program
22:18 - as you can see it says enter a name and
22:20 - i'll enter felix
22:21 - when i press enter then it says your
22:24 - name is
22:24 - felix you must have noticed that only
22:27 - these two statements are executed and
22:29 - even for these two statements these
22:31 - lines are simply ignored
22:35 - now let me remove these two comments
22:36 - from my
22:38 - program i am removing them because these
22:41 - two statements are self-explanatory and
22:44 - we do not want to make our code ugly by
22:46 - adding a lot of unnecessary comments
22:52 - we can also use comments to debug our
22:54 - code it is a common practice to comment
22:57 - out codes so that it is ignored rather
22:59 - than removing them completely let me
23:01 - give you an example
23:03 - let me write a program to take name and
23:05 - age input from the user so i'll remove
23:07 - this whole code and i'll say name
23:10 - equals
23:11 - input
23:13 - enter name
23:14 - and then i'll say age equals
23:17 - input
23:19 - enter is i want to convert it into an
23:22 - integer
23:24 - and then i will say print
23:26 - name is
23:30 - name
23:32 - and i will say print
23:35 - age is
23:38 - and then age
23:40 - suppose in this program it was not
23:43 - required for us to take age input from
23:45 - the user instead of removing these two
23:48 - lines what i can do is i can add a hash
23:51 - at the beginning of both of these lines
23:53 - so that they become comments and are
23:55 - ignored by the python compiler or
23:57 - interpreter
23:59 - let me run this program
24:01 - and as you can see it says enter a name
24:03 - i'll enter felix
24:04 - when i press enter then it says name
24:06 - equals name is felix but these two lines
24:09 - are completely ignored
24:11 - now later on if i want to use the age
24:14 - variable again or i need to accept that
24:16 - input from the user all i need to do is
24:18 - remove these two hashes and then they'll
24:20 - become statements instead of comments a
24:23 - little pro tip for you remember the
24:25 - keyboard shortcuts to apply comments in
24:27 - most text editors it's ctrl forward
24:29 - slash if you're in a windows and command
24:32 - forward slash if you're on a mac
24:34 - this will be very useful in debugging
24:36 - our code
24:40 - python doesn't have multi-line comments
24:42 - like other programming languages such as
24:44 - c plus and java however we can use the
24:48 - hash symbol at the beginning of each
24:49 - line to get the same effect
24:52 - suppose we have this code and we want to
24:54 - add comments to all three lines
24:56 - we can do that by selecting all three
24:59 - lines and pressing command slash since
25:01 - i'm on a mac as you can see all three
25:03 - lines have been converted to comments if
25:05 - i want these lines back then i can again
25:08 - select them
25:09 - and press
25:10 - command slash and they will be converted
25:12 - to regular python print statements
25:16 - you can also use multi-line strings as
25:18 - comments if you do not know we use
25:20 - triple quotes for multi-line strings
25:22 - like this
25:25 - when i press run our string is printed
25:29 - here we are assigning this multiline
25:31 - string i am a multiline string to the
25:34 - test variable and we are printing that
25:36 - test variable
25:38 - however if we do not assign strings to
25:41 - any variable it acts as a comment
25:43 - because python completely ignores
25:45 - unassigned strings for example i can say
25:48 - something like
25:50 - this
25:51 - program
25:53 - takes
25:54 - and integer
25:57 - input from the
25:59 - user
26:00 - and
26:01 - print set
26:03 - then i can write out my program like
26:06 - number equals int
26:08 - input enter and
26:12 - integer
26:14 - then as we have been doing a lot in this
26:16 - video series i'll say print
26:18 - u
26:19 - entered
26:22 - number here this string
26:25 - acts as a comment because it's not
26:28 - assigned to any variable
26:30 - let me run this code
26:32 - it says enter an integer i'll enter
26:34 - something like
26:35 - 7070
26:37 - and it says you entered 70.
26:40 - as you must have noticed these three
26:42 - lines are completely ignored by python
26:48 - now let's take a moment to discuss why
26:50 - comments are important imagine you're
26:52 - working on a year-long machine learning
26:54 - project for a client
26:56 - since you were on a tight schedule you
26:58 - decided to ignore comments
27:00 - anyways you successfully delivered it to
27:02 - the client and the client is happy about
27:04 - your work fast forward a couple of
27:06 - months a new government policy was
27:09 - introduced and the client wants the
27:11 - product to comply with that policy
27:13 - since you are the person who developed
27:15 - the app it's your responsibility to
27:17 - maintain it without comments you'll
27:20 - forget the reasons why you wrote a
27:21 - particular piece of code a certain way
27:23 - and you'll end up spending a lot of time
27:26 - looking at your own code trying to
27:27 - understand it
27:28 - comments are even more important if
27:30 - you're working in a group it makes it
27:32 - easier for other developers to
27:34 - understand and use your code that being
27:37 - said comments are not and should not be
27:39 - used as a substitute to explain poorly
27:42 - written code you should always try to
27:44 - write clean understandable code and then
27:47 - use comments as an addition
27:48 - before we end this video here's a quick
27:50 - recap of what we learned
27:52 - comments are hints that we can add to
27:54 - our program to make our code easier to
27:56 - understand
27:57 - python completely ignores them
28:00 - in python the hash symbol is used to
28:02 - write comments
28:04 - comments are also used for debugging
28:06 - code
28:07 - python doesn't have multi-line comments
28:09 - however you can use multi-line strings
28:12 - having triple quotes that act as
28:14 - multi-line comments
28:18 - in programming an operator is a symbol
28:21 - that is used to perform operations on
28:23 - values and variables we've already used
28:26 - the equals operator in our previous
28:27 - videos so we've been saying stuff like
28:29 - name equals puneet
28:32 - here the equals operator takes the value
28:34 - on the right and stores it in the
28:36 - variable on the left
28:38 - we'll get back to more assignment
28:40 - operators in a second let's start with
28:42 - arithmetic operators first
28:44 - we use arithmetic operators to perform
28:46 - arithmetic operations such as addition
28:49 - subtraction multiplication etc i'll copy
28:52 - a list of arithmetic operators here in
28:54 - my text editor so that it's a bit easy
28:56 - for us to use them
28:58 - let's try these operators one by one
29:00 - i'll start with the plus operator so
29:03 - i'll say something like x equals 5
29:06 - and then i can say result equals x plus
29:10 - 10
29:11 - and then i can print the result here
29:14 - i'll run this code and as you can see 15
29:17 - is printed
29:18 - what's happening here is 10 and the
29:21 - value of x which is 5 are being added by
29:23 - the addition operator and the equals to
29:26 - operator is storing the result of these
29:28 - in the result variable on line 12 when i
29:31 - print the result because its value is 5
29:33 - plus 10 or 15 that's what was printed
29:36 - instead of storing the result of adding
29:38 - 10 and x to the result variable we can
29:41 - also directly print the result like this
29:43 - so i can copy this and i can paste it
29:46 - here
29:47 - i'll remove the result variable for now
29:49 - and when i press run i get the same
29:51 - result because the addition operator
29:53 - still takes the value of x
29:55 - and 10 and adds them up and that's
29:57 - what's get printed by the print function
30:00 - but personally i think using a variable
30:02 - to store the result looks a bit cleaner
30:04 - than this so i'll revert back to the old
30:06 - code
30:10 - we have learned to perform the addition
30:12 - operator at this point now let's try all
30:14 - these operators one by one
30:17 - let me change plus to minus and run this
30:22 - as you can see minus 5 is printed
30:24 - because 5 minus 10 is minus 5.
30:29 - in python we use the asterisk symbol for
30:31 - multiplication so i'll replace this
30:34 - minus by asterisk and when i press run
30:37 - then 5 times 10 50 is printed
30:40 - similarly the forward slash is used for
30:43 - division
30:44 - so i'll replace this asterisk by slash
30:47 - and when i press run then 5 divided by
30:50 - 10 or 0.5 is stored in the result
30:53 - variable and that's what got printed
30:54 - here
30:56 - the symbols of these four operators
30:58 - addition subtraction multiplication and
31:00 - division are similar to symbols in
31:02 - mathematics let's try three more
31:05 - arithmetic operators
31:06 - the single asterisk is used for
31:08 - multiplication but if we use two
31:11 - asterisks without any space in between
31:13 - it's an exponent operator so i'll
31:16 - replace this slash with two asterisk and
31:19 - when i press run i'll remove this 10 and
31:21 - i'll make it 2 and when i press run
31:24 - then as you can see 25 is stored in the
31:26 - result because 5
31:29 - raised to the power 2 or 5 times 5 is 25
31:33 - the last two arithmetic operators are
31:35 - percent and two forward slashes
31:38 - using two forward slashes computes the
31:41 - quotient when one number is divided by
31:43 - another similarly the percent symbol
31:46 - computes the remainder when one number
31:48 - is divided by another let me give you an
31:50 - example
31:51 - so here i'll replace this
31:53 - result and i'll say quotient
31:56 - equals
31:57 - x
31:58 - double slash 2 and then i can say
32:01 - remainder equals x
32:04 - modulus 2 so the modulus this sign when
32:07 - used to calculate the remainder is
32:09 - called modulus
32:11 - and then i can say
32:12 - quotient
32:14 - is
32:16 - quotient
32:18 - and
32:20 - remainder is
32:22 - remainder
32:24 - when i press run
32:25 - then it says quotient is 2 and remainder
32:28 - is 1 that is because when 5 is divided
32:31 - by 2
32:32 - the quotient is 2 obviously because 2
32:34 - times 2 is 4 and the remainder 1 is
32:37 - stored in the remainder variable
32:40 - at this point we have covered everything
32:43 - we need to know about arithmetic
32:44 - operators when they are used with
32:46 - numbers before ending this section i
32:49 - have a pro tip for you
32:50 - we use a lot of operators in a single
32:52 - statement like this
32:54 - it's harder to understand which
32:56 - operation is performed first in this
32:58 - statement
33:00 - to avoid this we can use parenthesis so
33:03 - i can wrap these by parentheses
33:08 - like this
33:10 - and now it's so much easier to
33:13 - understand
33:16 - in the last section we use the plus
33:18 - operator to add two numbers
33:21 - the plus operator also serves another
33:23 - purpose in python it is used to join two
33:26 - strings let me give you an example so
33:28 - i'll remove this whole code and i'll say
33:30 - str1 equals
33:33 - hey
33:34 - and i'll say str2 equals
33:36 - jude and then i can print
33:39 - the concatenation of
33:41 - hay and jude like this when i press run
33:44 - then hey jude is printed it's working
33:47 - but let me add a space between hey and
33:49 - jude for that i can add a space at the
33:52 - end
33:53 - of hey and when i press run then as you
33:55 - can see there is a space now
34:01 - we have already used the most common
34:03 - assignment operator equals which is used
34:05 - to assign the value on the right to the
34:08 - variable on the left
34:09 - in python you can also do something like
34:12 - this
34:13 - so i i can say x comma y
34:15 - equals 5 comma 6
34:18 - here
34:19 - 5 is assigned to the x variable
34:22 - and 6 is assigned to the y variable in
34:25 - one statement
34:27 - so this code is equivalent to x equals 5
34:30 - y equals 6.
34:33 - personally i fee i feel this later
34:36 - syntax of x equals 5 and y equals to 6
34:38 - is better because it makes the code
34:40 - easier to read there are also some
34:42 - compound assignment operators in python
34:44 - these compound assignment operators
34:46 - combine arithmetic and assignment
34:48 - operators in one single place i'll show
34:51 - you an example so i'll remove this old
34:53 - code and i can say x equals 5 and i'll
34:56 - say x plus
34:57 - equals
34:59 - 10 and i'll also say x minus
35:03 - equals
35:04 - 10.
35:06 - this x plus equals 10 is equivalent to x
35:10 - equals to x plus 10.
35:13 - this plus equals to operator is called
35:16 - the addition assignment operator because
35:18 - it first performs the addition then
35:21 - performs the assignment
35:22 - similarly the x minus equal 10 is
35:26 - equivalent to
35:28 - x equals x minus 10.
35:34 - these compound assignment operators are
35:36 - available with all arithmetic operators
35:38 - there are also other numerous operators
35:40 - in python which we will learn about as
35:42 - we progress further in the video series
35:44 - if you are curious you can visit our
35:46 - website programmers.com for more
35:48 - information on python operators along
35:50 - with numerous examples the link will be
35:52 - in the description below let's put the
35:54 - things we have learnt in this video in
35:56 - action
36:00 - suppose you're a university student and
36:03 - you need to pay
36:04 - 4535 dollars tuition fee for the next
36:07 - semester
36:08 - the college is giving you a discount of
36:10 - 10 percent on early payment of your
36:13 - tuition fee
36:14 - since it's a very good offer you decided
36:16 - to make an early payment now can you
36:18 - find out how much money you have to pay
36:21 - i'll store the fee in a variable called
36:23 - fee so i'll say fee equals
36:25 - 4 5
36:26 - 3 5
36:28 - now my discount percentage
36:30 - will also go in a variable called
36:32 - discount percent and from here i can
36:34 - calculate the discount amount
36:36 - as
36:38 - discount
36:40 - percent
36:41 - by 100
36:43 - i'll add parenthesis to form clarity
36:47 - times
36:48 - the fee
36:50 - this should be discount amount
36:51 - and then i can say
36:53 - discounted underscore fee equals fee
36:57 - minus
36:58 - discount
37:00 - amount
37:02 - now let me print the discount amount so
37:03 - i can say print fee
37:05 - after
37:06 - discount is
37:08 - discounted underscore fee and when i
37:10 - press run then ik i get the correct
37:12 - value of the fee after discount
37:17 - now it's time for you to solve a problem
37:19 - can you create a program to convert
37:21 - distance in kilometers to miles
37:24 - suppose you have a distance in
37:25 - kilometers stored in a variable like
37:27 - this so i can say distance
37:30 - underscore km equals
37:33 - 564.5
37:37 - you need to convert this distance to
37:39 - miles using the formula
37:41 - 1
37:42 - kilometer
37:44 - equals
37:46 - 0.62133
37:48 - [Music]
37:50 - 7 1 miles
37:53 - you will find the answer to this
37:54 - question in our github repository i'll
37:57 - also put this link in the description
37:58 - below before we end this video here's a
38:01 - recap of what we learned today
38:03 - the most common assignment operator is
38:05 - the equals operator it is used to assign
38:07 - the value in the right to the variable
38:10 - on the left
38:11 - we use arithmetic operators to perform
38:13 - basic arithmetic operations such as
38:16 - addition subtraction etc
38:19 - if you use the plus operator with
38:21 - numbers it adds two numbers however if
38:24 - you use the plus operator with strings
38:26 - it joins two strings
38:28 - if you use multiple operators in an
38:30 - expression we can use parenthesis to
38:32 - make our code readable
38:36 - before we learn to use comparison
38:38 - operators we need to understand about
38:41 - booleans the boolean is a logical data
38:43 - type that represents one of two values
38:46 - either true or false let me give you an
38:49 - example quickly so on my compiler screen
38:52 - i'll say result 1 equals true and i'll
38:55 - say result 2 equals false
38:58 - then i can print result 1 and result 2.
39:04 - now
39:05 - here we have assigned a boolean value
39:07 - true to result 1 and a boolean value
39:09 - false to result 2.
39:11 - when we write true and false the first
39:14 - letter is always capitalized
39:16 - also make sure that you don't wrap true
39:18 - and false around with quotes otherwise
39:20 - they would be treated as strings
39:23 - now that we know about booleans let's
39:25 - learn about comparison operators
39:27 - python has a set of comparison operators
39:29 - that allow us to compare two values if
39:32 - the comparison is correct we get true
39:35 - and if the comparison is wrong we get
39:37 - false let me give you an example here
39:40 - the less than symbol is a comparison
39:42 - operator that is comparing the number
39:45 - variable and the integer 10.
39:48 - since the value stored in the number
39:49 - variable is 5 the expression number less
39:52 - than 10 is true and when i press run you
39:55 - can see that it indeed prints true
39:58 - if you change number to 15
40:00 - then the story is different so here i'll
40:02 - say number equals 15 and when i press
40:04 - run this time i get false because 15
40:07 - less than 10 is obviously false
40:11 - printing these boolean expressions like
40:12 - this has little to no use in the next
40:15 - video we will learn about the if
40:17 - statement that makes use of these
40:18 - boolean expressions and which allows us
40:20 - to run different codes depending upon
40:23 - whether a boolean expression is true or
40:24 - false however for the sake of this video
40:27 - we will focus on comparison operators
40:30 - back to comparison operators let me copy
40:32 - of list of all comparison operators in
40:35 - our text editor so that it's easier for
40:37 - us to use them
40:38 - so here i'll remove the old code and
40:40 - i'll paste the comparison operators
40:44 - we have already used the less than
40:46 - operator
40:47 - let's try these comparison operators one
40:50 - by one i will start with the greater
40:52 - than operator so here i'll say
40:55 - number
40:56 - equals 15 and i'll say print
41:00 - number
41:01 - greater than 10.
41:03 - when i run it this gives true because
41:06 - number which is 15 is obviously greater
41:08 - than 10 here
41:11 - now if i change the number to 10 and run
41:13 - this again
41:15 - then this time i get false because 10
41:18 - greater than 10 is false
41:20 - now let's see equal to and not equal to
41:23 - operators
41:24 - the equal to operator gives true if two
41:26 - values are equal so i can say number
41:29 - equals 10
41:31 - and i can replace this and say number
41:33 - equals equals 10
41:35 - so when i press run this time i get true
41:38 - because 10 and 10 are equal
41:42 - comparing a floating point value and an
41:44 - integer value which are equal also gives
41:46 - us true so here i can replace this by
41:48 - 10.0 and when i press run i still get
41:51 - true
41:53 - however the comparison of integer 10 and
41:56 - a string 10 gives us false so here let
41:58 - me replace this by the string 10
42:03 - and then this time when i press run
42:05 - i get false
42:08 - the not equal to operator is the
42:10 - opposite of the equal to operator if i
42:12 - change equal to to not equal to here
42:15 - then this time i'll get true
42:18 - because the string 10 is not equal to
42:20 - the integer 10.
42:22 - the last two comparison operators are
42:24 - less than or equal to and greater than
42:26 - or equal to let's try them in action
42:29 - so i'll replace this code with 10
42:31 - and then here i'll say number less than
42:34 - equals to 10
42:35 - the expression number less than equals
42:37 - to 10 returns true if either number is
42:40 - less than 10 or equal to 10.
42:43 - it combines two operators less than and
42:45 - equal to into one
42:48 - now i'll run the code and it returns
42:50 - true because number is equal to 10 and
42:52 - that also counts
42:54 - similarly there is also the greater than
42:56 - or equals to operator so here i could
42:58 - have done greater than equal to and when
43:00 - i press run this also works or this also
43:02 - returns true because of this equal to
43:05 - number equals equals 10 is true and
43:07 - that's why this is true now i could have
43:09 - changed this to something like 12 and
43:11 - this would still be true because number
43:13 - greater than 10 is true in that case
43:19 - python also has three logical operators
43:21 - and or and not for your convenience i
43:24 - have added here the list of all the
43:25 - logical operators and what they do let's
43:28 - start with the and operator i'll create
43:30 - three variables age equals 8 22
43:35 - gpa equals 3.8 and then i'll say a third
43:38 - variable result equals
43:40 - a is greater than equals 18 and
43:44 - gpa greater than 3.6
43:47 - here the and operator is telling me that
43:49 - the boolean expression is greater than
43:51 - equals 18 and gpa greater than 3.6 both
43:55 - have to be true for this overall
43:57 - expression to be true
43:59 - now let me print the result here and
44:01 - when i press run
44:02 - i get true this is because both of these
44:05 - expressions are true
44:07 - now let me show you how the and
44:08 - operation works by making the second
44:10 - condition false so here i'll change this
44:13 - to 3.9 and when i press run this time i
44:16 - get false this is because as i explained
44:18 - before both of the expressions have to
44:20 - be true the fact that the first
44:22 - expression is still true doesn't matter
44:24 - because the second expression is false
44:26 - and my result is now false
44:29 - now let's see the or operator i'll
44:31 - replace and with or in this code
44:35 - code means that if either this
44:37 - expression is true or this expression is
44:39 - true the overall expression should be
44:41 - true
44:43 - now when i press run i get true because
44:45 - although the second part of the
44:47 - expression is false the age greater than
44:50 - equals 18 is true and that is enough for
44:52 - the whole expression to be true
44:54 - of course both of these can be true and
44:55 - the result will always be true so i can
44:57 - say 3.6
44:59 - greater than 3.6
45:02 - and when i press run
45:03 - the overall expression is true because
45:05 - both of them are true
45:07 - and the final logical operator is not
45:10 - the not operator gives the complement of
45:12 - the result for example i'll replace all
45:14 - this code and i'll say result equals
45:16 - true
45:17 - and print result this time when i press
45:20 - run
45:21 - i get true but i can do not result and
45:24 - this time when i press run then i get
45:26 - false
45:27 - i can also do the reverse i can say
45:30 - result equals false and when i press run
45:33 - i get true because this result was false
45:36 - now result would also have been a
45:37 - boolean expression like age
45:39 - less than equals to 18
45:41 - and then i
45:42 - obviously i need an age variable 14 now
45:45 - when i press run then i get false
45:48 - because this expression is true and the
45:50 - not operator negates that result
45:53 - we have covered all the basics of
45:55 - comparison and logical operators at this
45:57 - point we'll be using these operators
45:59 - especially comparison operators
46:01 - extensively to create some interesting
46:03 - programs in the next few videos before
46:05 - we end this video here's a task for you
46:07 - can you guess the output of this program
46:09 - i'll give you a couple of seconds to
46:11 - pause the video and reflect on it
46:14 - as always you'll find the answer to the
46:16 - question in our github repository i've
46:18 - also included the link in the
46:19 - description below
46:21 - before we end this video here's a recap
46:23 - of what we learned the boolean is a
46:25 - logical data type that represents one of
46:27 - two values either true or false the
46:30 - comparison operators are used to compare
46:32 - two values if the comparison is right we
46:35 - get true and if the comparison is wrong
46:37 - we get false
46:39 - the logical operators are used on
46:41 - booleans
46:42 - there are three logical operators and or
46:45 - and not
46:48 - in python we use the if statement to
46:50 - create programs that can make decisions
46:52 - let's start with its syntax so on my
46:55 - screen you can see the syntax of the if
46:57 - statement the if statement evaluates the
47:00 - test condition
47:01 - which is a boolean expression if the
47:03 - test condition is true the body of the
47:06 - if statement is executed otherwise it is
47:09 - kept from execution
47:11 - notice the spaces before the statement
47:13 - here
47:14 - this indentation is used to
47:16 - differentiate between the body of the if
47:18 - statement
47:19 - it doesn't matter how many spaces or
47:21 - types we use for indentation however we
47:23 - need to be consistent with it
47:25 - generally it's considered a good
47:27 - practice to use four spaces for
47:29 - indentation
47:30 - now that we know the syntax of the if
47:32 - statement let's try a working example
47:35 - suppose you're a university student and
47:37 - to pass the examination you need to
47:39 - score 50 or more if you score 50 or more
47:43 - we will print you pass the examination
47:46 - let's see how we can implement this
47:47 - program so first i'll take the input
47:50 - from the user as score
47:52 - equals
47:55 - integer
47:56 - input
47:58 - enter
47:59 - your score
48:02 - then i'll say if
48:05 - score greater than equals 50
48:09 - print
48:10 - you have
48:11 - [Music]
48:14 - passed your
48:15 - exams let me add another print statement
48:18 - as a print
48:20 - congratulations
48:23 - let me run this program
48:25 - and here in the score i'll enter
48:27 - something like 75
48:30 - as you can see you have passed your exam
48:32 - and congratulations are printed to the
48:34 - screen when your score is 75 as in this
48:37 - example our test conditions score
48:39 - greater than or equal 50 is true and
48:42 - that is why these two statements are
48:45 - executed
48:47 - let me run this program again
48:50 - this time instead of 75 i'll enter
48:52 - something like 35
48:56 - so this time nothing is printed to the
48:58 - screen this is because since score is 35
49:01 - 35 greater than equals 50 is false and
49:04 - the body of the if statement is kept
49:06 - from execution our program is working
49:09 - correctly but it's not printing anything
49:11 - when the score is less than 50. we might
49:14 - want to print something like sorry you
49:16 - failed your exam during this case so i
49:18 - will add another if statement
49:21 - i'll say
49:23 - if
49:24 - score
49:26 - less than
49:28 - 50 print
49:32 - sorry
49:33 - you have
49:34 - failed your
49:35 - exam
49:37 - and we can see that when i press run and
49:40 - enter 35
49:41 - then it says sorry you have failed your
49:43 - exam
49:45 - this is because again this condition is
49:48 - false and this is skipped but this
49:50 - condition is true and this code is
49:53 - executed
49:58 - i have this code from our last section i
50:00 - have removed the code that takes the
50:02 - user input and instead i have hard coded
50:04 - the value of score so that we can focus
50:07 - on the logic of the if statement
50:09 - in this program we have used two if
50:11 - statements to perform two different
50:13 - tasks we know the student pass the exam
50:16 - if the score is greater than or equals
50:19 - 50. if the criteria is not met we know
50:21 - the student failed the exam
50:23 - in such cases instead of writing the
50:25 - second if statement with the condition
50:28 - we can use the else clause let's first
50:30 - look at the syntax of the if statement
50:32 - with the else clause on your screen you
50:35 - can see how it looks
50:37 - what happens here is that if our test
50:39 - condition is true these statements are
50:42 - executed and if it's false the
50:44 - statements inside the else clause are
50:46 - executed
50:48 - now getting back to our code to print
50:50 - whether the student passed or failed the
50:52 - exam
50:53 - in this program
50:54 - we know for sure that if the score is
50:56 - not greater than or equal to 50 then the
50:59 - student is failing the exam
51:01 - so instead of writing the second if
51:03 - statement we can replace the second if
51:06 - with else
51:07 - so here
51:08 - i'll remove this if and i'll write else
51:11 - and a colon here let me read this code
51:13 - in plain english
51:15 - if score is greater than or equal to 50
51:18 - then print you have passed your exams
51:20 - and print congratulations
51:22 - else print sorry you have failed your
51:25 - exam
51:26 - the else clause catches everything
51:28 - that's not covered in the if's condition
51:30 - now when i run this code
51:32 - you can see that sorry you have failed
51:34 - your exam is printed
51:37 - the if statement with the else clause
51:40 - allows us to make a choice from two
51:42 - different options but sometimes we need
51:45 - to make a choice from more than two
51:46 - options in those cases we can use the
51:49 - elif clause with the test condition
51:51 - let's see its syntax first
51:53 - the if statement checks the condition
51:55 - inside the if statement or the test
51:57 - condition 1 if it is true then this
52:00 - block of code is executed and statements
52:02 - 2 and statements 3 are skipped however
52:06 - if the first test condition is false the
52:08 - control of the program jumps to the
52:10 - second test condition
52:12 - if this test condition is true its body
52:14 - is executed and other statements are
52:17 - skipped
52:18 - if both test condition 1
52:20 - and test condition 2 are false finally
52:24 - the else body is executed
52:26 - if necessary we can add as many alif
52:29 - clauses as we want for our program to
52:31 - work and among all those alternatives
52:34 - only a single block of code is executed
52:37 - now we know how the alif clause works
52:39 - let's get back to our code to check
52:41 - whether the student passed a failed exam
52:43 - here this score variable stores the
52:46 - marks obtained by the student
52:48 - so it shouldn't be greater than 100 or a
52:50 - negative number if score is above 100
52:53 - our test condition is true and you have
52:55 - passed our exam and congratulations is
52:58 - printed even though the score is invalid
53:00 - logically and if score is a negative
53:03 - number sorry you have failed your exam
53:05 - is printed because our test condition is
53:07 - false
53:08 - again score shouldn't be less than zero
53:11 - we need to fix this
53:12 - we can fix this by adding a condition to
53:15 - check if the score is valid or not at
53:17 - the beginning
53:18 - only then we will check if the student
53:20 - passed or failed the exam so in my code
53:23 - i'll make the changes i'll let's try for
53:25 - 105
53:27 - and here i'll add a condition i'll say
53:29 - if
53:30 - score
53:31 - greater than 100
53:33 - or
53:34 - score less than 0
53:37 - then print
53:39 - score is
53:41 - invalid
53:42 - and then i'll turn this if into an alif
53:46 - and now i have put that condition to
53:48 - check if the score is valid or not
53:51 - now if score is greater than 100 or
53:53 - score is less than zero then score is
53:56 - invalid should be printed to the screen
53:59 - as long as score is a valid number our
54:01 - program should work correctly
54:03 - now if you remember this r is a logical
54:06 - operator which we discussed in the last
54:08 - video this test condition is true if
54:12 - either this part or score greater than
54:14 - 100 is true or this part score less than
54:18 - 0 is true
54:22 - as you can see the syntax of the if
54:24 - statement is pretty simple
54:26 - the harder part is the logic behind the
54:28 - test conditions and you will get better
54:30 - at creating test conditions with
54:31 - practice
54:32 - also be sure to check our video on
54:35 - comparison and logical operators that
54:37 - are used to create these test conditions
54:39 - i posted the link in the description
54:40 - below
54:42 - we have covered a lot of material in
54:44 - this video it's time for you to practice
54:46 - what we learned here is one programming
54:48 - challenge for you to solve now can you
54:51 - create a program to check whether a
54:52 - number is positive or negative or zero
54:56 - to create this program create a variable
54:59 - named number and assign a float value to
55:01 - it based on the user input
55:04 - then using a if statement check if the
55:06 - number variable is positive or negative
55:09 - or zero if the number is positive print
55:12 - the number is positive if the number is
55:14 - negative print the number is negative
55:17 - and if the number is zero print the
55:19 - number is zero you'll find the answer to
55:22 - this question in our github repository i
55:24 - posted the link in the description below
55:26 - since this video is already very long we
55:29 - will not explore nested effects in this
55:31 - video if you're interested you can find
55:33 - more information about the if statement
55:35 - in our website programmies.com along
55:37 - with numerous examples i posted the link
55:40 - in the description below before i end
55:42 - this video here's a recap of what we
55:44 - learned today
55:45 - the if statement is used to create
55:48 - programs that can make decisions
55:50 - the if statement evaluates a test
55:52 - condition if the test condition is true
55:55 - it executes the if body but if the test
55:58 - condition is false the if body is
56:00 - escaped from execution
56:02 - to specify the body of the if statement
56:05 - we use indentation in python
56:07 - the if statement can have an optional
56:09 - else clause the else clause is executed
56:12 - if the test condition is false
56:15 - if you need to make a choice from more
56:17 - than two alternatives you can add an
56:19 - optional alif clause with another test
56:21 - condition if you're enjoying this video
56:23 - please also check out programs pro where
56:25 - we provide tutorials along with quizzes
56:28 - and challenges which will help you
56:29 - practice and test your learning in real
56:31 - time also the course includes projects
56:33 - to give you an awesome experience of how
56:34 - programming works in the real world and
56:36 - for our youtube subscribers we are
56:38 - giving 50 off on the yearly plan sign up
56:40 - by scanning this qr code or use the link
56:42 - in the video description to claim your
56:44 - discount
56:47 - before we write the actual code of the
56:48 - while loop let's take a look at its
56:50 - syntax a while loop starts with the
56:52 - keyword while followed by a test
56:55 - condition
56:56 - followed by a colon
56:58 - then we write the body of the loop in
57:01 - the next lines
57:05 - notice the spaces before the body of the
57:07 - loop
57:09 - this indentation is important as it
57:11 - indicates the body of the loop
57:13 - here's how this pseudo code works
57:15 - python checks this condition which is a
57:18 - boolean expression that evaluates to
57:20 - either true or false if it's true the
57:23 - body of the while loop is executed
57:25 - at this point it's similar to the if
57:27 - statement
57:28 - however unlike an if statement that
57:30 - checks the test condition only once
57:33 - after executing the body of the loop it
57:35 - checks the test condition again
57:37 - this process goes on and on until the
57:39 - test condition evaluates to false
57:42 - if the test condition is never false the
57:44 - loop runs forever until the system's
57:46 - memory runs out let me give you an
57:48 - example so i'll remove this old code and
57:51 - i'll say count equals 0
57:54 - then i'll say while
57:56 - count
57:57 - less than 5
58:00 - print
58:01 - i am inside a loop
58:04 - let me add one more statement and say
58:06 - print
58:08 - looping is
58:10 - interesting
58:12 - let me run this program and as you can
58:14 - see these two print statements are
58:16 - executed again and again and again
58:21 - let's analyze what this program is doing
58:23 - here count equals 0
58:25 - in this line count less than 5 or 0 less
58:28 - than 5 is true that is why these two
58:31 - statements are executed
58:33 - now since this is the while loop it will
58:35 - again check the test condition
58:37 - again count or which is 0 less than 5 is
58:40 - true and again these statements are
58:42 - executed
58:43 - this happens again and again and this
58:46 - condition
58:47 - count less than 5 is never false
58:51 - so the loop runs forever
58:53 - this is known as an infinite loop
58:58 - however most of the time rather than
59:00 - running a loop forever and ever we want
59:02 - loops to end at some point let's say we
59:05 - want this loop to run only five times we
59:08 - can do that by adding one statement
59:11 - inside this loop so that this test
59:13 - condition
59:14 - count less than five
59:16 - is false after running five times
59:19 - at the end of the loop i'll add one
59:21 - statement
59:22 - count
59:24 - equals count plus one
59:28 - here we have increased the count
59:30 - variable by one in each iteration of the
59:32 - loop now let's see from the start how
59:34 - the program works
59:36 - initially the count variable is zero
59:39 - that's why count less than five or zero
59:41 - less than five is true and the body of
59:44 - the while loop is executed
59:47 - if you've noticed this new line that we
59:49 - have added is incrementing the value of
59:52 - count by one
59:53 - since its initial value was zero its new
59:55 - value is one
59:57 - now the while loop checks the condition
59:59 - again
60:00 - this time count less than 5 or 1 less
60:03 - than 5 is again true and again the body
60:06 - of the loop is executed but this time
60:08 - since the value of count was 1 its new
60:11 - value is 2.
60:15 - basically this line count equals count
60:18 - plus 1
60:20 - is increasing the value of count in each
60:22 - iteration of the loop from count equals
60:24 - 0 to count equals 4 which is 5 times
60:28 - after the 5 runs the count variable is
60:30 - increased from 4 to 5
60:32 - only then the test condition count less
60:34 - than 5 or 5 less than 5 is false
60:38 - let me press the run button and show you
60:40 - so when i press the run button
60:42 - this time i am inside a loop and looping
60:45 - is interesting is printed only five
60:47 - times
60:48 - let me change this program a bit i will
60:50 - remove these two print statements and
60:52 - instead i'll print the count variable
60:54 - inside the for loop so that we can
60:56 - better understand what's happening
60:58 - now when i press the run button
61:00 - as you can see the value of count was 0
61:03 - and it went up to 1 2 3 4 and 5 and when
61:06 - count was 5
61:08 - it was this condition was false and the
61:10 - loop exited
61:12 - now let me modify this program again i
61:14 - will change count to 5 and i'll change
61:17 - this test condition to count less than
61:20 - equal to
61:21 - 10.
61:22 - can you guess the output of this program
61:24 - without running it i'll give you a
61:25 - couple of seconds to pause the video
61:29 - you can find the answer to this program
61:30 - in our github repository the link will
61:33 - be in the video description now let's
61:34 - try one more example of the while loop
61:37 - we will print the multiplication table
61:39 - of a number that is entered by the user
61:42 - from 1 to 10.
61:44 - to write this program we need to create
61:46 - a loop that runs 10 times from 1 to 10.
61:49 - let's do that first so i'll remove this
61:51 - old code and i'll say
61:53 - number
61:54 - equals
61:55 - int
61:57 - and then i'll take an input
61:59 - enter a number
62:02 - then
62:02 - i'll say
62:03 - count equals 1
62:06 - while count
62:08 - less than equals 10
62:11 - count equals count plus 1.
62:14 - let me run this code and it says enter a
62:17 - number when i enter 6
62:20 - nothing really gets printed this is
62:22 - because i have not printed anything
62:23 - inside the while loop however this
62:25 - program is still doing something useful
62:27 - it is taking the variable count and
62:30 - increasing it from 1 to 10 in each
62:33 - iteration of the while loop because of
62:35 - the statement count equals count plus 1.
62:39 - now in each iteration of the loop we
62:41 - need to print the row of the
62:42 - multiplication table i will do that by
62:45 - adding a few lines
62:47 - so here i'll say
62:48 - product
62:50 - equals
62:51 - number
62:53 - times
62:54 - count
62:55 - and then i'll say print
62:57 - product
62:59 - we have computed the product by
63:00 - multiplying number by count and in line
63:03 - 6 we have printed the product by using
63:06 - the print statement let me run this
63:07 - program when i run it then it says enter
63:11 - a number and when i enter something like
63:12 - 6
63:13 - we can see that the output shows the
63:15 - result when 6 is multiplied by numbers
63:18 - from 1 to 10.
63:19 - let's make that a bit more readable here
63:22 - instead of print product i'll say print
63:25 - number
63:28 - times count
63:32 - equals product
63:34 - let me press the run button and it says
63:37 - enter a number i'll enter something like
63:38 - 6 and when i press enter
63:40 - then it shows the multiplication table
63:43 - in nicely formatted manner
63:45 - this is because as we have seen in the
63:47 - previous video the print function takes
63:49 - whatever is in between the commas and
63:52 - prints them with spaces in between
63:56 - as you can see from this example you can
63:58 - write pretty awesome programs using
64:00 - loops the syntax of the while loop is
64:02 - pretty easy
64:03 - however the important part is the logic
64:06 - and how you use it and how do you get
64:08 - good at logic one word practice so
64:11 - here's a task for you to practice
64:14 - can you modify our multiplication table
64:16 - program so that you get a multiplication
64:18 - table from 10 to 1 instead of 1 to 10
64:22 - you have to modify the same program that
64:23 - i've written here and you can see the
64:25 - expected output on the screen
64:29 - you'll find the answer to this question
64:30 - in our github repository also visit our
64:33 - website programmers.com for more
64:34 - information on why loop with examples i
64:37 - posted the links in the description
64:38 - below by the way if we know that our
64:41 - loop iterates for a certain number of
64:43 - times like 5 times or 10 times in our
64:46 - examples it's easier and better to use
64:49 - the for loop which we will learn about
64:51 - in the next video
64:52 - before we wrap up this video let's recap
64:54 - some of the concepts we have learned
64:57 - loops are used in programming to repeat
64:59 - a block of code the while loop runs
65:02 - continuously until the test condition is
65:04 - false
65:05 - if the test condition of the loop is
65:07 - never false the loop runs infinitely
65:10 - until the memory is full
65:11 - this is known as an infinite loop
65:16 - before we look at the working of the for
65:17 - loop we need to understand about
65:19 - sequences
65:22 - a sequence is a collection of items in
65:25 - an order we have already used strings
65:27 - numerous times in our programs a string
65:30 - is basically a sequence of characters
65:34 - as you can see in the image the string
65:36 - python is a sequence of seven characters
65:39 - p
65:40 - y t
65:41 - h o and n
65:44 - let's look at another type of sequence
65:47 - this sequence has three items separated
65:50 - by commas and enclosed in square
65:52 - brackets this sequence is called a list
65:55 - we will learn about these sequences in
65:57 - detail in the upcoming videos for now
66:01 - just remember that a sequence in python
66:03 - is a collection of items in an order
66:06 - now that we know what sequences are
66:08 - let's get back to our main topic for
66:10 - loop
66:13 - the for loop in python is used to
66:15 - iterate over a sequence and in each
66:17 - iteration we can access individual items
66:19 - of that sequence for example in my code
66:22 - editor i'll show you
66:25 - suppose we have a string like this
66:30 - using a for loop we can access
66:32 - individual items of the string python
66:35 - one by one
66:36 - now i'll create a for loop
66:40 - here i'll say for
66:42 - character
66:43 - in
66:44 - text
66:46 - then i'll print the character using our
66:48 - handy print function
66:51 - when i press run
66:52 - we can see that each character of the
66:55 - string python is printed one by one
66:58 - let's see how this program works
67:00 - during the first iteration of this for
67:02 - loop the variable character will have
67:05 - the value p which is the first letter in
67:08 - the text python
67:09 - and that will be printed to the screen
67:13 - in the next iteration the value of y
67:15 - will be stored in the variable character
67:17 - and when we print character y is printed
67:20 - to the screen
67:21 - this goes on until we reach n
67:24 - after which the for loop exits
67:28 - by the way we are seeing each character
67:30 - in a new line because the print function
67:33 - adds a new line at the end of each line
67:35 - by default
67:37 - before we move on i'll add the syntax of
67:39 - the for loop here so that it's easier
67:41 - for me to explain it to you
67:43 - for each item in sequence
67:47 - execute the body of the loop
67:50 - now let's talk about looping through a
67:52 - list
67:53 - suppose we have a list of languages like
67:55 - this
67:56 - let's use the for loop to iterate
67:58 - through each item of this list one by
68:00 - one
68:02 - just like we did in the strings example
68:04 - i'll say for
68:06 - language in
68:08 - languages
68:10 - print
68:11 - language
68:13 - now when i press run as you can see all
68:15 - three languages are printed one by one
68:19 - let me read out this code in plain
68:21 - english for each language in the
68:23 - languages list
68:24 - store that language in the language
68:26 - variable and print it
68:30 - now let's move on to python range
68:32 - function if you watch the last video of
68:34 - the while loop we used it to repeat a
68:37 - block of code a certain number of times
68:39 - like five times and ten times let me
68:41 - give you an example i'll create a while
68:44 - loop that iterates five times from count
68:47 - equal to one to count equal to five
68:49 - i'll remove the old code and i'll say
68:52 - count equals 1
68:54 - and then i'll say
68:56 - while
68:57 - count less than equals 5
69:00 - print
69:02 - count and then i'll increase the value
69:04 - of count like count equals count plus 1.
69:10 - i'll press run
69:11 - and as expected the numbers from 1 to 5
69:14 - are printed
69:16 - there's an easier way to write the same
69:18 - program using the for loop for that
69:20 - we'll use the range function let me give
69:22 - you an example i'll comment out this old
69:24 - code
69:25 - and then i'll say for
69:27 - count
69:29 - in
69:29 - range 1 to 6.
69:34 - print
69:35 - count
69:36 - this range function creates a sequence
69:39 - of numbers from 1 to 5. it doesn't
69:43 - include the last value 6.
69:45 - let me run this code
69:47 - and as expected it prints one to five
69:51 - range is a very useful function we will
69:53 - learn more about the range function in
69:55 - detail in a future video so be sure to
69:57 - subscribe and hit the bell icon so that
69:59 - you don't miss that video
70:01 - let's try one more example of the for
70:03 - loop we will print a multiplication
70:04 - table of a number entered by the user
70:07 - from 1 to 10.
70:08 - let's first take input from the user so
70:10 - i'll say number equals
70:13 - integer
70:14 - input
70:15 - enter and
70:17 - integer
70:18 - since we want to print the
70:19 - multiplication table from 1 to 10 i will
70:22 - create a loop that iterates 10 times
70:24 - from count equal 1 to 10.
70:27 - so here i'll say
70:29 - 4
70:30 - count
70:31 - in
70:32 - range
70:33 - 1 comma 11
70:38 - as we have discussed before 11 will be
70:40 - excluded and this will give me a
70:42 - sequence from 1 to 10
70:45 - now we need to find the product by
70:47 - multiplying number by count inside the
70:50 - body of the loop so here i'll say
70:52 - product
70:54 - equals
70:55 - number
70:56 - times count
70:58 - now let me use the print function with
71:00 - commas to format the output nicely so
71:03 - i'll say print
71:06 - number
71:07 - comma
71:09 - x or times
71:11 - count
71:13 - equals
71:15 - product
71:17 - when i run it it asks me to enter a
71:19 - number
71:20 - and i'll say something like 9 and when i
71:22 - press enter as you can see the
71:25 - multiplication table is printed in this
71:27 - nice format here count is increased from
71:30 - 1 to 10
71:32 - and we have calculated the product by
71:34 - multiplying number and count
71:37 - so in the first iteration product will
71:40 - be 9 times 1 which is 9 in the second
71:43 - iteration product will be 9 times 2 and
71:46 - so on
71:49 - before we end this video here's a
71:50 - programming task for you can you create
71:53 - a program to find the sum of numbers
71:55 - from 1 to 100
71:56 - basically the result should be equal to
71:58 - result equals 1 plus 2 plus 3 plus blah
72:02 - blah blah plus 100
72:04 - if you're a programming beginner you
72:06 - might find this program a touch harder
72:08 - give it a try you can always find the
72:10 - answer to this program in our github
72:12 - repository if you get stuck
72:14 - i will provide the link in the
72:15 - description below
72:17 - before we end this video let me recap
72:19 - the concepts that we have learned
72:21 - loops are used in programming to repeat
72:23 - a block of code a for loop is used to
72:26 - iterate through items of a sequence if
72:28 - you know that a loop needs to run for a
72:30 - certain number of times like 5 times or
72:32 - 10 times it is better to use the for
72:34 - loop instead of the while loop
72:36 - range is a useful function that creates
72:39 - a sequence of numbers it's common to use
72:41 - range in a for loop to iterate the loop
72:44 - a certain number of times
72:48 - in the last two videos we learned how to
72:50 - repeat a block of code using loops the
72:52 - while loop repeats a block of code until
72:54 - the specified test condition is false
72:57 - and the for loop repeats a block of code
72:59 - until the last item in a sequence is
73:01 - reached
73:02 - sometimes we may need to end the loop
73:05 - without checking the test condition or
73:07 - skip execution of code inside the loop
73:09 - in such cases break and continue
73:12 - statements are used i'll create a loop
73:14 - to print numbers from 1 to 5 to get
73:16 - started so i'll say 4 item in range
73:20 - 1 to 6
73:22 - and i'll print item and as you can see
73:24 - when i press run then 1 to 5 is printed
73:27 - now let me add a break statement here
73:30 - this time when i press run then only one
73:32 - is printed let's try to figure out
73:34 - what's happening here
73:36 - in the first iteration the item value is
73:39 - one
73:40 - one is printed
73:42 - and then the break statement is
73:43 - encountered as soon as we encounter the
73:45 - break statement we exit the loop
73:48 - now let me try something interesting
73:50 - i'll move this break statement before
73:52 - the print statement and this time when i
73:54 - press run absolutely nothing gets
73:56 - printed because the loop never reaches
73:59 - this print item statement
74:03 - the break statements are almost always
74:05 - used inside decision making statements
74:07 - like if and else because most of the
74:09 - time we may want to end the loop only
74:12 - when a certain condition is met
74:14 - let me show you this with a practical
74:16 - example i'll remove this code and i'll
74:18 - say if
74:21 - item equals equals 3
74:24 - then break
74:26 - otherwise print item and i also want to
74:29 - see
74:29 - find out when the loop is execute exited
74:32 - so i'll print outside the loop
74:34 - the end
74:37 - here we have a condition to break this
74:39 - loop when item is equal to 3
74:42 - now when the item becomes 3 the if
74:45 - condition is true and the break
74:46 - statement terminates the loop
74:48 - that's why 3 4 and 5 will not be printed
74:51 - this time let me run this code to show
74:53 - you this
74:54 - so when i run this code then 1 and 2 are
74:57 - printed and the end is printed
75:02 - let's create one more example of the
75:03 - break statement we will use a while loop
75:06 - to take a number input from the user if
75:08 - the user enters a positive number or
75:10 - zero we will print the number and again
75:13 - take another numeric input however if
75:16 - the user enters a negative number we
75:18 - will use the break statement and end the
75:20 - loop
75:21 - to approach this program first we will
75:23 - create a while loop with a test
75:24 - condition that's always true inside the
75:27 - loop we will take input from the user
75:29 - so i'll remove this old code and i'll
75:31 - say while
75:32 - true
75:34 - and i'll say number equals float
75:37 - input
75:38 - enter a number
75:41 - now this is an infinite while loop the
75:43 - only way to end this loop is by using
75:45 - the break statement now let's write our
75:47 - condition to print the number if it is
75:49 - positive and break the loop if it's
75:51 - negative
75:52 - so here i'll say
75:54 - if
75:55 - number
75:56 - less than zero
75:58 - then break
76:01 - otherwise print
76:03 - u
76:04 - entered
76:06 - and here i'll print the number
76:08 - when i run this program then it says
76:10 - enter a number let me enter a positive
76:13 - number like 4 and it says you entered
76:15 - 4.0 and let me enter another positive
76:18 - number 67 it says you entered 67 now let
76:22 - me try entering a number that's negative
76:24 - so i'll say minus 9 and when i press
76:27 - enter then it exited me from the loop
76:29 - and the program as well
76:32 - let's talk about the continue statement
76:34 - in python now the continue statement in
76:36 - python skips the rest of the code inside
76:39 - the loop for that iteration the loop
76:41 - will not terminate but continues on with
76:43 - the next iteration let me explain this
76:46 - with the help of an example so i'll
76:48 - remove this or code and i'll say for i
76:51 - in range five
76:54 - and then i'll say number
76:55 - equals float
76:57 - input
76:58 - enter a
77:00 - number then i'll print the number
77:04 - this program asked me for five numbers
77:07 - so i'll say 1 2
77:09 - 54
77:10 - 34
77:11 - minus 76
77:13 - and something like 67
77:15 - then it existed after five iterations
77:19 - what if you only want to print the
77:20 - positive numbers entered by the user and
77:22 - skip the printing of the negative
77:24 - numbers in such cases we can use the
77:27 - continue statement to skip code inside
77:29 - the loop if the user enters a negative
77:31 - number
77:32 - so here i'll add the continue statement
77:34 - like this
77:36 - i'll add the condition to check if the
77:38 - number is negative and continue the
77:40 - program without printing here so i'll
77:42 - say if number
77:45 - less than
77:46 - 0
77:47 - continue
77:49 - this time when i run the program then it
77:51 - asks me for an input i'll say 34 it asks
77:54 - me for another input i'll say 56.5 or 7
77:58 - and it prints the number and now if i
78:01 - enter a number like negative number like
78:03 - minus 87
78:05 - then it does not print the number it
78:07 - asks me for another number immediately
78:09 - this is because when this condition is
78:11 - true the continue statement takes me to
78:14 - the next iteration of the loop let me
78:16 - continue adding positive numbers so i'll
78:17 - say 23
78:19 - and then i'll add another negative
78:21 - number like minus 54 and as you can see
78:24 - this whole loop still executed for five
78:26 - times but depending on whether i input a
78:28 - negative number or the positive number i
78:31 - was able to use the continue statement
78:33 - to either print the number or go
78:35 - directly to the next iteration
78:39 - before we end this video here's a little
78:41 - programming task for you suppose we have
78:43 - a list like this
78:45 - can you create a program so that all
78:47 - items of the languages list are printed
78:50 - except swift and c plus you can find the
78:53 - answer to this question in our github
78:54 - repository also visit our website
78:57 - programmings.com for more tutorials and
78:59 - examples i've posted the link to both
79:01 - the github repository and our website in
79:03 - the description below
79:05 - let's recap the concepts we learned in
79:07 - this video the break statement
79:09 - terminates the loop immediately when it
79:11 - is encountered the continue statement
79:13 - skips the code after it when it is
79:15 - encountered
79:16 - most of the time we want to change the
79:18 - way loops work only when a certain
79:21 - condition is met that's why we usually
79:23 - use break and continue inside the
79:25 - decision making statements like if and
79:27 - else
79:30 - suppose you need to create a loop or a
79:32 - decision making statement however we are
79:34 - not sure yet what its body will be in
79:37 - such scenarios we can use the past
79:39 - statement let me give you an example
79:41 - so i'll say number
79:43 - equals
79:44 - 5.5
79:46 - and then i'll say if
79:47 - number
79:49 - greater than 0.0
79:52 - and then i'll add this pass statement
79:53 - here
79:54 - when i run this program my code will run
79:57 - without any errors
79:58 - now i can write code after the if
80:01 - statement and run it and implement the
80:02 - statement when it's necessary
80:06 - what would happen if we used comments
80:08 - instead of the past statement in the
80:09 - above program
80:12 - let's find out
80:13 - so i'll say
80:14 - so i'll remove this pass and i'll say
80:17 - to do
80:19 - will figure
80:20 - out later
80:22 - now this time if i press run
80:25 - then python gives me an error it says
80:27 - unexpected uf while parsing
80:30 - this error is basically saying you
80:32 - cannot end the program file like this
80:34 - something is wrong we are getting this
80:37 - error because the body of the if
80:38 - statement is empty and comments don't
80:40 - count because python completely ignores
80:42 - comments so whenever you need to create
80:45 - loops if else statement functions and
80:48 - classes with an empty body you can
80:49 - temporarily use the pass statement
80:52 - before i end this video let me recap the
80:54 - concept that we learned
80:56 - in python pass is a null statement that
80:58 - does nothing the pass statement can be
81:01 - used to create loops if else statement
81:04 - functions and classes with an empty body
81:06 - you will learn about classes and
81:08 - functions in the next few videos
81:12 - in programming a function is a group of
81:14 - related statements that performs a
81:16 - specific task they help us divide a
81:19 - large program into smaller chunks so
81:21 - that it's easier to understand and
81:23 - change suppose you need to create a
81:26 - program that draws circles and
81:28 - rectangles of different colors based on
81:30 - user input instead of creating one big
81:33 - chunk of statements to create this
81:34 - program we can create three functions to
81:37 - solve this first create a circle
81:39 - function then a rectangle function and
81:42 - then the color the shape function
81:45 - this helps us to divide complexity and
81:48 - we can focus on only a small part of the
81:50 - problem at one time
81:52 - now let's see how we can create a
81:53 - function in python
81:55 - to create a function we use the def
81:57 - keyword which stands for the function
81:59 - definition followed by the function name
82:02 - then i'll use the empty parenthesis
82:04 - followed by a column
82:06 - so i'll say d e f def
82:08 - greet
82:09 - empty parenthesis and column
82:12 - here we have defined a function name
82:14 - greet however this code will give us an
82:17 - error because the function body is
82:19 - missing let's fix that for now i'll only
82:22 - add two print statements as its body so
82:25 - i'll say print
82:27 - hello
82:28 - and then let me add another print
82:30 - statement print
82:32 - how do you do
82:34 - remember we need to use indentation to
82:37 - specify that this is the body of the
82:39 - function
82:40 - we have successfully created a function
82:42 - named greet now let me run this code
82:48 - and we don't really see anything this is
82:50 - because defining a function won't do
82:52 - anything in itself to bring the function
82:54 - into action we need to call it our
82:57 - function name is greet with empty
82:59 - parenthesis so to call it i will just
83:02 - use greet with empty parentheses so here
83:05 - i'll say
83:07 - greet
83:09 - and now when i press run
83:11 - then you can see that hello and how do
83:12 - we do are printed
83:15 - here's how this code works when we call
83:17 - the function the control of the program
83:20 - jumps to the function header
83:22 - then the statements inside the function
83:24 - are executed
83:26 - when this task is completed the control
83:28 - of the program goes back to the function
83:31 - call and the next statement after the
83:33 - function call is executed
83:36 - one thing with functions is that once we
83:38 - define a function we can call it any
83:40 - number of times
83:41 - let's call our greet function three
83:43 - times so here i'll say greet
83:46 - and one more greet and now if i press
83:49 - run
83:50 - as you can see the function has run
83:52 - three times that's why these two
83:54 - statements were executed one two and
83:58 - three
84:00 - times so if we need to perform a task
84:03 - again and again we can wrap the codes
84:06 - inside a function and use the function
84:08 - any number of times we just need to call
84:10 - the function again and again
84:12 - one thing to remember when we create a
84:14 - function is that we need to define a
84:16 - function first before we can call it
84:19 - this code for instance will not work
84:21 - let me run this code to show you
84:24 - here when the grade function is called
84:27 - python doesn't know that this function
84:29 - exists because it's defined after the
84:31 - function call so always remember to
84:33 - define a function before you use it
84:37 - now let's talk about python arguments
84:39 - and how our grid function from the
84:40 - previous example can be changed to allow
84:43 - arguments suppose we want to make our
84:45 - greet function a bit more personal so
84:47 - instead of printing hello we want to
84:49 - print something like hello jack or
84:51 - whatever the person's name is in such
84:54 - cases we can pass values to a function
84:57 - these values we pass to a function are
84:59 - called arguments so i'll go back to the
85:01 - code that i started with i'll remove
85:03 - these two greet functions because i want
85:05 - only one and here inside the grid
85:08 - function i'll pass the jack string like
85:11 - this
85:12 - this value that we passed during a
85:14 - function called is called an argument so
85:16 - jack here is an argument and in the
85:19 - function definition i'll add a variable
85:21 - in the greet function i'll call it name
85:26 - this name variable accepts whatever
85:28 - value is sent as an argument during the
85:30 - function call
85:32 - in this case jack is transferred to the
85:34 - variable name
85:36 - now i can use the name parameter inside
85:38 - the function so now i can say hello
85:41 - comma
85:42 - name and when i press run
85:45 - then i get hello jack
85:48 - let's see step by step how this function
85:50 - works when we call the greet function
85:52 - with the argument jack then this is
85:54 - passed to the name variable inside the
85:56 - function definition
85:58 - then the statements inside the function
86:00 - are executed we can use the name
86:03 - parameter inside the body of the
86:05 - function
86:07 - when this task is completed the control
86:09 - of the program comes back to the place
86:12 - from where the function was called and
86:14 - the next statement is executed in this
86:16 - case there's nothing here
86:19 - it's also possible to pass multiple
86:21 - arguments to a function as per our needs
86:24 - if we need to pass multiple arguments to
86:25 - a function we can separate them by
86:27 - commas let's see this in action by
86:29 - creating a function to add two numbers
86:32 - so i'll remove the old code
86:34 - and i'll create a new function called
86:36 - add numbers so i'll say def
86:38 - add underscore numbers
86:41 - obviously i'll need two parameters n1
86:43 - and n2
86:44 - [Music]
86:45 - and then inside the function i'll say
86:47 - result equals n1 plus
86:50 - n2
86:52 - print
86:53 - the sum
86:55 - is
86:56 - and here
86:58 - i'll say result
87:00 - now outside the function i'll say
87:03 - number 1
87:04 - equals 5.4
87:07 - number 2
87:08 - equals 6.7
87:11 - and then i can call add underscore
87:13 - numbers
87:15 - number 1 comma
87:17 - number two
87:18 - in this program we have passed number
87:20 - one and number two as arguments to the
87:23 - add numbers function
87:25 - these arguments will be accepted as n1
87:27 - and n2
87:28 - once they are passed to the add numbers
87:30 - function
87:31 - so inside the function n1 will be 5.4
87:34 - and n2 will be 6.7
87:37 - then we have added the numbers and
87:39 - printed them inside the function itself
87:43 - let's run this code and see the output
87:45 - as you can see i now have the sum of
87:47 - those two numbers
87:52 - in our program to add two numbers we are
87:54 - finding the sum of numbers and printing
87:56 - it it's working fine however it's better
88:00 - just to find the sum inside the function
88:02 - and print the result somewhere else we
88:04 - can achieve that by using the return
88:06 - statement inside the function i'll
88:09 - remove this print statement and i'll say
88:11 - return
88:15 - result
88:17 - when we return a value it comes back to
88:20 - the function and we can assign this
88:21 - return value to a variable like this so
88:24 - here i can say
88:26 - result equals add numbers number one
88:29 - comma number two and i can print the
88:31 - result as print
88:33 - the sum is
88:36 - and then i can say result
88:39 - let's see step by step how this program
88:41 - works we call the ad numbers function
88:44 - with two arguments number one and number
88:46 - two which are accepted by the function
88:49 - definition as n1 and n2
88:52 - the sum of n1 and n2 is calculated and
88:55 - the result is returned to the function
88:58 - call
88:59 - this return value is assigned to the
89:01 - result variable
89:03 - and in the next line we just print the
89:05 - result variable outside the add numbers
89:08 - function
89:09 - whenever a return statement is
89:11 - encountered inside a function the
89:12 - control of the program goes back to the
89:14 - place from where it's called let's see
89:16 - an example of this
89:18 - let's get back to our grid function that
89:19 - we wrote before i'm pasting it here
89:24 - when i press run
89:26 - then we get hello jack and how do we do
89:28 - here now let me modify this program a
89:31 - little bit i'll add a return statement
89:33 - after this line and let's see what
89:35 - happens
89:36 - now when i press run
89:38 - then you can see that only hello jack is
89:40 - printed
89:41 - this is because when the return
89:43 - statement is encountered immediately the
89:45 - function terminates and control of the
89:48 - program goes back to the place from
89:50 - where the function is called
89:52 - at this point we have covered all the
89:54 - basics to create a function these
89:56 - functions we created ourselves are known
89:59 - as user defined functions
90:01 - actually we have already used functions
90:03 - numerous times in all of our videos
90:06 - remember print it is also a function the
90:09 - function definition of this print
90:10 - statement is defined somewhere inside
90:13 - the python programming language that's
90:15 - why we can just call the function and it
90:17 - just works these functions defined
90:19 - inside of python are called built-in
90:21 - functions we have also used other
90:23 - built-in functions like float int input
90:27 - and so on in our videos
90:29 - there are numerous built-in functions
90:30 - available in python that make our life a
90:33 - whole lot easier for example suppose we
90:36 - have a list like this
90:38 - now if we need to find the length of
90:40 - this list we can use the len function
90:44 - so here i can say
90:47 - length
90:47 - equals
90:49 - len
90:50 - max and i can print the length of the
90:52 - list as print
90:55 - length is
90:57 - comma
90:58 - length
91:00 - let's run this code and see the output
91:01 - when i press run
91:03 - then as you can see it says length is 5
91:06 - which is the length of the number of
91:07 - items in this marks list
91:11 - if we instead needed to find the sum of
91:13 - the items of the list we don't need to
91:15 - manually write the code ourselves we can
91:17 - use the sum function that's available in
91:19 - python
91:20 - so here i can say marks underscore sum
91:23 - equals
91:24 - sum of marks
91:28 - and then i can print the sum as print
91:30 - the
91:31 - total
91:32 - marks you
91:35 - got is
91:36 - and then i can say
91:38 - marks underscore sum now when i press
91:41 - run then it says the length is 5 and the
91:43 - total marks you got is 308 which is the
91:46 - sum of these marks
91:48 - if you're interested you can find all
91:50 - the built-in functions available in
91:52 - python in the programming.com website
91:54 - the link will be in the description
91:56 - below let's put all the things we have
91:59 - learnt in this video in action
92:01 - suppose you have just attended a
92:02 - university examination the marks you
92:05 - obtained in various subjects are stored
92:07 - in a list like this you want to find the
92:10 - average marks you obtained in the exam
92:12 - and based on the average marks you want
92:14 - to find your grade the grading rule is
92:17 - like this you'll get grade a if the
92:19 - average marks is equal to or above 80
92:22 - you'll get grade b if the average marks
92:24 - is equal to or above 60 and less than 80
92:28 - you'll get grade c if the average max is
92:30 - equal to or above 50 and less than 60
92:33 - and if the average max is less than 50
92:36 - you will get great f
92:38 - to solve this problem we will create two
92:40 - functions one to find the average marks
92:43 - and another to compute the grade so
92:45 - let's get started i'll start with the
92:47 - function definition but before that let
92:49 - me add a little comment i'll say
92:51 - function to
92:53 - find average marks now let me define my
92:56 - function as def
92:58 - fine
93:00 - average marks now the argument to this
93:02 - will be a list of marks
93:05 - and inside i'll say sum of marks equals
93:10 - sum
93:10 - marks i also need to find the number of
93:13 - subjects or the number of marks i have
93:15 - so i'll say total
93:17 - underscore subjects
93:20 - equals
93:21 - the length of this marks list
93:24 - and then now i can calculate the average
93:26 - as average underscore marks equals
93:29 - sum of marks divided by
93:33 - total subjects let me return this
93:36 - average marks variable
93:38 - and now outside the function i can say
93:41 - average marks equals
93:44 - find
93:45 - average marks i'll pass in the marks
93:47 - list
93:48 - and here i'll say print
93:50 - your average marks is
93:54 - and i'll say average underscore marks
93:57 - when i press the run button i can see
93:59 - that my average marks is 67.8
94:02 - which is the average of these five
94:04 - numbers which is calculated as sum of
94:06 - these numbers divided by the total
94:08 - number of subjects which is 5 in this
94:10 - case
94:12 - now we need to create another function
94:14 - to calculate the grade based on the
94:16 - average marks let's do that now i'll
94:19 - create another function but before that
94:20 - let me add a little comment i'll say
94:23 - calculate the grade
94:25 - and return it
94:27 - and then i'll say def
94:29 - compute underscore grade now the
94:32 - parameter or the argument to this will
94:33 - be the average marks
94:35 - so i'll say average marks
94:37 - and inside i'll say
94:39 - if
94:40 - average marks
94:42 - greater than equals 80
94:45 - then grade
94:46 - is
94:47 - a
94:49 - alif
94:50 - average
94:52 - marks
94:53 - greater equals
94:54 - 60
94:56 - then the grade is
94:58 - b
95:00 - l if
95:02 - average max greater than equals 50
95:05 - in this case the grade is c
95:08 - and the else clause i'll say grade
95:11 - equals
95:12 - f
95:13 - and outside the if block i'll say return
95:17 - grade
95:18 - now i can use this compute grade
95:20 - function as
95:22 - grade equals
95:25 - compute underscore grade
95:28 - average marks now let me print
95:33 - this grade as your grade is
95:37 - and the grade variable
95:39 - now when i press it on i can see that my
95:41 - average marks is 67.8 and my grade is b
95:45 - which is not the best result but at
95:47 - least i now know what my grade is
95:51 - before we end this video here's a
95:53 - programming task for you can you create
95:55 - a program to add and multiply two
95:57 - numbers for this create two functions
96:00 - add underscore numbers and multiply
96:02 - underscore numbers these functions
96:04 - should compute the result and return
96:06 - them to the function call and the
96:08 - results should be printed from outside
96:10 - the function you'll find the answer to
96:12 - this question in our github repository
96:15 - also visit our website programmies.com
96:17 - for more tutorials and examples the
96:19 - links will be in the description below
96:21 - now let's recap what we learned a
96:23 - function is a block of code that
96:25 - performs a specific task
96:27 - we use the def keyword to define a
96:30 - function
96:31 - to bring the function into action we
96:33 - need to call the function we can call
96:35 - the same function as many times as we
96:38 - want as per our needs we can pass values
96:41 - to a function these values passed to
96:43 - functions are called arguments or
96:45 - parameters
96:47 - the return statement can be used inside
96:49 - a function the return statement returns
96:51 - a value from a function and exits the
96:53 - function as well if you're enjoying this
96:55 - video please also check out program is
96:57 - pro where we provide tutorials along
96:59 - with quizzes and challenges which will
97:01 - help you practice and test your learning
97:03 - in real time also the course includes
97:05 - projects to give you an awesome
97:06 - experience of how programming works in
97:08 - the real world and for our youtube
97:09 - subscribers we are giving 50 off on the
97:11 - yearly plan sign up by scanning this qr
97:14 - code or use the link in the video
97:15 - description to claim your discount
97:20 - have this program to add two numbers
97:22 - from the last video
97:23 - here we have called the add underscore
97:26 - numbers function with two arguments
97:29 - then our function
97:31 - adds those two numbers and returns the
97:33 - sum
97:34 - these arguments we pass to the function
97:36 - are called positional arguments because
97:38 - the first argument 5.4
97:41 - is assigned to the first parameter n1
97:44 - and the second parameter 6.7 is assigned
97:47 - to the second parameter n2
97:49 - these arguments are passed based on
97:51 - their position
97:52 - now let me modify this program and
97:54 - remove this 6.7 from the function call
97:59 - can you guess what will happen
98:01 - let me run this code
98:06 - as you can see we get an error type
98:08 - error add underscore numbers missing one
98:10 - required positional argument n2
98:12 - this error message is telling us that we
98:14 - need to pass a second argument during
98:16 - the function call because our add
98:18 - underscore numbers function takes two
98:21 - arguments n1 and n2
98:24 - in such cases we can provide default
98:26 - values to parameters in the function
98:28 - definition which we will see next
98:33 - i still have this program from the last
98:34 - example which gave us an error
98:36 - it was because there is one argument in
98:38 - the function call but two arguments in
98:41 - the function definition
98:42 - to fix this issue either we can add a
98:45 - second parameter in the function call or
98:47 - we can provide a default value to the
98:49 - parameters let me provide default values
98:51 - to parameters in this program so i'll
98:54 - say n1 equals 100
98:57 - and i'll say n2
98:59 - equals 1000
99:02 - now i have given 100 as the default
99:04 - value to n1 and 1000 as the default
99:07 - value to n2 let me run the program again
99:11 - this time when i ran the program the
99:13 - output was thousand five point four
99:15 - what's happening here
99:17 - well what's happened here is we have
99:19 - provided five point four as an argument
99:22 - this value will be passed to n1
99:26 - however we haven't provided the second
99:28 - argument so the default value of n2
99:31 - equals thousand will be used and the sum
99:34 - of five point four and thousand is
99:36 - thousand five point four
99:38 - let me modify this program again and
99:40 - this time i won't pass any arguments so
99:43 - i'll remove 5.4
99:46 - and in this case
99:47 - the default values of n1 and n2 will be
99:50 - used as we are not passing any values
99:53 - let me run this code and as you can see
99:56 - we're getting 1100 which is the sum of
99:58 - the default values 100 and thousand
100:05 - in python we cannot only pass arguments
100:08 - to function based on position but we can
100:10 - also pass arguments by name let me give
100:13 - you an example here we are passing jack
100:15 - to the name parameter and what's going
100:17 - on to the message parameter
100:20 - these are positional arguments now let
100:22 - me call this function again but this
100:24 - time i will pass arguments by name
100:28 - so i'll say greet
100:30 - message equals
100:33 - howdy
100:34 - and i'll say name equals
100:37 - jill
100:38 - during this second function call
100:42 - we have specified the arguments by name
100:44 - so howdy is passed to the message
100:47 - parameter and jill is passed to the name
100:50 - parameter
100:51 - the order of the arguments doesn't
100:53 - matter here because we are using name to
100:55 - specify which argument is passed where
100:59 - these arguments are called keyword
101:00 - arguments
101:02 - there are a couple of things we haven't
101:03 - mentioned about arguments in this video
101:05 - for simplicity if you're interested to
101:07 - learn more about arguments visit our
101:09 - website programmers.com i've posted the
101:11 - link in the description below now let me
101:13 - recap the concepts we learnt in this
101:14 - video when we pass arguments to a
101:17 - function without specifying the name the
101:19 - arguments in the function call is
101:21 - assigned to parameters in the function
101:23 - definition based on the position
101:25 - that means that the first argument is
101:27 - assigned to the first parameter and the
101:29 - second argument is assigned to the
101:31 - second parameter and so on
101:33 - these are called positional arguments
101:36 - you can also give names to arguments
101:38 - during a function call
101:39 - these arguments are called keyword
101:41 - arguments the order of arguments doesn't
101:43 - matter when we use keyword arguments
101:46 - we can provide default values to
101:48 - parameters in the function definition
101:50 - these values will be used if we do not
101:52 - pass arguments during the function call
101:56 - i have this function to add two numbers
101:58 - on my screen this add underscore numbers
102:01 - function takes two parameters finds the
102:04 - sum and prints the result all in the
102:06 - same function
102:08 - now instead of printing result from
102:10 - inside the function let's see what will
102:12 - happen if we print result after the
102:14 - function call so i'll cut this code and
102:17 - paste it after the function call
102:19 - and this time when i run this code
102:22 - then it gives me an error it says result
102:25 - not defined what python is trying to
102:27 - tell us is that the result variable is
102:30 - not defined on line 6.
102:33 - what's going on here
102:34 - this is where the concept of local
102:36 - variables comes in
102:38 - any variable that is created inside a
102:40 - function is local to it
102:42 - meaning the result variable is local to
102:45 - the add numbers function
102:47 - when this function ends this variable
102:49 - gets destroyed
102:51 - if you remember we can fix this by using
102:53 - a return statement so i can say return
102:57 - result
102:58 - and here i can say
103:01 - output equals add numbers and here i can
103:04 - print the output
103:07 - with the return statement we are not
103:09 - using the local variable directly
103:11 - rather we are returning its value to the
103:13 - function call
103:14 - this concept of a local variable is a
103:16 - good thing because anyone using the add
103:19 - numbers function
103:20 - doesn't have to know what's inside it
103:23 - they just need to know what arguments to
103:25 - pass and what value it returns and they
103:27 - can use this function without a problem
103:30 - this makes our code reusable to not only
103:32 - us but also to our fellow programmers
103:38 - any variables that are created outside a
103:40 - function are called global variables and
103:42 - you can use these global variables from
103:44 - both inside and outside of a function
103:47 - let me give you an example so i'll
103:49 - create a global variable called message
103:51 - and i'll say message equals
103:54 - how you doing
103:56 - and now let me create a function
103:58 - def
104:00 - greet
104:01 - that prints this message
104:04 - and i'll call this greet function
104:10 - here message is a global variable as
104:12 - it's defined outside the scope of the
104:15 - function greet
104:16 - and you can use it anywhere after it is
104:18 - defined let me run this code to show you
104:21 - this so when i press run then it says
104:23 - how you doing
104:25 - now let's see what will happen if you
104:27 - define a variable with the same name
104:29 - message inside the function
104:31 - so i'll say
104:32 - message equals
104:35 - how are you
104:37 - and here to know that i'm printing the
104:39 - message from inside the function i'll
104:40 - say inside
104:43 - message inside function
104:47 - and after greet i'll again print message
104:50 - message outside function
104:53 - and i'll print the message variable here
104:56 - here i'm trying to see what the value of
104:58 - message is by printing it from both
105:00 - inside and outside the function
105:03 - when i press run then you can see
105:05 - message inside function is how are you
105:07 - and message outside function is how you
105:10 - doing
105:12 - inside the function when we update the
105:14 - message variable then rather than
105:16 - changing the global variable message a
105:19 - new local variable called message is
105:21 - created
105:22 - that message has a new value called how
105:24 - are you and that is what gets printed
105:26 - here
105:27 - after the great function
105:29 - the since the global variable message is
105:32 - unchanged when we print it from outside
105:34 - then it shows the global value
105:38 - if we need to change the global variable
105:40 - inside the function we can achieve this
105:42 - by using the global keyword
105:44 - so here i'll add a new line that says
105:47 - global
105:48 - message and this time when i press run
105:51 - then you can see that
105:53 - from inside the function the value is
105:55 - how are you but because i had defined it
105:58 - as global
105:59 - the actual global message got changed
106:02 - and when i come out of the function and
106:05 - try to print message again
106:07 - the outside message or the global
106:08 - message variable has been changed to how
106:11 - are you
106:12 - before we end this video here's a tip
106:14 - for you that will serve you well in the
106:15 - long run try to avoid the use of global
106:18 - keyword inside a function whenever
106:20 - possible it makes our code really hard
106:22 - to understand as you must have seen in
106:24 - the last example now let's recap the
106:27 - concept that we learnt in this video a
106:29 - variable defined inside a function is
106:31 - local to it when the function ends this
106:34 - variable is destroyed
106:36 - variables defined outside a function are
106:39 - called global variables in python
106:41 - inside functions the global keyword can
106:43 - be used to change the value of a
106:45 - variable to a global scope however it's
106:48 - considered a bad practice and you should
106:50 - try to avoid it
106:54 - let's learn how to create a list we'll
106:56 - start with the list data type in python
106:59 - a list is a sequence of items in an
107:01 - order we create lists by placing items
107:04 - inside square brackets separated by
107:06 - commas
107:07 - now it's not necessary for a list to
107:09 - have all of the items of the same type
107:11 - like this we can also create a list
107:14 - having mixed data types and it may also
107:16 - contain duplicate elements let me show
107:18 - you so here i'll say mixed list and then
107:22 - i can say
107:23 - random
107:25 - list equals something like 2.5
107:28 - let me add in a string called hello
107:31 - and
107:32 - say and a negative integer like minus 5
107:35 - and i can also repeat a number like 2.5
107:39 - this list that i've stored in the random
107:41 - list variable has four items a float
107:45 - a string
107:47 - an integer
107:49 - and again the same float
107:52 - we can also create lists that do not
107:54 - have any items like this so here i can
107:57 - say
107:58 - empty list and i can say list 1 equals
108:03 - just the square brackets without any
108:04 - items in between and let me print it out
108:07 - to see what i get
108:09 - now when i press run then i can see that
108:11 - numbers list is printed having four
108:13 - elements and the list one is an empty
108:16 - list that's printed here
108:19 - since there are no items inside list one
108:22 - it's an empty list
108:23 - the size of an empty list is zero to
108:26 - check it we can use the built-in lend
108:28 - function let me remove the mixed list
108:30 - first
108:33 - and then i'll wrap the numbers list
108:37 - and the empty list
108:40 - list one to see what i get
108:43 - now when i press run then i get 4 and 0
108:47 - which are the lengths of the numbers
108:49 - list and list 1 respectively
108:53 - now let's learn how to access list
108:55 - elements a list is a sequence and its
108:58 - items are always in order suppose we
109:00 - have a list of programming languages
109:02 - like this
109:03 - so i'll say languages equals
109:08 - python
109:12 - javascript c plus plus
109:16 - and
109:18 - kotlin
109:20 - now let me print the languages
109:22 - here
109:23 - i'll say print languages
109:26 - and when i press run then you can see
109:28 - that python javascript c plus plus and
109:30 - kotlin are printed
109:33 - so the first item in this languages list
109:36 - is python
109:37 - the second language is javascript the
109:39 - third one is c plus plus and the last
109:42 - one and the fourth one is kotlin
109:44 - we can access individual items of list
109:47 - by using something called index and it
109:50 - starts from zero so the index of the
109:52 - first item is zero of the second item is
109:54 - one of the third item is 2 and so on
109:59 - now suppose we want to get this first
110:01 - item python
110:03 - to get this item after the name of the
110:05 - list i will type square brackets
110:08 - and inside those square brackets i'll
110:10 - put 0 because i want to access the first
110:13 - element
110:14 - now when i run it
110:16 - then i get python
110:19 - similarly to get c plus plus we need to
110:22 - use index 2 because it's the third
110:24 - element of the list so i'll replace 0 by
110:27 - 2
110:28 - because i want the third element and
110:29 - when i press run then this time i get c
110:32 - plus plus
110:34 - this languages list we have been working
110:36 - with has four items can you guess what
110:39 - will happen if we try to access the
110:41 - fifth item using four as an index
110:46 - why don't we try it in our code and see
110:48 - it for ourselves so i'll index i'll
110:50 - change index 2 to 4 and now when i press
110:54 - run
110:55 - then python tells me list index out of
110:57 - range
110:59 - this error message means that we are
111:01 - using an index that does not exist
111:04 - because the fifth item doesn't exist
111:09 - now let's talk about negative indexing
111:11 - in python we can also use negative
111:13 - indexing for sequences like lists using
111:16 - a negative index gives us items from the
111:18 - last so minus 1 gives us the last item
111:21 - minus 2 gives us the second last item
111:23 - and so on
111:25 - i have this languages list we have been
111:26 - working with on the screen
111:29 - let me change index to minus 1 and run
111:31 - it
111:32 - so here i'll say minus 1 and when i
111:34 - press run then i get kotlin which is the
111:37 - last item in the list
111:39 - similarly we can get javascript using -3
111:44 - because it is the third element from the
111:46 - last now when i press run then i get
111:48 - javascript this time
111:51 - as you can see negative indexing is
111:53 - pretty useful when we need to access
111:55 - items from the last because we do not
111:57 - even need to know the size of the list
112:01 - now let's learn about slicing of a list
112:03 - we learned to access an individual item
112:06 - from a list in the last two sections
112:08 - it's also possible to access a whole
112:11 - section of items from the list not just
112:13 - a single item let me give you an example
112:15 - i have the same code that we have been
112:17 - working with on my screen
112:19 - i'll remove the minus three index to
112:21 - access the third last item
112:26 - now let me access the first three items
112:28 - from the list so i'll use zero
112:31 - column three
112:33 - let me run this code
112:36 - this time i get the first three items of
112:39 - the list on the screen
112:41 - if you've been following along that
112:43 - means the items having index 0 1 and 2
112:46 - were printed
112:47 - the thing you need to remember with
112:48 - slicing is that the first index is
112:51 - inclusive and the last index is
112:54 - exclusive
112:56 - so 0 colon 3
112:58 - that means 0 column 3 will give me 0 1
113:02 - and 2 index which are the first three
113:04 - elements of the list now let's try to
113:07 - get the second third and fourth items
113:09 - since the starting index is inclusive we
113:12 - need to use index 1 to get the second
113:14 - item
113:16 - and the end index is exclusive so we
113:18 - need to use 4 as the end index
113:22 - using 4 will give us items up to the
113:24 - index 3 which is technically the fourth
113:27 - item
113:28 - i'll press run and as expected the
113:30 - second third and fourth elements are
113:32 - printed to the screen
113:34 - let me tell you an interesting fact if
113:36 - we use the empty start index the slicing
113:38 - starts from the beginning of the list so
113:40 - here i'll try something like colon 3 and
113:43 - when i press run then i get the first
113:46 - three elements
113:47 - this means that just leaving the first
113:49 - element open or empty is equivalent to
113:52 - putting 0 in front so when i press run i
113:55 - get the same result as before
113:58 - similarly if we use the empty end index
114:01 - the slicing ends at the last index so
114:04 - here i'll remove this and i'll say i
114:06 - want to start from one and i don't know
114:09 - and
114:10 - and i want to go to the end so when i
114:13 - press run then the slicing starts from
114:15 - the one index and is it goes up to the
114:17 - end of the list that means kotlin should
114:20 - be included in the slice
114:24 - by the way we can also use negative
114:26 - indexes during slicing if you're
114:28 - interested you can check out our website
114:29 - programming.com to find more information
114:31 - about it
114:32 - now let's learn how to change items of a
114:34 - list lists in python are pretty dynamic
114:37 - it's super easy to add modify and delete
114:40 - items of a list the term we use for
114:43 - these kinds of changeable objects is
114:45 - mutable so we can say that lists are
114:48 - mutable objects let's see how we can
114:50 - change items of a list i'll start with
114:52 - the same programming languages list we
114:54 - have been working with
114:56 - now let me change the second element
114:58 - from javascript to ruby it's pretty easy
115:01 - in python to do that we just need to
115:03 - assign ruby to the second element like
115:05 - this
115:06 - so here i'll say languages
115:09 - 1
115:11 - equals
115:12 - ruby and after this if i print languages
115:17 - and press run
115:18 - then now i can see that the second
115:20 - element which was javascript has now
115:23 - been changed to ruby
115:25 - if you don't know then ruby is a popular
115:28 - programming language
115:30 - we can also change the portion of the
115:31 - list in a single statement i'll modify
115:33 - the code i had written where i change
115:35 - javascript to ruby
115:37 - but this time i will change the second
115:40 - and third item of the list in one go
115:43 - here
115:44 - i'll say languages
115:46 - 1
115:47 - column 3
115:49 - equals
115:51 - list of ruby
115:53 - and dart
115:56 - now when i press run
115:58 - here i have access the second and third
116:00 - items which are javascript and c plus
116:02 - plus using the slicing operator column
116:05 - and then modified them by putting the
116:07 - new values ruby and dart in their place
116:10 - that is why the elements that were in
116:12 - present in index 1 and 2 are now ruby
116:14 - and dart
116:18 - now let's learn about iterating through
116:19 - a list before we learn to iterate
116:21 - through a list let's learn about the in
116:23 - keyword the in keyword is used to check
116:26 - whether an item is in the list or not i
116:29 - have this languages list from before
116:32 - now let me check if python is in the
116:34 - list or not here i can say print
116:38 - python
116:39 - in
116:40 - languages
116:42 - the python in languages statement prints
116:45 - true because python is in the languages
116:47 - list let me run this code
116:50 - now the python in languages statement
116:52 - prints true
116:53 - because python is indeed in the
116:55 - languages list
116:56 - let me change python to rust and run the
116:59 - code
117:00 - so here i'll say rust in languages and
117:02 - when i press run this time i get false
117:04 - because rust is not in the languages
117:06 - list
117:08 - this can be helpful when we want to
117:10 - check whether an item is present in a
117:12 - list or not we can use this as a test
117:15 - condition in an if statement for
117:17 - decision making we can perform one set
117:19 - of tasks if an item is in the list and
117:22 - another set of tasks if the item is not
117:24 - in the list
117:25 - if you want to get individual items of a
117:27 - list one by one the easiest way to get
117:30 - them is by using a for loop we've
117:32 - already discussed them in the previous
117:33 - videos but let me revise it again here
117:36 - i'll remove the print statement and i'll
117:37 - add a loop so i'll say for
117:40 - language in
117:42 - languages and then i'll say print
117:44 - language
117:46 - this for loop iterates through elements
117:48 - of the list one by one
117:50 - until the end of the list is reached
117:52 - i'll press run and as you can see all
117:54 - four programming languages are printed
117:56 - here one by one
117:58 - this language variable is python in the
118:01 - first iteration javascript in the second
118:03 - iteration and so on
118:05 - and that is what we have printed inside
118:07 - the body of the loop
118:09 - if you want to learn more about the for
118:10 - loop in detail check out our python for
118:12 - loop video the link will be in the
118:14 - description below
118:16 - now let's learn about list methods
118:18 - the reason lists are so versatile is
118:20 - because it's so easy to add change and
118:22 - remove elements from it suppose we have
118:25 - the same languages list we have been
118:26 - working on in this video
118:29 - now let's say we want to add an item to
118:30 - the list we can use the append method to
118:33 - do this this method is already available
118:35 - when we work with list
118:37 - let's say we want to add rust to our
118:39 - list we can just say languages dot
118:42 - append rust so i'll remove this old code
118:44 - and i'll say languages
118:47 - dot append
118:49 - rust and now if i print
118:52 - languages and press run then you can see
118:55 - rust is also included in the languages
118:57 - list let's say instead of adding rust in
119:00 - the end we want to insert it in the
119:02 - second position we can use the insert
119:04 - method for that so i'll replace this
119:06 - append and i'll say insert and because i
119:09 - want to insert it in the second position
119:11 - that means the index one
119:14 - and when i press run then now i can see
119:16 - that the rust programming language has
119:18 - been appended in the second position
119:20 - which is the index one
119:22 - now let's learn how to remove items from
119:24 - a list by removing c plus plus from our
119:26 - list using the remove method
119:30 - so i can just say
119:31 - languages
119:33 - dot remove
119:35 - c plus plus and now when i press run
119:38 - then i can see that c plus plus has been
119:40 - removed from the list
119:43 - sometimes you might have to create a
119:45 - copy of a list to copy a list we can use
119:48 - the list copy method so here i'll remove
119:51 - this old code and i'll say languages
119:54 - 1 equals
119:57 - dot copy
119:59 - and instead of languages if i print
120:00 - languages one
120:02 - then i can see that i get the same
120:03 - programming languages list that i had
120:05 - before
120:07 - the languages dot copy
120:09 - returns a new list and it is assigned to
120:11 - the languages one variable
120:14 - there are many more list methods readily
120:16 - available for use that make working with
120:18 - lists very easy you can find all the
120:20 - list methods and how they work with
120:22 - examples in our websiteprogrammings.com
120:24 - i will also include the link to the list
120:26 - methods page of our website in the video
120:28 - description
120:30 - now that we have covered lists let's
120:31 - talk about tuples or tuples as some
120:34 - people like to call them a tuple in
120:36 - python is similar to a list it's also an
120:39 - ordered collection of items the only
120:41 - difference between the two is that lists
120:43 - are mutable that is we can change
120:45 - elements of a list whereas tuples or
120:47 - tuples are immutables we cannot change
120:50 - the tuples elements to create a tuple we
120:52 - need to wrap items inside parentheses
120:55 - and these items should be separated by
120:57 - commas so let me create a new tuple i'll
120:59 - say
121:00 - numbers
121:02 - equals
121:04 - parenthesis 21
121:07 - 5
121:09 - 6
121:10 - and 9
121:12 - and then i'll print the tuples as print
121:15 - numbers
121:17 - let me quickly run this
121:18 - and you can see that tuple is printed
121:21 - we can access elements from a tuple in a
121:23 - similar way we access elements from a
121:25 - list accessing elements from a tuple is
121:28 - possible as long as we do not try to
121:30 - change the value
121:31 - so here i'll say new numbers
121:34 - 2 and when i press run then i get the
121:36 - element in the second index or the third
121:38 - element we can also perform slicing
121:41 - similar to list so here i can say
121:44 - 1
121:46 - colon
121:47 - 4
121:48 - and when i press run then i get elements
121:50 - from index 1 to index 3 which is the
121:53 - fourth element
121:55 - like in a list the first index is
121:57 - inclusive and the last index is
121:59 - exclusive
122:00 - we can also loop through a tuple using a
122:03 - loop so here i'll remove this whole code
122:05 - and i'll say for
122:07 - number in
122:08 - numbers
122:09 - and i can say print number now when i
122:12 - press run then i get all the numbers
122:15 - all the things that we have learned till
122:16 - now about tuples is similar to that of
122:19 - lists now let's see how tuples are
122:22 - different from lists as we have
122:24 - mentioned the difference between tuple
122:26 - and list is that the list can be changed
122:28 - but tuple cannot be changed let's see
122:30 - that in action i have this tuple that
122:33 - contains the same programming languages
122:34 - from before
122:37 - let's try to change its first element
122:39 - from python to java so here i'll say
122:42 - languages
122:45 - 0
122:46 - equals
122:47 - java
122:49 - let me also print the languages
122:56 - here i'm trying to assign java to the
122:58 - first element let me run this code we
123:00 - get an error type error tuple object
123:03 - does not support item assignment
123:05 - this error message is telling us that we
123:07 - are trying to change an item of a tuple
123:09 - by assigning it a new value but it's not
123:12 - allowed with tuples we also cannot add
123:15 - and remove items from a tuple because
123:17 - unlike lists tuple doesn't have methods
123:20 - like append insert and remove so if we
123:23 - are sure that our sequence won't change
123:25 - till the end of the program it's better
123:27 - to use tuples instead of lists
123:29 - if you're interested you can find more
123:31 - information about tuples and tuple
123:33 - methods on our website programming.com
123:35 - i'll include links to some relevant
123:38 - articles in the video description
123:40 - before we end this video here's a little
123:42 - task for you can you guess the output of
123:44 - this program that you see on your screen
123:46 - i'll give you a couple of seconds to
123:47 - pause the video
123:50 - as always you'll find the answer to this
123:52 - question in our github repository i'll
123:54 - also include this link in the
123:55 - description below
123:57 - we have covered a lot in this video
123:59 - let's have a quick recap of what we
124:01 - learned a list is a collection of
124:03 - ordered items to access individual items
124:06 - of a list we use indices python indexing
124:09 - starts at zero
124:10 - there is also a concept of negative
124:12 - indexing in python this is used to
124:14 - access elements from the last
124:17 - we can access a portion of a list by
124:19 - using the slicing operator column we can
124:21 - use loops to iterate through items of a
124:24 - list
124:25 - python has several useful methods that
124:27 - make it easier to add change insert and
124:30 - remove list elements finally we learned
124:33 - about tuples a tuple is similar to a
124:36 - list except tuples are immutable we
124:38 - cannot change elements of a tuple
124:42 - in python we create strings by enclosing
124:45 - characters inside quotations like this
124:48 - this hello there
124:50 - inside single quotations is a string we
124:52 - have assigned it to a variable named
124:54 - text
124:55 - and in the next line we have printed the
124:57 - text variable
124:58 - when i run it
125:00 - as expected hello there is printed
125:03 - instead of single quotes we can also use
125:05 - double quotes like this so i can say
125:08 - text equals double quote hello there and
125:10 - then double quote again
125:12 - when i run it
125:14 - again hello there is printed
125:16 - however we can't use mismatching
125:17 - quotations like this so i cannot say
125:20 - single quotation hello there double
125:22 - quotation if i press run
125:24 - then python tells me that there is an
125:25 - error
125:26 - we can also use triple single quotes or
125:28 - triple double quotes to create a string
125:30 - like this so i can say
125:33 - text equals
125:34 - double quote double quote double quote
125:35 - hello there and then again double three
125:38 - double quotes in the end now when i
125:40 - press run i get hello there like before
125:43 - this is usually used for creating a
125:45 - string that spans multiple lines let me
125:47 - add another line inside triple quotation
125:50 - marks
125:50 - so here i'll say hello there
125:53 - how are you doing
125:56 - now when i press run then i get hello
125:58 - there how are you doing on separate
126:00 - lines
126:02 - now suppose we want to create a string
126:04 - like this he said what's there this
126:06 - string contains both single quotes and
126:09 - double quotes
126:11 - i'll run this code
126:13 - and as you can see we get an error this
126:16 - is because python thinks this part
126:18 - inside quotation marks is the string and
126:20 - whatever is outside of that or following
126:22 - that is regular python code
126:25 - to fix this we can escape characters
126:27 - like quotations by using a backslash
126:29 - before it
126:30 - so here i can say he said
126:34 - backslash
126:35 - what's
126:36 - there
126:38 - and now when i press run
126:40 - then i get the correct output
126:44 - now that we know how we can create
126:45 - strings in python let's see how we can
126:48 - access characters from a string
126:52 - as mentioned before a string is a
126:54 - sequence of characters and these
126:56 - characters are in order so we can access
126:58 - individual characters of a string using
127:00 - indices just like with lists and tuples
127:03 - suppose we have a string like this
127:05 - the index of the first character p is
127:07 - zero the index of the second character y
127:09 - is one the index of the third character
127:12 - t is 2 and so on
127:14 - let's access the first character p from
127:16 - the string to access the first character
127:18 - after the name of the string we need to
127:20 - type square brackets and inside it i
127:22 - will provide the index since we are
127:24 - trying to get the first character
127:26 - we need to use index 0 so here i'll say
127:29 - print text square bracket 0 and when i
127:32 - press run
127:33 - then i get p which is the first
127:35 - character in the string
127:37 - now let's try to get the fourth
127:38 - character from the string to get this
127:40 - character we need to use index 3 inside
127:42 - square brackets so here instead of 0
127:45 - i'll say 3 and when i press run then i
127:48 - get h which is the fourth character in
127:50 - python string
127:54 - python also supports negative indexing
127:56 - for all sequences including strings
127:59 - using a negative index makes it easier
128:01 - to access characters from the last the
128:03 - index of the last character in the
128:04 - string is -1 the index of the second
128:07 - last character is -2 and so on let's try
128:09 - negative indexing in action i have this
128:12 - program from our last example on my
128:13 - screen
128:14 - let me change the index to minus 1 so
128:17 - i'll say
128:18 - print text minus 1 and now when i press
128:21 - it on and as you can see n which is the
128:23 - last character in the string is printed
128:29 - we can not only access a single
128:30 - character but we can also access the sub
128:32 - string from the string using the slicing
128:34 - operator to get a portion of the string
128:37 - inside the square brackets i'll mention
128:38 - the start index colon then the end index
128:42 - so here i'll say give me text
128:44 - 1 colon 4
128:47 - let me run the
128:48 - code here i get yth
128:52 - the thing you need to remember with
128:53 - slicing is that the first index is
128:55 - inclusive but the last index is
128:58 - exclusive
128:59 - that's why we got only y t h and not o
129:03 - which is the fourth index
129:06 - now let me remove the start index from
129:07 - our code
129:11 - when i run it we get characters from
129:13 - start to the third index
129:17 - this is equivalent to saying text 0 4
129:20 - when i run it i get the same output
129:23 - similarly if we do not mention the end
129:25 - index we get a string containing
129:27 - characters from the start index to the
129:29 - last character here i'll say give me
129:33 - all the characters from the second index
129:35 - up to the last and when i press run
129:38 - then i get t h o n
129:40 - that means start from the second index
129:42 - which is t and go to till the end
129:48 - strings in python are immutable and we
129:51 - cannot add or change characters of a
129:52 - string
129:53 - let's see what happens when we try to
129:55 - change characters of a string
129:57 - suppose i have the same text string we
129:59 - have been working with
130:00 - i'll try to modify the first character
130:03 - by saying text 0
130:05 - equals small p
130:07 - and then let me try to print text
130:11 - here when i press run
130:13 - then python tells me there's a type
130:15 - error str object does not support item
130:17 - assignment
130:18 - this error message is telling us that we
130:20 - are trying to change characters of a
130:22 - string but it's not allowed however we
130:25 - can perform operations on strings
130:27 - without modifying the original string
130:28 - which we will see next
130:33 - strings are one of the most frequently
130:35 - used data types and we can perform
130:37 - various operations on them before we
130:39 - learn about different string methods
130:40 - let's see a couple of operations that we
130:42 - can perform with strings the first
130:44 - operation is string concatenation it
130:47 - means the joining of two strings into
130:49 - one to join two strings we can use the
130:51 - plus operator let me give you an example
130:54 - so here i'll say text 1 equals
130:58 - python
130:59 - and text 2 equals
131:02 - programming
131:04 - now i can say result equals
131:07 - text 1
131:08 - plus text 2 and let me print the result
131:14 - here we have created a new string by
131:15 - joining text 1 and text 2
131:18 - which is assigned to the result variable
131:21 - the important thing to note here is that
131:23 - we are not modifying python and we are
131:25 - not modifying programming we are
131:27 - actually creating a new string which is
131:29 - stored in the result variable
131:31 - let me run it
131:33 - and as you can see a new string called
131:35 - python programming is created and
131:37 - printed
131:38 - let me add a space between python and
131:40 - programming so that it looks a bit
131:42 - better so here i'll say text one plus
131:45 - space
131:46 - plus text two and now when i press run
131:49 - then you can see that there's a space in
131:51 - between
131:53 - we can also repeat a string a certain
131:54 - number of times very easily in python we
131:57 - use the asterisk operator for that
131:59 - so here i'll go back to my old code that
132:01 - says text equals python
132:04 - and then i can say
132:06 - new underscore text equals
132:10 - text
132:11 - asterisk 3
132:13 - now when i print new underscore text and
132:17 - run the code
132:18 - then you can see python three times is
132:21 - printed
132:23 - python also has several string methods
132:25 - for common string tasks but before we
132:27 - check that let's see how we can iterate
132:29 - through a string
132:32 - the easiest way to iterate through
132:34 - characters of a string is by using a for
132:36 - loop let's take an example i'll go back
132:38 - to my old code that says text equals
132:40 - python then i'll say for
132:43 - character
132:44 - in
132:45 - text
132:47 - and inside the for loop i'll say print
132:51 - character
132:53 - when i run this code
132:55 - then you can see that each character is
132:57 - printed one by one
132:59 - this for loop iterates from the starting
133:02 - character
133:03 - p to the end character n
133:06 - in the first iteration the character
133:08 - variable holds p in the second iteration
133:11 - it holds y in the third iteration it
133:14 - holds t and so on
133:16 - and in each iteration we have printed
133:19 - the character variable
133:21 - this slope iterates six times because
133:24 - the size of the string python is six
133:28 - we can check this by using the len built
133:30 - in function it returns the length of any
133:32 - object in python so here i'll say print
133:36 - len
133:37 - text and now when i press run then then
133:40 - you can see that 6 is printed
133:43 - it's also pretty easy to check if a
133:45 - string is inside a string or not let me
133:47 - quickly give you an example so i'll
133:48 - delete this whole code and then i'll say
133:51 - print
133:53 - p
133:54 - in
133:55 - text
133:56 - now when i press run
133:58 - then since p
134:00 - is present in the word python i get true
134:04 - let's try something more interesting so
134:06 - instead of p i'll say y th and when i
134:09 - press run then this time also i get true
134:12 - because yth is inside python
134:16 - now let me try something else i'll say
134:19 - o n t and when i press run
134:22 - this time i get false because o n t is
134:25 - not inside python in that order
134:30 - as i have mentioned before strings are
134:32 - probably the most frequently used data
134:34 - type to make working with strings easier
134:36 - python has numerous string methods
134:38 - readily available for us to use let's
134:40 - try some of the string methods now
134:43 - suppose i have a string like this
134:45 - i like
134:46 - python 3.
134:48 - let's say we want all characters in this
134:50 - string to be lowercase now to do this we
134:52 - can use the lower method
134:54 - so here i can say result
134:57 - equals
134:58 - text dot lower
135:01 - and in the next line i'll say print
135:03 - result now when i press run then you can
135:05 - see i like python 3 with all characters
135:08 - in lower case is stored in the result
135:10 - variable and printed
135:12 - similarly if you want all uppercase
135:14 - characters we can use the upper method
135:16 - so i'll replace lower
135:18 - with upper and when i press run
135:21 - then i get i like python 3 in uppercase
135:25 - now suppose we want to find the index of
135:27 - this python substring
135:29 - then we can use either find or index
135:32 - method
135:33 - i'll change this upper to find and
135:36 - inside it i'll mention what substring i
135:38 - want to find so here i'll say
135:41 - python
135:42 - and now when i press run
135:44 - i get 7 because 7 is the index of the
135:47 - first occurrence of python inside this
135:49 - string
135:51 - let's try one last example suppose we
135:53 - want to replace python 3 with java we
135:55 - can do that by using the replace method
135:58 - i'll use the replace method instead of
135:59 - find and inside it i need to pass two
136:02 - arguments the first argument is the
136:04 - substring we want to replace so i'll put
136:06 - python 3 so here i'll say text dot
136:08 - replace
136:11 - and then python 3 and in the second
136:14 - argument since we want to replace it
136:15 - with java i'll put java
136:20 - this code returns a new string with
136:22 - python 3 replaced with java i'll run the
136:24 - code
136:26 - and as you can see i like java is
136:28 - printed
136:30 - there are numerous other useful string
136:31 - methods in python you can find all the
136:33 - string methods their descriptions and
136:36 - working examples in our website
136:37 - programming.com the link is in the video
136:39 - description
136:42 - before we end this video here's a little
136:44 - task for you can you guess the output of
136:46 - this program i'll give you a couple of
136:48 - seconds to pause the video as always
136:51 - you'll find the answer to this question
136:52 - in our github repository i'll also
136:54 - include this link in the description
136:56 - below
136:57 - we've covered a lot in this video let's
136:59 - have a quick recap of what we learned a
137:01 - string is a sequence of characters to
137:04 - create a string we use either single
137:06 - quotes or double quotes or triple quotes
137:08 - we can access the specified character
137:10 - from the string by using its index
137:13 - we can also get a substring from a
137:14 - string by using the slice notation
137:17 - since a string is a sequence we can
137:19 - iterate through characters of a string
137:20 - using a loop and finally we learned
137:23 - about different string methods if you're
137:25 - enjoying this video please also check
137:27 - out program is pro where we provide
137:29 - tutorials along with quizzes and
137:30 - challenges which will help you practice
137:32 - and test your learning in real time also
137:34 - the course includes projects to give you
137:36 - an awesome experience of how programming
137:37 - works in the real world and for our
137:39 - youtube subscribers we are giving 50 off
137:41 - on the yearly plan sign up by scanning
137:43 - this qr code or use the link in the
137:45 - video description to claim your discount
137:49 - a dictionary is a collection of key
137:51 - value pairs it is similar to associative
137:53 - arrays in other programming languages to
137:56 - create a dictionary in python we need to
137:58 - put these key value pairs inside curly
138:00 - braces separated by commas like this
138:03 - this dictionary has two items separated
138:06 - by commas and each item is a key value
138:08 - pair separated by a column
138:11 - for the first item its key is name and
138:13 - its value is linus
138:16 - similarly for the second item its key is
138:18 - age and its value is 21.
138:21 - let me print this dictionary and run it
138:24 - so here i'll say print
138:26 - person 1 and when i press run
138:28 - then the same dictionary is printed
138:31 - there are a couple of things we need to
138:33 - remember when we create dictionaries
138:35 - first keys of a dictionary can be any
138:37 - immutable object like numbers strings
138:40 - and tuples however they cannot be
138:43 - objects that can be modified like lists
138:46 - second the keys must be unique for
138:47 - identification
138:49 - let me change the name key to 10 and
138:51 - this age key to a tuple and run it so
138:54 - here i'll say instead of name i'll say
138:56 - 10 and i'll turn this age into a tuple
139:01 - and now when i press run
139:03 - then as expected this is a valid
139:05 - dictionary
139:07 - this works because both these keys
139:10 - 10 and this tuple age are immutable
139:13 - objects
139:17 - dictionaries are optimized to get values
139:19 - when the key is known if you remember we
139:22 - use numbered indices like 0 1 and 2 to
139:25 - get elements from sequences like lists
139:27 - and tuples
139:29 - in the case of dictionaries these keys
139:31 - are used as indices
139:33 - i have this program from our last
139:34 - example suppose we want to get linus
139:36 - from this dictionary
139:38 - to get this i'll type square brackets
139:40 - after our dictionary name and inside
139:42 - i'll type the name of the key which is
139:44 - name
139:46 - and now when i press run
139:48 - i get linus
139:51 - similarly to get 21 we need to use age
139:53 - as a key so here instead of name if i
139:56 - type age and press run then this time i
139:59 - get
140:00 - 21. now let's see what happens if you
140:03 - try to access a key that's not in the
140:05 - dictionary i'll change this age to
140:07 - hobbies
140:09 - and when i press run
140:11 - then python tells me that there's a key
140:13 - error because hobbies is not present in
140:16 - this dictionary person one
140:20 - sometimes instead of getting this error
140:22 - we may just want to know if the key
140:24 - exists or not and decide what to do
140:26 - based on it in that case we can use the
140:29 - dictionaries get method like this
140:31 - so here i can say person one dot get
140:35 - and inside parenthesis i can say hobbies
140:40 - let me run this code
140:42 - this time instead of an error we get
140:45 - none
140:46 - this non-object means empty or no value
140:50 - this can be useful because i can use
140:52 - this in an if statement and run
140:54 - different codes based on it
140:55 - we can also pass a second argument to
140:58 - the get method if the key doesn't exist
141:00 - this default value is returned instead
141:02 - of none i'll provide a list as a default
141:04 - value so here i can say
141:08 - person1.gethobbies and inside let me
141:10 - pass a list saying dancing
141:14 - and
141:15 - fishing
141:17 - now when i press run
141:20 - now instead of none we get this list
141:23 - back
141:26 - i have this person one dictionary we
141:27 - have been working on in my screen
141:31 - now let's change the name to dennis to
141:33 - do so we need to assign a new value to
141:36 - the key like this so here i'll say
141:38 - person 1
141:42 - name
141:43 - equals
141:45 - dennis
141:47 - i'll run it
141:49 - and we can see the value of the name key
141:52 - is now dennis if you try to assign a
141:55 - value to a key that doesn't exist yet it
141:57 - will add a new item to the dictionary
141:59 - let me show you
142:00 - so here i'll say
142:02 - person 1
142:05 - hobbies
142:07 - equals
142:09 - dancing
142:10 - and
142:12 - fishing
142:13 - i'll press it on and as you can see a
142:15 - new key hobbies has been added and its
142:18 - equivalent value dancing and fishing has
142:20 - also been added to this dictionary
142:25 - to remove an item from the dictionary we
142:26 - can use the dictionary's pop method
142:29 - let's see how we can remove this item
142:31 - from the dictionary to remove the item
142:33 - we need to pass the key of the item in
142:36 - the pop method like this
142:38 - so here i'll say
142:40 - person1 dot pop
142:44 - name
142:45 - now when i press run
142:47 - then you can see that name linus has
142:50 - been removed from the dictionary
142:52 - this pop method also returns the value
142:55 - of the removed item so if i wrap this
142:57 - code inside the print function
143:00 - and press run
143:02 - then i get linus which was the removed
143:04 - item
143:05 - there are many of these dictionary
143:06 - methods readily available for us to use
143:09 - this makes working with dictionaries
143:10 - much easier you can find all the
143:12 - dictionary methods and how they work
143:14 - along with examples in our
143:15 - websiteprogrammings.com i'll include the
143:18 - link in the video description
143:21 - similar to sequences we can easily
143:23 - iterate through items of a dictionary by
143:25 - using a for loop and in each iteration
143:28 - of the loop we get a key of the
143:29 - dictionary let's see that in action
143:32 - i have this same dictionary we've been
143:34 - working with so here i'll say for key in
143:38 - person one
143:39 - and here i'll say print key
143:42 - now when i press run
143:44 - then as you can see name and age which
143:46 - are the keys of the dictionary are
143:48 - printed
143:50 - when we know these keys we can easily
143:52 - get the corresponding values as well let
143:54 - me add a line to print values of the
143:56 - dictionary in each iteration of the loop
143:58 - so in the next line i'll say print
144:02 - person 1
144:04 - key
144:05 - now when i press run
144:06 - then as you can see name linus age 21 is
144:10 - printed which are the keys and the
144:12 - corresponding values in this dictionary
144:15 - starting from python 3.7 the order of
144:18 - items in a dictionary is preserved so
144:20 - when we iterate through a dictionary we
144:22 - get the keys in the order in which they
144:24 - are in the dictionary
144:28 - at this point we have pretty much
144:29 - covered the basics of python
144:31 - dictionaries before we end this video
144:33 - here's a task for you can you guess the
144:35 - output of this program i'll give you a
144:37 - couple of seconds to pause the video
144:39 - as always you'll find the answer to this
144:41 - question in our github repository i'll
144:43 - also include this link in the
144:45 - description below
144:46 - here's a recap of what we learnt in this
144:48 - video a dictionary is a compound data
144:50 - type that allows us to work with key
144:52 - value pairs we can easily access a value
144:55 - from a dictionary if its key is known
144:58 - to add or change items from a dictionary
145:00 - we can assign values to the keys
145:03 - we can remove items from a dictionary by
145:05 - using the pop method
145:06 - and finally we learn to iterate through
145:09 - keys of a dictionary using a for loop
145:13 - a set is a collection of items like
145:16 - lists and tuples however there are some
145:19 - important differences between them
145:21 - sets in python are like sets in
145:23 - mathematics a set cannot contain
145:25 - duplicate items and these items are not
145:28 - in any particular order
145:30 - also we can only use immutable objects
145:33 - in set like strings numbers and tuples
145:36 - so a set cannot have mutable objects
145:38 - like lists and dictionaries
145:41 - just three things to remember when we
145:43 - imagine sets in python number one items
145:46 - of a set are not in any particular order
145:49 - number two no duplicate items are
145:51 - allowed and the third one items must be
145:54 - immutable objects
145:56 - now that we know what sets are let's see
145:58 - how we can create them to create a set
146:01 - we place items inside curly brackets
146:03 - separated by commas like this so here
146:06 - i'll say animals equals curly bracket
146:10 - and then i'll add the list of animals as
146:12 - dog
146:14 - cat
146:16 - tiger
146:17 - and
146:19 - elephant
146:22 - let me print this set and run it so i'll
146:24 - say print
146:25 - animals
146:28 - when i press run
146:31 - then you can see the set was printed but
146:34 - you must have noticed that this order of
146:36 - animals is different from this order
146:39 - this is what i meant when i said that
146:40 - the items of a set are not in any
146:42 - particular order
146:44 - this is also the reason why set items
146:46 - also don't have indexes now let's see
146:48 - what happens if we try to create a set
146:51 - having duplicate items inside the set
146:53 - animals i will repeat the dog string
146:56 - twice so here i'll add another dog at
146:59 - the end
147:00 - and now if i press run then you can see
147:03 - that in the output dog is printed only
147:05 - once even though in the set definition
147:09 - dog is repeated twice
147:11 - the duplicate dog was removed from the
147:13 - set because sets in python automatically
147:15 - remove all duplicate items
147:18 - it's also possible to create a set that
147:20 - doesn't have any items to create an
147:22 - empty set we need to use the set
147:24 - function now we cannot use empty curly
147:27 - braces for this because it would create
147:29 - an empty dictionary instead so here i'll
147:32 - remove this old code and i'll say
147:33 - animals equals set
147:35 - and then i'll print
147:38 - animals oops animals now when i press
147:41 - run you can see
147:43 - that an empty set has been printed
147:47 - the set function that you see here can
147:49 - also be used to create non-empty sets
147:52 - i'll show you an example so here i'll
147:55 - add a list inside this set function i'll
147:58 - say cat
148:00 - dog
148:03 - tiger
148:04 - and
148:06 - elephant
148:08 - here we have passed a list inside the
148:10 - set function
148:11 - the set function converts this list into
148:14 - a set
148:15 - when i press run then you can see that
148:17 - this list has been converted to a set
148:20 - because it has curly braces instead of
148:22 - square braces
148:24 - here i have passed a list of four
148:26 - animals cat dog tiger and elephant and
148:29 - the set function has converted it into a
148:32 - set
148:33 - that is why the order has been changed
148:36 - we can convert other iterables like
148:38 - tuples dictionaries and strings into a
148:40 - set in a similar way
148:42 - now let's see how we can add items to a
148:44 - set
148:45 - sets in python are mutable we can add
148:48 - and remove items from them to add a
148:50 - single item to a set we use the add
148:52 - method i have this animal set we have
148:55 - been working on in this video
148:57 - let me add monkey to it to add it after
149:00 - the set's name i will type dot so
149:02 - animals dot and then i'll say add and
149:06 - inside the parenthesis i will pass the
149:09 - monkey string
149:10 - now let me print the animals set so that
149:13 - i can verify if monkey was added
149:14 - correctly or not so i'll say print
149:17 - animals and now when i press run
149:20 - then you can see that monkey was also
149:22 - added to the set
149:24 - we can also add all the elements of
149:26 - iterables like list tuples and other
149:29 - sets to a set for that we can use the
149:31 - update method let's take an example
149:34 - suppose we have a set and a list like
149:36 - this
149:38 - now we want to add all the items of this
149:40 - wired animals list to this animal set
149:45 - we can do that by using the update
149:47 - method like this so i can say animals
149:51 - dot update
149:53 - while
149:55 - animals now i'll print animals and see
149:58 - what i get
150:00 - when i press run
150:02 - you can see that leopard and tiger were
150:05 - added to animals list one thing to note
150:08 - here is that elephant is common in both
150:10 - animals and wild animals
150:12 - since sets cannot have duplicates the
150:14 - output has only one elephant
150:18 - by the way we can also pass multiple
150:20 - iterables to the update method like this
150:22 - so here along with wild animals i'll
150:25 - also add a set containing
150:27 - dolphins
150:29 - when i press run
150:31 - then as you can see dolphins was also
150:33 - added to the set of animals
150:36 - the update function added items from
150:38 - both
150:39 - wild animals
150:41 - and the set containing dolphins to the
150:44 - animal set let's now learn how to remove
150:47 - items from a set to remove an item in a
150:49 - set we can either use the discard method
150:52 - or the remove method let's use the
150:54 - discard method first
150:56 - i have this set of animals now i'll use
150:58 - the discard method as
151:00 - animals dot
151:03 - discard let me discard the cat
151:05 - and now let me print animals to see what
151:08 - i get
151:09 - when i press run
151:11 - you can see that dog elephant and tiger
151:13 - are still in the set but cat has been
151:16 - removed
151:18 - now instead of discard let me try and
151:20 - use the remove method
151:22 - so here i'll say remove and when i press
151:25 - run
151:26 - i get the same output of course in
151:28 - jumbled order
151:30 - both discard and remove are used to
151:33 - remove an item from a set however
151:35 - there's an important difference between
151:37 - them if the item we are trying to remove
151:39 - is not in the set discard returns none
151:42 - whereas the remove method throws an
151:44 - error let me change cat to something
151:47 - like ferret here
151:49 - so i'll say animals dot remove
151:51 - ferret and when i press run
151:54 - then python says there's an key error
151:57 - now when i use discard and run it
152:03 - you can see that no error was thrown
152:07 - we do not get any errors and our animal
152:09 - set is printed what happened here is
152:11 - that this code
152:13 - returned none because ferret is not in
152:16 - the animal set however we haven't
152:19 - assigned the return value to anything
152:21 - then this print statement prints the
152:23 - animal set
152:24 - by the way we can also remove all items
152:27 - in a set at once by using the clear
152:29 - method like this so here i'll remove
152:31 - this code and i'll say animals dot clear
152:34 - and when i press run
152:36 - then you can see that animals is now an
152:38 - empty set
152:41 - let's see how we can find if an item is
152:44 - in the set or not similar to other
152:46 - compound data types we can check if an
152:48 - item is in a set or not by using the in
152:50 - keyword let's see an example so here
152:53 - i'll remove this old code
152:56 - and i'll say
152:57 - print
152:59 - tiger
153:02 - in
153:03 - animals
153:04 - when i press run then i get true because
153:07 - indeed tiger is present in the set of
153:10 - animals
153:11 - if you change tiger to something like
153:12 - ferret and run it so i'll say ferret
153:16 - when i press run
153:17 - then this time i get false because
153:19 - ferret is not present in the set of
153:22 - animals
153:23 - it is also possible to loop through
153:25 - items of a set like other compound data
153:28 - types let's see an example
153:30 - here i have the same old set from before
153:32 - i'll remove this code and i'll say for
153:35 - animal
153:36 - in
153:37 - animals
153:38 - print
153:40 - animal
153:41 - when i press run then you must have
153:42 - guessed the output by now
153:44 - all the animals are printed one by one
153:47 - however the order in which these items
153:49 - are printed is random
153:52 - let's take a look at python set
153:54 - operations now as i mentioned before the
153:57 - way sets work in python is similar to
153:59 - how sets work in mathematics in this
154:01 - video we will cover two set operations
154:04 - union and intersection
154:06 - suppose we have two sets domestic
154:08 - animals and wild animals like this
154:11 - the union of these two sets is a set of
154:13 - all items in both domestic animals and
154:16 - wild animals
154:18 - to find the union of sets we can either
154:20 - use the union method or use the pipe
154:23 - symbol let's see an example
154:25 - so here on my compiler i'll remove the
154:27 - old code and i'll say
154:29 - domestic
154:31 - animals
154:32 - equals
154:36 - dog
154:39 - cat
154:40 - and
154:42 - elephant
154:44 - and then i'll say why
154:46 - animals
154:48 - equals
154:49 - lion
154:52 - tiger
154:53 - and of course elephant again
154:58 - now i can create the union of these sets
155:00 - by saying
155:01 - animals equals
155:03 - domestic underscore
155:05 - animals
155:06 - dot
155:09 - union
155:10 - wild underscore
155:13 - animals
155:15 - let me print the animals variable now
155:17 - i'll say print
155:18 - animals
155:22 - when i press run
155:25 - then i get a set containing animals from
155:27 - both the domestic animal set and the
155:30 - wild animal set
155:32 - the order of sets doesn't matter here i
155:35 - can reverse this order and i can say
155:36 - wild underscore
155:38 - animals
155:40 - dot union
155:42 - domestic
155:43 - underscore
155:45 - animals and when i press run
155:47 - i get the same output as i mentioned
155:49 - before we can also use the pipe symbol
155:51 - to find the union so here i could have
155:53 - also written
155:55 - wild animals pipe domestic animals when
155:59 - i press run i get the same output
156:05 - now let's talk about intersection of
156:06 - sets suppose we have two sets domestic
156:09 - animals and wild animals like before
156:12 - the intersection of these two sets is a
156:14 - set of items that are common in both
156:16 - domestic animals and wild animals
156:19 - to find the intersection of sets we can
156:21 - either use the intersection method or
156:23 - use the ampersand operator let's see an
156:25 - example so i have the same set
156:28 - of domestic animals and wild animals
156:30 - from before and here instead of saying
156:32 - union i'll say wild animals dot
156:36 - intersection
156:38 - domestic
156:39 - animals
156:42 - now when i press run
156:44 - then i get a set containing elephant
156:47 - because elephant is the common element
156:49 - between domestic animals and wild
156:51 - animals
156:52 - now let's use the ampersand operator to
156:54 - find the intersection this time
156:56 - i'll say wild animals
156:58 - ampersand
157:01 - domestic animals and when i press run i
157:04 - get the same output as before
157:08 - you can find more information about
157:09 - different set operations and methods in
157:12 - our website programming dot com i'll
157:14 - include the link in the description
157:15 - below
157:16 - at this point we have covered all the
157:18 - basics of python sets before we end this
157:20 - video here's a task for you can you
157:22 - guess the output of this program i'll
157:24 - give you a couple of seconds to pause
157:26 - the video
157:28 - as always you'll find the answer to this
157:30 - question in our github repository i'll
157:33 - also include the link in the description
157:34 - below now let's recap what we learnt in
157:36 - this video a set is a collection of
157:39 - unordered items since the items do not
157:41 - have any order they also do not have any
157:44 - indexes
157:45 - a set also cannot contain duplicate
157:47 - items and all items of a set must be
157:50 - immutable
157:51 - although the items of a set need to be
157:53 - mutable sets themselves are mutable and
157:56 - we can add and remove items from a set
157:59 - sets in python are similar to sets in
158:01 - mathematics that's why we can perform
158:03 - operations like union and intersection
158:05 - of sets
158:08 - suppose we want a sequence of numbers
158:11 - from 1 to 10
158:13 - to get the sequence
158:14 - we can use the range function like this
158:16 - so i can say result
158:18 - equals
158:19 - range
158:20 - 1 comma 11
158:22 - here the start of the sequence is
158:25 - inclusive but the end is exclusive
158:29 - that's why it gives us a sequence from 1
158:31 - up to 10 and not 1 up to 11 let me print
158:35 - the result so i'll say print
158:38 - result
158:39 - and when i press
158:40 - run
158:42 - instead of getting the result the
158:44 - sequence 1 to 10 i get range 1 11 which
158:48 - is basically the same thing i have typed
158:50 - here so what's happening
158:52 - well the range function returns a range
158:55 - object which is a sequence of characters
158:57 - we can see what's inside this object by
158:59 - converting it to a some other type like
159:02 - a list
159:03 - so here i'll convert the result to a
159:05 - list
159:06 - like this by using the list function
159:08 - and now when i press run then i get the
159:11 - sequence i was asking for that is 1 to
159:14 - 10.
159:16 - one thing to notice here is that by
159:18 - default the step between the numbers
159:22 - 1 2 three four five and up to ten is one
159:26 - we can change this step as you will see
159:29 - later in this video
159:32 - since range generates a sequence of
159:35 - numbers it is commonly used in for loops
159:37 - to iterate the loop a certain number of
159:40 - times let me give you an example so here
159:42 - i'll remove this old code and i'll say
159:44 - for
159:45 - value in range 1 comma 6
159:50 - and then i'll say print
159:51 - value
159:53 - iteration
159:55 - here this range gives us a sequence from
159:59 - 1 which is included to 5 because 6 is
160:02 - not included now when i press run then
160:05 - it says one iteration two iteration it
160:07 - goes up to five
160:09 - as we can see the loop iterates five
160:12 - times from value equal to one to value
160:14 - equals five
160:17 - in our examples up to now we have passed
160:20 - two parameters to the range function
160:23 - start which is the start of the sequence
160:25 - and stop at which the sequence stops
160:28 - it's also possible to use range without
160:31 - passing the start parameter if the start
160:33 - parameter is not passed 0 is used as the
160:37 - default value let me give you an example
160:40 - so here i'll say
160:41 - result equals range
160:44 - 11
160:45 - and then i'll say
160:46 - print
160:48 - list
160:49 - result now when i press run
160:52 - then it gives me a value from 0 to 10
160:55 - because it's the same as saying give me
160:57 - a range from 0 to 11 and when i press
161:01 - run it essentially gives me the same
161:03 - result
161:04 - this makes it even easier to use range
161:06 - function in a for loop suppose i want to
161:09 - iterate a loop five times i can simply
161:12 - pass five to the range function like
161:13 - this so i'll remove this whole code and
161:15 - i'll say for
161:17 - value
161:18 - in range 5
161:21 - and print
161:22 - value
161:24 - this loop
161:25 - iterates 5 times from the value 0 to the
161:29 - value equals 4 when i press run then you
161:32 - can see it says 0 to 4.
161:37 - if you have noticed in our examples the
161:40 - gap between two consecutive numbers is 1
161:43 - let me show you again so i'll remove
161:45 - this old code and i'll say result equals
161:47 - list
161:48 - range
161:50 - 1
161:51 - 11
161:52 - and when i print this
161:54 - as expected it says 1 to 10. as we can
161:58 - see the difference between the numbers
162:01 - is 1.
162:03 - this is because by default step of 1 is
162:07 - used this code is equivalent to adding 1
162:10 - as the third parameter
162:12 - which is the step that we want to use
162:15 - this range function basically means
162:18 - start from this number
162:20 - go up to this number not including it
162:22 - and use one as the stepping number
162:27 - let me change the step to 3 and see what
162:29 - happens so here i'll replace this one
162:31 - with 3 and when i press run
162:34 - then this time the difference between
162:36 - two consecutive items of this sequence
162:39 - is three
162:42 - we can also use negative numbers in the
162:44 - range function like this so i'll remove
162:46 - this old code
162:48 - and i'll say result equals
162:51 - list
162:52 - range
162:54 - 5
162:55 - to minus 6
162:57 - and the step will be -1
163:01 - now when i print the result
163:03 - and press run
163:05 - then you can see that it started from
163:07 - the number five it went up to minus six
163:10 - but not including minus six and the
163:13 - difference between two consecutive
163:16 - list items is minus one
163:19 - by the way range only works for integers
163:22 - we cannot use floating point numbers
163:25 - inside the range function
163:27 - at this point we have covered all the
163:29 - basics of python's range function before
163:31 - we end this video here's a task for you
163:34 - can you create a list like this using
163:36 - the range function
163:38 - i'll give you a couple of seconds to
163:40 - pause the video here
163:43 - as always you'll find the answer to this
163:45 - question in our github repository i'll
163:48 - also include this link in the
163:49 - description below now here's a recap of
163:52 - what we learnt in this video the range
163:54 - type is used to create a sequence of
163:56 - numbers
163:57 - range is commonly used in for loops to
164:00 - iterate the loop a certain number of
164:02 - times
164:03 - we cannot use floating point numbers
164:05 - inside range
164:08 - you've probably heard that python is an
164:10 - object-oriented programming language in
164:12 - this video you will learn what
164:14 - object-oriented programming is and why
164:16 - it is used after that we will implement
164:19 - the object-oriented style of programming
164:21 - in our code by creating two practical
164:23 - examples so let's get started suppose we
164:26 - need to store the name and marks
164:28 - obtained by university students and
164:30 - based on the marks obtained by the
164:32 - students we also need to find out if
164:34 - they passed or failed their exam
164:36 - then the structure of our code would
164:38 - look something like this
164:41 - now imagine that instead of one student
164:43 - you have to do this for numerous
164:45 - university students if you were to use
164:47 - the same approach our code would be less
164:50 - organized and it would look messy
164:52 - since these data and functions are
164:54 - related it would be amazing if we could
164:57 - treat them as a single entity
164:59 - we can do exactly that by creating
165:01 - objects
165:02 - this helps us to make programs more
165:05 - organized
165:06 - now there are two steps required to
165:08 - create objects first we need to define a
165:11 - class
165:12 - since we are working with students we
165:14 - can create a class name student
165:17 - this student class acts as a blueprint
165:20 - for the objects
165:21 - all objects created from this class have
165:23 - name and marks data and can use the
165:26 - check pass fail function
165:28 - think of a class as a blueprint of a
165:30 - house it contains all the details about
165:33 - the floors doors windows etc
165:37 - based on these descriptions we built the
165:39 - house
165:40 - the actual physical house is the object
165:43 - as many houses can be made from a
165:45 - house's blueprint we can create many
165:48 - objects from a single class so from our
165:50 - student class we can create as many
165:52 - student objects as we want
165:55 - the concept of object-oriented
165:56 - programming is not native to python and
165:59 - is available to most of the programming
166:00 - languages
166:02 - now that we know what objects are let's
166:04 - implement them in python as mentioned
166:06 - before we need to define a class before
166:09 - we can create objects let's do that
166:11 - first and here i'll say class
166:14 - student
166:15 - and then i'll just use pass
166:18 - here i have defined a class named
166:20 - student
166:22 - at the moment our class doesn't have any
166:24 - attributes and methods since classes
166:26 - cannot be empty i have added a pass
166:29 - statement so that i can run the code
166:31 - without any errors
166:32 - by the way when working with objects
166:35 - variables are called attributes and
166:37 - functions are called methods
166:39 - from now on we will be using these terms
166:42 - when working with objects now that we
166:45 - have defined a class we can create as
166:47 - many objects as we want from it let me
166:49 - create two objects of the class i'll say
166:53 - student 1 equals
166:56 - student in parenthesis and then i'll say
166:58 - student 2
167:00 - equals
167:01 - student and again parentheses
167:04 - here student 1 and student 2 are both
167:08 - objects of the student class
167:11 - now we can start adding different
167:13 - attributes to these object instances
167:15 - first let me remove the student 2
167:18 - and here i'll say student 1 dot name
167:23 - equals
167:24 - harry
167:26 - here we have assigned harry to the name
167:29 - attribute of the student1 object
167:32 - let me add another attribute to our
167:34 - object so here i'll say student
167:37 - 1 dot marks equals 85
167:41 - and i'll print these attributes
167:43 - i'll say print student
167:46 - 1
167:46 - dot name
167:48 - and print
167:50 - student
167:52 - 1 dot marks
167:54 - now when i press run
167:56 - i get harry and 85 back
167:59 - we have successfully added two
168:01 - attributes to a student1 object
168:03 - however this is not the proper way to
168:05 - add attributes to objects usually what
168:08 - we want to do is we want to put
168:10 - attributes inside our class so that all
168:13 - the objects created from the class have
168:15 - these attributes by default similarly we
168:18 - also put all methods inside our class so
168:20 - that every object of the class can
168:22 - access them
168:24 - let's first see how we can add methods
168:26 - inside a class
168:27 - then we will look into the proper way to
168:29 - create attributes here i have defined
168:32 - the
168:33 - check pass fail method inside the class
168:37 - now any object created from this class
168:40 - will have access to the check pass fail
168:42 - method if you have noticed we have used
168:46 - self as an argument here and self.marks
168:49 - inside the method
168:51 - we will talk about that in a moment
168:53 - let's first access this method using the
168:55 - student1 object
168:57 - so at the end here i'll say
169:00 - did underscore pass
169:02 - equals
169:05 - student 1 dot
169:08 - check
169:09 - underscore pass underscore fail
169:13 - and then i'll say
169:15 - i'll remove these two lines and i'll say
169:17 - print
169:18 - did underscore pass
169:20 - now when i press run
169:22 - then as expected it prints true because
169:25 - the student one has enough marks to pass
169:29 - let's see from the very beginning what's
169:31 - going on here
169:32 - we have created a class and we have
169:35 - defined a check pass fail method inside
169:37 - it
169:38 - then we created an object from this
169:41 - class
169:42 - and added two attributes name and marks
169:45 - to it
169:46 - finally we called the check pass fail
169:49 - method using the student1 object
169:52 - we have called this method without
169:54 - passing any arguments however the method
169:57 - definition has an argument called self
170:01 - now you must be thinking shouldn't this
170:02 - give us an error
170:04 - well whenever we define methods for a
170:07 - class we need to use self as the first
170:09 - argument
170:10 - this self represents the object calling
170:13 - it in our example self refers to the
170:16 - student1 object and self.marks refers to
170:20 - the marks attribute of the student1
170:22 - object
170:24 - so the object is passed as the first
170:26 - argument automatically
170:27 - if you create another object let's say
170:30 - student2 and call this method then self
170:33 - represents the student2 object and
170:35 - self.marks represents the marks
170:37 - attribute of the student2 object let's
170:40 - write out
170:41 - student
170:43 - 2 equals
170:44 - student
170:46 - student
170:47 - 2 dot
170:49 - name
170:50 - equals
170:52 - janet
170:54 - student
170:55 - 2 dot marks equals
170:58 - 30
170:59 - did underscore pass equals
171:02 - check
171:03 - pass fail
171:05 - oops student
171:07 - two dot check pass fail and let me print
171:11 - did underscore pass
171:13 - now when i press run then i get true
171:15 - first and i get false here marks of
171:19 - student 1
171:21 - is 85 so in this method
171:24 - self.marks is 85 which is greater than
171:27 - 40 that's why true is returned
171:30 - similarly for student 2
171:33 - student.2.max is 30 so self.max greater
171:36 - than equals to 40 is false that's why we
171:38 - get false
171:41 - by the way we can use any name instead
171:43 - of self here
171:45 - is just an identifier like variable
171:47 - names using self is a convention and for
171:50 - consistency we will also keep using self
171:53 - adding attributes to the object manually
171:55 - after defining it is not a good practice
171:58 - instead python offers a much more
172:01 - elegant and compact way of defining
172:03 - attributes right while instantiating the
172:06 - object
172:07 - for that we use the init method
172:09 - the init method is a special method that
172:12 - automatically gets called every time
172:14 - objects are created
172:16 - if you're coming from other programming
172:18 - languages like c plus or java the python
172:21 - init method closely resembles
172:23 - constructors
172:24 - so let's see how we can use the init
172:26 - method in our code and i'll remove the
172:28 - student 2 code
172:32 - and i'll also remove
172:33 - the code that adds the attributes of
172:36 - name and marks to the student1 object
172:38 - then i'll say
172:41 - def
172:43 - underscore underscore init underscore
172:45 - underscore
172:48 - self
172:49 - name
172:51 - marks
172:53 - and i'll say self dot name equals name
172:56 - self.marks equals marks
172:59 - and here i'll say
173:01 - harry
173:03 - and 85
173:05 - now let me also remove this did pass and
173:07 - i'll say print
173:09 - student one dot name
173:12 - and print
173:13 - student one dot marks
173:16 - let's see what's happening here when we
173:18 - create an object
173:19 - this init method is called automatically
173:23 - with the values harry and 85 passed to
173:26 - name and marks automatically
173:29 - remember the first parameter self
173:32 - represents the object calling it while
173:35 - the second and third parameter take the
173:37 - two arguments which were used during
173:39 - object creation
173:42 - now for the student1 object the name
173:45 - attribute will be harry because of the
173:47 - statement self.name equals name
173:50 - and marks will be 85
173:52 - because of the statement self.marks
173:54 - equals marks
173:56 - when i run this code
173:58 - then i get harry and 85.
174:01 - let's create another object first i'll
174:04 - add
174:05 - another student student 2
174:08 - equals
174:10 - student
174:12 - janet
174:14 - 30 and let me print those so i'll say
174:16 - print student
174:18 - 2 dot name
174:20 - and
174:21 - print
174:22 - student 2 dot marks now when i press run
174:26 - then i get harry 85 janet and 30.
174:30 - now let me check if student 1 and
174:32 - student 2 passed or failed the exams we
174:35 - already have the check pass fail method
174:37 - defined for this purpose we just need to
174:39 - call it
174:40 - but first i'll remove the code to print
174:42 - the attributes
174:44 - and then i'll say did underscore pass
174:47 - equals
174:48 - student1 dot
174:50 - check
174:51 - pass fail
174:53 - let me print
174:55 - did underscore pass and again i'll
174:57 - modify did pass so that i know the value
175:00 - or the pass field status of state
175:02 - student two so else it did underscore
175:04 - pass equals
175:06 - student two dot check
175:09 - pass
175:10 - fail
175:12 - print did underscore pass
175:15 - you must have guessed the output by now
175:16 - but let me run the code and verify
175:18 - anyways so i'll press run
175:21 - and as expected true and false are
175:23 - returned because in this line
175:26 - did underscore pass will be true since
175:28 - the first student harry has enough marks
175:31 - to pass the exam similarly here did pass
175:34 - will be false because student 2 does not
175:37 - have enough marks to pass the exam
175:41 - let's see how this program works from
175:42 - the very beginning again
175:44 - we have created a class with two methods
175:47 - an init method that initializes the
175:49 - attributes of name and marks and a check
175:52 - pass field method that returns true if
175:55 - the marks is greater than 40 greater
175:57 - than equals 40 and false if it's not
176:00 - greater than equals 40. we then created
176:03 - student1 in this line
176:05 - with the parameters harry and 85 when
176:09 - this object is created the init method
176:11 - is called
176:12 - and name and marks attributes of this
176:15 - student1 object are now harry and 85
176:19 - then we checked if student1 passed the
176:22 - exam and printed the result
176:25 - we had also created another object
176:27 - student 2 by passing janet and 30 so the
176:30 - name and marks of the student 2 object
176:32 - are janet and 30
176:34 - and then we calculated if the student
176:37 - had passed or not using the check pass
176:39 - fail method of the student 2 object and
176:41 - we printed the result
176:44 - i hope you have some idea of how classes
176:47 - and objects work by now let's try one
176:49 - more example for extra clarity in this
176:52 - example we will add two complex numbers
176:54 - manually
176:55 - python already handles this by default
176:58 - but we will create our own complex class
177:00 - to better understand the concepts of
177:02 - object oriented programming if you do
177:04 - not know a complex number has real and
177:07 - imaginary parts when we add two complex
177:10 - numbers we need to add the real and
177:12 - imaginary parts separately
177:14 - let's first create a class that
177:16 - represents complex numbers
177:18 - i'll remove this old code and i'll type
177:20 - class
177:21 - complex
177:23 - and here i'll define a unit function so
177:25 - i'll say def
177:27 - init
177:29 - self
177:31 - real
177:32 - image
177:35 - and inside this i'll say self dot real
177:37 - equals real
177:38 - and self dot imaginary equals image
177:43 - and now let me create two objects n one
177:46 - equals complex
177:49 - 5
177:50 - 6
177:51 - and n 2 equals complex
177:55 - minus 4 and 2.
177:58 - at this point we have created two
178:00 - complex numbers n1 and n2 and initialize
178:04 - the real and imaginary parts
178:06 - now we'll create a method to add these
178:08 - complex numbers so inside our class i'll
178:11 - add the code i'll say def
178:13 - add
178:15 - self
178:15 - number
178:16 - and here i'll say
178:19 - real equals
178:21 - self dot real plus
178:24 - number dot real and i'll say image
178:27 - equals self dot image plus
178:30 - number dot image
178:33 - then i'll say result
178:36 - equals
178:38 - complex
178:39 - real
178:41 - image
178:42 - and i'll return this result object
178:45 - now let me call the add method so here
178:48 - i'll say result equals
178:51 - n1 dot add
178:53 - n2
178:55 - here we have called the add method on
178:57 - the n1 object and pass the n2 object to
179:01 - it
179:01 - so
179:02 - inside the add method self will be n1
179:06 - and number will be n2 then the real and
179:09 - imaginary parts of these numbers are
179:11 - added separately so real equals self dot
179:14 - real plus number
179:16 - dot real means
179:18 - n1 dot real plus n2.real
179:20 - similarly image equals
179:23 - self.image.plusnumber.image means n1
179:25 - because n1 is self n1.image and number
179:28 - is n2 so n2.image
179:31 - we have then created another object of
179:33 - the complex class using the result
179:36 - values
179:37 - and then returned it in the next line
179:39 - now let's print the attributes of the
179:41 - result object
179:43 - i'll say print
179:45 - real
179:47 - equals
179:50 - result dot real
179:52 - and print
179:55 - image
179:57 - equals
179:59 - result dot image
180:01 - now when i press run
180:04 - there seems to be a problem i forgot the
180:05 - column now when i press run
180:08 - then i get real equals 1 image equals 8
180:11 - let's verify so 5 minus 4 is 1
180:15 - and 6 plus 2 is 8 so the answer is
180:17 - correct
180:18 - as you can see the real and imaginary
180:21 - parts have been added separately as
180:23 - expected
180:26 - why object-oriented programming
180:29 - as we have seen from our examples
180:31 - creating objects allows us to organize
180:33 - related data and functionalities
180:35 - together
180:36 - this helps us to write structured and
180:38 - flexible code now instead of thinking in
180:40 - terms of individual data and functions
180:43 - we start thinking in terms of objects
180:45 - and how one object interacts with the
180:47 - other
180:48 - this helps us to divide a complex
180:50 - problem into smaller sub problems
180:53 - also using an object oriented style of
180:55 - programming makes our code reusable
180:57 - because we can define multiple objects
180:59 - with similar attributes and
181:01 - functionalities from a single class
181:04 - before we end this video here's a task
181:06 - for you
181:07 - create a class named triangle
181:09 - create an object from it the object will
181:12 - have three attributes named a b and c
181:15 - that represent the sides of the triangle
181:18 - the triangle class will have two methods
181:20 - the init method to initialize the sides
181:23 - and a method to calculate the perimeter
181:25 - of the triangle from its sides the
181:27 - perimeter of the triangle should be
181:28 - printed from outside the class here's
181:31 - the bare bones code for the program
181:34 - you'll find the complete answer to this
181:35 - question along with source code of all
181:38 - the programs in this video in our github
181:39 - repository the link will be in the
181:41 - description below if you're enjoying
181:43 - this video please also check out
181:45 - programs pro where we provide tutorials
181:47 - along with quizzes and challenges which
181:49 - will help you practice and test your
181:50 - learning in real time also the course
181:53 - includes projects to give you an awesome
181:54 - experience of how programming works in
181:56 - the real world and for our youtube
181:58 - subscribers we are giving 50 off on the
182:00 - yearly plan sign up by scanning this qr
182:02 - code or use the link in the video
182:03 - description to claim your discount
182:07 - you probably heard python is an
182:09 - object-oriented programming language
182:11 - numerous times at this point
182:13 - this means python supports user-defined
182:15 - classes and objects
182:17 - one thing that is particularly
182:19 - interesting about python is that you can
182:21 - not only create custom objects but every
182:24 - pre-existing thing available in python
182:26 - is already an object whether it's
182:28 - strings numbers functions or even
182:31 - classes
182:32 - in this video we will learn to check the
182:34 - type of objects find their attributes
182:36 - and methods and have a solid
182:38 - understanding of python objects which
182:40 - will help you become a better python
182:42 - programmer everything in python is an
182:44 - object and we can check this using the
182:46 - type function let's try it out i'll go
182:49 - to my code editor and i'll say numbers
182:52 - equals 1 comma 4
182:55 - comma 9 comma 16
182:59 - and let me say print
183:01 - type
183:02 - numbers
183:04 - let me run this code
183:07 - in the output we see class list this
183:10 - means
183:11 - the numbers list
183:12 - is an object that is instantiated from
183:15 - the list class
183:17 - let's try a few more examples so let me
183:20 - create a number i'll say n1 equals 5
183:23 - and let's print the type
183:26 - i'll also try a few other data types so
183:29 - i'll say flag equals true
183:32 - print type
183:33 - flag
183:34 - let me also try a function so i'll say
183:37 - def
183:38 - my underscore function
183:40 - and i'll create an empty function
183:42 - now let me say print
183:44 - type
183:46 - my underscore function
183:49 - now when i press run
183:51 - we can see that all these entities are
183:54 - instantiated from a class which means
183:56 - they are all objects
184:02 - we can list out all the attributes and
184:04 - methods of a given object by using the
184:06 - dir function let's try it out let me
184:09 - remove this code first
184:11 - and i'll say numbers underscore list
184:14 - equals
184:16 - 1 comma 2.
184:19 - in the next line i'll say print
184:21 - dir
184:23 - numbers underscore
184:25 - list
184:26 - now when i press run
184:30 - this means that our list can access all
184:32 - these attributes and
184:34 - methods let's use the underscore
184:37 - underscore add underscore underscore
184:38 - method that's the first element of this
184:41 - list
184:42 - it is used to append all the items of
184:44 - another list to the end of the current
184:46 - list so i can say
184:50 - let me first
184:53 - comment this out then i'll say
184:56 - result
184:57 - equals
184:58 - numbers underscore list
185:02 - dot underscore underscore add underscore
185:04 - underscore and then let me add another
185:07 - list three comma four
185:10 - now let me print the result and see what
185:12 - we get when i press run
185:14 - then i get a list that has one and two
185:17 - and the elements of the other list
185:19 - appended at the end
185:21 - by the way we can also accomplish this
185:24 - task by using the plus operator like
185:26 - this i'll first comment out this code
185:30 - and then i'll say result
185:32 - equals
185:34 - numbers
185:35 - underscore list plus
185:37 - three comma four when i press run
185:41 - then i get the same output as before
185:44 - in fact the plus operator
185:47 - internally calls this same underscore
185:50 - underscore add underscore underscore
185:51 - method when working with lists that's
185:54 - why we can use the operator like this
185:56 - as you can see even though we are
185:58 - working with operators we are actually
186:01 - using attributes and methods of the
186:03 - object internally
186:05 - let me uncomment this code and run it
186:08 - again
186:10 - if you look at the attribute of lists we
186:12 - can see append clear
186:14 - copy
186:15 - count and many other methods that we've
186:18 - been using from before
186:19 - so if you're unsure about what
186:21 - attributes and methods an object can use
186:24 - the dir method can be useful the id
186:27 - function
186:28 - in python every object has an id for
186:31 - identity the id of an object is always
186:34 - unique and constant for this object
186:36 - during its lifetime you can check the id
186:38 - of an object by using the id function
186:40 - let's try it out so in my code editor
186:42 - i'll remove this old code
186:46 - and i'll say number one
186:48 - equals five
186:50 - print
186:51 - id
186:52 - of number one
186:53 - and let me create another number so i'll
186:55 - say number two
186:58 - equals 10
187:00 - print id
187:02 - of number two
187:03 - now when i press run
187:05 - then you can see two numbers
187:09 - nine 978
187:09 - two and nine seven eight five one five
187:11 - two are printed
187:13 - this is the id of the number one object
187:16 - and this is the id of the number two
187:18 - object
187:20 - let me modify this program and i'll
187:22 - assign number one to number two
187:25 - so here i'll say number two equals
187:27 - number one and when i press run now
187:30 - you can see that both of these ids are
187:33 - the same
187:35 - this is because we're working with the
187:36 - same object python does this for memory
187:39 - optimization
187:42 - suppose we have a code like this
187:45 - in our previous videos we have been
187:47 - saying that 5 is stored in a but this is
187:50 - technically wrong
187:51 - here a is more like a name tag and it
187:54 - can refer to any value currently it is
187:57 - referring to object 5.
187:59 - now if you create another variable b and
188:02 - assign a to it then both a and b will
188:05 - refer to the same object let me give you
188:08 - another example of this suppose we have
188:10 - a list like this so i'll say a equals 1
188:13 - comma 2 comma 3
188:15 - let me assign this variable to another
188:17 - variable so here i'll say b equals a
188:22 - now i'll modify a by adding one more
188:24 - element to it so i'll say a dot append
188:28 - and the element 4
188:30 - next let me print the values of a and b
188:32 - so here i'll say print
188:34 - a
188:35 - equals
188:36 - a
188:37 - and print
188:38 - b
188:39 - equals
188:41 - b
188:42 - i'll run this code
188:44 - and you can see a and b both have the
188:47 - same value even though i have made no
188:48 - changes to b
188:51 - this is because a and b are referring to
188:53 - the same object
188:55 - as you can see
188:57 - i've done b equals a
189:00 - and if we check the id of the variables
189:02 - a and b they will be the same
189:04 - that's why we use the list copy method
189:07 - to copy one list to another if you do
189:09 - not want this kind of behavior so here
189:12 - i'll say a dot copy
189:15 - and now when i press run
189:17 - then you can see a and b don't have the
189:19 - same value because i have only modified
189:22 - a and b
189:24 - which was a copy of a
189:25 - is not modified at all
189:28 - that's it for this video you can find
189:30 - the source code of all these programs in
189:32 - our github repository the link will be
189:34 - in the description below
189:38 - before we learn about python inheritance
189:40 - let's see an example of why it is used
189:42 - and what problem it solves
189:44 - suppose we are creating a racing game
189:47 - that will have cars and motorcycles to
189:49 - solve this problem we can create two
189:51 - separate classes to handle each of their
189:53 - functionalities however both cars and
189:56 - motorcycles are vehicles and they will
189:58 - share some common attributes and methods
190:01 - so instead of creating two independent
190:03 - classes what we can do is create a
190:05 - vehicle class that shares the common
190:08 - features of both cars and motorcycles we
190:11 - can then derive a car class from the
190:13 - vehicle class
190:14 - in doing so the car class will inherit
190:17 - all the attributes and methods of the
190:18 - vehicle class and we can later add car
190:21 - specific features to the car class
190:24 - we can also create a motorcycle class
190:26 - that inherits from vehicle in a similar
190:28 - way
190:29 - this is the basic concept of inheritance
190:31 - it allows us to inherit attributes and
190:34 - methods from a parent class to a child
190:36 - class in this example vehicle is our
190:39 - parent or base class while car and
190:41 - motorcycle are our child or derived
190:44 - classes by writing programs in this way
190:46 - we can reuse code that is common for
190:49 - different classes and also makes our
190:51 - code easier to use and maintain
190:54 - now that we know about inheritance let's
190:56 - learn how to implement it in python with
190:58 - the help of example we will derive a dot
191:01 - class from an animal class and get a
191:04 - feel of how inheritance works then we
191:06 - will move on to create a more practical
191:08 - example
191:10 - so i'll say class
191:12 - animal
191:14 - let's define a method named eat inside
191:16 - it
191:17 - so here i'll say deaf
191:19 - eat
191:21 - self
191:23 - and inside i'll say print
191:25 - i can eat
191:28 - this is our base or parent class
191:31 - now let's derive the dog class from this
191:33 - class
191:34 - so here i'll say
191:38 - class
191:39 - dog
191:40 - and before parenthesis i'll add animal
191:43 - inside braces
191:47 - inside this class i will create the bark
191:49 - method which is specific to the dot
191:51 - class so here i'll say def
191:54 - bar
191:56 - self
191:58 - and inside the function definition i'll
192:00 - say print
192:02 - i can
192:03 - bark
192:04 - this dog class inherits all the
192:07 - attributes and methods of the animal
192:08 - class
192:09 - this means objects of dog can also
192:12 - access attributes and methods of animal
192:15 - let's see how
192:16 - so here i'll say i'll create a new
192:18 - object called dog one and i'll say dog
192:21 - one equals dog
192:24 - now i can call this bark method on the
192:27 - dog one object
192:29 - so i'll say dog one dot bark now when i
192:32 - run this code you must have imagined the
192:34 - output already it says i can bark
192:37 - since our dog class is inherited from
192:40 - the animal class
192:42 - dog one can also call the eat method
192:44 - defined in animal so i can say
192:48 - dog one
192:50 - dot eat
192:51 - and now when i press run
192:53 - then
192:54 - i can eat is also printed because dog
192:57 - one has access to the eat method of the
193:00 - animal class
193:02 - let's see from the very beginning what's
193:04 - happening here
193:05 - we derived the dog class from the animal
193:08 - class
193:09 - so the dog class inherits all the
193:11 - features of the animal class
193:14 - now this object of the animal class can
193:17 - access attributes and methods of both
193:19 - the dog class and animal class
193:22 - similarly if we want we can derive
193:24 - another class called cat from the animal
193:26 - class like this
193:27 - so here i can say
193:30 - class
193:31 - cat and inside braces i'll say animal
193:35 - so inside this class i'll define a
193:37 - method called get grumpy so i'll say def
193:40 - get underscore
193:43 - grumpy
193:45 - self
193:47 - and inside this i'll say print
193:49 - i
193:50 - am
193:51 - getting
193:53 - grumpy
193:55 - now let me create an object of the cat
193:58 - class
193:59 - cat one equals cat
194:02 - and let's call
194:03 - the eat method to see if it is
194:05 - accessible to cat so here i'll say cat1
194:08 - dot eat
194:10 - and when i press run
194:12 - then as you can see i can eat is printed
194:15 - from the cat1 object
194:17 - as well
194:19 - as we just saw cat objects can also use
194:21 - the eat method defined in the parent
194:23 - class
194:24 - even from this very simple example we
194:26 - can see that inheritance makes our code
194:29 - more organized and reusable
194:31 - let's now look at a more practical
194:33 - example of inheritance and we will also
194:35 - cover the concept of method overriding
194:37 - in our example
194:38 - we are going to implement a program to
194:40 - calculate the perimeter of different
194:42 - polygons like triangles and
194:44 - quadrilaterals using inheritance here's
194:46 - what we will do we will first create a
194:49 - polygon class that has an init method a
194:52 - method to calculate perimeter and a
194:53 - method to display the definition of a
194:55 - polygon
194:56 - we will then derive two classes triangle
194:59 - and quadrilateral from it in these
195:01 - classes we will add methods specific to
195:04 - them
195:05 - let me first create a base class called
195:07 - polygon so in my code editor i'll remove
195:10 - the old code and i'll say class
195:12 - polygon
195:15 - and inside it i'll create an init
195:17 - function
195:19 - underscore underscore init underscore
195:21 - underscore and pass in self and i'll
195:23 - pass in the sides as the second argument
195:27 - so here i'll say self dot sides equals
195:30 - sides
195:33 - to make things easier we will make the
195:35 - sides attribute a list that will contain
195:37 - all the sides of a polygon
195:40 - now let me add a display info method to
195:42 - display information about this polygon
195:45 - so here i'll say def
195:47 - display underscore info
195:50 - it will also take the self parameter by
195:52 - default and inside i'll say print
195:55 - a polygon
195:57 - is a two
195:59 - dimensional
196:01 - shape
196:02 - with straight
196:05 - lines
196:07 - let me also add a perimeter method that
196:09 - will find the perimeter of this polygon
196:11 - remember that perimeter is the sum of
196:13 - all sides of a polygon so in my code
196:16 - editor i'll define the perimeter method
196:18 - as
196:19 - i'll say def
196:21 - get underscore
196:23 - perimeter
196:25 - self
196:28 - perimeter
196:31 - perimeter
196:32 - equals
196:34 - self
196:35 - oops sorry sum
196:37 - self dot sides
196:39 - sum is a function that can act on a list
196:42 - and provide the sum of the elements of
196:44 - that list
196:45 - so then i'll say return
196:48 - perimeter
196:51 - this will be our base class all polygons
196:54 - like triangles and quadrilaterals will
196:56 - derive these features
196:58 - now that we are done creating the base
197:00 - class let's create a triangle class that
197:02 - will inherit from the polygon class
197:05 - so i'll go here and i'll say class
197:08 - triangle
197:09 - and then because we want to inherit from
197:11 - the polygon class inside
197:13 - parenthesis i will say polygon and i
197:16 - have my regular colon
197:19 - inside the triangle class i'll define a
197:22 - function called display underscore info
197:23 - so i'll say def
197:25 - display underscore info
197:28 - self
197:29 - and the definition of a triangle is
197:31 - print
197:32 - a triangle is a
197:35 - polygon with three
197:37 - edges
197:39 - i'll also define the new quadrilateral
197:41 - class
197:42 - so i'll say class
197:45 - quadri
197:47 - lateral
197:48 - and also again derived from polygon and
197:51 - inside it i'll say def display
197:54 - underscore info
197:56 - self
197:57 - now let me define a pull a quadrilateral
197:59 - i'll say print a quadri
198:02 - lateral
198:04 - is a polygon
198:07 - with four
198:09 - edges
198:10 - here in each of these cases we have
198:12 - defined a child class from the parent
198:14 - polygon class that will inherit all the
198:17 - attributes and methods of the polygon
198:19 - class
198:20 - now let's find the perimeter of a
198:21 - triangle
198:22 - first i'll create an object of a
198:24 - triangle class so i'll say
198:26 - t1 equals
198:29 - triangle
198:30 - let me pass in the sides of the triangle
198:34 - when we create the t1 object the init
198:36 - method of the polygon class is called
198:40 - automatically
198:41 - now let's find its perimeter so here
198:44 - i'll say
198:47 - perimeter
198:49 - equals t1 dot get underscore
198:53 - perimeter
198:55 - this code calls the get parameter method
198:59 - in that is defined inside the polygon
199:01 - class
199:03 - and returns the perimeter of the t1
199:05 - triangle
199:06 - let's print parameter and run the code
199:08 - to see if our program is working
199:09 - correctly
199:10 - so i'll go back down and i'll say
199:13 - print
199:14 - the perimeter is
199:18 - and
199:19 - i'll say perimeter
199:21 - now when i press run
199:23 - then there seems to be an error okay
199:25 - triangle object has no attribute get
199:27 - parameter
199:28 - so i have forget underscore parameter
199:30 - correctly oh i am i've misspelled
199:34 - perimeter here now when i press run
199:37 - then it says the perimeter is 18 so 5
199:40 - plus 6 plus 7 is 18 that means my answer
199:42 - is correct
199:43 - as we can see we get the perimeter as
199:46 - expected
199:51 - if you've noticed we have this display
199:54 - underscore info method in both the
199:56 - polygon class
199:58 - and the two derived classes as well
200:02 - let's see what will happen if we call
200:04 - the display info method for the t1
200:06 - triangle
200:07 - so here i'll say
200:09 - t1
200:10 - dot
200:11 - display
200:12 - underscore info and when i run the code
200:16 - we can see that the display info method
200:19 - of the triangle class is called
200:21 - instead of the display info method of
200:24 - the parent class this is called method
200:26 - overriding if the same method is defined
200:28 - in both the base and the derived class
200:31 - then the method of the derived class
200:33 - overrides the method of the base class
200:36 - let's see from the very beginning what's
200:37 - happening here
200:39 - we defined a polygon class and created
200:42 - three methods inside it the init method
200:45 - the display info method and the get
200:47 - parameter method
200:49 - then we derive two classes
200:52 - triangle
200:53 - and quadrilateral
200:54 - where we again define the display
200:56 - underscore info method
200:59 - inside the display method of the
201:01 - triangle and the quadrilateral classes
201:04 - we defined specific details of both
201:07 - triangles and quadrilaterals
201:09 - this is called method overriding due to
201:12 - this when we call display info using
201:14 - triangle objects it doesn't use display
201:16 - info of polygon rather its own display
201:19 - method is called
201:21 - by the way if we need we can call the
201:23 - display info method of our parent
201:24 - polygon class from inside its child
201:27 - classes like this
201:28 - here inside the display info method of
201:31 - the triangle class i can say
201:34 - polygon
201:36 - dot
201:36 - display underscore
201:39 - info
201:40 - and self
201:42 - when i run the code
201:45 - then it also prints a polygon is a two
201:47 - dimensional shape which means the
201:49 - display underscore info method of the
201:51 - polygon class was called correctly
201:54 - as we can see
201:55 - the print function inside the display
201:58 - info of the triangle method was called
202:00 - first and then only after that the
202:02 - polygon classes display info function or
202:05 - method was called
202:08 - here polygon is the name of the parent
202:10 - class
202:11 - since we are calling the method using
202:12 - the class rather than an object we need
202:15 - to pass self explicitly here
202:18 - this code is a bit more unorthodox than
202:20 - what we have been using there is a more
202:23 - elegant way to achieve the same task by
202:25 - using the super function like this so
202:27 - here instead of pulling on i'll say
202:30 - super
202:31 - and when i press run
202:33 - it says display info takes one
202:35 - positional argument but two were given
202:37 - this means i don't need to pass self
202:39 - when i press run then i get the same
202:42 - output
202:43 - the super function
202:45 - returns a temporary object of the
202:47 - superclass for a subclass
202:50 - simply speaking super is an object of
202:52 - polygon in this example and we are using
202:55 - it to call display info of the polygon
202:56 - class that is why it through an error
202:58 - when i add herself here because super is
203:02 - an object and not the class name
203:05 - we can use this to access the method and
203:07 - attributes of a parent class from inside
203:10 - a child class
203:11 - at this point we have covered all the
203:14 - fundamentals of python inheritance
203:16 - by the way we haven't used this
203:18 - quadrilateral class in our example yet
203:21 - if you want feel free to create objects
203:23 - of the quadrilateral class and try
203:25 - accessing the available methods as you
203:27 - please it will help you understand these
203:29 - concepts much better and get a feel of
203:31 - how things work in object oriented
203:33 - programming
203:34 - by the way you can find all the source
203:36 - code mentioned in this video in our
203:38 - github repository the link is in the
203:40 - description below
203:43 - let's talk about python modules a module
203:45 - is a file that contains python code that
203:47 - we can use in our program in this video
203:50 - we will learn why modules are used and
203:52 - how we can use them in our program then
203:54 - we will learn to create custom modules
203:56 - with the help of example there are
203:58 - several built-in functions like print
204:00 - input and sum that are readily available
204:02 - to us in addition to these functions
204:04 - python also has several functions that
204:06 - are defined inside a module which we can
204:09 - use after we import them let me give you
204:11 - an example to show you what i mean by
204:13 - this
204:14 - so i'll go to my code editor this time i
204:16 - am using the vs code code editor because
204:19 - i need to be working with multiple files
204:21 - and that feature is not in our online
204:23 - compiler yet so here in my code editor
204:26 - i'll create a new file
204:28 - called main dot pi
204:31 - and inside this file i'll say import
204:34 - math
204:36 - this will import the math module that
204:38 - comes when we install python this module
204:40 - contains many mathematical functions and
204:42 - constants let's use the square root
204:45 - function from this module this function
204:47 - is used to calculate the square root of
204:49 - a number so here i'll say number
204:51 - equals
204:53 - 25
204:54 - result
204:55 - equals
204:56 - math dot sqrt
204:59 - number
205:00 - and then let me print the result
205:03 - now i'll save this file and to run it i
205:06 - have to say
205:07 - python
205:08 - main dot pi when i press enter
205:11 - then you can see that 5.0 which is the
205:14 - square root of 25 is printed now let's
205:16 - access the pi constant defined inside
205:19 - this module in my code editor i'll say
205:22 - print
205:23 - math dot pi
205:26 - now let me save this file and run this
205:28 - code again
205:30 - and you can see that 3.141592
205:34 - the value of pi is printed so once we
205:36 - import a module we can use everything
205:39 - inside it using the dot operator
205:45 - while importing a module we can also
205:47 - rename it to a different name as per our
205:48 - needs let me demonstrate this with an
205:51 - example in my code editor i'll add
205:53 - import math as m
205:57 - now we can access the math module and
205:59 - its definitions using m instead of math
206:03 - so here
206:04 - and here i need to replace math with m
206:10 - and i'll save this file and run this
206:12 - code again and as you can see my code
206:15 - still works because math is now imported
206:17 - as m
206:18 - when we import a module like in our
206:20 - previous examples everything in the
206:21 - module is available to us however if we
206:24 - only need to import a specific
206:26 - definition like a function or a constant
206:28 - we can use the from import statement
206:31 - let's write out in my code editor i'll
206:33 - remove this whole code and here i'll say
206:36 - from math
206:38 - import sqrt
206:40 - now num equals sqrt
206:44 - 64 and now let me print the result num
206:48 - and i'll save this file i'll run this
206:50 - code
206:52 - and as you can see 8.0 which is the
206:54 - square root of 64 is printed
206:57 - here only the sqrt function is imported
207:00 - from the math module when we use this
207:02 - syntax instead of math.sqrt we need to
207:06 - directly use the sqrt function we can
207:08 - also import multiple definitions from
207:10 - the module in a single line using this
207:12 - syntax let me import the constant pi and
207:15 - the functions sqrt and sine from the
207:17 - math module so in my code editor i'll
207:20 - say from math import pi
207:23 - sine and sqrt and let me calculate the
207:26 - value of sine pi by 2 so i'll say value
207:30 - equals sine
207:32 - pi by 2
207:33 - and let me print this value
207:35 - i'll save this file
207:37 - and run my main.pi file and as you can
207:40 - see 1.0 which is the value of sine pi by
207:43 - 2 is printed
207:44 - we can also use this from import
207:46 - statement to import all definitions from
207:49 - a module like this so here instead of
207:51 - manually importing pi sine and sqrt i
207:54 - can also do from math import asterisk
207:58 - i'll save this file
207:59 - i'll clear the screen and then let me
208:02 - say python
208:03 - main dot pi when i press enter then you
208:06 - can see my code still works and sign
208:09 - sqrt and pi are still imported
208:13 - here asterisk means import everything
208:16 - a side tip for you importing every
208:18 - definition name with the asterisk symbol
208:20 - is a bad programming practice and you
208:22 - should try to avoid it in a code
208:26 - the math module comes with many more
208:28 - handy functions and constraints we can
208:30 - list out all the things defined inside a
208:32 - module by using the dir function
208:35 - let's list out all the definitions of
208:37 - the math module so in my code editor
208:39 - i'll remove this old code and here i'll
208:41 - say import
208:43 - math
208:44 - and then i'll say print
208:46 - dir
208:48 - math
208:49 - i'll save this file and again run main
208:51 - dot pi
208:53 - as you can see there are many other
208:54 - mathematical trigonometric and
208:56 - logarithmic functions inside the math
208:58 - module
208:59 - by the way the math module comes when we
209:02 - install python and that's why we can
209:04 - import it directly there are many
209:05 - popular modules that are not natively
209:07 - available for us to use for example
209:10 - numpy is a popular package that is used
209:12 - for scientific computing to use numpy we
209:15 - must first install it similarly you
209:17 - might have heard about django it's a
209:19 - popular framework used for creating web
209:21 - applications it's also available only
209:24 - after we install it to keep this video
209:26 - short and to the point we will not cover
209:28 - about installing such modules here if
209:30 - you're interested you can find plenty of
209:32 - resources about it on the web custom
209:34 - modules
209:35 - now let's learn about creating custom
209:37 - modules in python we can also create our
209:40 - own custom modules as per our needs
209:43 - this helps us to keep our code organized
209:45 - here we'll create a module named
209:47 - calculator that will contain functions
209:49 - to perform arithmetic operations so in
209:52 - my code editor i'll create a new file
209:55 - name calculator dot pi
209:58 - and inside calculator.pi let me create
210:01 - four arithmetic functions so i'll say
210:03 - diff add
210:05 - a comma b
210:07 - this should return the sum of a and b
210:10 - similarly i'll say diff
210:12 - subtract
210:14 - a comma b this should return the
210:16 - difference of a minus b
210:19 - diff
210:20 - multiply
210:21 - a comma b
210:23 - this should return a multiplied by b
210:25 - and lastly diff divide
210:28 - a comma b
210:29 - and this should return a divided by b
210:34 - this file is in itself a module let's
210:37 - import this file from the main file so
210:39 - i'll go to the main file and here i'll
210:41 - say import
210:43 - calculator and let me use the functions
210:46 - using the dot operator as we previously
210:48 - discussed so here i'll say result
210:51 - 1 equals
210:53 - calculator dot add
210:56 - 2
210:57 - comma 3
210:58 - now let me print result 1
211:01 - similarly result 2 equals calculator dot
211:06 - subtract
211:08 - 6 comma 3
211:11 - here i'll say print result 2
211:14 - similarly result 3 equals calculator
211:18 - dot multiply
211:21 - 10 comma 3
211:24 - now let me print result 3
211:27 - and finally result 4
211:30 - equals
211:32 - calculator dot
211:34 - divide
211:35 - 6 comma 3
211:37 - and let me print
211:39 - result four
211:41 - let me save this file and here i'll say
211:43 - python
211:47 - main dot pi now when i press enter then
211:50 - you can see that all these calculations
211:52 - were correctly done in our example we
211:55 - have only used functions and constraints
211:57 - from a module however a module may also
212:00 - contain classes or any other definitions
212:03 - from this very simple example we can
212:05 - already see how useful a module is it
212:07 - helps us in better code management and
212:10 - improves reusability of our code that's
212:12 - it for this video if you want to revise
212:14 - these concepts you can find all these
212:16 - programs in our github repository the
212:18 - link is in the description below
212:22 - talk about python packages a package is
212:24 - a directory containing multiple modules
212:26 - and other sub packages in this video we
212:29 - will learn about python packages with
212:31 - the help of examples then we will learn
212:33 - about pip the standard package manager
212:36 - of python suppose we are developing a
212:38 - large program to simplify this program
212:41 - we can first divide it into modules
212:44 - if our program is very large there might
212:46 - be a lot of these modules so we further
212:48 - need to group related modules together
212:50 - so that everything is organized python
212:53 - packages allow us to do just that they
212:56 - help us to organize related modules
212:58 - together
212:59 - let's look at an example to understand
213:01 - this concept even more clearly suppose
213:04 - we are developing a game with multiple
213:06 - objects so it may have these different
213:08 - modules
213:09 - since these modules are in the same
213:11 - location they look cluttered right now
213:13 - we can structure them in this way
213:15 - instead
213:17 - here the similar player and boss modules
213:20 - are kept under the character's package
213:22 - also
213:23 - gun and knife modules are kept inside
213:25 - the weapons package
213:27 - then both characters and weapons
213:29 - packages are again kept inside the main
213:32 - game package
213:33 - as you can see our project looks much
213:36 - more organized and structured with the
213:38 - use of packages
213:39 - now let's try to implement this in our
213:41 - code to keep this video short and to the
213:43 - point i will only implement the
213:45 - characters package but you will soon see
213:48 - that the core concept will be the same
213:50 - for other packages as well
213:52 - i'll first create a package name game
213:54 - that will contain all our game
213:56 - components so let me go to my code
213:58 - editor and i'll create a directory named
214:00 - game
214:02 - then i'll create a file named init.pi
214:04 - inside it
214:05 - so i'll say underscore underscore init
214:07 - underscore underscore dot pi
214:10 - this is a special file which will tell
214:12 - python that this directory is a python
214:14 - package i'll leave this file empty for
214:16 - now
214:17 - now let me create a sub package inside
214:19 - this game package
214:21 - so here i'll create a new folder called
214:23 - characters
214:26 - since this will also be a package let's
214:28 - not forget to add the init.pi file
214:30 - inside the characters folder as well
214:35 - this will tell python that characters is
214:37 - also a package
214:39 - or it is a sub package of the game
214:41 - package now i'll create two modules
214:44 - inside this package so let me create the
214:46 - player.5 module first so here i'll say
214:49 - player.pie
214:51 - and inside this file let me add a
214:54 - function so i'll say def
214:56 - get player
214:59 - info and inside this function let me
215:02 - just say print
215:04 - i am the main
215:06 - player
215:10 - so let me save this file
215:12 - and then i'll create another module
215:14 - called boss.pi
215:16 - so i'll say boss.pi
215:19 - and inside this boss.file let me just
215:21 - add one function i'll say def
215:24 - get boss info
215:27 - and inside this function i'll just write
215:29 - print
215:31 - i am
215:32 - the
215:34 - enemy
215:35 - player
215:37 - and save this file here i have just used
215:40 - a simple function to illustrate python
215:41 - packages however while actually
215:44 - developing such large programs these
215:46 - modules might contain classes and
215:48 - multiple functions now let's try to
215:50 - import each of these components by using
215:52 - the import statement i'll create a new
215:54 - file outside the game package and i'll
215:57 - call it main dot pi
215:59 - so here i'll say main dot pi
216:01 - then i will say import
216:04 - game
216:05 - and use the dot notation to access the
216:07 - player module inside the characters
216:08 - package so i'll say import dot
216:11 - characters
216:12 - dot player
216:14 - now i can use all definitions inside the
216:16 - player module let's use the get player
216:18 - info function of the player module so
216:20 - i'll say game dot
216:23 - characters dot player dot get player
216:27 - info
216:28 - let me wrap this up so that you can see
216:30 - it
216:31 - okay i said info
216:33 - so i'll save this file
216:35 - and here on the terminal i'll say python
216:40 - main dot pi
216:41 - and as you can see the function was
216:43 - correctly called and i am the main
216:45 - player is printed
216:48 - we can also use the from import
216:50 - statement to import only certain modules
216:52 - from the package let me show you how to
216:54 - do this i'll first remove this old code
216:57 - and here i'll say from
216:59 - game dot characters
217:01 - import player
217:04 - here we have only imported the player
217:06 - module of the characters sub package so
217:08 - we can access the get player info
217:10 - function without using the game package
217:12 - so i'll only type player dot get player
217:16 - info
217:18 - i'll save this file
217:19 - run main dot pi again and you can see
217:22 - that i got the same result as before
217:24 - while writing lesser code
217:27 - we can also import only certain
217:29 - definitions from inside these modules as
217:31 - well i will now import only the get boss
217:33 - info of the boss module so here i'll say
217:37 - from
217:38 - game dot characters dot boss
217:41 - import
217:42 - get boss info
217:45 - now i can call the get boss info
217:47 - directly
217:50 - and if i save this file and run the code
217:53 - then you can see i am the enemy player
217:55 - was also printed both functions work as
217:58 - expected a tip for you when you use
218:00 - packages always try to give descriptive
218:03 - names to functions and classes so that
218:05 - you don't get confused
218:08 - now we have created this init files
218:10 - without doing anything inside them
218:13 - the code inside this file runs
218:14 - automatically when we import the package
218:18 - let me add a line here inside the init
218:20 - file of the game package here i'll say
218:23 - print
218:24 - initializing the game
218:28 - now let me go back to my main dot pi
218:31 - file
218:32 - and if i run the code again so here i'll
218:35 - say python
218:36 - main dot pi
218:39 - and when i press enter you can see that
218:42 - initializing the game was also printed
218:44 - to the screen
218:46 - that means the code within the init file
218:48 - was executed when the package was
218:51 - imported and that is why initializing
218:53 - the game was printed here
218:58 - in our previous example we looked at how
219:00 - to create a python package
219:02 - there are thousands of such useful
219:04 - packages tailored for specific tasks
219:07 - that are developed and maintained by the
219:08 - active python community
219:10 - when you start working on more advanced
219:12 - projects you will have to use these
219:14 - packages at some point rather than
219:16 - building everything from scratch
219:18 - for example if you're working with web
219:20 - development you will probably use
219:22 - packages like django or flask
219:24 - to use these packages we first need to
219:26 - install them this is where pip comes in
219:30 - pip is the standard package manager for
219:32 - python that helps to install and manage
219:34 - additional packages that are not
219:36 - available in the python standard library
219:39 - let's use pip to install a package
219:40 - called pandas it is a popular package
219:42 - for data analysis in python to install
219:44 - this package i'll say pip
219:47 - install
219:48 - pandas and when i press enter
219:53 - as you can see it's downloading the
219:54 - pandas package depending upon the size
219:57 - of the package it may take a while
219:59 - one cool thing about pip is that it also
220:01 - automatically installs all required
220:03 - dependencies to run pandas like numpy
220:06 - which is another popular package for
220:07 - scientific computing
220:10 - now that the process is complete i will
220:12 - open a new file
220:15 - and inside it i'll write
220:18 - from
220:19 - import
220:20 - pandas
220:21 - as pde
220:23 - now i just want to check if the pandas
220:25 - module is working so here i'll just say
220:27 - print pd and save this file
220:30 - now here i'll say python main dot pi
220:37 - as you can see pandas is correctly
220:39 - installed and we can start using it in
220:41 - our code
220:43 - sometimes you may have to install a
220:44 - specific version of a certain package in
220:47 - that case you can specify the package
220:49 - version using the double equal syntax
220:52 - let me show you i'll go to my terminal
220:54 - and i'll type pip
220:55 - install
220:57 - requests
220:58 - equals equals 2.21.0
221:02 - and as you can see it is collecting and
221:05 - installing the specific version of
221:06 - request that i requested for
221:12 - if you want to list all the installed
221:13 - packages you can use the pip list
221:15 - command so in my terminal and clear this
221:18 - out and i'll say pip list
221:21 - as you can see it printed out all the
221:23 - packages that i have installed on my
221:25 - computer
221:27 - as you can see pip is a very useful tool
221:29 - that makes managing external packages a
221:31 - whole lot easier if you want to learn
221:34 - more about pip you can check out our
221:36 - article on it the link will be in the
221:37 - description below
221:40 - i'm sure you have run into errors
221:42 - numerous times while programming
221:43 - basically these errors are of two types
221:46 - one is syntax errors like missing
221:48 - parentheses wrong indentation etc you
221:51 - can easily fix these errors by fixing
221:53 - the syntax and the other type of error
221:55 - is exception
221:56 - even if your code is syntactically
221:58 - correct it may sometimes result in an
222:00 - error for example if you divide a number
222:02 - by zero you will get an error these
222:05 - types of errors that we encounter during
222:07 - the runtime of the program are called
222:09 - exceptions in this video we will learn
222:11 - about exceptions in detail and then we
222:13 - will see how we can handle them in
222:15 - python
222:18 - let's understand about exceptions first
222:20 - for this i will write a program that
222:21 - will give us an error so in my code
222:23 - editor i'll say numerator
222:26 - equals 10
222:28 - denominator
222:30 - equals 0
222:31 - now i'll say print
222:34 - numerator divided by
222:36 - denominator
222:38 - and i'll save this file let me run it
222:40 - i'll say python main dot pi
222:43 - and you can see
222:45 - that when i run the code we can see the
222:47 - zero division error has been raised
222:51 - even though our code was correct syntax
222:53 - wise it's not allowed to divide a number
222:55 - by zero in python this is an exception
222:58 - in this case we are getting the zero
223:00 - division error exception
223:02 - depending upon the error these
223:04 - exceptions can be of different types for
223:06 - example if you try to access a file that
223:08 - doesn't exist we will get the file not
223:11 - found error exception similarly if we
223:13 - try to access the item of a list out of
223:15 - range we will get the index error
223:17 - exception
223:19 - as we know when our program encounters
223:21 - an exception our code ends abruptly with
223:23 - an error message and most of the time
223:25 - rather than showing the default message
223:27 - we may want to show a custom message
223:30 - that's more helpful or run a different
223:32 - set of code this is known as exception
223:34 - handling is the process of responding to
223:36 - exceptions in a custom way during the
223:38 - execution of a program
223:40 - in python we use the try except block to
223:43 - handle exceptions and its syntax goes
223:45 - like this inside the try block we write
223:48 - the code that might throw an exception
223:50 - now if an exception occurs the control
223:52 - of the program jumps immediately to the
223:54 - accept blocks and the program continues
223:57 - and if exceptions don't occur the except
223:59 - block is completely skipped pretty
224:01 - simple right now let's see a working
224:03 - example of it so inside the try block i
224:06 - will write some code that might raise an
224:08 - exception let me remove this and here
224:10 - i'll say numerator
224:12 - equals
224:14 - integer input
224:16 - enter
224:17 - numerator
224:20 - then i'll say
224:21 - denominator
224:24 - equals
224:25 - integer input
224:27 - enter
224:28 - denominator
224:31 - next i'll say result equals
224:34 - numerator divided by
224:37 - denominator
224:38 - and let me print the result
224:42 - here we are taking numerator and
224:44 - denominator from the user
224:46 - dividing the numerator and the by the
224:48 - denominator and then printing the result
224:52 - this code may raise an exception if the
224:54 - user enters 0 as a denominator let's
224:56 - print a simple message inside the accept
224:58 - block if an exception occurs so i'll
225:00 - remove this code and here i'll say print
225:04 - denominator
225:06 - cannot be zero
225:08 - please try again
225:11 - let me also put another print statement
225:13 - outside the try except blocks here i'll
225:15 - say print
225:16 - program ends
225:19 - let me save this and when i run this so
225:21 - i'll go to my terminal and say python
225:24 - main dot pi
225:25 - in the numerator i'll enter 10 in the
225:27 - denominator i'll enter 0
225:29 - and as you can see denominator cannot be
225:32 - 0 please try again is printed
225:36 - this is because this line result equals
225:38 - numerator divided by denominator raises
225:41 - an exception when denominator is zero in
225:43 - this case the control of the program
225:46 - jumps to the except block
225:48 - and the code inside it is executed
225:51 - let me run this program again so here
225:53 - i'll say python main.pi and this time
225:56 - let me enter the numerator as 4 and
225:58 - denominator as 2.
226:00 - when i press enter as you can see the
226:02 - correct answer which is 4 divided by 2
226:05 - is printed and the accept block is not
226:07 - executed this time
226:10 - i have this code from our earlier
226:12 - example on my screen here it doesn't
226:14 - matter what type of exception it is this
226:16 - except block is executed whenever an
226:18 - exception is thrown it's also possible
226:20 - to handle different types of exceptions
226:22 - in different ways for example we may
226:24 - want to print different error messages
226:26 - for zero division error and index error
226:28 - exceptions we can do that by specifying
226:31 - the type of exception after the accept
226:33 - keyword so here after accept i will add
226:37 - zero division
226:39 - error
226:40 - now this accept block is only handling
226:43 - the zero division error let me run this
226:46 - code so here i'll clear this
226:49 - and
226:50 - let's say python main dot pi
226:54 - enter numerator 10 and enter denominator
226:56 - again i'll enter 0 because i want to
226:58 - throw the exception
227:00 - and as you can see the code inside the
227:02 - except block was executed
227:06 - handling specific exceptions in this way
227:08 - is particularly useful if our try block
227:10 - may raise more than one type of
227:11 - exception suppose our try block can
227:14 - raise the zero division error and the
227:15 - index error as well we want to handle
227:18 - these two exceptions separately we can
227:20 - do that by adding another except block
227:22 - to handle the index error exception
227:24 - separately let me show you what i mean
227:26 - by this i will add code inside the try
227:28 - block that may raise the index error
227:30 - exception so in my code after the print
227:33 - result
227:34 - here i'll say my underscore list equals
227:38 - 1 comma 2 comma 3
227:40 - and i'll accept input
227:42 - or the index from the user so here i'll
227:44 - say i equals
227:46 - integer input enter
227:48 - index
227:51 - and then i'll print
227:53 - my underscore list
227:55 - i
227:58 - this code will raise the index exception
228:00 - if the user enters an index greater than
228:02 - two because our list only has three
228:04 - items now to handle the exception i will
228:07 - type another except block so here i'll
228:10 - say
228:10 - accept
228:12 - index
228:13 - error
228:15 - and inside this i'll say print
228:17 - index
228:18 - cannot be
228:20 - greater than size of list
228:24 - let me add the full stop
228:26 - now when i run this code
228:28 - i'll say python main dot pi
228:33 - oops there's an error so the error seems
228:35 - to be
228:36 - print result
228:38 - no print oh i forgot a bracket here okay
228:41 - i'll save this
228:43 - and let me say python main dot pi
228:46 - it says enter numerator so let me enter
228:48 - something like 10
228:50 - in the denominator i'll enter five now
228:52 - when it says enter index let me enter
228:54 - something like 5
228:56 - when i press enter then you can see that
228:59 - index cannot be greater than size of
229:00 - list which is the custom message i had
229:02 - put in for the index error is printed
229:09 - a try statement can also have an
229:11 - optional finally block which is executed
229:13 - regardless of whether an exception
229:14 - occurs or not and its syntax goes like
229:17 - this
229:18 - let me run this code first so here i'll
229:21 - say python mean dot pi now let's
229:24 - understand what's going on in this
229:25 - program
229:26 - this block of code gives us the zero
229:29 - division error so the accept block
229:32 - wrong denominator is printed to the
229:33 - screen finally the code inside the
229:36 - finally block is also executed
229:39 - however if an exception doesn't occur in
229:41 - the try block this except block is not
229:44 - executed but this finally block is still
229:47 - executed
229:49 - the final block is usually used to
229:51 - perform cleanup actions that need to be
229:53 - executed under all circumstances suppose
229:56 - we are working with an external file in
229:57 - our program we need to close this file
229:59 - at the end even if there was an error
230:01 - while writing to it in this case we put
230:04 - the close file function inside the
230:05 - finally block at this point we have
230:08 - covered pretty much everything we need
230:09 - to know about exception handling by the
230:11 - way we can also create custom exceptions
230:13 - in python if you're interested you can
230:15 - check that article on our website
230:17 - programmies.com the link will be in the
230:19 - video description if you're enjoying
230:20 - this video please also check out program
230:22 - is pro where we provide tutorials along
230:25 - with quizzes and challenges which will
230:27 - help you practice and test your learning
230:28 - in real time also the course includes
230:30 - projects to give you an awesome
230:32 - experience of how programming works in
230:33 - the real world and for our youtube
230:35 - subscribers we are giving 50 off on the
230:37 - yearly plan sign up by scanning this qr
230:39 - code or use the link in the video
230:40 - description to claim your discount
230:45 - we all know about files they are named
230:47 - locations on our storage device for
230:49 - recording data
230:50 - python provides numerous built-in
230:52 - functions to work with these files in
230:54 - this video we will see how we can
230:56 - perform various file operations such as
230:58 - reading and writing into files with the
231:00 - help of examples
231:03 - there are three steps we need to follow
231:04 - to work with files first open a file
231:07 - second perform the operations such as
231:10 - read content from the file or write data
231:12 - to the file third close the file now
231:15 - let's cover each of these topics in
231:16 - detail
231:18 - in python we use the built-in open
231:20 - function to open files here i have a
231:23 - file named message.txt and inside it i
231:26 - have two lines of text ilo programming
231:28 - and i love program is to open this file
231:31 - i will create a new python file in the
231:33 - same directory and call it main dot pi
231:38 - so here i'll type f
231:40 - equals
231:41 - open
231:43 - message.txt
231:46 - here
231:47 - message.txt is the location of the file
231:50 - if this file was in another directory we
231:52 - would also need to specify the path to
231:54 - this file and this open function is
231:57 - opening the file
231:58 - which returns a file object which is
232:00 - stored in the variable f
232:03 - this file object will be used to perform
232:05 - file operations
232:07 - by default the file will be opened in
232:09 - the read mode meaning we can read
232:11 - contents from the file but we can't
232:13 - modify it instead of this we could also
232:16 - have explicitly specified the file to be
232:18 - opened in the read mode by passing a
232:20 - second argument like this so here i'll
232:23 - add a second argument and say r
232:27 - here r means open the file in read mode
232:31 - similarly if you want to write contents
232:33 - to a file we should open the file in
232:35 - write mode by using w like this so i'll
232:37 - remove this r and i'll write w and this
232:40 - means that i'm opening the file in right
232:42 - mode these are called file modes the
232:45 - mode in which the file is opened and
232:47 - there are three commonly used modes in
232:49 - which we can open a file r for reading
232:52 - contents of the file w for writing
232:54 - contents to the file and a for appending
232:57 - more content to the end of the file
232:59 - now we know how to open a file next we
233:02 - will see how we can read the contents of
233:03 - the file
233:06 - after we open a file like this we can
233:08 - read its contents using the built-in
233:10 - read method so in my code editor i'll
233:12 - say content equals
233:15 - f dot read
233:16 - and then i'll print the content
233:20 - first i have opened the file in read
233:22 - mode this statement returns a file
233:24 - object then using the object we read the
233:26 - entire content of the file and printed
233:30 - before we see the output of this code i
233:32 - will add a line to close the file so
233:34 - here i'll say f dot close
233:37 - we should always close the file after
233:38 - working with them it's a good
233:40 - programming practice
233:41 - now let me run this code so let me hide
233:43 - the explorer open the terminal and here
233:46 - i'll say python
233:49 - main dot pi
233:51 - and you can see that the contents of the
233:53 - file message.txt were printed
233:58 - it's also possible to read only a
234:00 - certain number of characters from a file
234:02 - using the same read method for this we
234:05 - pass an optional size argument let me
234:07 - read only the first characters from the
234:09 - file so here i'll say f dot read six let
234:13 - me save this file and when i run it
234:15 - you can see that only the first six
234:17 - characters of the file were printed
234:21 - now if you read the same file again it
234:23 - starts reading from the seventh
234:24 - character because we have already read
234:26 - up to the sixth character let me show
234:28 - you how that works let me modify this
234:30 - program to read the next characters so
234:33 - here i'll say more underscore content
234:36 - equals f dot read
234:38 - 12
234:39 - and i'll print more content
234:42 - let me save this and when i run python
234:45 - main dot pi again you can see that
234:48 - programming was also printed
234:51 - so let's try to see what happened here
234:53 - the first read statement or the f dot
234:55 - read six is giving us the first six
234:58 - characters i love
235:01 - and the second read
235:02 - which is more content equals f.12
235:06 - is giving us the next 12 characters and
235:08 - which is programming
235:13 - we might encounter unexpected errors
235:15 - while working with external files so
235:17 - it's a good practice to open the files
235:19 - using try final statement let me show
235:21 - you how so in my code editor i'll make a
235:24 - few changes here i'll put this inside a
235:26 - try block
235:29 - all of this will go inside the try block
235:32 - and i will put the f dot close inside a
235:36 - finally block
235:38 - here we are adding try and finally
235:40 - blocks because now even if our program
235:42 - encounters an error our file will be
235:44 - closed
235:45 - this is because the finally block always
235:48 - gets executed
235:49 - there's even a better way to write this
235:51 - same code in python using the with open
235:53 - syntax let me show you how
235:56 - so here i'll remove the try block and
235:58 - i'll say with
236:00 - open
236:01 - as f
236:02 - i'll remove this finally code
236:06 - now when i run this code
236:08 - i'll say python main.pi
236:11 - which should have been with
236:13 - i'll save this
236:15 - and i'll just run python main.pi this
236:18 - again seems to be an error i forgot the
236:20 - colon at the end
236:21 - again let me try this once python main
236:25 - dot pi and as you can see i got the same
236:27 - output but using the width syntax
236:30 - automatically closes the file without us
236:32 - having to write the finally ourselves
236:37 - to write content to a file we must first
236:39 - open it in write mode then we can start
236:41 - writing content to it using the right
236:43 - method there are two things you need to
236:45 - remember while writing to a file if you
236:47 - try to open a file that doesn't exist a
236:50 - new file is automatically created
236:52 - if a file already exists its contents
236:54 - are removed and our new content is added
236:56 - to it first let me write to a file that
236:59 - doesn't exist so here in my code editor
237:02 - i'll say with
237:03 - open
237:05 - python
237:07 - dot txt
237:10 - and in write mode
237:13 - as f
237:15 - i'll say f dot write
237:18 - python is awesome
237:21 - and in the next line i'll write f dot
237:23 - write
237:24 - i love python
237:27 - i'll save this and let me run it
237:30 - when i run the code a python.txt file is
237:34 - created with the content python is
237:36 - awesome i love python
237:38 - here both the strings are in the same
237:40 - line we can change that by adding slash
237:43 - n to specify a new line character so
237:45 - here i'll go back to my main dot pi and
237:47 - i'll say python is awesome slash n
237:51 - now let me open up my terminal and run
237:53 - the code again so i'll say python
237:56 - main dot pi
237:57 - and if i go to
237:59 - if i open the
238:02 - now if i open the python.txt file you
238:04 - can see that python is awesome and i
238:06 - love python are on separate lines
238:09 - notice that while running the program
238:10 - for the second time the python.txt file
238:13 - was already there since opening an
238:15 - existing file in write mode will
238:16 - overwrite the file all the previous data
238:19 - was erased and new content was written
238:21 - to it so you have to be very careful
238:23 - while using the right mode because you
238:25 - may accidentally erase the old data
238:26 - without realizing it
238:29 - the final file mode that we will discuss
238:31 - in this video is append as suggested by
238:34 - the name we use this only if you want to
238:36 - add additional data to the end of the
238:38 - file without erasing our previous data
238:40 - at the moment our python.txt file looks
238:43 - like this
238:44 - let me add an additional line to this
238:46 - file and in main dot file i'll open this
238:49 - in append mode and here i'll write f dot
238:52 - write
238:54 - i'll write
238:56 - python
238:59 - is my
239:00 - favorite
239:01 - programming
239:03 - language
239:06 - here i have used a to specify that i
239:10 - want to append to the python.txt file
239:14 - then i have used the same write method
239:16 - to write new lines to the existing file
239:19 - let me run this code so let me hide this
239:21 - here open up my terminal and here i'll
239:24 - say
239:24 - python main dot pi and after running it
239:28 - if i open my python dot txt
239:31 - then
239:32 - you can see that python is my favorite
239:34 - programming language has been appended
239:36 - to the end of the file
239:40 - the read lines method returns a list
239:42 - containing each line of the file
239:44 - let's open the same python.txt file we
239:46 - have been working with on read mode but
239:48 - this time i will use the redlines method
239:51 - i'll remove this old code first let me
239:53 - change the mode to read
239:55 - and then i'll remove this old code i'll
239:57 - say lines equals
240:00 - f dot read lines
240:02 - and let me print lines to see what i get
240:06 - now i'll save this
240:07 - let me run the code so i'll say python
240:09 - main.pi
240:11 - and you can see that i get a list of the
240:14 - lines that are inside the python.txt
240:16 - file
240:18 - now if i want i can use a for loop to
240:21 - iterate through the list to get each
240:22 - line one by one
240:24 - similarly there is also a write lines
240:26 - method to write multiple items into a
240:28 - file it writes the items of a list to
240:30 - the file so i'll go to my code editor
240:33 - i'll remove this old code and instead of
240:35 - python.txt i'll say
240:37 - javascript.txt let me open this in write
240:40 - mode so inside this block i'll say lines
240:43 - equals
240:45 - js is also
240:48 - awesome
240:49 - and in the second item i'll say slash n
240:52 - js
240:53 - is my second
240:55 - favorite
240:57 - programming
240:58 - language
241:00 - now i'll say f dot write lines lines
241:05 - i hope you must have guessed the output
241:07 - by now but let me show you anyways so
241:09 - i'll do python
241:11 - main dot pi and when i press enter
241:14 - then if i let me close my terminal i'll
241:16 - go back to my explorer and you can see
241:19 - that a file called javascript.txt with
241:21 - the two lines js is also awesome and js
241:24 - is my second favorite programming
241:26 - language has been created
241:29 - at this point we have covered pretty
241:30 - much everything we need to know about
241:32 - file handling in python by the way there
241:34 - are many other built-in methods and file
241:36 - modes available to file objects if
241:38 - you're interested you can find more
241:39 - information about it on our website
241:41 - programmings.com the link will be in the
241:43 - video description
241:46 - a folder or directory is a location on a
241:48 - computer to store and organize multiple
241:50 - files and sub directories python has a
241:53 - module named os that makes it really
241:55 - easy to work with directories and file
241:57 - management tasks in this video we will
241:59 - learn to use the os module to perform
242:01 - various directory operations like
242:02 - creating renaming and removing
242:05 - directories with the help of examples
242:07 - let's see how we can get the path to the
242:09 - current directory first for that we use
242:11 - the getcwd function of the os module it
242:14 - returns the current working directory as
242:16 - a string i'll go to my text editor first
242:18 - i need to import the os module so i'll
242:20 - say import
242:22 - os
242:23 - then i can say current underscore dir or
242:26 - current directory equals os dot get cwd
242:31 - and now let me print this variable print
242:34 - current underscore dir i'll save this
242:36 - file
242:37 - run the code say python main dot pi and
242:40 - when i press enter then you can see that
242:43 - it printed the location of the main dot
242:45 - pi file or the current directory
242:50 - in python we can change the current
242:52 - working directory by using the chdir
242:54 - method of the os module
242:56 - as we saw in our previous section the
242:58 - present working directory is the
242:59 - directory containing our python file by
243:01 - default let's change the current working
243:03 - directory i'll start with the old code
243:06 - and i'll say os
243:07 - dot
243:09 - d i r
243:10 - and inside these quotation marks let me
243:14 - put this location
243:16 - and then instead of os i'll say
243:19 - exceptions which is the location of the
243:21 - file from the previous video so here i'm
243:25 - trying to change the default location
243:28 - and then let me print
243:30 - os dot get cwd again to confirm that the
243:33 - current working directory has been
243:34 - changed so let me run python
243:38 - main.pi
243:39 - as you can see os.getcwd
243:42 - first gave me the os folder where
243:44 - main.pi was located
243:46 - when i change the default directory by
243:48 - using os.csdir
243:50 - then when i call os dot get cwd again
243:53 - this time i get the new directory which
243:56 - i had set as the default directory here
243:59 - now if i create a file inside the
244:00 - current directory our file will be
244:03 - created inside
244:04 - this exceptions folder and not this os
244:07 - folder
244:08 - let me show this in action so here i'll
244:11 - write to a new file i'll say with
244:13 - open
244:14 - test
244:15 - dot txt
244:17 - i'll do that in write mode
244:19 - and i will call the file point f
244:21 - then i will say f dot write
244:24 - this is a test file
244:29 - now when i press run
244:31 - python main dot pi a new file has been
244:35 - created and this file if i check here
244:38 - then you can't see that file in the os
244:40 - directory instead if i go to the
244:43 - exceptions directory you can see that
244:45 - test.txt file has been created and
244:47 - inside it you can see that this is a
244:50 - test file is there that means python is
244:53 - considering the exceptions directory to
244:55 - be the current directory for
244:57 - opening file test.txt in write mode
245:03 - in python all files and subdirectories
245:05 - inside a directory can be retrieved
245:07 - using the list dir function of the os
245:08 - module
245:10 - and i'll say print
245:12 - os dot
245:14 - list
245:14 - dir and let me run this so i say python
245:18 - main dot pi
245:19 - and you can see a list of all the files
245:22 - and folders inside this python videos
245:25 - directory can be seen here
245:27 - i can also pass an optional path
245:29 - argument to hdir to return files and
245:32 - subdirectories from a specific path so
245:34 - here i can say
245:36 - exceptions
245:38 - and if i run this program again then you
245:41 - can see the files that are inside the
245:42 - exceptions directory
245:46 - we can create a new directory using the
245:48 - mkdir function of the os module in my
245:50 - code editor i'll say
245:52 - os dot mkdir
245:55 - test
245:57 - and i can run this code so i'll say
245:59 - python
246:00 - main dot pi
246:03 - and if i go into the folder i can see
246:05 - that there's a new folder called test
246:08 - if i wanted this text directory to be
246:10 - created in a specific path i can use the
246:12 - full path location like this
246:14 - so here i'll say mkdir
246:18 - exceptions slash test
246:21 - and now let me run this so python main
246:23 - dot pi
246:24 - and if i go inside the exceptions folder
246:27 - then you can see that there's a test
246:29 - folder inside the exceptions folder
246:34 - we can rename any directory or file
246:36 - using the rename function of the os
246:38 - module let me show you how
246:41 - os dot rename
246:43 - and inside this
246:44 - let me pick any file
246:46 - so our folder i'll call idle name test
246:49 - so here i'll say test
246:51 - and i can say test new
246:54 - and now if i run this co if i run this
246:56 - code so i'll say python mean dot pi
246:59 - then if i go back to my folder structure
247:02 - you can see that test has been renamed
247:04 - to test new
247:05 - as you just saw the rename method takes
247:08 - two arguments the current name of the
247:10 - folder or file and the new name of the
247:13 - folder or file
247:15 - the rename function can also be used to
247:17 - rename a file with the same exact syntax
247:20 - i encourage you to change the name of a
247:21 - file on your own and let me know if it
247:23 - worked in the comments section
247:27 - we can remove a file using the remove
247:29 - function of the os module so i'll go to
247:31 - my folder list and i can see that
247:34 - there's an exceptions 4k dot mov file
247:37 - here i'll remove it using python
247:40 - so on my code editor i'll say
247:42 - print first let me start by listing
247:45 - all the files and directories in this
247:47 - folder
247:48 - and here i'll say python main dot pi
247:52 - as you can see there is a file called
247:55 - python module let's remove this one so i
247:58 - want to remove python modules.mov
248:00 - next i'll say os dot remove
248:05 - python
248:06 - modules
248:09 - dot mov
248:11 - and then let me again print os dot list
248:14 - dir just to make sure that python
248:16 - modules has indeed been removed so now
248:18 - i'll say python main dot pi
248:22 - and as you can see python modules is not
248:25 - here python modules dot mov
248:28 - is not here anymore
248:31 - to remove a directory we use the rmdir
248:34 - function one thing we need to remember
248:36 - when removing a directory is that the
248:37 - directory must be empty otherwise an
248:39 - exception will be raised
248:41 - now we currently already have an empty
248:44 - directory called test new in our current
248:45 - directory which we have created before
248:47 - to remove this directory i will change
248:49 - my previous code and here i'll say os
248:52 - dot rmdir
248:55 - and here i'll say test new
248:58 - now let me run this first let me clear
249:00 - the screen here i'll say python main dot
249:03 - pi
249:04 - and now you can see that test new is
249:07 - here before but it's not in the new list
249:10 - or i can also verify this visually so
249:12 - you can see that test new folder is no
249:14 - longer there that means it has been
249:16 - removed
249:17 - that's it for this video if you want to
249:19 - revise this concept you can find all
249:21 - these programs you know github
249:22 - repository i'll also put this link in
249:24 - the video
249:26 - description iterators are everywhere in
249:29 - python they are elegantly implemented
249:31 - within for loops list and dictionary
249:33 - comprehensions but they are hidden in
249:35 - plain sight in this video we will learn
249:37 - about iterables and iterators in python
249:39 - with the help of examples we will also
249:42 - create our own custom iterator and see
249:44 - how the for loop actually works let's
249:47 - first understand what an iterable is
249:49 - basically anything that you can loop
249:51 - over in python is called an iterable for
249:54 - example a list is an iterable
249:56 - for an object to be considered an
249:57 - iterable it must have the iter or iter
250:00 - method
250:01 - let's check if lists have this special
250:03 - method to check this i will use the dir
250:05 - function which returns all the methods
250:07 - of an object so here on my code editor
250:10 - i'll say print
250:12 - dir
250:14 - numbers now let me run this code
250:17 - and here among all these methods you can
250:20 - see the dunder itr method
250:23 - let's call this method on this numbers
250:25 - list to see what it does so here i'll
250:29 - say
250:30 - value
250:31 - equals
250:33 - numbers dot
250:35 - dunder or double underscore iter double
250:38 - underscore
250:40 - and let me print the value
250:43 - when i press run
250:46 - then you can see that we got a list
250:48 - iterator object and this is the memory
250:50 - location of that object
250:52 - next we will see what iterator objects
250:54 - are
250:57 - iterator in python is simply an object
250:59 - that can return data one at a time while
251:01 - iterating over it for an object to be an
251:03 - iterator it must implement two methods
251:06 - eater or iter and next
251:08 - these are collectively called the
251:10 - iterator protocol now we'll look into
251:12 - the next method in detail
251:15 - suppose we have a list like this so i'll
251:17 - say numbers equals
251:19 - 1 comma 4 comma 9
251:22 - now i'll get an iterator from this list
251:24 - using the iter method so here i'll say
251:28 - value equals
251:30 - numbers dot
251:32 - dunder or double underscore under iter
251:37 - and next
251:38 - here this variable value is an iterator
251:41 - and we can get each element of this
251:43 - iterator by using the next method
251:46 - the next method returns the next value
251:48 - in the iteration
251:50 - so here i can say item one equals value
251:53 - dot double underscore or dunder
251:56 - next
251:57 - and then i can print item one when i run
252:00 - this code then one which is the first
252:03 - element of this list is printed
252:06 - now if i run the next method again it
252:08 - should return the next item which is
252:10 - four it's because the next method also
252:12 - updates the state of the iterator and
252:14 - here i'll say
252:16 - item 2
252:18 - equals value dot
252:20 - done.next
252:22 - print
252:23 - item 2 and then item 3 equals value.next
252:29 - and then i'll say print item three
252:32 - now let me run this code
252:35 - as you can see first one was printed
252:38 - then four then nine
252:40 - by the way instead of calling these
252:41 - special methods with an underscore
252:43 - python has an elegant way to call
252:45 - underscore underscore iter simply with
252:47 - the iter function and underscore
252:49 - underscore next underscore underscore
252:51 - with the next function i'll make these
252:53 - changes to my previous code so here
252:55 - instead of calling
252:57 - numbers dot underscore underscore iter i
252:59 - can say iter
253:00 - numbers and instead of calling value dot
253:04 - underscore underscore next underscore
253:05 - underscore i can say next
253:08 - value
253:09 - here to i can say next
253:11 - value
253:12 - and here as well
253:14 - next value when i run this code
253:17 - i get the same output as before but my
253:20 - code looks a lot cleaner than before
253:23 - by the time i get to the third element
253:25 - we have already reached the end of our
253:26 - list now let's see what happens if we
253:29 - further try to get the next value
253:31 - so here i'll say item 4
253:34 - equals next value
253:36 - and let me try to print item 4.
253:40 - now when i run the code
253:42 - then you can see that the stop iteration
253:44 - exception has been raised
253:48 - since our list had only three elements
253:50 - the call to the fourth next method
253:52 - raised the stop iteration exception
253:56 - did you know that for loops internally
253:58 - use the while loop to iterate through
253:59 - sequences to demonstrate this let me
254:02 - first loop through a list using the
254:04 - while loop so i'll go to my code editor
254:06 - and create a new list i'll say num
254:08 - underscore list equals 1 comma 4
254:13 - comma 9
254:14 - and now let me create an iterator object
254:17 - so here i'll say iter underscore obj or
254:20 - iterator object equals iter
254:23 - num underscore list
254:25 - here the iter object is an iterator we
254:29 - can now use an infinite while loop to
254:31 - get the next element using the next
254:33 - method and in case a stop iteration
254:35 - exception occurs we'll break out of this
254:36 - loop
254:37 - so here i'll say
254:39 - while
254:41 - true
254:43 - and then i can say try
254:45 - try to get the next element so next
254:49 - item underscore obj
254:51 - and then if i get the element print that
254:53 - element
254:55 - now if there is an exception
254:58 - then i can say
254:59 - or if there is more specifically i'll
255:01 - say if there an stop iteration exception
255:06 - then
255:07 - break the code
255:10 - here's how this code works first we have
255:12 - created an iterator object from a list
255:15 - using the iter function
255:17 - then we have created an infinite while
255:19 - loop inside the loop we have used the
255:22 - next method to get the next element in
255:24 - the sequence
255:26 - in the next line we have printed that
255:28 - element
255:29 - we have put all this code inside a try
255:31 - block and
255:33 - when all the items of the iterator are
255:34 - iterated the try block raises the stop
255:37 - iteration exception and we break out of
255:39 - the loop let me run this code
255:42 - and you can see that 1 4 and 9 have been
255:44 - printed in fact this is exactly how for
255:47 - loops work behind the scenes a for loop
255:49 - internally creates an iterator object
255:51 - and iterates over it calling the next
255:53 - method until the stop iteration
255:55 - exception is encountered
255:59 - as we have already seen iterators are
256:01 - simply objects that implement the item
256:03 - method and the next method
256:05 - let's try to make our own iterator
256:06 - object here we'll create a program that
256:09 - will generate a sequence of even numbers
256:11 - such as 2 4 6 8 and so on for this i'll
256:15 - create a class with the init method
256:17 - so let me remove this old code and here
256:19 - i'll say class
256:21 - even and inside this let me start by
256:23 - creating the init method so i'll say def
256:26 - underscore underscore init underscore
256:27 - underscore
256:28 - self
256:29 - and max
256:32 - and then let me initialize self dot n
256:34 - equals 2 so that's the first value which
256:36 - is always 2 and self.max is the value
256:40 - that we provide by now we already know
256:43 - that iterators must implement an item
256:45 - method which returns an iterator so i'll
256:47 - simply create an item method that
256:48 - returns the object itself
256:50 - so here i'll say
256:52 - def underscore underscore iter
256:54 - underscore underscore
256:56 - self
256:57 - and here i'll say return self
257:00 - now let's implement the next method this
257:02 - method should give the next element in
257:04 - the stream if it exists if the next
257:06 - element is not available it should raise
257:08 - the stop iteration exception
257:10 - so here i'll say def underscore
257:13 - underscore next underscore underscore
257:16 - oops i forgot a bracket here
257:19 - self
257:20 - and here inside this method we want to
257:23 - generate a sequence up to the max number
257:26 - and if the next element exceeds max we
257:29 - will raise an exception so let me first
257:31 - start with the framework of the code
257:33 - here
257:34 - if
257:35 - self.n
257:36 - as long as it is
257:38 - less than self.max
257:40 - then we need to do one thing and
257:42 - else
257:44 - we need to raise
257:47 - the stop iteration exception
257:50 - now inside this if i need to generate
257:53 - the next number in the sequence
257:56 - so here i'll say result
257:58 - equals
258:00 - self dot n i am temporarily saving the
258:02 - current value of n in the result
258:05 - variable
258:06 - now i want to increase
258:08 - the value of n by 2 so here i'll say
258:11 - self dot n plus equals 2
258:14 - and then return result
258:16 - because i want to return the old value
258:18 - of n not the new one
258:21 - now our class is finally complete let's
258:24 - create an object from this class which
258:25 - is an iterator because it implements
258:28 - both the iter and the next methods
258:31 - so here outside the class i'll say
258:35 - numbers equals
258:37 - even
258:38 - 10.
258:39 - now when i call the next method i should
258:41 - get even numbers one after another
258:44 - let me print three even numbers i'll say
258:46 - print next
258:48 - numbers
258:50 - print
258:52 - next
258:53 - numbers
258:54 - and print
258:56 - next
258:57 - numbers again
258:59 - now when i press run
259:01 - then you can see that 2 4 and 6 are
259:04 - printed
259:06 - if we use the next method three more
259:08 - times the stop iteration exception is
259:10 - raised as of sequence can only have
259:12 - numbers up to 10
259:13 - because of this limit here
259:17 - at this point we have covered all the
259:19 - basics of iterators in python but you
259:21 - might be wondering why it is used
259:23 - iterators are powerful tools when
259:25 - dealing with a large stream of data if
259:27 - you use regular list to store these
259:29 - values our computer would run out of
259:31 - memory quickly with iterators however we
259:34 - can save resources as they return only
259:36 - one element at a time so in theory we
259:38 - can deal with infinite data in finite
259:40 - memory
259:41 - generally iterators are implemented in
259:43 - python using something called generators
259:46 - that make it much easier to use them we
259:48 - will cover python generators in detail
259:50 - in our next video that's it for this
259:52 - video if you want to revise these
259:54 - concepts you can find all these programs
259:56 - in our github repository i'll also put
259:58 - this link in the video description
260:02 - a generator is an elegant way to create
260:04 - custom iterators in python that make it
260:06 - really easy to work with iterators if
260:08 - you haven't watched our video about
260:10 - iterators yet i suggest you watch that
260:12 - video first before you proceed before we
260:14 - learn about generators let's see an
260:16 - example of an iterator implemented in
260:18 - python let me run this code
260:21 - and you can see that a sequence of
260:23 - numbers 2 4 and 6 is generated
260:26 - to generate this we have created a
260:28 - custom iterator inside the even class
260:32 - for an object to be an iterator it
260:33 - should implement the item method which
260:36 - will return the iterator object the next
260:38 - method which will return the next value
260:41 - in the stream and possibly raise the
260:42 - stop iteration
260:44 - exception when there are no values to be
260:46 - returned
260:47 - as you can see the process of creating
260:49 - iterators is both lengthy and
260:50 - counter-intuitive generators come to the
260:53 - rescue in such situations python
260:55 - generators are a simple way of
260:56 - implementing iterators all the work we
260:58 - mentioned above are automatically
261:00 - handled by generators
261:03 - now let's see how we can use generators
261:05 - to create iterators i have this quote
261:07 - from the last section that creates a
261:09 - sequence of even numbers
261:12 - let me first remove this even class
261:15 - now let's implement this same iterator
261:17 - using a generator a generator is simply
261:19 - a function but with slight modifications
261:22 - in a generator function we use the yield
261:25 - keyword to get the next item of the
261:26 - iterator let's see how first i'll create
261:29 - a generator function named even
261:31 - underscore generator and also change
261:34 - this to even underscore generator so let
261:36 - me remove this and i'll call it e1
261:38 - underscore generator now let me define
261:41 - the even on the generator function i'll
261:43 - say def
261:44 - even underscore generator
261:48 - inside this for now i'll just say pass
261:57 - now inside of this function i will use
261:59 - the yield keyword instead of the return
262:01 - keyword to yield the next value without
262:03 - terminating the function so here i'll
262:06 - start with n equals 0
262:09 - and then
262:10 - n i'll increase the value of n by 2 and
262:13 - yield n and then i'll again increase the
262:15 - value of n by 2 and yield n
262:18 - and again let me increase the value of n
262:20 - by 2
262:22 - and yield n
262:23 - and let me remove this pass
262:27 - let's see from the very beginning what
262:28 - this code is doing
262:30 - first i've created a generator function
262:33 - that has three yield statements
262:38 - there should be an n here
262:40 - when we call this function it returns a
262:43 - generator which is an iterator object
262:46 - then we have called the next method
262:48 - to retrieve elements from this object
262:52 - this code gives us the value of the
262:54 - first yield which is 2 in this case
262:58 - this code will give us the value of the
263:00 - next yield which is n equals 0 plus 2
263:03 - plus 2 which is 4 and this code gives me
263:06 - the value of the third yield which is 6.
263:10 - the difference between return and yield
263:12 - is that the return statement
263:14 - terminates the function completely while
263:16 - the yield statement pauses the function
263:18 - saving all its states for next
263:20 - successive calls so when we call the
263:22 - next function for the second and third
263:24 - time
263:26 - it gave us the values of 4 which is the
263:29 - second yield and 6 which is the third
263:31 - yield
263:32 - let me run this code so that you can see
263:34 - it for yourself so when i run this code
263:37 - you can see that the same old numbers of
263:39 - 2 4 and 6 were generated that means our
263:42 - generator is working correctly however
263:44 - as of yet it only returns the first
263:46 - three even numbers i will now implement
263:49 - a loop to make this generator return
263:50 - even numbers till a certain max number
263:53 - and here i'll pass in a parameter called
263:55 - max
263:56 - now let me remove this old code now i'll
263:58 - say n
264:00 - equals 2
264:01 - and then i'll start a while loop so i'll
264:03 - say while
264:04 - n
264:06 - less than equals max
264:09 - yield
264:11 - n
264:11 - and then increase the value of n
264:14 - by 2.
264:16 - now i'll say numbers equals even
264:19 - underscore generator 4 when i press run
264:22 - then you can see that 2 and 4 are
264:24 - generated and after that a stop
264:26 - iteration exception is raised
264:40 - let's compare this generator code with
264:42 - our custom iterator code
264:44 - notice how we have never explicitly
264:45 - defined the item method next method or
264:48 - raised a stop addition exception they
264:50 - are handled implicitly by generators
264:52 - making our program and our life much
264:54 - simpler and easier to understand
264:58 - iterators and generators are generally
265:00 - used to handle a large stream of data
265:03 - theoretically even an infinite stream of
265:04 - data these large streams of data cannot
265:07 - be stored in memory at once to handle
265:09 - this we can use generators to handle
265:11 - only one item at a time
265:13 - now let's build a generator to produce
265:15 - an infinite stream of fibonacci numbers
265:17 - for those of you who don't know the
265:19 - fibonacci series is a series where the
265:22 - next element is the sum of the last two
265:24 - elements so i'll go to my text editor
265:26 - first i'll create a generator function
265:28 - name generate underscore fibonacci and
265:30 - call it here i'll say def
265:32 - generate underscore
265:34 - fibonacci
265:36 - and then inside this i'll just write
265:38 - pass and let me call the generate
265:41 - underscore
265:42 - fibonacci function it should be
265:45 - fibonacci
265:47 - okay now inside this function i will
265:50 - create the first two elements of the
265:51 - fibonacci series so here i'll say n1
265:55 - equals 0
265:56 - and n2
265:58 - equals 1 let me remove this pass
266:02 - then i'll use an infinite while loop and
266:04 - inside it i will yield the value of n1
266:07 - so here i'll say while
266:09 - true
266:11 - and inside it i will yield
266:14 - n1 and then i'll update the values so
266:17 - that the next term will be the sum of
266:19 - the last two terms so i'll say n1
266:23 - comma n2
266:24 - equals
266:26 - n2 comma
266:27 - n1 plus n2 if you're confused about
266:31 - what's happening here what's happening
266:32 - is the sum of n1 and n2 is being
266:35 - assigned to n2 and n2 is being assigned
266:38 - to n1 all in a single line isn't python
266:42 - sweet
266:43 - now let me print the first few elements
266:45 - in this series
266:46 - here i'll say let me assign this
266:49 - iterator so seq equals this
266:52 - now let me say print
266:54 - next
266:55 - seq
266:57 - and i'll copy this and paste it a few
266:59 - times
267:03 - oops
267:05 - all right
267:06 - when i run this code
267:09 - you can see that the fibonacci numbers
267:11 - has been generated
267:13 - if we had used a for loop and a list to
267:16 - store this infinite series we would have
267:18 - run out of memory however with
267:20 - generators we can keep accessing these
267:22 - terms for as long as we want it is
267:24 - because we are just dealing with one
267:26 - item at a time
267:27 - at this point we have covered the basics
267:29 - of python generators by the way we can
267:31 - also create generators on the fly using
267:34 - generator expressions if you want to
267:36 - learn more about it you can check our
267:37 - article on our website programmers.com
267:39 - the link will be in the video
267:41 - description below now i have a little
267:42 - assignment for you why don't you try and
267:45 - modify the generate fibonacci function
267:47 - to instead generate an infinite stream
267:49 - of odd numbers so you can call it
267:51 - generate underscore odd and then use the
267:54 - next method 10 times to print the first
267:57 - 10 odd numbers
267:58 - that's it for this video if you want to
268:00 - revise these concepts you can find all
268:02 - these programs in our github repository
268:04 - i'll also put this link in the video
268:05 - description
268:08 - as simple as date and time may seem in
268:10 - real life they can be challenging to
268:12 - implement in our code because we have to
268:14 - keep record of things such as different
268:16 - date and time formats different time
268:18 - zones and so on fortunately python
268:20 - provides a built-in date time module to
268:22 - simplify this task in this video we will
268:25 - use the datetime module to manipulate
268:26 - date and time in python with the help of
268:29 - examples let's first find the current
268:31 - local date so in my code editor i'll say
268:34 - import date time as dt
268:39 - and i can say current underscore date
268:42 - equals
268:43 - dt dot date dot today
268:46 - and let me print it so i'll say print
268:49 - current underscore date
268:53 - here i have used the today method of the
268:55 - date class
268:57 - of the datetime module which i have
268:59 - imported as dt to get the current local
269:02 - date
269:03 - let me open up my terminal and here i'll
269:05 - say python
269:08 - main dot pi
269:09 - and as you can see i get 27 january 2021
269:13 - which is today's date in nepal
269:16 - similar to the date class the daytime
269:18 - module has many other useful classes to
269:20 - work with date and time some of the
269:22 - popular classes defined inside the date
269:24 - time module are the date class to work
269:26 - with date the time class to work with
269:29 - time and the date time class that is a
269:31 - combination of date and time classes now
269:34 - let's cover each of these classes in
269:35 - detail
269:38 - the date class of the date time module
269:40 - is used to create date objects that can
269:42 - store year month and day let me create a
269:44 - date object so i'll go to my code editor
269:47 - and here i'll say import
269:49 - datetime as dt and in the next line i
269:52 - can say date1 equals
269:54 - dt.date
269:56 - now the first parameter is the year so
269:58 - i'll say 20 21
270:00 - and the second parameter is the month
270:02 - between 1 and 12 so let me say january
270:05 - similarly the third parameter is the day
270:08 - of the month so let me give an arbitrary
270:10 - number like 5
270:13 - because this needs to be between one and
270:14 - thirty one so let me close this and let
270:17 - me print what i get so print date one
270:21 - so i'll save this code open up my
270:22 - terminal and say python main dot pi
270:26 - as you can see i got the date back as
270:29 - expected
270:30 - instead of creating date like this we
270:32 - can also get today's date as we have
270:34 - previously discussed let me get the
270:36 - current date again i'll remove this
270:37 - whole code and i'll say dt dot date dot
270:42 - today
270:42 - and let me print the date 1 again
270:45 - and when i run this code you can see
270:48 - that i get 27 january 2021 which is
270:51 - today's date or the date of this video
270:53 - recording
270:55 - we can also access the year month and
270:57 - day attribute separately let me show you
270:59 - how i'll remove this old code that
271:02 - prints the date and instead i'll say
271:04 - print
271:06 - year
271:07 - and let me print date1.year
271:11 - similarly to print the month i'll say
271:13 - print
271:14 - month
271:16 - and here i'll say date1 dot month
271:19 - and similarly to print the day i'll say
271:21 - print
271:22 - day
271:25 - date1.day
271:27 - now let me save this file
271:29 - run the code
271:31 - and you can see that the year month
271:34 - and day have been printed separately
271:39 - the time class of the daytime module is
271:41 - used to create time objects that can
271:43 - store time of day like hours minutes
271:46 - seconds and microseconds
271:48 - let me create a time object so i'll go
271:50 - to my code editor and i'll remove this
271:52 - whole code i can say time 1 equals
271:55 - dt dot time now the time class takes
271:58 - integer arguments which are 0 by default
272:01 - the first argument is the number of
272:03 - hours between 0 and 24 so here i'll say
272:06 - 10
272:06 - the second argument is minutes from 0 to
272:09 - 60 so here i'll say 45
272:12 - the third argument is seconds from 0 to
272:14 - 60 so let me say something arbitrary
272:17 - like 30 and the fourth argument is
272:19 - microseconds from zero to one million so
272:22 - let me add in a number like four five
272:24 - six six seven i'll close this bracket
272:26 - let me print the time one to see what i
272:28 - get i'll save this file let me go to my
272:31 - terminal i'll say python main dot pi
272:35 - and as you can see i got a time object
272:37 - that stored the same
272:39 - time that i had sent in as arguments to
272:42 - the time class
272:44 - and if you need we can also access each
272:46 - individual attribute like the hour and
272:48 - minute separately let me show you how so
272:51 - here i'll say print
272:54 - hour
272:55 - is
272:57 - time 1 dot hour
272:59 - similarly
273:01 - minute
273:04 - is time one dot minute
273:06 - and
273:08 - second
273:10 - is time one dot second let me save this
273:13 - i'll go to my terminal python main dot
273:15 - pi and as you can see i got the hour
273:18 - minute and second separately
273:21 - let's also do micro seconds so i'll say
273:23 - print
273:24 - micro
273:26 - seconds
273:29 - and then i can say time one dot
273:31 - micro seconds
273:33 - if i save this file
273:34 - run this code
273:36 - it says time one dot oh it's micro
273:38 - second
273:40 - and run this file and as you can see i
273:42 - can also get the micro seconds
273:45 - the date times time class provides us
273:47 - some of the basic time functionalities
273:49 - however if you want more control and
273:51 - functionalities related to time we
273:53 - suggest you to use the time module we
273:56 - already have an article on it on our
273:57 - programming website in case you want to
273:59 - check it out the link will be in the
274:00 - video description
274:04 - the date time module has the date class
274:06 - to work with dates and the time class to
274:08 - work with time and if you need to work
274:10 - with both date and time at once the
274:12 - daytime module has also a datetime class
274:15 - the datetime class of the datetime
274:16 - module is used to create objects that
274:18 - contain all the information from a date
274:20 - object as well as a time object let me
274:23 - create a datetime object so i'll say
274:25 - import
274:26 - datetime as dt now let me create a
274:29 - datetime object so i'll say datetime
274:32 - underscore obj
274:33 - equals dt dot datetime the datetime
274:37 - class takes in all the integer arguments
274:39 - that are used by the date and the time
274:41 - class one after the other so here i can
274:43 - say 2021 which is the year 11 the month
274:47 - november 28th so 28th of november then i
274:51 - can say the time is 23 or 11 pm
274:55 - 55 so 11 55 pm and then 59 seconds so
275:00 - almost midnight let me close the bracket
275:02 - and i can say print date time underscore
275:05 - obj
275:07 - and let me see what i get so let me go
275:08 - to the terminal and say python mean dot
275:11 - pi
275:12 - and as you can see i get a daytime
275:15 - object that represents the time based on
275:17 - the arguments that i passed here
275:20 - now if i only need to get the date from
275:22 - this daytime object i can always use the
275:24 - date method so let me hide the terminal
275:27 - and here i'll say print
275:29 - datetime underscore obj and i want to
275:32 - call the date method of this object
275:35 - so here let me save this file and i'll
275:37 - run python main dot pi and as you can
275:39 - see i got the date object separately
275:42 - similarly to get the time i can use the
275:44 - time method so here i'll say
275:48 - print
275:49 - date time
275:50 - underscore obj dot time
275:55 - let me save and run this code
275:58 - and as you can see i get the date time
276:00 - object then by using the date method i
276:03 - separate the date object and similarly
276:06 - by using the time method i separate the
276:08 - time object
276:10 - like with date and time objects we can
276:12 - also access individual attributes like
276:14 - year month and hour as we have
276:17 - previously discussed
276:20 - to get the current local date and time
276:22 - at once we can use the now method of the
276:24 - datetime object so i'll go to my code
276:27 - editor and i'll say import
276:29 - datetime as dt now to get the current
276:33 - date time i can just say current
276:35 - underscore
276:36 - date time
276:37 - equals
276:38 - dt dot datetime.now
276:41 - now let me print this so i'll say print
276:44 - current underscore date time and save
276:47 - this file go to my terminal say main dot
276:50 - pi and as you can see i got the current
276:53 - date and time so it is 5 48 pm on 27
276:57 - january 2021
276:59 - right now during the time of this
277:01 - recording
277:03 - a time delta object represents the
277:05 - difference between two dates or times
277:07 - let me show you what i mean to
277:09 - demonstrate this i will find out the
277:11 - time difference between now and the next
277:13 - new year let me go back to my code
277:15 - editor and say import date time as dt
277:18 - now let me get the current time so i'll
277:20 - say current underscore time equals dt
277:24 - dot date time dot now we already know
277:26 - this
277:27 - now the next new year is next underscore
277:30 - new underscore year equals dt dot date
277:33 - time and the integers arguments are 2022
277:38 - and january is one and again first
277:40 - january is 1.
277:42 - now to calculate the time remaining i
277:44 - can say time underscore remaining
277:47 - equals
277:48 - next
277:49 - new year minus
277:52 - current underscore time
277:55 - let me print this and see what we get so
277:57 - i'll say print
277:58 - time
278:00 - remaining
278:01 - save this file go to my terminal run
278:04 - python main.pi and as you can see it
278:07 - tells me that there are 330 days six
278:10 - hours nine minutes zero seconds and
278:13 - three three five five seven six micro
278:15 - seconds from now to the next new year
278:19 - now let me see what the type of the time
278:21 - remaining variable is so here i'll say
278:23 - print
278:24 - type
278:25 - time remaining
278:26 - and when i run this code
278:29 - you can see that it gives me class date
278:31 - time dot time delta
278:33 - that means the difference between two
278:35 - date times is a time delta object
278:39 - this time delta object can also be added
278:41 - to or subtracted from daytime objects to
278:43 - get new daytime objects
278:48 - the strf time method returns a string
278:50 - representing date and time for the
278:52 - datetime object we know that there are
278:54 - many formats to write the date and time
278:57 - depending on your location if you're in
278:58 - the us you probably use month day year
279:01 - format but if you're in the uk you will
279:03 - generally use the day month year format
279:07 - the strf time method allows us to
279:09 - display the date and time in a custom
279:11 - specific format let me show you what i
279:13 - mean i'll go to my text editor and i'll
279:15 - say import
279:17 - date time as dt let me get the current
279:20 - date time
279:22 - so i say dt dot datetime
279:26 - dot now
279:28 - let me print the current date time so
279:29 - print
279:30 - current underscore date time i'll save
279:33 - this file go to my terminal and say
279:35 - python main.pi and as you can see this
279:38 - is the current date and time during the
279:40 - time of this recording in the standard
279:42 - format
279:43 - if i wanted to print the date in a
279:44 - different way i could convert this
279:46 - datetime object to a date string in a
279:48 - specific format let me show you how
279:51 - string underscore date equals
279:54 - current underscore date time dot because
279:58 - i want to call the str f time method and
280:01 - inside this fdi strf time method i'll
280:03 - pass an argument as percentage capital a
280:07 - comma
280:09 - percentage capital b
280:11 - space
280:12 - percentage d
280:13 - comma percentage capital y
280:17 - let me print this
280:19 - string underscore date
280:20 - i'll go to my terminal
280:22 - and say python mean dot pi
280:25 - and you can see wednesday comma january
280:28 - 27 comma 2021 is printed
280:31 - this date is now in a much more human
280:33 - readable format
280:35 - here i'm taking the current underscore
280:37 - date time object and calling the strf
280:40 - time method on it to get the string in
280:42 - the date format here percentage a
280:45 - represents the weekday name
280:47 - that is wednesday
280:49 - similarly percentage b represents the
280:52 - month's full name which is january
280:54 - percentage d represents the day of the
280:57 - month which is 27 since the time of this
280:59 - recording it's january 27th similarly
281:03 - percentage y is the year which is 2021.
281:06 - i could have also printed the date and
281:07 - time in a different format let me show
281:09 - you how that works so i'll remove the
281:11 - terminal and here let me change the
281:13 - format to something else
281:15 - i'll say percentage b
281:18 - space
281:20 - percentage dash d comma
281:23 - percentage i and percentage p
281:26 - now let me run this code so here i'll
281:29 - say python
281:31 - main dot pi
281:33 - and as you can see i have printed the
281:35 - same date in a different format
281:38 - here these are format codes that made it
281:42 - possible to transform our datetime
281:43 - object to a string in a certain format
281:46 - there are many such format codes
281:47 - available for us to use
281:49 - don't worry you don't need to memorize
281:51 - all these format codes you can visit our
281:53 - article on strf time to search among all
281:55 - the formatting directives as per your
281:57 - needs the link will be in the
281:58 - description below
282:01 - the strp time method is the opposite of
282:03 - the strff time method the strf time
282:06 - method converts date time objects to
282:07 - strings whereas the strp time method
282:10 - converts strings to datetime objects let
282:12 - me show you what i mean and i'll say
282:14 - import datetime as dt
282:17 - then i can say date underscore string
282:19 - equals so let me pass in a date that
282:22 - looks like 21
282:23 - june
282:24 - 2021
282:27 - and then i can convert this to a date
282:29 - object by saying date underscore object
282:32 - equals
282:33 - dt dot datetime
282:36 - dot str
282:38 - p time and the first argument is the
282:40 - date string so here i'll say date
282:43 - underscore string the second argument is
282:46 - as before the codes that represent the
282:48 - different parts of the date so i can say
282:50 - percentage d because 21 is the number of
282:53 - the day
282:54 - and then i can say percentage b
282:58 - comma similarly year in numeric format
283:01 - was percentage y
283:03 - and then end the code in the bracket
283:06 - now let me print what date object i get
283:09 - so let me say print
283:11 - date object
283:14 - and here i can say date underscore
283:16 - object let me go to my terminal say
283:19 - python main dot pi
283:22 - and as you can see i got the date object
283:24 - that i was looking for
283:26 - here i have passed both the string and
283:29 - the format in which the date is
283:31 - represented in the string as parameters
283:34 - to the strp time method of the datetime
283:37 - class of the datetime module and this
283:40 - gave me the datetime object
283:42 - as i said before percentage d represents
283:46 - the day of month
283:47 - similarly percentage b represents the
283:50 - month's name in full and percentage y
283:53 - represents the year
283:55 - it's also important for me to leave this
283:57 - comma and space here because it's the
284:00 - format that my date is in
284:02 - while using strp time the string and the
284:05 - format code must match exactly if the
284:07 - string and the format code don't match
284:09 - we will get the value error exception
284:11 - now that we know about strp time and
284:13 - strf time we can convert any date in any
284:16 - format to another for example if i have
284:19 - a date string in the uk format and need
284:22 - to convert it to the us format i can
284:24 - first convert the uk date string to a
284:26 - datetime object using the strp time and
284:28 - then convert this object back to a
284:30 - string in us format using strf time
284:34 - at this point we have covered all the
284:35 - basics of using the datetime module
284:37 - except one important topic handling time
284:40 - zones time zones can be especially
284:42 - tricky if you're working with them for
284:43 - the first time for example in nepal it's
284:46 - currently 6 05 pm which means it's 7 20
284:49 - am in new york and 5 50 in india as this
284:53 - video is already long we will not cover
284:55 - this topic in this video if you want to
284:56 - learn how to handle time zone issues in
284:58 - python we suggest you to use the pi tz
285:01 - module it's the same module recommended
285:03 - by the official python documentation
285:05 - that's it for this video if you want to
285:07 - revise these concepts you can find all
285:09 - these programs in our github repository
285:10 - i'll also put this link in the video
285:12 - description
285:15 - python decorator is a function that
285:17 - takes in another function add some
285:18 - functionality to it and then returns it
285:21 - in this video you will learn how to
285:22 - create decorators and why you should use
285:25 - them
285:26 - before we learn about decorators we must
285:28 - first understand a few basic things in
285:30 - python we must be comfortable with the
285:32 - fact that everything in python is an
285:34 - object including classes as well as
285:37 - functions variables are simply
285:39 - identifiers bound to these objects if
285:41 - you want to learn more we already have a
285:43 - video on this topic you can refer to
285:45 - that video since functions are also
285:47 - objects we can also pass functions as
285:50 - arguments to other functions let me
285:52 - demonstrate this to you i'll go to my
285:54 - code editor and here i'll say def
285:57 - inc
285:58 - x so i'm defining a function that
286:00 - returns
286:01 - x plus 1 or whatever is passed in plus 1
286:05 - now i'll create another function which
286:07 - takes a function as an argument so here
286:10 - i'll say def
286:11 - operate
286:13 - and func
286:14 - x
286:16 - this will save result equals
286:19 - func x and then
286:22 - return the result
286:24 - here the operate function takes two
286:26 - arguments the first is a function and
286:28 - the second is a regular argument x
286:32 - let me call operate with the ink
286:33 - function as the first argument
286:35 - so here i'll say operate
286:39 - ink and i'll pass 3 as the parameter
286:42 - now let me print this
286:44 - so here i'll say print
286:47 - and when i press run
286:50 - then you can see that 4 is printed
286:53 - here's how this code works
286:55 - first we have called the operate
286:56 - function
286:57 - with the ink function as the first
287:00 - argument and three as the second
287:02 - argument
287:03 - this ink function is then assigned to
287:05 - the func parameter
287:07 - inside the operate function
287:10 - then we have called the func function
287:12 - and assigned the return value of this
287:15 - func to the result variable and in the
287:17 - next line we have returned whatever
287:19 - result was stored in the result variable
287:23 - in this case since we have pass 3 and
287:26 - ink returns x plus 1 or 3 plus 1 this
287:30 - whole function returns 4 and that is
287:32 - what gets printed to the screen
287:35 - the main takeaway from this example is
287:37 - that a function can take another
287:38 - function as an argument
287:40 - in python we can also define a function
287:42 - inside a function let me show you an
287:44 - example
287:46 - so here let me remove this old code and
287:48 - here i'll say def
287:50 - print underscore message
287:53 - and then let me pass the message as the
287:55 - argument
287:56 - inside this function i'll say
287:59 - greeting equals hello
288:02 - and then let me define another function
288:03 - inside so here i'll say def
288:06 - printer now this does not need any
288:08 - arguments
288:10 - and here i'll say print
288:12 - greeting and then the message
288:15 - now let me call printer from inside the
288:17 - print underscore msg function so here
288:20 - i'll say printer
288:22 - and then from outside the function i can
288:24 - say print underscore msg
288:27 - python
288:28 - is
288:29 - awesome
288:31 - here i have defined an inner printer
288:33 - function inside the scope of the print
288:36 - underscore msc function
288:38 - here's how this code works
288:39 - first we called the print underscore msg
288:42 - function with python is awesome as the
288:44 - parameter
288:46 - inside the print underscore msg function
288:49 - we have called the inner printer
288:51 - function
288:52 - which prints the greeting and message
288:54 - variables
288:56 - let me run this code
288:59 - and you can see that hello which was the
289:01 - value of the greeting variable and
289:03 - python is awesome which was sent as a
289:06 - parameter to print underscore message
289:08 - are both printed
289:11 - the main takeaway from this example is
289:13 - that we can define a function inside
289:15 - another function
289:16 - another thing we need to understand
289:17 - about functions is that they can also
289:19 - return a function as a value now let me
289:22 - modify this code a bit instead of
289:24 - calling the printf function from inside
289:26 - the print underscore msc function i will
289:28 - return the printer function itself we
289:31 - already know that if there are
289:32 - parentheses after a function
289:34 - that function gets called in this case i
289:36 - don't want to call the function but
289:38 - return the function itself so let me
289:40 - remove this parenthesis and here i'll
289:42 - say return printer now i'll assign the
289:45 - return value to a variable named func
289:48 - now outside the print message function
289:50 - here i can say funk equals print
289:53 - underscore
289:55 - msg
289:56 - python
289:58 - is
289:58 - awesome and let me
290:00 - run the func function so f unc and
290:03 - parenthesis
290:04 - let me run this code
290:07 - and you can see i get the same output as
290:10 - before but do you notice something weird
290:12 - here
290:13 - we can see that the outer function print
290:16 - underscore msg is done executing on this
290:19 - line
290:21 - this should mean that all its local
290:22 - scope variables are destroyed after it
290:24 - finishes executing however when we call
290:27 - the func function
290:29 - we still have access to message and
290:31 - greeting variables in the inner printer
290:34 - function
290:35 - such a function is called a closure a
290:38 - closure is simply an inner function that
290:40 - remembers the values and variables in
290:42 - its enclosing scope even if the outer
290:44 - function is done executing python
290:47 - decorators make extensive use of
290:49 - closures
290:50 - now we are finally ready to learn our
290:52 - python decorators
290:55 - a python decorator is a function that
290:57 - takes in a function adds some
290:58 - functionality to it and returns the
291:00 - original function
291:02 - let's try to build a decorator function
291:03 - that prints out some information before
291:06 - and after executing another function
291:08 - i'll go to my code editor and first
291:10 - define a normal function called printer
291:12 - so let me remove this old code and here
291:15 - i'll say def
291:16 - printer
291:18 - this will just print
291:20 - hello
291:21 - world
291:23 - now i'll define a decorator function
291:25 - that takes in a function
291:27 - so outside this i'll say def
291:29 - display
291:31 - underscore info and then i'll pass func
291:34 - or function as a argument
291:36 - now i'll add an inner function that
291:38 - prints out some information before and
291:40 - after executing the function
291:42 - so here i'll say def
291:45 - inner
291:46 - now i'll use the underscore underscore
291:48 - name or dunder name attribute of the
291:50 - function to access its name
291:53 - so here i'll say print
291:56 - executing
291:57 - and i can say funk dot underscore
292:00 - underscore name underscore underscore
292:02 - and then i can say function
292:04 - then i'll call this function
292:06 - so here i'll say funk
292:09 - and after the function is executed i can
292:11 - say finished executing so here print
292:15 - finished
292:16 - execution
292:19 - now inside this outer display underscore
292:21 - info function i'll return the inner
292:23 - function so here i can say return
292:26 - inner
292:27 - now let me run the printer function
292:29 - normally first so i'll go outside and
292:32 - i'll say printer
292:33 - let me run this
292:35 - and you can see that hello world is
292:36 - printed nothing fancy
292:38 - now here comes the magic
292:41 - i'll use the decorator function to run
292:43 - the same printer function this time let
292:45 - me remove this code now i'll call the
292:47 - display info function with the printer
292:49 - function as the argument and store the
292:51 - returned value
292:52 - so i can say
292:54 - decorated
292:55 - underscore func equals
292:58 - display underscore info and this will
293:00 - take in the printer function as an
293:02 - argument now let me call this decorated
293:05 - underscore func function so i'll say
293:07 - decorated
293:08 - underscore func with parentheses and
293:10 - when i run this code
293:13 - you can see that executing printf
293:15 - function and finished execution are
293:18 - printed before and after our hello world
293:21 - here's how this code works when this
293:23 - line of code is executed the display
293:25 - underscore info decorator function gets
293:28 - called
293:29 - with the printer function which gets
293:31 - converted into the func argument inside
293:34 - this display underscore info function
293:37 - there is an inner function this inner
293:39 - function prints out executing the funct
293:42 - name function
293:44 - calls the func parameter or calls the
293:46 - function that is passed as a parameter
293:48 - and then prints finished execution
293:52 - as you can see the decorator function
293:54 - acts as a wrapper it allowed us to add
293:56 - some functionality to the past function
293:58 - without changing the code of the
294:00 - original function in python we have a
294:02 - much more elegant way of writing these
294:05 - lines
294:06 - implicitly using the at symbol let me
294:09 - show you how i'll first remove these
294:11 - lines and rearrange these functions so
294:13 - let me remove these i'll copy this code
294:16 - and put this before printer you will see
294:19 - why i'm doing this soon
294:22 - now comes the magic instead of calling
294:24 - the display info function
294:26 - before the printer function i'll say at
294:29 - display underscore info
294:32 - this code is equivalent to our previous
294:35 - code
294:36 - as you can see adding the add symbol on
294:38 - top of a function definition means that
294:40 - we are passing that function as an
294:42 - argument to the decorator function and
294:44 - reassigning the function to the return
294:46 - function we passed the printer function
294:48 - to display underscore info decorator and
294:51 - reassign the printer function to the
294:53 - returned inner function
294:55 - as you can see adding the add symbol is
294:58 - a sweeter way to do the same thing it
295:00 - also avoids creating one more extra
295:03 - variable
295:04 - we pass the printf function to the
295:06 - display info decorator
295:08 - using the add symbol makes our code much
295:10 - more cleaner and we can now call the
295:12 - printer function directly without
295:14 - assigning the decorated function to
295:16 - another variable
295:17 - so in my code editor i'll directly call
295:19 - the printer function this time i can
295:21 - just say printer
295:24 - and when i press run
295:26 - then you can see that i got the same
295:28 - output as before while writing a lot
295:31 - lesser code and also making it much
295:34 - sweeter or you know much more
295:36 - synthetically
295:37 - pleasing to see
295:40 - the decorator we created in the previous
295:42 - section was simple and it only worked
295:44 - with functions that did not have any
295:46 - parameters now let's discuss how we can
295:49 - create decorators for functions with
295:50 - parameters suppose we have a simple
295:53 - divide function so i'll go to my code
295:55 - editor remove this old code and say def
295:58 - divide
296:00 - a comma b so it's a function with two
296:02 - parameters and it says return a divided
296:05 - by b
296:06 - at this point we already know this code
296:09 - will throw an exception if we pass the
296:11 - value for b as zero now let's make a
296:13 - decorator function called smart
296:15 - underscore divide to prevent this so on
296:17 - top of this function i'll say def
296:20 - smart underscore divide now smart
296:23 - underscore divide will take a function
296:25 - as an argument since the inner function
296:27 - will replace our original function the
296:29 - parameters should be added to the inner
296:31 - function
296:33 - so here i'll say def
296:36 - inner
296:37 - a comma b
296:39 - i will print out some information before
296:41 - dividing so here i will say print
296:44 - dividing
296:48 - a
296:50 - by
296:51 - b
296:53 - i will then check if b is 0 and if so
296:56 - i'll print the message and use return to
296:58 - stop for the execution so here i can say
297:01 - if
297:02 - b
297:03 - equals equals 0
297:05 - print
297:06 - cannot divide by 0
297:11 - and then i can say
297:12 - return
297:14 - else i just return the function so i'll
297:16 - say return
297:17 - func
297:18 - a comma b
297:20 - and then on outside i can say return
297:23 - inner
297:24 - now let's add this decorator to our
297:26 - original function so here you must have
297:28 - already guessed what i'm going to do now
297:30 - i'll say add smart underscore
297:33 - divide
297:34 - now let me call the divide function so
297:37 - here i'll say
297:38 - divide first i'll call it with nonzero
297:41 - arguments and then i'll call it again
297:43 - with the zero denominator so divide 15
297:46 - by 3
297:47 - let me put this in a variable so i'll
297:50 - say value 1 equals divide 15 3 and let
297:54 - me print
297:55 - value 1 similarly
297:57 - value 2 equals divide and this time i'll
298:01 - say divide 5 by 0
298:03 - let me put a space here
298:05 - and here i'll say print
298:09 - value 2.
298:11 - let me run this code
298:14 - as you can see in the first call the
298:16 - denominator was a non-zero element so
298:19 - the value after division is returned and
298:21 - it gets printed to the screen in the
298:23 - second call the division was halted and
298:25 - no value was returned that is why none
298:28 - gets printed here
298:32 - in python a function can be decorated
298:34 - multiple times with different or the
298:36 - same decorator let me show you what i
298:38 - mean here i have a simple printer
298:40 - function that prints whatever message is
298:43 - sent to it as a parameter
298:45 - i also have two decorator function star
298:48 - and percent
298:49 - these functions print a series of star
298:51 - and percentage symbols before and after
298:54 - executing the function let's now
298:56 - decorate the printer function with the
298:58 - star and percent decorators and call the
299:00 - function so here i'll say at
299:03 - percent and similarly i can go to the
299:05 - next line and i can say star
299:08 - let me call this printer function so i
299:10 - can say printer
299:12 - decorators
299:14 - are
299:15 - wonderful
299:17 - let me run this code
299:20 - as you can see these decorators are
299:23 - chained and they wrap the original
299:25 - function
299:26 - here we have first added the star
299:28 - decorator and then the percent decorator
299:31 - so the star function wraps the percent
299:33 - function and the percent function wraps
299:36 - the printer function
299:37 - at this point we have covered the basics
299:39 - of python decorators if you want to
299:41 - learn more about decorators you can
299:43 - check our article on our website
299:44 - programmings.com the link will be in the
299:46 - video description if you're enjoying
299:48 - this video please also check out program
299:50 - is pro where we provide tutorials along
299:52 - with quizzes and challenges which will
299:54 - help you practice and test your learning
299:55 - in real time also the course includes
299:58 - projects to give you an awesome
299:59 - experience of how programming works in
300:00 - the real world and for our youtube
300:02 - subscribers we are giving 50 off on the
300:04 - yearly plan sign up by scanning this qr
300:06 - code or use the link in the video
300:08 - description to claim your discount