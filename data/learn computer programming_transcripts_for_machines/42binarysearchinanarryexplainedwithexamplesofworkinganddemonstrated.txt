welcome back students we have already learned linear search in previous class today we will learn binary search in our a binary search works only for sorted array it may be sorted by ascending order or descending order in this type of search search value is compared with middle element of array if the value matches with the middle element then search gets completed if the match is not found at the middle element again it will search with middle element of first half otherwise second half it depends on the searching value our sorting of the array for example if the value being searched is lesser than the middle element then it gets performed only in the first half this is in the ascending order array if the value being searched is greater then it will perform in the second half of the array this process will keep on repeating until the element is found our until search get completed if element is not found then search will get completed when first index number is equal to the last index number we will understand this by few examples later once again we will come to this and then we will read so I have array integer array having the values like this let us search for element 23 so for your reference I have given index numbers starts from 0 and the last index number here is 11 now it should find the middle index number and then for that whichever element is there it will compare with that element how the middle element is found is like mathematics we will take the first index and the last index we add both and divide by 2 or time we will get that mean so that is the middle index we will get for your better understanding I have matched first index last index even the middle index with the colors please follow the colors also so that it will be easy for you to understand for the first time the certs will be in the whole array so it takes the first index as 0 last index as 11 here and then we will add first index and last index divided by 2 so we will be getting 5.5 index number cannot be 5.5 so we leave the decimal part and then take only the integer part here in the program also it will do automatically implicit conversion that is integer divided by integer it gives only the integer value as quotient now in the middle element 37 is there so we are searching for 23 it is lesser than 37 so when it is sorted array there is no meaning in searching this second half because what we are searching will be in the first half only because search element is lesser than the middle element so it will not search in the second half now the middle element is already compared so remaining segment that is index from 0 to 4 only we have to search so here first index remains as 0 itself but the last index instead of 11 it should be 4 we already found middle in element as 5 so what we do middle element minus 1 you will use the next last index so in round 2 we will have first index as 0 last index as 4 so 0 plus 4 divided by 2 we will get to as the result so in 2 23 is available which is equal to which we are searching so what happens search becomes successful and then it will print the index number of that element let us see next example I have a new array here after removing the last element of that previous array so let us search for element 51 I have the index number from 1 to 10 so at round 1 the first index number will be 0 and the last index number will be 10 so middle element we find 0 plus 10 divided by 2 we get exact 5 at index number 5 I have 37 so 51 is greater than 37 so no meaning in the searching first half so automatically it will search in the second half first index of the new segment is arrived by adding 1 with the middle element so it becomes 6 last index remains unchanged so now we get 6 plus 10 divided by 2 that is 16 divided by 2 we get 8 as middle element of this segment at index 8 54 is available 51 is lesser than 54 so it is not necessary to search the second half again now the first index remains same the last index will be middle index minus 1 that is 8 minus 1 so now for round 3 the new value of middle index will be 6 plus 7 divided by 2 that is 6 point 5 here again we will take only the integer part that is 6 lakhs index so at index 645 is available so 51 is greater than 45 first half we don't need to search to get the first index we add middle index plus 1 we get 7 in the last index is also 7c now first index is also a say 7 last index is also 7 if the element is not found at this index then search also will stop let us check 7 plus 7 divided by 2 will be 7 X n so we get 51 here 51 which is we are looking for it becomes successful if some other element is at that place and then it becomes unsuccessful as first element and last element both are same index let us go to one more example index number of this array is 0 to 11 so let me search for the element 11 at round one first index is 0 and last index is level so we will have middle element as 0 plus 11 by 2 as 5 point 5 only integer part of this we will take so we will take 5 at 533 is the value available 11 is lesser than 33 so greater than the middle element index numbers we don't need to search the first index of new segment of array will be zero the last index will be middle index minus 1 that is 4 so at round to 0 plus 4 divided by 2 is equal to 2 element at index number 2 is 23 which is again lesser than 11 so the first half will be searched Sakina we don't need to search first index remains the same last two indexes middle index minus 1 so that becomes 1 so at round 3 0 plus 1 divided by 2 it will be 0.5 so we take only 0 at 0 11 is available which is equal to the element which we are searching for so search becomes successful I will give you the last example where the search element is not available so example for I am searching for 53 which is not available in this I think so here the first index is 0 last index is 10 so we get 5s answer at 5 we have 37 53 is greater than 37 so it will not search in the first half first element becomes middle element plus one last index remains same now it round to 6 plus 10 by 2 it becomes a eat again at index 8 54 is available 53 is lesser than 54 so the second half will not get searched now the first index remains same last index is middle index minus 1 so that is 7 so at round 3 6 plus 7 divided by 2 is 6 point 5 so it will take only integer that is 6 at 645 is available 45 is lesser than 53 so we don't need to certainly first half so index number our first element will be middle index plus 1 that is 6 plus 1 is equal to 7 from the last index also 7 so drowned 4 7 plus 7 divided by 2 is equal to 7 so at index 751 is available again which is not correct being first index and last index our same search stops then it becomes unsuccessful students when we do manually we will do like this but when we do your program all this round 1 round 2 round 3 round 4 all will be done in the loop so it will be very easy to write the program just we need to understand how we change the first induction last index and which segment to be searched let us do a program as usual I will copy codes from the previous program until we take the input I will create a new class called binary search I change the name of the class here we need 3 variables instead of this we will have first index 0 as default and then last index in the beginning it will be 1 lesser than the length of array that is a RR dot length minus 1 and also we need middle index the DCM here we take the input after taking the input user will also give the element to be searched so for that then I assign the value in s is equal to integer dot parse in Tov BR dot readline now now we need a loop to perform but we don't know the exact number of iterations it is going to happen so we cannot use farlow instead of that we will use while loop what condition here we can give the first index always will be lesser than last index and it will search until first index becomes last index that is both index becomes same so we will give the condition here first index is lesser than or equal to last index first we need to find the middle index so middle index is equal to first index plus last index divided by 2 do not forget to put this first index plus last index inside the bracket otherwise it will give other meaning that is L divided by 2 and then it will add with the first index then it will not work after finding the middle element we will compare the element of that index for that we will you if condition if so which we are searching is yes equal to equal to AR AR of that middle index yeah so if this is true we can print the index number where it is available so system dot out dot print line of element is available at index that is M is the index so young we will print and then we should have boolean type variable so we have not given that we will give here bull in flag is equal to false as default value so now it will become true flag is equal to two and then we can break the loop else if condition if search is greater than ARR of Y M then what we do we will not search in the first part of that array so first index will become F is equal to middle index plus one yells automatically it will be yes will be lesser than ARR of M so now what we do last index will be middle index minus one so this will keep on repeating until F is equal to L so if it is false then it comes out of the loop now we can print if flag is equal to equal to false otherwise this we can also write flag is not equal to false so not we can write here then we will print system dot out dot print line of the element now formed so now we will close the with that close the class let us compile no syntax error we will run this I will give 1 6 9 23 it should be sorted so we should give the greatest value only 67 8690 112 156 178 so which we are looking for maybe six so element is available at index one let us run once again 1 5 9 2356 478 598 634 700 841 so let us search for 841 so element is available at index 9 so that is one lesser than the length last index so in case it is in descending order how we can do it in stuff yes is greater than ARR of M we will just change into lesser than air RM so ultimately the whole process reverses let us check no syntax error are you 9 8 7 8 7 6 6 5 4 5 4 3 4 3 2 2 1 0 1 1 2 1 1 0 4 not 895 so let us search for 432 so it is at index 4 0 1 2 3 4 let us turn once again 10 9 8 7 5 3 1 10 12 15 so let me check twirl it is available at index 8 so students it is clear now let us learn how to search in string type of array so I will change the array type so let me change this as 6 then when we take the input we will have only BR dot readline off and then even this will be string type then taking the input will be we are not real enough here in the condition instead of equal to equal to we will use dot compare 2 which gives the integer type output 6 lexico and string functions I have already explained in the previous lessons you can check their yes dot compared to then this will be in chilly bracket which is equal to equal to zero here away we will have the same thing when it is greater than 0 greater than 0 is fine ascending order of that array that is ASCII value of first letter of the string which we are comparing is greater than the middle element so we will get the positive value which is greater than 0 so at that time we will not compare the first half of the array so it becomes first index will be middle index plus 1 in case it is descending order array then we will change the symbol to lesser than 0 let us compile this let me you Ament bolu chapin turn of all issuer joschwa so we will search for issue it is available at index 4 so 0 1 2 3 & 4 5 is the last index in case it is in descending order we change this into lesser brand symbol compile are you Windows UNIX office Microsoft Excel Doss let me check for Unix so element is available at index 1 here we are had given 10 elements it remained we didn't change at all so it was 6 right we can use 6 I should give in the descending order so let me you HP logitech lenovo epson Dell yessir let me check for Dell so element is available at index 4 it is right students let us revise the points once again I hope it is very clear for you please keep on watching my videos and learn more thank you students