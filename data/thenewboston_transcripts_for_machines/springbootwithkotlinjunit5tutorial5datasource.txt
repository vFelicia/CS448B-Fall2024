so in this video we're going to take a look at the next layer above our bank entity so above our data layer we'll also take a look at spring boot repositories and we'll write our first junit 5 test cases and actually using test driven development along the way so many interesting topics in this video so let's go ahead and get started so i want to start off by thinking about the architecture we want to have so at this point we have our data layer ready which is our bank entity so the next thing would be a service layer that knows how to retrieve the banks how to update a bank and so on and then later on we can move even further up to the web layer where we have a controller that defines all the rest mappings and so on now actually i'm going to go ahead and create one more layer in here let me actually copy this one so what we want to gonna do in this video is we're gonna introduce a data source and this data source will be responsible for data retrieval and storage and those kinds of aspects now why do we have an additional layer here well this is going to allow us to easily inject different types of data sources into the service layer later on so this way you could retrieve the data from the network from a database from a cache whatever you want to do and you can exchange those implementations of the data source quite easily so this can be a really useful pattern which is why i'm going to show it to you here all right so that means the goal for this video will be the data source layer and then in the following videos we're going to tackle the service layer and then the web layer so let's move back now to our ide so let's go ahead and create a new package for this new kind of spec to our application and i'm going to call this packet simply data source and then in here i'm going to create a new content class or file and actually i'm going to move down to interface down here and just going to call this one bank data source so this will be the more abstract interface for us which just defines what kind of functionality we expect from our data source and for now since we only want to implement the get endpoint for all the banks let's just add one method here called get banks and this of course we expect to return a collection of our bank entities okay so with the interface done let's go ahead and for now just create a mock implementation of this so i'm actually going to create another sub package here called mock and inside this i'm going to add a new mock bank data source so for now we're not going to care about database access or anything like that we just want to get it to work and see how all the layers work together now first of all this class is supposed to implement our bank data source interface in kotlin you just do this with a colon and then inside here of course we should implement this method called get banks and then the error is gone as well so it's already going to generate a fake method body here with a to do the next thing i want to do is i want to add a annotation here which is called repository and this simply marks our mock data source as a spring boot bean so this adds it to the application context and it tells spring to initialize this bean or this object at runtime and it also tells spring that this is not just any bean or object it's in fact a repository which has a few implications later on for instance when testing things and of course on top of that it also conveys meaning to the developers so when someone reads your code and they see the annotation at repository then they know okay this is a repository which means this class is responsible for retrieving data storing data and those kinds of functionalities to access one of your entities so now as i promised we're also going to take a look at testing in spring boot at junit 5 and test driven development so let's go ahead and create a new test for this one and this will simply be called mocked bank data source test and i'm going to go ahead and just create this please make sure that here you have junit 5 selected so hit ok and then here we have our empty test class ready to go now the whole point of test driven development is you go ahead and you write your test first and you make sure that your test fails so that you know when you fixed it that the test is actually testing what you thought it would test so if you don't know that it has failed before you actually fixed it oftentimes you can run into the case where you're not really testing or what you're trying to test so let's go ahead and write a first test case over here and please notice that i'm using a live template so if i just type test and hit tab it's going to create this test case template for me if you want to do something similar just go into your settings and then under live templates you can go to kotlin and then over here you can add a new um live template if you want to look how this is done you can see down here for test i just created a welder function body and you can create placeholders by placing them in dollar signs and then also you want to make sure that this is applicable in kotlin classes so you can select this when you create it down here and then you're all set and you're good to go now the first thing we want to test here is that the mock data source should provide a list or a collection of banks and then inside this test case you can see i have the given when then structure some people also call this arrange act and then assert and the whole purpose is that you have your test prerequisites or the whole test setup done in given and when denotes the actual call that's being made that you want to test and under the then block you just add all your assertions now for this particular test case i don't think we'll have any anything here under given but then when we say our banks is equal to our mock data source dot get banks and we don't have this variable yet so let's go ahead and create a property mock data source and so i'm just going to create this right here so i'm going to create an instance of mock data source and actually i want this to be not just the type i just want to assign this so in kotlin the type is inferred automatically as you may have noticed so i don't have to have the type there again so now i have this object ready and notice that this is a design decision already for this test there are different ways you could test this this right now by just instantiating this object manually basically means we're just testing our data source as a pojo as a plain old java object we're not using any spring boot dependency injection we're simply creating a regular junit 5 test case that we could write just the same way without any spring boot dependencies at all so just creating the object ourselves and then we're testing it and i'm going to talk about some of the different types of tests you can have in spring boot at the layers above where we're also going to use the application context but for now let's start with also i guess the simplest type of test where you're just testing a plain old java object so when we have our banks equal to mockbankdatasource.getbanks then we want to assert that and we should have this dependency here make sure it comes from a third j so assert that the bank's object is not empty now the assert j dependency comes with spring boot starter test which is integrated for you in the dependencies if you don't have this make sure that in your build.gradle you have your spring boot starter test dependency over here and that it's also of course marked with test implementation all right so let's go back and indeed we don't really have any given block in this one so let's go ahead and run this test and see what happens okay so once that's done we can see our test results down here and we see this one test case that we have which is red so that's actually a good thing we want our test case to be failing first again that's test driven development so you basically have this cycle of red green and then refactoring so now we're at the first stage we have a red test which means a failing test so now we want to make this test green so let's go back to our implementation so to our mock bank data source and then what's happening here is of course it cannot fulfill this assertion because instead it throws a not implemented error which comes from this to do so what we could do here is we could say return a list off or even we could just say empty list just to make the um or just to change the error message and then we can just rerun the test up here now of course since the assertion was that the list should not be empty this is not going to work yet but you can see it's now yellow which actually means that the assertion failed instead of that just an exception was thrown at runtime and we can see here we're expecting the actual value to not be empty so let's go ahead and instead return a list off and then we're going to create a bank entity here and for now we're just going to do the minimum to make the test pass so don't go ahead and implement everything right away at least if you're trying to do test driven development which is what i'm trying to show you here so just really do the minimal to make the test pass now with this that should be fine for this test case all right so we have a green test now so the next step is to refactor our production code and what i want to do is i want to extract the list into a variable which i'm just going to call banks and i also want to actually move this up here and then we just return the banks and again in kotlin we can also do it like this and this should still keep our test passing so i'm going to run this again with shift f10 and yeah it's still running just fine all right so far so good so let's go ahead and create our next test case which is that it should provide some mock data so inside here i think i'm not gonna need a given block again and then i'm gonna say when our banks equal mockback bank datasource.getbanks then i want to assert that that the bank object or the banks they let's say here all satisfy and we're going to take a look at this again in a minute and that the account number is not blank so i want that they all have a proper account number so let's go ahead and try to run this test case and you can see it runs through just fine but if we look at our current mock data we have a bank with an empty account number so what the heck's going on here now if you had already written all the production code you might just think to yourself okay it all looks fine the account number is not blank and all the tests are passing so i'm just going to move on but now because we only did the minimum to make the test case above work we can see that something must be wrong with this test case and in fact if we take a look at all satisfy we can see here an example of how it's supposed to be used so inside all satisfied you are supposed to add multiple assertions on the same object so that's what it's intended for and therefore if we just say all satisfied that the account number is not blank it's just not gonna assert anything what we want to do instead is we want to say all match and again let's also make sure how this one works so as assert that abc they all match the length equals one so this is what we wanted here so all or each element in the collection should fulfill this condition that we specify so now let's go ahead and run our test case again and i'm using shift f10 for this now you can see we have expecting all elements of this list to match the predicate which is the account number is not blank but this one didn't so that's good we have our failing test so now we can go back into our mock data source and try to fix this so i'm just gonna say one two three four for the account number and then run this again now of course we could be as strict as we want now with this mock data we could also say that at least one of them so any match let's say the trust should not be zero so we don't want just zero numbers here or we want the transaction fee to also not equal zero and maybe we even want well let's go step by step we might want more than just one element in the list later on but for now let's run this and let me actually run the entire test class so that we always run all our test cases at once and we can see which status we're at so obviously the second test case now fails so let's go ahead and add a trust of nonzero and the transaction fee already is nonzero let's actually make it 17 then let's run the test again give it a second and we can see all our tests pass now i'm going to add another assertion to our first test case which is that bank dot size is greater than well let's say or equal to three so we want at least three banks of sample data let's go ahead and run this and we can see the test case fails again so this one we probably should have done right away also is not empty is irrelevant now because it's part of this assertion which is also nice because we only have one assertion then in this test case which gives it only one reason to fail now let's go back into our production code and in here i want to create multiple banks now so in your kotlin versions you can actually have the trading comma which is quite nice so you can just duplicate the lines and just keep it like that and i'm gonna let's say add one zero one zero and a trust of 17 here and a transaction fee of zero and here we're going to add a trust of zero so it's always good to test border cases as well but of course this is not really test data so we're just mocking things but it might still be nice to have some zeros or ones in here now of course the account number should be different for each one you could actually create a test case for that if you want to so this would be a nice practice to write your own test case just making sure the account numbers are unique all right so this we should be good to go let's run our tests again and we can actually see the second test case failed now because here apparently i said all match but what i wanted to do is i want to have at least one element or one example bank with a transaction fee uh unequal zero i don't want all of them to be unequal zero even though i believe in the actual the new boston currency you can't have a transaction fee of zero but we're not really implementing that here for this example this is just fine all right perfect so we have our passing tests we could see if you want to refactor anything here but i look but i think this is looking just fine so we have our list of banks and then we just return them for now there's one tiny thing i want to do which is just a rename so for this data source i want to choose a more fitting name for this method which i think would be something like retrieve banks so the data source is a quite low level component and therefore it's really about retrieving the banks from somewhere we don't know if the data source retrieves this from a network or a database whatever the service doesn't really care as long as the data source knows how to provide the data that it needs and then of course in the mock data source it should have renamed it automatically as well it should not rename this one though that's not correct all right so now we have the data source ready to go so in the next videos we're going to work our way up to the service layer web layer and so on and we're also going to see different approaches to testing in spring boot so i hope you learned something in this video it's actually quite a few things although we only went to the surface but really using spring boot with kotlin with junit 5 and also using test driven development i think it's quite a nice practice to follow along and to kind of see how all of these things come together i hope you liked it if you did please leave a like below and i'll see you in the next one