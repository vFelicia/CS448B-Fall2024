alrighty guys welcome back to another tutorial and now that we have the basic registration logic built out what we can do now is we can start listening to the blockchain for transactions sent to our bot account aka deposits or payments whatever you want to call them basically coins sent to our bot account and remember like we said the first time they are going to send coins it's because they are trying to register their account in other words link their blockchain account to their discord account now after they are registered they can continue to send coins and this is going to be we're just going to have it update a balance on their user object but you can have it where you know maybe they're buying like digital gold or buying ingame items whatever you want to do that part is kind of up to the developer but either way what we are going to be doing is listening for those payments from our bank that we already have set up in like the first or second tutorial and before we get into more of the technical details or any of the code i want to walk you guys through this deposit object because this is what we're going to be storing in so the first thing of course like every object this is gonna have an id in this id we're gonna get from the bank's transactions the bank already creates a unique id for each transaction and we'll be taking a closer look at that later on but that's what this is now the amount of course you can probably guess this this is just the amount of coins the user is sending to our account and the block id this is a little bit more technical it's for it's pretty much the unique idea of the block as it's stored on the blockchain and we'll see how this comes in handy in just a bit now confirmation checks is related to this right here so by default whenever a user first sends a payment to the new boston blockchain network that payment is not confirmed it's just like an attempted payment or they're trying to pay someone now that is why whenever our bot first receives these deposits it's going to set is confirmed equal to false this means that yes we see the payment out there but it doesn't have any confirmations yet meaning it didn't officially get added to the blockchain or it wasn't verified yet basically now this confirmation checks if you remember this is gonna say okay once we receive this payment how many times are we gonna hit the network and say hey is this verified yet is this verified yet is this verified yet so we are going to do that up to 20 times because this um process is actually going to have a five second delay so this should really never take longer than like two checks so two checks means like there was ten seconds and that means that like the network was acting slow but we're just going to put 20 as max just to be super safe and the memo of course as you guys saw this is just the description that they add in the transaction and for ours that's what that random code generated is going to be now afterwards when they're already registered and they're just sending payments it doesn't really matter what they type in the memo the memo we are just using for the registration process but you know they can type whatever now another thing that i want to mention and i saw some users talking about this pattern in the community is that instead of this registration process yada yada you can actually have this memo be linked to something directly like a digital item or ingame currency or whatever and then technically users don't even have to register so you can just have people like it's almost like a unique upc or an item code where users can just pay for those things directly but we get some other benefits with um registering as well so anyways going to continue along just want to point that out in case you guys have any cool ideas the sender of course is the sender's account number and this is our basic deposit structure so what we are going to be doing in our code is we're going to be running more or less two processes the first process is going to listen for these deposits and then the second process is going to say okay what deposits did we receive that are not confirmed yet and have less than 20 confirmation checks and that process is independently going to go look at confirmations and once a payment is confirmed then we process their payment or update their balance all right so the last technical thing i want to point out to avoid any confusion is this right here so whenever a user from their client right here they go ahead and send coins what this is going to do is it's going to send an entire block now the block from a network protocol point of view it includes all your transactions which of course include the amount the recipient any optional memo if it's a fee or if it's just a regular transaction so on and so forth the block contains a lot of information a lot of this is just kind of specific to the network protocol involves like signatures to make sure that no one can you know cheat and pretend to be your account so on and so forth so why am i saying all this instead of coding in discord well i say this because what we are doing is we are connected to the bank now what the bank does to make it easier for the user to actually store and query this data is it takes these transactions out of the block and it stores those as a separate object called bank transactions so you can think of a bank transaction is really all the user specific information in the block that isn't part of the network protocol that only the users are really going to care about now to show you guys what this object looks like whenever it's stored i'm actually at the bank transactions endpoint that we're going to hit in just a second and you can see that within each transaction it's either a fee for the primary validator or the bank now typically a big transaction looks like this without any fee and it just has an id and this is what we're going to be storing as our id and then of course it has an amount a memo the recipient and so this is of course the recipient which is going to be our bot account now there are a lot of other transactions going to be happening on the network but we only want to make sure that we are looking at the transactions that were sent to our bot account i really don't care if user a sent user b some coins for pizza or whatever and another thing is it has a reference to its block or in other other words its parent or its container now why am i saying all this again because of this even though we are going to be looking at bank transactions right here those bank transactions came from a block now it's the block itself which has confirmations on it so again even though we're going to be looking at the bank transactions and essentially converting those to deposits pulled open the wrong thing deposits right here that we're going to be storing in the deposits are not going to have confirmations themselves in order to check if these deposits are confirmed we're going to need to look at the block and then we're going to have to say does the block have any confirmations on it if the block itself is confirmed then all transactions aka deposits within are also confirmed so that's why we need to follow this twostep process we just can't say okay if you have some transactions right here without any confirmations then we can just like accept the payment no no we need the confirmation and this says yes this payment is valid okay so hopefully i have that pounded in your head hard enough so now let's go ahead and get to the code so the first thing i want to do is i want to update this honor ready because i want to call a function after here that is going to pull the blockchain now actually can make that right here so we'll say it's going to be asynctask and if i can spell async async def blockchain okay so this is going to actually be the parent function that calls two other functions and we'll say it's gonna pull the blockchain for new transactions or deposits now another thing is that why am i doing this so these are called bank transactions we're going to be looking at an endpoint called bank transactions why did i decide to rename it to deposit in our architecture it seems like i'm just making things more confusing well whenever i think of a transaction especially like at my bank for example i'm thinking that i can send someone something and that's a transaction and also that i can receive something and then that's a transaction as well now for this system it's basically just going to be like a payment integration where you can receive funds but we don't have a withdrawal system built or anything like that so i want to make it very clear that these are just deposits these are just payments coming in to our bot account and then we're gonna sell some service or digital good or whatever but either way i i just think it was a little bit more clear looking at everything so anyways we're gonna say pull the blockchain for new transactions aka deposits sent to the bot account which is the account that we own now i'm going to leave another note here guys here's that ding what the heck was that and i'll say only accept confirm transactions okay so here we go this is going to be my poll blockchain and it's going to be do these two things and i'm gonna break this up into two different functions that we're gonna write later on one is gonna be called check deposits and the other one is gonna be called check confirmations what is this get out of here check confirmations and you guys can probably tell what these are going to do this one is going to look for keep holding this open this one is going to query this endpoint and see if there are any new deposits or any new payments that someone tried to send to our bot account and then this one i don't have the endpoint ready but it's basically going to check for those confirmations so for now let me just let me just comment those out and write pass so my ide doesn't freak out and all right now another thing that i want to do is i actually want to pull this blockchain not just once where as soon as my bot starts up then i'm just going to pull it and say okay uh that's it you check it once and you don't have to check anymore this needs to run again and again and again now i just don't want to run it as fast as it possibly can like on a while loop because then it's going to unnecessarily hit the network and it's guys going to say do you have any new transactions do you have any new transactions so i think that was a little much so instead i'm going to put it on a 5 second loop now anytime you want to make a command in discord that needs to run these periodic tasks it's actually really easy you don't have to set up celery you don't have to set up any cron job or linux task in the background they actually make it a piece of cake so in where you import commands from discord.ext import something called tasks as well and then go back to right above pull blockchain and then what we're going to add is a decorator and that is tess we're going to run this on a loop and then for seconds we're just going to say 5. so this means and i'll put 5.0 just to uh make it very clear so this function right here is gonna run every five seconds now it just doesn't run right off the bat because we still didn't call it from anywhere yet or invoke it so we have to do that from our on ready command so in order to run this function as a task what we need to do is we need to call pull blockchain but instead of just running it just like this we actually need to call start on it so again anytime you want to run a periodic task then you can just make this decorator and then you can call the function name and then dot start and just to show you guys that this is working i'm going to say um we'll just say i'm gonna print out apples every five seconds and this is just purely to test that this is indeed running as a periodic task so in our console we should see ready apples if i could zoom in apples and let's just do it one more time even though i think we get the point right now apples there you go so we did indeed set up our function to run on a five second delay or five second interval so now let's go ahead and create this check deposits function so let's go ahead and delete this print apples i don't think we need that anymore and i'll uncomment check deposits and of course we don't have it created yet so we need to go ahead and do that so i'm going to make a function called check deposits and what is this going to do all right so what it's going to do is it's going to fetch bank transactions from uh we'll say from the bank and then we'll insert a new deposits into database all right beautiful beautiful beautiful so let's pop back open our why is chrome only open like half the time okay so we're gonna be using this endpoint uh bank transactions now let me just go ahead and copy this and all right so what we can actually do if i pop that open one more time is this so whenever we call this endpoint right here which is just our banks ip bank transactions what it returns is not only all of these results but it returns some metadata too and this says if you have a next page in other words if there are more results because this page it only sends back 50 results at a time so either way if you have more results that are not showing on this page or this result set then it's going to come back with a link to next right here now if we don't have any link to next then it's going to be null just like this this one doesn't have a previous page because we are on the very first page so either way i say this because whenever we are checking for new transactions then we can add a filter to say instead of all the bank transactions which are the transactions to and from everyone we want to filter this down where we are only looking at the bank transactions for our bot and also whenever we order these we want to start with the newest ones first so with that filter and we're going to be writing that in just a second what we can do is we can basically iterate through until next equals null that means we got to the end of the result set in that we don't have any more results to check all right so let me go ahead and well i can copy this right here it doesn't really matter so what i'm going to do is i am going to make a variable called next url and this is going to be the very first url that we query and again once we are done querying this first url then if it does have a next page for us to view right here then that is going to be stored in next url so even though it technically is the first url right now it makes more sense in just a bit so i'm going to make an f string and the first thing i want to do is replace some of these with my constants so we already stored the bank ip and did i import these nope so from config settings i'm going to import bank ip and what do we need bank protocol and also that ba account number okay man kind of annoying how it always bumps it back okay so bank ip first so i'm going to replace this section with the bank ip i'm going to replace this section with the bank protocol and then what we can do is this okay so the limit offset we don't need instead we are going to add a filter called recipient because remember if i pop this open again in these bank transactions they have a recipient key and this means the person who is receiving the coins so we don't care about this uh we don't care about this we only want to look at the transactions that are coming to our account so we're going to say a filter on this where recipient equals bot account number so only our transactions coming in and another thing that i want to do is there's an ordering um flag available and this says how do you want to order these transactions whenever you get them from the api and what we want to do is we want to order these by the blocks created date and when we do that we pretty much just say give us the most recent blocks aka the most recent transactions first now in order to do that with the nested field you do block two underscores and then you do create a date and just make sure that spell everything correctly block underscore underscore created date so this is essentially going to give us the result set from the api of all of our new transactions coming to the bot account and then what i'm going to do is i'm going to make a while loop and i'm going to say while you have a next url continue to fetch this data because whenever we get to the end like i said in that next url is going to be null then we just want to break out of our loop we say we fetch all the data that we have all right now in order to make this network request what i'm actually going to be doing is making another utils and i'm just going to call this network and that we can say import requests let me bump this up and all this is going to do by the way is it's going to use this request library to fetch an endpoint fetch some api data and then it's going to convert it back to python in other words a python dictionary and it just cleans up a little bit of you know the dirty work so i'm just gonna name it fetch and then just so i enforce named arguments we're just gonna say what url do you want to fetch from are there gonna be any headers i don't believe we're going to have any headers in this but i always like to include it and then we are just going to say send get pressed in all right so send a get request and return response is a python object and we'll just say the response is equal to the request dot get and it takes url and the headers equal the headers that we pass in so basically just taking whatever we call to fetch and just routing it to request.get to make sure it's a get request and after that we want to return this response but before we do we just want to go ahead and convert it to json and that's going to give us a python dict to work with all right so simple enough and now if i go ahead and say from utils dot network import fetch okay beautiful so now we got that fetch command now just to actually do this so let me say print next url okay so this isn't the actual logic that we're gonna have however what i do want to do is run this and i did kick off okay check the posits so i just want to print out the url because this is like the most laziest way to do it but um i just want to print out the url all right so let me stop that and i'm just going to copy this url and then we'll pop it back open okay so i just want to throw it in my browser so we can take a little bit better look at the response that's coming back so in this case since i only had five transactions ever sent to this bot account that's why we don't have a next page because these pages uh like i said they either return 50 results at a time i believe but either way uh let's just take a note of this response so it comes back with the count that says how many total deposits have been sent to this bot account is there a next page that you have to check no there isn't a previous page doesn't really matter for us because we're only parsing in one direction and then we get our results right here in these results are a list of bank transactions okay so now we can get to actually parsing out this data so let me scroll back up here and okay so the first thing i want to do is say for all of that data that came back even the metadata what i want to do is call fetch and the url is going to be equal to the next url in other words the very first time it's just going to be equal to this endpoint that we're looking at right here and that for the headers uh this isn't going to take any special headers but i did want to enforce the passing in of those but you can just pass in an empty object just like this so the next thing that i want to do is i want to take these results which remember is just a list of bank transactions and i just want to store it in a variable that is just a little bit more intuitive other than results so i'm just going to call those bank transactions and set this equal to the data which is all the data that we get back in other words this entire thing so it's going to be equal to data results so data results just like that now after this what i want to do is i want to update this next url so the url is important whenever we're fetching data but after we get the data what i would like to do is set it equal to the next url that needs queried now in this case we don't have any more pages to query so it's going to be null and that's going to be an indication for our bot to say hey we don't have any more data to fetch we can go ahead and break out of this loop now so how do we do that we can just say the next url that we have to fetch is equal to whatever the response is in the next key so this is either equal to like i said a url or no all right so at the end of this loop right here since this is going to be equal to null that's why this loop is going to only iterate once or in other words it's only going to iterate the number of pages that you have to parse so that's all this and now what we want to do is this so we took all those bank transactions and remember these bank transactions are now only for our bot account if you see the recipient 5982 or what is it 59842 all of these since we threw in that query param these are all for our i can't talk because i'm fleming my throat these are all for our ba accounts so what we want to do is we want to go through each of these all of the bank transactions and we want to insert them into our deposits collection which we actually don't even have yet let's go ahead and make that and remember that this is going to be the shape of it right here so let me actually go ahead and copy that and i'll paste it right here just so we have a reference okay and maybe i'll zoom out a little bit so you guys can see and actually let me know the text size on youtube if this is too small too big whatever but either way what we're going to be doing is we are going to say for bank transaction in bank transactions so iterate through all of our bank transactions one by one and remember we're going to start with the newest first so what we can do is we can essentially just try to insert those into our collections one at a time now since we are using the id which the bank gave us if we are going to try to insert the same one one that we already inserted then it's going to throw an issue because remember in this id it has to be unique so show you guys a cool little trick whenever we get one of these bank transactions right here we can either look at the idea of it and we can say does this id already exist in your deposits collection if so then just skip it if not then go ahead and insert it now think that through whenever you take that and you query the database and say does this exist or not that's one query now whenever it says no it doesn't exist and you say okay insert it again that's another query that's two queries however what you can do is you can just go ahead and try to insert it and that's just going to take one query if everything's chill now if that doesn't work because that transaction already exists then the database is just going to send back an error anyways but either way it minimizes the amount of queries from two down to one now again there's probably a more efficient way to do this but uh i just want to talk you guys through the initial process so anyways what we are going to try to do is essentially uh insert one of these bank transactions now another thing that i want to do is this from pi errors there is an error called duplicate key error and this is what we're going to be expecting if we try to insert a bank transaction and it already exists in other words maybe we just inserted it like five seconds ago or whatever so in our case whenever we receive one of these duplicate key errors meaning hey these bank transactions you already parse these you already insert them into everything is good to go already what we can do is just break out of this loop so again this while loop is going to continue fetching api data it's going to continue pulling in bank transactions until one of two things happen one it runs out of pages to fetch which means we just parse the entire um bank database another thing is that whenever we get to a bank transaction that we already added it's gonna say bro you already added this we're just gonna break out of the loop now and the reason that this works is because we are ordering from newest to oldest now if we were iterating through the oldest ones first then we would have some issues but we're not so that's why this entire system is going to work okay so now instead of here we actually need to insert those deposits so we're going to say for each bank transaction we're going to in our deposits collection insert one and then how do we need to insert it well it depends on this info right here so the id of this is going to be equal to the bank transaction in this id if you guys can see it doesn't have an underscore so that's what i'm doing right there and i can probably copy this and now i won't be that lazy okay so after id what do we need we need the amount so the amount on a bank transaction how do we get that okay it just looks like the amount beautiful this is almost too easy and all right what do we need to add after this the block id so the block id this is going to be equal to the bank transaction and how do we get the block id so you need to look at the block dictionary and then the id from that so that you do block and then for the block you get the id all right now after this what do we need confirmation checks so confirmation checks we don't get this from the bank transaction api data we are just going to set this equal to zero at first because remember what we're doing right now is we're just taking these bank transactions and pretty much just cloning those over to we didn't check for any confirmations yet we are not doing anything fancy so we're just gonna set confirmation checks at zero is confirmed this is the easy one by default is it confirmed well i'm guessing if we never even checked for confirmations yet we probably cannot confirm that payment so we're gonna be setting that to false by default and for this memo so the memo we're gonna store is just whatever memo they had on that bank transaction and that is going to be called memo i don't know why i copied that but uh there you go let me just copy this all right so it's just equal to the memo field and last but not least what do we have okay so the last bit of information that we need to store is the sender so we'll say that the sender and how do we get the sender so in the center we gotta query the block again and there's a key or an attribute in this block called sender so we had similar structure up here but instead of the blocks id we're going to get the block sender there we go and believe it or not this deposit logic should be complete did we fetch bank transactions from the bank yup it looked like it did we insert new deposits into the database well it looks like that but let's just go ahead and test that now so what actually we can add for now uh okay let's just print out something like a polling blockchain even though you may not want to do this if you are releasing this production because it just might clutter up your logs or whenever you try to debug stuff however just for testing let's go ahead and run this okay so ready polling blockchain and that's good now let's pop over in and see what we got going on gonna refresh this and check this out okay so it looks like we now got some deposits in there and yeah it's looking pretty good displaying documents one of five so what it did is it essentially queried this endpoint which was good that's the one we were hoping it to query and it took all those and it converted them to deposits and it stored it in our deposits collection so right now even if i refresh the confirmation checks remain at zero and is confirmed is false because even though it's aware of these incoming payments since we don't have the confirmation logic bill in it can never confirm or process any of the users payments so that is uh not good but everything else seems to be working so in the next tutorial what we can do is we can work on that deposit confirmation logic i'm pumped up so i'll see you guys then