all right so check it out I know that I said in the last video what we're going to be doing next is working on this timer right here however in kind of thinking things through I saw some issues that we're going to run across and the first one was this so inner code what the original plan was to go ahead and log the request date and then whenever we get that response back to go ahead and log the response State and then once we calculate the difference between those it would essentially give us our speed right here however the issue with that is that by default these dates they only are accurate enough down to the second so again here's the date and here's the time hour minute second and that's not gonna offer enough accuracy for our use case so instead of using uh just this what we're going to be using is instead um we'll use the git time function from JavaScript and that's going to allow us to tap into milliseconds so on that note what we'll do is actually keep this request State even though we may have two sources of truth I like it because we'll keep the date logged out for this column right here however in addition to that we will also get the request time and again this is going to be a number which is going to be in milliseconds and then we are also going to change this response date to response time and this is going to be equal to a number or no and let me just see where response date okay so now I think I only need to change it here where we say response time equals null and also whenever we're setting runs this request time is now a required field it's a request time and we're just going to set this equal to the current date and instead of this which is going to give us the actual date we'll call get time on it I'll show you what this is give you the proper definition get time Returns the number of milliseconds since Unix I don't even know how to say the word not going to embarrass myself but uh point is it's going to give us that millisecond accuracy and all right so this is looking good let me just check one more time to make sure that uh response okay and another thing that I think that I want to do yeah I'm gonna add a one more run status here and that is just for air because what I'll say is this so whenever we first fire off this request it's of course going to be pending we know what success is whenever we get a valid pong message back timeout will have that if the request is taking longer than 10 seconds then we're going to go ahead and time it out however this area right here is if we send the request and there's an issue with the core server in other words we can't even communicate with that device at all then we're just going to set it equal to error so I want to differentiate like a server error from a device timeout and in addition to both of those things another thing that I want to do is right now actually let me pop open this component all right so our main button is enabled as long as we have a valid connection but that logic isn't quite good enough because what I want to do is to say not only um disable this if you are not connected but also whenever we have a pending request and we haven't received the response yet then I also want to disable this because I want to keep it nice and simple where I don't want like multiple requests pending at a time just because I like I wouldn't even know what to do with the timer so anyways I'm going to create a custom hook and we'll pick off to see if there's a pending run and if so then we'll also disable this button so under my hooks I'll call this use pending run all right now let me import everything all right subconscious use pending run and what this is going to do if I can type is it's going to return either a run or I'll say return undefined if you can't find any all right in actually let me go ahead and just to make sure I don't forget to export it all right and how are we going to write this well first thing I'm going to do is we need to get the runs and in order to that pull the runs from Redux or at that get run selector and now from here kind of just like it's user connected uh okay I don't copy that not that lazy so return use memo all right so how do we do this so to okay what I'm going to do is I'm first gonna order these and I will order them by this request time and then I'll find the latest one that's pending and this is just so if there's like multiple runs pending um which should never happen but we'll count for all this logic as well so const ordered runs I'm going to call order by and since I just want the Run objects and not the keys I'll say object values runs and for this order by what field do I want to sort by the request time let me think about this so since this is the number of milliseconds since the Unix State we want to order it descending from highest to lowest I think that makes sense all right for some reason whenever I'm have to like order dates I always get it wrong I don't know why it's uh it's kind of weird dates just don't mesh in my head very well all right so once we have those ordered runs what we're going to do is we are going to find a run that has the status of run status pending so find the run where the status equals run status pending and now this should be runs some semicolons in all right so again all this is doing is it's finding the most recent pending run and if I don't have any pending runs then it's just going to return undefined and now what I can do is back in my component I use is connected and also use pending run all right now actually I want to use this in a couple locations so I'm going to split out this enabled logic into a separate function because I'm going to use it in two places one to pass into this styled component to know if it should disable that button to make it appear gray or not and I also want to stick it right here because if the button is not enabled then I just want to make sure that this click Handler doesn't follow through so with that being said let me go ahead and make uh new memoized function I'll say use memo this is use memos and react right so all right so use memo is going to be the function it's going to return a Boolean if there's anything else oh this is good for now so I'll say the button is enabled if you are first of all connected and also there is no pending run and now for these dependencies should be both of those and all right so now what I can do is I can swap out this is connected for a more proper enabled and also right here as well now make sure nothing broke and for some reason whenever we create new hooks or update a hook yeah actually have to close this and restart the entire thing right I can't test this out because I actually have my MacBook closed but I really just want to make sure nothing is breaking for a second and it looks alright now another kind of housekeeping item that I'm going to do is I'm gonna restructure this click Handler right here because what I want to do is actually yeah let me go ahead and pull out this run because I want to throw this request in a try catch statement and if the server throws back an error then I want to update this run status to be this new error status let me do that right now how am I going to do this so I'll say cons to run set this equal to this and for the Run ID can probably just do this all right so first and foremost this is going to dispatch this run and I also want to wrap this in a try catch so try all right so try to dispatch this run to our Redux store and then after that go ahead and send a request to send this block in as the params since we got rid of that variable we'll say the Run ID is equal to the Runs run ID now hopefully nothing breaks but just in case if it does we're going to say console error just uh log out the error in the console and aside from that what I want to do is I wanna pretty much do this so if we do get an error then we're just going to update the uh the status of this run in Redux so spread out the Run since everything's the same the only thing that we need to update is a status and it'll set equal to run status.air just like this and I actually think that let me think this through for a second yeah I also think I need a state variable to set even before this because I believe that this entire function is going to be called before this I'll show you what I'm talking about no one just sit here listen to me uh mumbling so I'm also going to create a new variable to say request pending and I'll say set pending and this is going to be equal to a Boolean which is going to be false by default all right why am I getting error here oh you stay I use pending run embarrassing so let me go ahead and write this and then I'll explain why I wrote it so as soon as we fall into this try block then I want to set request pending equal Troop and then I'm gonna set that equal to false right after this catch statement actually kind of like a finally so false right here and now with this it this variable request pending should be true as soon as well even before the request is actually pending uh before we even dispatch anything to the Redux store and then it'll toggle off at the end of all this but I'll say that this is enabled if you're connected if there's no pending run and also if you don't have any requests pending and then I just need to update these and all right now the reason that I said that I wanted that is because whenever this function is called this handle click function again we have functionality to disable the button if there's a request pending however for this pending a run it's gonna check the Redux store now that's all in well however I don't believe that check or that rerender can take place until this function itself is done executing so that's why I want to set it right here just to be 100 certain that there isn't going to be any race conditions and for example if if uh the user I have to restart it again but anyways just to make sure that if the user is like clicking this button 100 times like as fast as they can then it isn't going to fire off multiple requests this should do the trick tonight let me actually go ahead and quit and restart and just to make sure that everything is good up until this point all right I got my MacBook open too so what we can do is actually like try to break this in a way let me go ahead and open this MacBook this is interesting so this is disabled and I have a feeling I know why I don't think it is any of the code that we wrote there's probably a pending run all right I'm not gonna I'm not going to scroll through all these but I have a feeling that there is a pending run in here from last time So eventually what I want to do is like have a little button down here that says clear history but for the time being a little trick and I don't even know if I would call it a trick as much as like bad practice maybe but in this store initializer actually it's not even bad practice um instead of uh pulling in the initial runs using the electron store what we can do is just temporarily set this to an empty dict and then whenever I boot this app up again it's basically just going to reset all of my runs so all right the app is booted and I'll show you what I'm talking about all those runs that were in there from last time if I check my speed test runs now you see it just set it to an empty decked so now let me go ahead and quit this yet again must be an easier way than this I know but uh now when I go ahead and restart this shouldn't have any pending or runs in there and then we can do a little mini QA mini QA sesh all right so minimize you console get it all nice and Purdy all right much better so let me go ahead and just look at my network inspector to make sure I can't fire off too many requests so first just clicking it at our normal speed I know all right I forgot this too so what happens because we didn't I'll show you what's going on here so in our listener our pong listener what it's supposed to do whenever we get that pong response back is it's going to say I'm gonna update this run where it's no longer pending but it's success now however since since we didn't write that yet either I'll show you new Redux we are stuck with this one pending run right here with no response time and again like I said it's still pending but point is that everything looked properly up until that point but uh yeah got some work to do from here now to save some time let me actually just go ahead and update this pong listener right now so let me pause the video and uh I'll see you in just a second all right so check it out I got the pong listener written and just to make sure we don't skip over any logic I'll go ahead and talk through this right now so what I'm doing in the pong listener is kind of just doing the same validation as before but after I checked that the uuid or the Run ID should I say is a valid uuid then I'm gonna look for that run in Redux and then once I find that run I'm first well this is just making sure that it exists and after that I'm validating the network ID actually I'm going here so when validating the network ID I want to ensure that the block ID or in other words the network that this response was sent over was the same one that matched my run since for example I don't want to be ascending the Ping request over the New Boston Network in having it respond through the vitaxia network because well it's kind of the point of the speed test to test how fast the single network is another thing that I'm validating is this run recipient right here and this I have no idea when this could possibly happen but I figured it might as well have it that the block sender matches the Run recipient in other words I don't want to send a block to like my MacBook and have my Linux desktop send it back again I have no idea when on earth that could possibly happen but I just want to make sure whenever we validate this data that everything's covered and then another thing that I'm doing is I'm validating the Run status to make sure that whenever we receive a response back then the run that we're trying to update is still pending and I do that because if I already timed out the run or if the run is already successful for some reason then we don't want to like update it again so anyways once this is all valid and we ensure that yes it's a pending run I just sent you that request and I'm expecting this response back then what we're going to do is we're going to set the response time to whatever the current time is and then we'll use this response time in just a sec for both the timer and also the history table and then this just sets it equal to success and also with this I'll show you let me clear out my blocks so I'm going to be clicking this a bunch and you see that that disabled state is working correctly right now where the containers main button this and that is because as soon as I click that button it is going to set this request pending State variable to true and that is going to alter this enabled State and of course this enabled state doesn't allow me to click it again and it also toggles on that disabled styling for the button so yeah everything is looking pretty good so far and actually let me just show you what's going on in Redux with one of these so whenever I kick this off it's going to send a requests we're going to get that pong response back which is going to update this run and then whenever this run is updated again it's going to set the response time and update it to success in Redux so now pretty much Redux is populated with all the correct data the only thing that we need to do now is update the UI and that should be a piece of cake at least compared to all the logic that we wrote already so smooth sailing from here on out see you guys next video