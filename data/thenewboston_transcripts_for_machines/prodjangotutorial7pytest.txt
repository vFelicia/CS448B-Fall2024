all right everybody welcome back and in this video we are going to be talking about Pi test now in the future videos we're actually going to be setting up a CI CD pipeline however before we do that I did want to cover Pi test because whenever we set that up what we want to do is we want to make sure we have a proper test Suite to make sure everything is working before we deploy our application so that's why I decided to make this uh pipe test tutorial now now with that said to get started we're going to need to install some packages and we are going to install of course Pi test itself Pi Test X dist and what this package does is it allows us to um test across multiple cores pretty much just speeds up testing for better performance this Pi test Django package right here this just gives us some useful tools for testing Django apps which we're going to see in a bit and then this last one is actually one on two lines here but model Bakery this last one is for creating realistic Django model instances for testing purposes so let me go ahead and install all of those and that was quick and okay now before we get into typing any real tests or anything what we need to do is just configure this Pi test tool so what we are going to do is go into pipeproject.tomo and you see just like before how we configured some different tools like isort Yap F in let me just paste this in I'm glad uh you guys said that you like this paste method rather than me typing everything out because hey I like it too all right so this is what I just pasted in and what are these configuration settings well some of these are pretty selfexplanatory for example for the test paths all of our tests are going to be in cooking core and for the python files that we want to test we're just going to prepend everything the module names with test underscore just to kind of signify which one of our files um yeah need to be tested now this one right here you may want to include this however whenever I run Pi test in addition to like telling me the output of the test like what one's passed what one's failed it also gives me some deprecation warnings and like it it isn't an air or a bug with app it's just like a warning that some of your packages are deprecated or some methods or functions in there it's just kind of annoying so I decided to hide it kind of just like clutters up my console so you can have it if you want but I decided to hide it and then last but not least we have these two right here so by default Pi test Django one of those packages that we just installed it uses the directory containing this manage.py script as the jingle project directory however because we have our settings set up a little bit weird what we want to do is we pretty much want to say hey don't worry about like automatically finding anything we want to explicitly give you a path to the Django settings module so use these two in conjunction even if it's working like it automatically finds the right directory I still like explicitly giving it that path just because I don't know it just feels kind of weird that process is like happening behind the scenes and you don't really see what's going on but anyways this is kind of the configuration for pi test now the next thing that we need to do from here before we start writing any tests is we actually need to create something called fixtures now let me actually go ahead and create one of these and then I'll kind of explain what it is so what I'm going to do is in my accounts app I'm going to go ahead and make a new package called Tess now for all of the tests that we write that's or this is where they are going to live right here however what we are going to do to kind of prepare those tests is we are going to create a new package called fixtures now in here let me go ahead and actually give you some sample data in here I'm just going to create a new python file accounts and I'll paste this in and then talk you through what exactly fixtures are kind of what all this is so in pi test a fixture in each of these right here are fixtures so a fixture is a function that returns some I want to say like a reusable bit of code that can be used in your tests now each of these fixture functions you can see that it's signified by this pytest.fixture decorator now in order to use fixtures in your test what you do is you pretty much just include the function name or the fixture name as a argument or parameter right into your function right here so you can see that what this fixture is doing right here is it's pretty much just making a sample account and this account has this account number and it just has a default balance right here and that's it so whenever we want to use this fixture later on in one of our tests we're pretty much just going to pass in sender account pretty much like this uh sender account number is being passed in and here you can actually see uh something cool that's going on within this fixture it's actually made up of this picture as well so whenever you have an account you of course need an account number and that account number is coming from this fixture and how do you get the account number well you need to make a key pair and a key pair consists of a private key which is kind of like your secret password almost and a public key and so this is kind of the chain right here but it's kind of cool to display so this fixture is being used again Center Key pair in this picture to get the sender account number and the center account number is being used in sender account in that this sender account is pretty much what we're going to use in all our tests so it's kind of a I don't want to say confusing at first but it's a cool way that you can just make a bunch of reusable Snippets of code to use across multiple tests rather than creating the same thing with the same exact data um you know across like 50 tests or whatever now another thing that I want to do just to make these Imports a little bit cleaner whenever we're working with these fixtures is in fixtures in it py I'm just going to import all of the stuff from this file right here now in addition to this fixture right here which is pretty much just a sample account that we're going to be using I also want to create one more fixture because in addition to just like having sample data um it doesn't always have to be data and I'll show you what I mean in just a sec so I'm going to go to General and I'm gonna make again a new test package and in here I'm going to create a new fixtures package I can close out of these actually now in this one what I want to do is I want to make a new python file called clients and I'm going to paste this fixture in right here so what this fixture is is an API client and this is just a class that we can use it's included in the rest framework package just so we can test our rest endpoints test our API so again like I said it doesn't always have to be sample data but it can be like a reusable class or well really any reusable snippet that you want to use across your test and just like before in this in it file I'm gonna just include everything from this file right here and then once I have my fixtures taken care of what I'm going to do now is go ahead and create a new file right in the um cooking core package and I'm going to name this conf ESS and make sure that you name this exactly like this is it stands for configure test or it's a it's basically a configuration file used by pi test and what we can do in here is pi test is pretty much going to pick this up before it starts running the test so it's the perfect place to pretty much um aggregate all your filters or anything that's going to be used across multiple tests and by the way this file like I said it's um like the default for pi test it's automatically discovered by pi test as long as you name it conf test then you don't have to like manually configure it anything else so now that we set this up this way whenever we write our test we can pretty much just use these fixtures pass them into the functions and yeah it's good to go so now let's go ahead and actually write a test so under accounts in test I'm going to make a new test file and remember anytime you write a test file we need to prepend it with the name test underscore anything that we want I'll just name this test rest API since I'm going to be testing some of my endpoints and for this again what I want to do is I want to have my function name test underscore retrieve account as well and you see that the parameters that we're passing in is sender account and yes it does have to be named this because this as you can see was the name of this fixture right here so basically what this reflects is this like dummy account that we just made and what this API client is is if I go back in general then you can see that this is resembling this right here which is just a tool like I said from rest framework that allows us to make requests to our API just like this so whenever we use our client to make a request to this endpoint which is the accounts endpoint for the sender's account what we're expecting to get back is first of all a status code of 200 that endpoint should be working and then another thing is that this is the shape of the Json and their account number should match their account number the balance should match their balance which is twenty thousand and then since we didn't have any display imager display name set then those should just be equal to blank so now everything is all pretty much set up so we can actually run our test so how do we run our test well what we could do is we can just go ahead and write a command to start running those however since we are going to be running our test multiple times of course what we want to do is head over to our make file and let's see here St always have to sing the ABC song in my head to figure out the alphabetical order but anyways uh what I just pasted in is this and we are going to be able to run it by just writing make test and it's going to run this Command right here so of course the command to run your test is pi test and what these flags mean we'll kind of break them down one by one so this uh V this just stands for verbose and again this is just a common it's actually a flag used in a lot of different commands just means like more output just so we can kind of see what's going on this RS right here this actually stands for two separate things this R uh stands for report and that is um kind of the it changes the summary report at the end that okay let me take a step back so at the end of your test Pi test is going to show you a summary of like all the tests like this one passed this one failed yada yada now that's what the report is this s means skipped and it can be used along with this R flag right here so when it's used together like this what we're pretty much saying the pi test is show me a summary of all the skip tests at the end now this n Auto what this means is let me pull open my uh Pi Project Tamil so you know how we installed these packages at the very beginning and one of the packages was this Pi Test X dist and I said that it allows you to um pretty much run these tests across multiple cores it doesn't really make sense since we only have um one test right now however later on I mean in a large project you're going to have like a hundred or thousands of tests and that's when it's really useful to speed up your test Suite by splitting them up to run across uh multiple different cores in parallel but for right now with this n Auto is is it's pretty much the option from that plugin to say um run these across as as many chords as we have again it doesn't really make sense right now but it will in the future so might as well include it now now this last one show capture equals no so by default if your test produces any output like print statements or logging or anything like that then what's going to happen is pi test is going to capture that output and show it in the event that that test fails now here we're saying not to show that output and it's useful in the case that your test produces like a ton of output and that output isn't very relevant to understanding why your test is failing so again this is optional I don't know if it's beneficial to you or if it's like detrimental but anyways this is what this is you can you guys can include in your projects or not but this is how I have my test set up by default and by the way if you find yourself like testing using make test which we can actually do right now just run make test yes see it's uh preparing all of my workers figuring out how many cores I have and then just running uh one test which pass by the way which is pretty cool but either way what I wanted to say is that if you find yourself like running the test in this kind of way and you like this setup however you go back and you're like okay let me tweak this and oh something was failing so let me like change one of these what you can actually do is just like make a couple commands say make tests and you know you can call this one like test detailed or something like that and that way you don't have to like explicitly change these and um of course you would want to tag this but either way it's kind of uh getting ahead of myself just saying that um if you find yourself like editing this often just go ahead and make another uh make Command all right so we got Pi test set up everything is looking pretty good however what we want to do to kind of prepare for some more intricate tests in the future and also just kind of good practice is whenever we run our test Suite we want to create our own custom settings file right here and this is just going to ensure that we have a consistent environment with all the consistent settings every single time that we run our test Suite so in order to do that what I want to do is if I go in cooking core and projects and settings and templates again this was my template for my Dev settings I'm also going to create a new one right here and this is a python file and I'm just gonna pretty much follow the same naming convention settings but instead of Dev I'm just going to write unit test make sure I spell the right unit test.py and in here I'm just going to paste in this so this looks pretty similar to our Dev settings right here however you see one difference is the secret key which I'll explain what we're going to do about that in a second but either way we are going to be populating this with some more stuff later on but the point is what we want to do is whenever we run Pi test we want to make sure that it picks up this file and that way whenever we're running it like I said it just gives a consistent environment to run each time so with that said what I'm going to do since this file is right now in uh well you can see right here cooking core project settings templates this we want to get this file over to our local directory and not only do we want to do it now which we can do with this command pretty much copy this file from wherever it is now to our local directory right here so let me just run this and when I do you can see that is now in local but I also want pretty much any developer working on this project to do that same thing whenever they're like just um you know getting their environment started so in that case I'm just going to add it to the readme right here so as part of the project setup not only do we want you to copy those local development settings which is just whenever you're developing also these unit test settings over here as well so now that we have those settings copied over what we pretty much want to say to Pi test or to our Django application is that whenever you are running in pi test mode then we want to pick up these settings so in order to do that we first need a function to detect if we are running in pi test mode so for this I'm going to go in cooking core in general and I'll put it in utils I'm going to create a new file called Pi test and in here I'm going to paste this right here expand this so you guys can see so this is a function that we're going to use and what this does is it pretty much says that if we have an environment variable set explicitly that says Pi test running and of course the value for this is going to be true or if the pretty much we're running a command in the first argument is one of these then that means that we are running this application in pi test mode or Pi test whatever you want to call it now because we have this logic right here what we actually need to do is we need to create an environment variable called Pi test running and set it equal to true and where do we do that well we do it in this file right here because remember this is our PI test configuration file it pretty much gets loaded in right before Pi test starts running the actual test so I'm just gonna import OS and this is going to set a temporary environment variable um pretty much through the duration of Pi Test's Pi tests execution so we're going to set this this function is going to be equal to true but the last thing that we need to do now is we need to use this function to say whenever this is true update our local settings path so it uses this instead of development or production or anything else and where do we do that well if you go to cooking core projects are in it settings right here then what we can do is first of all import that function and again that was in cooking core General utils Pi test and instead of this local settings pass what we can do is we can just update this logic right here where we can say that if Pi test running equals true then what we want to do is we want to use this unit test setting right here instead of Dev now of course whenever we are just in local development mode then this is not going to be true so then it's just going to pick up our Dev settings as usual now one other thing actually a couple other things that I want to do is I want to add this snippet right here now again this says if not if Pi test is not running then make sure the secret key is not implemented and there's a lot of like uh double negative statements in here but what this means in kind of layman's term is that unless Pi test is running there should be a secret key set because of course in normal mode whether it's um production or local development of course in Django you need the secret key for a lot of different things however check this out why is it that in pi test we kind of want to make sure that it's not implemented at this point right here because even in pi tests I'm sure we need Django secret key so like a lot of things don't break well the reason that in pi test we want to make sure that a secret key hasn't already been set and by the way the reason that I want to do this one of them is because if I am in pi test mode and just run out a bunch of tests and a secret key is set at this point that means that like I messed something up I'm either running in my development settings or God forbid I'm running my production settings and whenever you are running in production mode you definitely don't want to be running a bunch of automated tests and just like hitting your production database so on and so forth so this gives you some protection against that however because we still need a secret key um even in testing our PI test environment how do we handle this we'll check this out what I'm gonna do is I'm going to create one more fixture file and this is actually what we have uh two more things to do before we're done with this tutorial we are going to go to General test and remember where this fixture was right here this client right actually let me close this uh let me close all these all right so right alongside this we are going to create one more fixture file and we're just going to name it uh miscellaneous and in here I am going to paste this fixture right here so what is this doing well this fixture is it's kind of special in a way that it's used differently than the other fixtures and that is because we are using whenever we Define this fixture in this decorator right here we are using this Auto use equals true parameter now what this means is that this fixture is automatically going to be picked up every single test run without needing to explicitly include it as a parameter in those other functions so again this is always going to be used um across all tests so what exactly is this doing well what we are doing right here is we are using this builtin override settings context and this is a part of Django's test Suite and we are pretty much saying that within this context what we want to do is we want to provide an explicit secret key and this is just a way that you can pretty much within your testing you can have like standard uh Django settings applied to every single test and again this is useful to ensure that we have a consistent environment across all of our tests without having to modify our actual settings file or use any like settings keys from development or production or anything like that so that's what this context is in this yield keyword right here this keyword marks the point where Pi test is actually going to be running the test so if you can imagine that these tests let me just actually kind of show you what's going on so if you can kind of imagine that this yield keyword is going to be replaced with this test right here it's pretty much saying with these temporary settings apply it whenever you run the test however just the pi test syntax you use yield kind of in place of where your tests are going to be ran so actually the last thing that we need to do to pick up these settings is just make sure that everything from this file right here is just imported in our fixtures.init and we don't need to do anything else because in our test configuration we are already pulling everything in from this file which is General test fixtures and again we already did this before so now in all of our tests even though it didn't really matter for that one test but in all of our tests and we can run this again just to make sure nothing breaks we now have our consistent unique um like temporary secret key set and later on just kind of a heads up we're actually going to be adding more settings in here but yeah for now this is the basic structure of how you can set up Pi test and uh a lot to it but the cool thing is from here on out we pretty much just have to add more tests and everything else is going to be configured more or less So yeah thank you for watching and um in the upcoming videos what we'll do is now that we have some tests that we can kind of make sure that our application is working as expected I think we're ready to move on to some of the CI CD so looking forward to that and I'll see you next time