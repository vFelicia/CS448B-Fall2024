in this video let's go ahead and start implementing the first rest endpoint and let's start with the one that gives us the list of all the banks now there are two general ways that we can approach this we can either go top down so starting at the rest end point and then basically working our way down through all the layers until we have all the functionality that we need in order to return the list of banks now on the other hand we can also do it bottom up so here we would first think about the kind of data that we need and then build our way up all the way to the rest api so to the controller level for this first standpoint let's go bottom up because this will first of all allow more selfcontained videos going each step and also it allows us to do better unit testing of each single step so at each layer basically or for each video for each step you can have the unit test for that specific level which is a bit harder to do if you go top down so let's go ahead into our source main kotlin folder and in here let's create a new package and we're going to call this one model so as you might know the term model which comes from the model view controller architecture pattern it simply refers to the data representations of your application and since we're going bottom up now in this video we're just going to create the data layer for application so we're going to create the model and since we're talking about bank objects we need a class that represents our banks so inside this new package let's go ahead and create a new kotlin class or file and i'm simply going to call this one bank now this bank class here will basically be our data transfer object so a data transfer object is called data transfer object because it's the one that goes over the network so for instance if a user requests some data from your rest api you're going to respond with usually some json data or xml data and it's really just this bank class that's being serialized into a json representation and also the same way if someone makes a request and in the request body they provide a json or some json data for you to process now we're going to see this in action later on for now let's go ahead and create this bank class now inside this class we want some kind of data that represents the bank for this let's actually go ahead to the new boston website over here and then under get started let's look at the documentation and here on the bank api let's see what the bank's endpoint looks like in the real network of the digital currency and then we're going to use a simplified representation so here you can see this is what a bank object really looks like in the new boston digital currency for our simple example let's just use a account number a transaction fee and a trust so let's go ahead and represent this in our class now if you do already know some kotlin please bear with me here i want to show how you would traditionally go and create such a class and then i'm going to go and refactor that step by step until we reach really clean cuddling code that also shows you one of the super useful features of the cotton language and just shows you how concise it can be for now let's do it the same way you would basically do it in java so we're going to create these fields in the class so we have an account number which is a string we also said we want a trust this can be a double and then a transaction fee which is actually an int and then we're going to create a constructor down here so in kotlin you just say constructor and the constructor takes an account number of type string the trust of type double and a transaction fee and again if you already know kotlin bear with me here i know we're going to do this a lot simple later on so we have transaction fee and i'm going to reorder this in a second to be more consistent so let's just do it like this for now then it's all consistent now the next thing you would do in languages like java is you would have a getter and setter for each field so let's just do it for the account number for now so this would return a string let me at least write it a bit shorter in kotlin again using this notation over here and you would have a set account number which takes in an account number of course of type string and all it does is is it overwrites the account number now in order to be able to do this i'll actually have to make this a var so if you write val in kotlin that's like a final variable in java so instead i'll have to make this a var which allows me to reassign this variable later on now imagine the same getter and setter for trust and transaction fee and then also we have things like equals and hash code we can generate them and also we want a to string so we're going to generate that as well just like you would do in java all right so we have quite a lot of code even though i already removed the other get to send setters now let's go ahead and refactor this and move it to kotlin style now the first thing we can do actually independent of whether it's kotlin or java is i don't really want to set her i want these to be final so i'm going to pull this back again so you should always strive to have immutable classes where you cannot just overwrite any field at any point so once i create a bank object i want it to always contain the same account number trust and transaction fee and of course this would be the same in any programming language but now for this getter over here cotton actually has a specific syntax for that so below this class property here you can write get and also you can write set to create a setter now get should simply return the backing field so this backing field is the kind of hidden field that really powers this property over here so this is the one that stores the actual account number and you can only access this field in the getter or setter so if you were to add a setter here as well you get a value and typically you would just set the backing field to the value of course that's not possible here because i have a val so it doesn't have a setter it's a final variable and also we have a naming clash here so if i look at why it's showing these red lines you can see platform declaration clash the following declarations have the same jvm signature so you can see that this getter over here it will generate a java bytecode function which is also called getaccountnumber and we already have a getaccount number down here and this is why the two declarations will clash so instead of having this separate getter here in kotlin you would do it like this so so much for getters and status and kotlin now let's actually go ahead and refactor this and just for fun let's actually just use the recommendations from intellij so it's showing some gray squiggly lines here because the getter is redundant because just getting the value of the backing field is just the default implementation so you don't need to do this because by default if you have a val content will already generate the default getter for you the same if you have a var it's also going to generate the default setup for you only if you want to perform some custom logic then you can overwrite the get and set methods now next let's go ahead and see why it's showing the constructor in yellow and let's convert this to a primary constructor so in kotlin most of the time you use primary constructors and this means you define the constructor parameters up here right inside the class header instead of having secondary constructors you can still have more constructors by putting them here but oftentimes you just need one and then you can do it right inside the class header so now you can see it actually already refactored all the fields so if i go back for a second you can see it also moved all the fields so all this code it just moved into this other oops it just moved into a primary constructor all right so let me put this also on separate lines again now there's one thing we should change here i made these private initially because i wanted to show the way it's done in java with the private field and then the public getter but since in kotlin those two are basically both represented by this property we really want this account number trust and transaction fee to be public and by default in kotlin the classes and its properties are public so we don't really need to have the modifier here it's also going to tell you that it's redundant so what this means now if this account number here is public it just means that content exposes those default getters and setters publicly it doesn't mean that the backing field is in any way exposed to the outside so you still have information hiding it's really just the getters and setters that are not explicitly shown here but that still exists for this property all right so far so good so now we're left with a class that has three properties but we still have these equals hash code and to string implementations that are really quite dumb and that you just generate with your ide so what we can do in kotlin instead is we can declare a data class and a data class has quite a few useful and convenient features and some of them include that it automatically creates a standard implementation of equals of hashcode and of tostring so we don't need all of those we can just remove all of them and now we're left with a data class that really just represents what we initially wanted to do we just wanted to have a data transfer object or a data class that has three fields an account number a trust and a transaction fee so with this we have really perfectly expressed what we actually wanted and this is also the way you would do this normally in cotton so i really love this feature i love kotlin and this is just one of the reasons why if you want to learn more about cotton check out the links below for my youtube videos and also courses for now this is all we need now i should mention that in java 14 they introduced a feature called records and in java 14 it's a preview feature i believe but then in java 15 it's just a regular feature and records are basically the same thing so java is also catching up and really improving some of those boilerplate that have been necessary before so yeah but that's basically the end result of this video so just five lines of code i'm hope you're not disappointed because of this rather the opposite because we were able to remove around 40 lines of code and just really reducing it to what's necessary also we don't really need any tests in this video because we don't really want to test the programming language that we're using so there's no point in testing if the data class works as it should so it's always the question what are you trying to test we could test that we really have these three properties but i'm not convinced that this is really a useful test if you have a different opinion let me know in the comments below but for now we're gonna move on we have our data layer ready so let's move on up the chain until we reach the rest endpoint just to quickly recap in this video you already learned a few essential features of kotlin such as val versus var where val is basically a final variable or property you also learned about class properties which are kind of like fields together with their getter and if they're mutable they're setter and then you learned a bit about primary constructors and secondary constructors where typically you will only need primary constructors and obviously you learned about data classes which give you things like hashcode equals to string for free they also give you a copy method and a few other things so they're super useful especially for dtos data layers and are a really essential feature you would use every day now on top of that you also learned a little bit about topdown versus bottomup structuring of your code so i hope this was useful to you and i'll see you again in the next one