in this video let's move right on to the next get 10 point which is the one to retrieve a single bank so once we're done when we make this request in postman here to api slash bank slash sum account number we want to retrieve or we expect to get that bank back from our api so let's go ahead and do this of course we're going to start off at the test and i don't want to bore you with going bottom up for all of these end points you've seen it now once with test driven development how you build the system up how you test each layer using unit tests but for this one now for the following videos i would just create the controllers integration tests but feel free to keep also writing the unit tests just for practicing kotlin as well as junit 5. it's a really good practice now what i'm going to do here is i'm going to create another test case saying should return the bank with the given account number let's say and then let's say given the account number one two three four when our what can we see request performs a get to our api slash banks oops slash account number and we'll again do a print and so with my live template automatically jumps to the next one but i'm gonna combine these two into a when then block again here and also i want to expect that i get a status code of 200 so it should be okay and i'm going to keep it at just this simple test case for now again still doing test driven development even though i will only be writing the integration test from now on and now i actually started the application because that's the last thing i ran but i want to run the test class all right obviously this will fail so let's go to our bank controller and here we'll need another get mapping and i'm going to call this method just bank and now there's actually something new coming in because this one has a parameter which is the a count number and that test case takes really long for the first time but it's it's faster afterwards so we have the fading test um let's see what happens and of course we get a 404 because there's no such end point and so this account number is a string but in fact what we want to have is this should be a path variable which tells spring that it should get this variable or the value for it from the request path and so a path variable is a variable that's inside here now what we want to do is based on our base path of api banks this get mapping is actually on a id sub path and in fact i have to call this one account number because it has to match the name of the parameter here and this way spring boot now knows that it's a get mapping on api slash bank slash sum account number so this way we have it available in our function body and of course we just want to call the service dot get bank and pass on the account number and as you might notice i'm going a bit too far already so for this test case we have right now we can also let's say just return you want data about the account number and this way we can even test that it's parsing the account number as it should and then we run the tests yep indeed that's enough and we can also check here we have a response body of you want data about one two three four so perfect springboot is looking at the account number and giving it to us in our method so now let's be a bit more comprehensive here in the test so we want to expect that our content type again is application json and in fact i should move this into one block here using this kotlin dsl so i want to expect all of these and don't need this bracket so expect all of these and then again i'm using json path and in here now we only have a single object so we don't need any error access here instead we just use the root object again and on this one we can check for instance that the trust should have a value of let's see in the mock data source a trust of 3.14 and a transaction fee of 17. so let's go ahead and say the trust should be 3.14 and also the transaction fee should have a value of 17 and then i'll run this test again which will now obviously fail so in the bank controller let's just move on so here we're going to call our service and we get we want to get the bank with the given account number now right now we don't have this method yet so let's create this member function and it's going to take an account number of type string and it should return a bank so this one should also be on the bank controller then it could have already inferred this type and so then in here we're gonna again just delegate to our data source and retrieve the bank with this account number now later on there might be more logic in this service but for now we're just going to delegate to our data source and again create this member function which also takes the account number and returns a bank and that's all i want for this interface so now let's go into our implementation that's not the implementation i wanted to go through go to this one's implementation so mock data source and in here we can now implement the remaining interface methods that we do not yet have implemented so retrieve bank and in here we want to say return from the banks the first one which matches the following query its account number should be equal to the given account number and let's see what happens if it cannot find this one it would throw a no such element exception and this is just fine that's actually quite nice that's probably what i would have thrown otherwise let me also refactor this convert it to an expression body and then for now that's good we're going to take a look at what to do if we have this no such element exception later on and how we can map it to the correct status code for now we have all the layers so let's see what happens if we run our test again and it's already working just fine so let's see in our response we indeed get our bank object so that's looking really good but we're only testing the happy path right now and that's not really a good practice i also want to test what happens if i give it a nonexisting account number and now to do this i actually want to restructure this a little bit because it can become quite confusing if you have lots of tests and they're all just on the same level here and that's why in junit 5 there's something called a nested class so here again i have a live template for this that i'm going to show you in a second but basically you have this nested annotation which tells junit to look at all the test cases in this class i'm also going to use this test instance per class which means that junit is not supposed to create a new instance of this class for every test case that it runs and what's also really nice is this display name so this one here i'm just going to call getbanks because what i want to do with this nested class is i want to encapsulate all the tests for this endpoint of this method and i'm just going to call this class get banks as well and in here i'm going to move this test case that's the only one we have for this endpoint and then it's nicely nested in its own little scope let me just do the same for this one down here before i show you what exactly happens and what the live template looks like so i'm going to call this one get bank with a singular of course introduce this import that makes it a bit easier apparently it cannot show the context actions while it's still it still wants me to add something here so let's get this done and then let's import this one and i'm going to move the test case in our nested class and then this one also has its own nice little scope all right so with that done let's run the tests again and let's see what happens and we see that we see nothing if this happens so what we expect is that the display name getbanks would be shown here instead of this more cryptic qualified class name however what you have to do to make this work in intellij is go to the settings and then in gradle or under the build execution and deployment you have to run the tests using intellij idea and i think even you have to also build the project using intellij you can try without but for now to be sure i'm going to do it like this and then if i run them again it should work unfortunately at the moment if you run your test using gradle it basically doesn't expose this information to the ide so for some reason it's still running the tests with gradle you can see it even says open the gradle test report so i think what i have to do is just restart the ide and maybe even invalidate the caches you might face the same problem so i'm going to show it here so restart and it will tell you can also invalidate the caches and restart or just restart to make sure let's try invalidate and restart and then let's see if we can get it to work so if you chose invalidate of course it's going to take some time now to index everything again and rebuild the cache but hopefully that will get it to work it's a bit unfortunate that there are sometimes a few hoops we have to jump through but it's just a tooling issue and also i think even if you don't care about the display name the nested classes are just a separate feature so you can also use them obviously without a display name and they still give you a nice scope for your tests you can also use them for defining the test prerequisites so here i'm using them each for a different endpoint or a different method here but what you can also do if you have different for instance state based tests is you can have nested classes that build up your test prerequisites so something like given a valid request and then given invalid request and so on um this way you really know where you're currently at when you're looking at a test case because you can just look at the classes that it's nested into another advantage of this kind of nesting is if you look at the outline view in your ide it gives you this really nice way to browse through your test cases and see what's already being tested get an overview which can be otherwise really hard if you have a long test class which can happen quite easily so so much for why the nested classes are really nice feature i think um if you want to do the same in terms of live templates again just go to your live templates and then under cotton you can add a new one and this nested one looks like this over here um so yeah basically you saw it you have these kind of placeholders for the display name the class name and then the body and this one should be applicable in a class realm because you're creating inner class um an object declaration maybe and then also other so really well you don't want it in comments but just make sure it's class that's the the one where you're actually going to use it in you can probably skip the other two but it doesn't really hurt either all right so now without further ado let's just hope that it works now um running with uh and also building with intellij all right finally yeah so sometimes you have to restart intellij or even invalidate the caches but now it's running the tests uh not using gradle and you can see the display names here of course you can also have spaces in between just like with the test names and actually i just noticed i haven't really talked about this yet but in kotlin you can use backticks in your method names and then have these kinds of names with spaces for instance obviously this is really nice for test cases but please don't use this in your production code it's not a good function name in general but it's really great for writing tests all right so here we are we have our running tests and we have the tests that we have so far nested into their specific scopes now what i wanted to do is add another test case here saying that it should return not found if the account number does not exist so given an account number of let's say does not exist so it's always nice to make your test data very readable then i want to have again this combined when then block so when i say dot moccambc.get api bank's account number and i should extract this to a variable because i'm using it three times already now so this will be a let's say base url and obviously i don't want it just here i want it at the very top because it's also relevant for all the nested classes and then here i can just say when i get the base url and over here when i request base url slash account number and the same here then first of all i'm again gonna print out what's happening and i expect that the status code in this case is not found and to make this error test case stand out a bit more i'm actually going to write this in uppercase so let's run it again and see what happens all right here we are we have a failing test again i think it's actually also useful to select here the first test that failed when all the tests have run then it would already mark this one so let's see what's happening down here collection contains no element matching the predicate that's what we expect however it just says request request processing failed so it's really just throwing an exception and just completely failing instead of giving a proper response with a proper not found status code so now we get to another interesting topic in spring boot which is error handling so for this one there are multiple ways to solve it for this tutorial series i'm going to use a very easy one so in our bank controller what you can do is you can also define an exception handler and what we really want to do here is in our controller we want to map any internal exceptions that may have occurred like the no such element exception we want to map those to the appropriate status codes and so springboot has this really nice capability where you just say you have an exception handler for some type of internal exception that's not really or shouldn't be exposed to the outside and here we looked it up it was the no such element exception the one actually coming from kotlin not from java util and then here again this will be an annotation on a method and i'm going to call this handle not found because you can give it any name you want but this of course should signify also what you're trying to do and then it gets a parameter which should be the same type as the exception that you're handling so here i'm going to pass in this no such element exception so spring boot will be responsible for basically catching that exception and providing it to this method and it's going to return a response entity so really just a response a proper response with our 404 response code and here i'm going to create a simple response entity using the exceptions message and the status code not found so with just three lines of code we've achieved that spring boot will handle any no such element exception that bubbles its way up into the controller it's gonna provide it to our handle not found method and we're going to respond with this response entity that we have so let's go ahead and run the tests again and see if it's already working as we expect it to all right perfect so now in this test case here when springboot encounters the account number that doesn't exist it will go into our mockbank data source and the first method here will throw a no such element exception which is going to bubble up into our data source which is again going to bubble up into our service and then finally it's going to bubble up to our bank controller and here we have this exception handler so like i said there are different ways to do this in spring boot if you have many controllers you don't really want to define this in each and every controller so there's also way to do it for your entire springboot application but again for these tutorials this is just fine and in fact you can also look it up here in the output so the response now has error code 404 and even you get the really nice response body collection contains no element matching the predicate of course you could also extract this away a bit or abstract it to no such bank was found in fact let's go ahead and just do this so you know how to so in our mock bank data source instead of just calling first we can also say first or null but then if it is indeed null what we're going to do is we're going to throw our own no such element exception and now we can define our own message so to give a more useful answer in our response we can say could not find a bank with account number and then pass the account number and then this way if we run the tests again we're not really checking the response body but we could for now let's just look it up in the logs here so for this test case could not find a bank with the account number does not exist and obviously this is a more useful response for your users because it's more related to your domain with the banks with the account number and not just a super generic error message all right really nice so now all that's left is to jump back into postman and just see if it also works here so really we already have our automated tests but it's always nice to see it manually as well of course i should also start the application first if i want to do this and once we have that then i can go to postman and let's see what happens all right so i get my bank with account number one two three four also if i try something that doesn't exist here i will get could not find a bank with this account number all right perfect so everything working as expected so in this video you really learned quite a few new things starting with the get mapping that actually provides a path variable then of course also using um the mock mvc to test the nonhappy path which also led us to explore some of the exception handling capabilities of spring boot and obviously just how to create a new endpoint this time top down going through the service then going through the data source and then also implementing that one so i hope you've learned something in this video if you did please leave a like check out the links in the description and also let us know in the comments what other topics you might be interested in in the future and then i'll see you again in the next video