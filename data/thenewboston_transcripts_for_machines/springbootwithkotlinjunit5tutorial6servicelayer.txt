in this video we're going to create our service layer now the service layer is basically the main entry point into your business logic that really implements the use cases that your application supports so its responsibility will be to use the data source to retrieve all the data that it needs and for now it's going to be very trivial because that's not any business logic or any transformation that it will do on this data but we're gonna again do this with test drive development and we're gonna see a new springboot annotation and how it all works together and in this video we're also gonna look at mocking using mockay so let's go ahead and jump right in so in our ide i'm going to go ahead and add a new package again here so this one i'm just going to call service and in here i'm going to create a new kotlin class or file and this time i'm just going to call it bank service so this class represents our service for the bank use case and similar to the repository we're going to use the service annotation which again just like the repository annotation tells springboo to make this bean or this class or an object of it available at runtime so it's available in the application context and it can be injected by a dependency injection into your other objects and classes and again this also conveys meaning to other developers reading your code so they know this is a service level bean so this thing will be responsible for things like calling some data source maybe or maybe handling or mapping exceptions performing transformations on the data whatever the use case or the business logic is for that use case and by the way if you have a bean or a class that isn't really a service or repository or you're not too sure and you just want a generic bean that is available for component scanning and therefore for the application context you can just use the component annotation and really repository and service are pretty much just that so they are a meta annotation that applies the component annotation so if you're not too sure you're not really in the service layer or it's not really a repository you can always use the add component annotation for just a generic bean that's available in your spring application context all right so with this let's again go ahead and create our test class again make sure you have junit 5 selected up here and then i'm just going to hit ok so with this one we now again have to make a decision whether we want a pure unit test meaning that we really just want to test what the service class does and we mock out the data source that it uses or do we want to have an integration test that really goes maybe through the service bean but also uses the actual data source to retrieve some data and we see if those two work together just fine now what i'm going to do here in this video is i'm going to use a pure unit test so i'm going to make this a mock data source in the test and i'm just going to see or check that the service actually calls its data source as it should and i'm doing this because in the next video when we create the controller i'm going to create an integration test there that really uses the service the data source and really tests that all of these components work together as they should so for this level here for the service level we can just use mocking so let's start off by thinking about what we want to test so i'm going to use the test life template again and i'm going to import the test dependency or the test annotation make sure it's really from junit jupiter api and not another test annotation and here i'm just going to say it should call its data source let's say to retrieve data or to retrieve banks and then i'm going to skip the given part for now and i'm going to say we want our bank service dot let's say get banks and again we get some errors here and this is again using test driven development so this one actually is just because i don't have the property in the test itself so i'm going to create this one and here again i'm just using um this as a pojo so again in this test i'm not using any dependency injection i'm just creating these these objects manually so for now i don't really need it yet but i'm gonna use a mock data source or just a data source of type bank bank data source and this will later run be a mock so for now i'm going to comment it out but in our bank service what we don't have yet is we actually want to have a property so again we're using a primary constructor here and so this one needs its data source so it needs some object of type bank data source and now going back to the test we now again have an error here so we need to provide some data source so now what i need here is a mock object for this data source and to create this mark i'm going to add a new library to our gradle dependencies that's really good for creating mocks in tests with kotlin and this is also going to be part of the test implementation configuration here which just really means in gradle that the classes that you import or this dependency will be available in your test classes or your test resources but not in your production code and the dependency i want here is from io.mockay and it's just called mockay and currently the version is 1.10.4 so once you have this just make sure you load the gradle changes you can also enable auto import so it does this automatically and then once that's done being downloaded you can verify in your external libraries down here that it's really been downloaded successfully okay so once gradle is done downloading everything make sure you have io.k down here and then you should be ready to go so back in our test class we can now simply go and say our object of type bank data source is supposed to be a mock with this function mock k now there are quite a few options here that you can see as the parameters we're going to use one of those later on but for now you can just use this object and put that into your bank service and then the bank service property is ready to go so the next thing that would fail this test is that we don't have a get banks method yet in the bank service so let's create this and this of course should also create a or return a collection of our bank entities and in here for now let's really just again do the minimum so we're going to return an empty list all right clean up the white space a little bit and then back in our test class we can now verify that when we call the bank service dot get banks it actually calls this data source so that's what we want to test in this test case we want to make sure or we want to verify that our data source dot retrieve banks has been called and this verify method here if you go into it this is coming from mock k and what it does is it really just verifies that the method call that you put in here was being done in the realm of your test case and we can also make sure that it is called exactly once which is what we expect here so the server shouldn't call it three times or whatever it should really just call the data source and it should call it exactly once so with that done let's go ahead and run this test case all right so here we go we have our failing test case and it's saying that the verification failed because bank datasource.retrievebanks was not called so let's go to our bank service and in here what we really want to do is we want to return the datasource.retrievebanks and that's really all it has to do for now so let's go ahead and run the tests again all right we still get an error in here it says no answer has been found for bank datasource.retrievebanks so what's going on now let's go back to our test class and in here we're calling bankservice.getbanks and what's happening is if we now look at our get banks it's calling datasource.retrievebanks so it's doing what we expect but the problem is that we don't even get to our verify block down here instead the code runs into this call to the data source and it doesn't know what to do with it because the data source if you recall is really just a mock object and if you have such a mock you have to specify its behavior for every method call that you expect on it so what we can do is we can say given that every datasource.retrievebanks returns ah let's say a list of banks or well for now we can also just return empty list it doesn't really matter we just want to test that the data source is being called and with this let's go ahead and run the test case again and then it passes just fine now what we can also do to simplify this a little bit because we don't really care about this return value and we don't really care about what the mock exactly does we really just want to verify that if we call the service that it really just calls its data source and therefore we don't really need this and we don't really need any given block and what we can do here is we can say that this mark should be relaxed now what this means is whenever a method is called on it it will just return some kind of default value so if it's encountering a method that's supposed to return a collection like retrieve banks most likely it's just going to return empty list by default if it's an int it's going to return maybe a zero maybe one you shouldn't really care about it because it's relaxed if you want to specify explicitly what it should return you should use the every and then return syntax okay so that makes it easier then also we can clean this one up because we don't really need the return value here and then we run our tests and we're still green everything's still looking fine so now we're in the reflector phase of our red green refactor cycle so we can see in our bank service there's something we can refactor which is to convert this to an expression body and then we have just a single line of code because it's a very trivial indirection just to the data source all right and that's it we have our service layer with our first method implemented of course there's going to be more for the post and put requests later on we also have our test ready we've used mock which is a really nice mocking framework if you're interested in more about junit 5 test driven development unit testing or mocking with market please let us know in the comments below also note that again the bank service test here is completely independent of the spring boot or the spring boot application context we are again using pojos so we are initializing all the objects ourselves but we're going to do this differently in the next video where we're going to take a look at controllers and rest mappings if you like this video please make sure to leave a like below and i'll see you again in the next one