all right so with our two get endpoints ready to go in this video let's go and create the first post endpoint so while again endpoint is basically there for your users to just retrieve some data a post endpoint is for them to submit some data to you usually to create a new object of some type so back in postman here if we create a post request to the bank's endpoint and we provide some bank data in the request body then we expect the service to just retrieve that data get the data and then create a new bank with this data so afterwards if we get all the banks it should be in there just like it does here so let's go ahead and see how we can make such a post request work using spring boot now as you can guess i'm going to start off in the test class and what i'm going to do is create a new nested class i'm going to give it the name of let's say addbank you could also name them after the requests maybe that's even nicer so we have post api banks post new bank and then i can also rename these up here i actually like this so get api bank let's say account number and then over here it's just get api bank i think that's even nicer it's actually banks that's even nicer than having the method names because what we're really testing here is the rest api so it also reflects the level of abstraction a bit nicer in here i'm going to create a new test case saying that it should add the new bank so here we'll learn quite a few new things because we need to now provide a request body and we need to provide an entire bank in the request body so i'm going to start off by saying given we have a new bank which is a bank of some account number one two three and then what do we have next trust let's say 31.415 and a transaction fee of two and then when we say mock mvc.post now so we're making a post request to the base url so api slash banks then for now let's just go on and say again do a print and we also want to expect well for now let's just again start with the status and now we actually want to get the status code is created and this is the number 201 and again i'm going to move this into a combined when then block but now the problem is we don't yet have any request body so what we can do with this mock can we see syntax is open up curly brackets after the post and in here we can define first of all the content well or maybe we start with the content type so the content type for the request body should be json and then the content itself well it should be basically our new bank object but we have to serialize this and what we can do to serialize it is we can use the same object mapper that springboot uses by default which is using a library called jackson so it's part of the application context by default so what we can do quite simply up here is we can auto wire another bin and this one is of type object mapper so we have an object mapper of type object mapper so this one if you look at the hierarchy is a bean or a class that comes from jackson and that's again the standard library that springboot uses for serializing objects to json and you deserializing objects from json all right what i don't really like here is this field based injection and delayed init variables so what we can do instead is we can also move these to the constructor and in here we can now just say we have a val so what can we see of type mod can we see and we don't need the light in it anymore so here again you also have to use auto wired and well for the test case it's not really necessary to have the private in there because the entire class is only available in the test sources anyway and then the same for this one so i'm going to copy it here but it's going to look quite different so it's going to be just a val all right this is already looking a bit nicer but what i also like to do is not use auto wired on each of the parameters here but instead just tell springboot to inject all the dependencies for the constructor so for this you have to annotate the constructor itself in kotlin because of this syntax with the primary constructor in the class header it's a bit well different because then you also have to explicitly use the constructor keyword up here and this way if you have many parameters here that have to be injected you only need to have the auto wired annotation once okay so so much for cleaning up the code let's go back to where we were so the content now should be our well our new bank however we have to use the object mapper and then write that value as a string and this will really just um yeah serialize it to a json object just the same way that we see it here in postman so it's not like a regular tostring function it's really a serialization to a valid json representation so now because this is becoming a bit more complex and it's kind of weird with the indentation here i think what i'm going to do is actually split this up now into a when and a then block so what i want to do for now is say this will be the when block for now we'll have to go up here and actually store this into a variable so i'm going to just call this foo for now and let's see what it returns um it actually returns well just result actions which isn't really the best name so let's say response we'll just call it response already or maybe perform post that may be even nicer with the following syntax and then down here in the then block we can say perform post and do print and expect so this is i think reasonably readable and this is actually indented the wrong way now all right so perform post and do a print and then expect that the status is created so this let's go ahead and run our test class again we actually don't really have a post end point here so what it gives us is not a 404 because we do have an api slash banks however it only offers a get endpoint so 405 means method not allowed because the post method is not allowed the only allowed method on api banks currently is get so let's go ahead in our bank controller and at a you probably guessed it a postmapping now this one doesn't need anything here because it's really just on api slash banks and then let's say i'm going to call it at a bank and now we're at an interesting point again because in this method here we want to get a bank of type bank and the way it's provided to us is in the request body so similar to how we got data from the path or the url before now we want spring boot to extract the bank from the request body so what we do is we say request body and that's really it so spring boot will look at the request body and it will deserialize the json into a bank object of course given that you provide a valid json request body and then this one really is a matter of design what it should return back here just for purposes of visibility i'll just return the bank that was created well we could return the bank which will be a bit confusing because it then looks like it was created but we didn't actually do something but of course we'll fix it in just a minute so let's go ahead and run the tests first obviously we didn't really do anything yet to make it return the created status code but we'll see let's just run the tests okay so we still have a failing test and if you look down here now we're getting 200 which is okay but what we actually want to have is the status code 201 so what we can do here is we can add a new annotation called response status and this one of course takes a http status as an argument and then we can just say uh return created if everything goes as expected all right with this one let's run them again and now we should get our status code as expected all right perfect we've made our test green so now let's go ahead and extend the test because we also want to see that we have again a content with content type application json of course this is just if you decide to also return the bank that was created otherwise this is really all that you expect from this endpoint and then of course another thing that we expect is on the json path we expect that the account number is the same that we put in above so account number has a value of account one two three and then of course if you want to be very precise you can also test the trust and transaction fee which is probably a good idea so this should be 31.415 and of course you could extract these into variables to not repeat each value so now again this is a bit confusing because we actually just returned the bank so this should pass because we're just returning back what we get but we're not actually storing anything so for now let's just go ahead in our bank controller and obviously you want to actually call the service and we want to add a new bank with the given data so let's go ahead create this method takes in the bank and returns the bank and of course again this will just delegate to the data source for now and maybe here on this level we'll say create bank and then we're going to create this member function on the data source takes a bank returns a bank and i don't want any implementation in the interface itself but i want to go down to the mock and then in here down below the other implementations we're going to create our implementation so in this mock data source what we want to do quite simply is just add it to our list so what we'll have to do in kotlin is we'll have to make this a mutable list i can also show you what happens if you just have a list off that's basically a read only list in kotlin so if you try to do banks dot ad bank it really doesn't exist here this add method so it's going to be a compile time error and then we want to return the original bank but again you'll have to make this a mutable list which is quite a nice feature of cotton because it's by default if you just say list off or set off or map off you're just going to get a read only data structure and if you do want mutability in your code you have to explicitly write it down all right so with this done we actually have the bank stored in our list so the test of course still passes but what i want to do now is i want to create another test case which again tests not only the happy path but also what happens if something goes wrong or something's wrong with the request and to give an example what i'll do is i'll create a test where we're trying to create a bank with an account number that already exists so here i'm going to say it should return bad request so that's http status code 400 that indicates that well something's wrong with your request usually the request body is invalid and this should happen if bank with given account number already exists so let's say given an invalid bank which is our bank with an account number of one two three four that already exists and then just some other data doesn't really matter then when we say mock nvc.post and we can basically copy it from up here so the whole when block only that we've now called it an invalid bank just to make it clear again and then down here we'll say perform post and do a print and then expect that we have a status code that is bad request right then we run the tests this will not work right now because we haven't really done anything to make it work let's see what happens with the account number so you can see down here if you scroll down what we get in the response is just a two one two one created because we're just adding it to our list without any checks so what we have now is we have two banks in our mock data source with the same account number and that's of course an invalid state for our application now to fix this we'll have to go into our data source and then first perform a little check here so if there's any element in the banks list where the account number is equal to the new bank's account number then what we want to do is we want to say throw an illegal argument exception and here we can again provide some nice error message that we can also expose in our response so a bank with account number of the given account number or rather bank dot account number already exists and with this if we now try to add a bank with an account number that already exists before we even get to banks.add we will just throw this exception and then of course in the bank controller similar to how we did before we'll have another exception handler so i'm just going to copy this one however instead of handling the no such element exception we're now handling an illegal argument and illegal argument in general probably means that something was wrong with the request body or the data that you received so we can say this should handle bad requests of course you could use your own custom exceptions that are more finegrained and so that you know exactly this was definitely a bad request however for this very simple application just using the default exceptions that we have like no such element or illegal argument is more than enough to handle these kinds of error paths and then we want to again return the exception message in the request body but of course the status code should be bad request alright with that done let's rerun our test and see what happens looking good all our tests are now green um on this new test case down here if we want to take a look it says bank with account number one two three four already exists and it gives us a status code of 400 which again is just a bad request so all that's left now is to also try it in postman so not don't forget to run the application itself like i always do and then it's running again on port 9000 so now if i post a bank like this one i get 201 created you can see it here in postman and i get back the original bank that i put in but more importantly if i retrieve all the banks now i can see that it has indeed been persisted at least for the run time of the application because we're obviously just using in memory list another proper database but yeah you can see we have a post and we can retrieve the data that we submitted all right so everything's looking good there's one quick tip i want to give you regarding the ide or the tooling so in intellij you'll see that it will say the bank controller is never used and the same for its methods and that's because you're not really using the object in your code and you're not calling these methods anywhere but of course they're being used by the spring framework so what you can do is you can show the context actions with alt enter and say you want to suppress this warning for any class that's annotated with rest controller and then it will stop showing it as unused of course your exception handlers are also used by spring boot so you don't have to call them anywhere manually same for your get mappings and post mappings all right yeah but that's just a little tip on the side mostly in this video you learned of course how to use post mappings and then how to get the request body data into your application and also by the way how to override the status code very easily by just using the annotation on top of that for your testing you've learned how to use the object mapper and how to create post requests in your tests using the proper media type and content so i hope this was helpful to you if it was please like this video and also check out my links in the description and i'll see you again in the next video