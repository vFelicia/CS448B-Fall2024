so in the comments some of you asked about gradle and why i'm using gradle over maven um so i want to give just a quick user guide into how to use gradle and what comes with the gradle setup from the spring initializer out of the box so in this video you'll learn how to build your project how to package an executable jar for your springboot application and even how to bundle a docker image from it but let's first talk about what gradle itself actually is so gradle is a build automation tool that allows you to build your projects and automate any build tasks that you want so you can build your projects pretty much out of the box with a java plugin for instance for java projects you can also write your own custom gradle tasks to automate pretty much anything you want and also gradle focuses a lot on performance optimization so that your builds your tests and everything runs as fast as it can and also you can see here there are many big companies using gradle of course so beside maven gradle is really one of the primary build tools in the java ecosystem and i personally like gradle probably because i know it better than maven but also because it's more flexible so if you write your own custom tasks here you can basically write any groovy code that you want or if you're using the kotlin syntax so with kts you can basically write any coding code that you want whereas in in maven you have the declarative approach where you write your xml files your prom.xmls and so it's a little more constrained and in gradle you have an actual programming language under the hood so essentially you can write any automation that you want all right so let's take a look at some of the things we can do with gradle the tasks that we're going to see they basically come from the plugins that we have here so there are a few general kotlin or jvm tasks and also there are tasks provided by the spring boot plugin so let's open up a terminal down here and as you might remember we have this gradle wrapper in the project that you can call using gradle w now depending on your operating system you might have to call it like this it doesn't work you can also try calling the bat file directly but for me with windows here it works just fine just calling gradle w and this grader wrapper is really set up in the gradle directory here if you remember and under properties it basically just configures where to download gradle from and which version so whenever a developer or someone else opens your project they can just run gradle w and if it isn't buried it will just download the grade wrapper from the specified url and so this way anyone using your project doesn't have to have a local gradle installation in fact i don't have gradle installed locally right now so if i try to do gradle let's say status i don't actually have gradle here but i can still use the greater wrapper with this project and also the greater wrapper is version together with your project so you can always decide which greater version you want to use for this project to build it and so this way you know which gradle version is used for your build and that also makes it more reliable so let's get started down here by running gradle w tasks and this will just print all the tasks that are available for this project right now so you can see from the top here it starts with boot run which allows you to run your project as a spring boot we're also going to take a look at the clean tasks and the build task so over here and another interesting task here is boot jar so this allows you to assemble your springboot application into an executable jar so we're also going to take a look at that and then since spring boot version 2.3 you even have a task boot build image which builds an oci image so a certain way to build a docker image based on your stream boot application so those are the ones we're going to take a look at of course you can also go through the other tasks if you want to explore them but for now let's start off with the clean task so if you have built your project before with gradle you should see a build folder here and this is really where gradle puts all the build files so your compiled classes any jars that it generated and so on so if i run here grader wrapper clean that's just gonna delete the build directory basically so if i refresh now up here sometimes it takes a second okay there it's gone and then the other way around i can run gradle w build and that's going to compile the entire project it's going to assemble all the sources and it's also going to run by default the test that you have in your project so you can see here it starts with compile kotlin of course after you perform a clean it's gonna take um a few seconds so one of the ways that gradle improves this also is that once you've built the project before it can run subsequent builds a lot faster all right so here the build actually fails and i believe that's because we have some tests that don't pass anymore because we're using or we change something about the data source that we're using but at least this way you see that it really does run your tests so it won't build your project if the tests don't pass now fixing these is quite easy and so i challenge you to also try to do this yourself but basically we're going to go into our code here and first of all we don't want to use the network data source anymore because it doesn't implement most of its methods so i'm going to say qualifier mock and then in our mock data source i'm going to also give it this qualifier here so this will already fix most of it so let's take a look and run all the tests again i'm going to close this one down for now all right so now there are only two test cases that fail here and they're quite easy to fix so we've basically used the proper json syntax now so this is now in snake case and the same here so we call this one default default transaction fee and then if we run them again it should all be fine all right there we go all the tests pass again so let's run greater build again all right nice so now we have build successful and also you should have noticed that on the second run the build phase didn't really take long so it jumped almost instantly to the test phase simply because it had already compiled the project again there was also already the build folder so all i had to do was really run the tests again so now the next one we're going to take a look at is gradle w boot run and this really just runs your spring boot application so here you can see you see the same logs as if you ran this from intellij directly so you see spring starting up and it started on port 9000. so in some situations this can be really useful to run your springboot application if you don't want to run it from your ide or your java file and talking about jar files let's also take a look at gradle w and then boot jar and so this will really just take your project and you can see it's quite fast if you've already built the project before and we'll just assemble it all into a executable jar file so if you now look under build and then go into ellipse you should see a jar file being created here so if i now go ahead and say java minus jar so to run hr file and then i give it the build libs whoops not kotlin clips and the jar file that's also just another way to run your application so depending on how you deploy your application the spring boot jar here might be the way that you deploy your actual application into production of course if you're using kubernetes or something like this you need a docker image instead however since springboot 2.3 like i said you even have a task that comes out of the box with the springboot plugin called boot build image and by the way the casing doesn't really matter with these gradle tasks so you can also just write build image like this and that's gonna assemble a docker image that really just runs your springboot application so you can use those for docker environments whether docker compose or a docker swarm and you can also use it to run your application on a kubernetes cluster so here you can see now it starts building your image and it just takes the project name as the artifact name just like it did for the jar and also by default it's just a snapshot version so by the way notice that this will not work if you don't have docker installed so make sure you have docker installed and then it should be able to find your docker daemon and build your ultra docker image alright so here you can see it use build packs so this is why they also say it builds an oci image and it created quite a few different layers so the way this docker image is packaged follows many best practices it also splits up the springboot application itself into different layers so that if you only change your application only a very small layer changes but i don't want to go into too much detail about this right now that's a topic for a separate docker tutorial of course if you would be interested in such a course let me know down below so that i know which kind of courses you would like to see in the future all right but ultimately you should see successfully build image and then it gives you the name of your image so now taking this you should be able to just say docker run and then give it the name of your image and that tells docker to just run it so now there we go we have at least three ways to run your application now for actually you can run it from your ide which is great for development and you can also run it in debug mode you can use gradle w boot run in order to run it from your command line you can build hr and then use java minus jar or you can use a docker image and then run it with docker now of course if you want to bring your springboot app into production either depending on the environment it's going to run in you're going to create a jar file that can be run on some vm or linux machine or you're going to package a docker image to run on something like a kubernetes cluster and the best thing is all this comes out of the box now with spring boot so you have this plugin in here if you use the springboot initializer and that gives you the boot run the boot jar and the boot build image tasks now the great thing about gradle again is you can also write your own arbitrary tasks to automate anything that you want but that's the topic for a whole nother gradle course or tutorial if you would be interested in such a course also let me know down below so i know what to prioritize and which courses or tutorials you would like to see all right but that's all for this one i hope you liked it if you did please leave a like below and then i will see you in the next one