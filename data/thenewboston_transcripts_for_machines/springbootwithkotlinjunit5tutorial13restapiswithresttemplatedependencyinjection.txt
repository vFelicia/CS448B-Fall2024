all right hi everyone and welcome back to this tutorial in this video i want to talk a bit more about dependency injection in spring boot and how you can control which kind of beam you want to inject into one of your components if there are multiple that might work so one thing you might be wondering so far is what the heck do we even have this data source for it really just delegates every call that you make or currently the service delegates every call that you make to this data source so why this additional layer well as always when you have an interface like this bank data source here it's because you want to have potentially different implementations for this so here for instance you might have a bank data source that fetches your banks from a database you might have a mock data source like the one we currently have or you might retrieve banks from the network so there are different ways that this data source might do its job and really you don't want to couple yourself to a specific implementation and also i just want to show you how you can inject one specific implementation of a bean if there are multiple of the same type so here let's say we have another data source and we're actually going to do something fun and get them from the network so in this case from the new boston chain so we're going to look at one of the banks and get the actual list from one of this service but for now let's just create the class here and let's just call it network data source and of course this one should implement our bank data source interface so again in kotlin we just use a colon and this means both implement for an interface as well as extends for an abstract class or another class then we have to implement all its methods so for now i'm not going to go through all of them so we're going to use only the retrieve banks method but we're going to do this later so for now i'm just going to annotate this class just like the mock data source with the add repository annotation so now something interesting happens because we have two different implementations of this bank data source interface and if you think back in our bank service we're just telling spring boot to give us an implementation of this bank data source interface so let's try to run our application and see what happens all right so as you can see the application is no longer able to start successfully and that's not a surprise because springboot doesn't know which of those two implementations you actually want to have here so it's going to tell you there are two different implementations found the mock bank data source and the network data source and it also tells you that the bank service required a single bean but two were found and it even tells you what you might do to prevent this situation so we can mark one of them as primary so that would just then be the default one so if you say nothing more and just say give me an object of type bank data source it would choose the one with the primary annotation you can also allow the consumer so in this case the bank service to accept multiple beans but we don't want this here or you can use the add qualifier annotation and this is what we're going to do in this video so i'm going to close this up for now and now one way to solve this is we can go into our network data source and on the repository annotation we can actually provide an argument here which then acts as the qualifier for this bean so i'm going to say this is our network repository or network data source and then in the bank service i can now use the qualifier annotation just like spring would suggested and then in here i'm going to again use this qualifier string to tell spring boot which kind of bank data source being i'm interested in here and for this one i'm also going to disable the hints because the value is just not really a very useful hint and then let's try to run our application again and now it should fetch the network data source based on this qualifier here so now if we check the startup it now says again tomcat started on port 9000 and the application started successfully all right and we can also verify that it's actually using this data source now if you want so by going to our application on port 9000 to api banks and then of course it will give us an internal server error just because the network data source doesn't actually implement any of its methods so it's going to run into this to do method and this will just throw an exception and in fact you can also see it down here for now i'm just going to stop this and close it down here so now let's actually make this work by connecting to one of the banks in the new boston chain and just retrieving the list of banks from there so we're going to make a request to the network and in fact we're going to call the end point that you saw in one of the first videos if you recall just very briefly we looked at the new boston.com and in this documentation here you can see there's the documentation for the bank's endpoint of one of the banks and so there you can retrieve the list of the actual banks in the network so what we can do is we can take one of those banks and in fact i'm going to use the one that's also currently recommended let's say for the network and that's the one running on this ip address so if i enter this into the browser and call the bank's endpoint you can see i get a list here of all the banks that it knows of which are currently seven different banks and these are the actual banks in the new bus network so let's go ahead and make this exact request in our application and then retrieve those banks from here and springboot actually provides a very good capability for this kind of functionality because it's really common so without any new dependencies for our project we can auto wire a bean called a rest template so i'm going to also call the variable here rest template and it's going to be of type rest template which is really spring boots way of making rest requests and that's really all we're doing here so this end point here is really just another rest end point just like the one that we're building with our app and now we're calling this one and this is quite easy thanks to this rest template so in here we now have a bean of this type and now in retrieve banks we can make a request by saying rest template dot get for entity so here i'm going to pass in the url for this endpoint that we want to call and get for entity the get really stands for making a get request and for entity means you want to parse the response that you get into an object of some kind so currently we don't really have a representation for the response that we get because it actually has this structure over here so it's going to return an object which has account next previous and then it has a collection of results or an array of results in json and each of those has the data for each of the banks so starting from here we actually can use our bank entity which will only take the fields that it knows of so it's only going to take the account number from here it's going to take the transaction fee and the trust however we still need to represent the entire structure and so we're missing the results part here and now to map this i'm going to say this is called a bank list and this will be a new dto so new data transfer object that we're going to use here so for this i'm going to go into our network package and create a new one called dto because we only need this one inside our or for our network data source so it makes sense to put this into the scope and so in here i'm just going to create a new bank list and so similar to our bank entity this will be a simple data class and it actually only has one field for us because we're only interested in the results and we can parse this into a collection of our bank entities and this way spring boot or rather jackson our serializer will only take a look at the fields that we're looking for so here we're going to take the results but it's basically just going to ignore the count next and previous because we're not interested in them and it's only going to parse those and of course we have to use a collection of bank because this is in fact an array in json and then it's going to automatically parse each of these objects into one of our bank entities now we will have to adjust something in our bank entity later on but let's first take a look what happens if we do it just like this all right so let's first store this into a variable and i'm going to call this one response and now this call to get for entity will actually give us a response entity of bank list and so with this one we can say we want the response dot body if there is one and if there is one we want to take a look at the results so this is kotlin's way of handling nullable fields this body object might be null and if it is this entire expression will also be null but if it's not null we have a safe access to its results field and we can also again say if this entire thing is null then we want to throw a new io exception and just say could not fetch banks from the network so something must have gone wrong and otherwise we just want to return these results so results now if you take a look here is actually of type if it wants to show it is of type collection of bank and this is because we said we want to fetch a bank list so our body here is of type bank list question mark this means it's nullable it might be null and so this is how we get our list of banks and that's also what we want to return we can get rid of this one now because it's already defined here and then with this let's go ahead start up the application and just see what happens all right so down here it says we require a parameter in our network data source of type rest template and this one could not be found so actually we have something that we have to do for this and we can go into our application our springboot application for this and just provide a bean of this type so this is quite easy to do in springboot we can just call this function whatever we want and there is a socalled rest template builder so builder and this method is supposed to provide a rest template and quite simply if we just want to take the default configuration we can just say builder.build and that's going to give us a rest template so this bean annotation really just means that spring boot is going to look at this method and it's going to use that to provide beans of this type to any components that request it so here again it makes sense to say that you're not really calling this specifically so you can remove the unused warning and now if spring boot encounters the rest template that you want to auto wire in your network data source it's gonna see that there is a method that's annotated with adbean and that provides a rest template so it's gonna take it from there and so with this we should be fine so let's run our application again and this time it should be aware of our bin here and then inject the rest template all right it's starting up successfully so now let's see what happens when we call our endpoint again so on our port 9000 slash api slash banks well we actually get an error that the uri is not absolute so what we'll have to do in our network data source is this is not a proper url or it's not enough so we also need to include the protocol for this it's just http and so let's restart our application here and then let's go back into the browser refresh and we're actually getting an error here so internal server error when this occurs there will be some stack trace usually in your spring boot logs so here you can take a look and try to figure out what the problem is i mentioned already we'll have to make a change to our bank entity here and this is because spring boot or rather jackson will look for json properties json fields that have the same name as your class fields so if we look into our bank entity here we see that we have account number in camel case trust and transaction fee in camel case however if we look at the at the actual endpoint here and what it gives us it's an account number with underscore we have default transaction fee also in snake case with the underscores and trust so what we should do here is we can use the json property annotation and this is very common on dtos so data transfer objects to specify the name of the json property that you want to parse here so it's the account number then of course for trust we don't necessarily need it but just to be consistent with the other fields and also to make sure that it really stays this way even if we want to rename this internally in our class we just add the annotation let me also get rid of the hints and then this one is actually default transaction fee in the api and so this way now our serializer knows how to handle these so let's restart our application and now the entire structure should match the json response so it's going to try to parse everything into a bank list so it's going to look for a field called results and it's going to try to parse the results array from json into a collection of bank and then inside the bank it's now going to look at the json properties and it's going to parse the fields with the same names so let's go back to the browser and try this again and this time we can see we get the actual data from the network from the actual new boston chain so from this specific bank in fact and we get the exact same data that we have here of course just a subset of it because we just took those three fields from it but this is how you can make requests using the spring root rest template all right perfect so this way now you've learned how to make network requests from spring boot using the rest template how to also customize the serialization into an object or rather the deserialization of json into an object using json property and also how to control dependency injection a bit more using qualifiers and then passing that qualifier also as a name into your annotations such as repository you can do the same for services other components so if you have here the service annotation component or whatever you can always pass this kind of qualifier to them all right so i hope that this was interesting to you of course it's just scratching the surface of spring boot of jackson serialization and also deserialization how to handle network requests and some best practices for it but i still hope you learned something from it and if you did please leave a like below again take a look at the links in the description if you want to learn more from from me or from my other resources and then i will see you again in the next video for a little recap and conclusion