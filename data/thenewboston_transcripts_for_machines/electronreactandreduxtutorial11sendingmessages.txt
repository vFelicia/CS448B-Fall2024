all right so now that we got the connection status component up and running what we can do next is start working on this main button logic however before we just jump right into that I want to kind of take a step back and do a little recap of exactly how this app is going to work so whenever we hit that go button what's going to happen is my device is going to send a message through the core server to the receiving device and then once this receiving device receives this all it's going to do is it's going to send back a message back through the server to my device and we'll say that this first request we're going to call it the ping request and then this response we'll call it the pong so a ping pong message pretty simple architecture but before digging into the code let's go ahead and take a look at the structure for exactly how these blocks are going to be formatted so these blocks or in other words chunks of data that are going to be sent between devices they always need to have a unique ID and for this you can just have any valid uuid and the reason that we need this is just to ensure that this core server it isn't processing the same exact blocks again and again and again it also allows for you to specify an amount we're not going to need this in this tutorial this is just so if you ever want to transfer some messaging credits from one device to another then you can do it right there again like I said this is just going to be zero for this tutorial the recipient in the center this is pretty simple it's the account number of the receiving device in the one who sent this block and this transaction fee this we have set up on the core to be one by default and the reason that we have this is kind of for our security purposes if anyone ever steals my device it effectively throttles the amount of traffic or messages they can send back and forth so the core server like I said just requires one messaging credit to send a message to another device on the network now this payload will dig into in just a second but lastly the signature field is just for the digital signing process to ensure that the sender is indeed the one who is sending this message so now on to the payload so if we take a look at the source code for the server we can see that the payload is a Json field so you can include as this payload any valid Json however for tnbos just to keep things standardized we always shape the payload in this format we have a PID which stands for process ID and what this effectively translates to it's the ID of the application that is sending or receiving this data in that way let me pop this open again whenever we have blocks coming into tnbos tnbos is going to know which app to Route those blocks to depending on this process ID so again for us it's just going to be a speed test but for chat it's chat so on and so forth basically saying which app is this data for now aside from that we have this FN in params value because essentially whenever we are sending data to another device in a lot of ways it works similar to a RPC or remote procedure call or remote function call where we are essentially calling a function on another device so the two functions that we're going to be writing are a ping function and then a pong function and for both of those functions the params are going to be the same and that is just going to be the Run ID and the reason for that is whenever I send out this request and that device sends something back I know which run it's referring to so now let me go ahead and open my IDE and start writing some of the typescript definitions for I'll start with these functions so in types I'm going to create a new typescript file and I'll say FNS I don't like using the word function anywhere because it's a reserve keyword so that's why I decided to use FN rather than function in a lot of these places so export enum and I'll say speed test FN in like I said we're gonna have two functions a ping and a pong and palm and for each of these functions we'll write a separate interface and for this I'll say the Ping params whenever we call this function this is just gonna take in a run ID and this is going to be a string value and then I'll do the same exact thing for the pong function so whenever you use the pong function also pass in params of the Run ID now we can probably combine these into one interface but I like to be super explicit whenever I'm writing the params for each function and on that note what we can do now is just go ahead and import everything under functions import all of that all right now from here what I like to do is create utility functions for generating these payloads and you'll see why in just a second so under speed test I'm going to create a new directory called payloads and for the naming convention is just the function name followed by payload so first we'll do the Ping and R right so for the Ping payload again it needs three things process ID function name and params so let me go ahead and sense our process ID is just the app ID and that is stored in this app registration I'm going to import the speed test registration so M4 speed test registration from apps speed test registration and then after this let me go ahead and import some of these types so all right so we are going to need this speed test function and these pink params and no the only other thing that I need is a little helper interface that I wrote from system types and that is app payload right there I'll show you what this is so all this is saying is that for this interface it requires a function which is a string params which can be anything in process ID which is a string basically ensuring that we follow this format right here which is just the tnbos standard all right now this function say ping payload it's equal to a function and this function is going to return that app payload and the only thing that we're going to be passing in here are params matching the pink params in other words in this case just a run ID now the reason that we're only going to pass this in is because whenever we return this payload the function name is always going to be equal to speed test functioning.ping and the params those are just going to be set to whatever params that we passed in and for the process ID is speed test registration the app ID right there all right and this can be our default export all right so there we go this is uh looking good for our ping payload function and now let me go ahead and pretty much write the exact same thing for the pong payload and we'll just copy this Place ping with pong and then for uppercase ping replace it with uppercase pong now last but not least just like kind of our standard convention gonna create an index file and Export both of these into here and that way whenever we use these in our components then our Imports are just a little bit cleaner so we want to import first ping payload dang for pong payload King and Pawn all right beautiful now just like we wrote those helper functions to generate these payloads what I also want to do is write helper functions to generate these blocks and that's just going to make it a lot more clean whenever we work with this in our components so let me close all this make a new directory called blocks and we're going to have two blocks which is the Ping Block in the pong block so start with the pin block and import everything I need to and this is just going to have one function and I'll say ping block comes pin Block in the default export all right so this ping block function will pass in an object and let me type out the interface right now so the interface I'll just say ping block just make sure that we pass in all the correct Rams so whenever we generate a ping block or in other words send a ping block to another device we need to give it three pieces of information the first one is the network ID which network are you going to be sending this over the other one is the recipient which is just the account number of the receiving device and lastly we need to pass in the bramps and these for this are just the pink params so now we can say actually let me do this ping block and just the structure right here so network ID params and recipients and actually since this function right here it's not only going to generate the Ping block but actually send it over the network what we can do is make this an async function because we're going to be awaiting a nested call in here now before we even start writing the block structure what I want to do is say const I want to get a property from the system called self and this refers to basically the self account in other words my account on this device and the reason that I want this is because whenever we generate that block we need to sign it with our signing key so that signing key is stored in this self property right here so we're going to be using that in just a sec but for now what I want to do is Define where you're at right here so we're going to start defining this block structure and what we're going to do is we're going to Define all of these uh properties aside from signature because signature is going to be generated in a different kind of way so let me just do that right now so data this is going to be equal to an unsigned Block in other words a block with all these fields excluding the signature so the first thing that we need to do is specify an amount and this is just always going to be zero and then for the ID remember I said that we need a unique uuid and instead of writing our own function for that there is this function right here from the crypto Library random uuid gonna give you a new one each time now for the payload for this we are going to take that function that we just created ping payload helper function and remember this is just going to accept the Ping params and those are these params right here now after this we just need to specify the recipient which is the receiving account number the sender that is on self dot account number basically my own account number and for the transaction fee we just created a constant for this core transaction fee since it's always just one so let me clean this up in art so once we have our unsigned block what we need to do is add the signature to it and we created a helper function for this as well which is block sign data and what do you want to sign well this data right here this unsigned block and as the second param what we need to do is pass in the signing key that we want to sign in with and that's just self signing key so again this self is an object that consists of my account number in the related signing key so there you go so the only other thing that we have to do now now that we have that block signed is just send it over the network so to do this I'm actually going to return a function called create block and you can see that it takes a block and the network ID basically saying what network do you want to send it over so the block is of course just block and the network ID is equal to the network ID that we pass in and just to look at this real quick again all this does is it takes a block which we pass it in and it sends it over this network that's it so now that we have that taken care of for the Ping block I'm going to go ahead and copy this and pretty much just need to do find and replace to say pong to replace ping with pong uppercase and then ping with pong just like that and there you go so now that we have our two block generator helper functions as always just go ahead and make an index file ping block import block and Export these bad boys ping and pong block all right so now that we got all our helper functions written we can finally hop back into main button and start hooking everything up or it's everything I'm gonna need and all right so again what is going to happen whenever you click this go button is it's going to send a block to this account on this network and that is our active account number and Active network that we're going to need to pluck off so const active account number and this is equal to that slice of get active account number and same thing for the Active network ID so get back the network ID and then aside from this we're also going to be dispatching that run to our Redux store so for this we need to use dispatch and this is equal to use dispatch type of this is just our app dispatch and the other thing that we're going to need is that use is connected hook use is connected and remember we use this for our connection status right here but the reason that we're going to use it in this main button is because if we're not connected then we want to just make sure that this button is disabled so on that note what we can probably right now is that uh on click Handler so what happens whenever you click the button I'll say and we'll click and since this is going to be sending a block we'll make it an async function and all right so first of all I want to say that if you are not connected then we can just go ahead and return and then the what I would actually want to do after this is this I want to go ahead and generate a run ID and run ID this is just going to be equal to crypto.random uuid and now that we have that right after what I want to do is I want to generate this run and dispatch it to our Redux store so I'm going to dispatch a new run and for that I'll say set run now the shape of a run let me just go ahead and see what we need to create a run actually you can probably just do this copy all these params and just replace them so the network ID is going to be equal to our Active network ID and this is probably going to give an issue because it's Active network ID right here it can be a string or null however we are going to say that we definitely have it because if we're not connected in other words if we don't have a network ID then we're not going to be connected so this logic is never going to run so at this point we can guarantee that we have it now for the recipient this is going to be the active account number now for the request dates we can use this utility function right here current system date and I'll show you what this is going to return basically just a date formatted in the standardized format now for our response date this is going to be no because remember whenever we first generate this run we're going to send it off to the other device but we're not going to of course have a response at that time because we don't even know if they're going to respond so set that equal to null this is going to be set whenever we get a response of course now for the Run ID it's just the same as this run ID right here and for the status this is going to be equal to run status pending so pending by default and then depending what response we get back it's either a success or timeout so clean up all right so whenever we click this button what we'll do is we'll say on click handle click so you click the button what happens it generates this run stores it in our Redux store now right after that we'll go ahead and send out that request and remember that function was called ping block and if we take a look at this interface we'll see that it requires a network ID and this is just going to be equal to the Active network ID the recipient active account number and for those params those params are just the Run ID so now let me just go ahead and pretty this up remove this and our right now to test this out I do need a connection so I'm gonna go ahead and open my MacBook right now and I'm booting up tmbos and sweet now that we are connected let me go ahead and hop in my network tab that looks good and clear this out and hopefully when I hit go sweet all right and you saw that invalid block receive error message and that's because we didn't write the logic for my MacBook to actually understand what the heck that block was so it's probably sending uh Becca error message right now but uh before we even fix that what I want to do is fix this little situation right here because the logic that we want is if you are not connected then I want to just make sure that this button is disabled since you shouldn't be even allowed to click this or it shouldn't even look clickable if you don't have a connection so do that back in my component is and the Styles follow I'll go ahead and add in this disabled mixing CSS and what this is going to do is just add some disabled styling to the button and to actually accept these I need to pass in some props to this container and I'll just say I'll have it enabled prop and right now we're probably going to need to make some adjustments to this but we'll just say it's enabled in other words this button is enabled if you are connected and now what we can do is say for this Boolean I forgot my curly brackets all right so this is going to accept an enabled prop in with this what we want to do is just say with this enabled prop we will say that if you are not enabled then go ahead and render this disabled mix in clean this up and all right everything looks good so check it out all right so this is pretty cool so I am not I'll show you what's going on right here so right now I am connected to my iMac but I'm not connected to my Linux desktop so you can see I have Linux desktop I'm trying to connect you right now it's good this go button is disabled however whenever I choose my iMac everything is connected and then I can then send the request of course uh my iMac still doesn't understand what the heck data is receiving so it's sending back an error but uh yeah there you go the basic block structure is working and also this is the very first time where we are now sending data to another device and it is sending data back even though it doesn't understand what that data is at least we have something up and running communicating pretty cool checkpoint so in the next video what we'll do is we'll start working on this timer right here get this up and running and then the history table from there so yeah making some sweet progress here see you next video