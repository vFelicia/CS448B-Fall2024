already y'all welcome back and in this video what we're going to do is we're going to set up a very basic CI CD pipeline in a way that whenever we merge any code into our Master Branch then that code is automatically going to be deployed to our server so that way it prevents us from having SSH into our server pull down update everything yada yada it's going to save us a bunch of time however before we just go ahead and get started what I want to do is I want to give you a high level overview of kind of what we're going to be doing so the steps that we're going to be doing is I'm first going to make a unique SSH key now with this SSH key I'm of course going to be storing the public key on my server and for the private key I'm going to configure it to be stored in GitHub and what that's going to allow is GitHub the ability to communicate with my server and once we have that set up then we can go ahead and make a workflow to deploy everything but pretty much set up the communication first and then get into the good stuff so whenever you create a new SSH key I'll show you the command right here so pretty much saying that we want to generate a new SSH key these are just some of the settings for it and the file I don't want to just have it override my default one that I always use so I'm going to call this SSH GitHub now whenever you create this make sure not to include a password if you include a password then while your automation is going to break because well it's going to require someone to manually type in a password so go ahead and just hit enter to use a blank password or no password however you want to call it enter again and there you go so as we can see we now have our SSH key pair created and this one right here is your private key and this one right here is the public key that's going to be stored on the server so it doesn't really matter the order that we do this in but let's go ahead and first I might as well just set up GitHub to store this private key so how do we do that well in our settings what we can do is scroll down here to go to secrets and variables and click on actions right here and we're just going to make a new repository Secret so the name of the secret I'm just going to name it very clear SSH private key and for the actual value of this what we can do is we can just cat out this so here I can clear this so cats this and there you go and by the way even though um what just got logged out it says beginning and then it has your key and then an end make sure that you actually include these lines right here not just the stuff in the middle but the actual line that says beginning and end so I'm just going to copy this and paste that bad boy right in there beautiful add secrets and now we can reference in our workflow this private Key by using SSH private key so now that this is taken care of what I can do is let me just go ahead and do this in a new tab I'm gonna SSH into my server Ubuntu at and that's my IP and all right so what I actually want to do is just cat out this public key because we're going to be using that in just a second so let me clear my screen and log this out so this is my public key I'm going to go ahead and copy that now to add this to my server what I do is I'll just use Nano sudo Nano and it is in ssh in authorized keys and that's the one by to use that I use by default so right under here I'm just going to paste that new one in and save the file so now my public key is on my server and I believe we can just close this out now clear this and yeah pretty much good to go so before we actually write this workflow there are two other little things that I need to do let me pop open GitHub again click the right thing all right so you know how we just added this private key right here what I also want to do is I want to add two more secret values one for the host in other words well I might as well just do it it's probably easier that way so I'm going to create a new secret and this is SSH host and for this I am just going to give it my IP and then I'm going to create one more and this is SSH user and this is just the user to log in so whenever I log in I said SSH Ubuntu at that IP address and this way I can just use variables instead all right so now we got all of our secrets configured and yeah I think we are ready to start writing this workflow so how do we do this well remember in workflows what I can do is since this workflow is going to be triggered whenever I merge code into master I'm just going to create a new file called master.yaml just like that and for the name of this I am going to say continuous integration now unlike before where we trigger this on pull request what we want to do is trigger this I don't really have to explain it kind of selfexplanatory on pushes to the branch master so anytime we merge code into Master this workflow is going to get triggered now another thing that I want to do let me paste this in first is what this is basically saying is that if you just merge code into master and this workflow is in the process of deploying and then let's say that right after that you made another merge into Master like right again well in this case we don't want like these two separate processes deploying code at the same time so what this says is if there's any of these workflows already in progress then just go ahead and cancel that and that way the second one is the one that actually gets deployed so in other words it pretty much makes sure that only one of these workflows can run at a time even if you do two merges right after each other now for the jobs unlike before where we only had one job which was the quality assurance here we are going to break up this workflow into two separate jobs now the first job is going to be that quality assurance job in other words it's going to be this workflow because before we deploy any code what we want to do is we want to run this again like I said in the last video just to double check make sure that our code is properly linted and properly tested so before anything happens it's first going to run this workflow and again this is how you run other workflows within a workflow pretty much just give it a name and say uses and and then a path to the workflow and then after this which hopefully this workflow passed after this we are going to write one more job which is our deployment process so we are just going to give it the name deployed and this needs keyword is going to reference this job right here so this is pretty much saying that unless this past then don't continue in other words we need this to succeed before we can deploy now for this deployment process we are going to be setting up of course the commands to actually like ssh in and do some other stuff like deploy the code and for this we can just run it on in Ubuntu environment and what exactly do we want to do in this environment well this process is going to consist of two separate steps the first step is configuring just our SSH make sure that we have everything set up to connect and then the second step is actually running to the command to deploy and update the code and what this means is we are going to change into the directory where our app's at we're gonna take down whatever's running with Docker composed down we're going to pull the latest updates and then we pretty much just uh rebuild and spin everything up again so for the first step of configuring SSH let me paste this in and then I'll kind of talk you through everything so the name we're just going to call it configure SSH now what we need to do is we're eventually going to be running this command and I'll talk you through what this does in a second however this command is going to require environment variables so in order to get these environment variables what we can do in the easiest way is just to reference the value that's stored in GitHub and whatever that value is just map it over to an environment variable with the exact same name so this is pretty much taking a GitHub secret and converting it to an environment variable that we can use in our commands and then once we have those environment variables that we can use we're just going to run this Command right here so this is actually multiple commands but what this is doing is first and remember this is all happening basically in a blank version of Ubuntu so we're first going to make this SSH directory since that's just where the uh private keys go and then once we have that directory made we're just gonna take the value of whatever was in this environment variable and stick it in this file right here which is SSH GitHub in other words we're just creating our Simon key file now this line is just changing the permissions of that signin key file and then last but not least we are running this Command right here so this is a little bit strange if you've never seen that syntax but basically what we're doing is we are marking the beginning and the end of this bit of code which is pretty much saying we are making a new host called Target and this host is pretty much our servers address this is going to be the IP of our server the user this is going to be Ubuntu the identity file in other words the signing key that they're going to use is that one that we just created right here or not the signing key the private key I was thinking of my app logic um the log level just log out any errors and the strict host key checking you know whenever you first sha SSH into a server and it says Hey the server identity yada yada and you've got to manually type yes well what this does is it just says hey don't worry about that uh we're not don't bother us with having to type anything just uh go ahead and you know skip that part so anyways this pretty much just configures um the where we want to log in and how we're going to log in and then with this bit of code right here we're gonna cat or pretty much like display it out and then this redirect directive pretty much just sticks it or appends it to this SSH config file so in short we are taking this text and appending it to this file so now whenever we SSH into the host Target it's gonna pretty much know exactly what system we want to connect to and how we want to connect now with that said we only need to run one more command let me go ahead and paste it in and that is this command or this one last step I should say so this is just going to run our actual deployment and to run our deployment what we do is we're just going to SSH into this target in other words SSH into my ec2 instance and now once we're sshed in we pretty much just write the commands that we would normally do if we were just like uh you know already ssh in there and updating the server and of course do that what we need to do is we need to change into the cooking core directory that's where the app is now after this we're going to run Docker compose down and that's going to bring down those containers remember we're going to have one for the database and we have another container that the app runs in now once those containers are down we're going to pull down the latest code and remember at this point in time everything was already merged into master so this is like brand spanking new code the latest um changes that you made to your app and once we have the latest changes we're just going to run Docker compose build to rebuild those images with the latest code and then once we have everything built then we can go ahead and spin up those containers using Docker compose up run it in Demon mode and then we're just gonna make sure that we have everything recreated and yeah get all the latest stuff so let me actually just add a blank line to the end of this and now as soon as I push this up since I'm not on any other branch and I'm just pushing right up to master this should actually kick off this uh CI process so let me just go ahead and push it up and I can say testing CI CD and let me just commit and push that and check it out so now let me go in my actions and you can see that yes this new workflow is running and I want to view the details of it so I'm just going to click into this and this is how it's displayed if you have multiple jobs so the first job that we have if I reference back here is this QA job would actually references this right here so it's going to check all my linting and testing and if that succeeds then it's going to go ahead and run this deployment script and as long as I didn't mess anything up it should automatically deploy that so let me pop this back open all right look like everything past QA now we can see if our deployment process is working actually let me click into this SSH configured properly running deploy looking good wow pretty quick so this looks like it was all good to go and we can verify that actually if we go to the taxi at net admin so it looks like we're getting error but this is actually good because well errors aren't good but whenever I update my server then right after what it does is it has to of course restart Docker and restart nginx so this just means that nginx is restarting now the nginx process should restart and like um I don't know 10 seconds or so so as long as I refresh that I can see that yes everything was deployed and restarted successfully so that ladies and gentlemen is how you set up a very basic CI CD workflow now another thing that I want to point out is that even though this is indeed a Bare Bones working CI CD pipeline this isn't like the ideal process and I say that because remember whenever we deployed this even though I was kind of happy whenever I saw that nginx error you probably don't want like a production environment throwing these errors and we'll talk through some Solutions on how we can get around that and some tradeoffs between different deployment processes but for right now I think that's enough for this video we are now getting more familiar with GitHub actions and CI CD so yeah in the next video let's see what we got to cover so we're going to be spinning up RDS postgres database and then we're going to be using multiple instances and setting up a load balancer to distribute the traffic across those instances and then getting into some monitoring and debugging tools as well is going to be fun so yeah thanks for watching and I will see y'all next time