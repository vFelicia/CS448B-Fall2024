alrighty y'all welcome back to another video and in this one what I'm going to be doing is updating the functionality for this timer component however before we get into that I want to mention a few changes that I made between the last video and this one the first one is you may already notice it I added some styling to this history table so you see I styled these statuses and just formatted some things right here and again this is all CSS so I didn't really feel like I wanted to record it because I don't know it just felt like I wouldn't be teaching you anything new and there is one more change as well pop open my source code in addition to this use pending run which we wrote I think in the last video which basically gets the most recent pending run as you can tell by the hook name I also wrote this use latest run and as you can see right here all it does is it Returns the most recent run and if there's no run for example you first boot up the app it's just going to return undefined so again like the history table it's pretty similar to the code we wrote before so uh yeah just wanted to save you all some time but anyways on that note let's go ahead and pop open this timer component and before we start writing any code let's just go over the logic of exactly how this is going to work so the way that this is going to work is first whenever you first boot open this app for the very first time of course you're not going to have any runs at all so at that point in time I want to just set this equal to zero now whenever you click this button and you send off that request you are going to have what's called a pending run AKA a run where you haven't received the response yet now of course you can probably guess what we're going to be doing for the timer right here whenever you have a penny run this is just going to display how long that run is taking kind of like a stopwatch it's going to be updating in real time so that's the easy part but a couple unique situations that we have to look out for is this first of all if we ever get an error whenever we click this button then what we're going to do is we'll just reset this time to zero zero zero and again we'll have an error hopefully we don't get it ever but if we ever send this request and that server that core server is down or I don't know maybe we formatted the Block in the wrong shape or something then we'll just go ahead and reset this to zero and the last kind of weird situation is well it's not even that weird but what we'll do is whenever we have a pending run and it exceeds 10 seconds then we'll consider that run timed out and for this time right here we'll just have it set to 10 seconds basically saying that this is maximum amount of time the timer won't ever exceed 10 seconds now the last situation is whenever our run comes back so it's no longer pending but we then have a successful run then what I want to do is just display the time of this last successful run right here so it sounds like quite a bit of logic but it actually should be pretty simple in our code so let's just go ahead and get started first thing let me go ahead and import everything that I'm going to need and after this what I'm going to do is I'm just gonna make a constant for that timeout since it's never going to change timeout seconds will always say that the timeout is 10 seconds and now let me just go ahead and write some things that we're going to need so for this value right here we'll have this in a state variable and I'll just name it time keep it nice and simple so const time and we'll set it with set time and this is equal to use state and we'll initialize this to zero off the bat and then this is of course a number type that and all right so another thing that we're going to need is dispatch and please just copy this too lazy to type one sentence so we're going to need our dispatch statement now the reason that we need this is because if our run ever times out then we'll just go ahead and dispatch that updated status to set it to run status timeout right from here and then from here what I need is that latest run you can remember I said that I wrote the hook in between the last video and this one and of course this is because whenever we have a successful run we're gonna be displaying the time from the less successful run right here and then the last thing that we need before we get into the good stuff is just our runs and I'll say use selector and that is get runs and the reason that we need this is because we need to be able to listen for when the runs change because when the runs change we want to be able to say something okay I have some errors but we want to be able to say like whenever the runs change if the last run was successful then go ahead and get time and set the state to that time right there so sounds a bit tricky but I'll break this up in this kind of way I'll use a use effect statement and I'm going to be breaking up the logic in two main chunks the first chunk is dealing with a pending run and this is a little bit trickier I would say because we have to update that timer kind of in real time now the other use effect chunk of logic this is going to deal with everything but a pending run so again whenever that run comes back as either an error or we timeout or it's successful we want to be able to update that timer based on that logic so again one chunk for the pending run one chunk for everything else so for the pending run let me do this I'll say use effects and for the logic for this the first thing I'm gonna do is I am just going to check if the excuse me if the latest run status and again I need this question mark right here because we actually don't even know if we're going to have a latest run for example whenever we first boot open the app we're not going to have any runs at all so I'll just do latest run question mark if we do have one check the status and see if it is not equal to run status pending and for this I'll just go ahead and return so the logic in here like I said this is going to be all dealing with the pending run so if we don't have a pending run we'll pretty much just bypass this entire logic now if we do have a pending run then of course what we want to do is basically update that timer in real time so in order to do this what I'm going to do is I'm going to create an interval that's going to run every 10 milliseconds we can have it run like probably every single millisecond but I don't even think the human eye can you know tell the difference of all those so I'll show you exactly how this is going to work right now so I'm going to create an interval and this is going to be equal to set interval and this would just be an anonymous function that is going to run every 10 milliseconds now before I even write the logic for that what I want to do is just make sure in this return statement right here that we are clearing that interval so I'll say clear interval interval right here and this is just part of the react logic and use effect this hook right here whenever you have a return statement it's automatically going to call this function to uh yeah pretty much just a cleanup function and on that note let's go ahead and hop into this set interval logic and we'll write the meat and potatoes of everything so the logic that I'm going to write in here is this every 10 milliseconds we essentially need to calculate the updated time that it's taking this request so in order to do this what I'm going to do is first since I want to calculate everything in milliseconds I'll say MS difference and this is equal to new date dot get time and this new date is essentially equal to right now in this get time just allows us to work in milliseconds rather than like a string formatted date or anything like this so from right now this moment in time what I want to do is subtract the latest runs request time so this is going to give us the window in milliseconds that that run is taking and just because on our UI we display that in seconds I'll go ahead and convert it right now so to convert it into seconds we say Ms difference the modulus operator 6000 or zero and then over one thousand again this is just because this is how many milliseconds are in a minute so on that note this is gonna basically allow us to work in seconds which is going to make everything much easier because with this the first thing that we want to check is is the time that this request is taking in seconds first of all does it exceed our timeout amount is it taking longer than 10 seconds if so what we want to do is just set this run status to timeout now to do this what we could do and this is probably going to work basically all the time what we could do is take this latest run right here which is pending and we'll just update it in Redux to be run status timeout instead of run status pending however just to kind of handle any weird edge cases for example if we have a pending run and we shut down tnbos or maybe for some reason our data got messed up and we have two pending runs what I'll do instead is I'm just going to update all pending runs to timeout now again I don't think this is ever going to be needed but it's just a weird Edge case where most of the time this is just going to update this one pending run but it'll help clean up any old data that we have and to do that I first need to get all the pending runs which like I said most of the time is just going to be equal to one run but object dot values I'll go ahead and get those runs and then I'm just going to filter those were the status Those runs pending right there so again this is going to give us all of our pending runs and now for each of those just iterate through them and we'll say for for each of those I'm just gonna dispatch the set run if I import this hopefully and for this we can just spread out the run and update the status to be run status timeout just like this and this should be a comma and all right so again usually in pretty much like a hundred percent of the time this is just going to be timing out this one latest run but like I said just to cover all of our bases might as well clean up any other ones as well and then last but not least what we'll do for the timer is we're going to set that equal to this timeout so I'm going to say right here set time to time out seconds all right so again that block of code was how we're gonna handle if our pending run exceeds 10 seconds however if it doesn't then all we need to do is we need to set the time on the timer equal to this value right here however many seconds it's taking and then to finish up this hook all we need to do is set our dependencies and then there we go and actually for this latest run we'll just put a question mark right here because we can't ensure that we actually do have latest run but once we do it'll pass in the request time the status and the runs and yeah logic looking good so again this is going to take care of the pending runs now I just need to write one more use effect statement to pretty much handle every other run aside from pending around so use effects let me just go ahead and write the boilerplate so again in here what we're going to do is we'll look at the latest run and if it's not pending we'll say if it's an error then we're going to set the time to zero if it's a timeout then we're going to set the time to 10 otherwise if you have a successful run then just display on that timer the time it took so I'm going to write logic in here to say if you don't have a latest run we can just bypass this and also if you do have a latest run but the status of that is equal to run status pending then we can just go ahead and break out of this early no need to uh write any code in here and then we can just start handling all of those cases so first if the latest run status is an error so run status error then what we want to do in that case we said is set the timer to zero and then we can just return because below here is just checking for those other statuses and I can just copy this too so this is what we're going to do in the case of an error now in the case of a timeout if that run was timed out then what we're going to do is set it equal to 10 and just to make sure if we ever change that timeout then we don't have to go back in here and change it again I'll just use that constant timeout seconds now lastly this is the case if we have a successful run because again we're breaking out for a pending run an error and a timeout so this logic is only going to fall through here for a successful run and just like before what we're going to do is set the timer equal to how long it took so we need to calculate the milliseconds from this and to do this it's the latest run dot response time and I'm also going to have the exclamation mark because the response time is actually as you can see it's a number or null now we can guarantee that we have a number here because for every successful run we always have a response time so that's why I can safely add this exclamation mark and then for the latest runs response time to get the actual time of how long that took you just subtract the latest runs request time and that's going to give you the period basically how long it took and from here we just have to convert it to seconds so to do that the same as this one actually so milliseconds to seconds to just like I said before modulus 6000 over a thousand and then last but not least we just need to set the time in that State variable right here and let's say my dependencies that's the only thing we need passing the latest run and last but not least what I need to do here is actually instead of displaying our temp data we are just going to display that time that we've been setting again the set time is equal to or it's setting the value for this variable right here and also I want to make sure that we always display three digits so I'll say to fixed three and this is going to give us our millisecond accuracy and I believe that that's the only thing that we need to do let me just clean this up here so I have speed test store get runs in sort this you got to make sure all my imports are nice and clean and now let's go ahead and test this thing check it out all right so this is looking pretty good already because my latest run in Redux was 0.895 seconds and it is displaying the time from the latest successful run that is what we wanted now let me just go ahead and all right it's looking pretty sweet uh I actually let's do this just to test the timeout so these successful runs this is pretty sweet all right they're appearing successfully however I want to purposely time something out and the easiest way we can do this is just gonna go in the listener and it'll save for that pong listener which is the response this is whenever we receive a successful response we'll set it equal to success I'll just comment this out to kind of like simulate us never receiving our response at all and then hopefully this should time out so all right pop open redox all right pending pending latest round of spending and this button disabled state is working good too should be able to click it while we have a run pending all right beautiful so this is our proper timeout status again this should display 10 seconds that's exactly what we're going for so now let me just go ahead and revert my code and all right looking good and again sometimes whenever I update the source code this Redux tool kind of is like uh gets a little lost I guess so I just need to close the inspector tools or the dev tools and pop that open again you don't have to close down the entire app but there you go all right so I guess our record so far is 0.337 seconds pretty fast and by the way just for kind of reference I'm in New York City right now uh both my iMac and my MacBook and my core server is in Oregon so both the request and response are both going through the Oregon server so yeah not bad time and uh okay in the next video and now that we have that taken care of what I'll do is probably just clean up a few things maybe add some custom font but I mean really we got our working app it's just uh all improving it from here on out so good job everyone and I'll see you all next time