all right welcome back so in this video we'll create a patch endpoint using spring boot so here i'll actually have to correct myself from the past few videos where i mentioned that we'd be using a put request and you will see this quite a few times in some apis where put is basically used to update a resource however what i found is that more correctly you would use a patch request if you always want to update an existing resource and put is more correctly used if for instance you want to create the resource or the object if it doesn't already exist so kind of like the post request but really if you want to only update existing resources and only update certain fields of it so making partial updates a patch request is the better representation for this so that's what we're going to do here we're going to use a patch request and so what's going to happen here is if we let's say create a bank with this account number and then we make a patch request that updates the transaction fee and the trust we want the service to update the data so that if we now retrieve all the banks you can see here it has been updated with the data that we provided now also it depends a bit on how you want to design your rest api oftentimes you would use the identifier here as a path variable so in our case that could be something like this and then you only provide the data you want to update in your request body however here i've decided to actually move it all into the request body so that we have again the same kind of bank object in the request body and we read our identifier which is the account number from the request body so so much for the rest api design and why we're doing what we're doing so now with this out of the way let's go into our ide and start implementing this so as you can probably imagine i'm going to start again in our test case so here i am in the bank controller test and in here i'm going to create a new nested test class just like we did before and i'm going to use patch slash api banks as the display name and then the class name should be patch an existing bank all right and so in here i'm going to create my first test case and i'm going to scroll down here a little so this should update an existing bank first of all that's the happy path so let's say given the account number one two three four when we now make a request a put request in this case to our base url and inside this request we're using a body so i want to do this for now this actually looks the same as in the post request so i'm going to look over here and i'm going to take the content type application json and also the content from up here and in fact i will need of course also a bank object not just the account number so i can also do it similar to how we did it over there so updated bank should be well some bank with an account number that already exists and then i'm going to update it using this trust and transaction fee so now i'm going to update the variable name down here and i'm going to store this as perform put or in fact we're using patch now so perform patch and then we say perform patch maybe let's say perform patch request and do a print and i'm going to scroll down again here and then we expect first of all that the status code is okay so this should be again the status code 200 indicating that the operation has been performed and this is all that we need for now so again we're going to go step by step and we want to get this test case to run first so now let's go ahead and run our test and then we should of course get our failing test again using the test driven development cycle with red green and refactor so we have our red test our failing test so now it's time to make it green let's also take a look why it's actually failing and of course you're expecting a status code of 200 so okay and here again we have the status code 405 which means method not allowed and we've seen this before so this means there is no patch method that's allowed on this url so it was able to find the api slash bank's endpoint it does exist but there is no patch mapping for it so let's go ahead and create that now so over here we'll create a patch mapping i'm going to call this update bank and from the request body again we get a bank object and we're also going to return that one for now and again let's keep it simple so we're just going to return the object that we get and we remember that this is of course not the proper implementation and then let's go ahead and run this test case again which should now work and let's also refine it a little bit so down here we not only want to expect that the status is okay all right so it's actually still failing let's take a look so we're still getting method not allowed and that's because i'm actually using a put request here so it seems like i forgot this again but of course mock can we see allows us to do patch requests just the same way all right and now it should run through so down here we want to assert that not only the status code is okay but also we have as the content we first of all have the content type which is again application json of course and then also what we can do and what i'm going to use to also refine the other test case that we have is in this content block we can also assert the entire block of content or json data that we get so inside the content block i'm going to use json and in here i can now use the object mapper to compare this to our updated bank object of course it's serialized version because what this endpoint should return is in fact just the updated bank data that we gave it if it was able to update the bank as it should so this is actually a now nicer way to assert this kind of thing so up here for instance in our post test case we can do the same thing so instead of asserting each property of the object by itself we can also remove this and then instead in this content block here assert that we have json data and that it's the same as the data that we gave it so here i think it's called a new bank and this should work just the same way so that's also one of the reasons why we like to have fast running tests so we can run them many times and we still know that they pass and then let's see up here well here we freely just made a get request you could also create a bank object here so the expected bank that you expect to be returned and then compare against that but i think this is fine in this case and then i think we're done refactoring the existing test cases so this is really just a nicer way especially if you have larger objects to just compare all of their fields all right so yeah as you can see this still passes because well we're just returning the original object that we get so now one other thing we can actually do quite easily is we can get this object back again so we want to get our base url slash our updated bank dot account number and then we expect that this will of course give us from our get endpoint that we already have now the same object so the object mapper write value a string of the updated bank so this way we now make sure that we did indeed persist the changes that we gave the service and that it didn't just trick us and just gave us back our original object and this way we can now properly test that we're actually doing what we should do and now of course this should fail because in our current patch endpoint we're not really doing anything and the same thing we can also do up here we can again just make requests to our get endpoint and this way we can quite easily assert that this works as it should so we should also do this in our test case for the post endpoint so again i'm going to say that the content should have the same json content after we've called the post endpoint all right and with this we can run the tests again and then of course the patch endpoint will still fail so in our controller we should now see what we actually want to do now i challenge you to do this on your own because it's really the same process that we did before for the post standpoint except that now of course we want to have a bank in the request body that already exists so the account number must already exists in this patch mapping whereas on our post standpoint we check that the account number does not already exist so it's really of course a different use case but it's really very similar so feel free to pause the video here and do this for yourself and then we'll see how you can do it all right so we'll of course create this method in our service create the member function which will also return a bank object and this will simply delegate to the data source so here i'm going to say also update bank i think that's a fair name for this function and i'm going to say return and then refactor this and convert it to an expression body and of course we go one layer down so on this data source we'll create this member function and on the interface again i don't want any implementation here instead i'm going to go into the mock bank data source and then in here below the existing implementations i want to add our update bank and now this one will first search for the current bank object if there is one and so we look through the banks collection and then we find the first or null which fulfills that its account number is the given account number and if there is no such element with this given account number we say again no such element exception and it's really also the same message as up here and then if there is such a bank which already exists then we want to say from our banks collection we just remove the current bank and instead we add our new bank so add the new bank and then we want to also return this one just because we decided that the endpoint should return the bank that it received alright so that should do it if there is already a bank with the given account number it will remove that and add the new one which is basically a replace and if there is no bank that has the account number we'll get our no such element exception so with this we can run our tests again and now the current patch endpoint test should pass all right here we go we have a green test now we can refactor anything we'd like to refactor but there is really nothing i want to refactor it now i think except that here i'm going to say again it should suppress the not used warning if the method is annotated with the patch mapping all right so now it's time again to test also the nonhappy path so i'm gonna go down to the patch existing bank and then we have another test case here and let me close this down for a second and then this one should also return a bad request if no bank with given account number exists so this is the same as for the get endpoint where if you have an account number let's say does not exist then that one should also return a bad request which usually indicates that there was something wrong with the data that you provided to the service and in fact i should again make this a bank object so some invalid bank where i'm using invalid account number and the rest doesn't really matter but it has to be the other way around so first the trust as a double and then the transaction fee and then again using our mock can we see when we make a patch request to our base url and as the content this time we provide this invalid bank first of all we have also the application content type so in here if we now provide the invalid bank with the invalid account number then we of course expect and again let me split this up so perform patch request and then we can say perform patch request and do a print and then we expect that we get a status code of a bad request and that's really it we can also say that we expect the content to be empty but for now this should suffice so let's see what happens and in fact since we have the exception handler in our controller this might already work but there seems to be something wrong with it so let's see all right so down here we have expected bad request so that's number 400 um in the http status codes but actually we got not found okay so let's see if we can figure out what's going on up here so could not find bank with the account number that looks good if we look into the controller and into our exception handler up here we have one for no such element exception and indeed it goes to the not found and this makes actually sense so in the get 10 point when we want to get data about a bank or an account number that doesn't exist that should be a 4 4 not found and i think actually the same makes sense even for a patch endpoint so i think this mapping is actually fine and we should instead fix the test so instead of assuming we get a bad request i think not found is even better and then it will also say could not find a bank with this account number that was provided in the request body so here it's really i think a matter of fixing the test so sometimes you have to think about well first of all what you're testing but then also the question is always who tests the test and really it's of course your decision or if you have any requirements then you know what the response status should be here i think it's not found is even better than just a bad request alright so this is looking good let's go ahead and start up our application here so we're again up on port 9000 so let's switch to postman now over here if we get all the banks of course we start out with our three banks that are hard coded in our mock data source and then if i post a new bank over here we get of course the same bank as a response currently with a trust of 80 and a transaction fee of 10. so now let's see if we make a patch request with the request body being the newer bank having the same account number but new data we expect that we get first of all the same data back we get a status code of 200 and if we now check what the current status of our banks is we see we have this new bank and it also has the updated trust of 85 and the transaction fee has been reduced to 3. all right looking good so now all that's left regarding the rest 10 points that we have planned is the delete endpoint so that's what we're going to look at in the next video if you like this one and you learned something from it please leave a like below check out the links in the description and please let us know in the comments what other tutorials or topics you'd like to know about or learn more about and then i'll see you again in the next video