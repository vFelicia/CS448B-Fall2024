what up y'all welcome back to another video and in this one we are going to be talking about how to set up a Django project and I say setting up a Django project because we actually aren't going to be talking about Django itself too much as far as you know uh view serializers migrations all of that stuff not so much that more so just the structure of you know um organizing your code managing dependencies dealing with settings across multiple environments um linting testing logging dockerization deployment pretty much all of the stuff around the application or business logic because I don't see too much content around that and well I thought it would just be a cool little tutorial so let's just go ahead and get started and jump right in so I'm going to start by just creating a blank Django project so I'm going to navigate to where I have all my projects on my computer and that is desktop in a folder called projects and the first thing that I always do is use Django admin and by the way I assume that you have like a basic uh understanding of Django if you're watching this tutorial um probably not the best series to watch if this is your very first introduction to Django unless you just want to you know stick around and hang out with us that's cool too but anyways Django admin you already know how to start a project now typically what you want to name your project right off the bat and this is going to create a folder with the same name is you know whatever your application is like um putting website or you know bacon or whatever however what I do is no matter what I actually want to call my project whenever I push it up to GitHub and you know share it with the world I always Kick It Up by naming IT project at this stage right here now you're going to see why I did that in just a second however just note that this is going to create a folder called project however I don't want the name of my actual project to be project so right now I'm just going to rename that in the way that you can rename things right in the terminal is just um basically move project to the new name of the folder so I'm going to call that directory core tutorials so why did I just create a folder with all this stuff in it and then I just renamed it right after well check it out go ahead and open this up in any IDE of your choosing and I'm going to be using pie charm all right so check it out I opened this directory in my IDE and nested under it is still this folder right here called project and also the reason I created this by default and then renamed it is because when you rename it only this changes nothing else and I say that because if you look at how the rest of the project is set up it's set up exactly how I want with all of these like core settings nested under project and Django also sets up a couple other things you see it says project right here and I believe if you go to your settings there's some other things like the root um URL configuration is project.urls it basically sets everything up uh like I want it to nesting everything under project while allowing me to keep the top level folder exactly as I want but either way I won't dwell on that too much uh what do we do next so the very first thing that I do right after this is I create my git ignore file so dot get ignore there we go and the reason I do this off the bat is because I like to push up my project to GitHub pretty early even if I'm just working on it myself just because I don't know github's a nice total manage code and there have been a lot of times where I forgot to do this get ignored like maybe I'd had to read me or something then push it up and then a bunch of my files that I wanted to ignore are like accidentally committed or pushed up I'm like okay how do I remove my project files from uh git but still keep them locally and yada so uh moral of the story is just go ahead and add your ignore super quick and like I said I just copy over the most recent ignore from my previous Django projects so that's what I'm going to do now and I know you guys didn't see where I just copied that but I'm going to be sharing this on GitHub so you don't really have to like um create all of this line by line I'm not going to be going through this line by line because what this uh getting more file is is basically a template that I found for python or Django projects or something and then I just added a few things my own but this is pretty much standard where any Django project as long as I add this it like covers like 99 of what I needed to maybe we'll add some other things um you know in the future but for right now this is fine so like I said by the time you're watching this this will be on GitHub but uh yeah there you go let's go ahead and hop on to the next stage which is creating a readme file so I'm going to close this for now just create a new file and I'm going to call it read me now a lot of you are probably familiar with markdown however what I'm going to be using is an rst extension so readme.rst and what rst is is it's very similar to markdown actually but it's it stands for restructured text and the differences between restructured text file and a markdown file is that restructure text has some benefits when it comes to writing technical documentation and we're going to be taking a look at some of those benefits later on but for right now we don't even have a project so there isn't too much that we can do with the readme I'm just going to add some quick placeholder text in here for now and I'll say project setup in if you aren't familiar with any of the syntax don't worry just add some equal signs on the line under that again we just want to add a placeholder for now since I don't know it just feels weird being empty and I'll just say project set up instructions here all right so what does this equals uh you know what do we do after here don't worry about it for now we're going to be hopping back into this looking at researcher text in much more detail whenever we need it but for right now I just kind of want to skim through a lot of this and all right so we've got two files uh it's probably good to push up to GitHub now but before we do let's go ahead and just move on install some other tools that we need the first one that I want to talk about is poetry all right now whenever you type in Python poetry you're going to be taken to a site like this and just go ahead and follow the let's see where this is the installation okay if you go to what was that introduction and you just find installation then it's going to give you the most uptodate installation instructions and you can just follow this depending on whatever your system is again don't want to dwell on this too much I'm sure you guys can figure out how to install it if you haven't already and also I just wanted to uh say that you should be following the latest rather than you know whatever I show in this video but anyways what is poetry uh probably a good thing to figure out before we start installing this so poetry is a tool that allows you to do well quite a few things um it includes managing dependencies it allows you to run your project in a virtual environment it actually has a lot of other features and we're going to be covering those kind of as we need them however more of the story right now is that go ahead and make sure you have poetry installed and once you do terminal around a bit you can verify that you have it installed just by running poetry version and all right we've got poetry 1.1.11 looking good so how should I put this so if you're familiar with JavaScript you can kind of think of poetry right now is the npm of python or it's kind of like pip on steroids in a way I don't know it's a pretty unique tool but the first thing that we want to do and why I called it the npm of python is just like we do npm in it we can do poetry in it however instead of creating a package.json file what this is going to do is it's going to create a piproject.toml file so it's going to be a little interactive guide and we'll just go with the defaults now pack your name Court tutorials yeah version looks good author beautiful license for license we can actually type in MIT that might be the only thing okay and also for the compatible python versions instead of python 3.9 I want to do python 3.10 and what I like to know all right we can put no right here because I want to show you how to do this separately but really that's all you need to fill out just make sure you have MIT for license in 3.10 or actually whatever version of python you want uh nope I don't want to do any of this do you confirm generation yes all right beautiful so what exactly did we just do right there well as you can see we now have this Pi Project dot toml file so okay what is a pi project.tomo file so let me pull this up and show you so you can see all right so pipeproject.tomo if you've never seen it before again I don't mean to be making all these like JavaScript comparisons but I do know a lot of my viewers are familiar with JavaScript and uh npm so I figure it might be useful for right now you can kind of think this as package.json even though I don't want a lot of people to be yelling at me because it's not like a direct equivalent just right now for something to compare it to it's you know probably a decent comparison but we can really see the best description right here which is this file contains build system requirements and information which are used by pip to build the package so basically just that it contains system requirements needed to build our project basically so what other requirements are dependencies for our project it's kind of the uh quick and dirty of it and again there's more to this file than just listing what dependencies you need but for now we'll just um stick with that since that's kind of one of the main features of this file features of this file attributes I don't know however you say all right so we can see that right now python is a dependency we got some information about our project beautiful now the next thing that we're going to want to do is I'm going to run a command to specify some additional packages that our project is going to require so we're going to require let's see I know a couple off the bat I can't remember them all Django Django rest framework Django filter um you know a couple other things so in order to add those is dependencies you can write poetry add and let's see the ones I remember Django Django rest framework make sure I spelled that correctly uh we're actually gonna be using postgres so uh the package for that is Psy cop G2 I don't even know how to pronounce that and then all right Django filter there's some other ones but we'll be adding those uh later it's actually probably better that way since you know I'm just not showing you how to add Everything at Once of course as you're developing a project you realize that there's some other dependencies you need later on and can add them so either way I'm just going to go ahead and hit enter right now and when I do what poetry is going to do you see a couple of things so all right let's see if we can get some prompts all right python through nine not supported trying to find a compatible version uh creating a virtual environment that's interesting and then okay it looks like it's going out and grabbing those dependencies and installing them all right so that's pretty cool so now let's hop back in our IDE and check out our Pi Project Tamil and we can see that poetry did a couple things they added those dependencies uh to this file and it also created this poetry lock file huh this is interesting I didn't see this before so what exactly happened here well check it out whenever we ran this command poetry ad what it did is it not only added these dependencies to our Pi Project toml file but actually kind of in the background it ran another command right after in that was to install them so why did it do both at once and why would we ever need this command if poetry ad kind of like runs it together well whenever you just need to add a new package to your project or dependency whatever you want to call it then you can run poetry ad and it runs both however for any other developers working on this project whenever they pull this down from GitHub they don't actually need to add these again because they're already added to Pi Project tunnel they just need to go ahead and install those packages okay so they would probably run poetry install instead of poetry ad and that is correct but again what is this poetry lock file doing so whenever this poetry install command is Iran let me pull this down a little bit whenever this command is ran if there already is a poetry lock file then the developer is going to install these exact versions specified in this poetry lock file now if this poetry lock file does not exist let's pretend that it doesn't exist although I'm not going to delete it right now but let's just pretend it doesn't exist in a developer ran this poetry install what would happen is that poetry would read in the dependencies from this Pi Project that Tom will file hey actually there are cars beeping outside right now if that's like too annoying in the video then uh let me know and I'll cut them out but otherwise I never actually did this where uh I actually want to see how loud that honking is and if it's fine then I'll just kind of keep rolling with it but um yeah let me know and anyways let's get back on track here so if you run poetry install and there's not already a poetry lock file then it's going to go ahead and resolve all these dependencies and generate this poetry Dot Lock file so short summary pipeproject.tomo is really just a list of what packages your project needs and then poetry.lock is almost like the final source of Truth stating exactly which versions each of those packages are going to be included to ensure that everyone ends up with the exact same dependencies because even if two developers have the same dependencies but they have like a minor version different than each other these are some of the most tricky bugs to track down because that's when you get into well it's working on my computer but uh but not yours so as much as you can uh we want to end up with every single environment production uh local all of the different developers with the exact same packages to kind of prevent um a lot of these surprises so we can actually run poetry install right now and when you do it's it's pretty interesting because it says okay recreating this virtual environment and then it's it's trying to install everything again and that's kind of weird because well just like a minute ago I added everything and it seemed like I was installing it then and now I'm running poetry install kind of just to show you and it seems like it had to reinstall all those that's I don't know it's not sounding too efficient so check it out by default poetry is going to create its own virtual environment which is great because it does that to keep things isolated from your own system in other words whenever we install these dependencies it's nice to have them isolated and not install on like my Mac you know so poetry is always going to try to create a virtual environment and install the dependencies there however it gets a little bit tricky sometimes as you just saw in I actually had some issues with the past just by running it straight up and that was because it ended up I can't remember exactly what happened because well truth really truthfully it was like uh quite a ways ago when I was running into these issues but it was something like I had too many environments or I had trouble switching between the virtual environments like I said I can't remember however lucky for us there was a much better method that I found not really that I found just uh I don't know was reading about on their documentation and that's this if you go ahead and create your own virtual environment then whenever you run poetry commands then what poetry is going to do is it's going to automatically detect that you're already in a virtual environment and it's just going to use that one so let's just go ahead and do that in pie charm and okay so show you how to do it in pie charm if you go down to your project in Project interpreter if you click this little gear you can click add and we just want to create a new virtual environment and I'm not sure how to do it in the other Ides but um I assume that a lot of you are familiar with this so uh in pyterm this is how you do it and this looks okay and okay so now we can see that we have this new virtual environment and really that's all that we need to do for the time being like I said now whenever we run poetry install then it's going to detect that new virtual environment actually I think this may have okay so I'm actually gonna I need to close that tab specifically all right so I had a little mistake there I was already kind of shelled in to the wrong location not in my virtual environment but in pycharm release make sure that you actually close out of this tab specifically then when you reopen it you should see this little prompt right here that says pretty much an indication that you are now in your virtual environment and now I can demonstrate what I wanted to which is installing those packages and the cool thing is it doesn't say now creating a new virtual environment it looks like everything is just happening in the one that was already created so that's pretty dope and now let me wait till this is done installing and I'm actually just going to close out and try to do that one more time because I want to demonstrate one thing and that is now whenever you install it it's going to say hey pop them back into your virtual environment using that I see that you try to reinstall it you already had all these installed so no nothing needed all good to go so again that's just something I found was much more useful than to have poetry kind of try to manage these different virtual environments on its own but I did want to show it to you this way and kind of like do it that I don't want to say bad way but the alternative way first just to demonstrate some of those nuances that you might run into if you don't create your own virtual environment all right so now let's just go ahead and try to run this project and I got this little button in my IDE and check it out so here let me move this over here would be easier to see all right so it says whenever we click that all right it actually looked like things are working and let me pop this open and just make sure that all right so it looks like things are running correctly however huh so the first thing I see is we get this little migration warning so we have to deal with that so let me go ahead and stop this in another thing that I want to point out is that even though things uh appear to be working you know decently we really don't want to be running our project using the IDE and the reason for this is we want everything to go through poetry and by that what I mean is whenever you run this project we want it to run on poetry it not only our local environment but other developers environment and in production whenever we dockerize everything we basically want everything to run through poetry because poetry can keep everything consistent which is great because like I said we don't want any surprises at least not when it comes to programming now before we see how to run this project in poetry let's just go ahead and talk about the Syntax for running well anything using poetry so anytime you want to run something in poetry you type poetry run and then after is basically the command you would normally type so to run a python script is just Python and then you know uh whatever the name of the Python file is and for example let's say you're running Pi test instead of just running pie test straight up you can do poetry you run pie test yada yada but basically just remember that the syntax is poetry run and then your command so the command to run the app is python run actually what is it python manage that py run server there you go actually this is ironically a pretty uh good demonstration of the fact that I have trouble uh remembering these commands sometime so I believe it's poetry run python managed.py run server and okay so this looks like work still getting those migration issues but let me just pop this open and this was the new tab right here okay so apparently we can run it this way as well but well we did have that one issue where I forgot exactly the command so let me just go ahead and take another look at that okay poetry run python manage.py run server okay so I can probably remember this command uh going forward however I do know that they're quite of there are a few other commands that we're going to be using quite often for like creating super users running migrations running tests and well even though I could probably remember this command trying to remember all of those the exact syntax form it's is going to get pretty confusing so one thing that I know that I can do is I could probably create like some Google doc and paste all my commands in there and then whenever I need one I'll just copy it over and paste it in this terminal however that just it doesn't feel like the best way to be honest it doesn't even sound like the best way so a better method let me clear out my tabs right here a better method is creating a make file so I'm going to go ahead and create that it's called make file and okay looks like it already has an icon so well what the heck is a make file though so make is a tool used a lot in compiling software and it already comes with your system it's it's a Linux tool but actually the easiest way that we can probably understand uh what this make file is is kind of just to jump right in so this file is going to be made up of something called targets and under a Target you have your recipe right there so you can think of a Target as kind of like the function name and the recipe it just doesn't have to be one line it could be multiple lines you can kind of think of it like a function body although a lot of people familiar with make are like this isn't a function whatever whatever but uh um we'll see exactly uh what we can do with it in just a bit however before typing an actual useful mate command I do want to mention one other thing and that is another syntax and that is to the right of your target you may see some something called prerequisites and prerequisites are kind of like triggers that when the prerequisites change it can cause the recipe to be reran and I mentioned this last because we're actually not going to be using those prerequisites right now out and I don't want to throw too many things at you guys but I do want to just mention it because they're pretty cool in that make can detect changes in those prerequisites and keep track of whenever it needs to run this recipe again all automatically so it's a very efficient way that you can you know run complex commands or rerun complicated build processes and only rebuild the parts of your project that are necessary so it makes your build process a lot more efficient but like I said don't really worry about it right now um we'll be digging into those later on when we start dockerizing everything just didn't want you guys to get thrown if you see this you know little syntax looking at any make documentation or anything so anywho let's just go ahead and make an actual useful Command right now and in order to make a make Target or function command whatever you want to call it type in the name of it and this can be any name that you want I'm just going to call mine run server because what we are going to be doing is using it as a shorthand for this Command right here all right so I couldn't remember if it was poetry run python run or poetry run python manage.pri run server but lucky for me now I don't have to remember the syntax at all because anytime that I want to run this command all I have to do is run let me clear this out all I have to do is run make and then just make sure you guys can see make run server so again for a make file just make sure that you're in uh that directory run make Command and then the name of your target now whenever you do this you're going to see that it's the exact same thing is running this command it just allows us to have a much cleaner syntax so all right uh looks like this file is going to be handy learn a new tool make everything's looking good however we still have these migration issues and all right so let's close out of this for now since we've got that make file written all right so before we get into any more tools or project setups what I want to do is restructure the code base a bit and the reason I want to do it right now is because whenever we go and set up these um various tools those tools are typically going to like reference uh locations or actually files like lint this directory or this is where my project settings are so on and so forth so I like to get my code base structured early on because then you don't have to go back and like tweak all those uh file paths and whatnot so the first thing I'm going to do is I'm actually going to create a new package and this package is going to be a lowercase version of whatever your actual project name is so my project name is core tutorials however I am gonna kind of break my own standard and just drop off that hyphen tutorials because um this is really just to indicate that this is like a tutorials project however in a nonreal in like a real nontutorial project this is what I was trying to say uh we wouldn't have that so just to keep things kind of um as they would be in production I'll just name it core and now what I want to do is I want to move this project package which is the one that was created whenever it was created whenever we first started our project I want to move that in here and just refactor that and then also this manage.py so basically all of the um files that came whenever Django created that project for us I'm just going to scope it under this core and that's because I want to leave this top level directory mostly for uh like standard project files and Tool configurations and files referencing the various tools that we're going to be using I want to keep the application or business logic out of all this I don't want it all scattered in together so that's why I scope all of that undercore all right so if we actually try to run the project right now we're gonna get a couple issues and okay I can't find this file yada yada okay so basically what this is saying is since we moved all of those under basically to a new location there are a couple places in Django where we need to just update some things the first one is in this manage.py file and this is just saying uh the Django settings module is no longer in a package called project settings because in our top level we don't have project anymore is now under core.project.settings and also if you go under project settings.py let's see what we need to change here so first of all um since we nested uh this file under one additional package our base directory we just have to add another parent since we're we're kind of like one more level deep and now let's see what else needs change uh root URL config again same thing is over here too lazy to type five characters so that is now under core Dot projects.url and then I believe that there might be one or two more all right whiskey application just add core right there and okay so I think that's all we needed to change however um we will still get an issue if we just run this command still even though we updated all our source code and the reason for that is because in our make file what we said is this command says to run a script called manage.py and as you can see that manages that POI file is no longer in the same directory so in order to update that instead of running that manage.py we can say run the module if I can type and the module just different syntax is core Dot manage and that's where this is core dot manage all right so once you have those updated hopefully unless I didn't miss anything now when we run make run server yes we're selling getting these migration issues but we had those before point being is that now everything is updated and everything is working now that things have been shuffled around a bit good to go all right so now that that is looking good let me actually close out of this for now and I'm gonna be adding some more commands to this make file so you can go ahead and clear everything else out and all right so now I'm just kind of thinking through all the commands that I know 100 that I'm gonna be basically running uh quite often in this project the first one is to install the dependencies so I'm just going to call it install and I'll say poetry install essentially this is kind of what I what I tell myself in the head if in the terminal I'm using poetry a lot of the time and typing that in then I'm I probably want to make this uh make command so I know this is kind of of a weird way to think of it but it I don't know it just uh seems to work out and okay so install poetry install and now because I'm lazy gonna copy this and okay what's another thing well uh uh my grades migrate to get rid of those those uh migration commands and for this actually going to be copying this so the command to run those migrations is just migrate and then another command to actually make migrations so I'll just name this migrations instead of make migrations because we can run it this way like this make migrations but anyways this is just going to be make migrations and again uh the difference between these two just to skim on this real quick is that whenever you have a change that's going to update one of your models and in turn you need to update like your a database structure you're going to make those migrations basically does the equivalent of generating a bunch of SQL commands and then migrate actually runs those SQL commands against your database to actually do the updating so these are the instructions and this is how you actually like execute those instructions all right what else do we need uh run server uh create super user gonna be doing that so I'll call this command super user and we'll just say create super user and then uh let's see the last command I believe that we need for the time being is just a command that other um developers can use whenever they need to update their own environment so say that they pulled down a branch from GitHub and there are you know some changes maybe some new packages that got added and maybe some uh new migration files that they need to run to update their local database instead of typing all that and figuring it out we're just going to make a command called update now here instead of just tapping down to a new line and writing the instructions there's actually a a pretty cool I don't know what to call a trick a new syntax that you can use because well I want this update command to be is basically a combination actually I'll write it the uh not bad way but I rate it the long way and then I'll shorten this up so what we want to do is we want to first run the install command to run any of these uh basically install any new dependencies and then after that what we want to do is we want to run migrate and what this is going to do is it's going to say if there are any new migration files just go ahead and update the database however we see a lot of like repeated code and these commands are already like shortened to this new syntax so there must be a better way and indeed there is instead of just copying the recipes from here and moving it down here what we can do is write install and then migrate in what this does make sure you add a semicolon actually a spaced in semicolon what this does is whenever we run make update now it's basically the same is running make install and then right after it running make migrate so again I want to keep our commands as efficient as possible but yeah I think this is all the commands that we need for now and let's actually now that we have this snazzy new let me find it wait for it wait for it now that we have this snazzy new make migrate command let's go ahead and run that to hopefully get rid of some of these migration issues so I'm going to run make migrate and then it looked like everything was migrated now I'm going to go ahead and run make run server again and if everything worked we should see that these migration issues are no more let me just expand that make run server and beautiful so check it out so now we have our project running our Command shorten project structure looking good and all right uh let's just go ahead and close that we aren't digging into the actual project or don't care if it's running right now so what's next well before we get into kind of the next stage of this Django project setup I do want to make one additional update to this make file and that is adding something called I don't even know how to say it adding a new syntax called phony and I'll show you what it is and then I'll talk about it so if you're right period and then in capitals phony semicolon and then just write the name of your target right after it and we're actually going to be doing this for all of these targets right here I was going to say command Target demo with the column but what the heck is going on right here well check it out whenever you create a make file make by default it assumes that these targets right here migrate migrations run server it makes the assumption that these targets are actual files however when we were creating these we didn't reference any file for example there's no file here called like migration there's no file called Superuser no file called update so what's the deal like what are we supposed to do so what we want to do is essentially tell make that these commands right here they're not files we want to explicitly say that they're kind of just like custom commands that we built basically and we want to do this for two reasons the first one is actually to improve performance and that is because whenever make is going to see this phony keyword it knows oh okay I don't have to check if there's a file called you know installer or migrate I can just bypass that like file checking logic and another thing is whenever you um tag a Target is phony then it avoids a conflict in case there is indeed a file with the same name and I say that because sometimes let's say there could be indeed some script in here called update and a file called update and it might be like a shell script responsible for updating I don't know updating something however if we tag this Target is phony I'm just gonna say this update is phony right here then even if there was a file called update right here then it wouldn't even look at it or try to run it or anything like that it would just bypass that and say okay this command is what you're trying to execute so either way we're just going to go ahead and tag everything is phony all right we got some phony migrations here run server also phony meaning it is not an actual file and the super user Target right here yes this is all phony everything is phony and all right this looks good and by the way um right now whenever we run these commands it's going to make no difference whatsoever however just internally know that since we tagged our targets phony um it just improves performance in a bit and yeah we get all those benefits so that's what phony does in those I believe are the only changes I wanted to make the this make file right now so now let's go ahead and move on hi so let's close this make file and now what we can do is we can start on settings management so as our project scales what we need to do is we need to make sure that we keep all of our settings if I can pop it open we need to make sure that we can keep all of these settings organized now right now it doesn't look that bad I mean not that many settings you only got like 100 lines or so but as we scale as we got more packages as we need to configure our testing uh Docker Django rest framework needs settings that we're going to need to add then this file can get pretty beefy so the first thing I want to do is I want to create a way that we can kind of break this up a little bit easier now thankfully a lot of other people had this issue too so they already have a couple packages the one that we're going to be using is or adding I should say if I'm going to type in the add keyword is Django split settings and before we even install that I'll show you what it is has a pretty good nice short description so this package allows you to organize Django settings into multiple files and directories easily override and modify settings and use wildcard yada yada so this is kind of the meat of it and yeah that kind of sounds exactly what we were going for so we're going to be using that in another um not really uh important one I would say but we are going to be using something from Pie yaml as well so just go ahead and add these two and again when you add them it automatically installs them as well so we don't need to run a poetry install or make install separately now just to verify that okay we now have jingle split settings and Pie ammo in our project good to go so what are we going to be doing after this well jingle split settings as we saw it allows us to kind of break up this single settings file into multiple different ones and since we're going to have multiple settings files we should probably create a new package for that so go ahead inside your project where this settings module is just go ahead and create a new package and we're going to be calling this settings so basically converting this file to a little package right here now inside here we can actually create a new directory we don't need to make this a python package we can just use a directory and I'm just going to call this template tmblads always double check make sure you set everything correctly and um actually let me add one more file and then I'll kind of talk through what the heck I'm doing here so in here I'm going to add a python file which is kind of weird because it's a directory and not a package but it's just going to be like a template sample file so I'm going to call this settings dot Dev Dot py all right so what's going on with this structure all right you know what actually let me do one more thing and that is I'm going to rename the settings file a refactor rename I'm going to rename this to base dot py since these are indeed like our base settings I'm going to move this in this new settings package all right so now we got everything structured so let's go ahead and talk about this structure real quick so all of the settings are going to be in this package called settings and even though we have this one base file right now we're going to be breaking this up and pretty much creating more settings files in here we're going to have one for our base settings which are like the core um Django settings we'll keep it this kind of as is and then let's say that we want to set up our settings for Django or rest framework we're going to be adding another file for that we're going to be adding one for Docker one for like environment variables we're going to be adding more settings in here that's all you need to know in it's like a monster truck racing outside and it's just a cool way that you can uh break them up keep things a little bit more organized now this templates right here in the settings.dev.py this is going to be each developer's like local settings so let's say one developer wanted to change their logging they prefer things to be logged out in a certain way or maybe they wanted to switch to a new database to try something out what we're going to be doing is basically creating a template file right here however they just don't want to be editing this in each person pushing it up to GitHub so it's just going to be a template what they're going to do as part of the project setup is clone or copy this over to a separate location that basically doesn't get checked in a git and then they can each developer can kind of customize their own settings the template stays as is and all of the global settings that we need for every environment such as the base a Django rest framework so on and so forth those will stay as is and if that's all confusing and you it's like it's easier just to see this than to explain it but I did want to you know kind of give you an overview of what's going on so you know I don't just think it's easier that way all right so what to do next so let's do this in settings in it py I'm actually gonna go ahead and move this right here over and I actually need both of these I believe that's the only yep okay so I'm just going to go ahead and copy actually let me go ahead and do it this way I'm going to cut this and in settings py paste that in I'm also going to cut this since I need that and go ahead and really remove a lot of this okay let me just clean out some of these comments since it's uh getting a bit uh tricky to read all this all right so in this settings dot in it this is going to be where we're going to kind of aggregate everything so everywhere else that was importing from the settings module it can kind of do it the same way and we'll be getting into the setting up of those other files in just a second but for right now I just want to fix a couple things that kind of broke in this reshuffle the first thing is that since the path of this file which where we're specifying the space directory it was in a settings module directly under projects but since we created this new module in nested under there we just need to add one more parent right here to make sure we got the right path now after this what I want to do is hop back in base and set up a couple things near these comments too so you all know what I'm doing and actually let me I always like to keep things um very alphabetized I don't know I have OCD or something but either way uh what I'm gonna do is actually copy these over and I'm gonna stick these in these Dev setting template right here because I want these values by default I want debug to be equal to false in this pretty much says we're in production mode by default and I say this because it's just safer to do this way because then in your development modes you can easily turn on debug it's just um better this way in case let's say you forget to make it false then you have all these logs in um well security issues popping up and yeah so for secret key also I'm just gonna have set this to not implemented all right so now by default uh we are in production mode we have to manually overwrite that for a development environment that's exactly what we want and by default as well the secret key is not implemented and wouldn't this throw an error uh by default yes and that's exactly what we want because any environment you run this is basically saying hey you need to provide the secret key and this just helps to make sure like no secret keys are checked in to get or anything like that and all right so these are going to be our overrides for local environment however one other thing that I want to do is this uh database path is broken right now and that's because remember we removed this base stir setting from the space.pol file and we moved over to init and we're going to kind of see how everything hooks together in just a second but for right now I'm not gonna really worry about that because we're actually going to be replacing SQL Lite with postgres and um just to show you how to set up a actual database however if you use well really any other database my sequel even is going to be all the same however I just want to get this kind of like working for right now so we can kind of move on so what I'm going to do is I'm just going to go ahead and copy how do you I always forget where it is okay copy patch reference and just say absolute path so again this is kind of a hacky way for right now but like I said we're going to be deleting this soon just want to make sure that our project is still going to be able to run while we set up everything else so I copy the absolute path to this wherever your DB sqlite database is go ahead and paste it in for there now next up uh let's see what else we need to do got these overrides right here so what we're going to be doing remember these are like the global settings that developers basically shouldn't be messing with they're going to be set up once and you more or less don't touch them the developers custom settings are by default uh specified in this templates file however we don't want developers to be messing with these explicitly either this is just a template to show developers what they need to fill out however what do they do whenever they actually want to change their settings well what we are going to be doing is we first are going to be making a directory right here called local and it's due for my terminal it's probably uh always cool to learn some new commands if you don't know so I'm gonna be making a directory called local and now you can see we have this local directory right here and then what I'm going to be doing is I'm going to be copying over probably shouldn't have minimize that but I'm going to be copying over the settings from this template file to my local directory right here so how do we do that well let me just scroll down a little bit if you do CP I'm going to copy it from it's in core and then it's in Project settings templates and then it's settings.dev.py where do I want to copy it to well the current directory there's a directory called local and I just wanna basically name the same thing settings dot Dev Dot py and I'm gonna run that and now we should see that this file which was in the templates directory is now in my local slash settings.dev.py and by the way the reason that I um also like to run these commands rather than just saying go ahead and right click and new file this and that is because now what I can do is copy these and stick them in the readme pull that open and we're going to be cleaning all this up in a bit as well I just want to kind of pretty much make sure I don't forget anything so okay so as part of the project setup we're going to be running these demands and I'll show you how to kind of format this so it looks like code and make everything prettier but right now like I said it's just kind of a placeholder so okay so now we have our basic uh pretty much all of our basic settings structure setup however things aren't really tied together anyway for example we didn't really specify Hey whenever we run our project we want to First pull all these and then apply any overrides yada yada so how do we do that well in order to specify everything exactly how we want we need to write a couple custom functions for ourselves they're going to help with this entire process now for these utility functions I don't want to stick them under this uh settings package what I want to do is I want to create another package right alongside um this projects package and even though it's kind of weird right now but this you can name it core since we're going to be putting quite a few things in here and they're kind of like core uh you'll kind of see they're like core functionality oh we could almost name this General since this functionality is going to be General to really this entire project uh a lot of reusable generic functionality but either way inside here I'm just going to make another package called utils and let me close out everything else right now so in here we're gonna have the first thing that we're going to write inside a module called collections and the one function that we're going to be writing right now is a function to basically uh allow us to pack pass in two dictionaries one is like the original uh dict and the other one are your new values and what we're going to be doing is we're going to be basically a way to update a dictionary but we update it in a way that if there are any nested dictionaries or nested values those get updated as well and the reason that we're going to be doing this just is a little kind of give you some meaning behind everything is let's say that we are in um okay so let's say our we want to update our database settings now right now we only have a couple levels right here this is our default database the engine we're using sqlite but we're going to be changing it to postgres and let's say that you wanted to change the name of the database or the password or something like that maybe I don't know well with this function that we're going to write is going to allow us to do is it allows us to pass in certain Keys even if they're deeply nested and it's just going to update those values rather than having to like uh recreate this entire thing on an outer scope and then pass it in um it's probably easier just to kind of write this out so I'm going to create a function called Deep update and we're going to be passing in the base stick or the original dict and we'll say update with which is going to be the new dictionary and I'll just write a comment what we're gonna do actually I don't need a comment I'm coming in with my voice right now so the way that we're going to do to do this is pretty much iterate over this new dictionary the new values that we want and for each of those items we're basically going to pop apply the new values to the original dictionary so we'll see how this is done for a key value in update with dots items go ahead and first we need to check if the value that we're trying to apply is a dictionary itself so we'll say if is instance and what is an instance well check the value and then we're going to check if it's a dictionary now if so what we want to do is we want to get the value from basically the base stick in Basic Value the equivalent value and that's equal to the base stick dot get key all right so we're saying that if the value from the new dictionary is indeed a dictionary then the first thing we want to do is get like the equivalent value from the base dictionary and what we want to do here is we want to check if the original value is also a dictionary because if the original value in the new value are both dictionaries then what we're going to do is we're going to update basically run the same function again basically creating a recursive function right now now if the original value is not a dictionary then we're just going to set it to the new value and you guys that's uh a lot to take in in about two seconds you're going to see what's going on so if is instance that Basic Value we want to check if this is a dictionary as well then we're just going to call a deep update and this is going to take the base dict value in that new value referencing this right here and we can just say else if it is not addict then what we want to do is just update the basic key with that new value all right pretty cool so this was for this item saying what to do if it is addict however now we can say what to do if the new value is not addict and in that case what we want to do is just say the basic actually we can just copy this all right right like that and the last thing that we need to do is just return the base dick sense this is essentially the goal of it to um update this basic with the nested values all right so let me just I'm sure uh iterate over the new dictionary check if the values addict and then compare it with the base value of this update it again and fall through just update it okay actually let me pause this and just add some comments real quick all right I had some comments so whenever I uh push this up to GitHub if you're peeking back at it later on then um yeah don't have to watch this whole tutorial but unless you wanna that's cool too all right so we got this utility function written now another thing that we're going to need is I might as well just write it so I'm going to create a new uh file called miscellaneous and in here we're going to be making that yaml function and let me just go ahead and get things started so yaml and by the ammo function I mean back here remember when we added this pie ammo well this needs to be installed for this yaml package right here but either way what we're going to be doing is we're going to write a function called yaml coerce course how do you even say that who knows quarters of course all right and in here what this is going to allow is basically us to pass in a string dictionary and it's going to convert it to proper uh python now we named this yaml course because by default this functionality is um is kind of for loading in yaml which we can probably set up this way uh I don't use it but either way what actually let me show you why this is useful and it's going to make sense in a bit so check this out so let's go back to our database example and say that we are writing a Docker file however we want to override our database let's say we're getting ready to deploy to production and our production database has a new name a new user a new password well in our Docker file it doesn't take python syntax in fact our dockerfile it doesn't give us a whole lot of flexibility so what we need to do is we need to figure out how we can use this like a nested dictionary in a Docker file so what we're going to be doing is we're basically going to be stringifying everything so in our Docker fire file we just have one long string that's basically going to resemble this dictionary something like this right here oh no I'm getting yelled at by my IDE but we can basically pass in an entire nested dictionary as a string and then what this is going to do is basically convert that to a python dictionary so it's just super easy to do it this way convert the value to proper python actually let me add that comment that's all this function is going to do and now I'll show you how to do this we'll say if is instance we just want to check if that value is a string and then if so we're just going to return yaml dot load and what we can do is we're going to create a basically a um a tiny bit of yaml and then just convert it to python super quick so we'll say if you actually you can do it the shorthand value since you can use f strings now so what we can do is we're just going to be creating this tiny snippet of yaml under the key of dummy and then once we do that we can load it in or basically uh convert it so I'm going to say the loader is equal to yaml dot safe loader there we go and what value are we trying to pick off from this dummy right here now if it's not a string then we can just go ahead and return the value and all right so I believe that's all we need so basically whenever we get passed in a um a string that references a nested dictionary it's basically going to convert it to yaml which is going to convert it to Python and then we're just going to be returning the value from it which is now the python value and actually let me pause this and add a comment so all that makes sense as well all right so I added some comments uh yeah I'm a loader turns a python object so this is going to return to python object and I also gave a little example of what we're actually going to be using this uh basically to convert a string dictionary such as this right here to an actual python dict and I also added this comment right here it's useful because sometimes we need the stringify settings this way such as in Docker files it doesn't like python but it loves strings so basically to convert these to python that we can use and by the way I know just creating a bunch of these utility functions and not really seeing how they fit into our settings is a little bit confusing right now but I do want to say that we do have one more utility function to write and in about 10 minutes we're going to see how everything is going to come together to create this beautiful settings management system or at least I think it's beautiful so just bear with me a little bit longer and less I'll say maybe utility settings that file that we're going to write I can't even talk anymore uh inside utils just write settings.pui and one small function you can import OS and then I'm also going to import like a structuring this way I also want to import this function right here and you'll see why in just a second so from Miss and poor yaml course and all right so the function that I'm going to be creating right now is going to basically pull any specific environment variables from the actual system environment so we can use those now why would we want to do this it's because whenever we are well there's probably a couple different places but the one I can remember right now is that whenever we are going to be setting up and dockerizing this project we want to be able to set environment variables from our Docker container now those are basically the equivalent of setting system environment variables like I would do like uh right here in my terminal now we want to say if there are any relevant environment variables from the overall parent system like uh you know just locally or Docker container or whatever pull those out and apply them to this project now what we want to be sure of is is it's just not pulling all of our environment variables because you know we may have some for other projects or we may have some for other applications or we may have some environment variables that were just like playing around with something we don't just want to pull everything in from our environment and just like blindly apply it to our project so how do we kind of uh handle this well what we're going to be doing is we're going to be namespacing our own custom environment variables from the system and what we can do is we can just say that whenever we have an environment variable and it's typically named the name of your project and just something like settings whenever we have an environment variable like in Docker is one that we're going to be using or we can say something like I don't know even like a DB name something like that basically we're going to be looking for any system environment variables that are prefixed with this prefix and we're going to be making it a constant so we don't have to actually type the string out every time but we're going to be looking for these specific environment variables and if we find any then we're just going to strip this away and that this becomes what gets applied so it's kind of weird just to explain but you know just uh kind of give some meaning behind this function right now so I'm going to say get settings from environment and I'm also just gonna pass in the prefix right here to keep this function rather generic and then remember what we're going to be needing to do is kind of slice off that prefix because what comes after that first underscore is like the actual name of the environment variable or how we want to treat it so in order to do this I'll just say prefix dot Ling is equal to the length of the prefix just so we know how much text to slice off and what this function is going to be returning is a new dictionary and it's basically going to be a dictionary of all your clean up environment variables without that core setting underscore prefix so the key of this new dictionary is gonna just be equal to prefix length and the value uh we'll save this yaml course value and for this we're going to be actually it probably makes more sense if I just write it this way so for a key value in OS dot environment items so basically iterate through all of your environment variables and for each of those check if the key starts with I thought I was going to get some autocomplete there prefix all right so we're going to be passing in that prefix and if any of our environment variables start with that prefix then just filter those out and that is why I typed the value right here let me actually minimize this all right so now we can kind of see what's going on so again the prefix that we're going to be passing in this is just dummy code right here but it's going to be something like core settings underscore so again it's going to iterate iterate through all of the environment variables check the ones that start with this prefix and let's say that there's a environment variable called this what it's going to do is it's going to actually might as well do this let's say that we have an environment variable called core settings in Docker one what this is going to return is a dictionary whose value is in docker or excuse me the key is in Docker and the value is 1. so convert this to a dictionary of these that's all it's doing all right so now that we got all of our boring utility functions out of the way let's go ahead and close all those and hop into the good stuff my good stuff I mean seeing how all of this fits together so in it's wrong in it so in settings in it py remember this is kind of where we're going to aggregate um really all of this logic so the first thing that we need to do is import a couple things and that's OS dot pass and then we'll say actually passively I've got passed in what else do you need okay so you know that split settings package that we download that I said that it's a way to kind of aggregate multiple settings files into one well we are going to need some things from that so from split settings dot tools we're going to import include and we also are going to import optional and what this include is going to be is it's going to take um however many arguments you pass in you're basically going to be passing a bunch of settings file like file one file two so on and so forth and it's gonna um aggregate them together in this optional one right here this keyword is saying that if you have a file like file three in here in its uh labeled as optional this means that this file may exist or it may not exist so we would or we actually are going to be using this to specify this local settings file right here since if developers don't have any of their own uh local settings files then that's fine but um yeah that's basically the syntax of it so okay what else are we gonna need so let's actually let me remove this right now these bugs are kind of annoying me so another thing that we want is to create a constant for that prefix so let me actually add a comment are and again for you you probably wanna um change the value of this to be different depending on your the actual name of your project but for me I'm just going to name this EnV var environment variable settings prefix and for the value I'll just say core settings underscore so again whenever we have an environment variable that we want to be pulled in from basically the parent system whether it's Docker or my actual system I'm developing on which is not going to be too common but hey who knows we just need to make sure to prefix it with this string of text right here now before we get into actually aggregating all these files and so on and so forth I also want to make another constant for a local settings path so local settings passed and I'm just going to say this is equal to uh OS dot get from the environment and I'll make it an F string so this this path right here um we are going to allow the developers to specify their own settings file and that's because by default we can just assume that is in this location but let's say that they wanted to test something out but they didn't want to update this file right here maybe they just wanted to create a similar file for like testing a new database or logging something differently so on and so forth and to avoid you know having to comment this out and create new ones so on and so forth we can just allow them to create a new file and just update the path of where the local development settings are and we'll say that um again this is going to be optional as well but we'll say that if they have a custom one then just go ahead and it's going to be local actually this is this right here so if they do have a custom local settings file then they're going to be passing in an environment variable telling it telling us where it is and it's basically going to be this is going to be the value or excuse me this is going to be the key and then the path is going to be the value but yeah we'll just reference this right here and now what we need to say is if there is not a local settings path and there's not going to be one the majority of the time because they're just going to be using this one by default what we can say is that the local settings path is just equal to local slash settings actually let me just copy this name so I'll make sure I don't refactor rename this is what I do whenever I need to copy this name pretty sure there's an easier way but there you go all right so if they don't give us a custom settings path or a settings file then we'll just assume that they want to use this one right here and after this uh what we can do now is just to make sure that the paths are always um formatted consistently we can check if the settings path is a relative path or an absolute one and if it's relative we're just going to convert it to Absolute so from there forward we're just always working with a standardized absolute path to whatever settings file that we need all right so we'll say if the local settings path is not absolute by saying if not OS dot path dot is abs or didn't that autocomplete it's kind of scaring me now all right if the local settings path is not absolute then what we're going to do is just update it so we have the base directory and then the local settings path all right so if the local settings path is not absolute then just go ahead and prefix it with our base directory which is this right here that's essentially going to convert it to an absolute path and yeah I think we're good to go now all right so the last command that we need is that include function right here and again like I said what this is going to do is allow us to include um various settings files and it's going to aggregate it as one now right now the really the only settings files that we have is this base that py settings file and also this custom should I organize it like this all right and also this custom like local development settings file right there so no matter what we always want to include base.py it's always going to be there no developers ever supposed to delete it or anything so we can just write that in just like that now after this we want to go ahead and write an optional local settings path because like I said this may exist it may not um either way check if there is one and if so just include it and that should be oh good to go right there in we do have some additional let me think about this so we're going to be making a custom environment variables in Docker but I think we can actually test this out right now and in order I like this here for some reason in order to test this real quick let me just where do I want to go I'm just going to my URLs since this is going to load after the settings and I'm just going to write some a quick dummy code just to make sure that the settings are being pulled in correctly and that is from Django Dot configuration I just want to import settings and what I'm going to do is I'm gonna print out settings. debug and let me just print out this secret key as well usually you don't want to do this especially on YouTube but well not actually going to be deploying this project or anything so okay now the reason that I want to test it right now is because everything I believe should be hooked up where we're basically saying that these are our base settings that we're going to be using for every environment now for these base settings since we had base and then after we're including this local settings path which is this right here we're basically going to be overriding or adding any of the settings to base that are in here so if everything worked properly this debug which was false by default in a way should be true now in the secret key which is not implemented because we want each environment to implement it own their own explicitly so if everything's working correctly then when I run this I should see that debug is true and that secret key is this ends in teh so let's just go ahead and test that out right now make a run server and okay true and that this ends in t e h beautiful all right so uh those settings are good to go um any developer can just go ahead and tweak their own actually did I include this in my ignore make sure all right all right so let me where to go from here no no no okay let me always like to keep stuff uh nice and clean I can't believe uh when I see people on Chrome uh and they have like uh 60 tabs open I'm like oh man I just want to steal their computer and close all their dad but uh all right uh let's see okay so the next thing that we're gonna do is we're actually going to add another settings file right next to base and I'm gonna call this custom okay so what is going to go in here well let me actually add a comment and I'll say settings specific to this application only and by this I'll specify tries I'll specify that this means no Django or third party settings all right so as our project scales we're going to have more settings in addition to this um pretty soon we're going to be setting up settings for like Django filters Django rest framework Docker so on and so forth a lot of Django related packages though and in addition to that we're also going to want global settings just for our project and by that I mean like let's say we're making like a store we'll say like uh this would be stupid but I can't think of anything else right now like uh maybe the tax like so tax is like 0.07 or we'll say uh the global color theme or something like that basically any environment variables that are only going to be in this app in really not like every single Django app out there so one thing that I want to specify in here by default is in docker I'm going to be setting this to false so by default whenever we're running this we're gonna basically be telling our project that you are not running in a Docker environment and that's just because uh kind of throughout our project some things are going to be different if you're in Docker and if you're running outside of Docker so yeah it's just that flag is going to come in handy quite a bit so either way now that we have this additional settings file it's pretty uh Bare Bones right now but we need to make sure that we include it right here so custom.py again this is our these are our base Django settings and these are our custom application settings now another thing that I want to do is I want to create an additional settings file and remember these utility functions that created for example we created this function to pull all those environment variables and kind of apply those or convert them to a dictionary right here and that we also wrote this deep update to update a one dictionary with another dictionary well now we're going to see why these are coming in handy so I'm gonna name this file again under here as well under settings I'm going to create a new python file and I'm going to name it n vars envars.py in what this is going to do is it's going to use actually those two functions that we just talked about so let me import those first core dot core dot utils collections deep update and from core core utils the settings we want to import git settings from environment and there's a plane flying out okay so actually let me pause it and uh let me pause this video and add a comment and it's just going to be a lot more clear what's going on all right so here's a little cheat sheet of what is going on in the logic that we're going to be writing right here and by the way this is only going to be one line of code so you know not that much but basically what the logic we're going to be writing is going to do is it's going to look for any environment variables that are prefixed with this specific prefix again this is going to be different depending on your um your project but it's going to be looking for these environment variables and then whenever it finds one it's going to be stripping this off and it's going to be essentially converting any of these values to Python and then applying it to our globals which is just a dictionary of your Global variables basically converting this into a global variable or a regular setting that our project can use and actually let me uh specify this real quick so I'll say globals this is a variables it's not really that well I don't want to say not that common but uh you know just a little helper all right so how do we do this how do we update our globals with these you know nice clean uh updated settings well if you do deep update again let's go ahead and look at the signature for this so whenever we update something we're going to be passing in in um we'll say original dictionary and then the new dictionary that we want to basically apply to this original one so this original one are just our Global variables and again this is something that's built in with python and how do we get that new cleaned up um python dict what we do is we use this function get settings from environment we'll take a look at the signature for this right here and what this is going to do is it's going to pull all those settings from our environment clean them up and then return a nice python value and again this is where if we pass in like a string dictionary is going to going to convert it to a python dictionary but basically all of that we wrote already and the last thing that we actually need to pass in this get settings from environment is we need to pass in the prefix and what is this prefix it's this right here so we're going to be passing that in right here now actually this is another interesting thing uh let me actually update this real quick so right after this local settings path what we can do is we want to include this file right here which is our environment variable settings EnV varspy envars.py all right so we are basically telling Django whenever you're setting up our project configuring all the settings first load in base dot py let me close these other files first load in base dot py which are your base Django settings then load in any custom settings that are specific to this application only after that apply any local settings um yeah pretty much just that local settings from that specific developer and then after this look for the system environment variables which are right here and convert these to settings basically standard settings that we can use throughout the project now what we see here is something pretty interesting and that is we are including this nvar settings prefix but we didn't import it so is this going to break well believe it or not it is not going to why is that is because even though we didn't import it from this file whenever this include or excuse me I'll say it like this whenever split settings is patching together like this master setting structure what it basically does is this it's going to go one by one and say okay what's in base.py okay I'm more or less going to copy everything here and just keep it in memory for a second now what's the next thing you want me to apply well it's this custom settings right here so it basically takes every setting that it already has in memory which is basically all the ones from base.poi and it more or less like pastes it above here so I say that because if there are any thing in this file that references any of these then that's fine so we may get some syntax issues because the IDE doesn't really like it but that's essentially what's happening so by the time we get to this nvars that Pui file right here we can actually use any of the settings from here and from here and actually even the ones from in here you can imagine that all that's kind of copied and if we pasted all of those above here then those can get applied to here too so as part of this it also includes uh this right here so long story short all of this is kind of already included in here however even though we can write it this way my IDE just doesn't really like it because it doesn't know um what split settings is doing behind the scenes so just so I can avoid this and not always have this error and my IDE telling me I did something wrong when really it's like supposed to be set up this way I'm just gonna have type ignore and then basically just telling my IDE to ignore this this is actually how I want it it's not an issue there you go but yeah just kind of know that whenever you're applying your settings behind the scenes it kind of applies them in aggregate like that one by one so you don't always have to import everything and now this I believe is good to go let me just go ahead and run this real quick just to make sure that nothing broke so make run server and okay I still have those print statements that I probably want to get rid of and actually do that right now those are in our urls we verify that it's working don't need to test those anymore and all right now the last thing that we want to do is we want to add one more settings file for now and that is our Docker settings and this settings file is going to be pretty lean right now since we don't even have Docker set up however I do just want to have it in here just to get our you know kind of our settings structure finalized but either way go ahead and create a new settings file and let me clean some of this up let's keep basing here I'm going to show you guys some in a second by either way create a new settings file we're just going to call it Docker and what can we do right now we'll check it out so we're actually going to be um using this exact environment variable so by the time we get to actually let me do it like this so we are going to include the docker settings right after um this envirus right here let me pull this out in order so we're going to be loading in base then envar's Docker some other ones but that's the order we're going to be using so by the time we get to docker these environment variables are essentially going to be converted to globals so we can more or less just reference um this name from this Docker file so what do I mean by that I mean we can say something like if Docker and again we have that issue with the IDE not liking it because we didn't import it even though split setting is kind of like imported everything behind the scenes manually so for here we're just going to make a simple check and what we're going to be checking is that if we are running this project in Docker mode and we're going to be deploying this in Docker by the way but either way I say this because where's my middleware okay whenever we're running in Docker mode one thing that we want to do is we want to make sure that well not only this package right here but possibly some other um middleware is included but either way the logic I'm going to be writing is if you're in Docker then we need to make sure that we're running this middleware so how do we do this well let me just go ahead and copy that and I'll say we want to assert or make sure that the middleware the beginning of it is exactly equal to this all right so we're getting a few warnings from the IDE because it's saying hey I don't know what indocker is you're not importing anywhere and also what the heck is this middleware however all of this is going to be included because this middleware is going to come from the base settings and the soccer is going to come from our environment variables and both of those are going to be included by the time we get to this Docker file and then we're just going to test that the um basically this is just saying that this is included in the first section of the middleware list all right so actually let me do something else too just to kind of test this out okay so if we are in Docker and I'm going to delete this in just a second I'll say running in Docker mode actually running in Docker I don't know why that bothers me I'm going to delete in about two seconds but just to show you guys um that everything is working when we are running in Docker mode we're just going to log this out since you know this doesn't give us any indication if it worked or not so now everything looks set up properly the first thing I'm going to do after this is just run this real quick and okay I don't see anything running in Docker and that is expected because we actually didn't set that environment variable anywhere however the rest of the project look like it's all working nothing is broken at least so the last thing we have to do for now is just go ahead and actually let me pause my video and set this environment variable I actually don't want to do it um on screen just because you guys are going to see all my other environment variables I'm sure I have a bunch of secret keys in there and whatnot so let me just go ahead and pause this real quick and I'll set this environment variable in my own local system and then we'll make sure that uh everything is working correctly so one second all right so what I did is I went ahead and I updated my system or my Macs in environment variables and I also when I was testing this I did see that I had a one little typo um or a typo for our code but in this comment right here uh just in case you're following along line by line I had a core setting singular not plural however it's supposed to be course settings with an S so just updating this comment right here however now let me go ahead and make run server and we can now see it is indeed running in Docker mode so Docker settings uh everything is you know up and running correctly so what I'm going to do this do right now is just remove that since we don't actually need that and now that we've verified that yes this is working correctly uh our utility functions are pulling in the values correctly from our environment uh stripping out this prefix correctly converting these to Global values that are valid Python and all of our settings are pretty much set up again like I said as we install more packages in our application begins to scale we are going to likely need to add additional settings file almost certainly however for right now this is the basic structure so you know what this is probably good for this video too um so what I'm going to do is I'm going to make sure to remove that in Docker uh environment variable and then in the next video just making sure we don't need to cover anything else right now so in the next video we're going to be well we got a lot more to cover actually in terms of flake linting my pie editor config precommit and also we will set up some logging middleware we're going to be setting up Pi test we are going to be setting up Docker we talked about Docker a lot and didn't even set it up yet and then uh adding a license that's gonna take like two seconds setting up postgres and then after all that we are going to be learning how to uh set up some CI CD and actually deploy this to AWS getting a domain name setting up SSL and yeah pretty much doing everything like we would do for a production grade actual Django project so yeah we got a lot to cover but uh for now I think that's a good place to stop the video uh thank you for watching and I will see y'all later