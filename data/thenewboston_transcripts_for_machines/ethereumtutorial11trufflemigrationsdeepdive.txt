what is up y'all welcome back to another video and in this one we're going to be taking a closer look at truffle migrations so the first thing that i want you to do is go ahead and pop open ganache and we're just going to be working off a brand new blockchain so just click quick start ethereum nothing else we need to do here right now pretty much just ensure we have a brand new empty blockchain minimize that just make sure it's running in the background and what i did in this tutorial is i created a brand new empty folder and then i just opened that in my ide so make sure you have an empty folder to start and what we can do after that is we can initialize a new truffle project so how do we do that truffle init and it init it's short for initialize project and just hit enter and then that looks successful so after you run that you should have these folders contract migration test and truffle config now we touched on this at a very high level in the last video however what we're going to be doing in this video is we're going to be taking a look at this migration system and that consists of migrations.sol the solidity contract and more specifically we're going to be looking at these migration files so first of all what the heck is this migration system overall so the migration system is truffle's way of keeping track of what changed since you last deployed your project so what i mean by that is typically throughout the lifecycle of a project you're going to be working on a few contracts and say this looks pretty good i'm ready to push it up to the network you push it up and those contracts are deployed and then later on let's say the next day you're like okay let me add some more contracts here let me build in some new features uh you update your project in one way or another and then you're ready to deploy those changes now whenever you deploy those new changes you typically don't want to deploy your entire project again you typically just want to deploy like maybe some updated new contracts that you've written so this migration system is truffle's way of saying you know what these contracts they're already deployed good to go no need to touch those again and in fact you don't want to redeploy those if they haven't changed because it's just going to cost you extra gas fees aside from that what it's going to do is say however these contracts i haven't seen these yet these are new to me so whenever you deploy this i'm going to just deploy the updated portion of your project and if that doesn't really make sense we're going to be taking a look at an example just want to give you a quick overview of kind of what's going to happen and why we're learning it right now so that's the system overall now let's look at these pieces individually so this migration contract this is actually the smart contract that's gonna record which migrations have already been ran or in other words what code has already been deployed and it's gonna say if there's a new migration that i didn't see yet then i'm gonna go ahead and make sure that i run this and then log it here so it's essentially the way that it tracks which code was already deployed and not now this javascript file this migrations one underscore initial migration this is essentially the javascript half of it and all this is saying is this migration file right here again contract migrations this is the very first thing that we're going to deploy to the network and all of these uh little miscellaneous keywords artifacts require deploy or deploy we're going to be covering that in a little bit more detail in just a few minutes but just to show you how these two things are pieced together and now that we have an understanding of the overall system and kind of the couple key components let's go ahead and run our very first migration which is going to be this one right here so what i'm going to do is i'm going to pop open my terminal and i'm just going to run truffle migrate now at this point even though we did start our little uh simulation blockchain we didn't push anything up to the blockchain yet so whenever i run migrate what this is gonna do is truffle is gonna recognize and you can see it right here that whenever i said hey migrate in other words push up my changes to the network it's gonna say okay so the first thing it needs to do is compile this because we only have it in solidity code remember it needs to convert it to ones and zeros before it can push it up so after that is compiled it says starting migrations it's gonna deploy this migration so it essentially deploys that contract and says this is how much gas that it costs all right looks good so now truffle has already deployed these changes to the network and actually if we go back in ganache we can see a couple changes here and my ethereum balance is a little bit less here so it looks like these changes were deployed successfully so now what i'm going to do is i'm actually going to run this command again now whenever i hit enter this time something interesting happens instead of compiling and deploying and doing all that again instead this time it's going to say you know what everything is up to date there is nothing to compile and in fact there were no more changes to ganache no more blocks added nothing happened so why is that now that's because whenever we run truffle migrate what we are essentially instructing truffle to do is we're basically saying hey truffle push up any new updates from our project to the ethereum network and on that second instruction it's gonna say okay well there are no changes that happened since i last deployed so i really don't need to do anything so that's the basics of it and just to hammer this home what i want to do is i want to create one more contract and then we're going to migrate that and it's going to be crystal clear exactly what's going on so i'm just going to create a new contract called bucky.sol and i actually have right next to me that very first contract that we created in remix and the content of this contract it doesn't really matter for this example just want to have some bare bones contract so we can figure out how to migrate it and to do that the first command that we can actually run is truffle compile so what this is going to do is it's going to take any contracts that have not yet been compiled like this one and essentially you can think of it as taking the solidity code and converting it into ones and zeros and you can actually see more details of what it does if you go to build contracts after you compiled you're gonna see this bucky.json and in addition to some other things this interface meta byte code right here you can see that this is essentially preparing the contract converting it into a format that truffle can then push it up to the network all right fantastic so it looks like we have our solidity contract written it is now compiled with all the information in build contracts bucky.json so now how do we get it pushed up to the network well to do so you're going to go ahead and create a brand new migrations file right here so in your migrations directory just go ahead and create a new javascript file and the naming convention for this is actually very specific so the first thing you're going to do is you're going to prefix the file name with a number now this number is going to be sequential to the previous migrations that ran so essentially look at the number of the last migration and just add one to it so this one was one initial migration so this one needs to start with two and i say that this is important because this is actually how truffle keeps track of which migrations uh have already ran and which one have not ran yet so essentially truffle already knows that it already ran number one and when we run it again it's gonna say oh i didn't run two yet so let me go ahead and run that now after two just go ahead and write underscore and then you can just write any human readable short description and i'm just going to call this bucky migration again this number is the really important part and this is just for humans to understand whenever they're quickly looking at this file name what this migration is responsible for so i'm going to call mine to underscore bucky underscore migration.js and there we go so now we have an empty migrations file and what we can actually do is copy everything over from this initial migration and plop it into bucky migrations now i am also going to replace everywhere it says migrations with the name bucky and the reason for that is because that keyword references the contract name and i'm just basically instructing it to deploy bucky instead so everything else is pretty much the same we're okay so change all of the instances of migrations to bucky and now let's go ahead and break this down in a little bit more detail now the first thing that i want to point out is this artifacts require statement right here now if you're familiar with node or javascript this may look like somewhat familiar syntax however i do want to point out that it is actually quite a bit different than node's standard require statement where you essentially just pull in code from another file instead what this is going to do is it's going to pull in a contract and wrap it in a contract abstraction now this means is that with this bucky contract abstraction we can actually interact with it in some pretty special ways and we'll see that later on just want to point out right now that there is not a direct translation from artifacts require to require you can think of them kind of as different systems where instead of just pulling in the source code we're actually pulling in a contract abstraction now another thing that i want to point out that differs from node or javascript is that this value that we pass in as artifacts.require this is not the name of the source file so even though we have a contract file named bucky.sol this is actually the keyword signifying the contract's name right here now why do i make this differentiation why is it even important at all well believe it or not in these solidity files we can actually have multiple contracts in the same file for example we can create another contract in this file named wendy this might be kind of a bad convention but for example just want to show you what's possible now in that case we could just put wendy right here and it would work all the same but either way what i want to point out is that typically or i don't want to say typically a lot of the time you have your contract name the same as your file name right here and what people do is they just uh try to require in the name of the file like bucky as in bucky.sol but if you ever get issues it's probably because you need to pull in the contract name instead so in this case if we did have that wendy contract in there as well what we could do is we could actually pull that in just like this so requiring a bucky and requiring wendy just like that now another thing that must be included in these migration files is this module.exports so module.exports it needs to export a single function and this function takes deployer as its first parameter right here now this deployer object you can kind of guess is truffles object that comes with some functions useful for deploying smart contracts now we're going to be taking a closer look at each of those functions as we need them later on as you can see the first one is uh kind of simple uh it just has a deploy function which we pass in the contract and it essentially is just going to deploy this to the ethereum network pretty simple and the last thing that i want to mention before we actually deploy this is that you may also see some other values being passed into this function for example you may see network being passed in and this is just if you want to deploy but you need some more context around your deployment in this case you can do something like if network is equal to like a development network or something then you can do some kind of deployment uh otherwise you just do this you can do something else so again there is a little bit more to this but again i don't wanna kind of just focus on all the nitty gritty details uh before we actually need those features so for now this looks pretty good so what i'm gonna do now that we have everything set up is i'm gonna go ahead and run truffle migrate again now remember if everything worked correctly and i set everything up correctly then what this should do is truffle should recognize that we already did run that first migration so no change is needed there however this new migration which is deploying this bucky contract to the ethereum network this has not ran yet this is not yet on the network so these are the only changes that it should push up so let me go ahead and hit enter expand this a little bit all right so we ran truffle migrate looks like a compiled bucky.so and all right looks like it is deploying this bucky contract and only deployed one contract all right so far so good and just to verify that if i run truffle migrate again since it now deployed all those changes it should now say everything is up to date and just to verify that that all worked we now have some new blocks looking good now the last thing i want to talk about regarding truffle migrations is actually how to reset your migrations in other words if you do want to run all of your migrations from the very beginning even if you ran them before then how you would do that now before we just hop into that i want to show you example of when this would actually be useful and for that let me go ahead and pop open my terminal and i'm going to run truffle console just so i can interact with that ganache blockchain and to see what's going on here let me go ahead and get a reference to that contract abstraction and by the way all a contract abstraction means if that terminology is getting kind of confusing is just saying that hey i want a way to interact with this ethereum contract and i want to do it through javascript so pretty much just allows you to interact with ethereum contract through javascript so to do this i'm going to say let instance equals await bucky which is the contract and i want to get a reference to the deployed contract so again essentially just a abstraction for this deployed bucky contract storing it in a variable called instance and then this instance if i log it out you can see it's pretty much just a javascript object that is essentially a reference to our deployed contract so right now i'm gonna say let's go ahead and just get the age of this deployed contract so we can do instance dot get age and all right so this is kind of surprising instead of just a number which that's another thing so we initialized this contract and bucky didn't have any age and actually we didn't even set an age so whenever this contract is first initialized if we don't give age an explicit value then it's just going to initialize it by default to the default value which is zero so why don't we just see zero print out here so this is another interesting point about solidity and really a theorem overall and that is that the ethereum network can handle very large numbers now to make those numbers javascript compatible what we do is we essentially convert them to something called a big number and that's what this bn stands for right here and later on when we're actually writing a full dap i'll show you how to convert uh these big numbers to something that's more usable in our depth but for now just want to say that this is indeed storing that numerical value it's just kind of a javascript compatible version of that ethereum number alright so whenever this contract was initialized bucky's age did get set to zero by default now of course what we can do is we can say instance and we can set age to something like 300 and then okay whenever i run get age again now you can see that and it's kind of weird because this is stored in object and the value is actually the first item in this list but if you look uh kind of squint your eyes you can see that the age of bucky after setting it to 300 is now indeed 300. okay fantastic but what are we doing setting and getting bucky's age for you know this doesn't really seem related to migrations at all well i mentioned this because let's say that we realized after interacting with this contract that this isn't the exact logic that we want instead whenever this contract is first created we want to initialize bucky's age to well we're not sure yet let's give the deployer the flexibility to set their own age so what we can do is we can introduce a concept called a constructor and this constructor function again if you're familiar with well a lot of different objectoriented program languages you're probably going to understand the concept of this constructor but for those who don't it's really just an optional function that gets declared and any code that is inside here it's going to be executed as soon as your contract is first created so think of this code right here essentially as contract initialization code initialization code there you go that's a tongue twister so what can we do in this case well let's say that whenever this contract is first created in other words first deployed to the network then we're going to allow the user to pass an age and that's going to be bucky's initial age so how do we do that well it's actually the exact same as this function right here but let's just go ahead to change things up a bit we'll say that age is equal to the age that we pass in that's actually a little bit better than x and let's say we want to update that right there too okay so we made a few changes to this age contract right here most specifically or most notably i guess you could say is that we added this constructor we also changed the variable name right here now let's think about this a bit because the javascript code or the migration file responsible for deploying this contract right here it actually already ran so is truffle going to know to actually run this again with our updates well let's find out so what i'm going to do is i'm going to first compile this contract again now it is going to recompile this because it does see oh i compiled this before but there were some changes since then so i'm going to go ahead and recompile it basically it now converted this to a different set of ones and zeros so this file has been updated right here but now once that's compiled let me go ahead and run truffle migrate and all right everything is up to date okay so it did compile it but it didn't push these new changes up to the network so why didn't it do that well it turns out according to our migration system it is just working correctly because we said that whenever there is a new migration that you are unaware of then just go ahead and run the code in this migration file specifically in this function right here and this is essentially how you migrate those changes now it already ran migration 1 and already ran migration 2 so even though this contract was updated the migration system it didn't really care because you can update it all day no matter what it already ran migration too so if we want to update this contract how do we go back and say you know what truffle i know we told you only run new changes however we didn't make changes to this so if you can go ahead and rerun these migrations then that would be great well we know that it won't work with truffle migrate as is however what we can do is we can send in the flag reset now whenever we run truffle migrate reset then what this is going to do is instruct truffle to run all migrations from the very beginning instead of just running the new migrations since the last migration was successfully ran so now let me go ahead and run this again and check it out all right so it looked like it tried to migrate this but getting a weird error here here invalid number of parameters for undefined got zero expected one okay so somewhere it was expecting a value and we weren't passing in that value in so check it out before when we didn't have this constructor we could just take this contract deploy it up to the network and everything was fine now however since we made this update what's happening is that is part of the deployment process or in other words the very first time that you push this up to the network you have to give bucky an initial age and that is part of the constructor logic so that is why in this it's saying hey even though it doesn't or maybe it says it somewhere that it's the constructor but it's essentially saying hey as part of this initialization i was expecting a value for h which was this value right here but instead i got zero information zero values so how do we deploy this with this constructor requirement right here well what we can do is we can hop back into this migration and in this deployer.deploy the first argument is always going to be the contract abstraction right here and then the second one let's just say 90 this is going to be the value for the constructor so if this works correctly then what we should do when we run this command again is it should deploy the same contract however then when we tap into it and check the initial value of uh bucky's age that should be 90. so now let me go ahead and clear this and try running it again and are right so we are resetting and all right this looks pretty cool total deployments of two so now let's just go ahead and clear and make sure everything worked correctly so i'm gonna tap into this again hit truffle console all right let's go ahead and do the same thing where we are going to want to get the deployed reference to our bucky contract and now that we got a reference to our new contract if we do instance dot get age unlike before when it was zero hopefully we see 90 right there so again a couple notes just a reminder is that whenever we already ran migrations but we want to explicitly rerun those migrations then what we could do is we can run truffle migrate again by passing in the reset flag this is going to indicate no matter if you ran those migrations or not just go ahead and reset from the very beginning and rerun those again and another thing is that when we have a constructor during deployment in order to essentially pass in values to that constructor you just uh pretty much just add those values right after the contract name right here all right so i think that covers everything that we need to cover right now in terms of migration again i know this isn't the most uh interesting stuff you probably want to get into you know creating your own tokens and nfts and so on and so forth however i did want to take a tutorial and cover all this because it is going to save you a bunch of headaches in the future by understanding all this in a little bit more detail but for now thank you for watching don't get subscribed and i'll see y'all in the next video