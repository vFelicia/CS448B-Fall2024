what is up y'all what is up y'all all right so in this video what we're going to be doing is we're going to start dockerizing our app however before we get to that I want to show you a few things and that is that I did go ahead between the last video and this one and I built out a lot of business logic and that's because I was realizing that it was actually hard to teach a lot of these Concepts without having an actual app that does something so we now have this social network app where you can like share recipes and comment on other people's recipes so pretty uh generic app but it did allow me to install jingle rest framework create a few endpoints and I also added uh jingle channels for websocket sport and aside from that I also want to point this out that I move the location of this to the New Boston developers and it's called cooking core right here so if you want to follow along with the new repo then uh hit up this URL and there you go but either way Yep this is the app um like I said you have your own profile pretty generic you can create recipes and then once you have a recipe other people can come and just comment on them and then they can uh send coins as well and then when anyone sends coins to my recipe I can just like leave them there or I can click this and withdraw them to my main account which is this right here and I did that because I'm thinking about putting like a leaderboard system in to see who can I don't know get the most coins but either way that is kind of the skinnier that and with that out of the way let's go ahead and get to the good stuff so in this video what we're going to be doing is we're going to start dockerizing our app now eventually we're gonna be setting up Docker for production but for right now just to get started what I want to do is um I just want to set it up for local development and by that I mean we are just going to dockerize our database because I think I said in the last tutorial or two tutorials ago that we're not going to be using uh SQL Lite even for development so we're going to be replacing this with postgres and that's going to be our dockerized version of postgres and that's going to give us our development environment where we're going to be running postgres and Docker and we'll keep our main app running in that virtual environment running through poetry and then eventually what we're going to do is for the production mode we are going to be both um dockerizing the database like we do in development but also dockerizing the like built version of this app so we're going to have pretty much uh the database in the app running in two containers and then they're going to be able to communicate with each other that's what we're going to be running on the server whenever we deploy it but enough of this talking nonsense let's go ahead and get started so the first thing I want to do and by the way I already installed let me see if I can find it if I can find it right here uh we might have installed this in the last tutorial but this is the dependency that you're going to need for connecting to postgres so once you have that installed make sure that you go ahead and delete your sqlite database if you have it don't need it anymore and actually let me just copy this in it's probably going to be easier I have my notes to the side here all right so this is the setup that we're going to need for our postgres connection so we switch out the engine again before it was sqlite and now we are going with our postgres backend and then a few things that we're going to need is a name a user and a password to connect to the database and we're just keeping these all as cooking core keeping it simple for now where is the status database running it's going to be running on the same computer localhost on this port this is just a standard postgres Port Atomic request connection Max ages or just some postgres settings and now with this done we can go ahead and start with the docker portion of it so again like I said make sure you have your sqlite database deleted and then what we are going to be doing actually let me talk through a little bit about this before so I assume that you already have Docker installed on your computer and also Docker compose if not go ahead and watch my um probably the first video in my Docker series it'll walk you through that I don't want to repeat anything for those who I'm assume have it already so go ahead and make sure you have those installed and eventually what we're going to be doing is we are going to be creating a docker compose dot yaml file and this is what Docker compose is going to look for and it what this file is is basically consists of multiple containers and it just uh yeah it's just what Docker composes Docker compose uses and for production like I said in the production version of this we are going to have our app and our database however for now since we're not ready to set that up quite yet instead of the stalker compose.yaml create Docker compose dot Dev Dot yaml and then whenever we are running this in our local environment this is what we're gonna pick up instead so what exactly goes in here and actually let me do this again let me know if uh you like me typing all these commands one by one or if you kind of just would rather me paste it in and then kind of talk through it almost like a code review Style like to try and mix things up you know so anyways this is going to be our configuration for Docker compose again um this is just going to be the version Docker compose that we're using in case they changed it later on but the meat and potatoes of this is that this Docker compose file is made up of services now right now we only have one service in here which is our database service but just to kind of take a step back a service is like a piece of our application and it's similar to like an image in Docker but you can kind of think of them like separate uh like mini servers or processes so for example in application maybe we'll have one server or process running redis and then we'll have another server running our like main app so in this case what we're going to do is we're just going to create this one service and it's our database service and most of this is pretty selfexplanatory this is the image that we're going to use just a lean version of postgres now this right here restart and let's stop this is our restart policy so unless we explicitly stop this for example if our um well in production what this means is that if you ever have to like reboot your instance then this is automatically going to start back up and that way you don't have to let go in and manually start everything in Docker again so this is going to be our restart policy for our Port mapping what we're going to just do is uh map 5432 on our local system to this port 5432 and for the environment variables or pretty much the environment set up for this just make sure that your database name the user and the password all match whatever you have right here so again in and you may want to keep an eye out for this but in your Docker compose file you need to prefix these with postgres underscore and also this one's DB and then that's going to refer to the name so a little bit different name and Convention so just look out for that and the last thing that I don't think we talked about even in my darker series is volumes so what are volumes well almost all applications they're going to require some kind of data storage however we want our containers themselves to be as stateless as possible and that way as you know in Docker we can remove them we can stop them we can start them up whenever we want a lot of flexibility to do that now volumes are a way that we can persist data in a way that that can be used by the container and you can kind of think of it like a virtual thumb drive that can be used by the container so whenever we for example stop this service that data is still going to remain so even if we destroy this container this volume data is still going to be there now the first time that we run this Docker compose file which we're going to do in just a second that's going to go ahead and create the initial volume and then whenever like I said we stop it and started it again then that volume is going to stick around so pretty much allows you to reuse it now just to go over the syntax a little bit right here so this is basically saying that this volume the setup right here I'm going to create a like a virtual USB drive on my computer refer to it is postgres SQL hyphen data and use it to store the data at container path VAR lib postgres data now what's up with this path well it's not just a random path this is actually the default directory where the postgres database stores and serves or excuse me where it stores all of its data files like its tables indexes configuration files so on and so forth so yeah that's pretty much what that's doing right there and now with that said I I think I actually made this make Command before yeah so check it out so I made this makemand which is make sure you tag it as phony as well up dependencies only and what this is going to do is it's first going to check if you have this Dot N file and if not it's going to go ahead and touch it or in other words create it and then after that we are going to run this Docker compose command and if you don't include this flag right here then it's going to look for that Docker compose yaml by default but we want to save that one for our production Docker compose so make sure that you explicitly say no we want to run the dev Docker compose file right here and this is just going to make sure that we get a new database each time so with that said what we can do is actually maybe move this down here well oh well actually just to make sure that um and you guys probably won't need to do this but I just want to make sure that I'm starting fresh since I did play around with things before this tutorial I'm going to do Docker system prune wow prune all yes I want to wipe everything out just still wiping okay and I want to also Docker volume prune and that just means if I had any volumes in there I just want to wipe those out as well again you probably won't have to do this but uh just to make sure we're all starting from the same place in this tutorial and now what I want to do is run this command which is pretty much if all goes well it's gonna spin up this instance right here and that is make up dependencies only so okay it looks good I don't have it yet since I just wiped everything out so it's gonna pull it from Docker hub now we wait sweet so it looks like everything is working and now in my local I'm gonna do make run server and actually yes so because all of our data before was in SQL Lite and now it's in postgres we pretty much need to rebuild our database and for that since we have all our migrations we can just do make migrate and then I'm gonna have to create a super user as well so all those migrations are in right there and I'll do make super user and actually I forgot for this I want second I had a custom user set up so it's compatible with the New Boston ecosystem and this is actually uh a pretty cool system because you have like the same account number that you can use across any of the New Boston software but okay so now I created a super user real quick and I'm just going to run this again and now with that said let me pull up this one all right you should be able to go into my admin panel and just log in it was Auto saved and sweet so there we go nothing broke that means that our local version of Docker is working again this make Command is using Docker compose to run the services in our dockercompose.dev file right here and then this is just running our postgres database which we hooked up to our Django app right there all right so things are looking good and now with this all done what we can do now is start working on our production uh version of Docker now the production version of Docker that we're going to be running it's actually going to look pretty similar to this the main difference is that in addition to running our database it's also going to run our app in a separate container and if you're wondering all right well where is that container being built or is it defined that my friend is what we're gonna do right now so let's go ahead and create a new file and we'll just say Docker file and in here just go ahead and paste this in again and talk you through everything in detail all right so starting from the top so our base image that we're going to use is this uh Buster image and this is pretty much um oh it's Debian Buster which is a specific version of the Debian operating system and this one's just uh kind of popular for running python apps and then for our working directly working directory we are going to stick it in opt which stands for optional in a subdirectory called project and this opt directory in Debian is just a um yeah it's just like convention for whenever you are installing optional software that's kind of not part of the main operating system and then these you're going to find in a lot of um dockerized uh python applications uh quickly this first one is just gonna prevent you from writing dot pyc files to your disk this one is going to disable Python's input output buffering and then what this python path dot does this is going to add the current directory to Python's path and why do we do that is because um later on whenever we are importing our own modules it just makes it easier for python to find those now after this you see kind of the um that setup that we had before so I believe in the last tutorial this is another thing that I changed to but let me actually find this my cooking core project I believe it's in right here you see that the prefix for setting environment variables we had to prefix it with this let me actually copy and make sure I got the right one so we want to flag this indocker to be true and in order to do that for our Django app to pick it up we just need to prefix it with this and that way whenever we are running these settings and it picks up this Docker setting right here this is going to be true right here and we already saw how exactly that works behind the scenes and let me close this for now all right close this clean everything up all right so here we are just installing all of the dependencies that we're going to need and these are the like a system it's like a jet flying overhead but um these are like the system dependencies um not our python dependencies which are going to be installed right here actually right here what we're doing is we're just copying over this poetry lock file and also this piproject.tomo file which is pretty much just a list of all our dependencies and then here is where we are actually installing them with poetry and again poetry is going to be installed right here is where we're doing it and now after that jeez how many vehicles are flying in the air tonight Jesus okay now after this we're going to be copying over readme make file pretty selfexplanatory and then here this is where we're going to start copying our actual source code make sure not to forget this line and then one other thing that we're going to do is we're also going to need a local directory in our container as well because right now we have the settings.dev.pui however what we're going to do um in our production app is we're actually going to be setting debug equal to false and we'll also generate another secret key and by the way another thing that I should have mentioned especially when I was setting up that Django admin I built a little helper script right here called production data and if you just run this it's going to give you all of the data that you need for production so it's going to generate that account number because remember I overwrote the user model to use this like custom um like the New Boston compatible user system basically and the signing key is the equivalent of your password more or less and the secret key this is going to be the Django secret key that you are going to be using basically in the production version of these local settings right here but you'll see all that I just want to kind of put in that right now in case I forget and okay moving on so this of course like we saw actually this is a bad comment let me say uh expose uh port 8000. and this is just going to be the port that our application is going to be running on locally not the port that the user is going to hit from the outside um so what we're going to be doing is we're going to be setting up SSL https so they're going to be using Port 443 by default however like um this is all set up where they can just go to our domain name and that's the default Port so they don't have to like explicitly use a 443 or 80 or 8000 or anything like that but anyways moving on to this last bit this entry point so this entry point in this script by the way it doesn't exist yet we're going to be writing that in about like 30 seconds but what this entry point script is is it's pretty much a script that's going to be executed as soon as the container starts up and we'll see what the script is it's it's going to do stuff like um installer migrations and pretty much like run the app so anyways with that being said let me go ahead and copy this because what this line is saying is pay in your scripts directory I'm going to look for a file called entrypoint.sh and then I'm going to copy that over so yeah we're gonna need one right now so for this and again what this is is the main command that's executed whenever this entire thing starts up so let me copy this over as well by the way this is a lot easier for me so I really hope you guys like it not having to type in uh uh explain things at the same time all right so all this is doing and by the way the set eflag just means that if there's any uh errors right here then stop don't try to like power through them because hopefully we don't get error but if we do we want like things to stop so we can actually like check out what's going on and fix it um this is just setting a quick little variable to avoid having to type it multiple times this is just going to Echo out what we're doing and again this is just going to click static and I'm sure you already know what that is and then this is going to run our migrations like we just did a few minutes ago and then this last one is kind of the meat and potatoes to tie everything together we're going to be using poetry to run Daphne because we're no longer using run server since this is a production environment and also we are going to be no longer using whiskey like I said I installed Django channels and that means that we're going to be using Daphne which is capable of running ASCII in other words it just gives us a asynchronous or the ability to use websockets more or less and I already have all of this set up so in uh yeah all that set up I'll need to walk you through that we're going to be running it on Port 8000 and then this is just our uh local logo host basically all right so that is our Docker file again this is pretty much the blueprint for creating the container to run this Django application so now once we have this done we are now just to kind of walk you through what we're going to do we're going to create a new Docker compose file that's capable of running this in production mode which is both the database and this Docker file right here so how do we do that well we go ahead and create that new Docker compose dot yaml file and I can get rid of this one and instead I'll paste in this right there okay so we already know what the majority of this does again version Services again instead of just one service like we had before which was our local database instead in production we're going to be running two services our postgres database and again this is all the same settings we had before and also this other service right here which is our app so this of course is going to be our Django app and what is this saying so the first thing it's saying is okay for this container we are just going to be building whatever is in this current directory and again this is my Docker compose file right here and in that same directory is this Docker file so more or less this app is gonna reference this Docker file right here so whenever Docker compose builds it it's pretty much just going to execute all of this and then last but not least this entry point right here and the restart policy we want the same as our database where unless we explicitly stop one of these then just yeah keep it running and that way like I said if we ever restart our instance or like the power goes out or something whenever it boots back up um we don't have to go in and manually restart everything of course Port mapping right here and also this depends on the service right here and what this means is whenever Docker compose is kind of like uh running these Services wait till this one is booted up first and then run this one right here because we don't want our app running if the database isn't like ready yet and the last couple settings are again setting some environment variables however this time we do need to change one of our database settings so for the databases and this is another uh cool part about this how we set everything up you know how I said that sometimes we need to be able to access nested settings from our environment variables so check this out now I'm kind of glad I get to like show off how everything's tied together right now so now in our project settings base right here so what we need to do is we need to update the uh host right here so instead of localhost what we want to do is we want to say whenever we're running in Docker production then we want to use this database right here in Docker is going to be able to refer to it simply as DB now since this isn't like a simple environment variable because by this I mean usually if you set an environment variable it's just going to override this entire thing but we don't want to override this entire dictionary right here we just want to override one of the values in here this host and keep everything else the same so because in the last tutorials how we set up everything nice and special that's what we can do we can override default host and set that to DB pretty cool and then the last thing that we're going to change is in this local settings path I can just to show you how this is all patched together when we are not running it in Docker just for local development then we have this set equal to local settings dev.pui which is this right here and this is kind of like our default development environment settings however for production we're going to be creating a new file so we don't have you know we just don't want to reuse the same secret key and uh definitely don't want to have it running in debug mode so this is pretty much saying that look for this file and we don't have it created yet we'll actually create this when we deploy but uh yeah that's pretty much all that's going on here so and yeah I think that's actually all we needed to cover um we won't run this right now because we're going to be deploying in the next video and running it right then but uh yeah I think uh pretty much good to go so in the next video like I said we're going to be actually deploying this spinning up a ec2 instance and let's see what else we're going to be doing we will um set up an elastic IP point it to our instance we're setting up a domain name we'll be setting up like SSL to make sure that we can uh access everything over https and yeah we'll even deploy the front end I know that this tutorial series is more for like Docker and you know the back end but I'm guessing that if if anyone's like following along and they're going to be doing this in like a real job you're probably going to end up deploying the front end as well so we'll go through the process of deploying the front end to S3 and then setting up like CDN and stuff yada yada it's going to be awesome very entertaining and educational that's my pitch and uh on that note yeah I'll see you guys next time