all right so now that we have the logic in place to properly send a block to another device next up what we'll do is we'll go ahead and write out all the code to properly accept the block now before we just hop into writing the code as always we'll go ahead and take a look at exactly how this is going to work so what happens is whenever tnb OS receives a block from the core server the first thing that it does is it looks at this field right here the PID now remember this PID the process ID is the same as the app ID so this is essentially how it knows which app to Route this block to so once it has that again it's going to Route it to something called the app router basically passing it off and say hey speed test this block is for you you take care of it from here now what the app router is going to do is it's going to look at this field right here this FN and again this is pretty much a remote function call and for each of these function calls we're going to have a separate listener set up in other words just like the function itself or a function Handler so since we have two functions in the speed test one ping one pong we're also going to have two listeners basically listening for Ping blocks in pong blocks so pretty simple architecture based on this payload it knows which app to Route it to and which listener throughout it to and just like last time what we'll do is we'll kind of work on this From the Inside Out starting with the listeners and then once we have both those written we'll construct the app router and then last but not least we'll plug it into cnbos to say okay I'm now ready to start listening to speed test blocks so for these listeners I like to organize those by creating a new directory called listeners and just like basically every other naming convention the function name followed by a listener is the name of the file so ping listener and from here let me just go ahead and first import everything that I need to and okay so I'm gonna make a function called ping listener and these listeners are all going to follow the same convention whenever they're called they're passed in three parameters the first one is the block itself second one is a dispatch param and this is I'll talk to you about this in just a second but the last one is the network ID and this is just the network that it was sent over and the reason that we pass in dispatch as well is because very often whenever data is received what happens is this listener is going to first validate that data to make sure that everything is received in the correct format pretty much like you're setting up a server or API call and you need to validate that the client sent in the right format now after this usually one of two things happen once you have valid data receive you're either going to dispatch something to your Redux store or you're going to send back a request now in this case once we receive this ping and we validate it and all this validation is going to do is make sure that the Run ID is valid a valid uuid and after we know it's valid what we're going to do is just send back that ping block however a lot of the time for example in this chat app right here whenever another device sends you a chat message and you receive it and validate it then for example you would want to set it in your chat store so that is the kind of basic flow of this now because we're not going to be dispatching any data in this listener I'm just going to replace that dispatch variable with an underscore and also let me go ahead and export this is the default export all right now right after this what I actually like to do is carry off an anonymous async function and let me do that right now so async I'll say now the reason that we need this to be async is like I said once we validate that data we're going to be responding by sending back a pawn block and for that we need to await it so there you go that's a story about that and I also am going to throw in a try catch statement here and for this what we can do is if we want to get really fancy later on we can handle this error by sending back the other device a proper error message and I don't know maybe have some UI to have like a toast appear on the screen or something but for right now keep things simple holy moly what's going on here let me just go ahead and log out this error actually let me do Consular error error and I'm also going to display an error toast and this is just for me debugging purposes whenever we get one since I may not be looking one second let me uh since I'm not often looking in the console all the time just to have something uh pop up on my screen and then I can check the console but this is the basic flow again just a kind of structure everything out we'll say validate data and then once it's valid respond by sending back pop block so to validate this data what we need to do is okay we need to pull off the params because that's where the Run ID is and essentially all we're going to do like I said is make sure that run ID is a valid uuid before I do that let me go ahead and destructure some things from the Block and that is the payload first of all and again this is where those params are and then I also want to check the sender so and the center is going to be needed whenever we are sending back that pong response we need to know who to send it to so there you go and then const params I can just destructure those from payload all right so these params right here if I pull open this you can see that these pink ramps are just going to be equal to a run ID so in our validator we can probably write it right here but just to keep everything standardized what I do for all my validation is I create new directory called validators and then you can probably guess what I'm going to do here I'll just say ping validators now for these validators I'm using the yup Library and I'll show you how we can validate this right now so make validator I'll just say ping validator and we are basically ensuring that we have an object whose key is run ID and whose value is a valid uuid so to verify that or validate I mean we can just say object now in here we are just going to say run ID and that's the key that we're going to be looking for and what is the value well according to the yup you say yup string and you also need to say that this is required and then in addition one last thing it already has this method method built in which is uuid so again we're going to be passing in an object in here which is just our params and it's going to make sure that it conforms to these rules if it doesn't then it's going to throw a validation error so that is why this is essentially going to be handled by this logic right here and use that validator to actually validate our data what we need to do is await it and it was the Ping validator I already have it imported and then on that we call the function validate and pass in the data that we wanted to validate which are these params right here all right so we can remove this comment as well actually this is supposed to be pong block now under here what we can do is we can await that pawn block and again this pong block what it does is it takes a network ID params you guys hear that it's like a monster truck or something outside all right anyways getting a little bit distracted right here okay so the network ID and the params and the recipient which is just a sender property From the Block right here all right pretty sweet and again the reason that we don't have to have any additional checks we can just write it underneath this validator is because if this data is not valid then it's just going to throw an error right here and break out of this block and then just this is our error catching logic right here so anyways that is our listener function and let me actually go ahead and iterate in how I want to do this I'll go ahead and write the pong listener real quick so under here gonna make a new function and I'll kind of just make this a placeholder right now because we want to be spicing this up in just a bit but for right now what I'll do is just to make sure that like things are kind of structured together I'll just log everything out all right so console log block batch and the network ID now remove those so of course the pong listener is eventually going to whenever it receives the pong response then it's going to like uh set the response status and the response date and set everything in Redux but I just want to keep this uh video a little bit lean so on that note now that we have both our listener structured I'm going to go ahead and create that index file just aggregate everything there we go so popping back open our diagram what we did is we just wrote These two uh components I guess not actual components but like pieces of the system so now that we have these the next step is just the aggregate them into our app router so whenever this app router receives a block it knows which one to send them to and for this I will make a new directory called routers and I'll just have one file in here and I'll just say app router was those all right so I'm just going to have one constant in here and I'll just say app router and this is going to be equal to this come on there we go all right so the standard for these app routers is that whenever tnbos finds a matching process ID it's going to send it to this app router and it's going to call this function by passing in a block first and then let me actually steal this too lazy to type out definitely could have just typed it by now but it's oh I could have typed it like eight times by now all right it's gonna pass in a block and then dispatch and then the network ID which is a string and then remember the main job of this app router is to figure out which a listener to forward this data to so to do that we first need to pluck off some data from this block and let me just save this so From the Block what we want to do is we want to look at the payload and we're going to be looking at the function and also the process ID and now based on that we can figure out which Handler or basically listeners to call so I'm going to make a consonant called FN handlers and the keys of these are going to be the function name and that the value is going to be the listener so let me do this so the type of this is an app data handlers and I'll just show you what this means again just a dictionary of these functions right here a Handler it's a handle app data and like I said the keys of each of these is going to be the function so for ping we are going to be forwarding that to the Ping listener and when we receive a block for the pong function of course that's going to be sent off to the pong listener and now just to get my hand there I'll say const FN Handler is equal to one of those function handlers that we just declared above and for the key I'm just going to be passing in this function From the Block payload so that is going to give us one of these hopefully however there is one other Edge case and that is this let me see if I can well we don't need to look at it right now but if we ever were yet lucidchart okay so if we ever kind of structure our block incorrectly and we are sending it to the right process ID so speed test but we're sending it to a function that doesn't exist uh I don't know maybe we had a typo or something we just need to account for that so we'll say if there is no FN Handler if there's no effin Handler that's uh a little inappropriate but all right what do we want to do well let's just go ahead and display an error toast and we'll just say something actually let me steal one from chat so chats react routers all right we'll just deal with this logic so if there's no F inhaler which means if you just you know had a typo in the function name we'll say this process ID dot function is an unknown speed test function and then we'll just return it right there otherwise if you do have a valid FN Handler and you spelled everything correctly got the right process ID and a valid function name then we're just going to call that Handler and again remember each of these which is just the listener it accepts the block dispatch and network ID so again block dispatch and network ID and there you go that is our app router and again that is this right here so now that we have all of this logic written the last thing that we need to do is basically write the equivalent of this Arrow just letting tnbos know that we have a new app router in that if it ever receives a block it can begin routing data to the correct listener so to do that it is pretty easy close these to the right all right so in my speed Titus registration see under speed test and go ahead and import this and all right so this app registration also takes an optional router uh property a router key and this is just going to be equal to whatever your app router is I'm just importing this app router that we just wrote right here and then the last thing is in this app registry right here under app routers we just need to tell tnbos for any speed test blocks that you receive then go ahead and Route it to this router which is the speed test registration router so speed test registration router just like that now what I'm actually going to do is I'm going to open my MacBook and I'm going to pull down this code and then we'll kind of test to see if everything's working all right so I got tnbos running the latest changes pulled down now is the moment of truth so if everything is working correctly when I hit go uh just uh again before I know I'm building up the suspense right here but what should happen is that the my MacBook or the device I'm sending it to should receive this ping function call everything should be valid as long as we didn't make any mistakes and then once it's validating it should send back a pong block and since we have this listener set up um on this device I'll receive this pong message and then this is just going to print out the block a dispatch I don't this is probably going to look weird whenever it prints this out but also the network ID so pop this open send it all right ah beautiful look at that so again this is our block of course we have to do something a little bit more smart than just log this out and this is our ugly dispatch in the network ID pretty sweet just look in the network make sure nothing's breaking nice beautiful so we have some life here we have our two devices communicating with each other all right I'm uh I'm pretty pumped up now so let's see in the next video we uh just have to spice a couple things up of course still got to work on this timer and then actually what we're going to be doing whenever we receive these pong responses is we'll calculate the difference between whenever I first sent that block and whenever I receive that response and of course dispatch everything to Redux log it out in this history table so yeah looking forward to it see you next time