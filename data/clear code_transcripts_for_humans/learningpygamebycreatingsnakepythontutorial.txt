With timestamps:

00:03 - hello there
00:04 - in this tutorial we are going to be
00:06 - creating this snake game and python with
00:07 - the pygame module
00:09 - and this is intended for absolute
00:11 - beginners so you don't have to know
00:12 - anything about the pygame module
00:14 - although you do have to know the basics
00:16 - of python programming in general
00:18 - at least a little bit and i will go for
00:20 - these steps to create the entire game
00:23 - and if you already know the basics of
00:24 - pygame skip ahead to this step
00:26 - then you go straight to the snake game
00:28 - but for everybody else just continue
00:30 - watching and we're gonna talk about how
00:31 - games work in general
00:33 - that is going to be really useful to
00:34 - understand what we are doing a little
00:36 - bit later on in this video
00:39 - so let's talk about how games work and i
00:41 - think this is best done by using an
00:43 - example
00:44 - so here's an image from the first level
00:45 - of super mario world
00:48 - and this image is composed of several
00:50 - elements
00:51 - we start with the background then we add
00:53 - a floor and some bushes
00:54 - then mario himself and finally some
00:56 - indicators at the top
00:58 - and each of these elements is just a
01:00 - picture that you could even download and
01:01 - use yourself
01:03 - and the important thing to note here is
01:05 - that this image
01:06 - is not just drawn once instead it is
01:08 - drawn multiple times per second in what
01:10 - is called a game loop
01:12 - and then to turn this into a game we
01:15 - have to add two more things
01:17 - number one is player input so that you
01:19 - have to know what the player wants to do
01:21 - and number two is that on each cycle you
01:24 - also reposition where elements are
01:25 - supposed to be drawn
01:27 - so in total there are three steps we
01:29 - check for player input
01:30 - we position elements on the screen and
01:32 - then we draw all of these elements
01:34 - and if that happens often enough you get
01:36 - a video game
01:37 - so let's look how this would work in
01:39 - practice so we first want to check for
01:41 - the player input
01:42 - and let's say the player is pressing the
01:43 - button to the right and as a consequence
01:46 - we want to move mario 5 pixels to the
01:48 - right
01:48 - and after that we draw the entire image
01:51 - with mario being 5 pixels further to the
01:53 - right
01:54 - and all of this would happen in one
01:55 - cycle of the game loop
01:57 - and on the next cycle we do the same
01:59 - thing again so if the player keeps on
02:01 - pressing right we still keep on moving
02:02 - mario to the right
02:04 - and redraw the entire thing again and
02:06 - then we keep on redoing this about 60
02:08 - times per second
02:10 - and as a consequence the player is
02:11 - perceiving all of this as an interactive
02:13 - medium
02:14 - and in an actual game much more is
02:16 - happening than just moving a player to
02:17 - the right
02:18 - so for example for mario if he is moving
02:20 - to the right
02:21 - we also want to play a walking animation
02:24 - which further adds to the illusion that
02:25 - mario is walking instead of just being
02:27 - repositioned on the screen
02:29 - but we could also move around enemies or
02:31 - we could give the player power ups
02:33 - or we could add some coins or timers or
02:35 - really anything that would constitute
02:37 - parts of a game
02:38 - and if you understand that logic you can
02:40 - make a game in basically anything
02:43 - as long as you can get these free
02:44 - elements and this could even be a game
02:46 - in microsoft excel this would also be
02:48 - possible but in our case we will use
02:51 - pygame so let's have a look at that but
02:54 - pygame is an external module so you do
02:57 - have to install it from an external
02:58 - source
02:59 - but that is quite easy if you use pip
03:01 - either under powershell or on a terminal
03:04 - in both cases all you have to do is type
03:06 - pip install pygame and you should be
03:08 - good to go
03:09 - although there's one minor complication
03:12 - that if you have pygame 3.9 so the
03:14 - latest version that came out a couple of
03:16 - weeks ago
03:17 - the main version of pygame right now
03:19 - does not work because it wasn't updated
03:21 - yet
03:22 - but that isn't really a problem because
03:24 - there's a newer version of pygame that
03:25 - isn't fully released yet
03:27 - but for our purposes it is perfectly
03:29 - sufficient
03:31 - so if you have the very latest version
03:32 - of pygame all you have to do is type pip
03:34 - install pygame equals equals 2.0.0.dev22
03:40 - and then you should be good to go
03:41 - there's no other change you have to make
03:44 - and with that let's start writing some
03:46 - code here we are
03:47 - in an empty sheet of code but for now
03:50 - the very first thing we have to do
03:51 - is to import pygame which should make
03:54 - sense that if you want to use pygame you
03:55 - have to import it
03:57 - and in here if i execute the code if you
04:00 - are getting
04:00 - this message then the input worked well
04:03 - and along with that we get a hello from
04:05 - the pygame community message
04:07 - along with the link to the website but
04:09 - nothing that's really relevant here
04:10 - so let me close all of that so now we
04:13 - have imported pygame and we can use it
04:15 - but by itself nothing happened yet and
04:18 - to make something happen we have to add
04:20 - a couple more things
04:21 - the very first spring is pygame dot init
04:26 - and this line is quite simple but really
04:28 - important it effectively starts the
04:30 - entirety of pygame
04:31 - so pygm consists of several modules
04:34 - let's say one module for the sound
04:36 - another module for the graphics
04:37 - and all of these have to be started and
04:40 - much later in this tutorial
04:42 - we are going to work a little bit more
04:44 - with pygame.net
04:45 - but for now this is the one line we need
04:47 - to start pygame
04:49 - but if we run the code now we still
04:51 - can't see anything
04:52 - except the welcome message and to
04:55 - actually see something
04:56 - we have to create what's called a
04:57 - display surface and the display surface
05:00 - is basically what the player sees in the
05:02 - end so you might call this the main game
05:05 - window
05:06 - and this also has to be stored in a
05:07 - variable
05:09 - and this is usually called screen
05:12 - and how we create a display service is
05:14 - with pygame dot display
05:17 - dot set mode a slightly weird name but
05:20 - well it is what it is
05:22 - and in here we have the tuple with our
05:24 - width and the height
05:25 - of the window we want to get and let's
05:28 - say in my case
05:30 - i want to go with 400 times
05:33 - 500 so our window is going to be 400
05:36 - pixels wide and 500 pixels high
05:39 - and if i run this code you are going to
05:41 - see something really briefly
05:43 - so let me run it and there we could see
05:46 - a window for a very short period of time
05:49 - and this is by design so right now
05:52 - pygame knows that it's supposed to
05:53 - display a window
05:55 - but it doesn't know for how long to
05:56 - maintain this window
05:58 - and because of that it creates the
06:00 - window and then closes it immediately
06:01 - afterwards
06:03 - and to keep it open we have to create
06:05 - our main game loop
06:07 - and this is just a plain while loop and
06:10 - this while loop we are going to close
06:12 - from the inside
06:13 - so this can just be set to wild true so
06:16 - this while loop by itself unless we stop
06:19 - it from the inside
06:20 - is never going to stop and now in this
06:23 - while loop
06:23 - we need to have one line that is called
06:25 - pygame dot display
06:27 - dot update and what this basically does
06:31 - and let me add a bit of white space is
06:34 - that let's say
06:35 - in this while loop we're going to draw
06:37 - all our elements
06:40 - so for example for snake we're going to
06:41 - draw our background we're going to draw
06:43 - the snake
06:44 - we're going to draw a couple of fruits
06:46 - all of this is going to be drawn
06:47 - in here and then what pygame.display
06:50 - does
06:50 - is that it takes all of this information
06:52 - and displays it on the main display
06:54 - surface
06:55 - so that the player can see it so this is
06:58 - the very minimum you need to display
06:59 - anything
07:00 - and if i run the code now this would be
07:03 - working
07:04 - but i would not recommend to run it
07:06 - right now
07:07 - for the simple reason that we wouldn't
07:09 - be able to close it because we didn't
07:11 - implement this functionality just yet
07:14 - and to implement that we need what is
07:15 - called an event
07:17 - loop and an event loop is well it's a
07:20 - loop that looks for different events
07:22 - and each event could be something
07:23 - different but most of the time an event
07:26 - is some kind of user input so this could
07:29 - for example be you pressing a button
07:31 - like
07:31 - left or right up or down on your
07:32 - keyboard it could also be a mouse
07:34 - movement or us
07:35 - closing the window by pressing the
07:37 - little x on the top right
07:39 - it could also be something else like a
07:40 - timer for example
07:42 - we are actually going to see this later
07:44 - on but let's go for this step by step
07:46 - and the very first thing i want to check
07:48 - is if we are going to press the little x
07:50 - at the top of the window
07:51 - so i have to create a very basic event
07:53 - loop
07:54 - and this is just a for loop so i want to
07:57 - check for
07:58 - event in pygame.event.get
08:03 - so at the start of every loop of our
08:05 - game
08:06 - we are going to check for every possible
08:08 - event and then we can do something with
08:10 - these events
08:12 - and what we have to look for is event
08:14 - dot
08:15 - type and this is going to tell us what
08:17 - kind of event we have
08:20 - and this has to be an if statement so if
08:23 - a certain event type is equal to
08:25 - something we want to do something else
08:27 - and the thing we want to look for right
08:28 - now is pygame.quit
08:31 - and this event type is closing the
08:33 - window by pressing the x button
08:35 - and if that is the case i want pygame
08:38 - dot quit and this for all practical
08:41 - purposes is the opposite of pygame.init
08:45 - but by itself sometimes this can cause
08:47 - some complications
08:49 - that some other parts of the program
08:51 - might still be running so
08:52 - this usually is not enough we want
08:55 - another line of code
08:56 - and what we want is cis dot
08:59 - exit and this is another python module
09:03 - so we have to import it so at the top of
09:05 - our code
09:06 - i import pygame and cis
09:09 - and this is a fairly straightforward
09:12 - module
09:12 - it gives you access to lots of system
09:14 - functionality
09:16 - and what sys.exit does is it basically
09:18 - ends any kind of code
09:20 - that it's being run on so in our case if
09:22 - we run sister exit we make sure our code
09:25 - is definitely closed
09:27 - so with these two lines we make very
09:29 - much sure that our game is going to be
09:31 - closed
09:32 - with that being covered let's try to run
09:34 - our code now and let's see what happens
09:36 - and there we go we have a window that is
09:38 - 400 pixels wide
09:40 - and 500 pixels high and right now it's
09:42 - all black for the simple reason that we
09:44 - haven't drawn anything yet
09:46 - but that we're going to cover in just a
09:47 - second but for now
09:49 - we are able to create a basic pie game
09:51 - window so that's a good start
09:53 - but there's one more thing that's
09:54 - important for the basic setup
09:56 - and let me explain what this is right
09:58 - now our game loop so our wild true loop
10:01 - is going to run as fast as our computer
10:03 - allows it to run
10:04 - so for a really slow computer it might
10:06 - run 10 times per second
10:08 - but for a really fast computer it might
10:10 - run 10 000 times per second
10:12 - and this could be a problem because on
10:14 - different computers the game's speed
10:16 - might be completely different because of
10:18 - this difference
10:19 - so we have to make sure that our game
10:21 - runs at least somewhat consistently
10:23 - and even on the same computer it might
10:25 - run differently depending on how busy
10:26 - our scene is going to be
10:28 - so we want to make sure that our game
10:30 - doesn't run faster than a certain
10:32 - maximum frame rate
10:33 - and for that we have to create a clock
10:36 - object and all the clock object does
10:38 - is that it limits how fast our wire loop
10:41 - is going to run
10:43 - and it's ultimately quite a simple thing
10:44 - to achieve so let's go right back into
10:46 - our code and let's implement this
10:48 - so below our screen variable i am going
10:52 - to create a new variable that i call
10:54 - clock and this is going to create a
10:56 - clock object by typing pygame dot time
10:59 - dot spelling it properly
11:03 - and here do make sure the first letter
11:05 - is capitalized that is important
11:07 - but besides that this is all we have to
11:09 - do so this is a clock object that can
11:12 - help us influence time and pie game
11:15 - but all i want to do is right at the end
11:17 - of our game loop
11:19 - i want clock dot tick and in here
11:23 - we effectively have to pass in the frame
11:25 - rate
11:26 - so how many times this while loop can
11:28 - run per second
11:29 - and in my case i am going to go with 60
11:33 - which is usually a good middle ground
11:35 - for games but you could make this a much
11:37 - larger number if you really wanted to
11:40 - and with this our game is never going to
11:42 - run faster than 60 frames per second
11:44 - or in other words this while loop is
11:46 - never going to execute more than 60
11:48 - times per second
11:50 - which makes our game quite a bit more
11:52 - consistent now there's still the other
11:54 - possibility that our game might run too
11:56 - slow and this is something we don't have
11:58 - a simple solution for
11:59 - this is basically game design that you
12:01 - have to make sure that your game never
12:02 - runs too slow
12:04 - and you are doing that by not having too
12:05 - many elements on the screen for example
12:08 - but in our case since our game is so
12:10 - incredibly simple
12:11 - this is not going to be an issue but
12:14 - alright
12:14 - with that covered we have a very basic
12:17 - window that runs at a maximum of 60
12:19 - frames per second
12:20 - so this is a pretty good start and now
12:23 - let's talk about how to add basic
12:25 - visuals to this
12:27 - to really understand pygame you have to
12:30 - understand
12:30 - two basic elements they are called
12:32 - surfaces
12:33 - and rectangles and let's start with
12:36 - surfaces
12:37 - and here's something slightly confusing
12:39 - earlier in this tutorial
12:41 - we created a display surface and this
12:44 - is different to a regular surface
12:47 - although not that
12:48 - much and let me explain it like this our
12:50 - display surface is the big
12:52 - canvas that our entire game is going to
12:54 - run on and there can
12:55 - only be a single display surface and the
12:58 - display surface is also displayed by
13:00 - default
13:01 - for the simple reason that if we didn't
13:03 - have it we wouldn't have a game
13:05 - now a regular surface does the same
13:07 - thing it is still a layer that we can
13:09 - put stuff on
13:10 - but we can have as many surfaces as we
13:13 - like
13:14 - and each surface is only displayed if we
13:16 - write code for that
13:17 - so you could have quite a few different
13:19 - surfaces if you didn't write code to
13:21 - display them
13:21 - they would be invisible so if you want
13:24 - to use a surface
13:25 - you need to follow two steps you first
13:27 - have to create a surface and then you
13:29 - have to put the surface on the screen
13:32 - and creating a surface can be done in
13:34 - three basic ways
13:35 - if you import an image you are going to
13:37 - create a new surface with the image on
13:39 - it
13:40 - the same is going to happen with text so
13:42 - if you create any kind of text the text
13:44 - is always going to be on a new surface
13:47 - and number three is that you could just
13:49 - create an empty surface that doesn't
13:50 - have anything on it
13:51 - so it would just be black by default
13:53 - although you could also fill it with any
13:55 - color you want
13:56 - and for the second step you have to take
13:58 - the surface and put it on the target
14:00 - surface where you want it to be
14:02 - in our case this is always going to be
14:04 - our display surface
14:06 - although you could also put one surface
14:08 - on any other surface as well
14:10 - but that's quite a bit of talk let's
14:11 - actually play around with this
14:13 - so here i'm back in my code and for now
14:16 - i just want to create
14:17 - a basic test surface and this is going
14:20 - to be
14:20 - just an empty surface and how to create
14:23 - this
14:24 - is pygame dot surface and this
14:28 - kind of like set mode is going to need
14:31 - a tuple with a width and a height
14:35 - and let's make this let's say 100 pixels
14:39 - by 200 pixels and that is
14:42 - all we needed so now we have another
14:43 - surface but if we run the code now
14:46 - we wouldn't be able to see it because we
14:48 - didn't put it on the display surface
14:51 - and this we have to do in our while loop
14:53 - and what i want to do
14:55 - is to put our test surface on our screen
14:58 - display surface
15:00 - and for that we first have to type
15:02 - screen to get our display surface
15:04 - and then blit which stands for block
15:06 - image transfer
15:08 - and then here we need the surface and a
15:11 - tuple with the x
15:12 - and the y position so our surface is
15:15 - going to be our test surface
15:17 - and for x let's go with 200 and for y
15:20 - let's go with 250. so hypothetically
15:24 - we should see something right now so
15:26 - let's try it
15:28 - and our code is running but we still
15:30 - can't see it
15:31 - oh well technically we can but it
15:34 - doesn't help us too much for the simple
15:35 - reason
15:36 - that both our screen and our test
15:39 - surface are both black
15:41 - so technically while they are both
15:43 - visible we can't see them because they
15:45 - have the exact same color
15:47 - so we have to figure out how to add
15:48 - color to each of them
15:50 - and the easiest way to give them color
15:52 - is to use the fill command
15:55 - and let's do this actually on the screen
15:57 - itself
15:58 - so let me add another line of code
16:01 - and i want to fill the screen with a
16:03 - greenish color
16:06 - and for that we need screen dot fill
16:10 - and in here we need some kind of color
16:12 - argument
16:13 - and there are two ways of achieving this
16:15 - in pi game number one
16:17 - is an rgb tuple and number two is a
16:19 - color object
16:21 - the color object is easier to explain
16:23 - you just type pygame.color
16:25 - and insert the string of a name of a
16:27 - color and then pygame picks a specific
16:29 - color that was predefined
16:31 - so for example i could type in here
16:33 - pygame.color
16:35 - and let's go with gold and now if i run
16:38 - this we should see a golden background
16:40 - color
16:40 - and there we go and now we can also see
16:42 - our test surface
16:44 - and here think about the starting
16:46 - position this one is going to become
16:47 - a bit more important in a second but for
16:50 - now we have a basic color
16:52 - but in my case i don't want a predefined
16:55 - color
16:56 - instead i want to define my own color to
16:58 - keep the entire thing consistent in tone
17:01 - and to create a custom color we need
17:03 - what is called an rgb tuple
17:05 - so let me explain what that is rgb
17:08 - stands for red
17:09 - green and blue it's literally that
17:11 - simple and what we basically do
17:13 - is we determine the amount of color for
17:15 - each of these values
17:17 - so for example we could have a hundred
17:18 - percent red zero percent green and zero
17:21 - percent blue
17:22 - and if we then put these colors together
17:24 - we have a red color
17:26 - and that's really all it is the only
17:28 - thing you really have to remember
17:29 - is that the lowest value you can give
17:31 - for each color is zero and the highest
17:33 - 255
17:34 - with 255 being 100 of this color
17:38 - so in my case i'm going to go with an
17:40 - rgb tuple of 175
17:42 - 215 and 70. so our color is going to
17:46 - have
17:46 - quite a bit of green a bit less red and
17:49 - very little blue
17:50 - and this combined is going to give us a
17:52 - greenish color so let's actually
17:54 - implement this
17:55 - so here i'm back in my code and let me
17:57 - get rid of the color object
17:59 - and i want to create an rgb tuple so i
18:01 - create
18:02 - another list and then here i type 175
18:06 - 215 and 70.
18:10 - and now let's try this and there we go
18:14 - now we have a greenish background and if
18:17 - you want to challenge yourself and code
18:18 - along
18:19 - here is going to be a short exercise try
18:22 - to get
18:23 - this test surface and fill it with a
18:26 - blue color
18:28 - and if you want to do it pause the video
18:29 - now and try to do it yourself
18:35 - so this could be done before the while
18:38 - loop
18:38 - and i just want to get test surface dot
18:41 - fill
18:43 - and in here to get a blue color we could
18:45 - either go pygame dot
18:46 - color and in here type blue
18:50 - and if we run the code now our test
18:53 - surface is going to be blue
18:55 - alternatively i could just add an
18:58 - rgb tuple that has 0 red 0
19:01 - green and 255 of blue and if i run this
19:05 - code
19:06 - we have the exact same outcome and with
19:10 - that we have already covered the very
19:12 - basic colors
19:13 - but here's one thing i really want you
19:15 - guys to pay attention to
19:17 - that our test surface we have placed on
19:20 - position 200
19:21 - and 250 and this point is
19:24 - exactly half way of our display so the
19:26 - point we placed it on
19:28 - is right in the middle of the screen but
19:30 - our test surface
19:32 - is very much not in the middle of the
19:33 - screen
19:35 - so what's the problem here and it's not
19:37 - really a problem it's just how pie game
19:39 - works
19:39 - when we specify this point we specify
19:42 - the top
19:42 - left of this surface so of our rectangle
19:46 - the top left point is going to be at
19:48 - position 200
19:49 - and 250 and we are going to get more
19:52 - control over this
19:53 - in just a bit but before that i do want
19:56 - to cover an animation just to cover it
19:57 - on a basic level
19:59 - right now it looks like our surface is
20:01 - being static and well it kind of is
20:03 - but the main principle here is that this
20:06 - image is being redrawn every time this
20:08 - while loop is running
20:09 - and the reason it is static is because
20:11 - the position we put it on is always the
20:13 - same
20:13 - but we could totally change it so let me
20:16 - close it
20:17 - and let's say i want to move the x
20:19 - position so this one
20:21 - and for that i can just add a variable
20:23 - in here
20:24 - and create the variable early on so
20:26 - let's call this x-pos
20:28 - and by default it is 200 so exactly what
20:31 - we had so far
20:32 - so let me run it and we get the exact
20:34 - same result
20:35 - but what we can do now is just to add
20:38 - x plus plus equal one
20:42 - and now let's run the code again and see
20:44 - what happens and there you can see
20:47 - our surface is going to move slightly to
20:49 - the right
20:50 - and this looks like an animation but
20:52 - basically what happens
20:53 - is that every time this wallop is
20:56 - running
20:57 - it is going to put the surface on this x
20:59 - position but this exposition gets
21:01 - slightly larger every time we call it
21:04 - and because this happens at such small
21:06 - increments and so often
21:07 - that to us it looks like a fluid
21:09 - movement so we consider this an
21:11 - animation
21:12 - and we could also do it the other way so
21:14 - with
21:15 - and now let's try it again now our
21:17 - surface is moving the other way so it's
21:18 - going to the left
21:22 - and with that we have really basic
21:24 - animations
21:25 - but there's one thing that is important
21:27 - to keep track of
21:28 - and let me change this back to 200
21:32 - and now i want to move the y position
21:34 - and let me just
21:36 - put an x position in here not great
21:38 - naming but it really doesn't matter
21:40 - and now i want you guys to make a guess
21:42 - is this surface going to move upwards
21:44 - or downwards and what we basically do
21:47 - is make the x position smaller so this
21:49 - one starts at 200 then becomes 199 then
21:52 - 198
21:53 - and so on and let's actually run this
21:55 - and see what happens
21:57 - and here you can see even though our x
22:00 - is getting smaller
22:01 - our surface is moving upwards which
22:04 - can be quite confusing but let me
22:06 - explain what this means
22:07 - the origin of our display surface is in
22:09 - the top left
22:10 - so if you want to go to the right you
22:12 - have to increase x and if you want to go
22:14 - to the left you have to decrease
22:15 - x this part should feel quite natural
22:18 - however if you want to go downwards you
22:20 - have to increase y
22:21 - and if you want to go up you have to
22:22 - decrease y
22:24 - which is the part that can get quite
22:26 - confusing
22:27 - although this is also the part that is
22:29 - really common in video game development
22:32 - and this is going to take you some time
22:33 - to get used to but ultimately it's not
22:35 - that bad
22:37 - and let me close this and let's do the
22:39 - opposite so i want to increase y
22:41 - and and now our test surface is moving
22:44 - downwards
22:46 - [Music]
22:48 - so this is one thing that can get quite
22:50 - confusing
22:52 - but all right let me get rid of these
22:55 - variables because we don't want to go
22:57 - for animations anymore
22:58 - so i just want to place this thing back
23:00 - at position 200 and 250.
23:03 - and let me write again and this is still
23:05 - working and now here's one thing that i
23:07 - talked a tiny bit about earlier
23:09 - that we don't really have all that much
23:11 - control about how to place this surface
23:14 - so for example if we wanted to place the
23:16 - center of the surface we couldn't really
23:19 - do it
23:19 - or let's say if we wanted to place the
23:21 - bottom right we just couldn't really do
23:23 - it
23:24 - and to fix that pie game has another
23:26 - concept that is called a rectangle or
23:28 - wrecked in short
23:29 - and let's talk about those and
23:31 - incidentally they are also the second
23:32 - part on how to draw something in pie
23:34 - game
23:35 - and well a rack is just a rectangle
23:39 - that you can either put around something
23:40 - else or use for drawing
23:43 - and this rectangle has lots of different
23:45 - points that we can
23:46 - influence and you can see all of them on
23:48 - the screen right now
23:50 - and these points are super useful not
23:52 - just for moving something
23:53 - but also to measure if two objects are
23:55 - overlapping for example
23:57 - or if something is moved outside of the
23:58 - screen or you could also measure how
24:00 - large an object is
24:02 - and there are two ways to create a
24:04 - rectangle you could either create one by
24:06 - itself
24:07 - or you could take an existing surface
24:09 - and create a rectangle around it
24:11 - and then once you have a rectangle you
24:13 - can do quite a few different things with
24:15 - them
24:16 - but let's actually play around with this
24:17 - in code
24:19 - so here we are back in our code and the
24:21 - very first thing i want to do
24:22 - is to create a new rectangle let's call
24:25 - this test
24:27 - rectangle and this is just going to be
24:30 - pygame dot rect
24:32 - and in here we have to pass in four
24:35 - different pieces of information
24:36 - we need an x position a y position a
24:39 - width
24:40 - and a height and let's put this thing at
24:43 - position 100 let's say 200
24:46 - and let's give it a width and a height
24:48 - of let's say 100 each
24:52 - and here again this x and y is still
24:55 - going to be the top
24:56 - left but we are going to get more
24:58 - flexible in this in just a second
25:00 - so now we have a rectangle but if we run
25:03 - the code we
25:04 - are not going to be able to see it so
25:05 - this isn't going to do all that much
25:07 - but what i could be doing now is use
25:12 - pygame.draw.rect
25:14 - draw this rectangle and in here
25:17 - i have to pass in three pieces of
25:19 - information i need the surface to draw
25:21 - on
25:21 - i need a color and i need a rectangle
25:25 - so our rectangle is going to be our test
25:27 - rect
25:28 - our surface is going to be our screen
25:31 - and for the color
25:33 - let's go with pygame dot color
25:36 - and i want to go with we haven't used
25:38 - red yet let's go with that
25:40 - and now let's try this and there we go
25:43 - we have another rectangle and this one
25:46 - is not a new surface
25:47 - it's a different kind of object and
25:50 - later on when we create our snake
25:52 - we are going to be drawing lots of
25:53 - different rectangles that we are going
25:55 - to each put on the screen
25:57 - and you might be asking yourself what's
25:58 - the really big difference between
26:00 - creating a new surface and putting that
26:01 - on screen or creating a rectangle and
26:04 - drawing that
26:05 - and well it depends on what kind of job
26:07 - you want to do usually
26:09 - drawing a rectangle is a much simpler
26:11 - task so it takes less code and less
26:12 - processing power
26:14 - and most of the time for surface you
26:16 - don't just fill the surface you add
26:18 - something else
26:18 - to it so that just filling a surface and
26:21 - putting on the screen doesn't really
26:23 - happen if you want to do that you would
26:25 - just use a rectangle
26:26 - and there are quite a few different
26:27 - things we could draw this could also for
26:29 - example be an
26:30 - ellipse and now if we run this we get a
26:33 - circle
26:34 - and there are quite a few different
26:35 - shapes you could be drawing but i don't
26:37 - want to draw anything just yet
26:39 - and i also don't want to create a
26:40 - surface like that just yet
26:43 - instead what i want to do is to get this
26:46 - test surface
26:47 - and use that to create a rectangle and
26:50 - for that we need
26:51 - test surface dot get wrecked
26:55 - and what this one is doing is it gets
26:57 - this surface
26:59 - and it puts a rectangle around it but
27:02 - the really useful thing now is that in
27:04 - the parenthesis
27:05 - we can specify on what point we want to
27:08 - place it on
27:09 - so for example i could type center
27:12 - and now in here add an x and a y
27:14 - position
27:15 - so for example now if i add in here 200
27:19 - and 250 this rectangle would be placed
27:22 - right in the center of the screen and
27:25 - then
27:25 - when i use blit or original test surface
27:28 - i could use this rectangle to actually
27:30 - place the surface
27:32 - so let me remove those two points and
27:34 - insert test
27:36 - wrecked and now if we run this
27:40 - we get our surface right in the middle
27:42 - of the screen
27:43 - and there is quite a few different
27:45 - things going on right now so let me go
27:46 - through them one by one in terms of what
27:48 - i have just done
27:50 - i have first created a new surface
27:52 - called test surface
27:53 - and this surface is 100 pixels wide and
27:55 - 200 pixels high
27:57 - then i have drawn a rectangle around the
27:58 - surface and i have placed this rectangle
28:01 - right in the middle of our screen and
28:03 - then i have used this rectangle to
28:05 - actually
28:05 - place the test surface on the screen and
28:08 - we could also use another point
28:09 - for example i could use top
28:13 - right and then we'd be placing the top
28:15 - right
28:16 - so now the top right corner is in the
28:18 - center of the screen and this way you
28:20 - get a ton of control over how you place
28:21 - elements on the screen
28:23 - and let's actually try to move this
28:24 - rectangle to move our surface
28:27 - so i want to get our test rectangle
28:30 - and i want to move the right position
28:33 - and just add plus equals let's say one
28:36 - and let's try this now and now again we
28:38 - can see our surface moving to the right
28:41 - and the important point here is that if
28:44 - we move any point on the rectangle we
28:45 - are going to move
28:46 - all the points on the rectangle so we
28:48 - could for example also move the left of
28:50 - the rectangle
28:52 - and we'll have the exact same result so
28:54 - this one doesn't really matter
28:56 - and all right with that we have covered
28:58 - the absolute basics of pygame
29:00 - that was quite a bit of material so if
29:03 - you feel overwhelmed
29:04 - don't worry too much because i will go
29:06 - very slowly through all of this
29:08 - while i actually create the game so let
29:10 - me get rid
29:11 - of all of this material besides this
29:13 - green dot fill color
29:16 - so now we are back to a very basic setup
29:18 - that's just a green background color and
29:20 - doesn't do anything else
29:21 - and on that we are going to create our
29:24 - snake game
29:25 - but before we come to the actual code
29:26 - for the game let's first talk about the
29:28 - logic
29:29 - on what we are going to do and there are
29:31 - two main concepts you have to understand
29:33 - for the snake game to work number one is
29:36 - that we are effectively creating a grid
29:38 - on our display but we are not really
29:41 - creating a grid
29:42 - we are just simulating it and instead
29:44 - what we are going to do
29:45 - is that every time we are moving we can
29:48 - only move in certain increments
29:50 - so let's say every time you move you
29:51 - have to move by the amount of 40 pixels
29:54 - and since you can only move by that
29:55 - amount you are effectively moving in a
29:58 - grid
29:58 - although it's not really a grid it just
30:00 - looks like one and into this grid we are
30:03 - going to put our snake and that's going
30:04 - to be the second major concept
30:07 - and effectively our snack is going to be
30:08 - a list with different positions
30:10 - and each of these positions is a block
30:13 - and all we are going to do to move the
30:14 - snake is to update each of the block in
30:16 - a certain direction
30:18 - and then we are drawing the block and
30:19 - that gives us a snake
30:21 - ultimately it's actually a really simple
30:23 - logic but i think there was a ton of
30:25 - material covered let's actually start
30:26 - talking about the snake
30:28 - now that we have covered the basic logic
30:29 - of pygame and also logic to make the
30:31 - snake game work
30:32 - we can actually start making our game
30:35 - and i'm going to start setting up our
30:37 - board
30:37 - and placing one piece of fruit in there
30:39 - and the reason for that is that the
30:41 - fruit works in almost the same way that
30:42 - the snake does
30:44 - so the fruit is a really nice way to
30:45 - start with the board and see how we can
30:47 - place elements in there
30:49 - here we are in the code that we have set
30:50 - up earlier and the first thing i want to
30:52 - do
30:53 - is to change the size of our window so
30:55 - these two coordinates
30:57 - because right now they are fixed but i
30:59 - want them to be a bit more flexible
31:02 - and essentially what i want to achieve
31:04 - is that we have one variable with the
31:06 - number of cells
31:07 - and another variable with the size of
31:08 - each cell and then those two numbers
31:10 - combined create the size of our screen
31:13 - so if we always fill the entire screen
31:14 - regardless of how big the cells are or
31:16 - how many cells we have
31:18 - and for that i'm going to create two new
31:20 - variables
31:21 - the first one is going to be cell size
31:24 - and i've set this to 40 and then we need
31:27 - a cell
31:29 - number and this one i've set to 20
31:32 - and at least for now you could change
31:33 - these numbers to whatever you want it
31:35 - doesn't really matter until we add
31:37 - graphics to the entire game
31:39 - but now for the dimension of the screen
31:41 - i want the cell number
31:43 - multiplied by the cell size
31:46 - both for the x and for the y
31:50 - so now when i run the screen we are
31:53 - getting a screen that is 800 by 800
31:55 - pixels wide
31:56 - or 40 times 20. so this seems to work
31:59 - quite well
32:00 - and that's really all we need to set up
32:02 - the basics of our game
32:04 - so with that covered we can start
32:06 - creating our fruit
32:08 - and this is going to be a class or well
32:10 - it's going to be an object but we have
32:12 - to create a class for that
32:14 - it doesn't need to inherit anything and
32:16 - when i initiate it
32:19 - i own itself and now i want to achieve a
32:23 - couple of things with this class
32:26 - so let me just write it in the comments
32:29 - number one
32:30 - is that i want to create an x
32:33 - and y position so we can actually place
32:36 - it somewhere on the grid
32:38 - and besides that i also want to draw
32:41 - a square so whatever this position is i
32:43 - want to draw a square which is going to
32:45 - be the fruit
32:46 - and later on we are going to add
32:48 - graphics to this but for now this isn't
32:50 - going to matter
32:51 - so i want to create self.x and let's say
32:53 - for now this is going to be
32:55 - 5 and then i want self dot y
32:59 - and let's go with 4. so right now these
33:02 - are fixed numbers i am going to change
33:03 - them just a bit
33:05 - and having these two numbers along with
33:08 - a cell
33:08 - size would actually be enough to already
33:11 - draw a rectangle
33:12 - however i'm going to put one step in
33:14 - between but i'm going to store these two
33:17 - values
33:17 - inside of a vector 2d and let me explain
33:20 - why
33:21 - throughout this entire tutorial we are
33:24 - going to work very extensively with
33:25 - two-dimensional data
33:27 - so we want to have a really efficient
33:28 - way to work and store two-dimensional
33:30 - data
33:31 - so that we can change an x in the
33:32 - y-coordinate really easily
33:35 - and vectors are perfect for that and to
33:38 - explain
33:38 - why let me illustrate a difference
33:40 - compared to a list with two values
33:42 - you can see a vector that has an x
33:44 - coordinate of 5 and a y
33:45 - coordinate of 4 and at a normal python
33:48 - list with 5 and 4.
33:49 - and right now both of these express the
33:51 - exact same information
33:53 - and the first advantage of vectors is
33:55 - that accessing the x into y is a bit
33:57 - clearer compared to a list
33:59 - so if you want to access the x or the y
34:01 - for a vector
34:02 - we can just take the vector place x
34:04 - afterwards and then we get the x
34:06 - and the same for y and for a list we
34:08 - would have to use indexing and just add
34:10 - square brackets into 0
34:12 - or 1. and while this is quite a minor
34:14 - advantage it does make our code
34:16 - considerably more readable if we have
34:18 - more code
34:18 - so this is a nice thing to have but the
34:21 - really
34:22 - important thing that really helps us
34:24 - with vectors is vector math
34:26 - and here's what this means let's say we
34:28 - have our list and we want to move this
34:29 - cell to the right
34:31 - and moving something to the right just
34:33 - means increasing the x by the amount of
34:34 - one so in the list we would use indexing
34:38 - to get the x value and then just add one
34:40 - to it
34:41 - and this would be a fairly
34:42 - straightforward operation and don't get
34:44 - me wrong we could use
34:45 - lists for the entire game it would be
34:47 - doable but also kind of annoying to work
34:49 - in
34:50 - because in vectors doing this kind of
34:51 - thing is much easier
34:53 - because when we have a vector we can
34:54 - just create another vector that has a
34:56 - value of 1
34:57 - and 0. so this would be a movement to
34:59 - the right and then we can just add this
35:01 - vector to the original vector
35:03 - and if you add two vectors together you
35:05 - get the sum of both of the x values and
35:07 - both the y values
35:09 - so if you wanted to move the vector to
35:10 - the right we could just add a plus
35:13 - right vector and then we have moved it
35:14 - we would not need to identify any
35:16 - specifics of the vector we could just go
35:18 - straight ahead
35:19 - and especially for the snake later on
35:22 - this is going to be
35:22 - so much better to work with but alright
35:26 - i hope that makes sense and now let's
35:28 - actually implement it
35:29 - so here we are back in our code and i
35:31 - want to add these two values inside of a
35:33 - vector
35:34 - so i create a new attribute with self
35:36 - dot let's call it position
35:38 - and to create a vector 2d in pi game we
35:40 - need
35:41 - pygame dot math dot
35:45 - and in here we have to create an x and a
35:48 - y value
35:49 - which we already have we just created
35:51 - them
35:52 - and this is terrible spelling self and
35:55 - self so we just place these two values
35:59 - inside of this vector and then we have a
36:02 - two-dimensional vector
36:04 - and there's one more change i do want to
36:06 - make that i don't want to type
36:08 - pygame.math every single time i just
36:10 - want to type vector2
36:12 - so in the import i'm going to type from
36:16 - pygame.math import
36:20 - vector2 and that way i can just type
36:24 - vector2 which is going to save me so
36:26 - much writing
36:28 - and with that we have a really efficient
36:30 - way to store two-dimensional data that
36:32 - we later can use to draw a square
36:34 - so that's quite nice and with that
36:37 - covered
36:38 - i want to create a new method that i
36:40 - call draw fruit
36:42 - so this one is well it draws the fruit
36:45 - and let me get rid of these two comments
36:48 - all right so what i want to do in here
36:50 - is first create
36:53 - a rectangle
36:56 - in the right position and then i want to
36:59 - draw the
36:59 - rectangle so let's work through them
37:03 - the first one is to create a rectangle
37:06 - and let's call this one fruit rect
37:11 - and this one is just going to be a pie
37:13 - game
37:14 - wrecked object and this one is going to
37:16 - need an x-coordinate
37:18 - a y-coordinate then we need a width and
37:21 - a height
37:22 - so we need four different pieces of
37:24 - information and two of them are super
37:26 - easy to get because width
37:28 - and height are just going to be our cell
37:30 - size so i can literally just copy
37:32 - cell size and paste it in there
37:36 - and then we are already halfway there
37:38 - and then we have to figure out the x
37:40 - and the y and well this is going to be
37:43 - for now this position
37:45 - so what i want to get is self dot pause
37:47 - this would be
37:48 - the entire vector but i only want to get
37:51 - the x position so in this case this
37:54 - would be 5
37:55 - and then i want to do the same thing for
37:57 - our y position
37:58 - so self.y which will get us this value
38:02 - which is 4. and that is literally all we
38:05 - need to create a basic rectangle
38:07 - and now we can get to drawing it and
38:09 - really all we have to do
38:11 - is type pygame.draw.rect which draws a
38:14 - rectangle
38:15 - and in here we need three different
38:17 - pieces of information
38:18 - we need a surface to drawn a color and
38:21 - then
38:22 - a rectangle that we want to draw and we
38:24 - already have most of this information
38:27 - so our rectangle is just going to be the
38:29 - fruit rectangle we just created
38:32 - and the surface we want to draw on is
38:34 - this green surface so our main display
38:36 - surface
38:37 - so that is already getting us quite far
38:40 - ahead
38:40 - now we need to work on the color and
38:42 - this is going to be an rgb tuple and for
38:46 - that the amount of red
38:47 - is going to be 126 the amount of green
38:50 - is 166
38:51 - and the amount of blue is 114
38:54 - and for now this is just going to be a
38:56 - plain darkish green
38:58 - it doesn't look particularly good but
38:59 - later on we are going to replace it
39:01 - anyway
39:01 - so it doesn't really matter and all
39:04 - right
39:04 - this is actually almost all we need so
39:07 - let's actually create a basic fruit just
39:09 - to see how this would look like on our
39:11 - game
39:12 - so i'm going to create a new object with
39:15 - the fruit class and then in our main
39:19 - game loop
39:20 - after screen.fill i type fruit dot
39:24 - draw our fruit so that we can actually
39:26 - see it on the game
39:28 - and let's run this and see what happens
39:30 - so now we can't see our green rectangle
39:32 - but there are two problems number one is
39:35 - that the rectangle is way too far in the
39:37 - top left
39:38 - so something went wrong when we placed
39:40 - it and number two if you look at the
39:42 - bottom of the screen
39:43 - is that python is giving us a warning
39:45 - about implicit
39:47 - conversion to integrals using int and
39:49 - both of these
39:51 - we can fix quite easy because they
39:52 - happen in the same line
39:54 - in this line here so let's work for them
39:58 - step by step
39:58 - and the first one is the actual placing
40:00 - of this rectangle
40:02 - so right now for example this
40:04 - self.post.x is five
40:07 - so when pygame places it it literally
40:09 - places it 5
40:10 - pixels from the left but we don't want
40:13 - to place it 5 pixels
40:14 - instead we want to place it 5 times the
40:17 - cell size
40:18 - and same for position.y right now it's
40:20 - placed 4 pixels from the top
40:22 - but instead we want to place it four
40:24 - pixels multiplied by the cell size
40:27 - so literally all we have to do in here
40:29 - is to multiply
40:30 - this by cell size and this is what i
40:33 - explained earlier
40:34 - that we don't really create a grid
40:37 - instead we move each object by one pixel
40:39 - and then multiply it by the cell size
40:42 - and this creates the illusion of a grid
40:44 - and this is really all we need
40:46 - and let's try this so
40:49 - this is looking so much better and just
40:52 - to test
40:53 - let me change both of these to zero so
40:55 - we can tell
40:56 - if they are in the top left and
40:59 - there we go now we have our square in
41:01 - the top left
41:03 - and just to make one more test let's put
41:05 - it to 10
41:06 - so now it should be on the left and
41:08 - roughly in the middle of the screen
41:11 - and there we go this seems to be working
41:13 - now
41:14 - so now we actually have a basic grid
41:16 - that we can use to place
41:17 - elements on and with that we can also
41:21 - work on the second problem
41:22 - that way of an implicit conversion to
41:24 - integers and what this basically means
41:27 - is that pygame.rec wants to have
41:28 - integers for all of its values but
41:30 - getting values from a vector is always
41:32 - going to be a float
41:33 - even if we pass integers into it so
41:36 - right now
41:37 - python converts both of these into
41:38 - integers by itself
41:40 - but this might be removed in a future
41:42 - version of python
41:44 - so to make sure our code is going to
41:45 - work in the future we have to do this
41:48 - manually which is super easy to do all
41:50 - we have to do
41:51 - is to put the end method around it and
41:53 - we're good to go so let me do it for
41:55 - both of them
41:56 - and now if we run it we don't get an
41:59 - error message anymore
42:00 - and all seems to be good cool and really
42:02 - all the integer method does is it takes
42:04 - a value and turns it into an integer
42:06 - that's really all that happens here and
42:08 - before we finish this part there's
42:10 - one more change i do want to make that
42:12 - right now both of these values
42:14 - are fixed but we want them to be random
42:17 - and to do that we have to import another
42:20 - module
42:20 - the random module which can generate
42:23 - random numbers
42:24 - and what we want is random.rand
42:28 - int which generates a random integer
42:30 - from one value to another
42:33 - and we always want to start at zero and
42:35 - we want to go all the way to our cell
42:37 - number
42:38 - so cell number however there's
42:42 - one more thing we do have to do that
42:45 - rent in
42:45 - goes from this number all the way to
42:47 - this number and it also
42:49 - includes this number so this could be a
42:52 - number from 0
42:53 - to 20. and whenever we draw a rectangle
42:56 - this position is going to be the top
42:58 - left so there's a very small chance that
43:00 - the top left might be something like 0
43:02 - and 800 and this would be outside of our
43:05 - window
43:06 - so we have to subtract 1 from this
43:10 - and this ensures that we are always on
43:12 - screen
43:13 - and since we have a square we can just
43:15 - copy the entire thing for our y position
43:17 - and with that done let's try it a couple
43:19 - of times so we have a random square here
43:22 - let me close it and let's try it again
43:24 - we have a different position
43:26 - and one more time we have another
43:28 - different position
43:29 - cool and for now this is all we needed
43:32 - for the fruit
43:33 - so i can close it and we are going to
43:35 - make one more change later on to it but
43:37 - for now it's working as intended
43:39 - and alright now that we have covered the
43:41 - basics of the grid we can actually start
43:43 - creating our snake
43:45 - and the snake is going to work in a
43:47 - really similar way compared to the fruit
43:49 - the only difference being that now we
43:51 - don't just draw one block on the screen
43:52 - we draw multiple but we are still going
43:56 - to use
43:56 - vectors so effectively what we are going
43:59 - to do is we have a list with all the
44:00 - blocks now a snake
44:02 - and we cycle through this list and draw
44:03 - all of these blocks
44:05 - so let's start with that and once we
44:07 - have that we can talk about moving the
44:08 - snake
44:10 - so here we're back in our code and i
44:12 - want to create a new class
44:14 - that i call snake and i'm going to
44:17 - initiate it
44:18 - as always there's nothing special we
44:20 - need here
44:22 - and for now i only want to have a single
44:24 - attribute
44:25 - that is going to be the body of our
44:27 - snake and this is going to store
44:29 - all the vector 2s that create our snake
44:32 - and in here we are going to place all
44:33 - the blocks that constitute our snake
44:36 - and let me actually add some just to
44:38 - visualize this so i want vector 2
44:42 - and let's go with 5 and 10. so this is
44:45 - roughly in the middle
44:47 - then i want to have another vector and
44:50 - one more let's start with three
44:52 - and are going to be six and seven
44:55 - so this is just going to be three blocks
44:58 - right next to each other
45:00 - and this is also what the player is
45:01 - going to see when the game is being
45:03 - started
45:04 - so this would always be the starting
45:05 - position but you could change it as much
45:07 - as you want
45:08 - but all right now i need a method that
45:11 - draws
45:11 - our snake does not need any parameters
45:15 - and all i want to do in here is for
45:18 - block
45:19 - in self.body
45:22 - so i'm going to cycle through all of
45:24 - these vectors
45:26 - and i want to do something with each of
45:28 - them and in here
45:30 - very similar compared to our draw fruit
45:33 - i
45:33 - want to create a
45:36 - rectangle from the position and then
45:40 - draw the rectangle
45:43 - so this is going to be incredibly
45:44 - similar to our draw fruit method
45:46 - actually
45:47 - so let's go through it step by step and
45:49 - this could actually be an exercise if
45:51 - you want to challenge yourself
45:52 - try to cycle through this list and draw
45:54 - all of these vectors
45:56 - and this should look incredibly similar
45:58 - compared to these two lines
46:00 - so pause the video now if you want to go
46:02 - along and try this yourself
46:05 - so the very first thing i want to do is
46:08 - to create a new rectangle
46:10 - i call this one block
46:13 - and what we need again is pie game.rect
46:16 - and here we need an x a y a width
46:20 - and a height and again the width and the
46:23 - height
46:24 - are super easy it's again the cell size
46:26 - so all i want
46:27 - is the cell size for the width and the
46:29 - cell size for the height
46:31 - now for the x i want the block
46:34 - so this block here which right now let's
46:36 - say for the first element would be the
46:37 - vector of
46:38 - 5 and 10. and since we're looking at the
46:40 - x this is going to be
46:42 - x so this is literally the same thing we
46:45 - have done here
46:46 - and from there we have to multiply this
46:48 - by our cell size
46:50 - and then to avoid the warning by python
46:53 - again
46:53 - we have to put all of this into an
46:55 - integer statement
46:57 - and that's basically it so now i can
47:00 - copy the entire thing
47:02 - and place it in for the y and then
47:04 - change
47:05 - block dot y and
47:08 - here what you could be doing to make all
47:10 - of this a bit more readable
47:12 - is to create all of this on a few
47:15 - separate lines
47:16 - so our x position would be all of this
47:19 - and then i can copy it and create our
47:22 - y position
47:26 - and then in here i could just write x
47:29 - position
47:31 - y position so this would have the exact
47:34 - same outcome
47:35 - although i guess this one is quite a bit
47:37 - easier to read
47:38 - but it's ultimately up to you but okay
47:41 - now we have a rectangle
47:42 - we just have to draw it so again i want
47:46 - pygame.draw.rect
47:48 - and in here i still want our screen
47:50 - surface to draw on
47:52 - and now i'm going to need a new color
47:55 - and i went with 133
47:57 - 191 and 122
48:01 - and then for the rectangle we just want
48:03 - our block rectangle
48:05 - and with that we have drawn all of these
48:08 - vectors
48:09 - so now all we have to do is to create an
48:12 - object from this class
48:17 - and then in our game loop just called
48:19 - snake dot
48:20 - draw snake
48:23 - and let's see if this is going to work
48:25 - [Music]
48:26 - and
48:26 - there we go we have our basic snake
48:29 - although i think right now the color is
48:31 - a bit hard to see
48:33 - so let me close it and go all the way
48:35 - back to our snake
48:37 - and let's change the green value to 111
48:40 - this is going to turn the entire thing
48:42 - quite a bit more red and let's try it
48:44 - now
48:44 - and there we go this is quite a bit
48:46 - easier to see but ultimately it doesn't
48:49 - matter all that much because we are
48:50 - going to replace all of this with proper
48:52 - graphics later on
48:53 - but i think for now this is a bit nicer
48:55 - to work with
48:57 - but okay now we have drawn all the basic
49:00 - things we need to make the game
49:01 - workable but our snake doesn't move and
49:04 - let's work on that
49:06 - okay so let's talk about how to move the
49:08 - snake so here's a snake
49:10 - and let's say we want to move this snake
49:11 - one field further to the right
49:13 - to achieve that we take the hat and move
49:16 - it one block further to the right
49:17 - then we take the block before the head
49:19 - and move it to where the head used to be
49:21 - and then we go through the entire snake
49:23 - and do this to every block
49:25 - so that the position of every single
49:26 - block takes the position of the block
49:28 - that came before it
49:30 - and that way every single block follows
49:32 - the head of our snake
49:33 - and this is how we are going to move the
49:35 - snake so we are not actually moving the
49:37 - snake
49:38 - instead we are taking each of the block
49:40 - and putting them in different positions
49:41 - and this simulates the illusion of
49:43 - movement
49:45 - and here's how we are going to simulate
49:46 - this in our code
49:48 - besides our self.bodylist we are going
49:50 - to add a self.direction
49:52 - and this gives us the direction that the
49:53 - snakehead is going to take in the next
49:55 - turn
49:56 - and then in our game at certain
49:58 - intervals we take the first element of
50:00 - our self.body list
50:01 - which is the head and move it by the
50:03 - direction and this way we're moving the
50:05 - head of the snake
50:07 - and then we're going to create a new
50:08 - list that copies our entire self.body
50:11 - except for the last element
50:13 - and to this new list we are going to add
50:15 - our head and that way we have moved
50:17 - every single item inside of the list
50:19 - one step further and we also added a new
50:22 - item at the front for our head
50:23 - so that's quite a bit of logic so let's
50:25 - actually implement it
50:27 - and there are two more things that we
50:28 - really need to make this work
50:30 - number one is that we need some player
50:32 - input so that we can control the snake
50:34 - and number two is that we have to create
50:36 - a basic timer
50:37 - and then we only want to move our snake
50:39 - whenever this timer triggers
50:40 - and in my case this is about every 150
50:43 - milliseconds
50:44 - so quite a few things to cover and let's
50:46 - just start very simple and we only want
50:48 - to move our snake to the right
50:50 - so here we are back in our code and i'm
50:52 - still working in my snake class
50:54 - and what i want to do is to create a new
50:56 - method
50:57 - that i call move snake
51:00 - it doesn't need any parameters and in
51:03 - here we are going to move our snake
51:05 - and the first thing i want to do is to
51:07 - create a copy of our body
51:11 - and this i can just do with self.body
51:13 - and then using slicing
51:15 - so right now this would copy our entire
51:17 - list but we don't want to copy the
51:19 - entire thing
51:20 - we only want to have the first two
51:22 - elements so we are going to go
51:24 - from the first element to the one
51:26 - element before the last
51:28 - so this list right now would only give
51:30 - us these two elements
51:31 - so this element here at the end would
51:33 - just disappear which is exactly what we
51:35 - want because we want to move the snake
51:36 - forward
51:38 - and then to this list i want to
51:41 - insert another element right at the
51:44 - beginning
51:44 - and this is going to be our head that we
51:46 - are moving so this has to be at
51:48 - index 0 so it's right at the start of
51:50 - the list and the value it is going to
51:53 - have
51:54 - is the previously first item of our list
51:58 - plus a direction and this direction
52:02 - we are going to create from player input
52:04 - but for now
52:06 - it is just going to be a vector 2 that
52:09 - points to the right
52:10 - and let me just type it properly vector
52:12 - 2.
52:13 - let's say for now it's going to be 1 and
52:15 - 0 so it moves to the right
52:18 - so this is self.direction
52:21 - and this is really all we need for the
52:23 - basics of our snake movement
52:25 - so we copied the entire self the body
52:27 - list but
52:28 - removed the last item and then for the
52:31 - hat
52:31 - we're adding one more element right at
52:33 - the front that is going to be the first
52:35 - element of the previous list
52:36 - last the direction we want to go in and
52:39 - that way the entire snake is moving
52:40 - forward
52:42 - now for the last bit all we have to do
52:44 - is self.body
52:47 - is our body copy so that
52:50 - we are returning the entire list back to
52:52 - our body because this is the one we are
52:53 - going to draw
52:54 - and i don't want to change this entire
52:55 - thing again and
52:58 - really this is all we needed to move our
53:00 - snack in the most basic way
53:01 - but here's the problem now i don't want
53:03 - to execute this method all the time
53:05 - i only want to execute it at certain
53:07 - intervals in my case every 150
53:10 - milliseconds
53:11 - so we need to create a timer and timers
53:14 - in pygame work within the event loop so
53:17 - this part here
53:18 - because this event loop can look for
53:20 - different things right now we only look
53:22 - for one specific event that we are
53:24 - closing the game
53:25 - but there could be lots of other events
53:28 - and in a bit we are going to add more
53:29 - events for player input
53:31 - but we could also add another event that
53:33 - is just a timer that triggers every few
53:35 - milliseconds
53:36 - and this we are doing in two lines of
53:38 - code the first one
53:40 - i am going to call screen update and
53:42 - this is going to be a variable that we
53:44 - don't want to change
53:45 - and this one is a pygame dot user
53:48 - event and let me just type it properly
53:51 - so this would be a custom event that we
53:54 - could trigger
53:55 - and how we triggered is by creating a
53:57 - timer
53:59 - and to create a timer we need pygame dot
54:01 - time
54:02 - dot set timer
54:05 - and in here we need our event so screen
54:08 - update and then how often we want to
54:11 - trigger it
54:12 - so my case 150 and this is
54:15 - in milliseconds so this event is going
54:18 - to be triggered every 150 milliseconds
54:21 - and then in the event loop we can
54:23 - capture it
54:24 - so if event dot
54:27 - type is equal to screen update
54:32 - then we want to do something and what i
54:34 - want to do
54:35 - is to get our snake and i called the
54:38 - method move snake so snake dot
54:42 - move snake and this is all we needed so
54:45 - let's try this now
54:47 - and there we go we have a moving snake
54:49 - that moves to the right
54:51 - obviously right now we can't control it
54:53 - so it's not particularly useful
54:54 - but it is working so with that covered
54:58 - let's actually work on keyboard input
55:00 - and this still
55:02 - happens in the event loop so we can just
55:04 - keep on working in here so again
55:06 - if event dot type
55:10 - and this time we look for pygame dot key
55:13 - down
55:14 - so this is going to be triggered
55:15 - whenever we press any button on the
55:17 - keyboard
55:18 - but we want to check for specific keys
55:20 - so we have to look for
55:22 - if event dot key
55:25 - is equal to let's say in this case
55:27 - pygame
55:28 - dot k up and this pygame dot
55:32 - k up would be the up key on your
55:34 - keyboard so when we press this
55:36 - then we want to do something and what we
55:38 - want to do
55:39 - is to get our snack again and
55:42 - what i want to change is the direction
55:45 - so right now
55:45 - our direction is going to be one and
55:47 - zero so we're moving to the right
55:50 - but if i press up this should be
55:53 - back door two and we don't want to move
55:56 - to the right
55:56 - and we move up so minus one so now if we
56:00 - run the game
56:02 - we are still moving to the right but if
56:03 - i press up we start to move upwards
56:05 - so this is working quite well and now
56:08 - all we have to do
56:09 - is to copy this line a couple of times
56:11 - for each direction we want to go
56:12 - in and this could actually be a really
56:14 - good exercise for you to understand
56:16 - vectors so if you want to code the long
56:18 - pause the video now
56:19 - and try to add three more if statements
56:22 - go left
56:22 - down and right
56:26 - let's do it together now so i want to
56:29 - take
56:30 - this entire thing and just copy it a
56:32 - couple of times
56:34 - and the first one let's go with right
56:37 - this one is going to be one and
56:40 - zero then let's go
56:44 - now with down and down
56:47 - it's just y equals one and then finally
56:51 - we wanna go to the left and left is
56:54 - going to be minus one
56:55 - and zero and that is pretty much it
56:59 - so let's try the entire thing now and
57:00 - let's see how this works
57:02 - so we can still run around and
57:05 - this is working really well
57:09 - obviously right now i can go over our
57:12 - fruit and nothing is going to happen
57:14 - but this we are going to cover in the
57:16 - next part which is going to come now
57:18 - actually
57:19 - so now we have a snack that can be moved
57:20 - around and we have a fruit on the field
57:23 - now let's try to bring them together and
57:25 - for that i'm going to create a third
57:27 - class
57:28 - that i called main and this one is going
57:30 - to actually contain the logic of our
57:32 - code
57:33 - which is going to make it much easier to
57:35 - maintain where things are going to be
57:38 - and i think this is best explained by
57:40 - implementing it straight away
57:42 - so let's jump right into our code and
57:44 - let's implement it
57:45 - so here we're back in our code and let
57:47 - me minimize the snake and the fruit so
57:49 - we have a bit more space
57:51 - and i want to create another class that
57:53 - i called
57:54 - main and when we initiate it
57:59 - i want this main to have our snake
58:02 - and this is literally creating the snake
58:05 - object
58:06 - and then also the same for our fruit
58:09 - so that whenever we are creating an
58:11 - object from this class
58:12 - we are also creating two more objects
58:15 - from these two classes here
58:17 - so that the entire game can happen
58:18 - inside of this one class
58:20 - and then this main class is going to
58:22 - have a couple of methods to maintain the
58:24 - game
58:24 - the first one i called update and what's
58:28 - going to happen in here
58:30 - is that we are moving the snake so i
58:32 - copy this one from the event loop
58:34 - and place it in here
58:37 - and i can also get rid of these two
58:39 - objects because we don't need them
58:41 - anymore
58:43 - and instead for all of this i'm going to
58:46 - create
58:46 - our main game
58:50 - and this is going to get main and then
58:53 - in the event update
58:54 - i call main game dot update
58:58 - so we don't actually change our game but
59:00 - now whenever we call screen at update
59:02 - so this event here we are calling
59:05 - maingame.update
59:07 - and maingame.update moves the snake
59:10 - and there's one more change we have to
59:11 - make this has to be self.snake
59:13 - so we are targeting this one so the
59:16 - snake itself
59:17 - remains unchanged just how we trigger it
59:19 - is going to be slightly different
59:21 - and then i'm also going to do the same
59:23 - for
59:24 - raw elements so all the stuff that we
59:27 - want to draw
59:28 - is going to happen inside of this method
59:30 - so right now
59:32 - we draw our snake and our fruit in the
59:34 - main game loop
59:35 - but i want both of these to be in here
59:40 - so that all of this happens inside of
59:42 - our main class
59:44 - so in our actual game loop we can just
59:46 - call
59:47 - maingame dot draw
59:50 - elements and this is
59:54 - quite a good practice that you want to
59:56 - keep this main game loop as clean as
59:58 - possible
59:59 - okay let's actually try to see if this
60:02 - still works
60:04 - and it does not because name our snack
60:07 - is not defined
60:08 - when we are calling our directions
60:10 - because
60:11 - we have to change this one here to main
60:14 - game
60:15 - dot snake and then it should be working
60:18 - so let me copy all of these
60:22 - and let's try it again now
60:25 - and there we go nothing much changed so
60:28 - far
60:30 - and you don't necessarily have to do
60:32 - this kind of step but it is going to
60:33 - make it much
60:34 - easier to organize your game
60:37 - okay so all of this is still working and
60:40 - a really nice advantage we have right
60:42 - now
60:42 - is that both of the snake and the fruit
60:45 - are in the same class
60:46 - so we can check where they are in
60:47 - relation to each other so for example if
60:50 - the head of our snake
60:51 - is on top of the fruit we want to do
60:52 - something with the fruit and with the
60:54 - snake
60:55 - and let's actually do that so i'm going
60:57 - to create
60:59 - a new method that i called check
61:03 - collision it's not actually a collision
61:05 - they just happen to be on the same spot
61:08 - and what i want to check in here is if
61:11 - self dot fruit dot position
61:15 - so this vector here
61:19 - if that is identical
61:22 - to self.snare dot
61:26 - body and the first element so this is
61:29 - going to be the head of our snake
61:31 - and this is our fruit position and if
61:33 - they are in the same position
61:34 - our snake is eating the fruit so then we
61:37 - want to do certain thing
61:39 - and for now let's just test if this is
61:40 - working so i want to print
61:42 - snack and let's try to run the code
61:47 - and nothing is happening because i
61:51 - forgot to call
61:52 - this method so in our update method
61:55 - i want to call self dot
61:58 - check collision and now let's try this
62:03 - and there we go we can go over the fruit
62:06 - and we print a statement so we know this
62:09 - if statement is working so that's quite
62:11 - nice
62:12 - and there are two things i want to do
62:13 - when our snake is colliding with the
62:15 - fruit
62:16 - number one is i want to reposition
62:20 - the fruit so that it's ending up in a
62:23 - new position
62:24 - and then besides that i want to add
62:26 - another
62:27 - block to the snake
62:31 - which is the main point of the game that
62:32 - you make the snake as long as possible
62:35 - and let's start with the fruit that
62:36 - one's the easier part so i want to
62:38 - target our self.fruit
62:40 - and then i want to add a new method that
62:42 - i call the randomize
62:44 - so let's create this one so let me close
62:47 - the main one for now
62:48 - and all the randomized method has to do
62:50 - is to create new random numbers in here
62:53 - so pretty much literally the same lines
62:56 - of code
62:57 - so i can just copy all of them create a
62:59 - new method that i call
63:01 - random mice and just
63:04 - copy these three lines of code because
63:06 - they create a random position
63:08 - and place the element there and i can
63:10 - just call self.randomize
63:12 - and that's all we needed to move the
63:14 - fruit so let's try this
63:17 - so it's still working and we get a new
63:21 - position for our fruit
63:22 - and let's try it again and there we go
63:25 - this works really well
63:27 - last one there we go cool
63:31 - so this is the first part that we want
63:34 - to
63:35 - reposition our fruit so this one's done
63:39 - now we come to the second part adding
63:41 - another block to our snake
63:43 - and this one is also actually super easy
63:46 - so
63:46 - again we want to target our snake
63:49 - and i want to add a new method that is
63:52 - called add block
63:54 - so let's create this method so let me
63:57 - close mine again
63:58 - and open snake
64:01 - and now let's create add block
64:06 - and now we have to think about what we
64:08 - are going to do
64:09 - because doing this is actually super
64:11 - easy but you do have to think about what
64:13 - you are going to do
64:15 - and ultimately it goes back to these
64:18 - three lines of code
64:20 - and specifically this line here that
64:23 - right now we copy our self.body list
64:25 - and take every element except the last
64:28 - one
64:28 - so that we are moving the entire snake
64:30 - forwards but if we want to add a block
64:33 - to the snake
64:34 - all we have to do is to remove this one
64:36 - and take the
64:37 - entire body and we are still going to
64:40 - add a new position at the front
64:42 - so we are extending the snake but this
64:44 - is really all we have to do for the
64:45 - change
64:46 - so let me revert this back and how i
64:49 - implemented this is i created a new
64:50 - attribute that is called
64:52 - self dot new block
64:55 - and by default it is false and what add
64:58 - block does
64:59 - is it changes self dot new block
65:03 - to true and if self taught
65:06 - new block is true so in our move snake
65:10 - if self dot add block
65:13 - is true so let's just type it in full
65:17 - then i want to copy the entire block
65:21 - and not delete anything
65:24 - and if that is not the case i just want
65:27 - to
65:28 - move the entire snake without adding
65:30 - anything towards it
65:33 - and that is pretty much it
65:36 - so let's try it and there's one more
65:38 - thing i do have to add
65:41 - so oh i realized there's a typo this is
65:45 - an app lock
65:46 - this is new block if this one is true so
65:49 - now let's try
65:50 - it and now
65:53 - when we pick up something
65:56 - our snake is going to extend for all
65:59 - eternity
66:00 - which i guess is a little bit funny but
66:03 - not the intended thing we want to
66:04 - achieve
66:05 - and the reason why this happens is
66:07 - because this log through
66:09 - stays true so once we are colliding with
66:11 - the fruit it is always going to extend
66:14 - which we don't want but we can fix it
66:16 - super easily
66:18 - by changing self.new block to false
66:22 - and now let's try it again
66:26 - so now our snake every time we collect
66:29 - the fruit
66:29 - is going to get a tiny bit longer and
66:32 - this seems to be working
66:33 - really well so this already is a really
66:36 - basic snake game
66:38 - and well takes no time at all to create
66:42 - it
66:43 - and with that we have our basic logic
66:45 - but the problem right now is that our
66:47 - snake cannot die
66:49 - so let's work on that and there are two
66:51 - conditions that could lead our player to
66:53 - fail
66:53 - number one is that the snake hits itself
66:56 - or that the snake hits any of the screen
66:57 - walls
66:59 - so effectively we have to add two if
67:02 - statements
67:03 - so let's start working on it so here i'm
67:06 - back in my code
67:06 - and i want to work in our main class
67:09 - function
67:10 - and i want to create a new method that i
67:13 - call check
67:14 - bail doesn't need any parameters
67:18 - and in here we want to check if
67:22 - snake is outside
67:25 - of the screen
67:29 - and check if snake hits
67:33 - itself and let's start with the first
67:35 - one
67:36 - that we want to check if the snake is
67:37 - outside of the screen
67:39 - and this is actually going to be super
67:41 - easy to check effectively all i want to
67:43 - do
67:43 - is if the snake is between 0 and the
67:46 - number of our cells so in this case 20
67:49 - and if that is not the case then we want
67:51 - to go to the game over screen
67:53 - and we only have to check this for the
67:55 - head of our snake because the rest of
67:56 - the body always follows the head
67:58 - so only the head really matters when we
68:00 - check for game over
68:01 - but let's implement this so i want to
68:03 - check if not
68:05 - 0 is smaller or equal
68:09 - then our self dot snake dot body
68:14 - zero and this is smaller or equal than
68:18 - cell number so there's quite a few
68:21 - things going on right now so let me talk
68:23 - through it
68:24 - self.snack.body is the body of our snake
68:27 - and 0
68:27 - is going to be our head so let me open
68:30 - it right now
68:31 - this would be this element here at
68:33 - position 5 and 10.
68:36 - and we want to check if this is outside
68:38 - of the field so if it is not between
68:40 - zero
68:41 - and the number of cells and there's one
68:43 - thing i forgot
68:44 - this one here is a vector and we can't
68:47 - compare vector to
68:48 - one single number so we have to check
68:50 - this for x
68:52 - so that we only check left and right and
68:54 - we are going to add the top and the
68:56 - bottom in just a second
68:58 - but for now if that is the case we want
69:01 - to do something
69:02 - so let me create a new method that i
69:04 - call dot game
69:06 - over so def
69:10 - dot game over and at least for now if
69:13 - our game is over
69:14 - i just want to quit the entire thing so
69:16 - i copied these two lines
69:18 - and paste them in here but we are going
69:20 - to change this later on
69:22 - in our update method we actually have to
69:24 - call it so
69:25 - self dot check fail
69:30 - so in theory right now if our snake is
69:32 - too far to the left or too far to the
69:34 - right
69:34 - it should fail so let's try and let's
69:37 - just go to the right
69:38 - and the game is over cool
69:41 - but there's one bug right now that this
69:44 - cell number
69:45 - at the highest point would be 20 but our
69:47 - cell furthest to the right is cell
69:48 - 19 so we could in theory go one
69:52 - field outside of the game which i don't
69:54 - want so i just removed the is equal to
69:56 - and we have to be smaller than this
69:57 - number so now if i try this again
70:02 - our snake or game fails whenever we hit
70:04 - the right wall
70:05 - so that's perfect but now the problem is
70:07 - that this is only going to work for left
70:09 - and right so we have to improve this if
70:11 - condition to also check for the top and
70:13 - the bottom of the screen
70:15 - and this could again be your challenge
70:17 - so pause the video now and try to do
70:19 - this yourself
70:23 - so really all we have to do is to add an
70:25 - or statement
70:26 - and copy the entire thing and then
70:29 - change it to
70:30 - y so we are going to check if the head
70:33 - of our snake
70:34 - is not too far to the left or to the
70:35 - right or if it's not too far up or down
70:39 - and this is really all we have to do so
70:41 - let's try all of this now
70:42 - and let me try to go game over from the
70:44 - top of the screen and this is working
70:46 - cool so now we have the condition to
70:48 - check if the snake has hit any of the
70:50 - walls
70:51 - so with that covered we can check if it
70:54 - hit itself
70:55 - and really what this means is we want to
70:57 - check if the head of the snake has
70:59 - collided with any other part of the
71:01 - snake
71:02 - so i'm going to start by cycling for
71:03 - every single block of the snake
71:05 - except for the head so for block
71:08 - in self.snake and i only want to go from
71:12 - the element with the index 0
71:14 - all the way to the end so we don't take
71:16 - the entire snake we only take all the
71:18 - elements that come after the head
71:20 - and in here i want to have an if
71:22 - statement
71:23 - that if any of these blocks is equal to
71:28 - self.snake0 and if that is the case
71:32 - we go back to game over and this would
71:35 - be the proper logic
71:36 - although i did just realize i made a
71:38 - typo this should be
71:40 - snake.body and same for this one
71:42 - snake.body
71:43 - because snake is the actual object we
71:45 - created and body is the actual part that
71:47 - contains all of the blocks
71:49 - and while we add it i also realized i
71:51 - made another mistake
71:53 - and let me go all the way to the top to
71:54 - explain what i did wrong
71:56 - so when we are creating our snake it is
71:58 - moving to the right
72:00 - so the vector is one and zero however
72:03 - the problem now
72:04 - is that our snake is actually facing to
72:06 - the left not to the right
72:08 - as i initially intended it and
72:11 - you can see this quite easily that the
72:13 - very first item is this point here
72:15 - at position 5 and 10. so in theory this
72:18 - should be the point furthest to the
72:19 - right
72:20 - but it's not because the second and the
72:22 - third item have greater x values
72:25 - so this one is to the right of this one
72:27 - and this one
72:28 - is to the right of both of these which
72:30 - basically means that the head of our
72:32 - snake is to the left of the body of the
72:34 - snake
72:34 - and since we are moving the head of the
72:36 - snake to the right it is going to move
72:38 - inside of itself
72:40 - so we do have to fix this and sorry
72:42 - about that but there are two ways of
72:43 - fixing this it's really easy to do
72:45 - number one you could either move the
72:47 - head by default to negative one
72:49 - so that we are moving the head of the
72:50 - snake to the left and all would be good
72:53 - but i don't really like that because
72:55 - it's too close to the wall
72:56 - and instead what we can do is change
72:59 - these two vectors to
73:00 - four and three on the x positions so
73:02 - that they are to the left
73:04 - of the head and with that covered let me
73:06 - go back
73:07 - down to our check fail logic
73:10 - and let's try this and the snake is
73:13 - still going to move
73:14 - that seems to be working quite well and
73:17 - let me pick
73:18 - up a couple of items so i can actually
73:19 - move them to myself
73:25 - and yeah it seems to work so cool
73:28 - now we know this is going to work and
73:31 - this
73:32 - is the basic check fail logic however
73:34 - there's one problem right now
73:36 - and let me run the game again now the
73:38 - snake is moving to the right and i could
73:40 - just destroy myself
73:41 - by clicking to the left and the problem
73:44 - here
73:45 - is all of this code here
73:48 - that we could always change direction
73:51 - let's say
73:51 - going up even if we are going down so
73:54 - that we have to add some code here that
73:56 - our snake cannot reverse
73:57 - itself because then we would instantly
74:00 - destroy ourselves
74:01 - and this can very easily be done with
74:03 - just adding another if statement
74:06 - so right now we check if event key is
74:08 - the up key
74:10 - and now i want to check if maingame
74:14 - dot snake dot direction dot y
74:17 - is different than one and only if that
74:21 - is the case
74:22 - we want to execute this line of code and
74:25 - let me explain what this means
74:27 - so when we're pressing the up key we
74:28 - want to go up
74:30 - however if we are moving downwards this
74:33 - is not supposed to work because then we
74:35 - would fail immediately
74:36 - so we want to check if our current
74:38 - direction in the y direction
74:40 - so this part here is anything
74:43 - but one because if it's one we're moving
74:46 - downwards
74:47 - so only if it's different from one then
74:49 - we can actually do
74:50 - this line of code here and this line of
74:52 - code we just have to copy
74:54 - a couple of times and change it for the
74:57 - different directions
74:58 - so for right it would be x and
75:01 - -1 so that if we are going to the right
75:04 - we cannot currently go
75:05 - left that just wouldn't make sense we
75:07 - would just reverse immediately
75:10 - then for down we would again look at y
75:12 - but it would have to be
75:13 - minus one minus one
75:16 - and then finally to go left then we
75:20 - again have to look at
75:21 - x and we can only go to the left if our
75:23 - snake currently
75:24 - is not going in the right direction and
75:27 - all right
75:28 - this is basically all we need so let's
75:30 - try it now
75:31 - and now i'm moving to the left and i
75:34 - can't
75:34 - reverse direction you can't really see
75:36 - it but it does work
75:38 - and we can still pick up all the other
75:40 - elements
75:42 - so all of this is working
75:45 - so nice and i can still get game over
75:48 - from moving into a wall
75:50 - so with that we have created a really
75:52 - basic snake game
75:53 - so this one is going really well but it
75:56 - really doesn't look all that good and
75:58 - also we can't tell a score
76:00 - so this is the stuff we are going to
76:02 - start working on now
76:03 - that we are going to start making this
76:05 - game a lot prettier
76:07 - and this is going to involve quite a bit
76:09 - more code but ultimately
76:10 - it's a really good practice to learn how
76:12 - to use if statements and the enumerate
76:14 - method
76:14 - but let's start with really simple one
76:16 - that i just want to display a proper
76:18 - fruit instead of just a rectangle
76:20 - and let's jump right into the code i
76:21 - think that's going to be the easiest way
76:23 - to approach this topic
76:24 - so here we are back in our code and the
76:26 - very first thing i want to do
76:28 - is to actually import an image of our
76:30 - apple and i'm going to do
76:32 - this where i initiated all the other
76:34 - elements and i want to
76:36 - import an apple and to import an image
76:39 - we need
76:41 - igame.image.load
76:43 - and then the file direction and this has
76:45 - to be a string
76:46 - and in my case i have a folder called
76:48 - graphics
76:49 - and in this folder there's an image
76:51 - called apple.png
76:54 - and here again this is only going to
76:56 - work if your code is in the same folder
76:58 - as this graphics folder so make sure you
77:00 - have them in the right place and then
77:02 - also
77:02 - i want to convert alpha this image
77:06 - so pygame can work with it easier so all
77:09 - that this method does is it takes this
77:10 - image here
77:11 - and it converts it to a format that
77:13 - pygame can work with easier so our game
77:15 - can run better
77:16 - but okay this is all we needed for the
77:18 - apple so now
77:20 - when we have our fruit class we can
77:23 - instead of drawing a rectangle we can
77:24 - draw an apple
77:25 - so let me comment this line out because
77:27 - we don't need it anymore
77:29 - but we are still going to need the
77:30 - rectangle so keep that one
77:32 - and really all we have to do is to use
77:35 - screen
77:36 - dot blit and now we need a surface and a
77:39 - rectangle
77:40 - our surface is going to be this apple
77:42 - here
77:43 - that whenever we import an image into
77:45 - pygame it is going to be on its own
77:47 - surface
77:48 - so we can just add apple in here and
77:50 - after that we need a rectangle
77:52 - or at least some kind of position and we
77:54 - also have that it's just this fruit
77:56 - rectangle so i just type in
77:58 - through direct and this is literally all
78:01 - we needed it's
78:02 - surprisingly simple so let's try it off
78:05 - this now and see if it works
78:06 - and yeah it does we have an apple
78:09 - and it still works with randomizing and
78:12 - all of this
78:13 - works super well
78:17 - and there we go so this already covers
78:20 - our entire fruit class
78:22 - now i can close it and we never need to
78:24 - open it again
78:26 - and with that part covered we can
78:27 - actually put the graphics on for our
78:29 - snake
78:30 - and this is going to be the most complex
78:32 - part of this entire tutorial
78:34 - but in general terms here's what we are
78:36 - going to do
78:37 - we are going to go for every single
78:39 - block in our self.snackdoll body
78:41 - and look at how each block relates to
78:43 - the block before and after itself
78:46 - and from this relation we can tell what
78:48 - kind of block to put in this place
78:50 - so effectively we are going to create a
78:53 - really long if statement that checks a
78:54 - huge range of different factors
78:57 - and i think this is really best
78:59 - explained while actually doing it
79:01 - so here we are back in our code and the
79:04 - very first thing i have to do
79:05 - is to actually import all the images we
79:07 - need for the snake and this is going to
79:09 - look very similar compared to this apple
79:11 - import
79:12 - except now we are going to import quite
79:14 - a few more
79:15 - and since we only jump for the snack
79:17 - itself i'm going to do this in the snake
79:19 - class
79:19 - when we are initiating it and in here i
79:23 - already have all of the lines ready and
79:25 - let me paste them in
79:27 - so this is quite a few different
79:29 - graphics that are being imported
79:31 - we have all the possible head positions
79:34 - all the possible tail positions
79:36 - then a vertical and a horizontal body
79:39 - and finally all the curved body parts
79:41 - so in total 14 different images and
79:44 - these are all the possible graphics that
79:46 - could be used for our snake
79:47 - and now that we have all the graphics we
79:50 - just have to figure out where to put
79:51 - them in our game
79:52 - and this is going to happen in our draw
79:55 - snake function
79:57 - so let me close everything else and let
79:59 - me give some space so we can focus on
80:01 - this part
80:03 - and first of all this part that we used
80:06 - to have
80:07 - we don't need any more so i'm just going
80:09 - to comment it out
80:10 - actually let me get rid of it entirely
80:13 - so we need all the space
80:15 - we can get and here let me go through it
80:18 - really slowly the first thing we want to
80:20 - do is we want to look at all the blocks
80:22 - in our snake body so we want to look at
80:25 - for
80:25 - block in self dot
80:29 - body but this by itself would not be
80:32 - enough
80:32 - because we want to look at more things
80:34 - we don't just want to look at the block
80:36 - itself we also want to look at the
80:38 - blocked accounts before
80:39 - and the block that comes after and for
80:42 - that
80:43 - we are going to need the enumerate
80:46 - method
80:47 - and what enumerate does is that it gives
80:49 - us an index on what object we are
80:51 - inside of our list so we have to type in
80:54 - index and then block so index is the
80:57 - index we're on
80:58 - and block is the actual object that we
81:00 - are going to look at
81:01 - so for example in our body right now we
81:04 - will get an index of
81:05 - 0 and then vector 2 would be our block
81:08 - and for the second entry this would be
81:10 - index 1 and the block would be the
81:12 - vector
81:13 - and this would allow us to access quite
81:15 - a few more blocks that are not the block
81:17 - itself
81:17 - so this one is really useful and in here
81:20 - we have to do lots of different things
81:22 - now and let me just write them out
81:24 - so number one is we still need
81:27 - a rect for the positioning
81:31 - so maybe i shouldn't have deleted the
81:33 - earlier one but we can just write it
81:34 - again
81:35 - so it doesn't matter too much and once
81:37 - we have that
81:38 - just to get started we want to figure
81:40 - out
81:42 - what direction is the face
81:45 - heading so in what ways are snake
81:47 - looking
81:48 - and this is going to be quite a bit
81:50 - larger so let's code until that point
81:52 - so let me start by creating direct again
81:55 - and this again
81:56 - is the same thing we have seen earlier
81:58 - where we literally just take the x and
82:00 - the y position
82:01 - from our block and from that
82:04 - we create a pygame direct object
82:08 - and it has an x position a y
82:11 - position and then we have cell size and
82:15 - cell size for the x and the y size so
82:18 - this is the same thing we have done
82:19 - earlier
82:20 - and this we still need this is what we
82:22 - use to actually place the image and get
82:24 - the position
82:25 - so this was the easy part now we have to
82:28 - think about how can we identify
82:30 - different parts of the snake
82:32 - so for example how can we tell which
82:33 - part is a hat and which part is a tail
82:36 - and for that the index is incredibly
82:38 - valuable
82:39 - because all we have to do is if index
82:42 - is equal to zero because index zero is
82:46 - always going to be the first
82:47 - element and our hat is always going to
82:50 - be our first element
82:51 - so this is all we needed so if that is
82:53 - the case
82:54 - we want just like for the fruit screen
82:57 - dot
82:57 - blit and in here we have to enter a
82:59 - surface and a rectangle
83:01 - we do have the rectangle that's our
83:03 - block rect
83:04 - and just to pick one of the hats so we
83:07 - have four different heads for each
83:08 - direction
83:09 - let's start with head right
83:15 - and if that is not the case so else at
83:17 - least for now
83:18 - we just want to do the same thing we
83:20 - have done earlier so pygame.draw.rect
83:24 - and i want screen and i forgot the color
83:28 - we had so let's just go
83:29 - with 150 100 and
83:33 - and then log rect so effectively what we
83:37 - are going to do
83:38 - is that we create a rectangle at the
83:40 - position where we need it
83:42 - and if this rectangle is the first no
83:44 - self.body list
83:45 - we are going to place the right facing
83:47 - head of our snake there
83:49 - and if that's not the case we just draw
83:50 - a plane rectangle
83:53 - and let's actually try this and i made a
83:55 - typo it's
83:56 - enumerate and now it gets blue so this
83:58 - looks much better
83:59 - so now let's try it again and there we
84:01 - go we have an incredibly weird looking
84:04 - graphic
84:05 - but we do have a graphic of a snake hat
84:07 - that kinda works
84:09 - so at least we're making some progress
84:11 - cool
84:12 - let's step in the right direction so
84:14 - this line here
84:15 - is kind of working but the problem we
84:17 - have right now
84:18 - that let's put in number three the snake
84:23 - head direction is not
84:26 - updating so what i want to achieve is
84:29 - that if we are moving upwards the
84:30 - snakehead is also looking upwards
84:32 - and we do have all the graphics to make
84:35 - this
84:36 - work but we do have to figure out how to
84:38 - select the right image
84:40 - and how i solve this is by putting all
84:42 - of the logic for this
84:44 - into its own method so i have self
84:47 - update head graphics
84:52 - and this is going to create a new self
84:54 - hat attribute
84:55 - and this is what we are going to use in
84:58 - the end
84:59 - so this method here effectively picks
85:04 - one of these four whichever is
85:05 - appropriate for the direction we are
85:07 - going
85:08 - so let's create that one so i go to def
85:12 - update add graphics
85:15 - and in itself and here's how this is
85:18 - going to work
85:19 - we are going to take the head of our
85:20 - snake so the first element in self.body
85:23 - and subtract it from the item that comes
85:25 - right before it
85:26 - and that way we get the relationship
85:28 - between the two or in more mathematical
85:30 - terms we are going to subtract one
85:32 - vector from the other and from the
85:33 - result we are going to get how they
85:35 - relate with each other
85:36 - so if one vector is above or below or to
85:38 - a left or to the right of the other
85:40 - and here again vectors are incredibly
85:42 - useful because we can just subtract from
85:44 - each other and understand how they
85:45 - relate to each other
85:47 - but okay i created a new variable that i
85:49 - called had
85:50 - relation terrible name but i could not
85:53 - think of something better
85:55 - and what i want to do is i want to go to
85:57 - self.body
85:59 - and get the second item so the one with
86:01 - the index one
86:02 - [Music]
86:04 - and let me just type it properly and
86:08 - from that i subtract
86:09 - our head so self.body zero
86:12 - so this is going to result in a new
86:14 - vector that could point in one of four
86:16 - directions
86:17 - and from this direction we're able to
86:19 - tell how the head relates to the block
86:20 - that comes before it
86:22 - and really all we have to do is if had
86:27 - relation is equal to vector 2
86:30 - and let's start with the first one 1 and
86:33 - 0.
86:34 - so this would mean that those two
86:36 - combined end up with one
86:37 - and zero which means that our head is to
86:40 - the left of the next block
86:42 - so if that is the case self dot head
86:46 - is going to be self dot head
86:50 - left and since we have quite a few if
86:52 - statements i am going to keep them on
86:54 - the same line just to make it a bit more
86:55 - readable
86:57 - and now all we have to do is copy this
86:59 - thing a couple of times
87:01 - change this to l if statements
87:04 - and now update the different vectors so
87:07 - the easiest part would be
87:09 - changing this to minus one so then this
87:11 - one would be at dot
87:12 - right then if this is zero
87:16 - and this is one so this would mean
87:19 - there's a block
87:19 - below the head of our snake so our snake
87:22 - is looking
87:23 - up and then for the final one by the
87:26 - process of elimination
87:28 - the snake has to be looking down and
87:32 - that's basically it
87:33 - so let's see if i get this right and
87:35 - let's try it now
87:37 - and yeah there we go our snakehead is
87:40 - updating quite nicely
87:42 - so this is quite a good start okay so
87:46 - this would cover the head of our snake
87:47 - so i can close this method and not look
87:50 - at it again
87:50 - and now we come back to our if statement
87:53 - and let me get rid of this part here
87:55 - because we fixed that bit
87:57 - so now we have the head of our snake now
88:00 - the next
88:01 - easy bit or easy-ish bit is to get
88:04 - the tail end so the last block
88:08 - that we want to cover and this we can
88:10 - also address
88:11 - really easily because this part is
88:13 - always going to be the last one
88:15 - so we can use l if index is equal to
88:19 - last item in self.body
88:23 - so we have to figure out some code to
88:25 - get the last item
88:27 - in this self.body list
88:30 - and well all we need is the length
88:33 - of our self.body so this is all the
88:36 - items in there
88:38 - and then -1
88:41 - because we start counting from zero and
88:44 - with that
88:44 - we always get the last item so if we
88:47 - have that we can do the same thing we
88:48 - have done for the head so screen dot
88:50 - blit
88:51 - and this time it's self.tail and we
88:54 - still need our block
88:55 - rect and self.tail does not exist yet
88:59 - but we do have if i open our knit method
89:01 - again we have all the different
89:03 - directions
89:04 - for the tail so i am effectively going
89:06 - to copy the method we used for the head
89:09 - this one and create the same one for the
89:12 - tail
89:13 - so let me close all of this and create
89:17 - self dot update tail
89:20 - graphics and again
89:24 - if you want to code along this could be
89:25 - a nice exercise
89:27 - so look at the update head graphic and
89:30 - try to figure out the logic for the tail
89:33 - but okay pause the video now if you want
89:34 - to go to long
89:35 - and i'm going to continue myself in a
89:37 - couple of seconds
89:38 - [Music]
89:42 - okay welcome back let's try to do it
89:44 - together now
89:46 - so i want to create a new method dev
89:49 - update tail graphics
89:53 - and just to save me some writing i'm
89:56 - going to copy
89:57 - the entire line for the head
90:01 - and just paste it in here and now it's
90:03 - going to be
90:04 - tail relation and now we
90:08 - don't want to look at the second and the
90:09 - first element instead we want to look at
90:11 - the last element and the element that
90:13 - comes before the last one
90:14 - so we know our last one is minus one and
90:17 - then the one before
90:18 - is minus two so this one is quite easy
90:20 - to start and then i have to change
90:23 - all of the tail relation
90:27 - l if statements and also change all of
90:31 - this to
90:32 - tail might have benefited from naming my
90:36 - variables better
90:37 - but never mind okay here we go so
90:40 - this would actually almost work so let
90:42 - me try
90:44 - and i forgot one equal sign
90:48 - let's try it again now there we go and
90:51 - there we go
90:54 - we have a nicely functioning
90:57 - tail cool so that was surprisingly easy
91:01 - actually so
91:02 - the same logic that we used for the hat
91:04 - we can use for the tail
91:06 - so now we have covered the tail
91:10 - with that we can start working on the
91:12 - actual body or the rest of the body
91:14 - and this is all going to end up in an
91:16 - else statement
91:18 - and in here it is starting to become
91:20 - important to figure out what is the next
91:22 - and the previous block
91:23 - so i want to know what is my previous
91:26 - block and what is my next
91:30 - lock and we know the block we're on
91:32 - right now that's just block
91:34 - so in here the index again is going to
91:37 - be incredibly useful
91:38 - because all we have to do is self dot
91:42 - body and then index plus one
91:46 - minus log and then for the next block
91:51 - we have to do the same thing except we
91:53 - subtract index minus one
91:55 - so just to explain what happens here we
91:58 - are indexing from self.body
92:00 - and index is going to be our current
92:02 - element and then we either add one
92:04 - or subtract one to get the next or the
92:06 - previous block
92:08 - which i think is quite straightforward
92:10 - and then from that we are going to
92:11 - subtract our current block
92:13 - to get the relation between the two and
92:16 - this is going to result in a new vector
92:18 - that again can point in one of four
92:20 - directions
92:21 - and from that we can tell what kind of
92:22 - block we need and now we can start with
92:25 - the horizontal
92:26 - or vertical body parts so these are
92:28 - going to be body parts that either are
92:29 - entirely horizontal or entirely vertical
92:32 - so i don't go around the corner at all
92:34 - and this
92:35 - is really easy to get because all we
92:37 - have to check is if previous block
92:39 - and next block have the same x or
92:42 - y-coordinates because if that is the
92:44 - case the block between these two blocks
92:46 - has to be either horizontal or vertical
92:48 - depending on if we look at x or y
92:51 - so let's implement this with another if
92:54 - statement
92:55 - and what i want to know is if previous
92:57 - block
92:58 - dot x is equal to
93:01 - next block dot x and
93:04 - if both of these have the same x
93:06 - coordinate we know it's going to be a
93:08 - vertical block
93:09 - so we can use screen dot blit
93:13 - and this is going to be self dot
93:16 - vertical and then block rect
93:20 - and let's try this oh right as a typo i
93:24 - have to get rid
93:25 - of yeah let's get rid of it entirely
93:28 - because it's just going to cause errors
93:30 - otherwise so now some parts of our snake
93:32 - we don't draw
93:34 - but i think that illustrates it even
93:36 - better what is missing
93:37 - so now we can see our snake is working
93:40 - when we're going up and down
93:42 - but if we're going left or right or
93:43 - around the corner things are missing
93:46 - but otherwise our snake is still working
93:49 - quite nicely
93:50 - so we are making quite decent progress
93:54 - looks actually quite funny but okay now
93:57 - i want to copy this entire if statement
94:02 - and now i just have to check the y parts
94:06 - and if those are identical we know our
94:08 - block is
94:09 - horizontal and i want to make this
94:12 - an alif statement so let's try this one
94:15 - now
94:16 - and we can see we have horizontal and a
94:19 - vertical body part for our snake
94:22 - we don't have any corners but that's
94:23 - going to come next besides that
94:25 - everything seems to be working quite
94:26 - nicely so we are making some decent
94:29 - progress
94:30 - so now we come to the most complicated
94:33 - part
94:34 - where we have to look at the corners of
94:35 - our snake
94:37 - and all of this is going to be inside of
94:39 - another else
94:41 - statement and let me explain the
94:44 - logic here to get this done and i
94:47 - think the best way to explain this is by
94:49 - using an example
94:50 - so let's say we want to create a corner
94:52 - where we go left and then
94:53 - up or we go down and right it's going to
94:55 - be the same corner
94:57 - and really all we have to do is to check
94:59 - the x and the y position of our previous
95:02 - and next block and we have the
95:04 - information to achieve all of this
95:06 - but you probably have to look over this
95:07 - a couple of times it is a little bit
95:09 - confusing
95:10 - but okay here we are back in our code
95:13 - and what i want to do
95:14 - is screen dot blit
95:17 - and i want to blend self dot body
95:22 - tl so this is top left so the corner is
95:25 - going up and left
95:27 - and again we need our block rect
95:30 - so we are now so we now have to figure
95:32 - out when to trigger this corner
95:34 - so all of this goes inside of
95:38 - an if statement a pretty long if
95:40 - statement actually so we want to check
95:42 - if
95:43 - previous block dot x is equal to -1
95:48 - and next block dot y
95:53 - is also equal to -1 or we could start
95:56 - from the other way
95:57 - where our previous block dot y
96:01 - is equal to -1 and
96:04 - next block dot
96:07 - x is equal to minus one
96:11 - and let's try this one so
96:14 - top left there you can see it we have
96:16 - one corner
96:20 - and we can also go bottom right and this
96:22 - would still be working
96:24 - bottom left i mean sorry and there we go
96:27 - we have our first corner
96:31 - and now all we have to do is to copy
96:34 - this if statement
96:39 - a couple of times and change our
96:42 - attributes
96:43 - and of course the image we're actually
96:45 - blitting so i would have
96:46 - bottom left i would have
96:50 - top right and then the remaining one
96:53 - would be bottom right and the
96:56 - coordinates would be
96:58 - previous block x minus one and next
97:00 - block
97:01 - should be one and then previous block
97:04 - would be one for y and the x would be
97:08 - minus one
97:09 - then we have four top right the previous
97:13 - block x
97:14 - would be one
97:18 - and next block y would be minus one
97:21 - or alternatively we would have the y
97:24 - part would be minus one
97:26 - and next block would just be one
97:29 - and for the final one we would have one
97:32 - and one
97:34 - and same for the other way around as
97:35 - well
97:37 - okay and those are all the bits let's
97:39 - actually try this together
97:41 - and this looks pretty good okay
97:45 - cool so this is actually drawing
97:48 - graphics quite efficiently
97:49 - [Music]
97:50 - and works even if we go really close to
97:54 - each other
97:54 - and looks quite clean
97:58 - okay and all of this is probably quite
98:00 - confusing
98:02 - and honestly when i figured this out i
98:04 - went by trial and error thinking about
98:05 - all of this gave me a headache
98:07 - so if this doesn't make full sense don't
98:10 - worry about it
98:11 - it really is kind of annoying to think
98:12 - about but really all we are doing
98:15 - is we look at our previous block and our
98:18 - next block
98:18 - and how they relate to our current block
98:21 - and from that we can tell what kind of
98:22 - corner we need
98:24 - but granted it does get quite confusing
98:27 - but okay with all of that one done
98:28 - i can get rid of the comments
98:32 - and we have our basic snake and we
98:34 - created an el
98:35 - if statement that covers basically an
98:36 - entire page cool
98:38 - always feels good so now i can close
98:40 - drawing snake
98:41 - and not worry about this for a while and
98:44 - for the next part
98:45 - i want to update the grass so it starts
98:47 - to look a little bit nicer
98:49 - and let's actually jump right in i think
98:51 - that's going to be the easiest way to
98:52 - approach this
98:53 - so here we are back in our code and in
98:56 - our class main
98:57 - i want to create a new method that
99:00 - i call define raw
99:03 - grass and this one well it draws the
99:06 - grass
99:08 - so we have a checkerboard style grass
99:09 - pattern on our field to make it look a
99:11 - bit more interesting
99:12 - and to achieve this kind of effect all
99:14 - we really have to do is cycle through
99:16 - each of the line
99:17 - and draw a slightly darker green
99:19 - rectangle if we have an odd or an even
99:21 - number
99:22 - so to start this off i'm going to create
99:25 - just to save me some writing later on
99:27 - a grass color variable and this is just
99:29 - going to be an rgb tuple
99:31 - with 167 209
99:35 - and 61. so this is a dark greenish color
99:39 - and now we have to cycle through every
99:41 - single cell on our field
99:42 - and either draw a darker rectangle or
99:45 - not draw a darker rectangle
99:47 - and to start this one off simple let me
99:49 - just start with the first
99:50 - line this one is going to make it quite
99:52 - a bit easier so i want to start with for
99:55 - column in
99:59 - range cell number
100:02 - so this would cover the horizontal axis
100:05 - of our entire field
100:06 - and for each of those i want to create a
100:09 - new grass
100:10 - rectangle and this is just going to be a
100:13 - pie game wrecked
100:14 - object and here we need an x a y a width
100:17 - and a height just as we have always used
100:20 - and with and hive again is just going to
100:22 - be
100:22 - cell size the one we have always used
100:25 - i almost regret not naming this with a
100:27 - shorter name but okay
100:29 - now we need two more pieces of
100:30 - information the first one is y
100:32 - and for now this is just going to be
100:34 - zero because we want to work with the
100:35 - first row
100:36 - but we are going to change this later on
100:38 - so
100:39 - now we are going to need our x
100:40 - coordinate
100:42 - and we could just start with this call
100:44 - so our column
100:45 - multiplied by cell size
100:50 - so this would give us a rectangle and
100:53 - now
100:53 - we can just draw it with
100:55 - pygame.draw.direct
100:57 - and i think by now you should know it so
100:59 - this is screen the service want to draw
101:01 - on
101:01 - then the color it's already predefined
101:04 - and then our grass
101:06 - rect so this right now would cover the
101:10 - entire first line of our field
101:12 - and let's actually illustrate this so
101:14 - when we come to draw elements
101:15 - below all the other elements i want self
101:19 - dot draw press
101:23 - and let's try this and you can see
101:27 - the very first line of our field is
101:29 - slightly darker
101:31 - so we do manage to draw at least a
101:33 - little bit
101:34 - but well it's not great yet so we have
101:37 - to make some more changes
101:40 - and the first change i want to do is
101:41 - that i only want to draw every second
101:43 - field not every field and you could
101:46 - approach this in two different ways
101:48 - you could either draw all the fields
101:49 - that start with an even number or all
101:51 - the fields that start with an odd number
101:53 - which one you go for it doesn't really
101:55 - matter but really
101:56 - all this is is if call
102:00 - mod 2 gets us a 0
102:03 - only then do we want to draw all of this
102:07 - and let's try this and now we can see
102:11 - we have only every second field working
102:14 - for this
102:15 - so this is already working quite nicely
102:18 - so now we have to do this thing for
102:21 - every second line in our field
102:23 - so what i want to do is to go for
102:28 - row in range
102:32 - cell number so we go for every single
102:35 - row in our field
102:37 - and now we are going to do this
102:39 - operation again
102:40 - except for the row not for the column
102:44 - so we want to only draw this kind of row
102:47 - if the row
102:48 - starts on an even number so if rho
102:50 - divided by two
102:52 - is equal to zero and if i run this
102:56 - oh forgot the if statement so if row
103:01 - and i have to indent everything as well
103:04 - try now
103:08 - ah and this doesn't work right now
103:11 - because we are still starting at
103:13 - position zero
103:14 - so we have to make an update to this one
103:17 - so right now we are drawing this
103:18 - multiple times
103:19 - but we always start at position zero so
103:21 - they're all drawn on top of each other
103:23 - but all we have to replace it with is
103:26 - our
103:27 - row multiplied by our cell size
103:30 - and let's try this one now and there we
103:33 - go
103:34 - this is starting to look much nicer and
103:37 - now we have at least every second row
103:40 - working properly and everything still
103:43 - works
103:44 - okay so now all we have to do
103:47 - is if this is not the case so
103:50 - we go for an else statement
103:54 - then we want to do this entire thing
103:57 - again
103:58 - and let me copy it properly
104:03 - except now we want to check all the odd
104:06 - fields
104:07 - and this is working
104:11 - so this is looking at least a bit more
104:14 - interesting
104:15 - and there really isn't all that much
104:17 - left to go for for a proper game
104:20 - the two more things i want to add is a
104:21 - score and a sound effect
104:23 - and let's start with the score and to
104:26 - get a score we need some text
104:28 - and text and pie game needs a couple of
104:30 - steps to work
104:31 - so let's talk through them ultimately
104:33 - there are three steps we have to be
104:35 - aware of
104:36 - number one is that we have to create a
104:38 - font object and this one is going to
104:40 - determine what our text looks like and
104:42 - how large it is
104:43 - then we have to use this font to render
104:45 - some text and this is actually creating
104:47 - some text
104:48 - so for all practical purposes we are
104:49 - writing something and this text is going
104:51 - to end up on a new surface
104:53 - exactly like the pictures we have
104:55 - imported so far and then for the final
104:57 - step we have to blit the image on our
104:59 - actual game screen
105:00 - and that is pretty much it so let's
105:04 - start creating the basic score and once
105:06 - we have that we can make it look nicer
105:08 - so here we are back in the game code and
105:10 - the first thing i want to do
105:11 - in our main setup part i want to create
105:14 - a new font and i call this
105:17 - game font and to create a font we need
105:20 - pygame dot font
105:21 - dot bond and to make sure the second
105:24 - font has to start with an uppercase
105:25 - letter this one is important
105:28 - and in here we need two pieces of
105:30 - information the first one is the font we
105:32 - want to use
105:32 - and then font size font size is the
105:35 - easier part this one is just an integer
105:37 - i went with 25 and for the font
105:40 - we could just go with none and then we
105:42 - get a default font for pygame
105:44 - but i want to import a font and for that
105:47 - i need to give the name of the font i
105:49 - want to use
105:50 - and this has to be a ttf file that i
105:52 - downloaded earlier
105:54 - and you can get a ttf file really easily
105:56 - from websites like daffon.com for
105:58 - example
105:59 - and there are plenty of free ones just
106:00 - check it out but in my case
106:02 - the file is located in the folder called
106:04 - font and the name of the file
106:06 - is poets 1
106:10 - dash regular dot etf
106:13 - and with that we have imported a font so
106:16 - our text is going to look like whatever
106:17 - this one looks like
106:19 - and the size is going to be 25 so these
106:21 - are the two basic things we have to
106:23 - start with
106:24 - and now in our main class i want to
106:27 - create a new method
106:29 - and let me minimize all the other
106:31 - methods i have
106:32 - so far just to make it a bit easier to
106:35 - see what's going on
106:37 - there really is quite a bit of stuff
106:38 - going on by now
106:40 - i want to create a new method that is
106:42 - called draw
106:43 - score does not need any parameters
106:47 - and in here we have to create our score
106:50 - and there are quite a few bits of
106:51 - information we first need
106:53 - to draw all of this the first one is the
106:56 - actual
106:56 - score text so we have to figure out what
107:00 - is our actual score and put this into a
107:03 - text
107:04 - and the basic logic i went with is that
107:06 - the length of our
107:08 - self.snake.body
107:10 - is going to be our score so the longer
107:12 - our snake is the higher of a score we
107:14 - get
107:15 - so this will be the basic part that
107:16 - determines our score but we are starting
107:18 - with three blocks
107:19 - inside of our snake so i have to reduce
107:21 - this by three so that we start with zero
107:24 - but then all of this has to be a string
107:26 - so that we can
107:27 - display it easier so i put it in the str
107:30 - method
107:30 - that works very similar compared to the
107:32 - end method except now it turns any kind
107:34 - of value inside of this
107:36 - into a string instead of an integer and
107:39 - with that
107:40 - we are getting our basic score so this
107:43 - is a good way to start
107:44 - and with that i can create the actual
107:46 - score
107:47 - and this would be a score surface so let
107:49 - me write it properly
107:50 - and to create this we first need our
107:53 - game font
107:54 - so what we created down here and we want
107:58 - to render it
107:59 - and in here we need three pieces of
108:01 - information
108:02 - the first one is the text then if you
108:04 - want to end the alias it
108:06 - and then we need a color and let me talk
108:08 - for them step by step
108:10 - the first one for our text is just going
108:11 - to be our score text
108:13 - so what we created up here and for the
108:16 - color
108:16 - i am just going to go with an rgb tuple
108:18 - again which this time
108:20 - is 56 74 and 12
108:24 - which is a fairly dark color that has
108:26 - slightly more green than the other
108:27 - values
108:28 - finally we need the anti-alias text and
108:30 - this one either has to be
108:32 - true or false and anti-aliasing just
108:35 - means we make the text a bit smoother
108:37 - and unless you're working with pixel art
108:39 - or you work on a really slow computer
108:41 - this is usually best left for true and
108:44 - it makes our text look a bit nicer
108:46 - but ultimately this really isn't going
108:48 - to make that much of a difference
108:50 - especially for a simple game like ours
108:51 - so i just leave it with true
108:53 - alright now we have a text surface that
108:55 - we just have to put on the screen
108:57 - so this is going to go with screen dot
108:59 - blit
109:01 - and now we do have a score surface
109:04 - but now we need to get a position of
109:06 - this text
109:08 - and here we have to determine where we
109:10 - want to put it on our screen
109:12 - and i want to put it in the bottom right
109:14 - ish of our game
109:16 - and to get it there i'm going to add a
109:18 - few more variables
109:20 - just to make it easier to read so i
109:22 - create a scorex variable
109:25 - that is again going to be an integer of
109:28 - cell
109:28 - size times cell
109:32 - number so this would be the right end of
109:34 - the screen
109:35 - and from that i want to remove a couple
109:38 - of pixels
109:40 - so i removed 60 from there meaning that
109:43 - we go all the way to the right of the
109:44 - screen
109:45 - and then go a bit further to the left so
109:47 - we are in the right end of the screen
109:50 - and then i'm going to do the same thing
109:51 - for y that again
109:53 - i want to go all the way down to the
109:54 - bottom of the screen but now i want to
109:56 - go a bit up again
109:58 - so let's make this a bit less 240 and
110:01 - from these two bits of information we
110:03 - can create a score rectangle
110:05 - and here i want to get our score surface
110:09 - and get the rectangle around it so when
110:11 - we create this score surface with some
110:13 - text
110:13 - it has some dimensions and with get rekt
110:16 - we can access all of them
110:17 - and even better we can immediately place
110:20 - this
110:21 - rectangle somewhere on the screen and
110:23 - right now i'm placing the center
110:25 - and what we pass in here is an x and a y
110:29 - position where we want to place it
110:31 - and for this we can use these two bits
110:33 - of information
110:34 - so this would be our score
110:37 - x and score y
110:40 - and now that we have a rectangle we can
110:42 - just place this into the position for
110:44 - our screen dot blit
110:45 - and this is pretty much all we need for
110:48 - the score
110:49 - so now when we come to draw elements i
110:52 - want also to draw a score
110:55 - so self dot draw score
110:59 - and let's see if this is working and it
111:02 - is
111:02 - not because i made a typo this should
111:06 - be poet sen 1
111:09 - so now let's try this again and there we
111:11 - go in the bottom right of our screen
111:13 - we can see a number and every time we
111:15 - pick up an apple
111:16 - this one goes up and let's try one more
111:20 - and this seems to be working quite well
111:22 - cool
111:23 - so with this bit of code we get our
111:26 - score
111:27 - but by itself the score looks a bit
111:29 - bland so i want to add two things to it
111:32 - number one i want to add an apple to the
111:34 - left of it
111:35 - and number two below the score i want to
111:37 - add a plain rectangle
111:39 - so that it stands out a bit more from
111:40 - the background and both of these are
111:42 - quite easy to get
111:43 - so let's add them now so what we
111:45 - ultimately want to achieve
111:47 - is screen dot blit again and this time
111:50 - we want to use our apple again
111:52 - the one we imported down here and then
111:55 - again we need a position for the apple
111:57 - so we have to write some code for this
111:59 - position
112:00 - and the position is supposed to be at
112:02 - this apple is slightly to the left
112:04 - of our score so we have to use our
112:07 - current existing score
112:09 - and place the apple to the right of it
112:11 - which fortunately
112:12 - we can do quite easily and i think to
112:15 - make our code a bit easier i'm gonna put
112:17 - the two screened up blitz together
112:19 - and then all the setup part goes into
112:21 - one big chunk of code
112:23 - that should make it a bit easier to see
112:25 - okay what i want to do
112:26 - is apple rect to get the position
112:31 - and this is going to be our apple and
112:33 - get
112:34 - wrecked again and for this rectangle we
112:37 - don't want to place the center
112:39 - instead we want to place the mid
112:42 - right and where the mid-right is
112:44 - supposed to be
112:45 - is on the left of this apple here so
112:48 - for the x i want score correct
112:52 - dot left and for the y i want scorect
112:57 - dot center y and that's basically all we
113:00 - needed so now when we blit the apple
113:02 - we need apple and apple rect and let's
113:05 - try
113:07 - and there we go we have an apple next to
113:09 - our score
113:10 - and let me explain what happens here so
113:13 - on the score
113:14 - we place the center of our rectangle on
113:16 - these positions
113:17 - that are roughly in the bottom right of
113:19 - the screen but
113:20 - when we create our apple rectangle we
113:23 - take the mid
113:24 - right point of this rectangle we place
113:26 - it on the left of our score rectangle
113:28 - and the y position is going to be the
113:29 - middle of the score rack so what we
113:31 - effectively do is that we place the
113:33 - upper right on the same height as the
113:34 - score rack
113:35 - and the x position is going to be
113:36 - slightly to the left and with that we
113:39 - have the two basic points
113:40 - the only thing left to do is to create a
113:42 - slight background so that both of these
113:44 - stand out a bit more
113:45 - although i think by itself you could
113:47 - even leave it like that
113:48 - but um it's up to you doesn't look too
113:50 - bad right now
113:52 - so i want to create a bg rectangle for
113:54 - the background
113:56 - and this is going to be a pie game dot
113:58 - wrecked object
114:00 - and in here we need an x position a y
114:02 - position a width
114:04 - and a height so let's go through all of
114:07 - these step by
114:08 - step so our rectangle is supposed to
114:10 - start at the top left of our apple
114:13 - and these are points we can get very
114:15 - easily so i want
114:16 - apple rect dot left and for the y
114:21 - apple wrecked dot top so that our
114:24 - background starts at the top left of our
114:26 - apple
114:28 - and the height is the next easiest part
114:30 - because all we want
114:32 - is the upper rect dot height
114:36 - so our rectangle starts at the top left
114:38 - of the apple and takes the entire height
114:40 - of the apple
114:41 - for the simple reason that the apple is
114:42 - larger than the text so if we cover the
114:44 - entire apple we also cover the text as
114:46 - well
114:47 - so now we need the width and for the
114:50 - width we want to cover both the apple
114:52 - and the text so this is going to be
114:55 - our apple right dot with plus
114:59 - score rect dot with and
115:04 - this should cover the entire rectangle
115:07 - so once we have that i want to use
115:10 - pygame.draw.rect
115:12 - draw on the screen the color i want to
115:14 - go with
115:15 - is 164 209 and
115:18 - 61 so the dark grass color and i want to
115:22 - draw our bg
115:23 - rectangle and let's try this
115:26 - so if you look very closely you can see
115:28 - it especially if i go below it
115:31 - there you can definitely see it so this
115:33 - is working
115:35 - but it's very hard to see so what i am
115:37 - going to do
115:38 - is to draw a frame around this box
115:42 - and drawing a frame around the box
115:45 - is very easy to do in pie game so let me
115:47 - copy the first rectangle
115:49 - and all we have to do to draw a frame
115:51 - around it is to add another argument
115:54 - so in my case this would be two but the
115:57 - problem here right now would be
115:58 - that we have a rectangle with one color
116:00 - and the frame around it has the same
116:02 - color
116:03 - so we couldn't really see the frame and
116:05 - to fix that i'm just going to copy the
116:06 - text color
116:08 - and let's try this now so now this looks
116:12 - much better
116:13 - and now you can see that the box is a
116:15 - little bit too narrow
116:17 - so that the number is too far to the
116:18 - right and it touches the frame which
116:20 - doesn't look good
116:21 - so we have to make it slightly larger
116:24 - this is the width argument and all i
116:27 - want to do
116:28 - is to make this slightly larger so i'm
116:30 - going to add plus
116:31 - let's try six and let's try now
116:35 - and yeah this looks much better now it's
116:37 - roughly in the middle
116:39 - and there we go this is working pretty
116:42 - well
116:43 - so with that part covered we have a
116:45 - score
116:47 - and now we can work on adding some
116:49 - sounds to our game
116:51 - and adding sound in pie game is actually
116:53 - super easy
116:54 - but there's one thing you do have to be
116:55 - aware of that is a little bit annoying
116:58 - but i think it's best to jump right into
117:00 - our code and let's add the sound
117:01 - and then we can talk about the problems
117:03 - with sound and pygame
117:05 - and i only want to add a single sound
117:07 - that when our snake collides with fruit
117:09 - then we want to play a crunchy sound
117:12 - and we could add more sounds like a
117:14 - background music or game over sound but
117:16 - if you can get one sound you can get all
117:18 - of them and i don't want to over
117:19 - complicate things
117:21 - so we are just going to stick with a
117:22 - single sound
117:24 - and let's do all of this so here we are
117:27 - back in our code
117:28 - and i want to import our sound to our
117:31 - snake
117:32 - because that's the only place where we
117:33 - actually going to need it
117:35 - so right in the indent method that gets
117:37 - really extensive by now
117:39 - i want to add a new attribute that i
117:41 - call crunch
117:43 - sound and to import a sound we need
117:46 - pygame
117:47 - dot mixer dot sound
117:50 - and here again this sound has to start
117:52 - with an uppercase letter
117:53 - otherwise it's not going to work and now
117:56 - we need the file name
117:57 - and in my case i have a folder called
117:59 - sound and in there there's a file called
118:03 - crunch.wav
118:04 - and with that we have imported a sound
118:07 - so that's the first step we need
118:09 - and then for the snake i want to create
118:12 - a new method
118:13 - and let me minimize all of the
118:16 - other methods so this is a bit easier to
118:19 - see what we are doing
118:21 - okay so all the way down in this method
118:25 - i want to create a new method that's
118:26 - called play
118:28 - brunch sound and this
118:31 - only needs a single line of code we want
118:34 - self.crunch
118:36 - sound dot play and so now whenever we
118:40 - execute this method we are going to play
118:42 - the crunch sound
118:43 - and let me close the entire thing again
118:45 - and now in our main class
118:48 - when we get to check collision
118:51 - we also want to play this sound so self
118:54 - dot snake
118:55 - dot lay crunch sound
118:58 - and let's actually try this
119:04 - [Music]
119:06 - so this seems to be working but the
119:09 - problem we have
119:09 - right now is that the sound has a slight
119:13 - delay
119:14 - so that it doesn't play right when we
119:15 - eat the fruit instead it plays about
119:17 - half a second later
119:19 - which can be really weird the reason is
119:21 - that pie game first buffers a sound
119:23 - before it plays it
119:25 - and this creates a short delay between
119:26 - the chord being triggered and the sound
119:28 - playing
119:29 - but we can fix that quite easily so let
119:32 - me close
119:33 - our main class and what we have to do
119:36 - is work with pygame.init at least a tiny
119:40 - bit
119:40 - and in pygame.init there's a method
119:43 - called mixer
119:44 - and mixer is responsible for all the
119:46 - sounds and what we want to do
119:48 - is pygame.mixer.3
119:53 - init and in here there are quite a few
119:56 - arguments you could pass
119:57 - into it and it can get quite technical
120:00 - but i have found four numbers that work
120:02 - really well so these four give you a
120:04 - good sound
120:04 - and play the sound immediately but if
120:06 - you want to know more about sound in pi
120:08 - game there's the documentation that
120:09 - gives you a lot more detail
120:11 - so i would just copy the numbers and
120:13 - don't worry too much about it
120:16 - but let's try it with these numbers
120:22 - and we are getting a sound immediately
120:25 - so this
120:26 - is now working
120:30 - and with that we are nearly done there's
120:33 - one more thing i do want to cover though
120:34 - that i forgot to check
120:35 - earlier that let me go back to our main
120:41 - when we check collisions and we create
120:44 - a new fruit on the field there is a very
120:47 - small chance that our fruit
120:48 - lands on the body of our snake which
120:51 - would be very confusing
120:53 - so we have to add a little bit of extra
120:55 - code here
120:56 - that if the fruit is on the rest of the
120:58 - body of the snake we want to randomize
121:00 - it again
121:01 - so really all that we want to do is for
121:03 - block
121:04 - in self.snake.body
121:08 - and here we don't want to check for the
121:10 - hat so this would be from one
121:12 - all the way to the end with index 0
121:14 - being the head and everything else being
121:16 - the body and this is what we want to
121:17 - check
121:18 - and really what we want to check is if
121:20 - block
121:22 - is equal to self dot
121:25 - fruit dot pause
121:29 - and if that is the case we just want
121:31 - self dot
121:33 - root dot mice
121:37 - so really odd it is happening here is
121:39 - that we are checking
121:40 - every single block of our self that's
121:42 - negative body and check if it happens to
121:44 - be on the same position as the fruit
121:47 - and if that happens we want to put the
121:48 - fruit in a different place
121:50 - and that way we ensure that our fruit is
121:53 - never on top of the snake body
121:55 - and this is quite difficult to show
121:57 - because well
121:58 - it depends on a lot of random chance and
122:00 - ideally it's something we want to avoid
122:01 - happening
122:03 - but with all of that covered we have
122:04 - created a pretty nice snake game
122:07 - and there's one final thing i do want to
122:10 - change
122:11 - that whenever we die the game just ends
122:14 - which isn't ideal and really all i want
122:18 - to do is that if our player fails
122:19 - i want to put the snake back in the
122:21 - default position so we don't really have
122:23 - a game over menu instead we just restart
122:25 - the game immediately
122:27 - but you could be adding all the menus
122:29 - you wanted but i think in this case it
122:30 - doesn't really make sense
122:32 - but let's actually implement this so we
122:35 - have to go to our game over
122:37 - and see what happens in here right now
122:40 - we are just ending the game
122:42 - which well isn't great instead i want to
122:45 - get
122:47 - self.snake.reset
122:49 - so this method doesn't exist right now
122:51 - so we have to create it
122:53 - and let's close our main class and go
122:56 - back to the snake
122:58 - and here we really start to have quite a
123:00 - bit of stuff in there
123:02 - but let's add one more it's going to be
123:04 - the final one
123:05 - and i called this reset and
123:09 - what is supposed to happen here is that
123:12 - we take our initial self.body
123:16 - and just recreate the basic points so
123:19 - really we just take
123:21 - ourselves the body where we started
123:24 - and that is literally all we are to do
123:28 - and we don't even have to update the
123:30 - score because the score just checks how
123:31 - long this list is
123:33 - so we don't really have to do anything
123:35 - so let me try this now
123:38 - and our game still starts the score also
123:41 - works
123:42 - and now let me fail and we move back to
123:45 - the starting position
123:46 - so this is quite well let's try it again
123:49 - and yep it works quite well so
123:52 - most of the game is done there's one
123:55 - last thing that is a little bit annoying
123:57 - and let me illustrate this so right now
123:58 - our direction is downwards and we start
124:00 - again our snake goes downwards again
124:02 - so when we restart the game we also have
124:04 - to change the starting
124:06 - direction so all we have to do
124:09 - is go back all the way to the top and
124:11 - change this value
124:13 - and actually all we have to do is to
124:15 - change this
124:16 - to zero and zero and then let me copy
124:20 - the entire line
124:22 - and further down for the reset method
124:25 - i also want to set the direction back to
124:27 - 0 and 0
124:28 - when we reset the snake and let's try
124:31 - this
124:33 - so if i don't press anything the snake
124:35 - isn't moving if i press something
124:36 - we are starting to move
124:40 - and i can pick up a couple of apples the
124:43 - score is working
124:45 - if i go game over our snake isn't moving
124:47 - again
124:48 - and only if i start pressing the button
124:50 - it is starting to work
124:52 - so all of this is working really well
124:55 - and well that is it for the entire game

Cleaned transcript:

hello there in this tutorial we are going to be creating this snake game and python with the pygame module and this is intended for absolute beginners so you don't have to know anything about the pygame module although you do have to know the basics of python programming in general at least a little bit and i will go for these steps to create the entire game and if you already know the basics of pygame skip ahead to this step then you go straight to the snake game but for everybody else just continue watching and we're gonna talk about how games work in general that is going to be really useful to understand what we are doing a little bit later on in this video so let's talk about how games work and i think this is best done by using an example so here's an image from the first level of super mario world and this image is composed of several elements we start with the background then we add a floor and some bushes then mario himself and finally some indicators at the top and each of these elements is just a picture that you could even download and use yourself and the important thing to note here is that this image is not just drawn once instead it is drawn multiple times per second in what is called a game loop and then to turn this into a game we have to add two more things number one is player input so that you have to know what the player wants to do and number two is that on each cycle you also reposition where elements are supposed to be drawn so in total there are three steps we check for player input we position elements on the screen and then we draw all of these elements and if that happens often enough you get a video game so let's look how this would work in practice so we first want to check for the player input and let's say the player is pressing the button to the right and as a consequence we want to move mario 5 pixels to the right and after that we draw the entire image with mario being 5 pixels further to the right and all of this would happen in one cycle of the game loop and on the next cycle we do the same thing again so if the player keeps on pressing right we still keep on moving mario to the right and redraw the entire thing again and then we keep on redoing this about 60 times per second and as a consequence the player is perceiving all of this as an interactive medium and in an actual game much more is happening than just moving a player to the right so for example for mario if he is moving to the right we also want to play a walking animation which further adds to the illusion that mario is walking instead of just being repositioned on the screen but we could also move around enemies or we could give the player power ups or we could add some coins or timers or really anything that would constitute parts of a game and if you understand that logic you can make a game in basically anything as long as you can get these free elements and this could even be a game in microsoft excel this would also be possible but in our case we will use pygame so let's have a look at that but pygame is an external module so you do have to install it from an external source but that is quite easy if you use pip either under powershell or on a terminal in both cases all you have to do is type pip install pygame and you should be good to go although there's one minor complication that if you have pygame 3.9 so the latest version that came out a couple of weeks ago the main version of pygame right now does not work because it wasn't updated yet but that isn't really a problem because there's a newer version of pygame that isn't fully released yet but for our purposes it is perfectly sufficient so if you have the very latest version of pygame all you have to do is type pip install pygame equals equals 2.0.0.dev22 and then you should be good to go there's no other change you have to make and with that let's start writing some code here we are in an empty sheet of code but for now the very first thing we have to do is to import pygame which should make sense that if you want to use pygame you have to import it and in here if i execute the code if you are getting this message then the input worked well and along with that we get a hello from the pygame community message along with the link to the website but nothing that's really relevant here so let me close all of that so now we have imported pygame and we can use it but by itself nothing happened yet and to make something happen we have to add a couple more things the very first spring is pygame dot init and this line is quite simple but really important it effectively starts the entirety of pygame so pygm consists of several modules let's say one module for the sound another module for the graphics and all of these have to be started and much later in this tutorial we are going to work a little bit more with pygame.net but for now this is the one line we need to start pygame but if we run the code now we still can't see anything except the welcome message and to actually see something we have to create what's called a display surface and the display surface is basically what the player sees in the end so you might call this the main game window and this also has to be stored in a variable and this is usually called screen and how we create a display service is with pygame dot display dot set mode a slightly weird name but well it is what it is and in here we have the tuple with our width and the height of the window we want to get and let's say in my case i want to go with 400 times 500 so our window is going to be 400 pixels wide and 500 pixels high and if i run this code you are going to see something really briefly so let me run it and there we could see a window for a very short period of time and this is by design so right now pygame knows that it's supposed to display a window but it doesn't know for how long to maintain this window and because of that it creates the window and then closes it immediately afterwards and to keep it open we have to create our main game loop and this is just a plain while loop and this while loop we are going to close from the inside so this can just be set to wild true so this while loop by itself unless we stop it from the inside is never going to stop and now in this while loop we need to have one line that is called pygame dot display dot update and what this basically does and let me add a bit of white space is that let's say in this while loop we're going to draw all our elements so for example for snake we're going to draw our background we're going to draw the snake we're going to draw a couple of fruits all of this is going to be drawn in here and then what pygame.display does is that it takes all of this information and displays it on the main display surface so that the player can see it so this is the very minimum you need to display anything and if i run the code now this would be working but i would not recommend to run it right now for the simple reason that we wouldn't be able to close it because we didn't implement this functionality just yet and to implement that we need what is called an event loop and an event loop is well it's a loop that looks for different events and each event could be something different but most of the time an event is some kind of user input so this could for example be you pressing a button like left or right up or down on your keyboard it could also be a mouse movement or us closing the window by pressing the little x on the top right it could also be something else like a timer for example we are actually going to see this later on but let's go for this step by step and the very first thing i want to check is if we are going to press the little x at the top of the window so i have to create a very basic event loop and this is just a for loop so i want to check for event in pygame.event.get so at the start of every loop of our game we are going to check for every possible event and then we can do something with these events and what we have to look for is event dot type and this is going to tell us what kind of event we have and this has to be an if statement so if a certain event type is equal to something we want to do something else and the thing we want to look for right now is pygame.quit and this event type is closing the window by pressing the x button and if that is the case i want pygame dot quit and this for all practical purposes is the opposite of pygame.init but by itself sometimes this can cause some complications that some other parts of the program might still be running so this usually is not enough we want another line of code and what we want is cis dot exit and this is another python module so we have to import it so at the top of our code i import pygame and cis and this is a fairly straightforward module it gives you access to lots of system functionality and what sys.exit does is it basically ends any kind of code that it's being run on so in our case if we run sister exit we make sure our code is definitely closed so with these two lines we make very much sure that our game is going to be closed with that being covered let's try to run our code now and let's see what happens and there we go we have a window that is 400 pixels wide and 500 pixels high and right now it's all black for the simple reason that we haven't drawn anything yet but that we're going to cover in just a second but for now we are able to create a basic pie game window so that's a good start but there's one more thing that's important for the basic setup and let me explain what this is right now our game loop so our wild true loop is going to run as fast as our computer allows it to run so for a really slow computer it might run 10 times per second but for a really fast computer it might run 10 000 times per second and this could be a problem because on different computers the game's speed might be completely different because of this difference so we have to make sure that our game runs at least somewhat consistently and even on the same computer it might run differently depending on how busy our scene is going to be so we want to make sure that our game doesn't run faster than a certain maximum frame rate and for that we have to create a clock object and all the clock object does is that it limits how fast our wire loop is going to run and it's ultimately quite a simple thing to achieve so let's go right back into our code and let's implement this so below our screen variable i am going to create a new variable that i call clock and this is going to create a clock object by typing pygame dot time dot spelling it properly and here do make sure the first letter is capitalized that is important but besides that this is all we have to do so this is a clock object that can help us influence time and pie game but all i want to do is right at the end of our game loop i want clock dot tick and in here we effectively have to pass in the frame rate so how many times this while loop can run per second and in my case i am going to go with 60 which is usually a good middle ground for games but you could make this a much larger number if you really wanted to and with this our game is never going to run faster than 60 frames per second or in other words this while loop is never going to execute more than 60 times per second which makes our game quite a bit more consistent now there's still the other possibility that our game might run too slow and this is something we don't have a simple solution for this is basically game design that you have to make sure that your game never runs too slow and you are doing that by not having too many elements on the screen for example but in our case since our game is so incredibly simple this is not going to be an issue but alright with that covered we have a very basic window that runs at a maximum of 60 frames per second so this is a pretty good start and now let's talk about how to add basic visuals to this to really understand pygame you have to understand two basic elements they are called surfaces and rectangles and let's start with surfaces and here's something slightly confusing earlier in this tutorial we created a display surface and this is different to a regular surface although not that much and let me explain it like this our display surface is the big canvas that our entire game is going to run on and there can only be a single display surface and the display surface is also displayed by default for the simple reason that if we didn't have it we wouldn't have a game now a regular surface does the same thing it is still a layer that we can put stuff on but we can have as many surfaces as we like and each surface is only displayed if we write code for that so you could have quite a few different surfaces if you didn't write code to display them they would be invisible so if you want to use a surface you need to follow two steps you first have to create a surface and then you have to put the surface on the screen and creating a surface can be done in three basic ways if you import an image you are going to create a new surface with the image on it the same is going to happen with text so if you create any kind of text the text is always going to be on a new surface and number three is that you could just create an empty surface that doesn't have anything on it so it would just be black by default although you could also fill it with any color you want and for the second step you have to take the surface and put it on the target surface where you want it to be in our case this is always going to be our display surface although you could also put one surface on any other surface as well but that's quite a bit of talk let's actually play around with this so here i'm back in my code and for now i just want to create a basic test surface and this is going to be just an empty surface and how to create this is pygame dot surface and this kind of like set mode is going to need a tuple with a width and a height and let's make this let's say 100 pixels by 200 pixels and that is all we needed so now we have another surface but if we run the code now we wouldn't be able to see it because we didn't put it on the display surface and this we have to do in our while loop and what i want to do is to put our test surface on our screen display surface and for that we first have to type screen to get our display surface and then blit which stands for block image transfer and then here we need the surface and a tuple with the x and the y position so our surface is going to be our test surface and for x let's go with 200 and for y let's go with 250. so hypothetically we should see something right now so let's try it and our code is running but we still can't see it oh well technically we can but it doesn't help us too much for the simple reason that both our screen and our test surface are both black so technically while they are both visible we can't see them because they have the exact same color so we have to figure out how to add color to each of them and the easiest way to give them color is to use the fill command and let's do this actually on the screen itself so let me add another line of code and i want to fill the screen with a greenish color and for that we need screen dot fill and in here we need some kind of color argument and there are two ways of achieving this in pi game number one is an rgb tuple and number two is a color object the color object is easier to explain you just type pygame.color and insert the string of a name of a color and then pygame picks a specific color that was predefined so for example i could type in here pygame.color and let's go with gold and now if i run this we should see a golden background color and there we go and now we can also see our test surface and here think about the starting position this one is going to become a bit more important in a second but for now we have a basic color but in my case i don't want a predefined color instead i want to define my own color to keep the entire thing consistent in tone and to create a custom color we need what is called an rgb tuple so let me explain what that is rgb stands for red green and blue it's literally that simple and what we basically do is we determine the amount of color for each of these values so for example we could have a hundred percent red zero percent green and zero percent blue and if we then put these colors together we have a red color and that's really all it is the only thing you really have to remember is that the lowest value you can give for each color is zero and the highest 255 with 255 being 100 of this color so in my case i'm going to go with an rgb tuple of 175 215 and 70. so our color is going to have quite a bit of green a bit less red and very little blue and this combined is going to give us a greenish color so let's actually implement this so here i'm back in my code and let me get rid of the color object and i want to create an rgb tuple so i create another list and then here i type 175 215 and 70. and now let's try this and there we go now we have a greenish background and if you want to challenge yourself and code along here is going to be a short exercise try to get this test surface and fill it with a blue color and if you want to do it pause the video now and try to do it yourself so this could be done before the while loop and i just want to get test surface dot fill and in here to get a blue color we could either go pygame dot color and in here type blue and if we run the code now our test surface is going to be blue alternatively i could just add an rgb tuple that has 0 red 0 green and 255 of blue and if i run this code we have the exact same outcome and with that we have already covered the very basic colors but here's one thing i really want you guys to pay attention to that our test surface we have placed on position 200 and 250 and this point is exactly half way of our display so the point we placed it on is right in the middle of the screen but our test surface is very much not in the middle of the screen so what's the problem here and it's not really a problem it's just how pie game works when we specify this point we specify the top left of this surface so of our rectangle the top left point is going to be at position 200 and 250 and we are going to get more control over this in just a bit but before that i do want to cover an animation just to cover it on a basic level right now it looks like our surface is being static and well it kind of is but the main principle here is that this image is being redrawn every time this while loop is running and the reason it is static is because the position we put it on is always the same but we could totally change it so let me close it and let's say i want to move the x position so this one and for that i can just add a variable in here and create the variable early on so let's call this xpos and by default it is 200 so exactly what we had so far so let me run it and we get the exact same result but what we can do now is just to add x plus plus equal one and now let's run the code again and see what happens and there you can see our surface is going to move slightly to the right and this looks like an animation but basically what happens is that every time this wallop is running it is going to put the surface on this x position but this exposition gets slightly larger every time we call it and because this happens at such small increments and so often that to us it looks like a fluid movement so we consider this an animation and we could also do it the other way so with and now let's try it again now our surface is moving the other way so it's going to the left and with that we have really basic animations but there's one thing that is important to keep track of and let me change this back to 200 and now i want to move the y position and let me just put an x position in here not great naming but it really doesn't matter and now i want you guys to make a guess is this surface going to move upwards or downwards and what we basically do is make the x position smaller so this one starts at 200 then becomes 199 then 198 and so on and let's actually run this and see what happens and here you can see even though our x is getting smaller our surface is moving upwards which can be quite confusing but let me explain what this means the origin of our display surface is in the top left so if you want to go to the right you have to increase x and if you want to go to the left you have to decrease x this part should feel quite natural however if you want to go downwards you have to increase y and if you want to go up you have to decrease y which is the part that can get quite confusing although this is also the part that is really common in video game development and this is going to take you some time to get used to but ultimately it's not that bad and let me close this and let's do the opposite so i want to increase y and and now our test surface is moving downwards so this is one thing that can get quite confusing but all right let me get rid of these variables because we don't want to go for animations anymore so i just want to place this thing back at position 200 and 250. and let me write again and this is still working and now here's one thing that i talked a tiny bit about earlier that we don't really have all that much control about how to place this surface so for example if we wanted to place the center of the surface we couldn't really do it or let's say if we wanted to place the bottom right we just couldn't really do it and to fix that pie game has another concept that is called a rectangle or wrecked in short and let's talk about those and incidentally they are also the second part on how to draw something in pie game and well a rack is just a rectangle that you can either put around something else or use for drawing and this rectangle has lots of different points that we can influence and you can see all of them on the screen right now and these points are super useful not just for moving something but also to measure if two objects are overlapping for example or if something is moved outside of the screen or you could also measure how large an object is and there are two ways to create a rectangle you could either create one by itself or you could take an existing surface and create a rectangle around it and then once you have a rectangle you can do quite a few different things with them but let's actually play around with this in code so here we are back in our code and the very first thing i want to do is to create a new rectangle let's call this test rectangle and this is just going to be pygame dot rect and in here we have to pass in four different pieces of information we need an x position a y position a width and a height and let's put this thing at position 100 let's say 200 and let's give it a width and a height of let's say 100 each and here again this x and y is still going to be the top left but we are going to get more flexible in this in just a second so now we have a rectangle but if we run the code we are not going to be able to see it so this isn't going to do all that much but what i could be doing now is use pygame.draw.rect draw this rectangle and in here i have to pass in three pieces of information i need the surface to draw on i need a color and i need a rectangle so our rectangle is going to be our test rect our surface is going to be our screen and for the color let's go with pygame dot color and i want to go with we haven't used red yet let's go with that and now let's try this and there we go we have another rectangle and this one is not a new surface it's a different kind of object and later on when we create our snake we are going to be drawing lots of different rectangles that we are going to each put on the screen and you might be asking yourself what's the really big difference between creating a new surface and putting that on screen or creating a rectangle and drawing that and well it depends on what kind of job you want to do usually drawing a rectangle is a much simpler task so it takes less code and less processing power and most of the time for surface you don't just fill the surface you add something else to it so that just filling a surface and putting on the screen doesn't really happen if you want to do that you would just use a rectangle and there are quite a few different things we could draw this could also for example be an ellipse and now if we run this we get a circle and there are quite a few different shapes you could be drawing but i don't want to draw anything just yet and i also don't want to create a surface like that just yet instead what i want to do is to get this test surface and use that to create a rectangle and for that we need test surface dot get wrecked and what this one is doing is it gets this surface and it puts a rectangle around it but the really useful thing now is that in the parenthesis we can specify on what point we want to place it on so for example i could type center and now in here add an x and a y position so for example now if i add in here 200 and 250 this rectangle would be placed right in the center of the screen and then when i use blit or original test surface i could use this rectangle to actually place the surface so let me remove those two points and insert test wrecked and now if we run this we get our surface right in the middle of the screen and there is quite a few different things going on right now so let me go through them one by one in terms of what i have just done i have first created a new surface called test surface and this surface is 100 pixels wide and 200 pixels high then i have drawn a rectangle around the surface and i have placed this rectangle right in the middle of our screen and then i have used this rectangle to actually place the test surface on the screen and we could also use another point for example i could use top right and then we'd be placing the top right so now the top right corner is in the center of the screen and this way you get a ton of control over how you place elements on the screen and let's actually try to move this rectangle to move our surface so i want to get our test rectangle and i want to move the right position and just add plus equals let's say one and let's try this now and now again we can see our surface moving to the right and the important point here is that if we move any point on the rectangle we are going to move all the points on the rectangle so we could for example also move the left of the rectangle and we'll have the exact same result so this one doesn't really matter and all right with that we have covered the absolute basics of pygame that was quite a bit of material so if you feel overwhelmed don't worry too much because i will go very slowly through all of this while i actually create the game so let me get rid of all of this material besides this green dot fill color so now we are back to a very basic setup that's just a green background color and doesn't do anything else and on that we are going to create our snake game but before we come to the actual code for the game let's first talk about the logic on what we are going to do and there are two main concepts you have to understand for the snake game to work number one is that we are effectively creating a grid on our display but we are not really creating a grid we are just simulating it and instead what we are going to do is that every time we are moving we can only move in certain increments so let's say every time you move you have to move by the amount of 40 pixels and since you can only move by that amount you are effectively moving in a grid although it's not really a grid it just looks like one and into this grid we are going to put our snake and that's going to be the second major concept and effectively our snack is going to be a list with different positions and each of these positions is a block and all we are going to do to move the snake is to update each of the block in a certain direction and then we are drawing the block and that gives us a snake ultimately it's actually a really simple logic but i think there was a ton of material covered let's actually start talking about the snake now that we have covered the basic logic of pygame and also logic to make the snake game work we can actually start making our game and i'm going to start setting up our board and placing one piece of fruit in there and the reason for that is that the fruit works in almost the same way that the snake does so the fruit is a really nice way to start with the board and see how we can place elements in there here we are in the code that we have set up earlier and the first thing i want to do is to change the size of our window so these two coordinates because right now they are fixed but i want them to be a bit more flexible and essentially what i want to achieve is that we have one variable with the number of cells and another variable with the size of each cell and then those two numbers combined create the size of our screen so if we always fill the entire screen regardless of how big the cells are or how many cells we have and for that i'm going to create two new variables the first one is going to be cell size and i've set this to 40 and then we need a cell number and this one i've set to 20 and at least for now you could change these numbers to whatever you want it doesn't really matter until we add graphics to the entire game but now for the dimension of the screen i want the cell number multiplied by the cell size both for the x and for the y so now when i run the screen we are getting a screen that is 800 by 800 pixels wide or 40 times 20. so this seems to work quite well and that's really all we need to set up the basics of our game so with that covered we can start creating our fruit and this is going to be a class or well it's going to be an object but we have to create a class for that it doesn't need to inherit anything and when i initiate it i own itself and now i want to achieve a couple of things with this class so let me just write it in the comments number one is that i want to create an x and y position so we can actually place it somewhere on the grid and besides that i also want to draw a square so whatever this position is i want to draw a square which is going to be the fruit and later on we are going to add graphics to this but for now this isn't going to matter so i want to create self.x and let's say for now this is going to be 5 and then i want self dot y and let's go with 4. so right now these are fixed numbers i am going to change them just a bit and having these two numbers along with a cell size would actually be enough to already draw a rectangle however i'm going to put one step in between but i'm going to store these two values inside of a vector 2d and let me explain why throughout this entire tutorial we are going to work very extensively with twodimensional data so we want to have a really efficient way to work and store twodimensional data so that we can change an x in the ycoordinate really easily and vectors are perfect for that and to explain why let me illustrate a difference compared to a list with two values you can see a vector that has an x coordinate of 5 and a y coordinate of 4 and at a normal python list with 5 and 4. and right now both of these express the exact same information and the first advantage of vectors is that accessing the x into y is a bit clearer compared to a list so if you want to access the x or the y for a vector we can just take the vector place x afterwards and then we get the x and the same for y and for a list we would have to use indexing and just add square brackets into 0 or 1. and while this is quite a minor advantage it does make our code considerably more readable if we have more code so this is a nice thing to have but the really important thing that really helps us with vectors is vector math and here's what this means let's say we have our list and we want to move this cell to the right and moving something to the right just means increasing the x by the amount of one so in the list we would use indexing to get the x value and then just add one to it and this would be a fairly straightforward operation and don't get me wrong we could use lists for the entire game it would be doable but also kind of annoying to work in because in vectors doing this kind of thing is much easier because when we have a vector we can just create another vector that has a value of 1 and 0. so this would be a movement to the right and then we can just add this vector to the original vector and if you add two vectors together you get the sum of both of the x values and both the y values so if you wanted to move the vector to the right we could just add a plus right vector and then we have moved it we would not need to identify any specifics of the vector we could just go straight ahead and especially for the snake later on this is going to be so much better to work with but alright i hope that makes sense and now let's actually implement it so here we are back in our code and i want to add these two values inside of a vector so i create a new attribute with self dot let's call it position and to create a vector 2d in pi game we need pygame dot math dot and in here we have to create an x and a y value which we already have we just created them and this is terrible spelling self and self so we just place these two values inside of this vector and then we have a twodimensional vector and there's one more change i do want to make that i don't want to type pygame.math every single time i just want to type vector2 so in the import i'm going to type from pygame.math import vector2 and that way i can just type vector2 which is going to save me so much writing and with that we have a really efficient way to store twodimensional data that we later can use to draw a square so that's quite nice and with that covered i want to create a new method that i call draw fruit so this one is well it draws the fruit and let me get rid of these two comments all right so what i want to do in here is first create a rectangle in the right position and then i want to draw the rectangle so let's work through them the first one is to create a rectangle and let's call this one fruit rect and this one is just going to be a pie game wrecked object and this one is going to need an xcoordinate a ycoordinate then we need a width and a height so we need four different pieces of information and two of them are super easy to get because width and height are just going to be our cell size so i can literally just copy cell size and paste it in there and then we are already halfway there and then we have to figure out the x and the y and well this is going to be for now this position so what i want to get is self dot pause this would be the entire vector but i only want to get the x position so in this case this would be 5 and then i want to do the same thing for our y position so self.y which will get us this value which is 4. and that is literally all we need to create a basic rectangle and now we can get to drawing it and really all we have to do is type pygame.draw.rect which draws a rectangle and in here we need three different pieces of information we need a surface to drawn a color and then a rectangle that we want to draw and we already have most of this information so our rectangle is just going to be the fruit rectangle we just created and the surface we want to draw on is this green surface so our main display surface so that is already getting us quite far ahead now we need to work on the color and this is going to be an rgb tuple and for that the amount of red is going to be 126 the amount of green is 166 and the amount of blue is 114 and for now this is just going to be a plain darkish green it doesn't look particularly good but later on we are going to replace it anyway so it doesn't really matter and all right this is actually almost all we need so let's actually create a basic fruit just to see how this would look like on our game so i'm going to create a new object with the fruit class and then in our main game loop after screen.fill i type fruit dot draw our fruit so that we can actually see it on the game and let's run this and see what happens so now we can't see our green rectangle but there are two problems number one is that the rectangle is way too far in the top left so something went wrong when we placed it and number two if you look at the bottom of the screen is that python is giving us a warning about implicit conversion to integrals using int and both of these we can fix quite easy because they happen in the same line in this line here so let's work for them step by step and the first one is the actual placing of this rectangle so right now for example this self.post.x is five so when pygame places it it literally places it 5 pixels from the left but we don't want to place it 5 pixels instead we want to place it 5 times the cell size and same for position.y right now it's placed 4 pixels from the top but instead we want to place it four pixels multiplied by the cell size so literally all we have to do in here is to multiply this by cell size and this is what i explained earlier that we don't really create a grid instead we move each object by one pixel and then multiply it by the cell size and this creates the illusion of a grid and this is really all we need and let's try this so this is looking so much better and just to test let me change both of these to zero so we can tell if they are in the top left and there we go now we have our square in the top left and just to make one more test let's put it to 10 so now it should be on the left and roughly in the middle of the screen and there we go this seems to be working now so now we actually have a basic grid that we can use to place elements on and with that we can also work on the second problem that way of an implicit conversion to integers and what this basically means is that pygame.rec wants to have integers for all of its values but getting values from a vector is always going to be a float even if we pass integers into it so right now python converts both of these into integers by itself but this might be removed in a future version of python so to make sure our code is going to work in the future we have to do this manually which is super easy to do all we have to do is to put the end method around it and we're good to go so let me do it for both of them and now if we run it we don't get an error message anymore and all seems to be good cool and really all the integer method does is it takes a value and turns it into an integer that's really all that happens here and before we finish this part there's one more change i do want to make that right now both of these values are fixed but we want them to be random and to do that we have to import another module the random module which can generate random numbers and what we want is random.rand int which generates a random integer from one value to another and we always want to start at zero and we want to go all the way to our cell number so cell number however there's one more thing we do have to do that rent in goes from this number all the way to this number and it also includes this number so this could be a number from 0 to 20. and whenever we draw a rectangle this position is going to be the top left so there's a very small chance that the top left might be something like 0 and 800 and this would be outside of our window so we have to subtract 1 from this and this ensures that we are always on screen and since we have a square we can just copy the entire thing for our y position and with that done let's try it a couple of times so we have a random square here let me close it and let's try it again we have a different position and one more time we have another different position cool and for now this is all we needed for the fruit so i can close it and we are going to make one more change later on to it but for now it's working as intended and alright now that we have covered the basics of the grid we can actually start creating our snake and the snake is going to work in a really similar way compared to the fruit the only difference being that now we don't just draw one block on the screen we draw multiple but we are still going to use vectors so effectively what we are going to do is we have a list with all the blocks now a snake and we cycle through this list and draw all of these blocks so let's start with that and once we have that we can talk about moving the snake so here we're back in our code and i want to create a new class that i call snake and i'm going to initiate it as always there's nothing special we need here and for now i only want to have a single attribute that is going to be the body of our snake and this is going to store all the vector 2s that create our snake and in here we are going to place all the blocks that constitute our snake and let me actually add some just to visualize this so i want vector 2 and let's go with 5 and 10. so this is roughly in the middle then i want to have another vector and one more let's start with three and are going to be six and seven so this is just going to be three blocks right next to each other and this is also what the player is going to see when the game is being started so this would always be the starting position but you could change it as much as you want but all right now i need a method that draws our snake does not need any parameters and all i want to do in here is for block in self.body so i'm going to cycle through all of these vectors and i want to do something with each of them and in here very similar compared to our draw fruit i want to create a rectangle from the position and then draw the rectangle so this is going to be incredibly similar to our draw fruit method actually so let's go through it step by step and this could actually be an exercise if you want to challenge yourself try to cycle through this list and draw all of these vectors and this should look incredibly similar compared to these two lines so pause the video now if you want to go along and try this yourself so the very first thing i want to do is to create a new rectangle i call this one block and what we need again is pie game.rect and here we need an x a y a width and a height and again the width and the height are super easy it's again the cell size so all i want is the cell size for the width and the cell size for the height now for the x i want the block so this block here which right now let's say for the first element would be the vector of 5 and 10. and since we're looking at the x this is going to be x so this is literally the same thing we have done here and from there we have to multiply this by our cell size and then to avoid the warning by python again we have to put all of this into an integer statement and that's basically it so now i can copy the entire thing and place it in for the y and then change block dot y and here what you could be doing to make all of this a bit more readable is to create all of this on a few separate lines so our x position would be all of this and then i can copy it and create our y position and then in here i could just write x position y position so this would have the exact same outcome although i guess this one is quite a bit easier to read but it's ultimately up to you but okay now we have a rectangle we just have to draw it so again i want pygame.draw.rect and in here i still want our screen surface to draw on and now i'm going to need a new color and i went with 133 191 and 122 and then for the rectangle we just want our block rectangle and with that we have drawn all of these vectors so now all we have to do is to create an object from this class and then in our game loop just called snake dot draw snake and let's see if this is going to work and there we go we have our basic snake although i think right now the color is a bit hard to see so let me close it and go all the way back to our snake and let's change the green value to 111 this is going to turn the entire thing quite a bit more red and let's try it now and there we go this is quite a bit easier to see but ultimately it doesn't matter all that much because we are going to replace all of this with proper graphics later on but i think for now this is a bit nicer to work with but okay now we have drawn all the basic things we need to make the game workable but our snake doesn't move and let's work on that okay so let's talk about how to move the snake so here's a snake and let's say we want to move this snake one field further to the right to achieve that we take the hat and move it one block further to the right then we take the block before the head and move it to where the head used to be and then we go through the entire snake and do this to every block so that the position of every single block takes the position of the block that came before it and that way every single block follows the head of our snake and this is how we are going to move the snake so we are not actually moving the snake instead we are taking each of the block and putting them in different positions and this simulates the illusion of movement and here's how we are going to simulate this in our code besides our self.bodylist we are going to add a self.direction and this gives us the direction that the snakehead is going to take in the next turn and then in our game at certain intervals we take the first element of our self.body list which is the head and move it by the direction and this way we're moving the head of the snake and then we're going to create a new list that copies our entire self.body except for the last element and to this new list we are going to add our head and that way we have moved every single item inside of the list one step further and we also added a new item at the front for our head so that's quite a bit of logic so let's actually implement it and there are two more things that we really need to make this work number one is that we need some player input so that we can control the snake and number two is that we have to create a basic timer and then we only want to move our snake whenever this timer triggers and in my case this is about every 150 milliseconds so quite a few things to cover and let's just start very simple and we only want to move our snake to the right so here we are back in our code and i'm still working in my snake class and what i want to do is to create a new method that i call move snake it doesn't need any parameters and in here we are going to move our snake and the first thing i want to do is to create a copy of our body and this i can just do with self.body and then using slicing so right now this would copy our entire list but we don't want to copy the entire thing we only want to have the first two elements so we are going to go from the first element to the one element before the last so this list right now would only give us these two elements so this element here at the end would just disappear which is exactly what we want because we want to move the snake forward and then to this list i want to insert another element right at the beginning and this is going to be our head that we are moving so this has to be at index 0 so it's right at the start of the list and the value it is going to have is the previously first item of our list plus a direction and this direction we are going to create from player input but for now it is just going to be a vector 2 that points to the right and let me just type it properly vector 2. let's say for now it's going to be 1 and 0 so it moves to the right so this is self.direction and this is really all we need for the basics of our snake movement so we copied the entire self the body list but removed the last item and then for the hat we're adding one more element right at the front that is going to be the first element of the previous list last the direction we want to go in and that way the entire snake is moving forward now for the last bit all we have to do is self.body is our body copy so that we are returning the entire list back to our body because this is the one we are going to draw and i don't want to change this entire thing again and really this is all we needed to move our snack in the most basic way but here's the problem now i don't want to execute this method all the time i only want to execute it at certain intervals in my case every 150 milliseconds so we need to create a timer and timers in pygame work within the event loop so this part here because this event loop can look for different things right now we only look for one specific event that we are closing the game but there could be lots of other events and in a bit we are going to add more events for player input but we could also add another event that is just a timer that triggers every few milliseconds and this we are doing in two lines of code the first one i am going to call screen update and this is going to be a variable that we don't want to change and this one is a pygame dot user event and let me just type it properly so this would be a custom event that we could trigger and how we triggered is by creating a timer and to create a timer we need pygame dot time dot set timer and in here we need our event so screen update and then how often we want to trigger it so my case 150 and this is in milliseconds so this event is going to be triggered every 150 milliseconds and then in the event loop we can capture it so if event dot type is equal to screen update then we want to do something and what i want to do is to get our snake and i called the method move snake so snake dot move snake and this is all we needed so let's try this now and there we go we have a moving snake that moves to the right obviously right now we can't control it so it's not particularly useful but it is working so with that covered let's actually work on keyboard input and this still happens in the event loop so we can just keep on working in here so again if event dot type and this time we look for pygame dot key down so this is going to be triggered whenever we press any button on the keyboard but we want to check for specific keys so we have to look for if event dot key is equal to let's say in this case pygame dot k up and this pygame dot k up would be the up key on your keyboard so when we press this then we want to do something and what we want to do is to get our snack again and what i want to change is the direction so right now our direction is going to be one and zero so we're moving to the right but if i press up this should be back door two and we don't want to move to the right and we move up so minus one so now if we run the game we are still moving to the right but if i press up we start to move upwards so this is working quite well and now all we have to do is to copy this line a couple of times for each direction we want to go in and this could actually be a really good exercise for you to understand vectors so if you want to code the long pause the video now and try to add three more if statements go left down and right let's do it together now so i want to take this entire thing and just copy it a couple of times and the first one let's go with right this one is going to be one and zero then let's go now with down and down it's just y equals one and then finally we wanna go to the left and left is going to be minus one and zero and that is pretty much it so let's try the entire thing now and let's see how this works so we can still run around and this is working really well obviously right now i can go over our fruit and nothing is going to happen but this we are going to cover in the next part which is going to come now actually so now we have a snack that can be moved around and we have a fruit on the field now let's try to bring them together and for that i'm going to create a third class that i called main and this one is going to actually contain the logic of our code which is going to make it much easier to maintain where things are going to be and i think this is best explained by implementing it straight away so let's jump right into our code and let's implement it so here we're back in our code and let me minimize the snake and the fruit so we have a bit more space and i want to create another class that i called main and when we initiate it i want this main to have our snake and this is literally creating the snake object and then also the same for our fruit so that whenever we are creating an object from this class we are also creating two more objects from these two classes here so that the entire game can happen inside of this one class and then this main class is going to have a couple of methods to maintain the game the first one i called update and what's going to happen in here is that we are moving the snake so i copy this one from the event loop and place it in here and i can also get rid of these two objects because we don't need them anymore and instead for all of this i'm going to create our main game and this is going to get main and then in the event update i call main game dot update so we don't actually change our game but now whenever we call screen at update so this event here we are calling maingame.update and maingame.update moves the snake and there's one more change we have to make this has to be self.snake so we are targeting this one so the snake itself remains unchanged just how we trigger it is going to be slightly different and then i'm also going to do the same for raw elements so all the stuff that we want to draw is going to happen inside of this method so right now we draw our snake and our fruit in the main game loop but i want both of these to be in here so that all of this happens inside of our main class so in our actual game loop we can just call maingame dot draw elements and this is quite a good practice that you want to keep this main game loop as clean as possible okay let's actually try to see if this still works and it does not because name our snack is not defined when we are calling our directions because we have to change this one here to main game dot snake and then it should be working so let me copy all of these and let's try it again now and there we go nothing much changed so far and you don't necessarily have to do this kind of step but it is going to make it much easier to organize your game okay so all of this is still working and a really nice advantage we have right now is that both of the snake and the fruit are in the same class so we can check where they are in relation to each other so for example if the head of our snake is on top of the fruit we want to do something with the fruit and with the snake and let's actually do that so i'm going to create a new method that i called check collision it's not actually a collision they just happen to be on the same spot and what i want to check in here is if self dot fruit dot position so this vector here if that is identical to self.snare dot body and the first element so this is going to be the head of our snake and this is our fruit position and if they are in the same position our snake is eating the fruit so then we want to do certain thing and for now let's just test if this is working so i want to print snack and let's try to run the code and nothing is happening because i forgot to call this method so in our update method i want to call self dot check collision and now let's try this and there we go we can go over the fruit and we print a statement so we know this if statement is working so that's quite nice and there are two things i want to do when our snake is colliding with the fruit number one is i want to reposition the fruit so that it's ending up in a new position and then besides that i want to add another block to the snake which is the main point of the game that you make the snake as long as possible and let's start with the fruit that one's the easier part so i want to target our self.fruit and then i want to add a new method that i call the randomize so let's create this one so let me close the main one for now and all the randomized method has to do is to create new random numbers in here so pretty much literally the same lines of code so i can just copy all of them create a new method that i call random mice and just copy these three lines of code because they create a random position and place the element there and i can just call self.randomize and that's all we needed to move the fruit so let's try this so it's still working and we get a new position for our fruit and let's try it again and there we go this works really well last one there we go cool so this is the first part that we want to reposition our fruit so this one's done now we come to the second part adding another block to our snake and this one is also actually super easy so again we want to target our snake and i want to add a new method that is called add block so let's create this method so let me close mine again and open snake and now let's create add block and now we have to think about what we are going to do because doing this is actually super easy but you do have to think about what you are going to do and ultimately it goes back to these three lines of code and specifically this line here that right now we copy our self.body list and take every element except the last one so that we are moving the entire snake forwards but if we want to add a block to the snake all we have to do is to remove this one and take the entire body and we are still going to add a new position at the front so we are extending the snake but this is really all we have to do for the change so let me revert this back and how i implemented this is i created a new attribute that is called self dot new block and by default it is false and what add block does is it changes self dot new block to true and if self taught new block is true so in our move snake if self dot add block is true so let's just type it in full then i want to copy the entire block and not delete anything and if that is not the case i just want to move the entire snake without adding anything towards it and that is pretty much it so let's try it and there's one more thing i do have to add so oh i realized there's a typo this is an app lock this is new block if this one is true so now let's try it and now when we pick up something our snake is going to extend for all eternity which i guess is a little bit funny but not the intended thing we want to achieve and the reason why this happens is because this log through stays true so once we are colliding with the fruit it is always going to extend which we don't want but we can fix it super easily by changing self.new block to false and now let's try it again so now our snake every time we collect the fruit is going to get a tiny bit longer and this seems to be working really well so this already is a really basic snake game and well takes no time at all to create it and with that we have our basic logic but the problem right now is that our snake cannot die so let's work on that and there are two conditions that could lead our player to fail number one is that the snake hits itself or that the snake hits any of the screen walls so effectively we have to add two if statements so let's start working on it so here i'm back in my code and i want to work in our main class function and i want to create a new method that i call check bail doesn't need any parameters and in here we want to check if snake is outside of the screen and check if snake hits itself and let's start with the first one that we want to check if the snake is outside of the screen and this is actually going to be super easy to check effectively all i want to do is if the snake is between 0 and the number of our cells so in this case 20 and if that is not the case then we want to go to the game over screen and we only have to check this for the head of our snake because the rest of the body always follows the head so only the head really matters when we check for game over but let's implement this so i want to check if not 0 is smaller or equal then our self dot snake dot body zero and this is smaller or equal than cell number so there's quite a few things going on right now so let me talk through it self.snack.body is the body of our snake and 0 is going to be our head so let me open it right now this would be this element here at position 5 and 10. and we want to check if this is outside of the field so if it is not between zero and the number of cells and there's one thing i forgot this one here is a vector and we can't compare vector to one single number so we have to check this for x so that we only check left and right and we are going to add the top and the bottom in just a second but for now if that is the case we want to do something so let me create a new method that i call dot game over so def dot game over and at least for now if our game is over i just want to quit the entire thing so i copied these two lines and paste them in here but we are going to change this later on in our update method we actually have to call it so self dot check fail so in theory right now if our snake is too far to the left or too far to the right it should fail so let's try and let's just go to the right and the game is over cool but there's one bug right now that this cell number at the highest point would be 20 but our cell furthest to the right is cell 19 so we could in theory go one field outside of the game which i don't want so i just removed the is equal to and we have to be smaller than this number so now if i try this again our snake or game fails whenever we hit the right wall so that's perfect but now the problem is that this is only going to work for left and right so we have to improve this if condition to also check for the top and the bottom of the screen and this could again be your challenge so pause the video now and try to do this yourself so really all we have to do is to add an or statement and copy the entire thing and then change it to y so we are going to check if the head of our snake is not too far to the left or to the right or if it's not too far up or down and this is really all we have to do so let's try all of this now and let me try to go game over from the top of the screen and this is working cool so now we have the condition to check if the snake has hit any of the walls so with that covered we can check if it hit itself and really what this means is we want to check if the head of the snake has collided with any other part of the snake so i'm going to start by cycling for every single block of the snake except for the head so for block in self.snake and i only want to go from the element with the index 0 all the way to the end so we don't take the entire snake we only take all the elements that come after the head and in here i want to have an if statement that if any of these blocks is equal to self.snake0 and if that is the case we go back to game over and this would be the proper logic although i did just realize i made a typo this should be snake.body and same for this one snake.body because snake is the actual object we created and body is the actual part that contains all of the blocks and while we add it i also realized i made another mistake and let me go all the way to the top to explain what i did wrong so when we are creating our snake it is moving to the right so the vector is one and zero however the problem now is that our snake is actually facing to the left not to the right as i initially intended it and you can see this quite easily that the very first item is this point here at position 5 and 10. so in theory this should be the point furthest to the right but it's not because the second and the third item have greater x values so this one is to the right of this one and this one is to the right of both of these which basically means that the head of our snake is to the left of the body of the snake and since we are moving the head of the snake to the right it is going to move inside of itself so we do have to fix this and sorry about that but there are two ways of fixing this it's really easy to do number one you could either move the head by default to negative one so that we are moving the head of the snake to the left and all would be good but i don't really like that because it's too close to the wall and instead what we can do is change these two vectors to four and three on the x positions so that they are to the left of the head and with that covered let me go back down to our check fail logic and let's try this and the snake is still going to move that seems to be working quite well and let me pick up a couple of items so i can actually move them to myself and yeah it seems to work so cool now we know this is going to work and this is the basic check fail logic however there's one problem right now and let me run the game again now the snake is moving to the right and i could just destroy myself by clicking to the left and the problem here is all of this code here that we could always change direction let's say going up even if we are going down so that we have to add some code here that our snake cannot reverse itself because then we would instantly destroy ourselves and this can very easily be done with just adding another if statement so right now we check if event key is the up key and now i want to check if maingame dot snake dot direction dot y is different than one and only if that is the case we want to execute this line of code and let me explain what this means so when we're pressing the up key we want to go up however if we are moving downwards this is not supposed to work because then we would fail immediately so we want to check if our current direction in the y direction so this part here is anything but one because if it's one we're moving downwards so only if it's different from one then we can actually do this line of code here and this line of code we just have to copy a couple of times and change it for the different directions so for right it would be x and 1 so that if we are going to the right we cannot currently go left that just wouldn't make sense we would just reverse immediately then for down we would again look at y but it would have to be minus one minus one and then finally to go left then we again have to look at x and we can only go to the left if our snake currently is not going in the right direction and all right this is basically all we need so let's try it now and now i'm moving to the left and i can't reverse direction you can't really see it but it does work and we can still pick up all the other elements so all of this is working so nice and i can still get game over from moving into a wall so with that we have created a really basic snake game so this one is going really well but it really doesn't look all that good and also we can't tell a score so this is the stuff we are going to start working on now that we are going to start making this game a lot prettier and this is going to involve quite a bit more code but ultimately it's a really good practice to learn how to use if statements and the enumerate method but let's start with really simple one that i just want to display a proper fruit instead of just a rectangle and let's jump right into the code i think that's going to be the easiest way to approach this topic so here we are back in our code and the very first thing i want to do is to actually import an image of our apple and i'm going to do this where i initiated all the other elements and i want to import an apple and to import an image we need igame.image.load and then the file direction and this has to be a string and in my case i have a folder called graphics and in this folder there's an image called apple.png and here again this is only going to work if your code is in the same folder as this graphics folder so make sure you have them in the right place and then also i want to convert alpha this image so pygame can work with it easier so all that this method does is it takes this image here and it converts it to a format that pygame can work with easier so our game can run better but okay this is all we needed for the apple so now when we have our fruit class we can instead of drawing a rectangle we can draw an apple so let me comment this line out because we don't need it anymore but we are still going to need the rectangle so keep that one and really all we have to do is to use screen dot blit and now we need a surface and a rectangle our surface is going to be this apple here that whenever we import an image into pygame it is going to be on its own surface so we can just add apple in here and after that we need a rectangle or at least some kind of position and we also have that it's just this fruit rectangle so i just type in through direct and this is literally all we needed it's surprisingly simple so let's try it off this now and see if it works and yeah it does we have an apple and it still works with randomizing and all of this works super well and there we go so this already covers our entire fruit class now i can close it and we never need to open it again and with that part covered we can actually put the graphics on for our snake and this is going to be the most complex part of this entire tutorial but in general terms here's what we are going to do we are going to go for every single block in our self.snackdoll body and look at how each block relates to the block before and after itself and from this relation we can tell what kind of block to put in this place so effectively we are going to create a really long if statement that checks a huge range of different factors and i think this is really best explained while actually doing it so here we are back in our code and the very first thing i have to do is to actually import all the images we need for the snake and this is going to look very similar compared to this apple import except now we are going to import quite a few more and since we only jump for the snack itself i'm going to do this in the snake class when we are initiating it and in here i already have all of the lines ready and let me paste them in so this is quite a few different graphics that are being imported we have all the possible head positions all the possible tail positions then a vertical and a horizontal body and finally all the curved body parts so in total 14 different images and these are all the possible graphics that could be used for our snake and now that we have all the graphics we just have to figure out where to put them in our game and this is going to happen in our draw snake function so let me close everything else and let me give some space so we can focus on this part and first of all this part that we used to have we don't need any more so i'm just going to comment it out actually let me get rid of it entirely so we need all the space we can get and here let me go through it really slowly the first thing we want to do is we want to look at all the blocks in our snake body so we want to look at for block in self dot body but this by itself would not be enough because we want to look at more things we don't just want to look at the block itself we also want to look at the blocked accounts before and the block that comes after and for that we are going to need the enumerate method and what enumerate does is that it gives us an index on what object we are inside of our list so we have to type in index and then block so index is the index we're on and block is the actual object that we are going to look at so for example in our body right now we will get an index of 0 and then vector 2 would be our block and for the second entry this would be index 1 and the block would be the vector and this would allow us to access quite a few more blocks that are not the block itself so this one is really useful and in here we have to do lots of different things now and let me just write them out so number one is we still need a rect for the positioning so maybe i shouldn't have deleted the earlier one but we can just write it again so it doesn't matter too much and once we have that just to get started we want to figure out what direction is the face heading so in what ways are snake looking and this is going to be quite a bit larger so let's code until that point so let me start by creating direct again and this again is the same thing we have seen earlier where we literally just take the x and the y position from our block and from that we create a pygame direct object and it has an x position a y position and then we have cell size and cell size for the x and the y size so this is the same thing we have done earlier and this we still need this is what we use to actually place the image and get the position so this was the easy part now we have to think about how can we identify different parts of the snake so for example how can we tell which part is a hat and which part is a tail and for that the index is incredibly valuable because all we have to do is if index is equal to zero because index zero is always going to be the first element and our hat is always going to be our first element so this is all we needed so if that is the case we want just like for the fruit screen dot blit and in here we have to enter a surface and a rectangle we do have the rectangle that's our block rect and just to pick one of the hats so we have four different heads for each direction let's start with head right and if that is not the case so else at least for now we just want to do the same thing we have done earlier so pygame.draw.rect and i want screen and i forgot the color we had so let's just go with 150 100 and and then log rect so effectively what we are going to do is that we create a rectangle at the position where we need it and if this rectangle is the first no self.body list we are going to place the right facing head of our snake there and if that's not the case we just draw a plane rectangle and let's actually try this and i made a typo it's enumerate and now it gets blue so this looks much better so now let's try it again and there we go we have an incredibly weird looking graphic but we do have a graphic of a snake hat that kinda works so at least we're making some progress cool let's step in the right direction so this line here is kind of working but the problem we have right now that let's put in number three the snake head direction is not updating so what i want to achieve is that if we are moving upwards the snakehead is also looking upwards and we do have all the graphics to make this work but we do have to figure out how to select the right image and how i solve this is by putting all of the logic for this into its own method so i have self update head graphics and this is going to create a new self hat attribute and this is what we are going to use in the end so this method here effectively picks one of these four whichever is appropriate for the direction we are going so let's create that one so i go to def update add graphics and in itself and here's how this is going to work we are going to take the head of our snake so the first element in self.body and subtract it from the item that comes right before it and that way we get the relationship between the two or in more mathematical terms we are going to subtract one vector from the other and from the result we are going to get how they relate with each other so if one vector is above or below or to a left or to the right of the other and here again vectors are incredibly useful because we can just subtract from each other and understand how they relate to each other but okay i created a new variable that i called had relation terrible name but i could not think of something better and what i want to do is i want to go to self.body and get the second item so the one with the index one and let me just type it properly and from that i subtract our head so self.body zero so this is going to result in a new vector that could point in one of four directions and from this direction we're able to tell how the head relates to the block that comes before it and really all we have to do is if had relation is equal to vector 2 and let's start with the first one 1 and 0. so this would mean that those two combined end up with one and zero which means that our head is to the left of the next block so if that is the case self dot head is going to be self dot head left and since we have quite a few if statements i am going to keep them on the same line just to make it a bit more readable and now all we have to do is copy this thing a couple of times change this to l if statements and now update the different vectors so the easiest part would be changing this to minus one so then this one would be at dot right then if this is zero and this is one so this would mean there's a block below the head of our snake so our snake is looking up and then for the final one by the process of elimination the snake has to be looking down and that's basically it so let's see if i get this right and let's try it now and yeah there we go our snakehead is updating quite nicely so this is quite a good start okay so this would cover the head of our snake so i can close this method and not look at it again and now we come back to our if statement and let me get rid of this part here because we fixed that bit so now we have the head of our snake now the next easy bit or easyish bit is to get the tail end so the last block that we want to cover and this we can also address really easily because this part is always going to be the last one so we can use l if index is equal to last item in self.body so we have to figure out some code to get the last item in this self.body list and well all we need is the length of our self.body so this is all the items in there and then 1 because we start counting from zero and with that we always get the last item so if we have that we can do the same thing we have done for the head so screen dot blit and this time it's self.tail and we still need our block rect and self.tail does not exist yet but we do have if i open our knit method again we have all the different directions for the tail so i am effectively going to copy the method we used for the head this one and create the same one for the tail so let me close all of this and create self dot update tail graphics and again if you want to code along this could be a nice exercise so look at the update head graphic and try to figure out the logic for the tail but okay pause the video now if you want to go to long and i'm going to continue myself in a couple of seconds okay welcome back let's try to do it together now so i want to create a new method dev update tail graphics and just to save me some writing i'm going to copy the entire line for the head and just paste it in here and now it's going to be tail relation and now we don't want to look at the second and the first element instead we want to look at the last element and the element that comes before the last one so we know our last one is minus one and then the one before is minus two so this one is quite easy to start and then i have to change all of the tail relation l if statements and also change all of this to tail might have benefited from naming my variables better but never mind okay here we go so this would actually almost work so let me try and i forgot one equal sign let's try it again now there we go and there we go we have a nicely functioning tail cool so that was surprisingly easy actually so the same logic that we used for the hat we can use for the tail so now we have covered the tail with that we can start working on the actual body or the rest of the body and this is all going to end up in an else statement and in here it is starting to become important to figure out what is the next and the previous block so i want to know what is my previous block and what is my next lock and we know the block we're on right now that's just block so in here the index again is going to be incredibly useful because all we have to do is self dot body and then index plus one minus log and then for the next block we have to do the same thing except we subtract index minus one so just to explain what happens here we are indexing from self.body and index is going to be our current element and then we either add one or subtract one to get the next or the previous block which i think is quite straightforward and then from that we are going to subtract our current block to get the relation between the two and this is going to result in a new vector that again can point in one of four directions and from that we can tell what kind of block we need and now we can start with the horizontal or vertical body parts so these are going to be body parts that either are entirely horizontal or entirely vertical so i don't go around the corner at all and this is really easy to get because all we have to check is if previous block and next block have the same x or ycoordinates because if that is the case the block between these two blocks has to be either horizontal or vertical depending on if we look at x or y so let's implement this with another if statement and what i want to know is if previous block dot x is equal to next block dot x and if both of these have the same x coordinate we know it's going to be a vertical block so we can use screen dot blit and this is going to be self dot vertical and then block rect and let's try this oh right as a typo i have to get rid of yeah let's get rid of it entirely because it's just going to cause errors otherwise so now some parts of our snake we don't draw but i think that illustrates it even better what is missing so now we can see our snake is working when we're going up and down but if we're going left or right or around the corner things are missing but otherwise our snake is still working quite nicely so we are making quite decent progress looks actually quite funny but okay now i want to copy this entire if statement and now i just have to check the y parts and if those are identical we know our block is horizontal and i want to make this an alif statement so let's try this one now and we can see we have horizontal and a vertical body part for our snake we don't have any corners but that's going to come next besides that everything seems to be working quite nicely so we are making some decent progress so now we come to the most complicated part where we have to look at the corners of our snake and all of this is going to be inside of another else statement and let me explain the logic here to get this done and i think the best way to explain this is by using an example so let's say we want to create a corner where we go left and then up or we go down and right it's going to be the same corner and really all we have to do is to check the x and the y position of our previous and next block and we have the information to achieve all of this but you probably have to look over this a couple of times it is a little bit confusing but okay here we are back in our code and what i want to do is screen dot blit and i want to blend self dot body tl so this is top left so the corner is going up and left and again we need our block rect so we are now so we now have to figure out when to trigger this corner so all of this goes inside of an if statement a pretty long if statement actually so we want to check if previous block dot x is equal to 1 and next block dot y is also equal to 1 or we could start from the other way where our previous block dot y is equal to 1 and next block dot x is equal to minus one and let's try this one so top left there you can see it we have one corner and we can also go bottom right and this would still be working bottom left i mean sorry and there we go we have our first corner and now all we have to do is to copy this if statement a couple of times and change our attributes and of course the image we're actually blitting so i would have bottom left i would have top right and then the remaining one would be bottom right and the coordinates would be previous block x minus one and next block should be one and then previous block would be one for y and the x would be minus one then we have four top right the previous block x would be one and next block y would be minus one or alternatively we would have the y part would be minus one and next block would just be one and for the final one we would have one and one and same for the other way around as well okay and those are all the bits let's actually try this together and this looks pretty good okay cool so this is actually drawing graphics quite efficiently and works even if we go really close to each other and looks quite clean okay and all of this is probably quite confusing and honestly when i figured this out i went by trial and error thinking about all of this gave me a headache so if this doesn't make full sense don't worry about it it really is kind of annoying to think about but really all we are doing is we look at our previous block and our next block and how they relate to our current block and from that we can tell what kind of corner we need but granted it does get quite confusing but okay with all of that one done i can get rid of the comments and we have our basic snake and we created an el if statement that covers basically an entire page cool always feels good so now i can close drawing snake and not worry about this for a while and for the next part i want to update the grass so it starts to look a little bit nicer and let's actually jump right in i think that's going to be the easiest way to approach this so here we are back in our code and in our class main i want to create a new method that i call define raw grass and this one well it draws the grass so we have a checkerboard style grass pattern on our field to make it look a bit more interesting and to achieve this kind of effect all we really have to do is cycle through each of the line and draw a slightly darker green rectangle if we have an odd or an even number so to start this off i'm going to create just to save me some writing later on a grass color variable and this is just going to be an rgb tuple with 167 209 and 61. so this is a dark greenish color and now we have to cycle through every single cell on our field and either draw a darker rectangle or not draw a darker rectangle and to start this one off simple let me just start with the first line this one is going to make it quite a bit easier so i want to start with for column in range cell number so this would cover the horizontal axis of our entire field and for each of those i want to create a new grass rectangle and this is just going to be a pie game wrecked object and here we need an x a y a width and a height just as we have always used and with and hive again is just going to be cell size the one we have always used i almost regret not naming this with a shorter name but okay now we need two more pieces of information the first one is y and for now this is just going to be zero because we want to work with the first row but we are going to change this later on so now we are going to need our x coordinate and we could just start with this call so our column multiplied by cell size so this would give us a rectangle and now we can just draw it with pygame.draw.direct and i think by now you should know it so this is screen the service want to draw on then the color it's already predefined and then our grass rect so this right now would cover the entire first line of our field and let's actually illustrate this so when we come to draw elements below all the other elements i want self dot draw press and let's try this and you can see the very first line of our field is slightly darker so we do manage to draw at least a little bit but well it's not great yet so we have to make some more changes and the first change i want to do is that i only want to draw every second field not every field and you could approach this in two different ways you could either draw all the fields that start with an even number or all the fields that start with an odd number which one you go for it doesn't really matter but really all this is is if call mod 2 gets us a 0 only then do we want to draw all of this and let's try this and now we can see we have only every second field working for this so this is already working quite nicely so now we have to do this thing for every second line in our field so what i want to do is to go for row in range cell number so we go for every single row in our field and now we are going to do this operation again except for the row not for the column so we want to only draw this kind of row if the row starts on an even number so if rho divided by two is equal to zero and if i run this oh forgot the if statement so if row and i have to indent everything as well try now ah and this doesn't work right now because we are still starting at position zero so we have to make an update to this one so right now we are drawing this multiple times but we always start at position zero so they're all drawn on top of each other but all we have to replace it with is our row multiplied by our cell size and let's try this one now and there we go this is starting to look much nicer and now we have at least every second row working properly and everything still works okay so now all we have to do is if this is not the case so we go for an else statement then we want to do this entire thing again and let me copy it properly except now we want to check all the odd fields and this is working so this is looking at least a bit more interesting and there really isn't all that much left to go for for a proper game the two more things i want to add is a score and a sound effect and let's start with the score and to get a score we need some text and text and pie game needs a couple of steps to work so let's talk through them ultimately there are three steps we have to be aware of number one is that we have to create a font object and this one is going to determine what our text looks like and how large it is then we have to use this font to render some text and this is actually creating some text so for all practical purposes we are writing something and this text is going to end up on a new surface exactly like the pictures we have imported so far and then for the final step we have to blit the image on our actual game screen and that is pretty much it so let's start creating the basic score and once we have that we can make it look nicer so here we are back in the game code and the first thing i want to do in our main setup part i want to create a new font and i call this game font and to create a font we need pygame dot font dot bond and to make sure the second font has to start with an uppercase letter this one is important and in here we need two pieces of information the first one is the font we want to use and then font size font size is the easier part this one is just an integer i went with 25 and for the font we could just go with none and then we get a default font for pygame but i want to import a font and for that i need to give the name of the font i want to use and this has to be a ttf file that i downloaded earlier and you can get a ttf file really easily from websites like daffon.com for example and there are plenty of free ones just check it out but in my case the file is located in the folder called font and the name of the file is poets 1 dash regular dot etf and with that we have imported a font so our text is going to look like whatever this one looks like and the size is going to be 25 so these are the two basic things we have to start with and now in our main class i want to create a new method and let me minimize all the other methods i have so far just to make it a bit easier to see what's going on there really is quite a bit of stuff going on by now i want to create a new method that is called draw score does not need any parameters and in here we have to create our score and there are quite a few bits of information we first need to draw all of this the first one is the actual score text so we have to figure out what is our actual score and put this into a text and the basic logic i went with is that the length of our self.snake.body is going to be our score so the longer our snake is the higher of a score we get so this will be the basic part that determines our score but we are starting with three blocks inside of our snake so i have to reduce this by three so that we start with zero but then all of this has to be a string so that we can display it easier so i put it in the str method that works very similar compared to the end method except now it turns any kind of value inside of this into a string instead of an integer and with that we are getting our basic score so this is a good way to start and with that i can create the actual score and this would be a score surface so let me write it properly and to create this we first need our game font so what we created down here and we want to render it and in here we need three pieces of information the first one is the text then if you want to end the alias it and then we need a color and let me talk for them step by step the first one for our text is just going to be our score text so what we created up here and for the color i am just going to go with an rgb tuple again which this time is 56 74 and 12 which is a fairly dark color that has slightly more green than the other values finally we need the antialias text and this one either has to be true or false and antialiasing just means we make the text a bit smoother and unless you're working with pixel art or you work on a really slow computer this is usually best left for true and it makes our text look a bit nicer but ultimately this really isn't going to make that much of a difference especially for a simple game like ours so i just leave it with true alright now we have a text surface that we just have to put on the screen so this is going to go with screen dot blit and now we do have a score surface but now we need to get a position of this text and here we have to determine where we want to put it on our screen and i want to put it in the bottom right ish of our game and to get it there i'm going to add a few more variables just to make it easier to read so i create a scorex variable that is again going to be an integer of cell size times cell number so this would be the right end of the screen and from that i want to remove a couple of pixels so i removed 60 from there meaning that we go all the way to the right of the screen and then go a bit further to the left so we are in the right end of the screen and then i'm going to do the same thing for y that again i want to go all the way down to the bottom of the screen but now i want to go a bit up again so let's make this a bit less 240 and from these two bits of information we can create a score rectangle and here i want to get our score surface and get the rectangle around it so when we create this score surface with some text it has some dimensions and with get rekt we can access all of them and even better we can immediately place this rectangle somewhere on the screen and right now i'm placing the center and what we pass in here is an x and a y position where we want to place it and for this we can use these two bits of information so this would be our score x and score y and now that we have a rectangle we can just place this into the position for our screen dot blit and this is pretty much all we need for the score so now when we come to draw elements i want also to draw a score so self dot draw score and let's see if this is working and it is not because i made a typo this should be poet sen 1 so now let's try this again and there we go in the bottom right of our screen we can see a number and every time we pick up an apple this one goes up and let's try one more and this seems to be working quite well cool so with this bit of code we get our score but by itself the score looks a bit bland so i want to add two things to it number one i want to add an apple to the left of it and number two below the score i want to add a plain rectangle so that it stands out a bit more from the background and both of these are quite easy to get so let's add them now so what we ultimately want to achieve is screen dot blit again and this time we want to use our apple again the one we imported down here and then again we need a position for the apple so we have to write some code for this position and the position is supposed to be at this apple is slightly to the left of our score so we have to use our current existing score and place the apple to the right of it which fortunately we can do quite easily and i think to make our code a bit easier i'm gonna put the two screened up blitz together and then all the setup part goes into one big chunk of code that should make it a bit easier to see okay what i want to do is apple rect to get the position and this is going to be our apple and get wrecked again and for this rectangle we don't want to place the center instead we want to place the mid right and where the midright is supposed to be is on the left of this apple here so for the x i want score correct dot left and for the y i want scorect dot center y and that's basically all we needed so now when we blit the apple we need apple and apple rect and let's try and there we go we have an apple next to our score and let me explain what happens here so on the score we place the center of our rectangle on these positions that are roughly in the bottom right of the screen but when we create our apple rectangle we take the mid right point of this rectangle we place it on the left of our score rectangle and the y position is going to be the middle of the score rack so what we effectively do is that we place the upper right on the same height as the score rack and the x position is going to be slightly to the left and with that we have the two basic points the only thing left to do is to create a slight background so that both of these stand out a bit more although i think by itself you could even leave it like that but um it's up to you doesn't look too bad right now so i want to create a bg rectangle for the background and this is going to be a pie game dot wrecked object and in here we need an x position a y position a width and a height so let's go through all of these step by step so our rectangle is supposed to start at the top left of our apple and these are points we can get very easily so i want apple rect dot left and for the y apple wrecked dot top so that our background starts at the top left of our apple and the height is the next easiest part because all we want is the upper rect dot height so our rectangle starts at the top left of the apple and takes the entire height of the apple for the simple reason that the apple is larger than the text so if we cover the entire apple we also cover the text as well so now we need the width and for the width we want to cover both the apple and the text so this is going to be our apple right dot with plus score rect dot with and this should cover the entire rectangle so once we have that i want to use pygame.draw.rect draw on the screen the color i want to go with is 164 209 and 61 so the dark grass color and i want to draw our bg rectangle and let's try this so if you look very closely you can see it especially if i go below it there you can definitely see it so this is working but it's very hard to see so what i am going to do is to draw a frame around this box and drawing a frame around the box is very easy to do in pie game so let me copy the first rectangle and all we have to do to draw a frame around it is to add another argument so in my case this would be two but the problem here right now would be that we have a rectangle with one color and the frame around it has the same color so we couldn't really see the frame and to fix that i'm just going to copy the text color and let's try this now so now this looks much better and now you can see that the box is a little bit too narrow so that the number is too far to the right and it touches the frame which doesn't look good so we have to make it slightly larger this is the width argument and all i want to do is to make this slightly larger so i'm going to add plus let's try six and let's try now and yeah this looks much better now it's roughly in the middle and there we go this is working pretty well so with that part covered we have a score and now we can work on adding some sounds to our game and adding sound in pie game is actually super easy but there's one thing you do have to be aware of that is a little bit annoying but i think it's best to jump right into our code and let's add the sound and then we can talk about the problems with sound and pygame and i only want to add a single sound that when our snake collides with fruit then we want to play a crunchy sound and we could add more sounds like a background music or game over sound but if you can get one sound you can get all of them and i don't want to over complicate things so we are just going to stick with a single sound and let's do all of this so here we are back in our code and i want to import our sound to our snake because that's the only place where we actually going to need it so right in the indent method that gets really extensive by now i want to add a new attribute that i call crunch sound and to import a sound we need pygame dot mixer dot sound and here again this sound has to start with an uppercase letter otherwise it's not going to work and now we need the file name and in my case i have a folder called sound and in there there's a file called crunch.wav and with that we have imported a sound so that's the first step we need and then for the snake i want to create a new method and let me minimize all of the other methods so this is a bit easier to see what we are doing okay so all the way down in this method i want to create a new method that's called play brunch sound and this only needs a single line of code we want self.crunch sound dot play and so now whenever we execute this method we are going to play the crunch sound and let me close the entire thing again and now in our main class when we get to check collision we also want to play this sound so self dot snake dot lay crunch sound and let's actually try this so this seems to be working but the problem we have right now is that the sound has a slight delay so that it doesn't play right when we eat the fruit instead it plays about half a second later which can be really weird the reason is that pie game first buffers a sound before it plays it and this creates a short delay between the chord being triggered and the sound playing but we can fix that quite easily so let me close our main class and what we have to do is work with pygame.init at least a tiny bit and in pygame.init there's a method called mixer and mixer is responsible for all the sounds and what we want to do is pygame.mixer.3 init and in here there are quite a few arguments you could pass into it and it can get quite technical but i have found four numbers that work really well so these four give you a good sound and play the sound immediately but if you want to know more about sound in pi game there's the documentation that gives you a lot more detail so i would just copy the numbers and don't worry too much about it but let's try it with these numbers and we are getting a sound immediately so this is now working and with that we are nearly done there's one more thing i do want to cover though that i forgot to check earlier that let me go back to our main when we check collisions and we create a new fruit on the field there is a very small chance that our fruit lands on the body of our snake which would be very confusing so we have to add a little bit of extra code here that if the fruit is on the rest of the body of the snake we want to randomize it again so really all that we want to do is for block in self.snake.body and here we don't want to check for the hat so this would be from one all the way to the end with index 0 being the head and everything else being the body and this is what we want to check and really what we want to check is if block is equal to self dot fruit dot pause and if that is the case we just want self dot root dot mice so really odd it is happening here is that we are checking every single block of our self that's negative body and check if it happens to be on the same position as the fruit and if that happens we want to put the fruit in a different place and that way we ensure that our fruit is never on top of the snake body and this is quite difficult to show because well it depends on a lot of random chance and ideally it's something we want to avoid happening but with all of that covered we have created a pretty nice snake game and there's one final thing i do want to change that whenever we die the game just ends which isn't ideal and really all i want to do is that if our player fails i want to put the snake back in the default position so we don't really have a game over menu instead we just restart the game immediately but you could be adding all the menus you wanted but i think in this case it doesn't really make sense but let's actually implement this so we have to go to our game over and see what happens in here right now we are just ending the game which well isn't great instead i want to get self.snake.reset so this method doesn't exist right now so we have to create it and let's close our main class and go back to the snake and here we really start to have quite a bit of stuff in there but let's add one more it's going to be the final one and i called this reset and what is supposed to happen here is that we take our initial self.body and just recreate the basic points so really we just take ourselves the body where we started and that is literally all we are to do and we don't even have to update the score because the score just checks how long this list is so we don't really have to do anything so let me try this now and our game still starts the score also works and now let me fail and we move back to the starting position so this is quite well let's try it again and yep it works quite well so most of the game is done there's one last thing that is a little bit annoying and let me illustrate this so right now our direction is downwards and we start again our snake goes downwards again so when we restart the game we also have to change the starting direction so all we have to do is go back all the way to the top and change this value and actually all we have to do is to change this to zero and zero and then let me copy the entire line and further down for the reset method i also want to set the direction back to 0 and 0 when we reset the snake and let's try this so if i don't press anything the snake isn't moving if i press something we are starting to move and i can pick up a couple of apples the score is working if i go game over our snake isn't moving again and only if i start pressing the button it is starting to work so all of this is working really well and well that is it for the entire game
