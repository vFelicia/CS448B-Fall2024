With timestamps:

00:00 - hello there in this tutorial we are
00:02 - going to be talking about collisions and
00:04 - pygame and specifically we are going to
00:07 - create a project you can see on the
00:09 - screen right now and the really
00:11 - important thing i'm going to cover in
00:13 - this tutorial are the collisions between
00:15 - moving and static objects as well as the
00:17 - collisions between two moving objects
00:20 - which can be quite a hassle if you don't
00:23 - know how to think about it so this is
00:25 - what i'm really going to focus on in
00:27 - this tutorial
00:28 - and understanding the logic behind
00:30 - collisions is fundamental to make more
00:32 - complex games like zelda or mario game
00:35 - that i created on this channel they both
00:38 - use collision mechanics quite
00:39 - extensively
00:41 - and there isn't really that much else to
00:42 - talk about so let's jump straight in
00:46 - and the first thing just to save some
00:48 - time i have already created a basic
00:50 - project so for this section i want to
00:52 - talk about the project setup and once we
00:55 - have that i'll talk about collision
00:56 - logic but let's have a look in the code
00:59 - what we already have
01:01 - so here we have the project already it's
01:05 - not the shortest thing ever we have
01:07 - nearly 150 lines of code but it really
01:11 - isn't that bad i'll explain all of this
01:12 - in just a second
01:14 - but if i run this project so far
01:16 - here is the project you have seen in the
01:18 - intro except we don't have any
01:21 - collisions so the blue rectangle here is
01:23 - my player i can move it around and
01:26 - nothing happens
01:27 - and in the same logic the red square is
01:30 - supposed to be a ball that moves around
01:32 - right now it's just static without any
01:34 - collisions
01:35 - so we can move around but we can't
01:37 - really do anything other than that
01:40 - and well we are going to add collisions
01:42 - in just a bit but let's first talk
01:44 - through this entire project
01:47 - now all the way at the top we are
01:48 - importing pygame sys and time
01:51 - high game and cis are the basic things
01:53 - you need for pie game and time is going
01:56 - to be used for delta time that we're
01:58 - using down here
02:00 - to make the entire project frame rate
02:02 - independent
02:03 - if you don't know what that means check
02:05 - out this video
02:07 - in fact if you're new to pygame and you
02:09 - feel all of this is too complex check
02:11 - out this video
02:13 - it's explaining the entire module in
02:15 - quite some detail and i will assume that
02:17 - you already know basic pygame
02:20 - after the import we have five classes we
02:23 - have static obstacle moving vertical
02:25 - obstacle moving horizontal obstacle
02:27 - player and ball
02:29 - and i'm not going to go over them for
02:31 - now just assume they do what the name
02:33 - implies
02:34 - i will explain them in just a second for
02:36 - now just assume they work
02:39 - now once we have that we have a general
02:41 - setup with pygmy.init and we are
02:43 - creating a display surface
02:45 - nothing complicated so far
02:47 - then we have a group setup and in here
02:50 - we have all sprites and collision
02:52 - sprites
02:53 - and all sprites is for literally every
02:56 - single sprite we are going to create and
02:59 - this one is going to draw and update
03:01 - every single sprite
03:03 - collision sprites are for all the
03:05 - obstacles that the player is supposed to
03:07 - be able to collide with or well the
03:09 - player and the ball
03:10 - so this group here is literally just to
03:13 - figure out which sprites are supposed to
03:15 - be collided with and which ones aren't
03:17 - it doesn't really do anything besides
03:19 - that
03:20 - and once we have the groups we can
03:22 - create some sprites and in here we have
03:24 - seven sprites in total we first create
03:28 - three static obstacles and really all
03:30 - we're doing in here we are creating a
03:33 - position
03:34 - a size
03:35 - and then which groups this sprite is
03:38 - going to be in so all of the static
03:40 - obstacles are in all sprites and in
03:42 - collision sprites
03:44 - after that we have our moving obstacles
03:47 - and they work in the same way we have a
03:49 - position we have a size and then we have
03:52 - some groups and the arguments here are
03:55 - identical compared to the static
03:57 - obstacles so all of this is ultimately
04:00 - fairly simple code and at the end of all
04:02 - of this we have our player and we have
04:05 - the ball
04:06 - and those get predefined positions and
04:08 - sizes so all they need is all sprites to
04:11 - place both of them inside of this group
04:14 - here
04:15 - and once we have that we actually get to
04:18 - the game loop and this one is very
04:20 - simple for this project
04:22 - at the beginning we're getting delta
04:24 - time and we're using delta time in all
04:27 - sprites for the update method to update
04:30 - everything with delta time
04:32 - and once we have that we are drawing all
04:34 - of the elements on the display surface
04:36 - and before that we are filling the
04:38 - screen with a black color so we have
04:40 - some background color besides that we
04:42 - are checking for the player closing the
04:44 - window but that's pretty simple
04:46 - and we are updating the entire window so
04:51 - that we're actually drawing something
04:53 - but that's really quite simple
04:55 - nothing really complicated here
04:58 - actually now look at the classes and
05:00 - let's see what's going on here and the
05:02 - simplest one is our static obstacle
05:05 - and in here
05:07 - we have one in it method and then there
05:10 - we are defining a position a size and
05:12 - groups
05:13 - so all the stuff you could see down here
05:16 - and well it's only four lines of code we
05:19 - are using the super.init method to
05:21 - allocate the groups we are creating an
05:23 - image with the size we are filling the
05:25 - image with a color in this case yellow
05:27 - and then we are creating a rectangle and
05:29 - the top left of that rectangle is the
05:31 - position
05:32 - and that's literally it it's not a
05:34 - complicated object now besides that we
05:36 - have a moving vertical obstacle and
05:39 - moving horizontal obstacle
05:41 - and both of those
05:43 - inherit from the static obstacle so both
05:47 - of these classes
05:49 - inherit
05:51 - from this class here the one i've just
05:53 - created and since this one inherits from
05:56 - a sprite those ones become sprites as
05:58 - well
05:59 - except they already have a couple of
06:00 - basic attributes
06:02 - so let's have a look what they actually
06:04 - do
06:06 - we have the very same arguments we have
06:08 - positions size and groups and then in
06:11 - the unit method we're passing the same
06:13 - information in there
06:14 - and this happens both for moving
06:16 - vertical and moving horizontal
06:18 - as a matter of fact both of those
06:20 - classes work in basically the same way
06:22 - except they move either vertical or
06:24 - horizontally
06:25 - and i guess they have a different color
06:27 - but that's a small thing
06:29 - now for moving vertical we are filling
06:31 - the surface with a green color we are
06:34 - giving it a position a direction and a
06:37 - speed
06:38 - then for the position
06:40 - we have a vector 2 and by default the
06:43 - position is the top left of the
06:45 - rectangle
06:47 - and this position is what we are going
06:48 - to move why we don't move the rectangle
06:50 - by itself is because of delta time that
06:53 - this position is more precise which is
06:55 - what we really care about
06:57 - now besides that we have a direction
06:59 - which is a vector 2 and then we have a
07:02 - speed which in this case is 450 but it's
07:05 - basically random so we essentially
07:08 - create two vectors one for the position
07:10 - one for the direction and the speed
07:12 - that's kind of all we need
07:14 - then we have the update method and in
07:17 - here ignore this part for now the
07:20 - important bit happens down here
07:22 - essentially all we do is we get the y
07:24 - part of our position vector and towards
07:26 - that we're adding direction.y multiplied
07:29 - by speed multiplied by delta time so we
07:32 - are essentially moving it in one
07:33 - direction
07:35 - and after we have done that we are
07:37 - getting our rect position and this one
07:40 - actually creates the position of the
07:41 - sprite and for this one we're getting
07:44 - position at y and we are rounding it
07:47 - and that way we are getting the correct
07:48 - position
07:50 - if this gets complicated i have
07:51 - explained all of this in a bit more
07:53 - detail in my delta time video
07:56 - now once we have that we have these
07:58 - couple of lines of code here
08:00 - and basically all they are doing
08:03 - is
08:04 - imagine that this right now
08:07 - is the entire distance we want this
08:10 - moving vertical obstacle to move in
08:12 - and essentially what this one here does
08:15 - is
08:16 - the top part is 120 so that's 120 up
08:20 - here and the highest part is 600 so we
08:23 - are down here
08:26 - and essentially what happens in this top
08:29 - bit here
08:30 - is if the bottom of the rectangle is
08:32 - greater than 600 so if the obstacle is
08:35 - let's say down here
08:37 - and the bottom part is at let's say 605.
08:43 - if that is the case we're moving the
08:45 - bottom of the rectangle to 600 so we're
08:47 - moving this thing up by a tiny bit
08:52 - then we are updating the position
08:54 - and then we are reversing the direction
08:57 - and that way once this rectangle is
09:00 - below the bottom part it's going to
09:02 - start moving up
09:04 - and then the exact opposite happens on
09:07 - the second if statement the one down
09:09 - here
09:10 - now we are checking if the top part of
09:12 - our rectangle is smaller than 120 so we
09:15 - are up here
09:17 - and if that is the case we are moving
09:19 - the rectangle
09:20 - to 120
09:22 - and we are changing our direction again
09:24 - so this thing is moving downwards
09:27 - and that way the sprite is always going
09:28 - to move up and down and up and down
09:31 - continuously
09:32 - and that is literally the entire moving
09:36 - vertical obstacle class
09:38 - and if you understand this one
09:40 - moving horizontal obstacle works in
09:42 - exactly the same way
09:44 - except now we don't change position.y we
09:47 - change position.x
09:49 - and that way we're moving in the
09:50 - horizontal axis not in the vertical
09:52 - anymore
09:54 - but besides that this one does pretty
09:56 - much the same thing except well we have
09:58 - different numbers
10:00 - so those two classes pretty simple
10:03 - now besides that we have player and ball
10:05 - and i guess ball is the easier one of
10:07 - those two because this one doesn't do
10:09 - anything right now
10:12 - so in here we only have an indented
10:13 - method we have super done the init then
10:16 - we have an image and we're filling the
10:18 - image we're creating a rectangle
10:20 - and then we have a position a direction
10:22 - and a speed
10:23 - and for now since we're not updating any
10:25 - of this this doesn't do anything but we
10:27 - will work on that in just a bit
10:30 - now finally we have our player and this
10:34 - one is getting a touch more complex
10:37 - although not that much
10:39 - we again have an image that we're
10:41 - filling with blue we have a position
10:44 - that is in the middle of the screen
10:46 - roughly
10:47 - and we have a movement we have position
10:49 - direction and speed again
10:51 - so this is identical to all of the other
10:53 - classes
10:54 - besides that we are getting some input
10:58 - so we are checking if the player presses
11:00 - up or down to move in the vertical
11:02 - direction and if the player presses
11:04 - neither we are not moving at all
11:06 - and if the player is pressing right or
11:09 - left we're moving left or right and if
11:11 - the player presses neither of those two
11:13 - we don't move at all
11:14 - so this is getting all of the input and
11:17 - essentially what we do for the input we
11:19 - check keyboard input and we use that to
11:21 - influence the direction
11:23 - and now once we have all of that we have
11:28 - our update method and in here we are
11:30 - first checking for the input
11:33 - after we have done that we are
11:36 - normalizing the vector in these two
11:38 - lines
11:40 - and normalizing a vector
11:42 - basically means that we make sure the
11:44 - length of the vector is always one
11:47 - the idea here is that we only move up we
11:50 - would move by a unit of one
11:52 - and if we moved only right it would also
11:55 - move by a unit of one but if we move to
11:58 - the top right
11:59 - we would have a speed of 1.4
12:03 - so if we move diagonally
12:06 - this basically means we'll move faster
12:08 - and these two lines avoid all of that so
12:11 - all this really does is it makes sure
12:13 - that this 1.4 becomes a 1.
12:16 - once we have that we are again updating
12:19 - our position and this time we are
12:21 - getting just the position and we're in
12:23 - the direction the speed and delta time
12:26 - and multiplying all of them together and
12:28 - then we are setting the top left of our
12:30 - rectangle to rounded position x and
12:33 - rounded position y
12:34 - and that way our player is going to move
12:37 - so if i run all of this again
12:39 - we can move the player around and
12:41 - everything works just fine
12:45 - cool so that is a pretty good start i
12:48 - hope all of that makes sense
12:51 - so the important question now is how can
12:54 - we add collision mechanics and for that
12:57 - we do have to talk about some theory
12:59 - i'll try to keep it short
13:02 - and in here the first important thing
13:04 - you have to understand is that we have a
13:06 - separation between updating our game and
13:08 - drawing all of the elements
13:10 - so essentially before we are drawing a
13:13 - frame we first figure out where all the
13:15 - elements have to be
13:17 - and this is important because it gives
13:19 - us some leeway to place elements
13:23 - and for collisions this matters in
13:25 - particular
13:27 - so let's think about collisions in the
13:29 - real world let's say you throw a ball at
13:32 - any kind of object essentially what
13:34 - happens at some point the ball collides
13:36 - with the outer part of the object
13:38 - and the two don't really intersect with
13:41 - each other because they're both solid
13:44 - in games collisions work slightly
13:46 - differently essentially what we do in a
13:49 - game we first check if the two objects
13:52 - are overlapping with each other so if
13:54 - the ball and the other objects share
13:56 - some space
13:58 - and if that is the case
14:00 - we want to move the ball outside of the
14:04 - object
14:05 - and only once that is done we are
14:07 - actually drawing the image
14:09 - so for the player it looks like the ball
14:12 - didn't actually go inside of the object
14:14 - but what actually happened was that the
14:16 - ball went inside of the object and we
14:18 - placed it just outside of that object
14:20 - and that way we are simulating a
14:22 - collision
14:23 - and that is the first thing you really
14:25 - have to understand that we don't check
14:28 - actual collisions and then we are
14:29 - placing one element at the edge of the
14:31 - other element and to the player it looks
14:34 - like a collision but it actually isn't
14:36 - but now we have a problem and to really
14:38 - understand this problem let me give an
14:40 - example here we have a ball and an
14:43 - obstacle
14:44 - and right now they are obviously
14:46 - overlapping
14:47 - and now imagine you're the computer and
14:50 - you have to figure out where to place
14:52 - this ball
14:53 - and the problem you now have is you
14:55 - don't actually know where to place this
14:58 - because this ball could have come from
14:59 - any direction and you really have to
15:02 - know where the ball came from to place
15:04 - it on the edge because you don't know on
15:06 - which edge to place it
15:09 - and if you had the wrong edge you would
15:10 - just teleport the ball around which is
15:13 - something that can happen very very
15:14 - easily and would make your game look
15:17 - very glitchy and might even break it
15:19 - so you need to understand where the ball
15:21 - came from to place it in the right
15:23 - position after an overlap
15:26 - now to solve this problem you have a
15:29 - couple of different approaches and i'm
15:31 - going to talk about two but there are
15:34 - quite a few more
15:35 - and there's one thing both already have
15:37 - in common and that is that we are
15:39 - separating the horizontal and the
15:41 - vertical axis
15:43 - so what we are going to do we are first
15:45 - moving an object in the x direction then
15:48 - we are checking for a collision and only
15:50 - once we have done that we are moving the
15:52 - object in the y direction and then we
15:55 - are checking for the vertical collisions
15:57 - and this is already making our map
15:59 - significantly easier because we only
16:01 - have to check for a single axis
16:03 - and now inside of both of these axes we
16:06 - have to figure out where the ball came
16:09 - from
16:10 - and in the first approach we are
16:12 - checking our direction
16:14 - so essentially what we are doing imagine
16:16 - the ball is again overlapping with an
16:18 - obstacle and the ball came from the left
16:21 - and is moving to the right if that is
16:24 - the case
16:25 - you can assume quite safely that the
16:27 - ball is colliding on the left side of
16:29 - the obstacle
16:30 - and now that you know that you can place
16:32 - the ball on the left side of that
16:34 - obstacle and you're basically done and
16:36 - this you can do with all of the other
16:38 - directions as well
16:40 - and this system is totally fine it's
16:43 - really easy to implement and it works
16:45 - pretty well i have actually used it
16:47 - myself for a complex zelda game and in
16:50 - there it worked really well
16:53 - but there's one downside and that is
16:55 - that in this system you cannot check
16:57 - collisions between moving objects
17:00 - so for example in my zelda game
17:03 - we have zelda and we have the enemies
17:05 - moving around
17:06 - but these two objects do not actually
17:09 - collide so they can totally move on top
17:11 - of each other but if you had any kind of
17:14 - moving platform or anything moving that
17:16 - can be collided with this approach would
17:19 - break
17:20 - and the reason why it breaks is quite
17:22 - simple
17:24 - imagine again we have our ball and our
17:26 - obstacle
17:27 - and now we have our ball moving to the
17:29 - right and the obstacle this time is
17:32 - moving as well also to the right and
17:34 - happens to be overlapping with the ball
17:37 - now for the game's purpose we know that
17:39 - the ball is moving to the right so we
17:41 - would assume the collision is happening
17:43 - on the left of the obstacle
17:45 - but in this case this is wrong the
17:46 - collision would happen on the right side
17:48 - of the obstacle
17:50 - so we would need another kind of system
17:53 - and this system does work with both
17:55 - static and moving sprites but it is a
17:59 - tiny bit more complex
18:01 - essentially we are going to check for
18:03 - every single sprite the current position
18:06 - and the position on the previous frame
18:09 - and essentially what we are going to do
18:12 - is we are checking for each direction
18:15 - if for example the right side of a ball
18:18 - is greater or equal than the left side
18:19 - of the obstacle
18:21 - and on top of that we are also going to
18:24 - check where each of these sprites were
18:26 - in the previous frame
18:28 - and now again with the same example we
18:30 - have a ball moving to the right and we
18:32 - have an obstacle moving to the right and
18:34 - the obstacle moves a tiny bit faster
18:38 - and on the old frame the obstacle is
18:41 - just to the left of the ball and then in
18:43 - the current frame the obstacle is just
18:45 - overlapping with the ball on the left
18:47 - side
18:48 - if we have this kind of setup we know
18:50 - that in the previous frame the obstacle
18:52 - was just to the left of the ball so we
18:55 - know where the collision is going to
18:56 - happen on the left side of the ball on
18:58 - the right side of the obstacle whichever
19:00 - one you want to work with and that way
19:02 - we don't get confused by different
19:04 - directions we just check where the
19:06 - object is now and where it was in the
19:08 - last frame and that is also going to be
19:11 - the system we are going to implement
19:14 - now unfortunately this is going to be a
19:16 - tiny bit more complex because for every
19:18 - single sprite class
19:20 - we have to check the current frame and
19:22 - the previous frame although that's well
19:24 - one more line of code it really isn't
19:26 - all that bad
19:28 - and well let's implement all of this and
19:30 - let's see what we get
19:32 - here we are back in the code and for
19:35 - each of these objects i have to check
19:37 - where they are right now
19:38 - and what i wear in the previous frame
19:40 - which sounds way more complex than it
19:42 - actually is
19:44 - so let's start with the static obstacle
19:46 - this one needs one as well even though
19:48 - it doesn't move
19:49 - and essentially all i am going to do
19:52 - i'm going to give
19:54 - each of my sprites another attribute
19:57 - that i'm going to call self.all direct
20:00 - and all i'm going to do here is
20:02 - self.rect.cob
20:06 - for this one we are just going to copy
20:08 - this rectangle and since this one isn't
20:10 - moving we can just keep it like this
20:13 - but let me copy this line we are going
20:15 - to need it a bit more
20:16 - so this one already done
20:20 - now a slightly more complex one we have
20:22 - our moving vertical obstacle
20:25 - in here
20:26 - we still want to copy the rectangle
20:28 - but now we have to do something else
20:31 - that when we are updating this sprite
20:35 - all the way before we do anything else
20:38 - i want to get my old rect and copy it so
20:41 - this is the position where it is right
20:42 - now
20:44 - and after all of this code is run
20:46 - this sprite is going to be in a new
20:48 - position
20:49 - essentially what this means is that this
20:52 - is the previous
20:53 - frame
20:55 - and
20:56 - this one down here
20:58 - is going to be the current frame
21:01 - and well this is actually all we needed
21:05 - so now i can minimize
21:07 - this class here and do the same thing to
21:09 - my moving horizontal obstacle and here
21:12 - we again are going to need an old
21:14 - rectangle and we have to do the same
21:16 - thing for the update method
21:18 - and again this is pretty much the same
21:21 - thing as we have done with the vertical
21:22 - obstacle in an actual game those two
21:25 - could probably be one class i was just a
21:28 - bit lazy for this setup but alright now
21:31 - we have the player and in here let's say
21:33 - for the position
21:35 - i again want my old rectangle and copy
21:38 - it
21:39 - and then
21:40 - before i do anything else in the update
21:43 - method
21:44 - i want to get an old rectangle as well
21:47 - so again we have our previous frame and
21:50 - we have our current frame down here
21:55 - and now let me minimize the player and
21:58 - we can do the same thing
21:59 - for the ball
22:00 - we just need the old rectangle
22:03 - and now
22:04 - if we run all of this we literally
22:07 - cannot see any difference but we can
22:09 - actually visualize what we have just
22:11 - done
22:13 - before we are drawing all of the
22:15 - elements
22:16 - what i want to do is for sprite in
22:20 - all sprites dot sprites
22:23 - and i just want to draw pygame.draw.rect
22:29 - and this just means we are drawing a
22:31 - rectangle and in here i want to draw on
22:34 - the screen
22:35 - i want to draw in a color i haven't used
22:38 - yet let's go with orange
22:41 - and then sprite dot old rect
22:44 - and let's see what happens now
22:46 - so now you can see this very faint
22:50 - orange background and this is the
22:53 - previous frame
22:55 - now because of the frame rate it is kind
22:57 - of hard to see but it is definitely
22:59 - there so this previous frame very very
23:02 - small
23:04 - so at the very least we know it is
23:06 - working
23:08 - but now that we have that
23:10 - we actually have to work with the
23:12 - collisions and this let's start with the
23:14 - player
23:16 - so inside of my player i want to create
23:19 - another method and this i called
23:22 - collision
23:24 - and then here we need self and they also
23:26 - want to get a direction
23:28 - because remember we are first going to
23:30 - check the horizontal and then the
23:31 - vertical direction
23:33 - you could switch this around it really
23:35 - does not matter
23:36 - and now first of all i need all let's
23:41 - call it the collision underscore sprites
23:44 - and this essentially is going to be all
23:46 - of the sprites our players overlapping
23:48 - with
23:50 - so
23:51 - let me comment this out
23:53 - so for example if i move my player to
23:56 - the obstacle down here right now they
23:58 - are overlapping so this yellow rectangle
24:02 - here should be in my collision sprites
24:07 - and if i were to collide with multiple
24:08 - objects they should also be in there
24:10 - now pygame has an inbuilt method for
24:13 - that it is called pygame.sprite.sprite
24:17 - collide all in lowercase
24:20 - but for this to really work our player
24:23 - has to know where all of the obstacles
24:26 - are
24:26 - so what i did when i create a player
24:30 - we have another parameter
24:32 - that i called obstacles
24:35 - this is just going to be self dot
24:37 - obstacles is going to be obstacles and
24:40 - these obstacles let me minimize my
24:42 - player
24:44 - we get down here when we are initiating
24:46 - the player
24:48 - besides putting the play on all sprites
24:50 - i also want my
24:52 - collision sprites
24:54 - and the important thing here is that we
24:57 - don't put the player inside of the
24:59 - collision sprites we just give the
25:01 - collision sprites as an attribute to the
25:03 - player so the player knows where all of
25:05 - the sprites inside of this group are and
25:08 - that's all we care about
25:10 - so i hope that makes sense
25:13 - all right so now inside of the player
25:16 - we need three arguments in here we need
25:19 - a sprite we need a group and we need
25:22 - what is called do kill
25:25 - now the sprite we want to look at is
25:27 - just self spelled properly
25:29 - then the group we want to look at is
25:32 - self dot collision sprites i think i
25:36 - called it no i call it self dot
25:39 - obstacles
25:41 - and for do kill
25:42 - this should be false because i don't
25:46 - want to delete any of the sprites
25:48 - and all right
25:49 - now
25:50 - we can just print and see what we get so
25:53 - print collision sprites
25:55 - and then let's put it down here
26:00 - self dot
26:01 - collision sprites
26:04 - self dot collision
26:08 - and let's say just test it doesn't
26:10 - really matter what we put in here for
26:11 - now
26:12 - so now if we run this we get an empty
26:14 - list but if i move over something we get
26:16 - static obstacle sprite in two groups we
26:19 - get our moving horizontal sprite
26:22 - and well we know what each of these
26:24 - sprites are going to be
26:26 - so this is all we care about
26:28 - so this is already telling us if there
26:30 - is a collision over an overlap and with
26:34 - what object the overlap happens
26:37 - now
26:38 - what i want to do i first want to check
26:41 - if
26:42 - collision sprites exists in the first
26:44 - place so if there's any object inside of
26:47 - that list
26:48 - and once that is the case i want to
26:50 - check if my direction is either
26:54 - horizontal
26:56 - then i want to do something let's say
26:58 - pass for now
26:59 - and
27:00 - if my direction
27:02 - is equal to
27:04 - vertical
27:06 - and i want to do something else let's
27:07 - say pass in here for now
27:09 - and let's start working on horizontal
27:12 - although again it really doesn't matter
27:14 - which direction you start with and what
27:17 - i want to do in both of these is for
27:19 - sprite in
27:21 - collision
27:22 - sprites
27:23 - and now the question is
27:26 - is the collision on the right
27:29 - or do we have a collision on the left so
27:34 - remember we already know that there's an
27:37 - overlap and right now we are just
27:39 - checking if we're moving left or right
27:42 - so all we have to figure out from the
27:43 - player's perspective is if the collision
27:45 - happens on the right or on the left and
27:48 - then once we get to the vertical side we
27:50 - are checking if the collision is on top
27:52 - or at the bottom
27:53 - so now how can we check if the collision
27:56 - is on the right
27:57 - and in here we need two if statements or
28:00 - we need one if statements with two
28:02 - conditions the first is self.rect.right
28:06 - is greater or equal than sprite.rect.
28:12 - left
28:13 - if this one here is our player so this
28:16 - is our self and then our sprite
28:19 - rectangle
28:20 - is
28:21 - let's say this yellow thing here
28:24 - right now we know there's no collision
28:27 - and we know that because the right side
28:30 - of the player so this point here
28:33 - is let's say on position 100 and the
28:36 - left side of the obstacle is at let's
28:39 - say position 150
28:42 - now because this position
28:44 - is smaller we know there's no collision
28:47 - between these two they couldn't be
28:49 - because the right side of the player is
28:51 - too small to even touch the left side of
28:53 - the obstacle there literally cannot be
28:55 - any kind of collision
28:57 - but now
28:58 - if we have another kind of collision
29:01 - let's say now our player moved to the
29:04 - right and now looks something like this
29:08 - the right side of the player is at
29:10 - position let's say 200 and now this
29:13 - condition here
29:15 - is going to be true because the right
29:17 - side of the player is greater than the
29:19 - left side of the obstacle and as a
29:21 - consequence we know there's going to be
29:22 - a collision on one of these sides
29:25 - and let me clean this one up a tiny bit
29:28 - so i have a bit cleaner off a space
29:30 - so now we have this situation here where
29:33 - we know the right side of the player is
29:35 - greater than the left side of the
29:36 - obstacle and this means we do have a
29:39 - collision
29:40 - the problem we have right now is that
29:42 - this situation by itself
29:44 - doesn't help us to understand where the
29:46 - player is supposed to go
29:49 - so is the player supposed to go to this
29:51 - point here this point here this point
29:53 - here
29:54 - this point here or any of these other
29:56 - points we don't know where to put the
29:58 - player because we don't know where it
30:00 - came from
30:01 - and it might seem obvious to put a
30:04 - player on this side
30:06 - but that would not be a good way to
30:08 - think about it because the player might
30:10 - as well come from this direction here or
30:13 - if the player moves really fast it might
30:15 - have even come from this side
30:17 - and the collision was actually supposed
30:18 - to be here
30:20 - remember that when we just check
30:22 - initially we're just checking for an
30:24 - overlap
30:25 - so if the player moves very fast it
30:27 - might even happen that the player jumps
30:29 - over most of the obstacle so even though
30:32 - the collision is on the right side
30:33 - initially a player is more on the left
30:36 - which is also the reason why you
30:37 - couldn't check something like this
30:38 - center that's not really reliable
30:41 - but okay i hope that makes sense
30:43 - to fix all of this we are going to need
30:45 - another statement that's going to be and
30:48 - and what we're going to check in here is
30:50 - self dot alt rect
30:52 - dot
30:54 - write
30:55 - is smaller or equal than sprite dot alt
30:59 - right dot left and let me actually
31:02 - reopen this one and clean it up a tiny
31:05 - bit
31:06 - here again we are in the starting
31:08 - situation where again we are in this
31:12 - situation here
31:13 - we know there's an overlap
31:15 - but now what we're also going to check
31:18 - on top of that is
31:20 - this situation here let me use a blue
31:22 - color so this situation here we are
31:25 - basically checking in the previous frame
31:27 - if the player for example was here
31:31 - where the right side of the player so
31:33 - this bit here is smaller or equal than
31:37 - the left side
31:40 - of the obstacle
31:41 - which in practice means that the player
31:44 - in the previous frame was to the left of
31:46 - this obstacle so with these two
31:48 - conditions we know that in the previous
31:51 - frame the player was to the left of the
31:54 - obstacle and in the current frame so
31:56 - this one here we know the player is
31:58 - colliding so with these two conditions
32:01 - we know the player is colliding and did
32:03 - come from the left in the previous frame
32:06 - so once we have all of that
32:09 - we can self dot wrecked dot right
32:13 - is going to be equal to sprite dot
32:16 - rect.left
32:18 - and don't forget you also have to set
32:20 - self.pause.x
32:22 - is going to be self.direct.x
32:26 - so what have we done here let me re-open
32:29 - all of this and clean it up a tiny bit
32:31 - again
32:33 - there's a lot of drawing involved in all
32:35 - of this
32:36 - these two lines here are going to do if
32:38 - we again have our situation up here
32:40 - essentially what we want to do
32:42 - we want to move this purple rectangle to
32:46 - this position here
32:49 - where we are moving the right side of
32:52 - the player to the left side of the
32:54 - obstacle and that way it looks like the
32:57 - player is colliding with the obstacle
32:59 - and cannot go any further
33:01 - or at least that's what it looks like to
33:03 - the player but in reality we checked for
33:05 - an overlap and then we place the player
33:08 - in a certain position and then
33:10 - position.x is our actual thing we are
33:12 - moving so this always has to be in the
33:15 - top left of this rectangle
33:18 - and this is why we're updating it here
33:20 - as well
33:21 - and there is one more thing that we have
33:23 - to do
33:24 - and that happens in the update method
33:26 - here so this line right now is a problem
33:30 - because remember we first want to move
33:32 - into horizontal direction then we want
33:34 - to check the horizontal collisions
33:36 - then we want to move in the vertical
33:38 - direction and then we want to check
33:40 - collisions in the vertical direction
33:42 - so we essentially have to separate
33:45 - this movement here in an x and a y
33:48 - position
33:50 - so what that means in practice is
33:52 - ultimately fairly simple i first want to
33:54 - get myself.post.x
33:57 - plus equals self.direction.x
34:01 - multiply this with self.speed
34:04 - and then multiply this with delta time
34:06 - and now once we have that self.reg.x
34:09 - is going to be rounded self.post.x
34:13 - and now once we have done that i want to
34:16 - check myself dot
34:18 - collision and for now
34:20 - i just want to do my horizontal
34:22 - collision
34:23 - and just so we can move around with the
34:25 - player i also want to do the same thing
34:27 - here for the y position
34:29 - so
34:30 - let me copy all of this and let me
34:32 - remove these two lines entirely
34:36 - so now this should be self.pause.y
34:39 - and direction.y then rect.y and
34:43 - position.y
34:45 - and what we're going to do in just a
34:46 - second is self dot collision
34:49 - and check for vertical collisions but
34:51 - this one we don't have right now so this
34:53 - one doesn't do anything
34:55 - and well let's run the code and let's
34:57 - see what we get
34:59 - so oda could already see something is
35:00 - happening so now if i move around with
35:02 - my player
35:03 - there we have a collision
35:06 - and right now this only works on the
35:08 - right side but it does work both with
35:10 - moving
35:11 - and with static objects
35:13 - the red square right now doesn't have
35:15 - any collisions so just ignore that one
35:18 - but you can already see the problem if i
35:20 - move from any other side but the right
35:22 - side the collisions don't work
35:25 - so this we have to implement as well but
35:28 - the right side by itself works
35:29 - beautifully fine cool
35:32 - so essentially all that means is we have
35:35 - to write three more if statements for
35:38 - the left the top and the bottom
35:40 - and i would really recommend for you to
35:42 - try to figure this one out yourself so
35:45 - try to write the collision mechanic for
35:47 - the left side the top and the bottom and
35:50 - see how far you get
35:54 - let me just copy the entire if statement
35:57 - and paste it in here
36:00 - now what we want to check for this one
36:04 - is if the left side of our rectangle
36:07 - is
36:08 - smaller or equal than the right side
36:13 - of the current sprite so if i'm drawing
36:15 - all of this one out let me give a bit
36:17 - more space
36:19 - this one here is going to be our
36:21 - obstacle
36:23 - and right now what we want to check is a
36:25 - collision on this side here
36:29 - and in this if statement right now
36:33 - we basically want to check if the player
36:36 - is somewhere like here
36:38 - so if the left side of our player
36:40 - is smaller than the right side of our
36:43 - obstacle
36:45 - kind of the opposite what we have done
36:47 - in the first if statement for the right
36:48 - side
36:49 - and on top of that
36:51 - we want to check the second if statement
36:54 - and this one has to check if in the
36:56 - previous frame the left side of the
36:58 - player was further to the right than the
37:01 - right side of the obstacle
37:04 - so what that means
37:06 - is self.oldrect.left
37:10 - is greater
37:12 - or equal than the old right side of the
37:16 - rectangle
37:17 - and once we have that we are good to go
37:20 - those two lines can't stay identical
37:23 - so let's run the code
37:25 - and
37:25 - these collisions still work just fine
37:27 - now let's try the left side and they
37:29 - don't work because i made a mistake
37:32 - let's have a look but this is actually
37:34 - really good so now you can see what
37:35 - happens when you mess up the collisions
37:38 - that the player just teleports around
37:40 - which feels pretty bad well kind of
37:42 - funny but let's see what i did wrong
37:46 - like i should tell
37:47 - this line here has to change because now
37:50 - we want to change
37:51 - selfdirect.left
37:53 - has to be on the sprite.rect.right
37:57 - and now let's try this again so now left
38:00 - side still works and the right side now
38:02 - works as well
38:04 - and with the static obstacles this one
38:07 - works as well
38:08 - and this one works as well cool
38:11 - so with this we have the left and the
38:14 - right side
38:15 - nice
38:16 - so next up we have to do the same thing
38:19 - for the vertical direction and for all
38:21 - of this let me copy these couple of
38:24 - lines here
38:25 - and let me paste them in there
38:28 - and now we want to check a collision
38:30 - let's say on the
38:32 - bottom and a collision
38:34 - on the top
38:35 - and i guess let's do another round of
38:37 - drawing for the bottom part i again have
38:41 - my obstacle
38:43 - and what i now want to check is if my
38:46 - player did something like this
38:48 - where the bottom of my player is greater
38:51 - than the top of the obstacle
38:54 - and for that i need self.wrecked dot
38:58 - bottom
38:59 - is greater or equal than sprite.rect.top
39:03 - so now we know there's some kind of
39:05 - collision
39:07 - at least on this axis
39:10 - and now what i want to check if in the
39:11 - previous frame the player was above the
39:14 - obstacle
39:15 - so if all dragged dot
39:18 - bottom
39:19 - was smaller or equal this one can stay
39:22 - then all direct dot top
39:25 - and now once we have this if statement
39:28 - and this is true i want to check my
39:30 - rect.bottom
39:32 - to the top
39:34 - of the other rectangle
39:35 - and now this position x has to be
39:38 - position.y
39:40 - and this is basically all we needed
39:43 - now
39:44 - for the final if statement let's do this
39:46 - a bit faster
39:48 - we want to check if the top of my
39:49 - rectangle is smaller equal than the
39:52 - bottom of the obstacle
39:55 - and if the old top part of the player
39:59 - was greater so below
40:01 - than the bottom
40:03 - of the obstacle and if that is the case
40:07 - i want to set the top of the player to
40:09 - the bottom
40:11 - of the obstacle and then again we want
40:13 - to check position and rect.y
40:17 - and with that
40:19 - let me fix this typo with that we should
40:22 - be done let's check this
40:24 - now our player
40:26 - can't move inside of this purple
40:29 - rectangle anymore because we are being
40:31 - moved along with it
40:33 - i can't also move inside of any of these
40:37 - objects here
40:39 - and let's check the green rectangle and
40:41 - this one works perfectly fine as well
40:44 - cool
40:45 - so let's try the top side
40:48 - and yeah this is working really nicely
40:52 - so with that
40:55 - we have a basic collision mechanic so
40:58 - this one is working really really nicely
41:01 - and i guess now that we have that
41:04 - let's minimize the player
41:07 - let's move some white space
41:09 - and now we can do the same thing for the
41:12 - ball
41:13 - and this could be a pretty good exercise
41:14 - for you so from the stuff you have just
41:17 - learned
41:18 - try to make the ball bounce around the
41:20 - game window and make it collide with the
41:23 - player with the obstacles both the
41:25 - static and the moving ones
41:27 - and this should take you some time but
41:30 - try to implement this one
41:34 - first of all
41:36 - we need to create an update method that
41:40 - needs self and delta time
41:43 - and in here i am going to steal quite a
41:46 - bit from the player because well it
41:48 - doesn't make sense
41:50 - so we can take all of this actually all
41:53 - of this from the player
41:54 - so let's copy all of this into our new
41:57 - update method
41:58 - and the one thing i don't need for this
42:00 - one is the input because the ball
42:02 - doesn't have any input
42:04 - we essentially just give it a starting
42:05 - vector and then change the direction
42:07 - whenever it collides with anything
42:10 - and now we are going to need
42:12 - two more methods the first one is going
42:15 - to be collision and this one itself and
42:18 - direction
42:19 - let's copy this one straight from the
42:21 - player again because we're going to
42:23 - reuse quite a bit
42:25 - so i'm going to copy
42:26 - all of this here
42:28 - and paste it inside of the collision
42:31 - method
42:32 - so quite a long method but i hope you
42:35 - understand it
42:36 - now we do have a problem and let me go
42:39 - to the init method and let me minimize
42:41 - the collision method
42:43 - this ball right now
42:45 - doesn't know whatever of the obstacle or
42:48 - where the player is so we have to tell
42:50 - it that
42:51 - and for that i created two new
42:54 - parameters when we initiate this class
42:56 - obstacles and layer
42:59 - and let me add them right at the bottom
43:02 - so we have self dot obstacles is going
43:05 - to be obstacles and self.player
43:09 - is going to be
43:10 - player and now when we are creating this
43:14 - ball
43:15 - i first want to insert my collision
43:18 - sprites
43:20 - and besides that i also need the player
43:22 - but right now i don't have access to the
43:24 - player so i'm going to place this in a
43:27 - separate variable
43:28 - and then this variable i'm going to
43:30 - place inside of the ball
43:34 - so
43:34 - now our ball is going to know
43:38 - let me minimize the player we don't need
43:40 - it anymore so now our ball is going to
43:42 - know where the obstacles are and where
43:44 - the player is
43:46 - and now let's actually run this and
43:48 - let's see what happens so now the ball
43:50 - is colliding but well you can see two
43:53 - problems actually
43:54 - the first one
43:56 - is that
43:57 - when the ball collided
43:59 - here with this object it didn't change
44:01 - the direction so it just went like this
44:04 - then shimmy along the side and then went
44:06 - down
44:07 - and the second problem is that it just
44:09 - left the screen so it went down here so
44:12 - these two things we have to work on
44:15 - and both of these things aren't terribly
44:17 - complicated
44:19 - i guess let's start on changing the
44:22 - direction
44:23 - essentially what we want to do
44:27 - if our ball collides on the horizontal
44:31 - axis
44:32 - we want to self.direction.x
44:35 - and
44:36 - multiply equal this with minus one
44:39 - so at a plus one we become a minus one
44:42 - so this way i have to copy this to both
44:45 - of these
44:47 - we would change our direction if the
44:49 - ball is colliding in this direction
44:51 - and we have to do the same thing for the
44:53 - vertical axis except now it's direction
44:56 - dot y
44:58 - and now let's try this again
45:01 - and this is working better
45:05 - but we do have to work on the window
45:07 - itself and that one shouldn't be too
45:10 - hard as a matter of fact
45:12 - if you understand this logic here
45:15 - figuring out the window logic shouldn't
45:17 - be too hard
45:19 - but well
45:21 - let's do it together
45:22 - so
45:23 - i want another method and i call this
45:26 - one
45:27 - the window
45:29 - collision
45:31 - and here we need self and i also want to
45:34 - have a direction
45:36 - and basically what i want to do after we
45:39 - have run all of this
45:41 - i also want self dot
45:43 - window collision
45:45 - and this one should also be horizontal
45:48 - and then i can copy all of this
45:50 - and do the same thing for the vertical
45:53 - collision
45:54 - so we essentially have two different
45:56 - kinds of collision except the window
45:58 - collision is going to be fairly simple
46:01 - basically all we are going to do in here
46:03 - is if the direction is equal to
46:06 - horizontal
46:09 - and if that is the case if
46:12 - self.rect.left is smaller than zero
46:16 - which means that our ball is moving to
46:18 - the left side of the window
46:21 - if that is the case i want to set
46:23 - self.rect.left
46:25 - to
46:26 - zero i have to update the position as
46:29 - well so self.post.x
46:31 - is going to be self.rect.x
46:35 - and finally self.direction.x
46:39 - i want to again multiply equal with
46:41 - minus one
46:42 - so we are changing our direction
46:46 - and now we just have to do the same
46:47 - thing for the right side of the window
46:50 - so
46:51 - right dot right and in my case my window
46:54 - is 1280 pixels wide
46:57 - although in a real game you would store
46:59 - this variable somewhere separately so
47:01 - you can access it a bit more easily and
47:03 - the game is a bit more flexible but in
47:05 - my case i don't care about that
47:08 - now if that is the case
47:10 - self.rect.right
47:11 - should also be 1280
47:14 - and this one is still fine so now let's
47:17 - try this one and
47:19 - something about weird
47:21 - and the problem here is
47:23 - self.direct.right
47:24 - should be
47:25 - greater than 1280. now let's try this
47:28 - so now we have a collision with the
47:31 - right side but not with the top so at
47:33 - least something is working
47:35 - and well basically all we have to do is
47:38 - copy
47:39 - all of this here
47:41 - and change the direction to
47:43 - vertical
47:45 - and now we want to check if rect.top
47:48 - is smaller than zero and if that is the
47:50 - case you want to set the top to zero and
47:53 - then position dot y
47:56 - is going to be rec dot y
47:58 - and direction not y we multiplied with
48:00 - negative one so we are reversing the
48:02 - direction
48:04 - and for the final one self direct bottom
48:07 - is greater than 720
48:10 - and if that one is the case
48:12 - then
48:13 - self.rec.bottom
48:15 - is going to be equal to 720
48:17 - and finally we have to change all of the
48:20 - axes to a y
48:23 - and now let's try all of this again
48:26 - this one is working this one is working
48:28 - this one is working as well we don't
48:30 - have player collisions yet that's going
48:31 - to come in a second but besides that
48:34 - things are looking pretty good
48:38 - okay cool now the final thing
48:42 - we have to address is the collision
48:44 - between our player and the ball
48:46 - and this is going to happen inside of
48:48 - collisions let me minimize
48:51 - all of the other methods so it's a bit
48:53 - easier to see what's going on
48:55 - the problem we have right now
48:57 - that our collision sprites
48:59 - just checks for the obstacles so we
49:02 - don't check for any collision with the
49:04 - player
49:06 - and well we just have to add two more
49:09 - lines here to fix that
49:11 - and basically what i want to check if
49:13 - self dot wrecked dot collide rect
49:18 - so if the current rectangle of the ball
49:20 - is colliding with self.player.rect
49:25 - and this is a very simple
49:28 - i should spell it correctly this is a
49:30 - very simple
49:31 - wreck collision method that just checks
49:34 - if two rectangles are overlapping that's
49:36 - all we're trying to do here so this is
49:39 - basically telling us if the rectangle of
49:41 - the ball is overlapping with the
49:42 - rectangle of the player
49:45 - and if that one is the case
49:48 - we want to collision sprites dot append
49:51 - self dot player
49:54 - and now let's try this again
49:57 - and now let's try to get it and yeah
50:00 - this is working just fine
50:03 - hope i can get the ball again the ball
50:05 - is moving quite fast so it's a bit
50:06 - difficult to get it
50:10 - okay uh well i hope you get the idea uh
50:13 - there we go there yeah so this seems to
50:15 - be working just fine
50:17 - cool
50:19 - and well with that we are pretty much
50:22 - done
50:23 - now before i finish this video
50:25 - there are two i wouldn't call it bugs
50:28 - but two things we don't really cover in
50:31 - this kind of logic and to fix this we
50:33 - would need quite a bit more code so i'm
50:35 - kind of going to ignore them but let me
50:38 - visualize what the problem here is right
50:39 - now
50:40 - let's say i'm going to move my player
50:43 - exactly in this in wait a second in this
50:46 - position here
50:47 - now you can see that
50:53 - we get kind of a bug that the player is
50:57 - pushed through the yellow rectangle
51:00 - and the reason for that is that this
51:02 - green rectangle is just pushing the
51:04 - player and that is overwriting this
51:05 - collision here
51:08 - and the other problem we have here is if
51:11 - our ball is colliding with any of the
51:12 - moving obstacles
51:14 - it's kind of hard to see right now
51:16 - i'm probably going to add some kind of
51:18 - video to explain it a bit better because
51:20 - it only happens sometimes
51:22 - the basic problem is
51:24 - if the ball is being pushed down by
51:27 - another moving obstacle so for example
51:29 - the ball is being pushed down
51:31 - we get kind of a random direction
51:34 - because every time these two collide
51:36 - the vertical or the horizontal direction
51:39 - of the ball is being reversed
51:40 - so if they collide once on one frame
51:43 - we get one collision and then a change
51:45 - in direction but if they collide again
51:47 - on the next frame we get the same thing
51:49 - again so the direction changes again and
51:52 - this happens probably hundreds of times
51:54 - if the ball is being pushed down or up
51:56 - or left or right and as a consequence we
51:59 - get kind of a random direction
52:00 - afterwards
52:02 - and you could add a lot more code to
52:04 - account for these cases
52:06 - although another thing you could be
52:07 - doing is design your levels in such a
52:09 - way that this problem doesn't even come
52:11 - about so for example if you have moving
52:13 - platforms in the game
52:15 - make sure these platforms can never
52:16 - squash the player between themselves and
52:19 - another kind of object
52:22 - or if you have something bouncing around
52:24 - make sure you work with the directions
52:26 - to address all of this that there
52:27 - couldn't be a bug
52:29 - so just keep these things in mind but
52:31 - well i hope this video was helpful and i
52:33 - will see you around

Cleaned transcript:

hello there in this tutorial we are going to be talking about collisions and pygame and specifically we are going to create a project you can see on the screen right now and the really important thing i'm going to cover in this tutorial are the collisions between moving and static objects as well as the collisions between two moving objects which can be quite a hassle if you don't know how to think about it so this is what i'm really going to focus on in this tutorial and understanding the logic behind collisions is fundamental to make more complex games like zelda or mario game that i created on this channel they both use collision mechanics quite extensively and there isn't really that much else to talk about so let's jump straight in and the first thing just to save some time i have already created a basic project so for this section i want to talk about the project setup and once we have that i'll talk about collision logic but let's have a look in the code what we already have so here we have the project already it's not the shortest thing ever we have nearly 150 lines of code but it really isn't that bad i'll explain all of this in just a second but if i run this project so far here is the project you have seen in the intro except we don't have any collisions so the blue rectangle here is my player i can move it around and nothing happens and in the same logic the red square is supposed to be a ball that moves around right now it's just static without any collisions so we can move around but we can't really do anything other than that and well we are going to add collisions in just a bit but let's first talk through this entire project now all the way at the top we are importing pygame sys and time high game and cis are the basic things you need for pie game and time is going to be used for delta time that we're using down here to make the entire project frame rate independent if you don't know what that means check out this video in fact if you're new to pygame and you feel all of this is too complex check out this video it's explaining the entire module in quite some detail and i will assume that you already know basic pygame after the import we have five classes we have static obstacle moving vertical obstacle moving horizontal obstacle player and ball and i'm not going to go over them for now just assume they do what the name implies i will explain them in just a second for now just assume they work now once we have that we have a general setup with pygmy.init and we are creating a display surface nothing complicated so far then we have a group setup and in here we have all sprites and collision sprites and all sprites is for literally every single sprite we are going to create and this one is going to draw and update every single sprite collision sprites are for all the obstacles that the player is supposed to be able to collide with or well the player and the ball so this group here is literally just to figure out which sprites are supposed to be collided with and which ones aren't it doesn't really do anything besides that and once we have the groups we can create some sprites and in here we have seven sprites in total we first create three static obstacles and really all we're doing in here we are creating a position a size and then which groups this sprite is going to be in so all of the static obstacles are in all sprites and in collision sprites after that we have our moving obstacles and they work in the same way we have a position we have a size and then we have some groups and the arguments here are identical compared to the static obstacles so all of this is ultimately fairly simple code and at the end of all of this we have our player and we have the ball and those get predefined positions and sizes so all they need is all sprites to place both of them inside of this group here and once we have that we actually get to the game loop and this one is very simple for this project at the beginning we're getting delta time and we're using delta time in all sprites for the update method to update everything with delta time and once we have that we are drawing all of the elements on the display surface and before that we are filling the screen with a black color so we have some background color besides that we are checking for the player closing the window but that's pretty simple and we are updating the entire window so that we're actually drawing something but that's really quite simple nothing really complicated here actually now look at the classes and let's see what's going on here and the simplest one is our static obstacle and in here we have one in it method and then there we are defining a position a size and groups so all the stuff you could see down here and well it's only four lines of code we are using the super.init method to allocate the groups we are creating an image with the size we are filling the image with a color in this case yellow and then we are creating a rectangle and the top left of that rectangle is the position and that's literally it it's not a complicated object now besides that we have a moving vertical obstacle and moving horizontal obstacle and both of those inherit from the static obstacle so both of these classes inherit from this class here the one i've just created and since this one inherits from a sprite those ones become sprites as well except they already have a couple of basic attributes so let's have a look what they actually do we have the very same arguments we have positions size and groups and then in the unit method we're passing the same information in there and this happens both for moving vertical and moving horizontal as a matter of fact both of those classes work in basically the same way except they move either vertical or horizontally and i guess they have a different color but that's a small thing now for moving vertical we are filling the surface with a green color we are giving it a position a direction and a speed then for the position we have a vector 2 and by default the position is the top left of the rectangle and this position is what we are going to move why we don't move the rectangle by itself is because of delta time that this position is more precise which is what we really care about now besides that we have a direction which is a vector 2 and then we have a speed which in this case is 450 but it's basically random so we essentially create two vectors one for the position one for the direction and the speed that's kind of all we need then we have the update method and in here ignore this part for now the important bit happens down here essentially all we do is we get the y part of our position vector and towards that we're adding direction.y multiplied by speed multiplied by delta time so we are essentially moving it in one direction and after we have done that we are getting our rect position and this one actually creates the position of the sprite and for this one we're getting position at y and we are rounding it and that way we are getting the correct position if this gets complicated i have explained all of this in a bit more detail in my delta time video now once we have that we have these couple of lines of code here and basically all they are doing is imagine that this right now is the entire distance we want this moving vertical obstacle to move in and essentially what this one here does is the top part is 120 so that's 120 up here and the highest part is 600 so we are down here and essentially what happens in this top bit here is if the bottom of the rectangle is greater than 600 so if the obstacle is let's say down here and the bottom part is at let's say 605. if that is the case we're moving the bottom of the rectangle to 600 so we're moving this thing up by a tiny bit then we are updating the position and then we are reversing the direction and that way once this rectangle is below the bottom part it's going to start moving up and then the exact opposite happens on the second if statement the one down here now we are checking if the top part of our rectangle is smaller than 120 so we are up here and if that is the case we are moving the rectangle to 120 and we are changing our direction again so this thing is moving downwards and that way the sprite is always going to move up and down and up and down continuously and that is literally the entire moving vertical obstacle class and if you understand this one moving horizontal obstacle works in exactly the same way except now we don't change position.y we change position.x and that way we're moving in the horizontal axis not in the vertical anymore but besides that this one does pretty much the same thing except well we have different numbers so those two classes pretty simple now besides that we have player and ball and i guess ball is the easier one of those two because this one doesn't do anything right now so in here we only have an indented method we have super done the init then we have an image and we're filling the image we're creating a rectangle and then we have a position a direction and a speed and for now since we're not updating any of this this doesn't do anything but we will work on that in just a bit now finally we have our player and this one is getting a touch more complex although not that much we again have an image that we're filling with blue we have a position that is in the middle of the screen roughly and we have a movement we have position direction and speed again so this is identical to all of the other classes besides that we are getting some input so we are checking if the player presses up or down to move in the vertical direction and if the player presses neither we are not moving at all and if the player is pressing right or left we're moving left or right and if the player presses neither of those two we don't move at all so this is getting all of the input and essentially what we do for the input we check keyboard input and we use that to influence the direction and now once we have all of that we have our update method and in here we are first checking for the input after we have done that we are normalizing the vector in these two lines and normalizing a vector basically means that we make sure the length of the vector is always one the idea here is that we only move up we would move by a unit of one and if we moved only right it would also move by a unit of one but if we move to the top right we would have a speed of 1.4 so if we move diagonally this basically means we'll move faster and these two lines avoid all of that so all this really does is it makes sure that this 1.4 becomes a 1. once we have that we are again updating our position and this time we are getting just the position and we're in the direction the speed and delta time and multiplying all of them together and then we are setting the top left of our rectangle to rounded position x and rounded position y and that way our player is going to move so if i run all of this again we can move the player around and everything works just fine cool so that is a pretty good start i hope all of that makes sense so the important question now is how can we add collision mechanics and for that we do have to talk about some theory i'll try to keep it short and in here the first important thing you have to understand is that we have a separation between updating our game and drawing all of the elements so essentially before we are drawing a frame we first figure out where all the elements have to be and this is important because it gives us some leeway to place elements and for collisions this matters in particular so let's think about collisions in the real world let's say you throw a ball at any kind of object essentially what happens at some point the ball collides with the outer part of the object and the two don't really intersect with each other because they're both solid in games collisions work slightly differently essentially what we do in a game we first check if the two objects are overlapping with each other so if the ball and the other objects share some space and if that is the case we want to move the ball outside of the object and only once that is done we are actually drawing the image so for the player it looks like the ball didn't actually go inside of the object but what actually happened was that the ball went inside of the object and we placed it just outside of that object and that way we are simulating a collision and that is the first thing you really have to understand that we don't check actual collisions and then we are placing one element at the edge of the other element and to the player it looks like a collision but it actually isn't but now we have a problem and to really understand this problem let me give an example here we have a ball and an obstacle and right now they are obviously overlapping and now imagine you're the computer and you have to figure out where to place this ball and the problem you now have is you don't actually know where to place this because this ball could have come from any direction and you really have to know where the ball came from to place it on the edge because you don't know on which edge to place it and if you had the wrong edge you would just teleport the ball around which is something that can happen very very easily and would make your game look very glitchy and might even break it so you need to understand where the ball came from to place it in the right position after an overlap now to solve this problem you have a couple of different approaches and i'm going to talk about two but there are quite a few more and there's one thing both already have in common and that is that we are separating the horizontal and the vertical axis so what we are going to do we are first moving an object in the x direction then we are checking for a collision and only once we have done that we are moving the object in the y direction and then we are checking for the vertical collisions and this is already making our map significantly easier because we only have to check for a single axis and now inside of both of these axes we have to figure out where the ball came from and in the first approach we are checking our direction so essentially what we are doing imagine the ball is again overlapping with an obstacle and the ball came from the left and is moving to the right if that is the case you can assume quite safely that the ball is colliding on the left side of the obstacle and now that you know that you can place the ball on the left side of that obstacle and you're basically done and this you can do with all of the other directions as well and this system is totally fine it's really easy to implement and it works pretty well i have actually used it myself for a complex zelda game and in there it worked really well but there's one downside and that is that in this system you cannot check collisions between moving objects so for example in my zelda game we have zelda and we have the enemies moving around but these two objects do not actually collide so they can totally move on top of each other but if you had any kind of moving platform or anything moving that can be collided with this approach would break and the reason why it breaks is quite simple imagine again we have our ball and our obstacle and now we have our ball moving to the right and the obstacle this time is moving as well also to the right and happens to be overlapping with the ball now for the game's purpose we know that the ball is moving to the right so we would assume the collision is happening on the left of the obstacle but in this case this is wrong the collision would happen on the right side of the obstacle so we would need another kind of system and this system does work with both static and moving sprites but it is a tiny bit more complex essentially we are going to check for every single sprite the current position and the position on the previous frame and essentially what we are going to do is we are checking for each direction if for example the right side of a ball is greater or equal than the left side of the obstacle and on top of that we are also going to check where each of these sprites were in the previous frame and now again with the same example we have a ball moving to the right and we have an obstacle moving to the right and the obstacle moves a tiny bit faster and on the old frame the obstacle is just to the left of the ball and then in the current frame the obstacle is just overlapping with the ball on the left side if we have this kind of setup we know that in the previous frame the obstacle was just to the left of the ball so we know where the collision is going to happen on the left side of the ball on the right side of the obstacle whichever one you want to work with and that way we don't get confused by different directions we just check where the object is now and where it was in the last frame and that is also going to be the system we are going to implement now unfortunately this is going to be a tiny bit more complex because for every single sprite class we have to check the current frame and the previous frame although that's well one more line of code it really isn't all that bad and well let's implement all of this and let's see what we get here we are back in the code and for each of these objects i have to check where they are right now and what i wear in the previous frame which sounds way more complex than it actually is so let's start with the static obstacle this one needs one as well even though it doesn't move and essentially all i am going to do i'm going to give each of my sprites another attribute that i'm going to call self.all direct and all i'm going to do here is self.rect.cob for this one we are just going to copy this rectangle and since this one isn't moving we can just keep it like this but let me copy this line we are going to need it a bit more so this one already done now a slightly more complex one we have our moving vertical obstacle in here we still want to copy the rectangle but now we have to do something else that when we are updating this sprite all the way before we do anything else i want to get my old rect and copy it so this is the position where it is right now and after all of this code is run this sprite is going to be in a new position essentially what this means is that this is the previous frame and this one down here is going to be the current frame and well this is actually all we needed so now i can minimize this class here and do the same thing to my moving horizontal obstacle and here we again are going to need an old rectangle and we have to do the same thing for the update method and again this is pretty much the same thing as we have done with the vertical obstacle in an actual game those two could probably be one class i was just a bit lazy for this setup but alright now we have the player and in here let's say for the position i again want my old rectangle and copy it and then before i do anything else in the update method i want to get an old rectangle as well so again we have our previous frame and we have our current frame down here and now let me minimize the player and we can do the same thing for the ball we just need the old rectangle and now if we run all of this we literally cannot see any difference but we can actually visualize what we have just done before we are drawing all of the elements what i want to do is for sprite in all sprites dot sprites and i just want to draw pygame.draw.rect and this just means we are drawing a rectangle and in here i want to draw on the screen i want to draw in a color i haven't used yet let's go with orange and then sprite dot old rect and let's see what happens now so now you can see this very faint orange background and this is the previous frame now because of the frame rate it is kind of hard to see but it is definitely there so this previous frame very very small so at the very least we know it is working but now that we have that we actually have to work with the collisions and this let's start with the player so inside of my player i want to create another method and this i called collision and then here we need self and they also want to get a direction because remember we are first going to check the horizontal and then the vertical direction you could switch this around it really does not matter and now first of all i need all let's call it the collision underscore sprites and this essentially is going to be all of the sprites our players overlapping with so let me comment this out so for example if i move my player to the obstacle down here right now they are overlapping so this yellow rectangle here should be in my collision sprites and if i were to collide with multiple objects they should also be in there now pygame has an inbuilt method for that it is called pygame.sprite.sprite collide all in lowercase but for this to really work our player has to know where all of the obstacles are so what i did when i create a player we have another parameter that i called obstacles this is just going to be self dot obstacles is going to be obstacles and these obstacles let me minimize my player we get down here when we are initiating the player besides putting the play on all sprites i also want my collision sprites and the important thing here is that we don't put the player inside of the collision sprites we just give the collision sprites as an attribute to the player so the player knows where all of the sprites inside of this group are and that's all we care about so i hope that makes sense all right so now inside of the player we need three arguments in here we need a sprite we need a group and we need what is called do kill now the sprite we want to look at is just self spelled properly then the group we want to look at is self dot collision sprites i think i called it no i call it self dot obstacles and for do kill this should be false because i don't want to delete any of the sprites and all right now we can just print and see what we get so print collision sprites and then let's put it down here self dot collision sprites self dot collision and let's say just test it doesn't really matter what we put in here for now so now if we run this we get an empty list but if i move over something we get static obstacle sprite in two groups we get our moving horizontal sprite and well we know what each of these sprites are going to be so this is all we care about so this is already telling us if there is a collision over an overlap and with what object the overlap happens now what i want to do i first want to check if collision sprites exists in the first place so if there's any object inside of that list and once that is the case i want to check if my direction is either horizontal then i want to do something let's say pass for now and if my direction is equal to vertical and i want to do something else let's say pass in here for now and let's start working on horizontal although again it really doesn't matter which direction you start with and what i want to do in both of these is for sprite in collision sprites and now the question is is the collision on the right or do we have a collision on the left so remember we already know that there's an overlap and right now we are just checking if we're moving left or right so all we have to figure out from the player's perspective is if the collision happens on the right or on the left and then once we get to the vertical side we are checking if the collision is on top or at the bottom so now how can we check if the collision is on the right and in here we need two if statements or we need one if statements with two conditions the first is self.rect.right is greater or equal than sprite.rect. left if this one here is our player so this is our self and then our sprite rectangle is let's say this yellow thing here right now we know there's no collision and we know that because the right side of the player so this point here is let's say on position 100 and the left side of the obstacle is at let's say position 150 now because this position is smaller we know there's no collision between these two they couldn't be because the right side of the player is too small to even touch the left side of the obstacle there literally cannot be any kind of collision but now if we have another kind of collision let's say now our player moved to the right and now looks something like this the right side of the player is at position let's say 200 and now this condition here is going to be true because the right side of the player is greater than the left side of the obstacle and as a consequence we know there's going to be a collision on one of these sides and let me clean this one up a tiny bit so i have a bit cleaner off a space so now we have this situation here where we know the right side of the player is greater than the left side of the obstacle and this means we do have a collision the problem we have right now is that this situation by itself doesn't help us to understand where the player is supposed to go so is the player supposed to go to this point here this point here this point here this point here or any of these other points we don't know where to put the player because we don't know where it came from and it might seem obvious to put a player on this side but that would not be a good way to think about it because the player might as well come from this direction here or if the player moves really fast it might have even come from this side and the collision was actually supposed to be here remember that when we just check initially we're just checking for an overlap so if the player moves very fast it might even happen that the player jumps over most of the obstacle so even though the collision is on the right side initially a player is more on the left which is also the reason why you couldn't check something like this center that's not really reliable but okay i hope that makes sense to fix all of this we are going to need another statement that's going to be and and what we're going to check in here is self dot alt rect dot write is smaller or equal than sprite dot alt right dot left and let me actually reopen this one and clean it up a tiny bit here again we are in the starting situation where again we are in this situation here we know there's an overlap but now what we're also going to check on top of that is this situation here let me use a blue color so this situation here we are basically checking in the previous frame if the player for example was here where the right side of the player so this bit here is smaller or equal than the left side of the obstacle which in practice means that the player in the previous frame was to the left of this obstacle so with these two conditions we know that in the previous frame the player was to the left of the obstacle and in the current frame so this one here we know the player is colliding so with these two conditions we know the player is colliding and did come from the left in the previous frame so once we have all of that we can self dot wrecked dot right is going to be equal to sprite dot rect.left and don't forget you also have to set self.pause.x is going to be self.direct.x so what have we done here let me reopen all of this and clean it up a tiny bit again there's a lot of drawing involved in all of this these two lines here are going to do if we again have our situation up here essentially what we want to do we want to move this purple rectangle to this position here where we are moving the right side of the player to the left side of the obstacle and that way it looks like the player is colliding with the obstacle and cannot go any further or at least that's what it looks like to the player but in reality we checked for an overlap and then we place the player in a certain position and then position.x is our actual thing we are moving so this always has to be in the top left of this rectangle and this is why we're updating it here as well and there is one more thing that we have to do and that happens in the update method here so this line right now is a problem because remember we first want to move into horizontal direction then we want to check the horizontal collisions then we want to move in the vertical direction and then we want to check collisions in the vertical direction so we essentially have to separate this movement here in an x and a y position so what that means in practice is ultimately fairly simple i first want to get myself.post.x plus equals self.direction.x multiply this with self.speed and then multiply this with delta time and now once we have that self.reg.x is going to be rounded self.post.x and now once we have done that i want to check myself dot collision and for now i just want to do my horizontal collision and just so we can move around with the player i also want to do the same thing here for the y position so let me copy all of this and let me remove these two lines entirely so now this should be self.pause.y and direction.y then rect.y and position.y and what we're going to do in just a second is self dot collision and check for vertical collisions but this one we don't have right now so this one doesn't do anything and well let's run the code and let's see what we get so oda could already see something is happening so now if i move around with my player there we have a collision and right now this only works on the right side but it does work both with moving and with static objects the red square right now doesn't have any collisions so just ignore that one but you can already see the problem if i move from any other side but the right side the collisions don't work so this we have to implement as well but the right side by itself works beautifully fine cool so essentially all that means is we have to write three more if statements for the left the top and the bottom and i would really recommend for you to try to figure this one out yourself so try to write the collision mechanic for the left side the top and the bottom and see how far you get let me just copy the entire if statement and paste it in here now what we want to check for this one is if the left side of our rectangle is smaller or equal than the right side of the current sprite so if i'm drawing all of this one out let me give a bit more space this one here is going to be our obstacle and right now what we want to check is a collision on this side here and in this if statement right now we basically want to check if the player is somewhere like here so if the left side of our player is smaller than the right side of our obstacle kind of the opposite what we have done in the first if statement for the right side and on top of that we want to check the second if statement and this one has to check if in the previous frame the left side of the player was further to the right than the right side of the obstacle so what that means is self.oldrect.left is greater or equal than the old right side of the rectangle and once we have that we are good to go those two lines can't stay identical so let's run the code and these collisions still work just fine now let's try the left side and they don't work because i made a mistake let's have a look but this is actually really good so now you can see what happens when you mess up the collisions that the player just teleports around which feels pretty bad well kind of funny but let's see what i did wrong like i should tell this line here has to change because now we want to change selfdirect.left has to be on the sprite.rect.right and now let's try this again so now left side still works and the right side now works as well and with the static obstacles this one works as well and this one works as well cool so with this we have the left and the right side nice so next up we have to do the same thing for the vertical direction and for all of this let me copy these couple of lines here and let me paste them in there and now we want to check a collision let's say on the bottom and a collision on the top and i guess let's do another round of drawing for the bottom part i again have my obstacle and what i now want to check is if my player did something like this where the bottom of my player is greater than the top of the obstacle and for that i need self.wrecked dot bottom is greater or equal than sprite.rect.top so now we know there's some kind of collision at least on this axis and now what i want to check if in the previous frame the player was above the obstacle so if all dragged dot bottom was smaller or equal this one can stay then all direct dot top and now once we have this if statement and this is true i want to check my rect.bottom to the top of the other rectangle and now this position x has to be position.y and this is basically all we needed now for the final if statement let's do this a bit faster we want to check if the top of my rectangle is smaller equal than the bottom of the obstacle and if the old top part of the player was greater so below than the bottom of the obstacle and if that is the case i want to set the top of the player to the bottom of the obstacle and then again we want to check position and rect.y and with that let me fix this typo with that we should be done let's check this now our player can't move inside of this purple rectangle anymore because we are being moved along with it i can't also move inside of any of these objects here and let's check the green rectangle and this one works perfectly fine as well cool so let's try the top side and yeah this is working really nicely so with that we have a basic collision mechanic so this one is working really really nicely and i guess now that we have that let's minimize the player let's move some white space and now we can do the same thing for the ball and this could be a pretty good exercise for you so from the stuff you have just learned try to make the ball bounce around the game window and make it collide with the player with the obstacles both the static and the moving ones and this should take you some time but try to implement this one first of all we need to create an update method that needs self and delta time and in here i am going to steal quite a bit from the player because well it doesn't make sense so we can take all of this actually all of this from the player so let's copy all of this into our new update method and the one thing i don't need for this one is the input because the ball doesn't have any input we essentially just give it a starting vector and then change the direction whenever it collides with anything and now we are going to need two more methods the first one is going to be collision and this one itself and direction let's copy this one straight from the player again because we're going to reuse quite a bit so i'm going to copy all of this here and paste it inside of the collision method so quite a long method but i hope you understand it now we do have a problem and let me go to the init method and let me minimize the collision method this ball right now doesn't know whatever of the obstacle or where the player is so we have to tell it that and for that i created two new parameters when we initiate this class obstacles and layer and let me add them right at the bottom so we have self dot obstacles is going to be obstacles and self.player is going to be player and now when we are creating this ball i first want to insert my collision sprites and besides that i also need the player but right now i don't have access to the player so i'm going to place this in a separate variable and then this variable i'm going to place inside of the ball so now our ball is going to know let me minimize the player we don't need it anymore so now our ball is going to know where the obstacles are and where the player is and now let's actually run this and let's see what happens so now the ball is colliding but well you can see two problems actually the first one is that when the ball collided here with this object it didn't change the direction so it just went like this then shimmy along the side and then went down and the second problem is that it just left the screen so it went down here so these two things we have to work on and both of these things aren't terribly complicated i guess let's start on changing the direction essentially what we want to do if our ball collides on the horizontal axis we want to self.direction.x and multiply equal this with minus one so at a plus one we become a minus one so this way i have to copy this to both of these we would change our direction if the ball is colliding in this direction and we have to do the same thing for the vertical axis except now it's direction dot y and now let's try this again and this is working better but we do have to work on the window itself and that one shouldn't be too hard as a matter of fact if you understand this logic here figuring out the window logic shouldn't be too hard but well let's do it together so i want another method and i call this one the window collision and here we need self and i also want to have a direction and basically what i want to do after we have run all of this i also want self dot window collision and this one should also be horizontal and then i can copy all of this and do the same thing for the vertical collision so we essentially have two different kinds of collision except the window collision is going to be fairly simple basically all we are going to do in here is if the direction is equal to horizontal and if that is the case if self.rect.left is smaller than zero which means that our ball is moving to the left side of the window if that is the case i want to set self.rect.left to zero i have to update the position as well so self.post.x is going to be self.rect.x and finally self.direction.x i want to again multiply equal with minus one so we are changing our direction and now we just have to do the same thing for the right side of the window so right dot right and in my case my window is 1280 pixels wide although in a real game you would store this variable somewhere separately so you can access it a bit more easily and the game is a bit more flexible but in my case i don't care about that now if that is the case self.rect.right should also be 1280 and this one is still fine so now let's try this one and something about weird and the problem here is self.direct.right should be greater than 1280. now let's try this so now we have a collision with the right side but not with the top so at least something is working and well basically all we have to do is copy all of this here and change the direction to vertical and now we want to check if rect.top is smaller than zero and if that is the case you want to set the top to zero and then position dot y is going to be rec dot y and direction not y we multiplied with negative one so we are reversing the direction and for the final one self direct bottom is greater than 720 and if that one is the case then self.rec.bottom is going to be equal to 720 and finally we have to change all of the axes to a y and now let's try all of this again this one is working this one is working this one is working as well we don't have player collisions yet that's going to come in a second but besides that things are looking pretty good okay cool now the final thing we have to address is the collision between our player and the ball and this is going to happen inside of collisions let me minimize all of the other methods so it's a bit easier to see what's going on the problem we have right now that our collision sprites just checks for the obstacles so we don't check for any collision with the player and well we just have to add two more lines here to fix that and basically what i want to check if self dot wrecked dot collide rect so if the current rectangle of the ball is colliding with self.player.rect and this is a very simple i should spell it correctly this is a very simple wreck collision method that just checks if two rectangles are overlapping that's all we're trying to do here so this is basically telling us if the rectangle of the ball is overlapping with the rectangle of the player and if that one is the case we want to collision sprites dot append self dot player and now let's try this again and now let's try to get it and yeah this is working just fine hope i can get the ball again the ball is moving quite fast so it's a bit difficult to get it okay uh well i hope you get the idea uh there we go there yeah so this seems to be working just fine cool and well with that we are pretty much done now before i finish this video there are two i wouldn't call it bugs but two things we don't really cover in this kind of logic and to fix this we would need quite a bit more code so i'm kind of going to ignore them but let me visualize what the problem here is right now let's say i'm going to move my player exactly in this in wait a second in this position here now you can see that we get kind of a bug that the player is pushed through the yellow rectangle and the reason for that is that this green rectangle is just pushing the player and that is overwriting this collision here and the other problem we have here is if our ball is colliding with any of the moving obstacles it's kind of hard to see right now i'm probably going to add some kind of video to explain it a bit better because it only happens sometimes the basic problem is if the ball is being pushed down by another moving obstacle so for example the ball is being pushed down we get kind of a random direction because every time these two collide the vertical or the horizontal direction of the ball is being reversed so if they collide once on one frame we get one collision and then a change in direction but if they collide again on the next frame we get the same thing again so the direction changes again and this happens probably hundreds of times if the ball is being pushed down or up or left or right and as a consequence we get kind of a random direction afterwards and you could add a lot more code to account for these cases although another thing you could be doing is design your levels in such a way that this problem doesn't even come about so for example if you have moving platforms in the game make sure these platforms can never squash the player between themselves and another kind of object or if you have something bouncing around make sure you work with the directions to address all of this that there couldn't be a bug so just keep these things in mind but well i hope this video was helpful and i will see you around
