With timestamps:

00:00 - [Music]
00:10 - [Music]
00:26 - n
00:31 - [Music]
00:41 - hello there in this tutorial we will
00:43 - create a Pok√©mon inspired RPG in there
00:47 - you can explore an Overworld full of
00:48 - characters and you can fight trainers
00:50 - and wild monsters the battle system is
00:53 - also quite complex you are able to
00:55 - choose a range of attacks switch
00:57 - monsters and even catch Wild Ones
01:01 - the entire thing includes a lot of
01:02 - animations and visual details to make it
01:04 - look nice also monsters can level up and
01:07 - evolve they also learn new attacks on
01:10 - some levels to visualize all of that
01:12 - information there will be a monster
01:14 - index that shows you the attacks stats
01:16 - and abilities of all of them all
01:19 - combined this will become a fairly large
01:21 - tutorial but you are going to learn how
01:23 - to organize complex projects how to
01:25 - manage databases and how to build your
01:27 - own user interfaces from scratch skills
01:30 - that can be incredibly useful now
01:33 - creating these projects requires a broad
01:35 - range of skills for example in this game
01:38 - I have relied heavily on Vector math and
01:40 - geometry if you want to practice these
01:42 - Concepts more thoroughly check out the
01:44 - sponsor of this video brilliant.org they
01:47 - offer courses on all of these Concepts
01:49 - that are full of interactive lessons and
01:51 - Hands-On problem solving skills not only
01:54 - is this approach uniquely effective at
01:56 - learning it is also much more fun than
01:58 - just passively reading a book or
01:59 - watching a lecture it is also really
02:02 - good at getting you to build problem
02:03 - solving skills since this is what you
02:05 - will doing from day one on top of that
02:08 - all of the content has been made by
02:09 - award-winning teachers researchers and
02:11 - professionals with industry experience
02:13 - you can access brilliant via a website
02:15 - or an app and spending just a few
02:17 - minutes on it every day will help you
02:19 - learn a lot so instead of scrolling idly
02:22 - on the bus or at the gym you can build a
02:24 - powerful habit that will make you a more
02:25 - competent thinker brilliant also
02:27 - recently added a lot more content like
02:30 - programming with python data
02:31 - visualization and how llms work and they
02:34 - regularly add more content if you head
02:37 - over to brilliant.org clear code you can
02:39 - get 20% off a subscription and the first
02:42 - 30 days are free so not much to lose and
02:45 - if you subscribe you also help me make
02:47 - more videos so thanks again to brilliant
02:49 - for sponsoring this video let's get
02:51 - started with the game and the first
02:53 - thing that we need is the Overworld with
02:55 - all of the characters this will include
02:58 - a lot of imports since we have to to
02:59 - cover quite a bit of artwork so I
03:02 - suppose let's start by looking at the
03:03 - project folder in which we have four
03:05 - subfolders audio code graphics and data
03:09 - the only folder that we will work in is
03:11 - the code folder this one actually
03:14 - already contains a few python files I
03:16 - will talk about them once they are
03:17 - needed besides that we have a data
03:19 - folder with a whole bunch of tiled Maps
03:22 - those store the various layouts of the
03:24 - Overworld finally the graphics folder
03:26 - contains well all of the graphics it's
03:29 - probably a good idea to have a quick
03:31 - look at all of these files just so you
03:33 - have an idea of what we are working with
03:35 - although I will also talk about it when
03:37 - we import them into pame you can get the
03:39 - start folder and the folder for each
03:41 - stage of the tutorial on GitHub and from
03:43 - Google Drive just check the video
03:46 - description now to get started I want to
03:48 - go to the code folder and open main.py
03:51 - and
03:51 - settings.py here we are inside of m.p
03:55 - and at the moment nothing is really
03:56 - happening we are simply importing
03:58 - everything from settings let's have a
04:00 - look at that one all the way at the top
04:02 - we have a couple of imports the most
04:04 - important one is py game but on top of
04:06 - that we are importing from py MAF a
04:09 - vector 2 as a vector for this project we
04:13 - are going to rely very heavily on
04:14 - vectors so I want to have them available
04:17 - quite easily this part isn't strictly
04:19 - necessary but it makes our life a bit
04:21 - easier finally from CIS import exit is
04:25 - going to be used to close down the game
04:26 - later on after that we are defining a
04:29 - couple of basic constants like the
04:32 - window width and the window height the
04:34 - tile size the animation speed and so on
04:37 - none of this is too complicated or at
04:39 - least I hope it isn't after that we have
04:42 - a couple of dictionaries for example
04:44 - this one defines all of the colors in
04:45 - the game these dictionaries aren't too
04:48 - important for now so don't worry too
04:50 - much about them I'll cover them in more
04:52 - detail later so that's the basics of
04:54 - settings. Pi although before we continue
04:58 - there's one really important thing for
05:00 - this project I am going to use py game-
05:02 - C or pame Community Edition not the
05:06 - regular or traditional pame that is
05:08 - because there are two versions of pame
05:11 - the traditional pame and py game- c and
05:14 - the version that you want to use is py
05:16 - game- CE this one has frequent updates
05:19 - it has more features it runs faster and
05:21 - it is 100% backwards compatible there
05:24 - really isn't any reason to use the old
05:26 - py game anymore and if you want to
05:29 - install it you either go to the
05:30 - Powershell or The Terminal and type pip
05:33 - install py game- CE that's all you need
05:36 - to install it in my case I already have
05:38 - it installed so I don't have to do it
05:41 - now the one important thing you want to
05:42 - keep in mind is that inside of python
05:45 - you are importing pame and pame C in the
05:48 - same way both are imported with import
05:51 - py game that is important to ensure
05:53 - backwards compatibility for pame C but
05:56 - if you have both versions installed then
05:58 - this is going to cause some problems so
06:01 - I would recommend to get rid of the old
06:02 - pame entirely and only use pame C you
06:06 - are retaining all of the features and
06:07 - you get some additional ones so you're
06:09 - not losing anything and all of your old
06:11 - projects are still going to work just
06:13 - fine righty with that we have the setup
06:16 - that means we can work inside of main.py
06:19 - and create the basic game class let's
06:21 - call it class game no need for
06:25 - inheritance but we will need a thunder
06:27 - init method in which we first of all
06:30 - want to initialize py game with pygame
06:33 - do init next up we will need a display
06:36 - surface let's call it self. display
06:39 - uncore surface this one we are creating
06:42 - with py game. display. set uncore mode
06:47 - this one wants to have a tupile with the
06:48 - window WID and the window height which
06:51 - we are getting from the settings there
06:53 - we have window Wii and window height and
06:55 - those we want to pass into a
06:57 - tupal inside of set mode
07:00 - also while we are here we can set a
07:02 - window title with py game. display.
07:06 - setor caption and to make sure that I am
07:09 - not getting sued let's Call it Monster
07:11 - Hunter cool with that we have the basic
07:14 - setup next up we want to have a run
07:17 - method in which we are going to run the
07:20 - game Loop meaning while true then we
07:23 - want to get an event Loop and we want to
07:27 - run the game logic
07:30 - the event Loop is fairly simple for
07:32 - event in py game. event. getet at the
07:37 - moment the only event that we care about
07:39 - is if event. type pame
07:44 - dowi if that is the case we want to run
07:47 - pame do quit and the exit method that we
07:51 - are getting from settings this one that
07:53 - way we are able to close down the game
07:56 - after that inside of the game logic at
07:58 - the moment we can't really do anything
08:00 - but I want to set py game. display.
08:04 - update so we're making sure that
08:06 - whatever we are drawing inside of this
08:08 - run Loop is going to be displayed and
08:11 - that is it to get started all we have to
08:14 - do now is inside of the global scope
08:16 - check if Dunder
08:18 - name is equal to the string Dunder main
08:22 - so we are checking that we are in the
08:24 - main file if that is the case we want to
08:26 - create one instance of the game class
08:29 - and on that class called the run method
08:33 - if I now Run the game we should be
08:36 - seeing a window and there we go that
08:38 - looks good we can also close it so all
08:41 - of this is working just fine oh and by
08:43 - the way if you have no idea what these
08:46 - terms are so if you don't know what a
08:48 - display surface is or what an event Loop
08:51 - is I should mention that this tutorial
08:54 - is for more advanced users I will
08:56 - already assume that you have a basic
08:58 - understanding of P game G if you are
09:00 - entirely new to it check out my ultimate
09:02 - introduction to pame this one is going
09:04 - to cover all of the basics the next part
09:07 - that we have to work on is going to be
09:09 - the Imports for the level and for that
09:12 - let's have a look at the project folder
09:14 - in there we want to look at data and
09:16 - then there we have all of the maps those
09:18 - contain the data for every level inside
09:21 - of the game and the most important one
09:23 - is world. TMX and by the way all of the
09:26 - files have been created en tied which is
09:29 - an open- Source map editor if you have
09:32 - that one and you open a map there you
09:34 - can for example see the Overworld now
09:37 - for this tutorial you don't have to know
09:39 - tiled in too much detail although if you
09:42 - want to expand the game on your own you
09:44 - should probably know the basics of it
09:47 - and I have made a tutorial specifically
09:49 - on it so check this one out if you are
09:51 - interested but the basic gist of it is
09:54 - if you look on the top right there we
09:55 - have a whole bunch of layers like
09:57 - terrain terrain top entities and so on
10:00 - the layout that we care about for now is
10:02 - called terrain so let me hide everything
10:06 - else like so this is going to be the
10:09 - background for the level and this is
10:11 - basically a grd if I go to view and show
10:15 - GD you can see we are simply dragging
10:18 - from the layers specific Graphics into a
10:20 - position I could for example select this
10:23 - mountain and then place it in these
10:27 - positions that's all that's happening in
10:29 - here here so ultimately what we want to
10:31 - do is import all of these graphics and
10:34 - then display them via py game so inside
10:37 - of py game I want to create two more
10:40 - methods the first one is called import
10:44 - assets no need for custom parameters and
10:47 - in there we going to import all of the
10:49 - assets for now the only one that we
10:52 - really care about is going to be self.
10:55 - TMX
10:57 - maps and this is going to be a
10:59 - dictionary with key value pairs where we
11:02 - have a world and then an Associated TMX
11:06 - map now to import this TMX map we need a
11:09 - specific python module or rather one
11:12 - specific part of a custom module we want
11:16 - from
11:17 - PMX do
11:19 - _ pame import load uncore iame PMX is a
11:27 - module that is really good to import TM
11:29 - X Files into py game and this specific
11:32 - method that we are looking for is called
11:33 - load py game now if you run the code you
11:36 - should not be getting an error message
11:38 - from this line if you do you have to
11:40 - install
11:42 - PMX which you do inside of the
11:44 - Powershell you want to type pip install
11:46 - py TMX and that's all you have to do
11:49 - with that we can import PMX maps and we
11:53 - using this with load py game and then a
11:56 - file path in our case we want to go
11:59 - upper folder then we want to go to data
12:02 - in there we have the maps and in there
12:04 - we have world.
12:07 - DMX so if you look at a project folder
12:10 - we are starting inside of the code
12:12 - folder in main.py then we want to go up
12:15 - to project to data maps and then world.
12:19 - TMX that is the relative path we have
12:22 - just
12:23 - created that being said approaching file
12:25 - paths like this isn't ideal because some
12:28 - operating systems use a forward slash
12:30 - others use a backward slash and if you
12:32 - have a hardcoded relative path this
12:34 - might cause some problems to fix that we
12:37 - can use another python module from os.
12:40 - paath import
12:42 - join and all that join does is it
12:45 - creates custom paths the way you use it
12:49 - is instead of one hardcoded path you
12:51 - simply specify the folders or the notes
12:54 - you want to go through you want to go up
12:56 - a folder then we want to go to data
12:59 - then we want to go to maps and finally
13:02 - we want to go to world.
13:05 - TMX and that is all we need those two
13:08 - things for windows are basically going
13:10 - to be identical but depending on the
13:13 - operating system you might get a
13:15 - different kind of slash now we don't
13:17 - need the original path anymore and we
13:21 - can print self. TMX
13:25 - maps on top of that inside of the done
13:28 - ended method I want to run self. import
13:33 - assets if I now run the entire
13:36 - code after a second we are getting a
13:39 - dictionary with a tile map so that is
13:41 - looking really good that means we don't
13:44 - need to print statement anymore and next
13:46 - up we can create a setup method which is
13:50 - going to need two custom parameters the
13:52 - first one is the TMX map that we want to
13:55 - use the second one will be the player
13:59 - start position later on this setup
14:03 - method is going to load different kinds
14:04 - of levels depending on what TMX map we
14:07 - are putting into it but for now we only
14:10 - have a single one so this one isn't too
14:13 - complicated all that we want to do for
14:15 - now is Loop through one of the layers of
14:17 - our TMX map and if I open tiled you can
14:21 - see that the one layer we care about for
14:23 - now is called terrain this is the one
14:25 - that we want to import we getting that
14:28 - with TMX map and then get underscore
14:31 - layer uncore byor name the layer name
14:35 - for this one is terrain and it's
14:38 - essentially going to be a list with all
14:40 - of the positions and the images that we
14:42 - have laid out inside of til although to
14:45 - access all of that we need dot tiles
14:48 - afterwards with that we can put this
14:51 - data inside of a for Loop for x y and
14:56 - the surface in this particular
14:59 - layer that way we can print x y and the
15:04 - surface and we would get access to the
15:07 - position so X and Y and the surface and
15:10 - that is all we need in the setup method
15:12 - for now so next up we can call self. set
15:17 - up with two arguments the first one is
15:20 - the TMX map which we get with self. TMX
15:23 - maps and this one has the key world the
15:26 - one we have just created the player stop
15:29 - position doesn't matter too much but
15:31 - later on this is going to be house if I
15:33 - now run the
15:34 - code we can't see anything but we are
15:38 - getting positions and then a
15:41 - surface and quite a few of those the way
15:45 - to read this information is the surface
15:47 - is simply the graphic that we have
15:49 - placed and then the numbers next to it
15:52 - are going to be the column and the row
15:54 - keep in mind for this one we are at the
15:57 - moment working inside of a grp
16:00 - we do not have pixel positions or in
16:02 - other words if we are inside of til I
16:05 - can zoom out and if we go all the way to
16:08 - the top left this tile here would be
16:10 - tile zero and zero the one to the right
16:13 - of it would be tile one and zero or in
16:17 - other words x would be one and Y would
16:19 - be zero that would be the position
16:21 - inside of the grid but it's not a pixel
16:23 - position since our tile size is 64
16:26 - pixels this tile would start 6 64 pixels
16:29 - to the right of the origin Point that's
16:32 - an important thing to keep in mind and
16:34 - something that we want to use right away
16:37 - so instead of using X and Y we want to
16:40 - multiply both of these values with the
16:42 - tile size that we are getting from the
16:44 - settings and there we have tile size I
16:47 - want to multiply X and Y with the tile
16:51 - underscore size and then we should have
16:54 - the correct position if I run this again
16:58 - you can see that we get much much larger
17:04 - numbers and that does look quite a bit
17:06 - more accurate so ultimately our map is
17:09 - going to be 4,500 by 4,900 pixels so
17:14 - with that we know what graphic we want
17:16 - to display and where to display it but
17:19 - we don't actually show it and for that I
17:21 - want to create a Sprite Which I'm going
17:24 - to do in a new python file let's save
17:27 - this one as Sprite
17:30 - dop and first of all in there we want
17:33 - from settings import
17:36 - everything and then I want to create a
17:38 - class called Sprite Which has to inherit
17:41 - from py game. sprite. Sprite and be
17:44 - careful on this one about the spelling
17:46 - the second Sprite should have an
17:47 - uppercase s inside of the Sprite we want
17:51 - to call a thunder inage method and then
17:54 - Define a couple of basic
17:56 - parameters we for now want to define a
18:00 - position a surface and the
18:05 - groups after that we want to Calla super
18:08 - Dunder init to initialize the parent
18:10 - class and then pass the
18:13 - groups in there as an argument in case
18:16 - you don't know how Sprites work you
18:17 - should really check out the basics of py
18:19 - game but basically a Sprite is a simple
18:22 - class that contains a position rectangle
18:24 - and a graphic that we are placing inside
18:26 - of a group then via the group we have
18:28 - updating and drawing the Sprite to make
18:31 - all of that work we have to Define self.
18:34 - image and self.
18:37 - rectangle the image is simply going to
18:40 - be the surface that we getting from the
18:42 - parameters meaning we are simply passing
18:45 - this thing right through and saving it
18:47 - as a parameter for the rectangle we want
18:50 - to get self. image and then get
18:52 - underscore F rectangle where we are
18:55 - defining the top left and setting this
18:58 - to the position
18:59 - that we are getting from the parameters
19:00 - once again and I should mention get fct
19:04 - is short for G floating Point
19:06 - rectangle which is something unique to
19:09 - pame C if you're using the traditional
19:12 - pame this would get you an error hence
19:15 - make sure to update the reason why you
19:17 - want to use a floating Point rectangle
19:20 - is because in the traditional rectangle
19:22 - you are storing all of the points via
19:24 - integers for example the top left could
19:26 - be a position of one and two two very
19:29 - simple numbers and importantly those are
19:32 - both integers which are a good start but
19:35 - very often you want to be a bit more
19:37 - precise and for that you want to have
19:39 - floating Point rectangles which work
19:42 - exactly like the old rectangles except
19:44 - now you can store floating Point values
19:46 - for the position so the top left could
19:48 - be for example 1.5 and
19:52 - 2.13 significantly more precise and
19:56 - that's basically the entire difference
19:58 - but this ision can be incredibly useful
20:00 - so I would generally recommend to use
20:02 - floating Point rectangles but anyway
20:05 - with that we have a basic Sprite inside
20:07 - of main. Pi first of all we want from
20:11 - Sprites import the basic Sprite after
20:14 - that inside of the dunder init method
20:18 - let's do it all the way at the top we
20:19 - want to create a whole bunch of groups
20:22 - or Well for now we only want to create a
20:24 - single group self. allore Sprites which
20:28 - is going to be pam. sprite.
20:31 - group this group all Sprites is going to
20:34 - contain well all of the Sprites or at
20:37 - least all of the visible Sprites and
20:39 - then via this group we're going to
20:41 - display and update all of these
20:43 - Sprites so after we have that inside of
20:46 - the setup method when we are looping
20:48 - through all of the terrain tiles I want
20:50 - to create a Sprite and then we want to
20:54 - get a position a surface and a groups
20:58 - let me paste it
20:59 - in position is going to be a dupal that
21:03 - we have just created with X multipli by
21:06 - tile size and Y multiplied by tile size
21:09 - the surface is the surface we are simply
21:12 - going to get from the for Loop I.E we
21:14 - are taking this surface and we are
21:16 - passing it into the class finally for
21:19 - the groups we only have a single group
21:20 - self. all
21:23 - Sprites and with that we have a basic
21:26 - Sprite if I now run the code we getting
21:28 - an error message that's a good sign but
21:30 - we still can't see
21:32 - anything the reason for that is that we
21:35 - have to draw this all Sprites which is
21:37 - going to happen inside of the run method
21:39 - before we updating the screen we want to
21:42 - run self. or Sprites do draw and the
21:47 - argument we have to pass in there is the
21:48 - surface we want to draw on in our case
21:51 - we want to draw on self. display surface
21:55 - if I now run the code we can see the top
21:58 - left of the map so if you look at til we
22:01 - are currently drawing this top left part
22:05 - more or less and I realized there's one
22:08 - graphical issue this part here that
22:10 - isn't looking correct that we can fix
22:12 - right away so I want to select this one
22:15 - tile and then place it in there and that
22:18 - looks much better if I now save the tile
22:20 - map go back to my code editor and run
22:23 - all of this now we have fixed this
22:25 - corner much better that covers the basic
22:28 - Imports but that's still not really
22:31 - useful simply because we want to display
22:33 - more than this top left corner we have a
22:35 - huge map that we want to
22:37 - display to make all of this visible we
22:40 - have to create a basic player along with
22:42 - a camera to create the player I want to
22:45 - create a new python file and save this
22:48 - as entities. Pi besides the player later
22:52 - on we are also going to store all of the
22:54 - other characters in there but that is
22:56 - going to come later but now I first off
22:59 - I want from settings import everything
23:02 - and then create a class called
23:05 - player like the Sprite this one has to
23:07 - inherit from py game. sprite. Sprite and
23:11 - then we will need a thunder in it method
23:15 - with self a
23:16 - position and the groups for now after
23:20 - that we will need Super Thunder init
23:23 - along with the groups after that we will
23:25 - need self. image and self. rectangle the
23:30 - image isn't too important for now later
23:32 - on we are going to have proper graphics
23:34 - for now I simply want to create pame do
23:37 - surface with a size of let's say 100 by
23:42 - 100 also this self. image I want to fill
23:45 - with a color so it looks a little bit
23:47 - better let's say red for the rectangle I
23:50 - want to get self. image and
23:53 - getorf rectangle where I am setting the
23:56 - center to the position that we're
23:58 - getting from the parameters with that we
24:01 - have a basic player that is very similar
24:03 - compared to the Sprite we have just
24:05 - created which means inside of main.py I
24:08 - can from entities import
24:12 - layer and then we can use that class
24:15 - inside of the setup
24:17 - method although for that we need another
24:20 - for Loop because the player is not
24:22 - inside of the terrain layer if you look
24:25 - at all of the layers inside of til we
24:28 - have one object layer called entities
24:31 - and you know it's an object layer
24:32 - because of these purple dots next to it
24:35 - if you enable that one you can see two
24:38 - things oh well you can see all of these
24:41 - markers those can do two things if you
24:44 - look on the left
24:45 - side a name could either be player or a
24:49 - name could be a character a character
24:51 - would either be a trainer or a hospital
24:53 - nurse but now we don't really care about
24:56 - either we only care about the player
24:58 - notes and if I display all of the
25:01 - objects they're going to make a bit more
25:02 - sense so for example this note here for
25:06 - the player would be the start position
25:08 - if we just came from the planned Arena
25:11 - and if we go for example to this point
25:14 - it is Hospital 2 and the marker right in
25:16 - front of it would be the start position
25:19 - if the player just came from this
25:20 - Hospital 2 and so on basically we have a
25:23 - whole bunch of start positions for the
25:25 - player and the one that we want to start
25:27 - with is is this one which at the moment
25:30 - is not in the right position it should
25:32 - be in front of this house inside of your
25:36 - project it should have been in the right
25:37 - position I was simply testing things
25:40 - this should be the starting position for
25:42 - the player where we have a position so
25:45 - house and the direction that way we can
25:47 - identify this particular marker now
25:50 - inside of the code first of all we have
25:53 - to Loop through this particular layer
25:55 - from tiled and since we have an object
25:58 - layer
25:59 - we have to approach this just a little
26:01 - bit differently compared to the styled
26:03 - layer instead we want for obj in TMX map
26:09 - do get layer by name and the name we
26:12 - want to look at is called is
26:16 - enter no need for DOT tiles afterwards
26:19 - and now we could print obj if I run the
26:24 - code we are getting a print out
26:29 - of all of the objects on this layer we
26:32 - have a name either player or a character
26:35 - at the moment we only care about the
26:37 - player
26:39 - once which means we want to run some
26:41 - code if
26:43 - objname is equal to player if that is
26:47 - the case for now let's say I want to
26:49 - print the object node so if I run all of
26:53 - this we are only getting all of the
26:55 - player start
26:57 - positions that's that's a good start now
26:59 - from this object we can get quite a bit
27:01 - of information for example we can get X
27:04 - and Y for the position or we can get the
27:08 - properties that we have to find if you
27:11 - look at til the custom properties I'm
27:13 - talking about are in this case the
27:14 - direction and the position direction for
27:17 - now doesn't really matter the one that
27:19 - we care about is the position and this
27:21 - one would Define where the player came
27:24 - from this case the starting position
27:25 - would be the house or this house to be a
27:27 - bit more specific if you go to another
27:30 - start position this one it will be
27:32 - planned for this planned Arena now back
27:35 - in the code when we are calling the
27:38 - setup method early on I have passed in
27:41 - the house for the starting position and
27:44 - we basically want to look at all of the
27:46 - objects and then find the object that
27:49 - has the custom property house for the
27:50 - position to get that one we want to get
27:53 - the properties and then look for the
27:55 - position if I run the code like that
27:59 - we can see we have all of the starting
28:01 - positions and the one we care about is
28:03 - the house which means to single out this
28:05 - one object we want to expand this if
28:08 - statement if obj name is player and obj
28:14 - do properties with the
28:17 - position is equal to the player start
28:21 - position if that is the case we want to
28:24 - get obj dox and obj doy
28:28 - I can now run the code and we should
28:30 - only be getting one position that looks
28:33 - really good perfect that also means now
28:36 - that we have a position we can start
28:38 - working on the player because this one
28:40 - needs a position and groups both of
28:43 - which we have meaning I want to create a
28:46 - player objx and obj Y will be the
28:49 - position and then for the groups I want
28:52 - to have self. all
28:54 - Sprites and if I fix my typo this should
28:59 - also work if I now run the code we are
29:02 - not getting an error message but we also
29:04 - cannot see the player simply because at
29:07 - the moment we are only displaying the
29:09 - top left of the map and to see the
29:11 - player we have to create a camera that
29:14 - being said inside of til if you move
29:17 - this player start position all the way
29:19 - to the top
29:21 - left like
29:23 - this save the tile map return to pame
29:28 - and then run this again we can see the
29:30 - player so this one does indeed work
29:33 - which means we have everything we need
29:35 - to get started with the camera although
29:37 - before that there's one more thing that
29:39 - I would like to do the player should be
29:42 - able to move around without that the
29:44 - camera is going to look a little bit
29:46 - weird now moving around is going to
29:48 - involve two parts number one we have to
29:51 - capture input let me add a pass in there
29:55 - for now and the second part is is going
29:58 - to be the actual move method which will
30:01 - need self and Delta time I'll explain
30:04 - that one in just a second although for
30:05 - now I will simply add pass in there to
30:08 - get started with input we first of all
30:11 - want to get all of the keys being
30:12 - pressed which we get with pame dokey.
30:16 - getor pressed that we can use for
30:19 - example via keys and py game. Kore up
30:25 - which is a constant inside of pame that
30:27 - tells us that we are pressing the up
30:29 - Arrow key if that is the case I want to
30:31 - for example print up and that logic
30:35 - should be sound but we have to call the
30:37 - input method for it to work in the first
30:39 - place and that we do via an update
30:42 - method which for now is only going to
30:44 - accept self as a parameter in there we
30:47 - want to call Self do input now to call
30:50 - this update method we have to look at
30:53 - the all Sprites group because this one
30:56 - can draw all of the Sprites and it can
30:58 - call the update method which is quite
31:00 - easily done before we are drawing all of
31:03 - the game logic we want to get self. all
31:06 - Sprites and then call the update Method
31:10 - All That update is doing is it looks at
31:12 - all of the Sprites inside of all Sprites
31:14 - or whatever group you have and then call
31:16 - the update method in our case this will
31:18 - only apply to the player because the
31:20 - Sprites do not have an update method but
31:23 - other than that if I now run the code we
31:25 - are getting an error that inside of pame
31:28 - I have a typo this should be py game if
31:31 - I now run all of this and I press the up
31:33 - Arrow key we can see up so that is
31:35 - looking really good we can now capture
31:38 - keyboard input we just have to use it
31:40 - inside of the game and the way I usually
31:43 - approach that is by first of all
31:45 - creating another Vector that I call
31:47 - input Vector which is simply going to be
31:50 - a vector without any
31:52 - values the default value for a vector is
31:55 - zero and Zer for X and Y meaning if if
31:57 - you simply create a vector like this
31:59 - you're getting zero and zero this Vector
32:02 - I want to update for example if we press
32:05 - the up Arrow then I want to get the
32:08 - input Vector update Y and subtract one
32:12 - from it all of this I want to copy
32:15 - because next up we want to check the
32:17 - down arrow if that is the case we want
32:20 - to increase y by
32:22 - one I can do this once more next up we
32:25 - want to look at left and if that is the
32:28 - case we want to get the export of the
32:30 - vector and reduce it by one finally we
32:34 - want to walk to the right which means we
32:38 - want to increase X by one the end result
32:42 - if I print the input vector and run
32:45 - main. Pi you can see if I press
32:49 - different arrows on my keyboard we are
32:52 - getting the various directions so that's
32:54 - looking really good one thing that I do
32:57 - want to mention before we continue this
32:59 - input Vector is quite important because
33:01 - it gives us a blank Vector with values
33:04 - of 0 and zero that way whatever we're
33:06 - doing here simply gives us the keyboard
33:08 - input and nothing else if the input
33:11 - Vector already had any other value this
33:13 - would cause some
33:14 - problems hence I want to keep this
33:17 - inside of the input method and not have
33:19 - anything else influence it but that
33:21 - causes another issue because we're
33:23 - getting the input in there but we want
33:25 - to use it inside of the move method to
33:28 - actually move the
33:29 - player I.E we have to connect these two
33:32 - and this I do via another attribute of
33:35 - the class that I'm going to call self.
33:37 - Direction which by default is going to
33:39 - be another Vector now after we're doing
33:42 - all of the input I am updating self.
33:46 - Direction and set it to the input Vector
33:50 - that way we can use Direction inside of
33:52 - the move method and I think for now we
33:55 - don't actually need Delta time so let me
33:58 - get rid of it to move the entire Sprite
34:01 - all we really need to do at least for
34:03 - now is self. w. Center plus equal self
34:09 - do Direction multiplied with some kind
34:12 - of speed for now let's go with
34:15 - 250 and that is it if I now run self.
34:20 - move after the input run may not Pi
34:23 - again I can move around but you can see
34:26 - that the player is moving way too fast
34:27 - fast if I run this again and simply tap
34:30 - right once we are going way too far to
34:33 - the right I suppose if I reduce the
34:36 - speed to something like five and that is
34:40 - looking significantly better at least
34:43 - now we can see the player movement this
34:46 - is still not ideal simply because this
34:50 - update is not frame rate
34:52 - independent that means inside of the
34:54 - game we have some kind of frame rate
34:57 - that we can actually measure via a self.
35:01 - loock which we get with py game. time.
35:05 - clock that clock inside of the game Loop
35:08 - we have to call self. clock. Tick this
35:13 - simply tracks the frame rate and once we
35:15 - have that we can measure the frame rate
35:18 - and print it out self. clock doget
35:21 - uncore FPS and don't forget to call this
35:24 - one if I now run all of this you can see
35:27 - that our frame rate is around 250 frames
35:31 - a little bit more than that meaning we
35:33 - are running this while loop 270 times
35:36 - per second and then apply this update to
35:38 - the player position by the same amount
35:40 - so 270 times per second we are changing
35:43 - the center of the player which is fine
35:46 - on its own however it does not work when
35:49 - the frame rate changes which we can
35:51 - emulate by adding an integer into the
35:53 - tick method if you leave it empty the
35:55 - game tries to run as fast as possible
35:57 - but if you add a 60 in there then our
36:00 - frame rate is going to be 60 and now our
36:02 - player is going to move significantly
36:05 - slower which is not
36:08 - ideal our movement problem at the moment
36:10 - is that the game tries to run as fast as
36:13 - possible and then update the player
36:15 - position since we are doing this by
36:17 - default very often the player is going
36:19 - to move really fast however some levels
36:22 - especially the smaller ones like the
36:24 - hospital are going to run even faster
36:27 - because we don't have to render as many
36:29 - elements not to mention that the game is
36:31 - going to run on a variety of computers
36:33 - some more powerful than others and
36:35 - because of all of that the frame rate of
36:37 - the game is not really going to be
36:39 - predictable on some computers it might
36:42 - run at 30 frames per second on other
36:44 - computers you might get a thousand
36:45 - frames and we want to account for all of
36:48 - that and that we are going to do via
36:51 - Delta time or DT in short now I am not
36:54 - going to cover Delta time in detail in
36:56 - this tutorial that being said I have
36:58 - made an entire video on Delta time so
37:01 - check this one out if you want to learn
37:02 - about all the details essentially we
37:05 - want to run our game as fast as possible
37:07 - no arguments inside of the take method
37:10 - and then capture the return value of the
37:12 - take method and stored inside of DT this
37:15 - DT is now going to give us the time
37:17 - difference between the current frame and
37:19 - the last frame or in other words how
37:21 - long it took in seconds to render the
37:23 - current frame and this we want to have
37:25 - in milliseconds at the moment we have
37:27 - all of this in seconds so we want to
37:29 - divide it by a th since they're 1,000
37:32 - milliseconds in a second and just to
37:34 - print out what we are getting I want to
37:36 - print Delta time run this entire thing
37:38 - again and now if I run around for a bit
37:42 - you can see on the last frame we had a
37:44 - frame rate of 270 and a Delta time of
37:49 - 0.003 which means that it took my
37:51 - computer about
37:53 - 0.003 seconds render the current frame
37:57 - which by itself isn't particularly
37:58 - useful but we can use that information
38:01 - inside of the update method so I want to
38:03 - pass it in there although for that to
38:05 - work inside of the update method in the
38:07 - player we have to create another
38:09 - parameter Delta time which we then want
38:12 - to pass into the move method so now we
38:15 - can recreate the Delta time parameter
38:18 - basically all we have to do to use Delta
38:19 - time is to multiply it with the update
38:22 - of the
38:23 - movement and now I can use a speed of
38:26 - 250 again because if I run main. Pi even
38:29 - though our speed is 250 we are moving at
38:31 - a reasonable speed which is going to be
38:35 - the same speed regardless of the frame
38:37 - rate if I set for example the frame rate
38:39 - to 10 really low we are still moving at
38:42 - the same speed now the game is going to
38:44 - look really choppy because the frame
38:46 - rate is terrible but the actual movement
38:48 - is the same cool so with that we have
38:51 - some very basic player movement that's
38:53 - all we need for this part which means
38:56 - next up we can work work on an actual
38:58 - camera because at the moment the player
39:00 - can simply move outside of the window
39:02 - and then it disappears so we want to
39:05 - create a camera to follow the player and
39:07 - the way that works in pame is by
39:10 - creating a custom group for that I'm
39:12 - going to create a new python file that I
39:15 - want to save as groups. Pi and there
39:19 - first of all we will need from settings
39:21 - and I want to import
39:24 - everything then we can create a class
39:26 - called all
39:27 - Sprites which needs to inherit from
39:30 - pygame dos sprite.
39:33 - Group after that we will need it under
39:36 - init method with self and nothing else
39:40 - for now the only thing that we will need
39:42 - in there is super Thunder init to
39:45 - initialize the parent class and with
39:48 - that we have basically created a copy of
39:50 - the inbuilt Sprite Group which means
39:53 - inside of main. Pi I can from group
39:57 - import all Sprites and then instead of
40:02 - assigning py game. sprite. group to all
40:05 - Sprites I can simply assign it all
40:09 - Sprites if I now run out of this we
40:11 - cannot see a difference the game runs
40:13 - just as before that being said we are
40:16 - now able to customize the drawing
40:18 - logic basically what we want to do we
40:21 - want to create a custom draw method
40:24 - which by default will need self and a
40:26 - surface to to draw on so this draw
40:29 - method is what we are already using down
40:33 - here so if I don't to anything in there
40:36 - and simply add pass I can run main not P
40:38 - again and now we can't see anything
40:40 - anymore simply because this draw method
40:43 - doesn't do anything to recreate the
40:45 - default Behavior we will need a for Loop
40:48 - for sprite
40:50 - in this one would give us all of the
40:52 - Sprites inside of this group self is
40:55 - going to return all of the Sprites that
40:57 - are contained inside of it now by
41:00 - default all that pame really does in
41:02 - there is it takes the surface and then
41:04 - runs the blit method with sprite. image
41:07 - and sprite. rect I can now run all of
41:10 - this again and we get the default
41:11 - behavior that looks good except now we
41:14 - can customize this quite a bit more for
41:17 - example in our case we always want to
41:19 - draw on the display surface meaning we
41:22 - don't really want to pass a surface in
41:24 - there instead in the dunder init method
41:27 - I want to get self. display uncore
41:30 - surface which I'm going to get with py
41:32 - game. display doget uncore surface only
41:37 - on this surface do I want to blit all of
41:40 - the Sprites because of that I don't need
41:43 - the surface parameter anymore I want to
41:46 - get rid of it in there and then inside
41:48 - of main. pi as well if I now run the
41:51 - code everything still works just as
41:54 - before that's the first step the next
41:57 - one that we need is to offset all of
42:00 - these Graphics by default we are placing
42:02 - the Sprite image always in the position
42:04 - of the rectangle but that we don't have
42:07 - to do for example we could Define self.
42:11 - offset which would just be a vector and
42:14 - let me add in a default value let's say
42:17 - 100 by 20 that value I can use to offset
42:21 - all of the Sprites which I'm doing by
42:24 - getting the top left of the rectangle
42:26 - and then adding self. offset I can now
42:30 - run my not Pi again you can see that we
42:32 - are drawing Everything 100 pixels
42:34 - forever to the right and 20 pixels
42:36 - further down which means all that we
42:39 - really have to do is somehow connect
42:42 - this offset to the player position so
42:44 - that we are always centering the player
42:47 - for that first of all we need to get
42:49 - access to the player itself which I want
42:51 - to do via a parameter let's call it
42:54 - player uncore Center that we can get
42:58 - inside of main.py although for that we
43:01 - will have to store the player inside of
43:03 - an attribute self. player is going to be
43:06 - the
43:07 - player that way inside of the draw
43:10 - method I can get self. player. rec.
43:14 - center after that inside of
43:17 - groups I can update self.
43:21 - offset let's say for now self. offset
43:24 - dox is going to be player Center and
43:27 - zero remember this player Center is a
43:29 - tup with X and Y which means to get the
43:33 - offset y we want to get player Center
43:35 - one also by default the offset shouldn't
43:38 - have any values if I now run m not Pi
43:42 - again and I move the player around we
43:45 - are getting something this isn't working
43:49 - perfectly yet but well we are making
43:52 - progress the way you want to approach
43:54 - all of this if this is the entirety of
43:58 - the window our offset position by
44:00 - default is going to be in the top left
44:03 - or Zer and zero we want the player to
44:06 - always be in the center of the
44:08 - window which means this offset point
44:12 - should have a distance to the center of
44:14 - half the window width like this and then
44:18 - half the window height on the vertical
44:20 - axis like this which means on the X part
44:24 - I want to subtract window on _ WID
44:28 - divided by two and then on the vertical
44:32 - axis I want to get window
44:35 - height and now if I run this again we
44:38 - are getting
44:41 - something well that is working a little
44:44 - bit
44:44 - better the only thing that's left to do
44:47 - is to get the negative value for both of
44:50 - these let me put it inside of
44:52 - parentheses and then add negative now
44:55 - all of this is going to work just fine
44:57 - so that is looking much
45:02 - better I can move around freely the
45:04 - camera is working now the reason why we
45:07 - have to get the negative values is
45:10 - imagine once again we have the window we
45:12 - have the player in the center and then
45:15 - we have a whole bunch of tiles around it
45:17 - let me just draw them in something like
45:19 - this and there are some elements outside
45:21 - of the
45:22 - window all that the camera is really
45:25 - going to do if the player is moving down
45:28 - we are moving all of the elements up by
45:31 - the same amount or in other words we
45:33 - always want to move the camera in the
45:35 - opposite direction compared to the
45:37 - movement that way we keep the player in
45:40 - the center of the window and well that
45:43 - is all we need to get started with the
45:45 - camera which means back inside of til I
45:48 - can move the starting position of the
45:50 - player back to the original Point here
45:55 - is
45:57 - and now inside of main P we are starting
46:00 - in a really nice spot so that is working
46:03 - much better although you can see if we
46:06 - go outside of the map everything still
46:09 - falls apart that is because we are not
46:13 - filling the
46:15 - background what is happening here is
46:17 - that py game doesn't discard the
46:19 - previous frame it simply draws on top of
46:21 - it because of that we're getting all of
46:23 - the fragments if we're not filling the
46:25 - background
46:27 - that is an issue we can fix quite easily
46:29 - before we are drawing all of the Sprites
46:32 - using the draw method I want to get self
46:34 - dot display surface and then fill it
46:37 - with a black color I can now run this
46:40 - again and now we don't see the fragments
46:43 - anymore which is feeling much better now
46:46 - later on we're going to fill this area
46:49 - with a coastline and with water and the
46:51 - player is never going to see the black
46:53 - background simply because we're going to
46:55 - have collisions for example here with
46:57 - the rocks and the player will then not
46:59 - be able to see any of the black areas
47:03 - but that's a problem for later and I
47:05 - think this part has gone on long enough
47:07 - so let's do an exercise and then we have
47:09 - finished with this part what I want you
47:12 - guys to do is number one place all of
47:15 - the objects from til and make them
47:17 - visible inside of P game in other words
47:21 - if you look at TI we have an object
47:23 - layer called objects which contains all
47:25 - of the houses trees rocks and so on this
47:29 - one is quite extensive I want you guys
47:32 - to display all of these elements inside
47:34 - of the game after that import the
47:37 - hospital TMX map and also display all of
47:40 - the tiles on the terrain top layer
47:43 - inside of til you want to open hospital.
47:46 - TMX this one contains a level very
47:49 - similar compared to the
47:51 - Overworld I want you guys to launch this
47:53 - level inside of the game and also we
47:57 - have terrain top which contains the
47:59 - countertop thingy this I also want you
48:02 - guys to display inside of the game this
48:05 - is going to take you a little bit of
48:07 - time so try to go through it
48:09 - slowly and if you can't do it don't
48:12 - worry too much about it I will go
48:13 - through it in just a second pause the
48:15 - video now and try to figure this one out
48:17 - on your
48:21 - own to get started I want to work inside
48:25 - of the setup method and add a few
48:27 - comments to make this thing a bit more
48:29 - readable we have the terrain tiles and
48:33 - then we have the
48:35 - entities besides that I also want to
48:38 - have the objects which we're getting via
48:40 - another for loop I want to have for obj
48:44 - in TMX map doget layer by name the layer
48:48 - name for this one is objects all we want
48:51 - to do in there is to create a Sprite at
48:54 - least for now which like before is going
48:58 - to need three arguments position surface
49:00 - and groups the position we can get from
49:04 - obj dox and obj
49:08 - doy the surface we get from the object
49:11 - as well obj do surface the surface we
49:15 - can get from the object as well obj do
49:19 - image and finally for the groups we only
49:22 - have a single one self. all Sprites and
49:26 - that should be it if I now Run the game
49:28 - we can see all of the objects now this
49:31 - isn't perfect for example this tree is
49:34 - on top of the house and also if you go a
49:37 - bit further down we have a few more
49:39 - issues so this isn't working perfectly
49:42 - yet but it's good enough to get started
49:45 - which means we have covered the first
49:46 - part so next up I want to work on the
49:49 - hospital first of all for that we have
49:51 - to import it inside of import assets I
49:55 - want to add a second entry to the
49:57 - dictionary and let me do this over
49:59 - multiple lines in fact I can duplicate
50:01 - all of this and add a second key value
50:03 - pair the key is going to be hospital and
50:07 - we want to import data maps and
50:11 - hospital.
50:13 - TMX after we have that inside of the
50:16 - setup method I want to load TMX map and
50:20 - Hospital although if I run the code now
50:23 - we are going to get an
50:25 - error that game object has no attribute
50:29 - player that is because inside of the
50:32 - hospital we don't have a house starting
50:34 - position to get the actual starting
50:37 - position you want to look at tiled and
50:40 - then the entities let me hide everything
50:42 - else this marker is going to be the
50:44 - starting position of the player and that
50:47 - position is called World which means for
50:50 - this part we want to start the player in
50:52 - the world position if I now run the code
50:55 - we get the hospital hit so that is
50:58 - working pretty well there's just one
51:01 - more thing that we have to do we want to
51:02 - display terrain top this one contains
51:05 - the counter on top of all of the other
51:09 - tiles so that part is going to be fairly
51:12 - similar compared to the terrain which
51:14 - means we can literally copy the entire
51:16 - four
51:17 - Loop and then change the layer name to
51:22 - terrain pop if I now run all of this we
51:26 - have a counter that is later going to
51:28 - have
51:29 - collisions now that being said there's
51:32 - one important thing you do want to keep
51:33 - in mind for all of this and that is the
51:36 - drawing order at the moment we are
51:38 - sorting all of the Sprites by the time
51:40 - of their creation which means the
51:42 - terrain tiles were created first so they
51:45 - are always at the bottom then we are
51:47 - creating terrain top then the objects
51:49 - and then the entities meaning the
51:50 - entities are always on top of everything
51:53 - else however if I create ter top before
51:57 - the terrain and run this again we cannot
52:00 - see terrain top
52:02 - anymore that is because the terrain is
52:04 - now on top of the rain toop which
52:06 - shouldn't be the case now later on we
52:09 - going to create a much better system to
52:11 - sort all of the spres in fact if you
52:14 - look at settings there we have World
52:17 - layers this one we will later on use to
52:19 - sort all of the Sprites but for now
52:21 - that's a bit more advanced and we don't
52:23 - have to worry about it too much the one
52:25 - thing you want to keep in mind point is
52:27 - that you want to have the terrain tiles
52:29 - first then terrain top then objects and
52:31 - then the entities if you couldn't see
52:33 - some Sprites that was probably the
52:35 - reason but all right with that we have a
52:38 - basic level set up there's just one last
52:41 - thing that I want to do to clean this
52:42 - thing up just a bit because we have two
52:45 - four Loops that basically do the same
52:48 - thing that we can simplify with another
52:51 - for Loop we want for layer in and then
52:55 - we have the rain and ter rain pop which
53:00 - needs to be a string inside of this for
53:03 - Loop we want to have the for Loop that
53:05 - actually creates the
53:07 - Sprite except we don't want to have the
53:09 - terrain name we want to have the layer
53:12 - that way we shouldn't need the second
53:14 - for Loop anymore and now if I fix my
53:18 - typo this should be terrain all of this
53:20 - should also work just as before and that
53:23 - looks really good cool perfect with that
53:26 - we have covered the basic outline of the
53:28 - level the next major part are going to
53:31 - be the Overworld animations specifically
53:33 - we want to have a coast animation and a
53:36 - water animation that is going to make
53:38 - everything look significantly nicer for
53:41 - these animations we have to go through
53:43 - two steps the first part is the actual
53:45 - animation itself and this part is fairly
53:48 - easy inside of a Sprite we're going to
53:50 - store multiple surfaces and then cycle
53:52 - through them for example we could have
53:54 - four Sprites like this and we we are
53:56 - simply going to play one after the other
54:00 - and that way we are getting an animation
54:02 - what is actually a bit more difficult is
54:04 - to get all of the data because for these
54:07 - animations we have to import a lot of
54:10 - data and this we cannot do manually so
54:14 - we want to create a couple of functions
54:15 - to mass import data and that is going to
54:18 - be the main part of this section as a
54:21 - matter of fact we already have a couple
54:23 - of functions ready but step by step
54:25 - first of all let's have a look at the
54:27 - project folder in there we want to look
54:29 - at graphics and for now we only care
54:32 - about the water animation and the coast
54:35 - animation I want to start by looking at
54:37 - the tile sets and in there we have a
54:40 - folder called water and then a graphic
54:42 - called Coast those two we want to work
54:45 - with and they are different styles of
54:47 - graphic if you look at the water folder
54:50 - we have four graphics and if you combine
54:52 - them you get a water animation besides
54:56 - that for the coast we want to import all
54:59 - of this and then take it apart if I make
55:02 - this full screen the way you want to
55:04 - think about all of this is we have a
55:06 - tile here a tile here a tile here and a
55:12 - tile here and if you play all of those
55:15 - in sequence so with 0o 1 two and three
55:18 - then you would get one Coast animation
55:21 - or this style of Coast if you then go a
55:23 - bit further to the right you can import
55:25 - all of the center tiles and get another
55:28 - kind of animation for the same Coast
55:30 - type but for a different section of the
55:32 - coast so when we are importing this
55:34 - graphic we have to take it apart and
55:36 - then store it in a way that is more
55:38 - easily usable that will be the most
55:40 - complicated part of this section
55:43 - although ultimately it's not going to be
55:44 - too hard back inside of the code I want
55:48 - to first of all go back to the Overworld
55:49 - meaning TMX map. world and the start
55:53 - position is going to be house if I now
55:56 - run the code we are back in the overw
55:58 - world and we can move around that still
56:00 - looks just fine with have that covered
56:02 - we have to talk about the Imports and
56:05 - for that we actually have already a
56:07 - python
56:08 - file so in my case I want to open up
56:12 - support.
56:14 - Pi in there we have five functions that
56:19 - take care of the Imports the first one
56:22 - is the easiest one this one simply
56:24 - Imports a single image and there are two
56:26 - things it simplifies number one when we
56:29 - are creating the path for the import we
56:32 - are using the join method meaning this
56:34 - is going to work across operating
56:36 - systems without a problem and on top of
56:38 - that we are also specifying a default
56:41 - format so when you're using this import
56:44 - image it's a bit easier to use than py
56:46 - game. image. load not terribly but it's
56:49 - a bit more convenient after that we have
56:52 - import folder and this one basically
56:54 - goes through a have and then Imports all
56:57 - of the images inside of that folder now
57:00 - for this function we are only storing
57:02 - the surfaces but if you want to retain
57:04 - the name you would look at import folder
57:07 - dictionary this one stores the file name
57:09 - and the actual Surface after that we
57:13 - have import
57:14 - subfolders this one goes through a
57:16 - folder with lots of subfolders and then
57:19 - Imports all of the images inside of each
57:22 - subfolder and finally we have import
57:25 - tile map This One Imports a tile map and
57:28 - slices it up depending on how many
57:30 - columns and rows we have now these
57:32 - functions I am not going to explain in
57:34 - too much detail because I have made a
57:36 - separate video on them so if you want to
57:39 - know all about them check out that video
57:41 - but for now I want to work with import
57:44 - folder because if you look at our title
57:47 - set folder inside of Graphics there we
57:50 - want to import the water folder this one
57:53 - simply contains four surfaces and we
57:55 - don't really care about the
57:59 - inside of main.py I first of all want
58:02 - from support import
58:06 - everything and then in the import assets
58:09 - method create another dictionary self.
58:13 - Overworld uncore frames for the key I
58:18 - want to go with water and for the value
58:21 - I want to use
58:22 - import underscore folder the function
58:26 - function I've just talked about this one
58:28 - and then we have to specify a path with
58:31 - comma separated values we want to go
58:34 - upper folder then we want to go to
58:38 - Graphics in there we have a folder
58:40 - called tile sets finally we have the
58:43 - water folder so the folder path we have
58:46 - just specified is upper folder Graphics
58:49 - title sets and water if I now run the
58:52 - code we not getting an error message
58:55 - that is a really good sign
58:56 - on top of that I could print self.
59:00 - Overworld frames and if I then run the
59:02 - code we are getting a dictionary with
59:05 - one key called water and the associated
59:07 - value is a list with surfaces these are
59:10 - going to be our water
59:12 - surfaces so this one is working just
59:14 - fine now we have to figure out how to
59:17 - display them and for that we will need a
59:19 - new type of sprite animated Sprite Which
59:23 - will need to inherit from the Sprite we
59:25 - have already created IE this Sprite will
59:29 - be the parent class of the animated
59:31 - Sprite Which means when we are creating
59:34 - the dunder init method with self we will
59:37 - need a position surface and groups to
59:41 - also satisfy the parameters of the
59:43 - parent class which we are doing by
59:45 - calling super Thunder
59:48 - init then pass in the position surface
59:51 - and groups that way we would simply
59:54 - duplicate the Sprite although that's not
59:56 - actually what we want to do instead of a
59:58 - single surface for animated Sprite we
60:00 - want to have a list of surfaces that I
60:03 - usually call frames and then when we are
60:06 - initializing the parent class so the
60:08 - Sprite I want to get frames and for now
60:11 - use the first item inside of the list
60:14 - now that is not going to create an
60:16 - animation but at least with that setup
60:18 - we will not get an error message so we
60:21 - can get started with this class right
60:23 - away which means next up inside of tiled
60:26 - we have to figure out where water
60:28 - actually is and for that we have another
60:31 - layer called water if I make this one
60:34 - visible you can see we have a whole
60:37 - bunch of
60:38 - objects that are going to Define where
60:41 - water
60:42 - is all of those are going to be
60:44 - rectangles in various sizes the way we
60:47 - are going to use them is we are always
60:49 - going to separate each area for example
60:51 - this would be one area that we are going
60:53 - to import a simple rectangle this we are
60:56 - then going to separate into three
60:58 - individual Parts this would be one this
61:00 - would be the second one and this would
61:03 - be the third one by that system we're
61:06 - getting the proper position for every
61:08 - water Animation Sprite Which means back
61:11 - inside of the code and I want to move
61:14 - support. Pi all the way to the right
61:17 - that just feels a bit cleaner next up
61:19 - inside of main. Pi in this setup method
61:22 - I want to add another section we can do
61:25 - that one all the way at the bottom for
61:27 - the water and there we want for obj in
61:31 - TMX map and then get layer by name the
61:35 - layer name is water and just to see what
61:38 - we are getting let me print
61:41 - obj do WID obj do height obj dox and obj
61:49 - do y if I now run the code we are
61:52 - getting a whole bunch of output so we
61:56 - have a lot of areas for the water but
61:59 - the way you want to think about it we
62:00 - always have triple values with an exp
62:03 - position a y position a height and a
62:07 - width these numbers we have to use to
62:10 - create the proper
62:11 - areas so what we want to do is first of
62:15 - all a for Loop where we are going
62:17 - through all of the x
62:19 - positions which we're getting for X in
62:23 - and then a range where we need a start
62:26 - position an end position and a step size
62:30 - imagine that this is the entirety of the
62:34 - map area and we for example have one
62:37 - Water Area
62:39 - here at the moment we want to splice
62:42 - this thing up into columns and rows
62:47 - something like this at the moment inside
62:50 - of our four Loop we are simply looking
62:53 - at the columns meaning we want to start
62:56 - here and there and then jump by these
63:00 - column sizes that would be our step size
63:04 - and also the easiest part that one is
63:06 - simply going to be the tile size we
63:09 - always want to move an increments of 64
63:11 - pixels also let me clean this one up a
63:14 - bit so we can see what's going on next
63:16 - up we have to figure out the start and
63:18 - the end position and those are going to
63:20 - be fairly simple because the start
63:22 - position is this one and the end
63:24 - position is this one
63:26 - which we can get with obj dox and this
63:30 - at the moment is a floating point value
63:32 - which the range function does not like
63:34 - meaning we have to convert this to an
63:36 - integer right away but that way we're
63:38 - getting the left side of the object area
63:41 - or other words this line next up we have
63:45 - to figure out the end point which is
63:47 - simply going to be the start point plus
63:49 - the WID of the entire area this one also
63:52 - has to be an integer we want to get obj
63:54 - dox which is the left side plus obj do
63:59 - wi that way we're getting the right side
64:03 - next up we have to do all of that for
64:05 - the vertical part so for y in range in
64:10 - obj doy that's the start then integer
64:14 - obj doy plus obj do height that would
64:19 - give us the endp point or the bottom of
64:21 - the rectangle area and finally for the
64:23 - step we want to use the tile size
64:27 - and now we have an XY position which we
64:30 - want to use inside of the animated
64:33 - Sprite the one we have just created
64:36 - although for that to work all the way at
64:38 - the top we have to import the animated
64:42 - sprite from
64:45 - Sprites that way we can use it and we
64:47 - have to pass in a
64:50 - position the frames and the groups the
64:55 - position is super easy that one is
64:56 - simply going to be X and Y the frames
65:00 - are going to be self. Overworld frames
65:02 - and water the one we have just imported
65:06 - this one and finally for groups we only
65:09 - have a single one self. all Sprites and
65:13 - now if I run all of this and move a bit
65:16 - down we can see the water and at the
65:18 - moment the water is on top of the player
65:21 - because we are creating it after the
65:23 - player that's going to be an issue we
65:25 - have to deal with later on but for now
65:27 - that is looking pretty good and by the
65:29 - way this black area between the sand and
65:32 - the water is going to be for the
65:33 - coastline that's the intentionally first
65:35 - of all though we have to create an
65:38 - animation for that I want to create two
65:41 - more attributes
65:43 - self. frame uncore
65:47 - index and self. Frames we can do all of
65:50 - that on a single line because the frame
65:53 - index is going to be zero and the frames
65:55 - are going to be the frames we are
65:57 - getting from the parameters these frames
66:00 - here self. frames is simply going to
66:02 - store the frames so we can reuse them
66:05 - and we are going to pick one frame via
66:07 - the frame index for example when we are
66:10 - initializing the parent class we don't
66:12 - want to have a static integer we want to
66:14 - have self. frame index which is not
66:18 - going to change anything this value is
66:20 - still zero but if we increase the frame
66:22 - index we would get a different kind of
66:25 - graphic
66:26 - that system we can use by creating an
66:28 - animate method which will need self and
66:31 - Delta time all that we are going to do
66:34 - in there is self. frame index plus equal
66:39 - some animation speed let's for now say
66:42 - four and this we have to multiply with
66:44 - Delta time that way all of the
66:46 - animations are going to be at the same
66:48 - speed regardless of the frame rate and
66:51 - that we can then use to update self.
66:54 - image for which we want to get self.
66:58 - frames and then pick one of the self.
67:01 - frame index
67:03 - values that however is not going to work
67:06 - for two reasons number one self. frame
67:09 - index after this line is going to be a
67:11 - floating point value remember Delta time
67:14 - is a really small value something like
67:17 - 0.004 if you add that to the frame index
67:20 - which at the moment is zero you are
67:21 - going to get a value that will not be an
67:24 - integer which we we have to fix right
67:26 - away by turning this into an
67:28 - integer that's the first issue after
67:31 - that we have to account for this number
67:34 - growing without any kind of
67:36 - constraint but we have a limited number
67:38 - of frames at the moment for water we
67:41 - have four animation frames so the frame
67:43 - index cannot exceed that and that we can
67:46 - Implement via modulus where we want to
67:49 - get the length of self dot
67:53 - frames that way if the frame index
67:55 - exceeds the length of the animation
67:57 - frames we are starting back from the
67:59 - beginning and that is all you need for
68:01 - the animation it's ultimately very
68:03 - simple all we have to do now is to
68:05 - create an update method with self and
68:08 - Delta time and then call anate or more
68:12 - specifically self. animate Biff Delta
68:15 - time that should be all we need if I our
68:17 - run made of Pi we have animated water
68:21 - and that is looking pretty good cool the
68:25 - only thing I want to change is instead
68:27 - of using this four I want to go to
68:29 - settings and then use the animation
68:32 - speed let's paste it in there and now
68:37 - main.py looks about the same but now we
68:40 - have more control over it or rather we
68:42 - know a bit more what's happening inside
68:44 - of this method this feels more readable
68:46 - that's the first part next up we have to
68:49 - work on the coast tiles for that we are
68:51 - still going to use the animated Sprite
68:53 - class but we have to figure out a few
68:55 - more things the first thing that we have
68:57 - to work on is what frames to use and for
69:01 - that let's have a look again at the
69:03 - graphic I talked about earlier this is
69:05 - what we want to import and then take
69:07 - apart so that we can use it for
69:09 - animations after that we need to figure
69:11 - out which of these tiles to play so do
69:13 - we want this grassland this inverted
69:16 - grassland the beach the snow or any of
69:19 - these other graphics on top of that we
69:22 - also need to know where to place that
69:24 - animation all of that you can find
69:26 - inside of til let's have a
69:28 - look at the moment we don't need the
69:31 - water anymore and we also don't care
69:33 - about the objects instead we want to
69:35 - look at the coast layer let me make this
69:37 - one visible and this is going to give us
69:40 - a whole bunch of object areas that all
69:43 - have the same size that part actually
69:46 - doesn't matter very much what we really
69:48 - care about is the X and Y position along
69:51 - with their custom properties there we
69:53 - have the site and the terrain the
69:55 - terrain should be fairly straightforward
69:57 - this one could either be sand or it
69:59 - could be something like up here where we
70:02 - have grass inverted and just to explain
70:05 - inverted if I maximize this all of these
70:09 - tiles would be the grass tile sets and
70:13 - all of those tiles would be grass
70:16 - inverted so with that we know where to
70:19 - place this tile and what kind of graphic
70:22 - we want which means we can now go
70:24 - through the entire process step by step
70:26 - and let's start with the Imports that is
70:29 - going to happen inside of support. Pi in
70:33 - there we already have one function that
70:35 - can import a tile map it's called import
70:39 - tile map for this one we have to specify
70:41 - the amount of columns rows and then a
70:44 - path that function we are going to use
70:47 - but we need a bit more extra
70:49 - functionality which means I want to
70:51 - create a function called Coast importer
70:55 - for which we are going to specify the
70:57 - amount of columns the amount of rows and
71:00 - then once again a path that information
71:03 - we are going to use right away to create
71:06 - a frin dictionary which will be the
71:09 - return value of import tile map let me
71:13 - copy it and then we have to pass through
71:16 - the columns the rows and then the path
71:20 - that we also want to unpack right away
71:23 - and just to make sure you see what's
71:25 - going on on let me print the frame
71:27 - dictionary right away after we have that
71:31 - I want to copy Coast importer and then
71:34 - inside of import Assets in the overbo
71:36 - frames we want to create post tiles
71:41 - which is going to store the return value
71:43 - from import
71:45 - folder for which we will need the
71:47 - columns the rows and the path to look at
71:50 - the graphic once again this one is going
71:52 - to have 24 columns and 12 rows
71:57 - it's a bit hard to see but basically
71:59 - every single one of these individual
72:02 - tile groups like one of those is going
72:05 - to be 3x3 tiles and we have eight of
72:08 - those in total and each of those has
72:12 - four
72:13 - iterations which means we have 3 * 8 on
72:17 - the WID and 3 * 4 on the
72:20 - height I.E 24 by 12 meaning 2 4 by 12
72:27 - and the file path is going to be a
72:29 - folder up then we want to go to Graphics
72:33 - then we want to go to tile sets and the
72:37 - actual file that we want to import is
72:39 - called Coast if I now run all of this P
72:44 - game is going to load for a second and
72:46 - then we are getting a pretty substantial
72:49 - dictionary so what happened here well we
72:53 - are getting a dictionary where each of
72:56 - the keys is a tall that has an X and A Y
72:59 - value or rather a column and a row value
73:02 - with the associated key being a surface
73:06 - what that means if I open up the graphic
73:08 - again all the way in the top left this
73:11 - first tile is going to have the key zero
73:14 - and zero if we then go one field further
73:18 - to the right this one we would have a
73:21 - column of one and a row of zero that
73:24 - would be the key for for this surface
73:27 - and this we're going to do for every
73:28 - single one of these tiles until we reach
73:32 - the end of the graphic which is going to
73:35 - result in this entire dictionary it is
73:38 - actually quite long that's a good start
73:41 - but not actually what we want what we
73:43 - instead want is a list with surfaces
73:46 - let's say this one then this one then
73:48 - this one and finally this one along with
73:52 - an appropriate name that is going to
73:54 - give us the position on the tile set and
73:57 - the kind of tile we are working with for
73:59 - that we are going to write a bit more
74:01 - logic inside of Coast
74:03 - importer first of all I want to create a
74:06 - new dictionary which for now is simply
74:09 - going to be an empty dictionary and then
74:11 - we're going to create a list of terrains
74:14 - for that value let me paste it in so you
74:16 - don't have to watch me type we're going
74:18 - to have a list with all of the types of
74:20 - terrain that we are working with I.E if
74:23 - I open the graphic once again the first
74:25 - tile set would be grass that is this one
74:29 - the second one would be grass inverted
74:31 - that's this one then we have sand
74:33 - inverted that's this one and we keep on
74:36 - going until we reach the end of the tile
74:39 - set after that we will need the sites
74:42 - that we are working with and for that we
74:44 - will need a dictionary that gets a bit
74:46 - more extensive so let me copy this one
74:48 - in as well it's going to look like this
74:51 - and this should happen over multiple
74:53 - lines I guess we can do do
74:56 - it like
74:58 - this that looks good for this one we are
75:01 - looking at the various sides of the
75:02 - coastline for example in the top left we
75:05 - have this part and that is zero and zero
75:09 - then we have the top which is going to
75:11 - be the one right next to it where we
75:13 - have column one and row
75:16 - zero however if we take another example
75:18 - the bottom right one this one would be
75:21 - the one in the bottom right where we
75:23 - have the second column and the second
75:25 - row the way you want to think about the
75:27 - sides is that we are looking at the
75:29 - first eight tiles or rather the first
75:31 - tile group and that can be really useful
75:34 - because if we are offsetting all of
75:36 - these numbers for example to go three
75:38 - columns further to the right then we are
75:40 - getting all of these tiles while still
75:43 - keeping the same top left the same left
75:45 - side the same bottom side and so on also
75:48 - in the description of this video I'm
75:50 - going to add a note with all of these
75:52 - values so you can copy them right in
75:54 - anyway after we have that we can work on
75:56 - the actual logic and essentially what we
75:59 - want to do we want to look for Terrain
76:04 - in uh Reigns The List we have just
76:08 - created although on this one we also
76:10 - want to know the index we are on which
76:13 - we get via enumerate and then we can
76:16 - expand the for Loop we want to have the
76:17 - index and the terrain which means what
76:20 - we're going to get is index and terrain
76:23 - let me print it run main. pi
76:25 - and we can see we get zero for grass one
76:28 - for grass inverted and so on after we
76:30 - have that inside of the new dictionary I
76:33 - want to create a new key which means I
76:36 - want to get the new dictionary and the
76:38 - new key is going to be the terrain which
76:40 - itself is going to have a value of a
76:43 - dictionary and this dictionary we're
76:45 - going to fill with key value pairs where
76:47 - the key is the S side and the values are
76:50 - the associated Graphics that we need for
76:53 - that we're going to need another for
76:54 - Loop for key and position in sites do
76:59 - items after we have that I want to work
77:02 - inside of the dictionary we have just
77:04 - created which we can now access via this
77:07 - value and then we want to create a new
77:10 - key value pair where the key is going to
77:12 - be the key I.E top left top top right
77:15 - and so on with the associated value
77:18 - being a list of frames those frames we
77:22 - are going to get from the frame
77:25 - dictionary the values we imported all
77:27 - the way in the beginning now this is a
77:29 - dictionary meaning if we specify a tupal
77:32 - with a column and a row we are going to
77:35 - get a value for example what we want to
77:38 - do at the moment we are inside of this
77:40 - for Loop and have some kind of a
77:42 - position let's say we have the top left
77:45 - that would be this top left tile from
77:49 - this tile we want to jump down three
77:52 - tiles to get this one then three more
77:54 - tiles to get this one then three more to
77:57 - get to this part these are the four
77:59 - tiles that we actually want to store
78:02 - which means first of all we need to
78:03 - figure out the row and that we can do
78:06 - via a for Loop and by the way we are
78:08 - going to use list comprehension I
78:10 - already started doing that we want to
78:12 - use for row in a range for this one we
78:17 - always want to start all the way at the
78:19 - top so zero then we want to go to the
78:22 - amount of rows that we have that's the
78:24 - number we have specified in the
78:26 - parameters for the step size we want to
78:28 - go with three that would almost give us
78:32 - the row the one thing we have to add is
78:35 - we want to get position one the position
78:38 - we getting from the for Loop and then
78:40 - add the row to it this position one is
78:44 - really important because in the top left
78:47 - we get a default value of zero so in
78:49 - there it's not going to do anything but
78:51 - if we are going to go a bit further down
78:53 - for example to bottom right there the
78:55 - start row is going to be two this we
78:57 - have to account for and after that we
79:00 - have to work with the column for which
79:02 - we once again will need a start position
79:05 - which is going to be position zero we
79:07 - want to add the index and multiplied
79:11 - with three the index is what we're
79:14 - getting from the enumerate of the parent
79:16 - for Loop if we are on grass this would
79:18 - be a zero if we are on grass inverted
79:21 - this would be one and so on that way if
79:24 - we are on grass has inverted the column
79:26 - wouldn't be zero anymore it would be
79:28 - three because we are multiplying one
79:30 - with the number three that is always
79:32 - going to give us the right column and
79:34 - with that we are done all we have to do
79:37 - now is at the end of the function
79:40 - return the new
79:43 - dictionary then we can work inside of
79:46 - the Overworld frames and print self.
79:50 - Overworld frames and we only care about
79:52 - the coast if I now run all of the is we
79:55 - are getting an error and that is a
79:58 - really easy one to fix I have simply
79:59 - made a typo inside of the dictionary
80:02 - let's try this again and there we go
80:05 - this is looking much better now we still
80:07 - have a massive dictionary but now the
80:11 - first key is going to be grass the
80:13 - associated value is a another a
80:14 - dictionary where the first key is top
80:17 - left and then we have a list of surfaces
80:20 - and those we can use for the animation
80:22 - that is a really good start now we just
80:25 - have to figure out how to use all of
80:27 - these Graphics that is going to happen
80:29 - inside of setup specifically after the
80:32 - water I want to have a section for the
80:34 - coast and figuring this part out is
80:37 - going to be your exercise I want you
80:39 - guys to use the coast tiles we have just
80:41 - imported to actually display the
80:43 - graphics all of that information you can
80:46 - get from the TMX map first the video now
80:49 - and see if you can figure this one out
80:50 - on your own
80:55 - we are going to need another for Loop
80:57 - for obj in TMX map doget layer by name
81:02 - the layer we want to work with is called
81:04 - Coast for each of those objects we want
81:07 - to get a Terrain and a side for that
81:11 - inside of til you want to look at the
81:13 - properties because there we literally
81:15 - have a side and a Terrain those values
81:18 - we can access via obj do properties and
81:22 - for the terrain we want to get the
81:24 - terrain and for the site we want to get
81:27 - the site finally we can create an
81:31 - animated Sprite Which is going to need
81:34 - three parameters position frames and
81:38 - groups groups is the really easy part we
81:41 - only have a single one all
81:44 - Sprites position is also fairly easy
81:47 - it's simply going to be a tuple with
81:48 - objx and obj doy the only thing that's a
81:52 - bit more complicated is going to be the
81:54 - frames for that we will want to get
81:57 - self. Overworld frames then we want to
82:01 - have the ter
82:04 - Rin and finally we want to have the
82:07 - right
82:08 - side and that's basically it if I now
82:11 - run all of this we are getting an error
82:15 - and I hope you can see the problem at
82:17 - the moment I am getting all of overbo
82:20 - frames that would be this dictionary
82:23 - which at the moment has only two Keys
82:25 - Water and Coast but I am trying to get
82:28 - the terrain right away to fix that what
82:31 - we have to add is first of all we want
82:34 - to get the dictionary coast and now this
82:37 - should work and now we have an animated
82:41 - coast line so that is looking pretty
82:43 - good now the coast is on top of the
82:45 - playup which looks a bit weird but
82:47 - that's an issue for later I think for
82:49 - now this is working pretty well and
82:52 - let's try and check the other
82:56 - Coastline should come up there we go
82:58 - this is looking pretty good so I am
83:02 - quite happy with that perfect I hope
83:04 - this section wasn't too complicated
83:06 - basically the Imports can get a bit
83:10 - confusing but ultimately when you're
83:13 - looking at this again we not doing
83:15 - anything fundamentally complicated we
83:17 - are simply writing in nested for Loop so
83:20 - I would really recommend to go over this
83:22 - thing a couple of times to make sure you
83:24 - understand it
83:25 - mastering list comprehensions and python
83:27 - is a really important skill and
83:29 - something you definitely want to
83:30 - practice for the next part we are going
83:32 - to start with the characters meaning we
83:35 - are going to animate the player and
83:36 - we're going to create all of the other
83:38 - characters they are not going to do
83:40 - anything and we have no collisions but
83:42 - at the very least we are making some
83:44 - solid progress now for the logic of this
83:47 - part the player and all of the NPCs
83:50 - share quite a few attributes meaning we
83:52 - can rely on inheritance where we have a
83:55 - parent entity class this one for example
83:58 - covers the animations and the setup of
84:00 - the character this will then be the
84:02 - parent class for the player and for all
84:04 - of the characters after that for example
84:06 - for the player we are going to capture
84:08 - user input and check collisions while
84:11 - for the characters they're going to get
84:12 - some other code for example to look
84:14 - around or for the dialogue should be a
84:16 - fairly straightforward section although
84:18 - before we get to any of that we have to
84:20 - do a few more
84:21 - Imports because if you look at the
84:24 - project
84:24 - in graphics there we have the characters
84:27 - and we have to import all of this let's
84:30 - get started with that part for that I
84:32 - want to work inside of import assets
84:35 - besides the water and the coast I want
84:38 - to have another key value pair which is
84:40 - going to be for the characters and
84:44 - essentially I want to have a function
84:46 - called all
84:48 - character import where we simply have to
84:51 - specify the parent folder which is going
84:53 - to be going one folder up then we are
84:56 - going to go to graphics and finally we
84:59 - want to go to
85:01 - characters that would get us to the
85:03 - folder I just talked about this one now
85:06 - this all character import doesn't exist
85:08 - at the moment so let me copy it and
85:12 - inside of support I want to minimize
85:16 - everything so we have a bit more space
85:18 - and then below the import tile map I
85:21 - want to Define all character import
85:24 - where we have to specify a path for this
85:27 - one like we have done with the coast
85:29 - tiles we want to create a new
85:33 - dictionary where for example we have a
85:35 - character like the player and then the
85:38 - associated value is going to be another
85:40 - dictionary for example one key could be
85:43 - called downcore Idol and this would be a
85:48 - list with a single surface so basically
85:53 - this is going to be our player and the
85:56 - down idle key is going to get a list
85:59 - with this surface only so if the player
86:01 - is facing down and not moving this is
86:04 - the animation we are going to play now
86:06 - since we have an animation with a single
86:08 - frame we are only going to play this
86:10 - individual frame so that's not going to
86:12 - do very much however another key that we
86:15 - are going to add could be for example
86:17 - down where we want to have a list of
86:20 - frames
86:21 - specifically we want to import the
86:24 - entire first
86:26 - row if you play all four of those frames
86:29 - in sequence you get a down walking
86:32 - animation that's all we have to do and
86:34 - by default I do not want to have any
86:36 - value inside of the new
86:38 - dictionary instead first of all I want
86:41 - to get all of the characters meaning I
86:43 - want to get all of those
86:45 - images to get that we could look at the
86:48 - other functions we have already in there
86:50 - for example if you look at import folder
86:52 - we have a for Loop for folder path
86:54 - subfolders and image names in the walk
86:57 - function this one simply walks through a
86:59 - folder and then gives you all of the
87:01 - content this is what we want to do as
87:03 - well for this one as a matter of fact I
87:06 - can literally copy this line and just to
87:09 - demonstrate what we are getting let me
87:12 - print the folder path the
87:16 - subfolders and we want to get the image
87:19 - names if I now run may not Pi we are
87:23 - getting some data
87:25 - the first entry is the folder name that
87:27 - we don't really care about because we
87:29 - already have that one then we get an
87:31 - empty list and this is what we're
87:32 - getting from the
87:34 - subfolders since in the folder we are
87:36 - currently looking at there are no
87:37 - subfolders we are getting an empty list
87:40 - returned that's also not a part we care
87:42 - about so we can just ignore it finally
87:45 - the only value that we really care about
87:47 - is image names that would be a list with
87:50 - all of the images inside of the folder
87:52 - or to be a bit more specific
87:54 - this is going to be a list with the name
87:56 - of every single file in that folder in
87:59 - our case it just happens to only have
88:01 - image
88:02 - files now this is the only value that we
88:05 - actually care about meaning I can
88:07 - replace the folder path with an
88:09 - underscore and the subfolders with a
88:11 - double underscore to indicate that I
88:12 - don't care about these values all I want
88:15 - to look at is the image names this is a
88:18 - list that I want to cycle through which
88:20 - we do before image in image names if I
88:24 - print the result we only care about the
88:28 - image we are getting the file name for
88:32 - every single one of these files this
88:34 - data I want to retain and use it as the
88:37 - key for the new dictionary although I do
88:40 - want to get rid of the PNG let's create
88:43 - a new local variable I guess we can call
88:45 - it image
88:47 - name which we're getting with image and
88:50 - then using this split method we can
88:53 - separate the string wherever we have a
88:55 - DOT and then only pick the first value
88:58 - that way we are getting rid of anything
88:59 - after the dot once we have that we can
89:02 - get the new dictionary and create a new
89:05 - key which would be the image name the
89:09 - value we want to assign to it is going
89:10 - to be another dictionary where for
89:13 - example we have a key with down and then
89:16 - a couple of frames along with it but
89:19 - this we can't do easily right now now
89:21 - you could use the import kle map
89:25 - function the one we already have and we
89:28 - know if you look at the folder or any of
89:31 - these Graphics we have four columns and
89:34 - four rows for every single one of the
89:36 - characters meaning we can get four and
89:40 - four along with a file path that file
89:43 - path we can get from the parameters the
89:46 - one all the way at the top along with
89:48 - the image name that we have created here
89:53 - if I now run m Pi we are not going to
89:55 - get an error and if I
89:59 - print self. Overworld frames with the
90:04 - characters I can run this again and now
90:07 - we are getting none that is because at
90:10 - the end of this function we are not
90:12 - returning anything so return new
90:16 - dictionary and now let's try this again
90:19 - that looks a bit better basically the
90:22 - first entry is called blonde
90:24 - and then we have all of the frames that
90:27 - we have gotten from the tile map
90:30 - importer then we get the second
90:32 - character fire boss and a similar kind
90:35 - of dictionary that's a good start but we
90:38 - have to organize this better inside of
90:41 - support. Pi I don't want to use import
90:44 - tile map so let me cut it out and
90:46 - instead I want to create another
90:48 - function that I called character
90:51 - importer where we are specifying rows
90:54 - and columns just as before and then we
90:56 - are assigning a
90:58 - path let me create that function right
91:00 - away actually define character importer
91:05 - where we have the columns the rows and a
91:08 - path inside of that function we are
91:10 - still going to use import tile map
91:12 - although now we are only going to need a
91:14 - path Because the actual path we are
91:17 - creating inside of all character
91:20 - import all we have to change is that
91:23 - instead of A4 we want to have the
91:25 - columns and the rows and then we should
91:29 - get roughly the same result if we are
91:33 - returning the values from this tile map
91:35 - function so so far we haven't really
91:38 - achieved anything but what we can now do
91:41 - is instead of returning the value right
91:43 - away I want to for now store it inside
91:45 - of a local variable called frame
91:47 - dictionary now this value we want to
91:49 - change quite a bit so I want to create a
91:52 - new dictionary which for now is going to
91:55 - be entirely
91:56 - empty and now to separate the graphics
91:59 - let's have a look at it if you look at
92:02 - the first row you can see that we are
92:05 - just moving down so on zero we get all
92:08 - the down animations then on the second
92:11 - row or Row one we are going to the left
92:14 - on the one with index two we're going to
92:16 - the right and on index 3 we are going
92:20 - up that information we can use right
92:22 - away inside of a for Loop you want to
92:25 - have for row and
92:29 - direction in a
92:31 - numerate and then we can add a tuple
92:34 - with the values down left right and up
92:41 - just to demonstrate what we are getting
92:43 - if I print the row and directions I can
92:46 - run main. pi and we are getting for
92:49 - every character zero down one left two
92:52 - right and three up meaning we're getting
92:54 - the right row along with the state of
92:56 - the character for that row that
92:59 - information we want to use to create a
93:01 - new key value pair inside of our
93:03 - dictionary which means new dictionary
93:06 - and the direction is going to be a list
93:09 - of frames where we are looking at our
93:12 - frame dictionary the one we are getting
93:14 - from import tile map and for this one we
93:17 - have to specify a tuple with a column
93:20 - and a row the row is the easy part
93:23 - because this is what we're getting from
93:24 - the for Loop that part we don't have to
93:26 - worry about the only thing we have to
93:29 - worry about is the column and for that
93:32 - part we can use the list comprehension
93:34 - once again because I want to go for
93:36 - column in range
93:39 - alss very much a similar thing compared
93:42 - to what we have done with the coast
93:43 - importer this stuff down
93:47 - here with that we are getting a new
93:49 - value inside of our dictionary so at the
93:52 - end of the function
93:54 - I want to return the new dictionary
93:57 - which we are capturing inside of this
93:59 - other dictionary which we are then
94:01 - storing inside of the Overworld frames
94:04 - in the characters key let me print the
94:07 - result self. Overworld frames we want to
94:10 - get the characters and now if I run all
94:12 - of
94:14 - this we don't need the output for the
94:17 - blond character we still have a
94:19 - dictionary but now the first value is
94:21 - going to be down with a list of surfaces
94:24 - there should be four in
94:26 - total those four and then we get the
94:29 - left movement there we have four more
94:31 - entries then we get right and so on that
94:34 - is looking really good but we want to
94:37 - have just a little bit more this is only
94:39 - going to give us the walking animation
94:42 - besides that I also want the idle
94:44 - animation which is always going to be
94:46 - the first frame of the walking animation
94:50 - for each individual Direction the way
94:52 - we're going to get that I want to get a
94:54 - new dick entry where we're going to get
94:57 - the direction but now this part is going
95:00 - to be inside of an F string where we are
95:04 - going to add underscore idle at the end
95:07 - the value for this one and this is
95:09 - really important has to be a list even
95:12 - though we are only going to add a single
95:13 - surface in there we still need to have
95:15 - this inside of a list that will simplify
95:18 - the animation logic a lot but other than
95:21 - that we want to get the frame dictionary
95:23 - again for which we have to specify a
95:25 - tuple with the column and the row the
95:29 - row once again we are getting from the
95:31 - four Loop and the column is always going
95:34 - to be
95:35 - zero and that is it if I now run m. Pi
95:40 - we get the dictionary printed out and
95:42 - you can already see at the bottom we're
95:45 - getting right idle that has a list with
95:48 - only a single surface inside and well
95:51 - then we have a whole bunch more Valu
95:54 - I am pretty sure that this is working
95:56 - well cool so with that we have done a
96:00 - lot of importing let's minimize this and
96:03 - now we can actually create the
96:04 - characters that's going to happen inside
96:06 - of entities. Pi in there all the way at
96:10 - the top I first of all want to create a
96:12 - class called entity that is the class I
96:15 - talked about in the beginning which will
96:17 - become the parent for the player and for
96:19 - all of the other
96:21 - characters for this one we we want to
96:23 - inherit from pygame dos sprite. Sprite
96:28 - we also want to create a thunder init
96:30 - method where we are specifying self then
96:33 - a position frames and the groups also we
96:38 - have to initialize the parent class
96:39 - which we do with super Dunder in it and
96:42 - pass the groups in there now this entity
96:45 - class will become the parent of the
96:47 - player which means the player shouldn't
96:49 - inherit from a Sprite it should inherit
96:51 - from the entity mean meaning we have to
96:54 - update the super Dunder init method or
96:57 - in other words we have to get a position
96:59 - frames and groups let me copy all of
97:02 - those parameters actually now position
97:04 - and groups are fairly straightforward
97:07 - we're getting those for the player right
97:08 - away via the dunder init method although
97:11 - frames we do not have at the moment to
97:14 - fix that the player's going to need
97:16 - another parameter frames which means
97:19 - inside of
97:20 - main.py when we are running the setup
97:22 - method and create the player that
97:25 - happens here we have to add another
97:28 - argument in there we want to get self.
97:32 - Overworld frames in there we have the
97:35 - characters which is going to be a
97:37 - dictionary on its own which has the key
97:41 - layer also I am running out of space and
97:44 - later on we're going to add more values
97:46 - into the player I want to use multiple
97:48 - lines and then named arguments we have
97:51 - the position we have the frames and
97:55 - finally we have the groups that is much
97:58 - more readable cool with that inside of
98:02 - entities we get all of the arguments for
98:04 - the player and to initialize the parent
98:06 - entity
98:07 - class which means if I run main.py the
98:11 - code runs just as before we are not
98:13 - using any of the data but at the very
98:15 - least the game doesn't crash so that's a
98:17 - good
98:18 - start next up then inside of the entity
98:21 - class we want to organize the animation
98:24 - or in other words I want to set up the
98:27 - graphics for that like in the animated
98:30 - Sprite we will need two attributes a
98:33 - frame uncore
98:35 - index and self. Frames the frame index
98:40 - will always going to be Zero by default
98:42 - and the frames are simply going to be
98:44 - the frames after we have that we can
98:47 - cover the actual Sprite setup for which
98:50 - we are going to need self. image and
98:53 - self do
98:55 - rectangle the image is going to be self.
98:59 - frames and from that we want to pick a
99:02 - single surface however that we can't do
99:05 - immediately because these frames are
99:08 - different compared to the frames we
99:09 - using inside of animated
99:11 - Sprite inside of that class frames are
99:14 - simply going to be a list with surfaces
99:17 - so indexing is very easy we simply have
99:19 - to specify a value like 0 1 or two and
99:22 - so on for entities this gets more
99:24 - complicated because this one has a
99:26 - dictionary where we have a state like
99:29 - down and only then do we get a list with
99:32 - all of the surfaces which means to get a
99:35 - single surface we first of all have to
99:37 - get the state of the animation and then
99:40 - we want to get self. frame uncore
99:44 - index I suppose to get started the state
99:46 - could simply be down for now although
99:48 - later on this we are going to change
99:51 - next up we have the rectangle this is
99:53 - quite simple self. image. getet F
99:57 - rectangle we want to set this Center to
100:00 - the position after we have that inside
100:03 - of the player since entity is already
100:06 - covering the image and rectangle the
100:08 - player doesn't need that part
100:10 - anymore let's try main.py and now we can
100:14 - see the player there's no animation yet
100:16 - but at the very least we have a basic
100:18 - graphic to animate all of that we have
100:21 - to create an animate method meod with
100:23 - self and Delta time for this one we want
100:27 - to get self. frame index and then plus
100:30 - equal the animation underscore speed
100:34 - multiplied with Delta time after that
100:37 - self. image needs to be updated where we
100:40 - are going to get self. frames then don't
100:43 - forget we will need the state and then
100:46 - we can pick one surface from the list of
100:49 - surfaces via the frame index which is
100:52 - going to happen basically in the same
100:54 - way compared to what we have seen inside
100:56 - of the animated Sprite class we want to
100:59 - get an integer with self. frame index
101:04 - then the modulus operator along with the
101:06 - length of self. frames although once
101:10 - again this is a dictionary to get the
101:12 - actual frames we need the state again
101:15 - cool that looks pretty good next up we
101:18 - need an update method with self and
101:20 - Delta time in which we are going to call
101:22 - self do animate with Delta time let's
101:26 - try out of that and nothing is
101:30 - happening the reason for that is that we
101:33 - don't actually have an entity class we
101:35 - have a player class and we are only
101:37 - calling the update method on that class
101:40 - or on the instance of that class meaning
101:43 - in there we have to call self. animate
101:46 - with Delta
101:47 - time we do not have to do that inside of
101:50 - the entity class what happened there is
101:52 - that we have this this update method
101:54 - inside of the entity class but since we
101:56 - also have an update method inside of the
101:58 - player this update method overwrites
102:01 - this update method we can actually get
102:03 - rid of it entirely it's not needed but
102:06 - if I now run main.py we get a walking
102:08 - animation we are only walking down so
102:11 - not amazing but at the very least we
102:13 - have something to actually have a proper
102:16 - animation we will need another method
102:18 - that I called get uncore State no need
102:22 - for custom parameter in this one and
102:24 - then there we basically want to get the
102:26 - state of the player I.E if the player is
102:29 - going down left right if the player's
102:31 - idle or not things like that and the way
102:34 - this function is going to work is we're
102:35 - going to have a whole bunch of logic and
102:38 - by the end of it we are returning the
102:41 - proper state for example this one could
102:43 - be right and then instead of always
102:46 - having a default value let me select all
102:48 - of them so all of the down values should
102:51 - instead be self. get underscore state
102:55 - with that if I run the code now the
102:57 - player is always walking to the
102:59 - right we could also change this to
103:02 - return right uncore idle then the player
103:06 - is always going to idle in the right
103:08 - direction that is looking pretty good
103:11 - now we just have to figure out the logic
103:13 - to make this get State interactive this
103:16 - get State needs to know in what
103:18 - direction The Entity is moving and
103:20 - that's actually a really good start this
103:22 - self. direction should be inside of the
103:25 - entity class not inside of the player
103:27 - let me add another section in there for
103:30 - the movement there we have self.
103:33 - direction also while we are here at the
103:35 - moment for the player we have a generic
103:38 - number for the speed this should be an
103:40 - attribute that we are going to store
103:42 - inside of the parent class self. speeed
103:46 - which can be 200 and 50 this self. speed
103:49 - we actually want to use for this move
103:52 - method
103:54 - that just feels a bit
103:55 - cleaner after that we have to figure out
103:57 - the logic for the get State method and
104:00 - the first issue we have to address here
104:02 - is that we only want to update the state
104:05 - if the player is moving which we can do
104:08 - by creating a local variable moving that
104:11 - is going to be the Boolean value of
104:13 - self. Direction the reason why this is
104:17 - necessary imagine that our player is
104:19 - moving and we are currently moving to
104:21 - the right and then we are stopping
104:24 - if that is the case we do not want to
104:26 - play the animation anymore but we still
104:28 - want the player to look to the right
104:31 - which means we want to store the last
104:33 - thing the player has done when he was
104:35 - moving and then use that information
104:37 - when the player is idling which we can
104:40 - do by only updating the movement
104:42 - Direction when the player is moving so
104:44 - when the player stops moving and we have
104:46 - been moving to the right then the player
104:48 - is still going to face to the right when
104:50 - we are
104:51 - idling I hope that makes sense I suppose
104:54 - to do this a bit more practically inside
104:56 - of the graphics I want to create another
104:59 - attribute self. facing underscore
105:03 - Direction by default this one could be
105:06 - down this is the value we actually want
105:09 - to update for example inside of get
105:11 - State we want to return an F string
105:16 - where the first value is always going to
105:18 - be the direction or self. facing
105:21 - direction to be a bit more precise
105:23 - but after that we want to add another
105:26 - value which is going to be empty if we
105:29 - are moving that way we would simply get
105:33 - down left right or up which is going to
105:35 - be the walking animation however if
105:38 - we're not moving so else then we want to
105:41 - add underscore
105:44 - idle that way if I run main. Pi we are
105:48 - currently not moving so the player is
105:50 - idling but if I start moving we are
105:52 - getting to walk in animation now this at
105:54 - the moment only works in a single
105:56 - Direction so not great but we are making
105:59 - progress what we now want to do is to
106:02 - check if the player is moving then we
106:05 - can check if self. direction dox is
106:10 - different from zero if that is the case
106:13 - we know we are moving on the horizontal
106:16 - axis which means self. direction is
106:20 - going to be right if we are moving to
106:22 - the right
106:23 - I.E if self. direction dox is greater
106:27 - than zero if that is not the case else
106:31 - we know we are moving left that we can
106:34 - already try if I now Run the game and I
106:36 - move to the right we are getting an
106:38 - error that the string object has no
106:41 - attribute X and I think I can see the
106:43 - issue so the error happened on this line
106:47 - but the actual problem happens on the
106:48 - next one because on this line we are
106:51 - overwriting self Direction which is
106:54 - supposed to be a vector where we get X
106:56 - and Y but we are now assigning a string
106:58 - to it either left or
107:01 - right this is simply a typo I meant to
107:04 - update self. facing Direction now this
107:07 - should be working if I move to the right
107:09 - or to the left we get the walking
107:11 - animation for that state so that's
107:14 - looking pretty good however down and up
107:16 - don't work
107:17 - yet that we can fix quite easily by
107:20 - simply duplicating this if St statement
107:23 - and check if self. Direction doy is
107:26 - different from zero it is going to be
107:29 - down if self. Direction doy is greater
107:32 - than zero and if that's not the case we
107:34 - are going
107:35 - up and now I can walk around and we are
107:40 - getting the proper animation for each
107:44 - Direction so that is looking pretty good
107:47 - that means we can minimize both of these
107:49 - methods and then we can start working on
107:52 - the other character s for that if you
107:55 - look at tiled we don't need the coast
107:57 - anymore and we only really care about
107:59 - the entities so let me hide everything
108:02 - else basically we have in the Overworld
108:05 - a whole bunch of markers some of these
108:07 - markers are going to be just for the
108:08 - player you can identify all of those via
108:11 - the name if the name is player we don't
108:13 - really care about them for this part we
108:16 - only care about the markers with the
108:17 - name character for those we also get a
108:20 - graphic Like Straw for example
108:23 - and this graphic is simply the file name
108:25 - for example straw would be this
108:28 - character on top of that we're getting a
108:31 - direction and this will be the starting
108:33 - direction of this character we have all
108:35 - the information we need to create a
108:36 - character so this is going to be your
108:39 - exercise create a new class for all of
108:41 - the characters and then display them via
108:43 - this class inside of the game with the
108:46 - correct start facing Direction the one
108:48 - that you're getting from til pause the
108:50 - video now and see how how you get
108:56 - first of all inside of entities. Pi I
108:59 - want to create another class called
109:02 - character which needs to inherit from
109:04 - The Entity class then we will need a
109:07 - thunder in it method self a position
109:12 - frames and groups later on we will also
109:15 - add the facing Direction in there but
109:18 - let's keep it focused for now next up we
109:20 - have to initialize the parent class with
109:22 - super thunder in nich and pass through
109:26 - the position frames and the groups now
109:30 - at this point we don't need to animate
109:32 - the characters meaning there's no need
109:34 - for an update method which makes our
109:37 - life a bit easier meaning next up inside
109:40 - of main.py inside of the setup method we
109:43 - want to look at all of the character
109:47 - markers we are already isolating the
109:49 - player if we add an else statement then
109:53 - we can print
109:55 - objname and let's see what we
109:59 - get we are getting mostly characters but
110:03 - there are some players in there that is
110:06 - because for this if statement we have
110:08 - two
110:09 - conditions which is not ideal let me
110:12 - take the second condition cut it out and
110:15 - then add an inner if statement we only
110:18 - want to create a player if obj name is
110:21 - player and we are on this starting
110:23 - position after that we can indent self
110:27 - the player one more time and now if we
110:29 - run this we are only getting characters
110:33 - that looks pretty good so now we can
110:35 - create an actual instance of the
110:37 - character class although for that first
110:40 - of all all the way at the top from
110:42 - entities we want to import the character
110:45 - and the character class next up for each
110:48 - character we're going to need a position
110:50 - frames and groups
110:53 - now these arguments are going to be
110:55 - fairly similar compared to what we are
110:57 - doing with the player hence we can
110:59 - literally copy all of the named
111:00 - arguments from the player so I have to
111:02 - write just a little bit less there we go
111:06 - now we have a character class with
111:08 - position frames and
111:10 - groups this is actually already going to
111:13 - work if I run the code we can see
111:14 - there's one NPC and if I go a bit
111:17 - further down here there we have another
111:18 - one there's one more and that's a good
111:21 - start but the graphic isn't right that
111:25 - is because we are always using the
111:26 - player graphic from the Overworld frames
111:29 - for this one I want to get obj do
111:32 - properties and then get a
111:35 - graphic let's thr off this again and now
111:38 - this is working much better we're
111:40 - getting a whole range of different
111:42 - characters so I am quite happy with that
111:46 - cool the last thing that we have to
111:48 - figure out is the start facing direction
111:50 - for each entity at the moment this one
111:53 - is always going to be downwards but that
111:55 - we want to customize via another
111:57 - parameter let's call it facing Direction
112:00 - and this value we are assigning to the
112:03 - self. facing Direction
112:05 - attribute that means when we are
112:07 - creating the characters and a player we
112:10 - have to add one more argument facing
112:13 - Direction which we are getting when we
112:16 - are creating this class so for the
112:19 - dunder init method for both of these
112:21 - classes we will need a another a
112:22 - parameter facing Direction once we have
112:25 - that we can work inside of main. Pi and
112:29 - to both of those class Constructors we
112:32 - want to add facing underscore
112:36 - direction if we set this one to right we
112:40 - should always have a right starting
112:41 - Direction so that is working pretty well
112:44 - cool to make this Mo interactive let's
112:47 - have a look at til in there when you
112:50 - look at the markers for the characters
112:52 - you can see that we have a direction
112:55 - this one for example should Face Down by
112:56 - default this one should face left by
112:59 - default and so on we got a few more this
113:01 - one for example faces up and then for
113:05 - all of the player starting markers we
113:07 - also have a direction which we can use
113:10 - this one would be down then we have one
113:12 - here for down as well and I think all of
113:15 - the markers in the Overworld are down
113:17 - but if you look at the hospital or the
113:19 - marker for the player the direction is
113:21 - going to be right although this this one
113:22 - should actually be up anyway you get the
113:26 - idea back inside of the code for the
113:30 - player we are currently working with a
113:32 - marker that's our object and on this one
113:35 - we can get obj do properties along with
113:40 - the
113:41 - direction the same thing we want to do
113:44 - for all of the characters it's actually
113:46 - the same property if I now run this
113:48 - again the player looks down by default
113:51 - this character looks to the left
113:53 - this character looks down and this
113:56 - character also looks down and if we go a
113:58 - bit further up then we should see a
114:00 - character looking up as
114:02 - well this one here and that is working
114:06 - pretty good cool so with that we have a
114:09 - pretty good start to all of the
114:10 - characters they don't do anything at the
114:13 - moment and we have no collisions but at
114:14 - the very least we are making some pretty
114:16 - solid progress so at this point we do
114:19 - have a basic level but there are a
114:21 - couple of things that could be improved
114:23 - and that is what we are going to work on
114:25 - in this section number one we are going
114:27 - to add all of the grass tiles those we
114:30 - are later going to use from Monster
114:32 - encounters but for now they're simply
114:34 - part of the Overworld number two is
114:36 - going to be a better drawing order that
114:39 - way we don't have trees on top of houses
114:40 - or the player below the water anymore
114:43 - and finally we're going to add
114:45 - collisions which is going to make the
114:47 - game feel significantly more realistic
114:50 - that should be fairly straightforward
114:51 - let's get started with the first point
114:53 - the monster grass patches for that we
114:56 - have to first of all look at til here we
114:59 - are and at the moment we only have the
115:01 - terrain visible on top of that we have a
115:04 - layer called monsters if you make this
115:07 - one visible we have a whole bunch of
115:09 - grass tiles also if you look at the top
115:12 - left there we have a few ice grass
115:14 - tiles also what is very easy to miss if
115:18 - you look at the beach and select this
115:21 - section there we have a bunch of beach
115:24 - tiles those are not going to be visible
115:26 - but we can use them to control where
115:28 - monster encounters happens when the
115:30 - players on the beach sadly there's no
115:32 - grass on the beach
115:34 - available but anyway if you look at one
115:36 - of these grass tiles you can see we have
115:39 - a couple of custom properties the biome
115:41 - the monster level and the Monsters
115:43 - available although for now this isn't
115:46 - really information that we care about we
115:48 - simply want to have the graphic that we
115:51 - can use inside of the code I want to
115:53 - work in the setup method and in there we
115:56 - can create below objects although the
115:58 - actual position is not going to matter
116:00 - in just a bit I want to add the grass
116:04 - patches for that we will need a for Loop
116:06 - for opj and TMX map doget layer by name
116:11 - the layer we want to look at is called
116:15 - Monster and I suppose for now we can
116:17 - simply create a Sprite for which we are
116:20 - going to need let me copy the parameters
116:22 - a position surface and
116:25 - groups position is super easy we have
116:28 - obj dox and obj doy for the surface we
116:32 - want to get obj do image and for the
116:35 - groups self. all Sprites if I now run
116:39 - main. Pi we are getting an error because
116:42 - this layer is called monsters if I now
116:44 - run the code you can see that we have
116:47 - the grass patches so that is looking
116:49 - pretty good and if you go all the way to
116:51 - the top left there should also be the
116:53 - ice grass
116:55 - patches there we go that is looking
116:58 - pretty good so we are making progress
117:01 - but it's still not ideal because there
117:04 - should be some overlaps and that is
117:06 - going to bring us very nicely to the
117:07 - next part that would be the drawing
117:09 - order so for example if you look at
117:12 - these two trees right next to the player
117:14 - the drawing order here is a bit messed
117:16 - up because the shadow of this tree is on
117:19 - top of this other tree the same same
117:22 - happens to this tree as well and if you
117:25 - walk a bit more around you can see that
117:27 - this is a very common
117:29 - problem you can see it here as well you
117:33 - can see it here in particular because
117:36 - the player is below the water and
117:38 - finally with the houses it becomes
117:40 - incredibly noticeable so on there the
117:43 - tree is on top of the house and the
117:45 - issue here is that at the moment we are
117:48 - sorting all of the Sprites by the time
117:50 - of their creation I.E the stuff that we
117:53 - are doing in the setup method which is
117:56 - not a reliable solution at all what is
117:59 - going to be a much better approach is to
118:01 - give each Sprite a layer and then when
118:03 - we display the game we are going layer
118:05 - by layer or in other words what we are
118:08 - going to do is we are first going to
118:10 - draw the water then we're going to draw
118:11 - the backgrounds and then we're going to
118:13 - draw the characters with all of the
118:14 - other objects like the houses and the
118:16 - trees now this system isn't terribly
118:19 - difficult to implement but there are
118:21 - going to be two
118:22 - complications number one is that each
118:24 - character should have a shadow and this
118:27 - we have to incorporate with the layout
118:28 - approach to
118:30 - drawing besides that there's one object
118:33 - that should always be on top of
118:34 - everything else and that is the top bit
118:36 - of the pillars or in other words if I
118:39 - run the game again and I go down a bit
118:42 - this pillar thingy here should always be
118:44 - on top of the player that way we can
118:46 - walk below it and it looks like there's
118:48 - a bit of threedimensional depth in the
118:51 - game so how can we start approaching
118:54 - this kind of problem and first of all if
118:56 - you look at settings there we have a
118:59 - dictionary code World layers this is
119:02 - going to define the drawing order I.E
119:04 - we're going to draw water first then
119:06 - we're drawing the background then we are
119:08 - drawing the Shadows then Main and then
119:10 - top because of that since water is drawn
119:12 - first everything else will always be
119:15 - drawn on top of it so what we need to
119:17 - get started is to tell each Sprite what
119:20 - layer it is on and for that inside of
119:23 - Sprites I want to give every single
119:26 - Sprite a z parameter which is going to
119:29 - get a default value we want to get the
119:32 - dictionary World layers the one I just
119:35 - talked about this one and by default a
119:38 - Sprite should be on the main layer so
119:42 - dictionary indexing and Main this value
119:45 - we now have to store as an attribute
119:47 - self. Z is going to be
119:50 - Z after that we also have to update the
119:53 - animated Sprite and for that I can
119:55 - duplicate the parameter and don't forget
119:58 - to pass it through to the parent class
120:00 - so we want to add Z in there as well
120:03 - with that we can store the Z parameter
120:06 - that means inside of the setup method we
120:09 - have to actually pass in that
120:12 - information when we are creating the
120:13 - terrain we want to have
120:17 - worldcore layers and those will always
120:20 - be BG our after that we can work with
120:23 - the water and with the coast because for
120:26 - those we have World layers and water and
120:30 - then we have for the coast World layers
120:34 - and BG and I realized while recording
120:38 - you could combine the water layer and
120:40 - the BG layer since they're both simply
120:43 - going to be in the background it's not
120:45 - going to make a massive difference but
120:47 - in practice this isn't going to make a
120:48 - difference although what I do want to do
120:51 - is to copy all of these lines and then
120:53 - move them up just a bit so we have the
120:56 - terrain the water and the coast all in
120:59 - one place like so you don't have to do
121:02 - that but it just feels cleaner all
121:04 - righty next up we have to cover the
121:08 - objects the grass patches and the
121:11 - entities and while we are here I
121:14 - realized the character objects do not
121:17 - have a z parameter this we have to fix
121:19 - right away and each entity should have a
121:22 - z parameter I suppose we can put it all
121:25 - the way at the top self do Z and this
121:28 - one is really easy because an entity
121:31 - should always be on the main layer World
121:34 - layers and we want to go with main no
121:38 - need for a parameter for this one that
121:40 - way we have finished the entities as
121:42 - well and the grass patches we don't have
121:44 - to touch those will always be on the
121:47 - main layer as well the one thing that we
121:50 - do have to care about is the object
121:51 - objects because for those we have to be
121:53 - a bit careful to understand why let's
121:56 - have a look at til and I want to look at
121:58 - all of the objects so in there we have a
122:02 - whole bunch of trees and houses and then
122:05 - random objects like the rocks and those
122:08 - pillars and the top
122:09 - thingy now basically all of the objects
122:12 - should be on the main layer with one
122:15 - exception and that is this top part this
122:18 - one should always be on top of
122:19 - everything else that way the player can
122:21 - walk below it and this object we can
122:24 - identify by its name it is called name
122:26 - top and this is unique no other object
122:29 - has any name which means inside of this
122:33 - for Loop for the objects we can add an
122:35 - if statement if obj dotame is equal to
122:41 - top if that is the case we want to
122:43 - create a Sprite that has all of the same
122:47 - arguments that we have used before so
122:50 - let me copy them and then add World
122:53 - layers with the layer at top however if
122:56 - that is not the case else then I want to
122:59 - create the Sprite we have already
123:01 - created later on for the collisions we
123:03 - have to add a bit more logic in here
123:06 - hence I do want to have a proper if
123:09 - statement anyway let's try and the game
123:12 - is still running as before but we do not
123:15 - have any update to the drawing method
123:17 - because so far we only added a single
123:20 - attribute it's not actually used yet for
123:23 - that we have to look at the groups
123:25 - because in here we are drawing
123:27 - everything this is the part that we have
123:29 - to refine and essentially I want to
123:31 - create three lists of Sprites I want to
123:34 - have the BG Sprites I want to have the
123:37 - main Sprites and I want to have FG
123:41 - Sprites after we have that inside of the
123:44 - for Loop for the actual drawing we're
123:46 - going to go through all of these lists
123:48 - and then draw them one by one I.E we're
123:51 - going to first draw all of the
123:52 - background Sprites then the main Sprites
123:54 - and then the FG Sprites because of that
123:56 - the FG Sprites will always be on top of
123:58 - everything and the main Sprites will be
124:00 - on top of the background Sprites for the
124:03 - background Sprites I want to use list
124:06 - comprehension with Sprite for sprite
124:09 - inself that way we are simply going to
124:11 - copy all of the Sprites inside of the
124:14 - class but there's going to be a
124:16 - condition I only want to get a Sprite if
124:19 - Sprite
124:20 - doz is smaller than
124:24 - worldcore
124:26 - layers and Main i e I want to get all of
124:30 - the background Sprites that come before
124:33 - the main layer we can do the same thing
124:36 - for the main Sprites because in there we
124:39 - simply want to check if we are on the
124:41 - main layer and finally for the FG
124:44 - Sprites we want to check if we are
124:46 - greater than the main layer that we can
124:49 - now use with another four loop I want to
124:52 - have four layer in the tupal BG Sprites
124:57 - main Sprites and FG
125:00 - Sprites and the order here is really
125:03 - important BG Sprites has to come first
125:06 - then we have main Sprites and then we
125:08 - have FG
125:09 - Sprites the for Loop is going to go
125:12 - through those in order and this is
125:14 - really important for our purposes once
125:16 - we have that we want to go through every
125:18 - Sprite inside of the layer and for that
125:21 - we already have have this for Loop we
125:23 - simply have to indent it remove the
125:25 - white space that should be all we need
125:27 - to get started if I now fix the extra
125:31 - character here and run main. Pi you can
125:35 - see that so far not much has changed
125:38 - however if I go a bit further down the
125:40 - player should at very least be below
125:42 - this part and that is working really
125:45 - well also if I now walk over the water
125:48 - the player is always going to be on top
125:50 - so that is working pretty pretty
125:52 - well we are definitely making progress
125:56 - and I hope the logic for all of this
125:57 - makes sense ultimately we are simply
126:00 - splitting up all of the Sprites into
126:02 - three separate groups and then draw the
126:04 - groups in order but we are not entirely
126:07 - done yet if I run the game again we
126:11 - still have this kind of issue where for
126:14 - example the trees are on top of the
126:16 - house this issue here that happens
126:19 - because this tree this tree and this
126:22 - house are all on the same layer meaning
126:24 - we still have the same issue that they
126:26 - are being drawn by the time of their
126:29 - creation it simply happens to be that
126:31 - this house was created first and then we
126:33 - created those two trees which means when
126:36 - we are creating the main Sprites layer
126:39 - we want to sort them in a different way
126:42 - which we can do with the python sorted
126:45 - method we just have to figure out a
126:48 - specific e to sort and by and let me
126:52 - talk about the logic here really quick
126:54 - imagine we have two characters although
126:57 - it could be any two objects for those we
127:00 - want to have a criteria to figure out
127:02 - which character should be drawn on top
127:04 - and which one should be drawn in the
127:06 - background and usually the best approach
127:08 - is to Simply use the vertical position
127:11 - we have the vertical center for the
127:12 - player and for the other character you
127:15 - put some actual numbers on this let's
127:17 - say the player centery is a 100 and for
127:21 - the other character it is
127:24 - 120 all we really have to do is to look
127:27 - at the largest number I.E the character
127:30 - has a greater white position so it
127:32 - should be drawn on top of the player
127:35 - that's literally all we have to do that
127:38 - way the further down an object is the
127:40 - later it is going to be drawn inside of
127:43 - python the key we want to assign is a
127:46 - Lambda function with one parameter that
127:49 - I usually call Sprite or and by the way
127:51 - what is going to happen in here the
127:53 - sorted method wants to have a list that
127:56 - we already have it will then go through
127:59 - every single element of this list and
128:01 - pass that element into this Lambda
128:03 - function or whatever function you
128:05 - specify from that Lambda function it is
128:07 - then expecting some kind of return value
128:10 - ideally some kind of integer all of
128:13 - those integers are then stored in the
128:15 - list and this list will be sorted from
128:17 - the lowest all the way to the highest
128:20 - value or in other words what we want to
128:23 - do this Lambda function is going to get
128:26 - a Sprite whatever Sprite we getting from
128:28 - the list and the value that we want to
128:31 - get from the Sprite is sprite. rec.
128:34 - Center y bya that system we are
128:38 - extracting all of the vertical Center
128:40 - points and then sorting them from the
128:42 - lowest to the highest value and well
128:46 - that's literally all we need for this
128:47 - part if I now run main. Pi again you can
128:51 - see that the trees look significantly
128:53 - better and if the player walks through
128:55 - the house at some point the player
128:58 - disappears and with that we have a much
129:02 - better looking game this feels
129:04 - drastically better also you can see with
129:06 - the grass
129:07 - patches they are starting to come
129:09 - together but we do have to refine things
129:11 - just a bit because something like this
129:14 - shouldn't happen in the game now to fix
129:17 - that we want to work inside of the
129:19 - Sprite
129:20 - class in there I will add another
129:23 - parameter self underscore let's call it
129:26 - y sort for now this can simply be self.
129:30 - re. Center y that way when we are
129:35 - sorting all of these Sprites we don't
129:37 - need sprite. rec. Center y instead we
129:40 - can simply get sprite. Yore sort
129:44 - although once again I forgot that we
129:46 - have to do the same thing for the
129:48 - entities I.E below self. z i also want
129:51 - to have self. Yore sort which is going
129:55 - to be self. re. Center y if I now run
129:59 - may not Pi we are getting an error that
130:03 - happens because when we are running this
130:05 - y sword erect does not exist yet we only
130:09 - create this one down there so I guess we
130:11 - have to move y sword all the way to the
130:15 - bottom with that I can run all of this
130:18 - again and now we are getting something
130:22 - weird the player is always on top of
130:24 - these Sprites but he will always be
130:26 - below all of the others so what happened
130:30 - here y sword is not being updated and
130:34 - when the player is moving around y sword
130:37 - is always going to remain the same that
130:40 - way the player sorting doesn't really
130:41 - work but for that for the player when we
130:45 - are updating everything first of all we
130:48 - can update self. y sword if I now run of
130:51 - this again the player should integrate
130:54 - much better and that is looking good
130:57 - also if we're now walking over the grass
130:59 - this is working perfectly fine again all
131:02 - righty so with that we haven't really
131:04 - achieved very much the game still looks
131:06 - the same but what we are able to do now
131:10 - is to customize this y sword or in other
131:13 - words we have a bit more control over
131:15 - what kind of sorting Behavior we have
131:17 - for example if you reduce the center Y
131:20 - for the Sprite by by 40 and run m. Pi
131:24 - again now this grass is going to overlap
131:27 - with the player much much faster which
131:30 - is going to look a lot
131:32 - better now for the other objects this is
131:35 - going to look a little bit weird but we
131:39 - are making some progress basically what
131:42 - we are going to do I want to have one
131:44 - kind of drawing Logic for the grass and
131:46 - then another drawing Logic for
131:48 - everything else and by drawing logic I
131:50 - simply mean mean that we have a
131:53 - different offset for the Y sword and for
131:56 - that I have actually created a whole
131:58 - another class although for now this
132:00 - isn't going to be the most useful part I
132:03 - want to have a monster patch
132:06 - Sprite Which has the Sprite as the
132:10 - parent which means in there we will need
132:13 - position surface groups and z and we
132:16 - don't need Z in the dund ended method of
132:19 - the class itself with that we can pass
132:22 - position surface and groups right
132:23 - through and Z at least for now is going
132:26 - to be World layers and
132:30 - Main and only in there do we want to
132:33 - update self.y sort and we simply want to
132:37 - reduce it by 40 pixels we don't need to
132:40 - do that in the original
132:42 - anymore and now inside of main. Pi when
132:46 - we are creating the grass I don't want
132:49 - to create a Sprite I want to create a
132:52 - monster patch
132:54 - Sprite although this we have to first of
132:56 - all import all the way at the top I want
132:59 - to import Sprite animated Sprite and
133:02 - monster patch Sprite let's try this one
133:05 - now and the grass is still looking much
133:08 - better but if I look at the other
133:10 - objects there the player disappears once
133:13 - we are behind the object and once we
133:15 - have collisions that is also going to
133:16 - look much
133:18 - better cool so with that we we have
133:22 - quite a nice overlapping Behavior
133:25 - there's just one issue we do have to
133:27 - work on and that is here we have the
133:31 - sand monster Sprites overlapping with
133:33 - the player and this shouldn't happen
133:36 - those tiles should always be behind the
133:38 - player that is an easy part to fix
133:41 - inside of Sprites dop when we are
133:43 - setting the Z layer for the monster
133:45 - patch Sprite it should only be main if
133:48 - we are on grass or ice grass
133:51 - if we are in the sand it should always
133:53 - be in the background now for that we
133:55 - have to know what kind of monster patch
133:57 - we have or in other words inside of til
134:01 - if we're looking at the monster layer
134:03 - again we want to look at the biome
134:06 - because in there we have have a forest
134:08 - we have sand or if you look all the way
134:10 - in the top left we have
134:14 - ice which means if we are on the sand
134:18 - layer we want to change the layer for
134:21 - the drawing now for that we will need to
134:24 - know the biome that will happen inside
134:26 - of main. pipe when we are creating all
134:29 - of the grass
134:32 - patches in there I want to get obj do
134:35 - properties and then the biome property
134:40 - with that inside of
134:42 - Sprites after groups I want to have a
134:45 - biome and for now let's simply print
134:48 - what we get so if I run m.p again
134:51 - we are getting sand ice and Forest and
134:54 - that is looking pretty good that
134:56 - information we want to store right away
134:59 - so self. biome is going to be biome that
135:03 - will become important later on although
135:05 - for now I simply want to update the
135:07 - world layers this one should be main if
135:12 - biome is different from Sand and if that
135:17 - is not the case then we want to have the
135:19 - BG layer
135:21 - let's run main notp again the game
135:23 - doesn't crash the overlapping still
135:25 - works but now there should not be any
135:27 - visible sand patches here anymore and
135:30 - there aren't so this is working
135:33 - perfectly well cool so with that we have
135:37 - the drawing logic that is going to work
135:39 - much
135:40 - better and ultimately the only really
135:43 - important part is inside of the groups
135:46 - because in there we are separating the
135:48 - Sprites via the world layer and then we
135:51 - are drawing the layers one by one that
135:53 - part alone will make the game feel
135:55 - significantly nicer that nearly finishes
135:58 - this part there's just one more thing
136:00 - that I would like to add and that is a
136:03 - shadow below all of the characters
136:05 - something like this a shadow below all
136:08 - of them now this Shadow needs to follow
136:10 - all of the characters in fact it needs
136:12 - to be in the same place and also it
136:15 - needs to respect the drawing order or in
136:18 - other words it has to be on top of all
136:20 - of the BG Sprites but below the main
136:23 - Sprites because in there we have all of
136:25 - the characters but let's go through it
136:27 - step by step first of all we will need
136:30 - an import and since the graphic is
136:32 - fairly simple we can do it right away
136:34 - and by the way what we want to import is
136:37 - inside of Graphics there we have I
136:39 - believe it's an other we have a shadow
136:42 - that is what we want to import let's
136:45 - save it as the attribute self.
136:48 - shadowcore surface and this we are going
136:50 - to import via support and import image
136:54 - which means from
136:56 - support I want to import import image
137:00 - then we are going to need a file path I
137:02 - want to go up a folder Graphics then I
137:05 - want to go to other and finally we have
137:10 - Shadow let's try to run main.py and the
137:13 - game is not crashing so the UT is
137:15 - working cool next up when we are drawing
137:19 - the entirety of the game we want to draw
137:21 - a shadow before we are drawing any of
137:24 - the entities I.E before we are drawing a
137:26 - player or a character the easiest way I
137:29 - think to approach this problem is inside
137:32 - of this for Loop to check if we have an
137:35 - entity and if that is the case before we
137:38 - are drawing the actual Sprite we're
137:41 - going to draw a shadow for that we have
137:44 - to do one more import I want from
137:48 - enti import entity
137:51 - or in other words I want to import this
137:55 - class that allows me before we are
137:58 - blitting the image to check if is
138:03 - instance the Sprite and the entity class
138:08 - if that is the case then we know the
138:10 - Sprite that we are currently getting
138:11 - from the for Loop is an entity which
138:14 - means it would be this entity it could
138:17 - be a character or it could be a player
138:19 - since character and player inherit from
138:21 - entity they would also fall into this is
138:25 - instance and if that is the case I want
138:27 - to get self. display surface and then
138:30 - blit self. Shadow
138:33 - surface after that we are just going to
138:35 - need the position let's go with sprite.
138:39 - re. toop left plus self.
138:43 - offset basically the same thing we have
138:46 - done right below if I now run main. Pi
138:49 - we are getting an error
138:51 - because inside of groups this shouldn't
138:53 - be entity this should be
138:54 - entities let's try it again and there we
138:57 - go now we have a shadow below all of the
139:02 - entities let's have a look at another
139:04 - one there we go so this is working but
139:07 - the shadow is in the wrong position now
139:09 - to fix the shadow we could do a couple
139:11 - of things we could create a rectangle
139:14 - around the shadow surface and then place
139:16 - the center or to keep things a bit more
139:18 - simple we could add another vector door
139:21 - 2 with a certain position I found that
139:24 - the numbers 40 and
139:26 - 110 work really well if I now run myp
139:30 - again the shadow is right below where
139:33 - it's supposed to be and that is working
139:36 - pretty well and now the game just feels
139:39 - a lot
139:40 - better and all of the other characters
139:42 - are also looking really good perfect so
139:46 - with that we have finally covered the
139:47 - entirety of the drawing order which
139:50 - means now we can work on the collisions
139:52 - and before we start working on the
139:54 - actual logic we need to do a bit of
139:56 - groundwork number one the player can
139:59 - collide with other characters the
140:01 - objects I.E houses and trees and rocks
140:04 - and with Collision rectangles those we
140:06 - are getting from
140:08 - tiled now the last part I do have to
140:10 - explain and let's do that in tiled right
140:13 - away here we are inside of tiles and at
140:16 - the moment we have the object layer and
140:18 - the entities layer don't those are what
140:21 - really matters at the moment and when it
140:23 - comes to Collision I think there are
140:25 - some fairly easy parts for example we
140:27 - want to have a collision with the tree
140:29 - we want to have a collision with the
140:31 - house or generally any kind of object we
140:33 - want to have a collision with on top of
140:36 - that if there is a character like the
140:38 - one here we want to have another
140:40 - collision with that one as well all of
140:43 - those are going to be fairly simple
140:44 - because they have a simple area that we
140:46 - can work with however what is going to
140:49 - be a bit more complicated
140:51 - are these Cliffy areas all of this stuff
140:54 - here because those don't really have a
140:57 - regular shape we could have one area
141:00 - here then we have another one here we
141:02 - have a weird one here all of those are
141:06 - kind of annoying to work with as a
141:08 - consequence to make our life a bit
141:10 - easier I created another layer that is
141:13 - called collisions and this one is full
141:17 - of let me isolate it it is full of of
141:21 - very small areas all of those are also
141:24 - going to be collidable and if you
141:26 - combine it with the terrain you can see
141:28 - that those collisions are basically
141:30 - there for all of the walls and the
141:32 - cliffs and things like that could also
141:35 - be a safety area like this one so the
141:37 - player cannot exit the window those are
141:40 - the three kinds of object that the
141:42 - player can collide with on top of that I
141:45 - want to have a Custom Collision size so
141:48 - at the moment this is our player
141:51 - and the rectangle around the player
141:52 - looks like this it is quite large since
141:56 - we imported the player via a tile set
142:00 - which I should probably
142:01 - explain here we have the graphics folder
142:04 - again and in there we have the
142:05 - characters with the player although this
142:08 - applies to all of the characters we are
142:10 - importing all of this and then we are
142:11 - cutting out one part for the player this
142:14 - would be the rectangle of the player
142:17 - which as you can see is quite large
142:20 - which for collisions is going to look
142:22 - really weird so what would be much
142:24 - better is a smaller rectangle for the
142:26 - hitbox that doesn't even cover the
142:28 - entirety of the player that way since we
142:30 - have an overlap these parts and these
142:33 - parts are going to give additional depth
142:35 - to the game which looks really good
142:37 - you're going to see in a second what
142:38 - that means in
142:39 - detail but first of all we have to get
142:42 - all of our areas I we have to get the
142:45 - player hitbox and the character hit
142:47 - boxes in general and then all of the
142:49 - collidable areas
142:51 - and I suppose we could start with the
142:54 - entities for all of those I want to
142:57 - create another attribute self. hitbox
143:01 - which is going to get self. wct do
143:05 - inflate and in case you don't know all
143:08 - that the inflate method does is it takes
143:10 - a rectangle and then expands it or
143:12 - shrinks it and all of that happens
143:15 - around a center point for example in my
143:18 - case I want to get Negative self. rec.
143:22 - wift divided by two this would be the
143:26 - horizontal size change and for the
143:28 - vertical one I want to go with 60 what
143:32 - is happening here is we are taking the
143:34 - original rectangle which would look
143:36 - something like this and then via the
143:39 - inflate method we are looking at the
143:41 - center point and then we are creating a
143:44 - new rectangle from these numbers for
143:47 - example self. rec. WID and this is
143:50 - negative really important so we are
143:51 - shrinking the new rectangle in this case
143:54 - we are getting half of the width of the
143:56 - original rectangle so the new rectangle
143:59 - would have a width of something like
144:02 - this and then on the vertical axis we
144:05 - have -60 so we are removing 30 pixels at
144:09 - the bottom and 30 pixels at the top at
144:14 - the end we have a rectangle that looks
144:16 - something like this and this rectangle
144:19 - is what we actually want to use for the
144:22 - collisions for that since the characters
144:26 - are not moving we can ignore them for
144:28 - now but for the player we have to make
144:31 - sure that when we are moving the player
144:34 - we are also updating the
144:36 - hitbox otherwise the hitbox would always
144:38 - remain in the starting position of the
144:40 - player which would obviously look very
144:42 - silly now luckily that part is fairly
144:44 - simple we simply want to get self.
144:47 - hitbox and place this Center to where
144:50 - ever self. w. Center happens to be and
144:55 - that is all we need for now if I now try
144:57 - to run main. Pi again the game doesn't
145:00 - crash that's a good sign but we can't
145:02 - really see the hitbox and I suppose
145:05 - that's okay for now we are going to make
145:07 - all of this a lot more visual in just a
145:09 - second first of all though we have to
145:12 - get all of the collidable objects those
145:15 - I want to store in another Sprite group
145:18 - I usually call this one self. Collision
145:21 - uncore Sprites and this one can just be
145:24 - a normal pygame dos sprite. group it is
145:28 - just there to identify all of the
145:30 - collidable Sprites so it doesn't have to
145:32 - actually do anything speaking of which
145:35 - when we are setting up the
145:38 - Overworld we have all of these objects
145:42 - the top one we can safely ignore this
145:44 - one is not going to have any Collision
145:47 - however for the Sprite we do want to
145:49 - have a cision because of that this
145:52 - Sprite will be in self. all Sprites and
145:54 - self. collision
145:56 - Sprites besides that the other
145:59 - collidable object is going to be the
146:01 - character meaning for the group or this
146:04 - one we have all Sprites and collision
146:07 - Sprites as well this would give us the
146:10 - objects and the characters that leaves
146:13 - us with the collidable areas those we
146:16 - first of all have to import I suppose
146:19 - the best place would be right below the
146:21 - object but for this one the position
146:23 - really does not matter we want to have
146:25 - the
146:26 - Collision objects as always for obj in
146:31 - TMX map. getet layer by name the layer
146:34 - name we're looking for is called
146:37 - collisions this Sprite that I want to
146:39 - create I called a border
146:42 - Sprite that is going to get a
146:45 - position a surface
146:48 - groups and that's all we need for this
146:52 - one now this border Sprite does not
146:55 - exist at the moment so let's create it
146:57 - by first of all importing it and then
147:01 - inside of Sprites below this Sprite I
147:05 - want to create a class border Sprite
147:07 - Which will inherit from the Sprite class
147:10 - then we need Thunder
147:13 - init with self position surface and
147:17 - groups we also have to initialize the
147:19 - parent plus with super Dunder in it and
147:23 - pass through the position surface and
147:27 - groups now those border Sprites are not
147:30 - going to be visible so the that layer
147:32 - doesn't actually matter we can just keep
147:34 - it with the main one the one really
147:36 - important thing that we have to add to
147:38 - this one is
147:39 - self.
147:41 - hitbox which for the Border Sprite is
147:43 - simply going to be self. w. copy we want
147:47 - to have for the hitbox the same size as
147:50 - the rectangle at least for the Border
147:52 - Sprite however later on when we are
147:55 - placing the objects so all of
147:59 - those we want to have a custom hitbox
148:02 - for the Sprites as well for now I am not
148:06 - going to do that because that way it's a
148:08 - bit easier to see what's going on but
148:10 - what we do want to do is we only want to
148:12 - check collisions between the
148:15 - hitboxes so all of the collidable
148:17 - Sprites will need a hitbox
148:20 - so inside of the Sprite class we also
148:22 - need self. hitbox which for now can be
148:25 - self. rec. hoopy so with that we have
148:29 - all of the hitboxes I think the last
148:31 - thing that we have to do is to actually
148:33 - add proper arguments in here for the
148:35 - position we want to have obj dox and obj
148:40 - doy for the surface we want to create
148:43 - pygame dot
148:45 - surface with obj do WID and obj do
148:51 - height finally for the groups this one
148:55 - is only going to be in self. Collision
148:59 - Sprites and that is really important if
149:01 - this Sprite was inside of all Sprites it
149:03 - would be
149:04 - visible which we really want to avoid as
149:07 - a matter of fact I can actually
149:09 - demonstrate I want to place this Sprite
149:11 - inside of collision Sprites and self do
149:14 - all Sprites on top of that when we are
149:18 - creating this surface there should be Pi
149:20 - game do surface and we have to add a
149:23 - tupal in there as an
149:25 - argument now the game should work and
149:29 - there you can see we have all of the
149:31 - Collision
149:33 - shapes that looks pretty good there we
149:36 - have a few more and those we can work
149:41 - with now obviously those we do not want
149:43 - to
149:44 - see hence Collision Sprites should not
149:48 - be inside of all Sprites rights that way
149:51 - if I run the
149:52 - game we can only see the actual objects
149:56 - so with that we have all of the
149:59 - collidable Sprites and those we have to
150:01 - make accessible inside of the player
150:04 - because only in there are we going to
150:05 - run Collision logic meaning I want to
150:08 - give the player another named argument
150:10 - Collision Sprites is going to be self.
150:12 - Collision
150:14 - Sprites after that inside of
150:18 - entities the players going to need
150:20 - another
150:21 - argument Collision underscore
150:25 - Sprites those we want to store as an
150:27 - attribute self. Collision Sprites is
150:30 - going to be Collision
150:32 - Sprites and now that we have that we can
150:35 - create a method to check
150:39 - collisions for the parameters we will
150:42 - need self and the AIS that we are
150:45 - looking at this could be either
150:46 - horizontal or
150:48 - vertical and before we continue let's
150:51 - talk about Collision Logic for the
150:54 - Collision we are first of all going to
150:56 - split the axis meaning we do first of
150:58 - all the horizontal collisions and then
151:00 - the vertical ones now the order does not
151:03 - matter but separating them is going to
151:05 - make our math a lot
151:07 - easier after we have that we are going
151:09 - to check for
151:11 - overlaps for example if we're doing this
151:13 - on the horizontal axis we have one
151:15 - object that we can collide with and our
151:18 - player so in the the current example we
151:21 - have an overlap on this side which would
151:25 - indicate that we have a collision on the
151:27 - right side of the player or the left
151:29 - side of the obstacle but this doesn't
151:32 - necessarily have to be the case because
151:34 - it could be that the player came from
151:36 - the right side and simply moved really
151:40 - fast the correct answer could also be
151:42 - that the player actually collided on the
151:44 - right side of the obstacle we simply
151:47 - don't know yet so we need one more piece
151:49 - of information which is going to be the
151:52 - direction of the player let's say if the
151:55 - player is currently moving to the right
151:57 - and we have a collision on the right
151:58 - side of the player then we know we are
152:01 - on this side that's kind of all we need
152:04 - to know so in other wordss the direction
152:07 - of the moving object tells us on which
152:09 - side the Collision happened now this is
152:11 - a very easy Collision method to
152:13 - implement it does however have the
152:15 - downside that it only ever works with
152:17 - one moving object which for this game is
152:20 - the case the only object that can move
152:23 - and Collide is going to be the player
152:25 - all of the other characters aren't
152:27 - really going to move or rather when they
152:29 - are moving we're going to block the
152:31 - player so they can never overlap
152:34 - although if you want to learn more about
152:36 - complex Collision behaviors check out
152:38 - this tutorial of mine it goes into much
152:40 - more detail or if you want to do all of
152:42 - this in practice I have also made a
152:44 - Mario Style platformer that is going to
152:46 - do a lot of collision logic anyway in
152:49 - inside of the Collision method we first
152:53 - of all want to go through all of the
152:55 - Sprites for sprite in. Collision Sprites
153:00 - after that we want to check if sprite.
153:04 - hitbox do Collide rectangle remember we
153:09 - only want to check the collision between
153:10 - the hitboxes of all of the Sprites so at
153:14 - the moment we are checking the hitbox of
153:16 - the Sprites and we want to check that
153:18 - against self dot hit box if that is the
153:24 - case we know we have an overlap as a
153:26 - matter of fact we can print that I want
153:28 - to print
153:31 - Collision this we want to call inside of
153:34 - the move method self. collisions we also
153:38 - have to add the axis and this one could
153:40 - for example be
153:42 - horizontal if I now run main. Pi by
153:45 - default nothing is going to happen but
153:47 - if we are overlapping with the house
153:49 - we're getting Collision the same would
153:51 - happen to the tree or any of these
153:53 - objects we always get a collision that
153:56 - is a really good start so now we know
153:58 - that we have an overlap but that's not a
154:01 - collision so basically once we have an
154:04 - overlap we want to resolve that overlap
154:06 - and place the player in the new position
154:09 - and for that we have to go through the
154:10 - logic I just talked about and the first
154:13 - step was to separate the
154:15 - axes which is also going to involve the
154:18 - movement
154:20 - which means in this case we want to
154:22 - update self. re. Center X and to this we
154:25 - want to add self. direction. X multiply
154:29 - it with self. speeed and Delta time
154:32 - after that the hitbox is also going to
154:34 - be updated to only include the
154:37 - horizontal movement and after we are
154:40 - doing that we are covering the
154:42 - horizontal collisions now this at the
154:45 - moment means that we can only move left
154:47 - or right there's no up or down movement
154:49 - which I think for now is okay so we can
154:52 - focus on one Collision
154:54 - axis the way we want to approach this
154:57 - one is inside of this if statement if we
155:00 - have an
155:02 - overlap we want to check if self.
155:06 - direction dox is greater than
155:10 - zero if that is the case we know we are
155:12 - moving to the right which means self.
155:16 - hitbox do WR is going to be sprite.
155:21 - hitbox do left the way you want to think
155:24 - about this one imagine we have the
155:26 - player and the player is moving to the
155:28 - right or in other words self. direction
155:31 - dox is greater than zero this means
155:33 - we're moving right and then we are
155:36 - overlapping with some kind of object
155:39 - that information we are getting from
155:41 - this line if that is the case we
155:44 - basically want to move the right side of
155:45 - the player and move it to the left side
155:48 - of the obstacle
155:50 - that way it looks like the player is
155:52 - stuck on this side and then we have an
155:55 - actual collision and that's literally it
155:59 - although at the moment there's one more
156:01 - thing that we have to
156:02 - do currently we are only updating the
156:05 - hitbox but what is actually displaying
156:07 - the player is the rectangle which means
156:10 - at the end of this line we have to get
156:12 - self. rec. Center X and set it to self.
156:16 - hitbox do Center x with that we should
156:20 - have a collision on the right side and
156:22 - if I move to the right that looks pretty
156:24 - good so we now have one side which means
156:27 - we only have to cover three more and
156:29 - then we also have to give all of the
156:31 - Sprites a smaller hitbox this part is
156:35 - going to be your exercise for this one I
156:38 - want you guys to first of all finish the
156:40 - other three Collision sides and on top
156:42 - of that create another class called
156:45 - collidable Sprite this one should be for
156:48 - all of the collidable objects
156:50 - I.E the trees and the houses and the
156:52 - Rocks this class is going to be
156:54 - basically identical to a Sprite with one
156:56 - major difference and that is that the
156:58 - hitbox should be 100% of the width but
157:01 - only 60% of the height with the same
157:03 - Center Point once we have that we should
157:06 - be done with the collisions so pause the
157:08 - video now and see if you can figure this
157:10 - one
157:14 - out I suppose we should start with the
157:16 - player or more specifically the player
157:19 - movement so that we can move around
157:20 - freely again I want to copy all of this
157:23 - for the horizontal logic and then change
157:26 - it to be vertical this should be self.
157:28 - re. Center y self. direction doy and
157:32 - then Center Y and Center Y and after
157:36 - that we want to do the vertical
157:40 - collisions that means inside of
157:43 - collisions we actually want to check if
157:46 - we have a vertical or a horizontal
157:48 - Collision for that we are going to need
157:50 - another if statement if AIS is equal to
157:55 - horizontal only if that is the case do
157:57 - we want to do all of this and if that is
158:01 - not the case else then we want to do
158:03 - something else let's say pass for
158:05 - now because on the horizontal Collision
158:10 - we have to check if the player is moving
158:12 - left or in other words if self.
158:15 - direction dox is smaller than zero then
158:19 - we want to set self. hitbox do left to
158:24 - sprite. hitbox do
158:27 - right and that is pretty much it next up
158:31 - for the vertical side I want to check if
158:34 - self. Direction doy is greater than zero
158:38 - that means we are moving down and if
158:40 - that is the case self. hitbox do bottom
158:44 - should be
158:46 - sprite. hitbox dotop
158:49 - finally and for this point I can simply
158:51 - duplicate these two lines I want to
158:54 - check if self. Direction doy is smaller
158:57 - than zero meaning we are moving up and
159:00 - if that is the case we want to check the
159:01 - top of the player hitbox and if there's
159:04 - an overlab we want to set it to the
159:07 - bottom of the colliding object and
159:10 - finally we want to update self. rec.
159:14 - Center y to self. hitbox do Center y
159:20 - that should give us proper movement
159:23 - again I can move in all directions and
159:25 - now we have collisions so there is the
159:28 - house there is a
159:31 - tree and we have a hospital we should
159:34 - also try the
159:36 - characters that looks pretty
159:39 - good and cool I am quite happy with that
159:44 - now there is a bit of an issue that I
159:47 - don't really like and that is let me
159:50 - find a single tree this
159:52 - one the collision with the tree happens
159:55 - right here or here on the side or here
159:58 - at the top and I think there is a bit
160:02 - too much of a space between these two
160:04 - objects or in other words the Collision
160:07 - side of the tree looks something like
160:09 - this and for the player the Collision
160:11 - hitbox looks something like this because
160:14 - of that we have just a little bit of
160:17 - overlap right here which which is
160:19 - looking really good and I want to have
160:21 - more of that and to get that we want to
160:24 - reduce the size of the hitbox of the
160:26 - tree to make it something like this in
160:29 - fact for the tree you could even create
160:31 - a smaller horizontal hitbox so you get
160:35 - this part for an overlap as well which
160:37 - is probably going to look really good
160:39 - but that you can do in your own time
160:41 - what I want to do when we are creating
160:44 - the objects that we can collide with all
160:47 - of those I want to create a
160:51 - collidable Sprite that does not exist at
160:55 - the moment so once again we want to from
160:58 - Sprites import the collidable
161:03 - Sprite and then inside of Sprites we
161:06 - have to create that class since it's
161:08 - going to be fairly similar to The Border
161:09 - Sprite let me copy this one and then
161:13 - create a collidable Sprite nearly done
161:17 - the last thing that we have to do is for
161:20 - the rectangle we don't want to create a
161:22 - one toone copy instead we want to use
161:27 - inflate to keep 100% of the width and
161:31 - 60% of the height which means for the
161:34 - width we want to have zero pixels in
161:36 - change but for the height we want to get
161:40 - Negative self. wct do
161:44 - height and multiply it with 0.4
161:49 - that way we are reducing 40% or 20% at
161:52 - the top and 20% at the
161:55 - bottom and now if I run M do PI let's
161:58 - move back to the tree this one over
162:01 - there now we get quite a bit more
162:03 - overlap I think it's easier to see here
162:06 - now the player is much more behind the
162:07 - tree and I think we could push this even
162:10 - more inside of Sprites let's go with
162:14 - 0.6 and see how good that is going to
162:16 - look so let's try this tree we are quite
162:20 - close to the center but I think it's
162:22 - working fairly
162:24 - well let's try this one and yeah now we
162:28 - get a ton of overlap which is actually
162:30 - looking pretty
162:32 - good and yeah I am quite happy with this
162:34 - one but once again play around with the
162:37 - numbers and just see what looks good on
162:38 - your end either way we have finished
162:42 - another important part although before
162:44 - we finish up there's one more thing that
162:46 - I do want to cover and that is if the
162:49 - player is simply moving left and right
162:51 - we have one kind of speed the same if we
162:54 - are moving up and down however once the
162:57 - player starts moving in the diagonal
162:59 - direction we actually moving quite a bit
163:01 - faster and this is a noticeable change
163:04 - so I think you can see it fairly
163:06 - well the reason why the player is moving
163:09 - faster when we are moving diagonally is
163:12 - because inside of the input this line
163:15 - here we are not normalizing the input
163:18 - vector if our direction is one and zero
163:22 - I.E we are moving to the right if that
163:25 - is the case our speed is just going to
163:27 - be one multiplied by whatever speed we
163:30 - have which is totally fine however if
163:33 - our direction is one and one so we are
163:37 - moving right and down then the actual
163:40 - movement is actually going to be
163:42 - 1.4 multiplied by the speed that we have
163:45 - simply because we are moving on two axes
163:48 - via speed speed and those two add up
163:51 - together the way around that is to
163:53 - normalize the vector that way we are
163:56 - setting the length of the vector always
163:57 - to one all we have to do is to use the
164:01 - normalize method this however if I run
164:04 - the code is not going to work we're
164:05 - going to get an error right away that we
164:08 - cannot normalize a vector of length zero
164:11 - and that should actually make sense if
164:13 - you think about it imagine you are
164:15 - Python and we are telling python that we
164:17 - have an arrow that looks like this or
164:21 - like this we are moving to the right or
164:23 - we are moving down and right all that
164:25 - normalize is going to do is it takes
164:27 - this vector and it sets the length of it
164:29 - to one so if we're going down and right
164:32 - or simply right it is always going to
164:34 - work but now imagine we have a vector
164:37 - with zero and
164:39 - zero this thing doesn't really move in
164:42 - any direction it's simply a point hence
164:45 - python cannot set the length of this
164:47 - thing to a one it's simply not possible
164:49 - it doesn't know which way to go as a
164:51 - consequence we are getting an error now
164:54 - the way around that is fortunately
164:55 - fairly simple we simply want to check if
164:58 - we have an input Vector if this Vector
165:01 - is zero and zero which it is by default
165:04 - then we want to do something else which
165:06 - in our case is going to be the input
165:09 - Vector on its
165:11 - own if I now Run the game again I can
165:13 - move left right up down and if I move
165:16 - diagonally we still get the same speed
165:19 - which feels much more
165:22 - consistent well and with that we have
165:24 - made a whole bunch of progress for the
165:26 - game now we actually have a proper
165:29 - Overworld and the player cannot leave
165:31 - the game anymore oh and also I didn't
165:33 - mention for the beach we have
165:36 - collisions so there's no way for the
165:38 - player to see the black background of
165:40 - the map
165:42 - perfect so at this point we have
165:45 - basically finished the Overworld which
165:47 - means next up we can start working on
165:48 - the dialog tree that way the entire game
165:52 - is starting to become interactive and to
165:54 - get the dialogue system we Broly need
165:57 - two things number one we have to check
166:01 - if dialogue is available in the first
166:03 - place and number two once we have that
166:05 - we need some kind of dialog tree system
166:08 - I'll buy a fairly simple one first of
166:11 - all we have to check if dialogue is
166:13 - available in the first place and this
166:15 - will involve a couple of things first of
166:18 - all we we want to check if the trainer
166:20 - and the player are on the same axis for
166:23 - example if this is the trainer we want
166:26 - to check if the player is roughly on
166:29 - this Axis or on this Axis or in other
166:32 - words if the player is for example here
166:35 - or here or here or here only then should
166:39 - the player be able to talk to this
166:40 - character after we have that we want to
166:43 - make the entities face each other that
166:45 - should be fairly straightforward then we
166:47 - have to block player movement and then
166:49 - we can start the actual dialogue none of
166:52 - this should be too difficult so let's
166:54 - Jump Right In back in the code first of
166:57 - all we have to get access to all of the
166:59 - trainers easily and for that I want to
167:02 - create another Sprite group on the
167:04 - groups I can duplicate the Collision
167:06 - Sprites because besides that I want to
167:09 - have a character sprites Group which
167:12 - like the Collision Sprites doesn't have
167:14 - to do very much it's simply there to get
167:16 - easy access to all of the characters
167:18 - when which means when we are creating
167:21 - all of the characters which happens down
167:24 - here we have to place them in three
167:27 - groups all Sprites Collision Sprites and
167:30 - self. character sprites that's all we
167:33 - need in here next up inside of the
167:37 - Overworld I want to check input as well
167:40 - at the moment the only input that we
167:42 - have is inside of the player class to
167:44 - move the player itself but I also want
167:47 - in the actual main game class have an
167:50 - input method let's place it right above
167:53 - run I want to check for input no need
167:56 - for custom parameters on this one and
167:59 - just as before I want to get all of the
168:02 - keys which we are getting with pame
168:05 - dokey
168:07 - doget
168:08 - rest and the key I care about is keys
168:12 - and pame Dot aore space and if I spell
168:17 - this correctly this could also work much
168:19 - better now if the player presses the
168:22 - space button I want to print for now
168:25 - dialogue now don't forget to run this
168:28 - method that is going to happen before we
168:31 - are doing anything else self. input now
168:34 - if I run all of this we getting an error
168:37 - because this should be key and Dot get
168:42 - pressed if I now press space we getting
168:44 - dialogue that means input is working but
168:47 - it's not working as intense it because
168:50 - even though I only pressed space once we
168:52 - got dialogue a few hundred times that is
168:55 - because of the frame rate all that py
168:57 - game really checks is if this button is
168:59 - pressed and then it prints dialogue and
169:02 - this happens on every frame of the game
169:04 - in our case our frame rate is probably
169:06 - around 2 to 300 meaning this method runs
169:09 - way too often and we getting way too
169:11 - much output if we had actual dialogue
169:15 - and we press space then we would skip
169:17 - dialogue 200 times so that's not ideal
169:20 - and there are broadly two ways to get
169:22 - around this number one you could create
169:25 - a timer that after Keys was pressed we
169:28 - have to wait let's say half a second to
169:30 - press the button again could be
169:32 - implemented and later on we are going to
169:34 - do something like that but for now an
169:36 - easier way of solving this is get just
169:40 - pressed if I now Run the game and I
169:43 - press space we only ever get a single
169:46 - dialogue output essentially get just
169:49 - pressed is only going to return newly
169:51 - pressed Keys which for any kind of UI
169:54 - work is incredibly useful so that is
169:57 - what I'm going to use also get just
169:59 - pressed is a pame c feature if you're
170:02 - using traditional py game you would get
170:04 - an error at this point so do be careful
170:06 - and make sure you have the most recent
170:08 - version of py game anyway after the play
170:12 - has pressed space we want to check if we
170:14 - are close to one of the characters for
170:16 - that we will need four character
170:19 - in self. character sprites this would
170:23 - give us all of the characters and
170:25 - basically what we want to do is we want
170:27 - to check the
170:30 - connection now this check connection is
170:32 - going to involve two parts imagine this
170:35 - is the trainer and this is the player
170:38 - first of all what we want to check is
170:40 - the distance between the two I.E if the
170:42 - player is within a certain radius of the
170:45 - character these two entities should only
170:47 - be able to interact if they are close
170:49 - enough should be fairly straightforward
170:51 - and on top of that we want to check if
170:53 - they are roughly on the same axis I.E if
170:57 - the player is either roughly here let's
170:59 - say with a margin of error or on this
171:02 - axis now this kind of check connection
171:05 - we are going to reuse a couple of times
171:08 - meaning I will keep this as a function
171:10 - and then actually keep it inside of
171:12 - support So in there let me minimize
171:15 - everything and all the way at the bottom
171:18 - I want to have some game functions while
171:21 - all the other stuff is import
171:25 - functions which means in here I want to
171:27 - have a function check uncore
171:31 - connections the same function we are
171:33 - using here and in there I want to have
171:36 - three arguments the radius the player
171:40 - and the character radius for this is
171:43 - always going to be 100 and player is
171:47 - going to be self. player
171:49 - after that inside of support we want to
171:51 - have a radius we need an entity and we
171:56 - will need a Target also we can set a
172:00 - tolerance that by default is going to be
172:02 - 30 pixels inside of this function first
172:05 - of all I want to get the relationship
172:07 - between the entity and the target which
172:10 - we can do via vectors very easily I want
172:12 - to get the vector of target. rect do
172:16 - Center and from that that subtract the
172:19 - vector of entity. rect do Center if this
172:25 - is our current entity and we have a
172:29 - Target their relation would be an arrow
172:32 - pointing from the center of one to the
172:34 - center of the other like this which is
172:36 - already really useful because on this
172:38 - thing we can get the length and then
172:39 - check how far apart these two entities
172:42 - are which we actually are going to do
172:44 - right now I want to check if relation
172:49 - do length is smaller than the radius if
172:54 - that is the case for now I want to
172:56 - return
172:57 - through and if we don't return anything
173:00 - this function is going to return none
173:02 - which is going to be
173:03 - falsy hence we only need a single return
173:06 - value now with that inside of main. Pi
173:09 - we can check if these two entities are
173:12 - nearby and if that's the case only then
173:15 - do I want to allow the dialogue output
173:17 - meaning now if I run all of this again I
173:19 - press space and we are getting an error
173:23 - because this should be check connections
173:25 - let's try it again if I press space
173:27 - nothing happens but if I get close to
173:29 - this character I can press space and we
173:31 - are getting dialogue I can move away if
173:34 - I press space nothing happens but if I
173:37 - get to this other character I can press
173:39 - space and we are getting dialogue once
173:40 - again so this is working really well
173:43 - that means next up we can work on the
173:45 - second part where we are checking if the
173:48 - player and the character are on the same
173:50 - horizontal or vertical axis now to
173:53 - understand how this is going to work
173:54 - imagine once again we have the player
173:57 - and we have the target with an arrow
174:01 - between the centers of these two
174:03 - ultimately all that we really have to
174:05 - check to for example test if those two
174:07 - are on the same horizontal axis we
174:10 - simply need to know the height of this
174:13 - line if it is below 30 then we know it
174:18 - is inside of the tolerance although we
174:21 - do have to be careful because below 30
174:23 - could be any negative number which means
174:26 - what we actually want to check is the
174:29 - absolute value of relation doy if that
174:33 - value is below the tolerance only then
174:37 - do we want to return
174:38 - true with that I can run main. Pi I can
174:42 - press space nothing happens if I am on
174:44 - the left side of the character we are
174:46 - getting dialogue but if I go on top I
174:49 - can press space and nothing is going to
174:51 - happen because of the collisions this is
174:53 - a bit hard to see let me try another
174:56 - character this one so at the moment I'm
174:59 - on top of the character I can press
175:01 - space nothing is going to happen but if
175:03 - I am on the side we're getting dialogue
175:06 - so the system is working so this is kind
175:09 - of working but at the moment it looks a
175:11 - bit weird because the player is facing
175:14 - downwards and what I would rather want
175:16 - to check is if the player is is on the
175:19 - same horizontal axxis and if the player
175:22 - is facing the
175:24 - opponent only if those conditions are
175:26 - met as well then I want to allow
175:28 - dialogue now we do know which direction
175:31 - the player is facing that we are getting
175:33 - from get State we have a facing
175:36 - Direction this we want to use again
175:38 - which means what we actually want to
175:40 - check is first of all if entity dot
175:46 - facing underscore
175:49 - direction if that is for example left
175:53 - then we know the player is facing left
175:55 - on top of that we want to check relation
175:58 - dox is smaller than
176:02 - zero that way we know the player is
176:04 - facing to the left and we are to the
176:06 - right of the opponent and then finally
176:10 - we are also on the same horizontal plane
176:14 - only if these three conditions are met
176:16 - then I want to allow dialogue so at the
176:17 - moment
176:18 - we should only be able to talk to an
176:20 - opponent if we are on the left side and
176:24 - if we are facing that character so for
176:25 - this one there's no way to talk to her
176:27 - at the
176:28 - moment but if I go to the other
176:31 - character and I'm on the right side and
176:33 - I'm facing left I am getting a dialogue
176:36 - but if I am on any other side it doesn't
176:39 - work and if I'm facing the wrong way we
176:42 - also do not get a dialogue but if I'm
176:44 - facing her and the other conditions are
176:46 - met then we are getting a working system
176:48 - system cool so with that we have one
176:50 - side this we just have to expand a bit
176:53 - to cover the other sides as well for
176:55 - that I can actually just copy all of
176:59 - this because we only have to change a
177:02 - few things for the second line I want to
177:04 - check if we are facing right then we
177:06 - want to check if we are currently on the
177:09 - left side of the opponent and we still
177:11 - want to check if we are on the same
177:13 - horizontal plane that's the next part
177:16 - after that we have to do up and down
177:18 - I want to check if we are let's start
177:21 - with facing up then we want to check if
177:24 - relation doy is smaller than zero and we
177:28 - want to check if relation. x the
177:31 - absolute value is smaller than the
177:34 - tolerance nearly done the last thing
177:36 - that we have to cover is going to be if
177:39 - the player is facing down relation doy
177:44 - is greater than zero and the tolerance
177:47 - part is still just fine that should
177:49 - actually be all we need so we don't need
177:51 - the or at the end anymore and for once
177:54 - let's try a different character this one
177:56 - I can talk to him from this side from
178:00 - this
178:01 - side from this side and from this side
178:05 - but if I face another way or I am
178:09 - diagonally compared to him we are not
178:11 - getting a dialog so that system is
178:14 - looking to be working pretty good cool
178:17 - that also covers the check connections
178:20 - function we are going to reuse it later
178:22 - on but for now this is all we need from
178:24 - this one we want to block ler input
178:28 - after that we want to make the entities
178:30 - face each other and then finally we can
178:35 - create the dialogue to go through it
178:38 - step by step let's start with blocking
178:39 - the player input for that we have to
178:42 - work inside of the entities and let me
178:44 - minimize all of this so it's a bit
178:46 - easier to see inside of the entity under
178:49 - movement I want to add another parameter
178:53 - self. locked which by default is going
178:56 - to be false on top of that I'm going to
178:59 - create two more methods Define block
179:03 - with self which is going to set self.
179:07 - blocked to through and on top of that
179:10 - self. direction is going to become a
179:13 - vector with zero and zero that is
179:17 - definitely going to stop
179:19 - player on top of that I want another
179:21 - method unblock with self and all that
179:25 - this one is going to do is self. blocked
179:28 - is going to be
179:29 - false with those attributes in place I
179:33 - can look at the player input essentially
179:37 - what we want to do if the player is
179:39 - blocked we don't want to allow any input
179:42 - and we also do not want to allow
179:43 - anything inside of the move method which
179:46 - means inside of update
179:49 - these two methods should only run if not
179:53 - self. blocked I suppose we could put
179:56 - animate in there as well it's not really
179:58 - going to make a difference with that we
180:01 - can go back to main.py and then if
180:03 - there's a connection self. player. block
180:08 - let's try and if I talk to this
180:13 - character the player cannot move anymore
180:16 - although you do get some weird Behavior
180:19 - we simply stopped mid animation so
180:23 - actually I was wrong this animate does
180:26 - care about being inside of self do
180:27 - blocked if we take it out of it and try
180:30 - all of this
180:32 - again now we are getting the player
180:35 - blocked and we also getting back to the
180:37 - default State let's try this one again
180:40 - just to make sure it wasn't an accident
180:44 - with that we can block the player next
180:46 - up we want to make the enti face each
180:48 - other or in other words if the player
180:51 - talks to this Buck catcher the buck
180:53 - catcher should start facing the player
180:56 - for that we want to get the character
180:59 - and then call a function change
181:02 - underscore facing uncore
181:05 - direction for which we will need a
181:07 - Target position which will be self.
181:09 - player. rec. center now this method
181:13 - doesn't exist right now and we want to
181:15 - create it inside of the entity class it
181:19 - is going to be used both for the player
181:21 - and for the
181:23 - characters let's place it right below
181:26 - get State Define change facing Direction
181:30 - with self and a Target position like we
181:34 - have done with check connections we
181:36 - first of all want to get the relation
181:38 - between the Target and the current
181:40 - character the same thing we have done
181:42 - here I can actually just copy the line
181:45 - although we do have to update it because
181:47 - now the tar Target is going to be the
181:49 - target position and instead of entity.
181:53 - rec. Center we want to have self. re.
181:56 - center after that we want to check if
181:58 - they are on the same horizontal plane if
182:01 - absolute relation
182:03 - doy is smaller than 30 if that is the
182:08 - case we have to decide if we're going to
182:10 - face right or left in either case we
182:13 - want to update facing Direction and
182:16 - let's say by default we are going to go
182:18 - with right that should already work at
182:21 - least for One Direction if I now talk to
182:24 - this guy nothing is going to happen that
182:27 - is because this change. facing direction
182:31 - is being called but inside of the
182:33 - character simply nothing is going to
182:35 - happen the character never
182:37 - updates so it doesn't really matter what
182:39 - this attribute is doing it's not being
182:41 - used inside of the character all we need
182:43 - to fix that is Define update with self
182:47 - and Delta time and proper
182:50 - spelling and then call self. animate
182:54 - with Delta time the character already
182:57 - has the animate method because this one
182:58 - is part of the entity class if I now try
183:02 - this again we should be seeing an update
183:06 - and there we go this is working really
183:07 - well so next up let's finish up this
183:11 - method we only want this character to
183:13 - face right if the player is to the right
183:16 - of it or in other words if relation dox
183:21 - is greater than zero if that is not the
183:23 - case else it should be
183:26 - left after that we want to check if the
183:30 - player is on another plane I.E on the
183:33 - vertical one if that is the case self.
183:36 - facing direction is going to be let's
183:39 - say down by default if relation do y is
183:43 - greater than zero if that is not the
183:46 - case else it should be f facing up and
183:49 - with that let's try another character
183:52 - and make her face down that is working
183:56 - well and one more attempt let's try the
183:59 - character down
184:02 - here and she is facing up so that seems
184:05 - to be working just fine cool so finally
184:09 - we can start working on the actual
184:11 - dialogue which we want to initiate with
184:13 - create dialog a method we have to create
184:17 - let's do it right below Define create
184:21 - dialogue for the parameters we want to
184:23 - have self and the character which means
184:26 - when we are calling this create method
184:28 - we have to pass in the character that we
184:31 - currently have after that we want to
184:33 - create a dialogue tree class that is
184:37 - going to get the character it is going
184:40 - to get self. player it will need self.
184:44 - Sprites so we can show things and then
184:47 - it is also going to need a font now the
184:50 - font we don't have at the moment and
184:52 - that's the easiest part to fix after we
184:54 - have that we can create the actual class
184:57 - but let's first of all import some fonts
185:00 - that is going to happen inside of import
185:03 - Assets in there I want to have another
185:05 - dictionary self. FS now later on we are
185:10 - going to have quite a few key value
185:11 - pairs for now though I only want to have
185:13 - one for the dialogue which we create
185:16 - with py game. font do font then we will
185:19 - need the join method for the path and I
185:22 - want to go up a folder then I want to go
185:24 - to
185:25 - Graphics in there we have a folder
185:28 - called fonts and in there we have a file
185:31 - called pixel lloy ss. ttf for the font
185:37 - size I want to go with 30 now if I run
185:40 - the game we are not getting an error
185:43 - message so that is looking really good
185:45 - with that we have a font and that we
185:47 - want to paste into the dialogue tree
185:49 - right away which we do with self. fonts
185:52 - and we want to have the dialogue font
185:55 - next up we have to actually create this
185:58 - dialogue tree for that I want to create
186:00 - a new python file that I saved as dialog
186:05 - dopy as always we will need from
186:07 - settings and we want to import
186:10 - everything after that we can create a
186:13 - class called dialogue tree no need for
186:16 - inheritance and then inside of the
186:19 - dunder init method we have to cover all
186:22 - of the arguments I just talked about
186:24 - these ones here we want to have a
186:26 - character we want to have the player we
186:29 - want to have all Sprites and then we
186:32 - want to have let's call this one simply
186:34 - the font all of those need to become
186:37 - attributes so self. player is going to
186:39 - be player self do character will become
186:44 - the character self. font will become the
186:48 - font and self. all Sprites will be all
186:52 - Sprites with that the game is not going
186:54 - to crash anymore once we are talking to
186:56 - a character but fundamentally we're not
186:58 - really doing anything so how can we
187:01 - actually display some text for each of
187:02 - the characters well first of all for
187:05 - that we have to get some data and for
187:07 - that we need to import a file I haven't
187:10 - really talked about yet that one is
187:12 - called game data which is a massive
187:15 - dictionary so let me hide everything for
187:19 - now we only want to look at trainer data
187:22 - and this is a giant dictionary with the
187:25 - data for all of the trainers in the game
187:27 - and if we look at the first one 01
187:30 - stands for Overworld one in fact if you
187:33 - look at all of the entities inside of
187:35 - the
187:36 - Overworld I believe the first character
187:39 - is this one yeah this one is called 01
187:42 - or in other words via the character id
187:45 - we're going to associate this marker in
187:47 - the tile map with this entry inside of
187:50 - trainer data now in there we have quite
187:53 - a bit of information we have the
187:55 - monsters of this character we have the
187:57 - dialogue options we have the looking
187:59 - around directions and if the player
188:01 - looks around I.E if this character is
188:04 - looking out for the player then we're
188:06 - checking if this player was defeated and
188:08 - what biome he is in that could be Forest
188:11 - sand or a bit further down we have ice
188:13 - as well like this one now that is quite
188:17 - a bit of data and I suppose before we
188:20 - continue we have to get this data into
188:23 - the character class I.E inside of
188:25 - entities we have to get all of the data
188:28 - into this thing here for that I want to
188:31 - create another parameter character data
188:35 - for now I suppose let's simply print
188:38 - what we are
188:39 - getting after that inside of main.py
188:43 - when we are setting up the entirety of
188:46 - the Overworld
188:48 - inside of the characters we will need
188:50 - another named argument
188:54 - character data now the value from this
188:57 - one we are getting from game data this
188:59 - one and there we have trainer data
189:02 - although I suppose a better name would
189:03 - be character data but I guess both work
189:06 - just fine and from this dictionary we
189:08 - want to pick one item which we're
189:11 - getting via obj do
189:14 - properties the property we want to look
189:17 - at is called character uncore id or in
189:21 - other words this character id I just
189:23 - talked about if I now Run the
189:26 - game we are getting trainer data is not
189:29 - defined that's an easy thing to fix all
189:32 - the way at the top we need from gamecore
189:36 - data import everything now let's try
189:39 - this again and there we go we are
189:43 - getting the data for all of the trainers
189:45 - for example for the first trainer we
189:47 - have monsters then we have the dialogue
189:51 - options they start here we have
189:53 - directions defeated biome and so on that
189:56 - looks really good this character data we
189:58 - do want to store as an attribute self.
190:02 - character data is going to be character
190:04 - data on top of that I want to create a
190:08 - method for get dialogue no need for
190:11 - custom parameters and then we want to
190:14 - return the data for this character
190:17 - although this could be one of two
190:19 - options if you look at game data for
190:22 - example trainer 01 has a dialogue option
190:25 - for default and for
190:27 - defeated we want to get the right option
190:29 - depending on the character being
190:31 - defeated or not which means we want to
190:35 - return self. character data and the
190:41 - dialogue but then we want to create an F
190:44 - string which is going to be the defeated
190:48 - if self. character
190:51 - data is indeed defeated if that is not
190:55 - the
190:57 - case so else then we want to get default
191:01 - inside of game data we are simply
191:03 - checking if this value is true or false
191:06 - oh and by the way it's really important
191:08 - to keep all of the data inside of this
191:11 - dictionary I.E later on once the
191:13 - character is defeated this value changes
191:16 - we do not keep that data inside of this
191:19 - class that is important later on because
191:22 - when the player changes the map for
191:24 - example to go from an arena back to the
191:26 - Overworld then we are going to recreate
191:28 - this class and any attribute would be
191:31 - reset so we cannot keep data in here it
191:34 - wouldn't be persistent anyway with that
191:37 - we have get dialogue this we can use
191:39 - inside of the dialogue because in there
191:42 - we have the character so we can print
191:45 - character and get under score dialogue
191:49 - let's try this one if I now talk to the
191:52 - blonde girl we are getting an error that
191:55 - dialog tree is not defined that is quite
191:58 - fixable I want from dialogue import
192:02 - dialogue three let's try this again and
192:06 - if I talk to her one more time we're
192:09 - getting one more error that we are
192:11 - taking four positional arguments but
192:13 - five were given that is because I forgot
192:16 - self in there
192:18 - next
192:19 - attempt and there we go we are getting
192:24 - an actual dialogue output and I realized
192:27 - I was really bad with consistent
192:29 - quotation marks but doesn't really
192:31 - matter I suppose we should try another
192:34 - character this one here and this one
192:38 - also has a
192:39 - dialogue that looks pretty good cool
192:42 - next up instead of Simply printing the
192:45 - dialogue I want to store it as an
192:48 - attribute
192:50 - self. dialogue I suppose works on top of
192:54 - that I also want to have self. dialog
192:57 - number which is simply going to be the
192:59 - length of self. dialogue and finally I
193:03 - want to have self. dialog index which by
193:07 - default is always going to be
193:09 - zero once we have all of that I want to
193:13 - create self. Curren uncore dialogue
193:17 - which is going to be a dialogue Sprite
193:20 - this one doesn't exist just yet but we
193:22 - are going to create it in just a second
193:25 - for that we want to have a message we
193:28 - want to have the trainer we want to have
193:30 - groups and we want to have a font this
193:33 - dialog Sprite is what will actually
193:34 - display the message let's create it
193:37 - right away plus dialog Sprite Which has
193:42 - to have a parent of pygame Dos sprite.
193:45 - Sprite
193:47 - there we want to
193:49 - initialize the class with the message we
193:53 - want to display the trainer the groups
193:56 - and the font with that we can add actual
193:59 - arguments into this class for the
194:01 - message I want to have self. dialogue
194:05 - and then pick one of the options with
194:07 - self. dialog index trainer is quite easy
194:11 - this one should be self. character and I
194:13 - suppose I should always call this
194:16 - character groups is super easy this one
194:18 - is simply going to be self. all Sprites
194:21 - and for the font we want to have self.
194:23 - font we only have a single one inside of
194:27 - the dialogue Sprite then first of all we
194:29 - want to have super Dunder init and
194:33 - initialize the
194:36 - groups we will also need self. Z which
194:39 - is going to be World underscore layers
194:44 - and these Brides should always be on top
194:47 - after that we have to create the actual
194:50 - text I want to have a text underscore
194:54 - surface which we create with self. font.
194:58 - render we want to render the message
195:02 - nlas should be fults and the colors
195:05 - we're getting from settings in there we
195:07 - have a colors
195:09 - dictionary which means inside of
195:11 - dialogue I want to get colors and for
195:14 - this one I want to have a black color
195:17 - so that would give us the text surface
195:20 - but what we actually need is self. image
195:24 - I suppose for now we can simply set the
195:26 - text surface to the image just so we
195:28 - have something but this we do have to
195:30 - change anyway next up we want to create
195:33 - self.
195:34 - rectangle which will be self. image.
195:39 - getorf
195:40 - rectangle where we are placing the mid
195:43 - bottom to character do rect do mid up
195:49 - and we could add a bit of an offset
195:51 - let's say Vector 0 and
195:54 - -10 that should give us something if I
195:57 - now run main. pi and I talk to the girl
196:01 - we are getting an error message that we
196:03 - do not have a font that is because this
196:05 - font is not an attribute let's try this
196:10 - again and there we go I don't like sand
196:13 - we are getting one dialogue output now
196:16 - unfortunately it doesn't look
196:18 - particularly good for that inside of
196:21 - dialogue we have to work more with the
196:23 - Sprite the problem that we have to fix
196:26 - is that the image is simply going to be
196:28 - a text surface hence we have no
196:30 - background whatsoever after we are
196:32 - creating the text surface I want to set
196:35 - the width and the height of the
196:38 - background both of those should be
196:40 - basically the Tex surface and then we
196:42 - add some padding to it that padding by
196:44 - the way should probably be a local
196:47 - variable padding and I went with five
196:50 - pixels but simply choose what you like
196:52 - the most for the WID we want to get the
196:55 - text surface and then get
196:58 - underscore WID this would give us the
197:00 - width of the text
197:02 - surface this we want to increase by
197:06 - self. padding multiplied by two I.E this
197:11 - is our text and we want to have padding
197:13 - to the left and to the right and we're
197:15 - multiplying padding with two
197:17 - now there's one more thing that I do
197:19 - want to do and that is to set a minimum
197:22 - width which I'm doing with Max and then
197:25 - 30 that way our width is either 30
197:29 - pixels or the text width that's the
197:32 - padding which every one is larger that
197:35 - way even if we don't have much text we
197:37 - always have a bubble that is noticeable
197:39 - for the height we have to do something
197:41 - fairly similar I want to get the Tex
197:44 - surface then get underscore
197:47 - height and to that I want to add self.
197:51 - padding multiplied by two there's no
197:55 - need to set a minimum height like we
197:56 - have done for the width because the
197:58 - height is always defined even if we only
198:01 - have a single character we always
198:03 - getting a sufficient amount of height
198:05 - next up we can create the
198:09 - background this is going to be a surface
198:13 - which we are creating with pame do
198:15 - surface for the two BS I want to have
198:18 - Whi and height and for now I want to
198:22 - fill the surface with a color self. fill
198:24 - color then I want to get my colors and
198:28 - the bubble color should be a pure white
198:31 - one of the colors we are specifying
198:33 - inside of settings this one this surface
198:36 - will then become the surface we are
198:39 - actually going to
198:40 - display which is a good start but with
198:43 - this system we're not going to see the
198:45 - text anymore we are simp getting a
198:47 - surface with the same size as the
198:50 - text which means we have to put the text
198:53 - on the surface which we do with serve.
198:57 - blit I want to blit the text surface in
199:01 - the center of this surface I want to get
199:04 - the text surface and then get F
199:07 - rectangle where we are setting the
199:10 - center to the center point of this
199:13 - surface or in other words we're getting
199:15 - the width and the height and the div
199:16 - either of those values by two we have a
199:19 - tuple with width divided by two and
199:23 - height divided by two and that should be
199:27 - it although I did realize that this
199:30 - shouldn't be self do padding it should
199:31 - just be pading because pading is a local
199:35 - variable if I now go to the character
199:38 - and I can talk to him we are getting a
199:41 - speech bubble that looks pretty good
199:43 - although it is very blocky that happens
199:47 - because this surface is simply going to
199:49 - be a rectangle and we are going to fix
199:52 - that by adding another argument pame do
199:55 - SRC Alpha that way we can set an alpha
199:59 - value for the surface and by default I
200:02 - want to fill the surface with well
200:05 - nothing I.E a tupo with z z and zero for
200:09 - RGB this value doesn't actually matter
200:11 - because we are going to specify another
200:13 - value for Alpha which is zero so we
200:16 - going to see anything of the
200:18 - surface let's try this one
200:22 - and there we go now we cannot see the
200:25 - background anymore which is totally fine
200:28 - because before we are drawing the text I
200:30 - want to go with py game. draw. rectangle
200:34 - I want to draw on the surface I want to
200:37 - draw with colors and pure white the
200:41 - rectangle I want to draw is surface and
200:44 - get F rectangle
200:47 - where we can set a top left of 0 and
200:51 - zero that way we are simply covering the
200:53 - entire surface with a rectangle so far
200:57 - that isn't going to do very much but
200:59 - what we are now able to do is specify
201:01 - two more arguments a border width of
201:04 - zero and then a corner radius of
201:07 - four with that if I run my Pi again and
201:11 - I talk to a
201:12 - character we are getting rounded Corners
201:15 - so that is looking pretty good and I
201:16 - suppose with that we can close the
201:19 - dialogue Sprite for now we will not need
201:21 - it for a while instead we have to figure
201:24 - out how to get to the next dialogue
201:25 - option at the moment we are only ever
201:28 - getting the first one for that inside of
201:30 - the dialogue tree I want to look for
201:34 - input just as before I want to get all
201:37 - of the press keys with py game. key get
201:41 - uncore just underscore rest then I want
201:44 - to check if keys and P game. Kore space
201:51 - if that is the case first of all I want
201:53 - to get rid of the current dialogue self.
201:56 - Curren dialogue.
201:58 - kill that way we are not going to see a
202:00 - dialogue anymore after that I want to
202:03 - get to the next dialogue index I.E the
202:06 - dialogue index we are using to pick one
202:08 - of the dialogue options this one we
202:10 - simply want to increase by one self.
202:13 - dialog index plus equal one finally we
202:18 - have to make a choice if self. dialog
202:21 - index is smaller than self. dialogue
202:25 - number if that is the case we know there
202:28 - is a next dialogue option available
202:31 - which means we can create another self.
202:34 - Curren dialogue which will be another
202:37 - dialogue Sprite with the same options we
202:40 - have specified up here I can literally
202:42 - just copy all of them and paste them in
202:45 - here however
202:46 - if that is not the case else then we
202:49 - want to end the dialogue although for
202:51 - now we can't really do that so I'm going
202:53 - to add pass in here also to make sure
202:55 - that we are actually calling the input
202:57 - method we will need Define update with
203:01 - self and in there we want to call Self
203:04 - do input however now we have an issue
203:08 - inside of this dialog tree we are
203:10 - checking for the space bar but inside of
203:13 - the main game we are also checking the
203:16 - space bar here so we have a bit of a
203:19 - problem at the moment we would activate
203:22 - both of those options meaning we would
203:24 - get the next dialogue option but we
203:26 - would also get an entirely new dialogue
203:29 - which we want to avoid I only want to
203:32 - check this input if not self.
203:36 - dialog tree only if we do not have a
203:39 - dialog tree do we want to check for this
203:42 - input although at the moment this
203:44 - attribute does not exist but we can fix
203:46 - that very easily when we are creating a
203:49 - dialogue I want to assign the dialogue
203:51 - tree to this attribute and then inside
203:54 - of the dunder init method and let me
203:57 - clean this one up a bit inside of the
203:59 - dunder init method I want to create
204:02 - self. dialog tree which by default is
204:06 - none and once we are creating a dialogue
204:09 - we want to assign the dialog tree to
204:11 - this value that way this if statement is
204:15 - going to run and give us all of this
204:17 - there's just one more thing I do want to
204:19 - do and that is we only want to create a
204:22 - new dialog tree if we currently don't
204:24 - have one I.E if not self. dialog Tree in
204:28 - here as well just as a safeguard that we
204:31 - don't create two dialog trees at the
204:32 - same time cool so with that we have our
204:36 - dialogue tree we just have to make sure
204:39 - that we are actually calling this update
204:41 - method for that inside of the game logic
204:45 - I want to create another section for the
204:49 - overlay and then check if self. dialog
204:53 - tree exists that I want to run self.
204:56 - dialog tree. update let's try I can now
205:01 - go to this character talk to him and we
205:06 - get some updates although this is way
205:08 - too
205:10 - fast let's try it again actually just so
205:12 - we can go through this one by
205:14 - one I am standing next to the character
205:16 - and if I now press
205:18 - space we very quickly go to the second
205:21 - dialogue option although if I press
205:23 - space again we get progress and then the
205:27 - dialogue disappears so this works but we
205:30 - cannot move we do have something but
205:33 - this is not ideal to start with the
205:36 - first issue when we are starting a
205:38 - dialogue we almost immediately switch to
205:41 - the second dialogue option that is
205:43 - because when we are creating the
205:45 - dialogue we are checking this input for
205:48 - the last time but then we also
205:50 - immediately get this input that way we
205:53 - are switching right away to the second
205:55 - dialogue index to avoid that we are
205:58 - going to need a timer that way we are
206:01 - ensuring that we only get this input
206:04 - let's say once every half second
206:07 - unfortunately the inbuilt pame timers
206:09 - aren't particularly flexible however I
206:12 - have made a timer class so if you open
206:16 - the file explorer and go to timer you
206:19 - can open this one and there we have a
206:21 - fairly simple timer class for which you
206:24 - can set a duration repeat auto start and
206:27 - a function you want to call once this
206:29 - thing times out now the class itself
206:31 - isn't terribly complicated and if you
206:33 - want to know more about it check out
206:35 - this video it builds the entire class up
206:37 - from scratch now in our case I am simply
206:41 - going to use it which we start doing by
206:43 - from timer import time
206:47 - and then we want to create one instance
206:49 - of a timer which I want to store in
206:52 - self. dialogue timer for that we want to
206:57 - create a timer class and the one
206:59 - argument we will always need is the
207:01 - duration in milliseconds which in my
207:03 - case is 500 or half a second after that
207:07 - I want to specify one named argument
207:10 - which is auto start true once we have
207:13 - that inside of the input method I only
207:16 - want to skip to the next dialogue if we
207:18 - are pressing the space key and not self.
207:23 - dialogue timer is active also whenever
207:28 - we are getting a new dialogue in this if
207:30 - statement I want to activate the timer
207:33 - which we do with self. dialogue timer
207:37 - and
207:38 - activate that way after we're getting a
207:40 - new dialog timer we have to wait for
207:42 - half a second to get to the next option
207:45 - finally the last thing that we have to
207:47 - do is call
207:48 - self.
207:50 - dialogue timer.
207:53 - update the entire logic of the class is
207:56 - basically inside of this update method
207:58 - if you look at the timer class in there
208:01 - we are basically checking our current
208:03 - time and then a start time if that
208:06 - difference is greater than a duration we
208:08 - want to deactivate the timer that's
208:11 - basically all that's happening inside of
208:12 - the class because of that we always have
208:15 - to call the update method to make sure
208:17 - that this class actually does something
208:20 - but with that if I now try the dialogue
208:25 - again we are getting Hi how are you do
208:27 - you want to fight and fight and then we
208:30 - are finishing the dialogue although we
208:33 - cannot move anymore and later on we also
208:36 - want to start a battle but for now I
208:38 - simply want to end the dialogue below
208:41 - create dialogue I want to Define end
208:45 - dialogue
208:47 - which will need self and the character
208:50 - we have for now we are simply going to
208:53 - set self. dialog tree To None also we
208:58 - want to get self. player and unblock the
209:02 - entire class so we can move around again
209:05 - with that when we are creating a
209:07 - dialogue I want to pass in self dot end
209:12 - dialogue for that to work inside of the
209:15 - dialogue we have to add another
209:17 - parameter and underscore dialogue and
209:21 - then save this one as an attribute let's
209:24 - do it all the way at the top self do and
209:26 - dialogue is and dialogue and then inside
209:31 - of the input if we are exceeding the
209:34 - number of messages we want to call self.
209:37 - end
209:39 - dialogue also this method expects one
209:42 - argument the current character which we
209:45 - have inside of an attribute so we simply
209:47 - have to pass in self.
209:51 - character so with that let's try to have
209:54 - a dialogue with this guy and while I'm
209:56 - talking with him I cannot walk around
209:59 - and we get to the next dialogue option
210:01 - and afterwards I can move around freely
210:03 - again so that is looking pretty good
210:06 - let's try the other lady this one
210:13 - and that is also working pretty well
210:16 - cool so with that we have a basic
210:18 - dialogue
210:19 - system there's just one more thing that
210:22 - we do need and that
210:26 - is if the player is walking in front of
210:30 - any of these characters I want them to
210:32 - talk to the player or a bit more
210:35 - generally for all of the characters I
210:37 - want to check their view Direction and
210:39 - if the player crosses it like we are
210:41 - doing right now then I want the
210:43 - character to move towards the player and
210:46 - start a dialogue for that we have to
210:48 - work inside of the entities and let me
210:52 - minimize things because we only care
210:55 - about the character at the moment to get
210:58 - started we first of all need a bit more
211:00 - information inside of the class we will
211:03 - need the location of the player we will
211:05 - need the ability to create a dialogue
211:10 - and we going to need the Collision
211:13 - Sprites now in case you're wondering we
211:15 - do need Collision Sprites because if
211:18 - this is the character and this is the
211:21 - player we might get a line of site
211:24 - between the two but this we want to
211:26 - block if there's an obstacle between the
211:29 - two which we are getting from the
211:30 - Collision Sprites now first of all we
211:34 - have to create a few more attributes
211:37 - self. player is going to be the player
211:40 - self. create dialogue will be create
211:44 - dialogue and finally for self. Collision
211:48 - Sprites we don't actually care about the
211:50 - Sprites themselves instead we want to
211:53 - have a list of collision rectangles
211:55 - which we can get via sprite. rect or
211:59 - Sprite
212:01 - in Collision
212:04 - Sprites although for this one we do have
212:07 - to be careful because we do not want to
212:09 - get the character itself remember all of
212:12 - the characters are also collidable
212:14 - objects meaning they are in inside of
212:16 - collision Sprites I.E we want to have
212:19 - all of the Collision Sprites if Sprite
212:21 - is not self with that we have the basic
212:25 - setup afterwards we will need a couple
212:28 - of movement attributes self do has
212:32 - underscore moved by default should be
212:36 - faults self.
212:39 - cancore
212:41 - rotate should be true by default and
212:44 - self. has underscore
212:48 - noticed which is going to be false has
212:51 - moved it's going to check if the player
212:53 - has already walked can rotate is going
212:55 - to tell us if this character can rotate
212:57 - around to look in different directions
213:00 - and has noticed is going to tell us if
213:02 - this character has noticed a player or
213:03 - not on top of that we will need two more
213:06 - attributes self. radius and we will need
213:10 - what I called view
213:13 - directions which is going to be list
213:16 - that for example contains left and right
213:20 - meaning this character is going to look
213:21 - left or right at random the radius we
213:26 - can get from til if you look at that and
213:29 - you click on any of the markers if they
213:31 - are a character they always have a
213:34 - radius although I think I was a bit lazy
213:36 - for this one because every single marker
213:39 - has a radius of 400 customize this in
213:42 - your own time for the game it's not
213:44 - going to make that much of a difference
213:46 - anyway in our case we want to get the
213:49 - radius that we put into the Class via
213:52 - the parameter
213:54 - radius for the view directions we have
213:57 - to look at game data in there for
214:00 - example for trainer 01 we have
214:02 - directions down so this character can
214:05 - only look down but for trainer O2 this
214:08 - one can look left or down and trainer 03
214:11 - can look in all four directions this one
214:14 - we can get a bit more easily because we
214:16 - have the character data I want to get
214:18 - the character data and then get the
214:24 - directions with that we just have to
214:26 - figure out all of these extra parameters
214:29 - that we do inside of main. P when we are
214:32 - setting up the character down
214:36 - here we will need a whole bunch more
214:38 - arguments we will need a player this one
214:40 - is going to be
214:42 - self
214:43 - dot player
214:46 - then we will need create underscore
214:48 - dialogue I believe I called it which is
214:51 - self and create
214:53 - dialogue and make sure to not call this
214:56 - method after that we will need the
214:58 - Collision Sprites and the
215:00 - radius Collision Sprites are simply
215:03 - going to be self. Collision Sprites and
215:07 - finally the
215:09 - radius is going to be obj do properties
215:14 - and I think I C this want the radius
215:17 - let's run the entire thing and we are
215:19 - not crashing and if I talk to a
215:22 - character it's still working just fine
215:24 - cool good start but still the characters
215:28 - don't actually do anything meaning we
215:30 - have to add just a bit more Logic for
215:33 - that I have created a method that I have
215:35 - called Ray
215:37 - cast because ultimately what we are
215:40 - going to do is well we're going to cast
215:42 - AR Ray from the current character in the
215:45 - viewing Direction direction for example
215:46 - if this character is looking to the
215:48 - right we are casting out array in this
215:51 - direction if the player intersects with
215:53 - it then we want to do some more stuff
215:55 - that for now isn't too important we have
215:57 - to go through this step by step for this
215:59 - rast method we don't need any custom
216:02 - parameters and basically what we want to
216:04 - do in there is we want to check our
216:09 - connections once again the same method
216:12 - we have used inside of main. pipe when
216:14 - the player wants to talk to to a
216:16 - character this one or in other words the
216:18 - one that we have created inside of
216:21 - support. Pi this check connections for
216:24 - which we are going to need a radius
216:26 - entity and Target radius is going to be
216:30 - self.
216:31 - radius entity is going to be self and
216:35 - the target is going to be self. layer if
216:39 - that is the case for now to test it
216:42 - let's
216:43 - print layer also we have to make sure
216:46 - that we are calling self. rcast oh and
216:50 - finally we also have to make sure that
216:51 - we are from support import check
216:57 - connections after that inside of main.py
217:00 - we are getting an error that we cannot
217:03 - do a comparison between a float and a
217:05 - string that happens inside of entities
217:09 - with raycast and check Connections in
217:12 - there we are getting a problem on this
217:15 - this line and the issue is fairly simple
217:18 - when we are importing the radius this
217:21 - one is coming from til in there the
217:24 - radius if you look at the data type it
217:27 - is a string for some reason that is my
217:30 - mistake and not terribly easy to fix
217:32 - simply because we have a whole bunch of
217:34 - characters or rather I would say it's
217:36 - not easy to fix inside of tiled inside
217:39 - of pame we can simply convert all of the
217:41 - radi into integers and then this should
217:44 - be working so if I now go in front of
217:47 - this Buck catcher we can see
217:49 - player and if I go to other lady down
217:57 - here for all of the sides nothing is
217:59 - going to happen but if I am below her
218:01 - then we are getting
218:03 - player and finally if I go to this lady
218:08 - we can be below nothing happens but if I
218:10 - am to her left then we get more player
218:13 - output so if that is the case
218:16 - I want to get self. player and block the
218:20 - player also I want to update the player
218:23 - facing Direction which we do with self.
218:26 - player and then change facing Direction
218:30 - the method that we have created earlier
218:32 - inside of entity this one we can reuse
218:36 - that quite easily all we have to do is
218:38 - change the target which in this case is
218:40 - going to be self. re. Center self in
218:43 - this case is referring to the character
218:46 - let's try that one and if I now walk in
218:50 - front of the buck catcher the player
218:52 - cannot walk anymore and we are facing
218:54 - the character
218:55 - cool although the issue is that this is
218:59 - going to work even if there's an
219:00 - obstacle so even if we walking here the
219:04 - player is going to stop and face the
219:06 - opponent but this shouldn't happen
219:08 - because we have an obstacle in the way
219:12 - that we do have to check for to
219:14 - incorporate that I will create another
219:17 - method that I called hasore Lo short for
219:22 - line of sight no need for custom
219:24 - parameters in this one and basically all
219:27 - we want to check first of all if the
219:31 - vector of self. Rec do Center and then
219:37 - distance to self. layer. rect do Center
219:44 - if that value is below self. radius I.E
219:48 - we are only doing stuff if the player is
219:50 - inside of the character radius if that
219:53 - is the case we want to check for all of
219:55 - the collisions between these two
219:57 - entities which should be a list of
220:01 - Boolean values I.E we only really care
220:04 - about if there's an object in the way or
220:07 - not we do not care about the size or the
220:09 - position we simply care if there's an
220:11 - object in the way that is all we need to
220:13 - know I.E this this should be a list of
220:16 - either true or false values but step by
220:20 - step first of all I want to get W for re
220:23 - in self.
220:25 - Collision rectangles the list we created
220:28 - in the dunder init method early on and
220:31 - on this rectangle we want to run a
220:33 - method called clip line this one wants
220:37 - to have two points a starting point and
220:40 - an end point our starting point is self.
220:43 - do Center and our end point point is
220:45 - self. player. rec. Center and clip line
220:50 - is basically going to check if we have a
220:52 - line if it passes through a rectangle if
220:57 - that is the case it will give us the
220:58 - line inside of the rectangle which we
221:01 - don't really care about we just want to
221:03 - know if this line exists in the first
221:05 - place which means we can wrap the return
221:08 - value into a Boolean function that way
221:12 - we ever get true or false and after that
221:15 - we can return not any and the
221:20 - collisions any is going to check if
221:23 - there's any True Value inside of the
221:25 - list if that is the case it is going to
221:28 - return true overall and in our case via
221:31 - this list we're getting lots of true or
221:34 - false values if there's even a single
221:37 - obstacle between the player and the
221:38 - character all of this is going to
221:40 - evaluate to true or to be a bit more
221:43 - precise because of this not we're
221:45 - getting the very opposite I.E if there
221:48 - are no collisions whatsoever this value
221:51 - is going to be true however once we have
221:53 - a single obstacle this value will become
221:56 - false that way we will know if we have
221:58 - line of sight or not which we can use
222:02 - inside of raycast I want to check the
222:04 - connection and
222:07 - self.
222:10 - L if I now try to run the game and walk
222:13 - below this obstacle we we do not get
222:16 - anything but if I walk on top of it so
222:19 - there's no obstacle we once again get
222:22 - the player block and we are facing the
222:23 - character so we can start working on the
222:26 - next issue and that is that I want the
222:28 - character to start walking towards the
222:30 - player for which we're going to need two
222:32 - methods the first one will be start
222:35 - underscore move with no custom
222:38 - parameters and in there we want to set a
222:41 - direction for this
222:43 - character so in other words self.
222:46 - direction is going to get a value self.
222:49 - Direction by the way already exists
222:51 - inside of the character because the
222:53 - parent class entity has a direction this
222:57 - one which means all that we have to find
223:00 - is the direction from the character to
223:02 - the
223:03 - player let's do that on the line before
223:06 - I want to get the relation between the
223:08 - character and the player for that I want
223:12 - to get the
223:13 - vector with self. player. re. Center and
223:18 - then subtract another Vector with self.
223:22 - re. Center this value we need to
223:25 - normalize or in other words we want to
223:28 - call the normalize method now for the
223:31 - direction I do not want to set the
223:33 - relation right away because imagine that
223:37 - this is the character and we have a line
223:40 - of sight going straight down but there
223:43 - is a bit of tolerance so the ual line is
223:45 - something like this and if the player
223:49 - collides with it like so our relation
223:53 - would be an arrow that tilts a bit to
223:56 - the right which might be okay for the
223:58 - game but I want the character to only
224:00 - move up or down or left or right there
224:03 - should not be any diagonal movement to
224:05 - get that I want to create a new Vector
224:08 - with relation dox and relation
224:12 - doy and then the trick is
224:15 - to round both values after that if the
224:19 - player gets into the ray casting area we
224:21 - want to start move now this is not going
224:24 - to do anything because the direction is
224:27 - not being used there's no move method
224:29 - inside of the character so let's create
224:32 - one no need for custom
224:34 - parameters we want to self. rec. Center
224:39 - plus equal self do Direction multiplied
224:43 - with self do speed multiplied with Delta
224:46 - time oh and for that we do need Delta
224:49 - time as a parameter so when we are
224:52 - calling self. move we can pass in Delta
224:55 - Time by default direction is going to be
224:57 - zero so there shouldn't be any movement
224:59 - let's try main. pi and if I go in front
225:03 - of the character it is well it's doing
225:07 - something the issue is we never stop
225:10 - moving but this part at the very least
225:12 - works now to fix that issue while the
225:15 - character is moving we're going to
225:17 - create another larger rectangle around
225:21 - it and if this area coll lights with the
225:23 - player then we are going to stop moving
225:27 - or in other words we want to check if
225:30 - not self. hitbox do inflate and let's go
225:35 - with 10 and 10 if this new hitbox
225:39 - collide
225:40 - rects with self. player. hitbox then we
225:45 - know we have a collision so we only want
225:47 - to move if this is not the case else I
225:51 - want to set self. Direction back to a
225:55 - vector with default values I.E 0 and
225:58 - zero and also I want to wrap all of this
226:01 - inside of another if statement we only
226:04 - want to do all of this if not self dot
226:08 - has moved and if there is a self dot
226:12 - Direction now self dot has moved we
226:15 - haven't touched yet but basically after
226:18 - this if statement is correct we know
226:20 - that the character has moved I.E inside
226:23 - of the El statement we can set has moved
226:26 - to
226:28 - R after that the character should not be
226:30 - able to move anymore all of the
226:32 - characters should only be able to move
226:34 - once so with all of that let's try main.
226:38 - p and the buck catcher should only work
226:41 - to the player and that didn't work and I
226:44 - think I know why
226:46 - when we are updating the rectangle of
226:48 - the buck
226:49 - catcher we are not updating the hitbox
226:52 - that is the same issue we had with the
226:54 - player because in there after moving the
226:57 - rectangle we also had to update the
226:59 - hitbox which at the moment we are not
227:02 - doing but we can fix that quite easily
227:04 - self. hitbox do Center is going to be
227:08 - self. rec. center now this should be
227:12 - working let's try and and the buck
227:15 - catcher is walking to the player and
227:18 - then keeps on walking nearly done we
227:20 - just have to fix the animation the issue
227:22 - we have at the moment is that the
227:24 - character spots the player inside of
227:27 - raycast and then moves towards the
227:29 - player and once we have reached a player
227:32 - we keep on checking the ray cast and
227:35 - then we are starting to move again and
227:37 - we're calling to move method and this
227:38 - keeps on going forever we have to break
227:41 - the loop which we can do with another
227:44 - condition in the if statement and not
227:47 - self do has moved let's try this again
227:51 - now and we should not be getting a
227:55 - walking animation that looks good also
227:57 - what we can do at this point after the
227:59 - character has reached the player we want
228:01 - to initialize the dialogue with self.
228:04 - create dialogue as an argument we have
228:07 - to pass in the character itself let's
228:09 - try that part and
228:13 - now we are getting dialogue and I can go
228:16 - to the next option fight and then walk
228:19 - around that is looking pretty good let's
228:21 - try another character this lady and this
228:24 - part is also working perfectly fine
228:27 - there's not that much more that we have
228:28 - to do and I think at this point we
228:30 - should do an exercise number one make
228:33 - the characters look around using the
228:36 - values inside of self. view directions
228:39 - on top of that create a timer that
228:41 - changes this direction I call this one
228:43 - the look around timer but you could call
228:45 - it whatever you want after this exercise
228:47 - you should have characters that look
228:49 - around in random directions and that
228:51 - should make the game feel much better so
228:53 - pause the video now and see if you can
228:55 - figure this one
228:59 - out inside of the character class I
229:04 - first of all want to create a timer for
229:06 - that all the way at the top we need from
229:09 - timer import timer next up in the dunder
229:13 - init method of the character
229:15 - I want to create self.
229:18 - timers this is going to be a dictionary
229:21 - because in just a bit I want to add a
229:23 - second timer but for now I simply want
229:25 - to have the look around timer which is
229:29 - going to be a timer with a bunch of
229:31 - values we want to have a duration auto
229:34 - start repeat and a function called once
229:38 - the timer times out now the duration is
229:41 - going to be
229:42 - 1,500 so the character rotates every 1.5
229:46 - seconds auto start should be set to True
229:50 - repeat should also be set to true and
229:54 - then for the function that we are going
229:55 - to call once this timer times out I want
229:58 - to get self. random view Direction a
230:04 - method that does not exist right now so
230:06 - let's create it I guess we can do it
230:09 - right below random view Direction
230:13 - without any c
230:15 - parameters in there first of all we want
230:18 - to check if this character can rotate so
230:21 - this attribute if self dot can rotate if
230:25 - that is the case we want to update the
230:27 - facing Direction I.E self. facing
230:30 - direction is going to be one value of
230:33 - self. view directions for that we can
230:36 - use the choice method that we have to
230:39 - import all the way at the top I want
230:42 - from random import
230:45 - choice and that's more or less all you
230:47 - need to get some rotation although you
230:50 - do have to keep in mind that we have to
230:52 - update all of the timers for that inside
230:56 - of the update method before we are doing
230:58 - anything else we can do for timer in
231:02 - self. timers Dov values don't forget to
231:05 - call this one and then timer. update
231:09 - that should be it if I now run main.py
231:11 - and I look at the lady although I think
231:13 - she can only look left I don't there you
231:14 - can see she's looking e left or down so
231:17 - that is working pretty well let's have a
231:20 - look at this character I think she can
231:22 - look in all four
231:25 - directions and that is working pretty
231:27 - well cool and finally we have this guy
231:30 - who can only look down now the next
231:33 - question is is the dialogue thing still
231:36 - working and yep that looks good although
231:39 - you can see once the character is
231:41 - starting to talk to us it is still
231:43 - rotating that we need to fix which is
231:46 - going to happen inside of the raycast
231:50 - method once the character has notice the
231:53 - player we want to set self dot can
231:56 - rotate to
231:59 - false that way if I talk to a character
232:03 - again let's go to the lady at the bottom
232:05 - because she has more rotate options he's
232:08 - still talking to us and now she always
232:10 - looks in the player Direction so that is
232:12 - working pretty well also while we are
232:15 - here I want to incorporate the has
232:20 - noticed attribute once the character has
232:23 - noticed the player self do has noticed
232:26 - is going to be true and then we only
232:30 - want to check the raycast if the
232:32 - character hasn't noticed the player yet
232:34 - I.E and not self. has noticed on
232:39 - occasion I get a buck without this one
232:41 - where the character kept on looking for
232:43 - the player but any anyway we are making
232:45 - some pretty good progress there are just
232:48 - two more things that I want to implement
232:50 - the first one is if you look at the game
232:53 - data you can see that some characters
232:56 - can look around While others cannot look
232:58 - around for example character O2 should
233:01 - not be looking around for the player or
233:03 - in other words if the player walks in
233:05 - their line of sight they shouldn't start
233:06 - to talk to the player only the player
233:08 - can talk to them the way we are going to
233:11 - implement that is we only want to call
233:15 - rast and move if that condition is true
233:18 - I.E if self. character data and we are
233:23 - looking for look around only if that is
233:28 - the case do we want to call these two
233:29 - methods if I now run all of this we are
233:32 - getting an error because inside of game
233:35 - data I call this look underscore
233:38 - around let's fix that one really quick
233:41 - look underscore around and now main pi I
233:44 - think this one is character two and now
233:47 - even though I'm in her line of
233:49 - sight we are not getting any kind of
233:51 - dialogue but if I talk to her we are
233:54 - still getting the dialogue but she keeps
233:56 - on rotating so that we have to fix I
234:00 - suppose the easiest way of doing that is
234:02 - once we have start talking with the
234:05 - character this if statement we want to
234:08 - get the character and then set can
234:12 - underscore rotate to false or in other
234:17 - words we are only rotating if this can
234:21 - rotate is
234:24 - true if I talk to the character she's
234:27 - pointing at us and she stops the
234:29 - rotation that looks pretty good that was
234:31 - the first point and for the second Point
234:35 - let me run the game again imagine that
234:37 - this lady has line of sight and actually
234:39 - wants to talk to the player if that is
234:41 - the case I want the player to stop for a
234:44 - little bit let's say a second and also
234:47 - have a notice symbol at the top so the
234:50 - player notices that he was well noticed
234:53 - for that we have to implement a couple
234:55 - of things number one inside of the
234:58 - entities I want to work in the player
235:00 - for just a second in there I want to
235:03 - create self. noticed which by default is
235:07 - going to be false after that we can work
235:10 - inside of the character and once the
235:13 - player has been noted inside of this if
235:15 - statement I want to get self. player and
235:19 - then set noticed to grp that way we know
235:23 - that the player was noticed and if that
235:25 - is the case I want to display an
235:28 - exclamation mark on top of the player or
235:31 - rather if I look at a graphics folder
235:33 - inside of UI we have a notice graphic
235:37 - this is what I want to display above the
235:39 - player once the player has been noticed
235:41 - the easiest way to implement that is in
235:44 - inside of the all Sprites group first of
235:47 - all in there I want to get self. notice
235:51 - uncore surface which we get with import
235:55 - image I want to go up a folder then I
235:58 - want to go to graphics and there we have
236:01 - UI and the graphic I want to import is
236:04 - called
236:05 - notice after that basically after we are
236:09 - drawing all of this I want to add
236:11 - another check if Sprite is equal to
236:15 - player and player do noticed in that
236:20 - case I want to get self. display surface
236:23 - and then blit self. notice surface after
236:28 - that we will need a position for that
236:30 - first of all I want to create a
236:33 - rectangle which we get with self. notice
236:36 - Surf and then get underscore F rectangle
236:41 - where we want to place the mid bottom
236:44 - the the position for this one should be
236:45 - sprite. w. midtop which should be the
236:50 - midtop of the player remember the Sprite
236:52 - is going to be the player after that for
236:55 - the position I want to get the rectangle
236:57 - and don't forget we have to add self do
237:00 - offset for the camera and with that we
237:04 - are getting an error that player is not
237:06 - defined and that I believe happens
237:09 - inside of groups ah there we have the
237:11 - issue the player at the moment does not
237:14 - exist inside of this draw
237:16 - method I suppose the easiest way of
237:19 - getting the player is for the one
237:22 - parameter we don't want the player
237:23 - Center we just want to have the player
237:26 - IE inside of main. Pi we are not passing
237:29 - in player. rec. Center we are simply
237:32 - passing in the player
237:33 - itself and then when we getting the
237:36 - player
237:37 - Center this would be player. rec.
237:42 - centerx and for player Center one we
237:45 - would simply get player Center y after
237:49 - that the game does work again the camera
237:51 - also works that's a good sign and now if
237:54 - I walk into the notice radius we are
237:56 - getting another error that we are inside
238:00 - of groups uh adding an offset to a
238:03 - rectangle this should be re. top left
238:07 - next
238:10 - attempt and there we go now we have the
238:13 - exclamation Mark although the character
238:15 - starts walking way too fast so you can't
238:18 - really see it very well first of all I
238:21 - want to create another timer I call this
238:24 - one
238:25 - noce it's going to be another timer the
238:28 - duration for this one is 500 and we want
238:32 - to declare a function which is going to
238:34 - be self. start move the start move we
238:38 - already have so the idea is once the RAS
238:43 - triggers then we want to start the timer
238:45 - and once the timer triggers out we are
238:47 - calling start move or in other words we
238:51 - do not want to cause. move right away
238:54 - instead we want to get self.
238:57 - timers and notice and then activate the
239:03 - timer also there should be a comma at
239:06 - the end of this and that's basically all
239:08 - we have to do this function is now going
239:11 - to be called after the timer times out
239:13 - and then means if I walk in front of a
239:17 - character we have to wait half a second
239:19 - for anything to happen but the rest
239:21 - still works just fine although the
239:24 - notice sign doesn't disappear not ideal
239:27 - after the character has walked towards
239:28 - the player we want to set self. player.
239:33 - noticed back to
239:35 - vaults I can walk in front of him again
239:38 - we have to wait we are talking and that
239:40 - looks pretty good cool we can try this
239:43 - again with another character down here
239:46 - there we go that looks pretty good and
239:49 - we are getting dialogue and with that we
239:52 - have finished the character dialogue
239:54 - this was a larger section but now the
239:56 - game is much more interactive another
239:58 - really important part of the game will
240:00 - be a transition system so for example we
240:03 - can transition from the Overworld to an
240:05 - arena or we can transition from a
240:07 - dialogue to a battle scene for that
240:10 - let's start with a level transition the
240:13 - basic logic is actually fairly simple
240:15 - number one we are going to fade to a
240:17 - black screen during this black scene we
240:20 - are going to delete all of the Sprites
240:22 - and then we are going to rerun self.
240:24 - setup with another titled map by the
240:27 - time the player can see the level again
240:29 - we have a whole new level although
240:31 - before we can start with that we need to
240:33 - get the level transition areas for that
240:37 - inside of til let me display all of the
240:40 - objects and then we have another layer
240:42 - called transition this one you have to
240:45 - zoom in a bit is basically just a layup
240:47 - full of very small areas which are going
240:50 - to be the entrance areas for the doors
240:52 - for example this one gets us to the
240:54 - hospital this one would get us to the
240:58 - house or if you look at another one a
241:01 - bit further up we have the entrance for
241:04 - the arena this one all of those
241:06 - transition areas have two custom
241:08 - properties a position and a target the
241:11 - target is going to be the tile map we
241:14 - want to load and the position is the
241:16 - position within the tile map where the
241:18 - player should start that means inside of
241:21 - main. Pi we need to do two things number
241:24 - one inside of the setup method I want to
241:28 - add another let's do it below the
241:32 - objects I want to have my transition
241:36 - objects just as before we will need a
241:38 - for loop with for obj in TMX map. getet
241:42 - layer by name the we want to get is
241:44 - called
241:46 - transition for this one we want to have
241:49 - a very specific kind of sprite one that
241:51 - doesn't exist yet which means inside of
241:54 - sprite I want to collapse all of this
241:57 - and then create a new class transition
242:01 - Sprite Which will inherit from the
242:03 - Sprite class fundamentally nothing too
242:06 - complicated is going to happen in here
242:09 - we want to have self we want to have a
242:11 - position we want to have a a size then
242:14 - we will need a Target and we will need
242:17 - groups notice for this one we are not
242:20 - going to load a surface simply because
242:22 - we don't need to those tiles are not
242:24 - going to be visible we can simply create
242:26 - a surface with pame do surface right
242:30 - inside of the dunder init method using
242:32 - the size next up we can call Super
242:35 - Dunder
242:37 - init and pass in the position the
242:40 - surface and the groups on top of that we
242:43 - we want to store the target IE the ti
242:46 - map we want to load as an attribute
242:48 - self. Target is going to be Target that
242:51 - is all we need next up inside of main.py
242:54 - I want to import the transition Sprite
242:58 - as well with that inside of the for loop
243:02 - I want to create a transition Sprite for
243:06 - every single one of the objects let's
243:08 - copy all of the
243:11 - parameters we need all of this position
243:14 - is fairly simple obj dox and obj
243:18 - doy for the size it's not going to be
243:21 - much more complicated obj do WID and obj
243:26 - do height now for the Target we want to
243:29 - have it Tuple that is going to contain
243:31 - both of these properties IE which map we
243:35 - want to load and the starting position
243:37 - of the player for that we will need obj
243:40 - do properties and we want to get the
243:44 - Target and then obj do
243:49 - properties with the
243:52 - position nearly done the last thing we
243:55 - need is the groups and for that I want
243:58 - to have all of those Sprites inside of
244:00 - self.
244:01 - transition uncore Sprites this group
244:05 - does not exist yet so all the way at the
244:08 - top in the dunder init method I want to
244:11 - create self. transition
244:14 - Sprites which once again is going to be
244:16 - pame dos sprite. group like with
244:21 - Collision Sprites and character sprites
244:23 - we are only using this group to identify
244:25 - the transition Sprites that's all it
244:27 - needs to do which means next up I want
244:30 - to create another method although before
244:33 - that I think we should organize the game
244:35 - class just a bit
244:36 - better for example the input along with
244:40 - create dialogue and end dialogue should
244:42 - all be the dialog log system under init
244:46 - import assets and setup is going to be
244:49 - General stuff after that I want to have
244:53 - a transition system I think that
244:57 - organizes the entire thing just a little
244:58 - bit better anyway I first of all want to
245:01 - do a transition underscore check no need
245:06 - for custom parameters and really all we
245:08 - want to do in there is first of all
245:10 - check if the player is colliding with
245:11 - any of the transition Sprites
245:14 - or to be a bit more specific I want to
245:16 - check if the hitbox of the player
245:17 - collides with any of these areas I want
245:20 - to store them inside of a sprite's
245:23 - variable and for that we can use list
245:25 - comprehension Sprite for sprite in self.
245:30 - transition Sprites if sprite. rec.
245:36 - collide rect with self. player.
245:41 - hitbox or in other words we are are
245:43 - looking at all of the Sprites inside of
245:45 - transition Sprites and pick the Sprites
245:48 - that are colliding with the player hit
245:49 - box if there are any
245:52 - Sprites then we want to get the player
245:56 - and block it let's check if this is
245:58 - working in the first place meaning
246:01 - inside of the run method sometime before
246:04 - we are drawing everything I want self.
246:07 - transition check and I think this part
246:11 - could also be a bit better organized we
246:13 - first of all want to fill the entire
246:16 - surface with a black color and this
246:17 - could even be all the way at the top
246:19 - there we have Delta time and self.
246:21 - display surface. fill then we are
246:25 - updating the game in there we check
246:27 - input transition check and all of the
246:29 - updates after that we are doing the
246:32 - drawing then we're doing the overlays
246:34 - and then we are updating the screen that
246:36 - feels much cleaner anyway let's try all
246:39 - of this and if the player goes to this
246:41 - area we cannot walk anymore
246:44 - that is working pretty well so now we
246:46 - have to work on a transition Logic for
246:49 - that first of all we are going to need a
246:52 - few more attributes I suppose right
246:55 - below the groups we can add a transition
246:59 - or screen tint system first of all we
247:02 - want to have a transition uncore
247:06 - Target which by default is going to be
247:09 - none this target we can update right
247:11 - away actually because what once the
247:13 - player is colliding with any of the
247:15 - transition Sprites then we want to set
247:18 - self.
247:20 - transition Target to sprite. Target
247:25 - although we do have to be careful
247:27 - Sprites at the moment is a list and we
247:29 - only want to get the first item of this
247:32 - list I.E Sprite index zero and then the
247:34 - Target also this should be Sprites next
247:38 - up we have to work on the tinting logic
247:41 - first of all for that we will need a
247:44 - tintore surface which is simply going to
247:47 - be pame do surface with the same
247:50 - Dimension as the actual window I.E the
247:53 - display surface which means I can copy
247:55 - the window width and window height and
247:57 - paste it in there I also want to have
248:00 - self. tint mode which by default is
248:04 - going to be
248:06 - untint if we are tinting the screen
248:08 - we're going to Black and if we are
248:10 - unting it we're going from black to
248:12 - transparent after that we want to have
248:14 - self. tintore progress which by default
248:18 - is going to be
248:20 - 255 we want to have self.
248:23 - pintore Direction which by default will
248:26 - be negative -1 and finally self.
248:30 - hore speed which I have set to 600 that
248:35 - will give us all of the basic attributes
248:38 - that we need now we have to implement
248:40 - the system although first of all once
248:43 - the player collides with a transition
248:46 - Sprite we also want to set self. tint
248:50 - mode to tint with that we can actually
248:54 - start with the system I call this method
248:57 - tintore
248:59 - screen this one is going to need self
249:01 - and Delta time we want to check if self.
249:05 - tint mode is equal to
249:09 - tint the value we are setting inside of
249:13 - the transition check if that is the case
249:15 - we want to get self. tint progress and
249:19 - increase it by self. tint speed
249:23 - multiplied with Delta time Delta time is
249:26 - really important so we have the same
249:28 - transition speed regardless of the frame
249:30 - rate that way we are increasing the tint
249:33 - progress although by default it is 255
249:36 - let's set it to zero for now that's
249:38 - going to make debugging a bit easier I
249:41 - want to use the tint progress to update
249:43 - to transparency of the tint surface
249:46 - self. tint surface do set uncore Alpha
249:52 - to self. tint progress in case you
249:57 - haven't used set Alpha all it does is it
250:00 - well sets the alpha value I.E the
250:02 - transparency of a surface and the value
250:05 - goes from zero all the way to
250:08 - 2055 at the moment our tin progress is
250:11 - going to be zero but because because of
250:13 - this line we are going to increase it
250:16 - and to actually see it we will need
250:18 - self. display surface do blit with self.
250:23 - tint surface with the starting position
250:27 - being zero and zero this tin screen we
250:30 - actually have to call which needs to
250:32 - happen on top of everything else I did
250:36 - it right below the display update self.
250:39 - tint
250:41 - screen that part is really important
250:44 - because if there's any other element on
250:46 - top of the tinting it's going to look
250:48 - really weird also don't forget we need
250:50 - Delta time in there let's try and if the
250:53 - player collides with a transition Sprite
250:56 - we are fading out so this system is more
250:59 - or less working we just have to add a
251:01 - few more parts to it most importantly we
251:04 - want to check if self.
251:07 - tint progress is greater or equal to 255
251:13 - I.E our screen is entirely black if that
251:17 - is the case I want to call self. setup
251:21 - again and remember for the arguments we
251:24 - will need a TMX map and a starting
251:26 - position for the player for the TMX map
251:29 - I want to get self. TMX Maps along with
251:35 - self. transition Target and this one
251:38 - should be zero for the player starting
251:41 - position I want to get self do
251:43 - Transition Target with one remember
251:47 - transition Target is simply going to be
251:49 - a tupal the first value is the map we
251:52 - want to load and the second value is the
251:54 - player starting position inside of that
251:56 - map on top of that we want to set self.
252:00 - tint mode to
252:03 - untint and also we want to clear the
252:06 - transition Target I.E self. transition
252:09 - Target is going to be none next up we
252:13 - have to implement the logic for the UN
252:15 - tinting I suppose we can do that one all
252:18 - the way at the
252:19 - Top If
252:22 - self. htin mode is equal to
252:28 - untint if that is the case self. tin
252:32 - progress is going to be minus equal
252:35 - self. tin speed multiplied with Delta
252:40 - time let's try all of that and now if I
252:44 - get to a door we are getting a key error
252:49 - the reason for that is inside of import
252:51 - assets we only have two TMX Maps world
252:55 - and Hospital let's try to hospital
252:57 - instead if I get to this part we first
253:00 - of all get a huge waiting time and then
253:04 - we're getting a key error so step by
253:06 - step the first issue
253:09 - is when we are calling self do untint
253:14 - the tint progress is actually a really
253:16 - large number in fact let me print self.
253:20 - tint progress if I now Run the game this
253:24 - number becomes increasingly negative and
253:26 - only once we reach the door then this
253:29 - number reverses and it becomes larger
253:31 - and larger but we have to wait for it to
253:33 - become positive for actually something
253:35 - to happen to fix that I want to limit
253:38 - self. tin progress to a value between 0
253:41 - and 255
253:43 - which we can do by setting self. tin
253:47 - progress we are using the max function
253:50 - with a floor value this one would be
253:53 - zero and the other value would be self.
253:56 - tint progress with Max we are selecting
253:59 - the larger of the two numbers I.E we are
254:02 - never going to go below zero after that
254:05 - I want to use the mint function for a
254:08 - ceiling via that we are always going to
254:10 - pick the lower value which can be tint
254:13 - progress or
254:15 - 255 with that we can never go beyond 255
254:19 - or below zero let's try this one and now
254:23 - we get zero at our lowest value and if I
254:26 - hit the hospital we are getting to
254:29 - 255 at the most not even that however
254:33 - then we're getting a key error
254:35 - direction for that error we want to look
254:38 - at the character because in there we are
254:41 - not getting a Direction and that is an
254:44 - error inside of the tile map if you look
254:47 - at the TMX map that we want to load for
254:49 - our player starting position we have a
254:51 - direction and a position that part is
254:54 - fine but for the mark 2D for the nures
254:57 - we don't have a direction or radius now
255:00 - that we can fix quite easily by adding a
255:02 - property we need a direction which
255:05 - should be down by default and we will
255:08 - need a radius which can be zero for
255:11 - nurse after we have that I want to run
255:14 - the game again and now if I go to a
255:17 - hospital we get well we get something so
255:21 - the issue is we have the hospital but we
255:24 - also have the arena and well that's not
255:26 - ideal the problem we have is that when
255:30 - we are calling the setup method we are
255:32 - not getting rid of all of the previous
255:34 - Sprites I.E we can still see the
255:36 - original Overworld which is going to
255:39 - look incredibly weird and to fix that we
255:42 - want to First of all clear the map all
255:45 - we need to do for that is for group in
255:49 - self do for Sprites self. Collision
255:53 - Sprites self.
255:57 - transition Sprites and self. character
256:02 - sprites we want to call
256:05 - group.
256:07 - Mt that way if I try all of this again
256:13 - we are only able to see the level
256:15 - although other than that we still get
256:17 - collisions and that is working pretty
256:22 - good and we can also go back to the
256:24 - overw world so quite happy with
256:28 - that now the issue is if we try to go to
256:31 - another area we're getting a key error
256:34 - to fix that we have to import all of the
256:36 - TMX maps that is going to happen inside
256:39 - of support. Pi and let me minimize
256:43 - everything I want to create a
256:46 - TMX importer which is going to need a
256:50 - path unpacked and then we want to create
256:53 - a TMX
256:55 - dictionary which by default is going to
256:57 - be entirely empty after that I want to
257:00 - have the for Loop that we have already
257:02 - seen in which I am getting the folder PA
257:06 - the sub folders and then in this case
257:09 - the file uncore names this this will be
257:13 - all of the TMX files in walk with join
257:18 - and the path we are getting from the
257:22 - parameters after that we want for file
257:25 - in file names and I suppose for now
257:29 - let's simply print what we are getting
257:31 - that way inside of
257:33 - main.py I want to print the return value
257:38 - of TMX importer for the path we want to
257:42 - go up folder then we want to go to data
257:46 - and in there we have our Maps if I now
257:49 - run all of this we are getting all of
257:53 - the TMX Maps also we are getting a whole
257:56 - bunch of zeros that happens because of
258:00 - this print statement that we don't need
258:03 - anymore so at the moment we can get all
258:06 - of the names of the TMX maps that we
258:08 - want to import that we can use to create
258:12 - a new ENT tree inside of the TMX
258:15 - dictionary I simply want to get the file
258:17 - and then split it wherever we have a DOT
258:20 - and then pick the first value that way
258:23 - we are getting rid of the TMX ending the
258:26 - value Associated is going to be ladore
258:29 - py game the method we have already used
258:32 - inside of the Overworld this
258:35 - one this we want to reuse and we already
258:38 - have the import statement I want to
258:40 - create a path via the join method
258:43 - I want to get the folder path and then
258:46 - the actual file after that I can return
258:50 - TMX dictionary and now if I run main.py
258:54 - again we are getting a dictionary with
258:58 - all of the tiled
259:00 - maps that value we want to store inside
259:02 - of the attribute TMX Maps I want to cut
259:06 - this part out and then get rid of this
259:09 - entire dictionary and simply use the
259:11 - return value for from TMX importer felds
259:15 - significantly cleaner and now that we
259:17 - have that let's try the game and if I go
259:20 - into a house we have a house along with
259:23 - the collisions and that's kind of all we
259:26 - can do in here so if I go out again we
259:29 - are back in the Overworld I can try the
259:32 - hospital again and this one is also
259:34 - working we cannot talk to the nurse at
259:37 - the moment but that we can cover
259:39 - later anyway for now I think this is
259:42 - looking pretty
259:43 - good what you can also do at this point
259:46 - is you can take the start position and
259:48 - then drag it let's say all the way up
259:51 - here to test the water Arena don't
259:54 - forget to save if you not run the code
259:57 - you can check out the water Arena and
259:59 - there you go looks pretty good we can
260:01 - also leave again and then we could check
260:03 - out the other Arenas do that in your own
260:07 - time and with that we have finished the
260:09 - entirety of the Overworld now in dat
260:12 - bits we have to come back to add some
260:14 - additional Parts like the nurses or the
260:17 - dialogue to battle system but I think
260:19 - for now we have a pretty good setup
260:21 - which means next up we can actually
260:23 - start working on the
260:25 - monsters now that we have the Overworld
260:27 - we can start with the actual monsters
260:29 - and there are three things we have to
260:31 - cover the most important part is the
260:33 - actual battle system and this one will
260:35 - become quite large besides that we have
260:38 - the monster index and we have the
260:40 - evolution system now these three system
260:42 - systems work kind of independently so we
260:45 - can approach one at a time and I think
260:47 - the best way to get started is with the
260:49 - monster index this one is going to show
260:52 - us what monsters we have and all of
260:53 - their stats along with their abilities
260:56 - on top of that we are also going to
260:58 - create a pretty fancy UI although before
261:01 - we can get started with that there is a
261:03 - bit of groundwork we have to cover most
261:06 - importantly for all of the monsters
261:08 - there will always be a dedicated monster
261:10 - class that stores the data and there we
261:13 - are going to keep the health the energy
261:14 - the level the XP all of the stats and
261:16 - abilities and so on now this monster
261:19 - class will never be visible we are
261:22 - always going to create a dedicated
261:24 - Sprite or an animation for example in
261:26 - the battle we have a monster Sprite that
261:29 - is connected to the monster class and
261:31 - inside of the monster index we simply
261:33 - have to play an animation by add that
261:35 - system we can keep all of the stats
261:37 - inside of the class and then simply use
261:39 - them in different parts of the game
261:41 - let's start with that part here we are
261:44 - in the code and I do have quite a few
261:47 - tabs open I don't really need them
261:49 - anymore we don't need the dialogue we
261:51 - don't need the timer we are going to
261:53 - need the game data we are not going to
261:56 - need the groups at least for now we
261:58 - don't need the entities we are not going
262:00 - to need the Sprites and we are not going
262:02 - to need support So at the moment I only
262:04 - have main.py game data and settings.py
262:07 - open although I do want to create a new
262:09 - python file that is going to be monster
262:13 - do I in there I want to create a class
262:17 - called Monster no need for inheritance
262:20 - and also notice here we are not using py
262:23 - game since this class is only going to
262:25 - store data there's nothing we need from
262:27 - py game for this I want to create a
262:30 - Dunder init
262:33 - method with self I want to have the name
262:36 - of the monster and then I want to have
262:37 - the level of the monster now the way the
262:40 - system is going to work to get all of
262:42 - the stats and graphics for the monster
262:44 - via the name from game data we're going
262:47 - to pick one of the monsters so if you
262:49 - look at Monster data there we have all
262:51 - of the monsters and if you look at one
262:54 - of those let's say
262:56 - chamad there you have all of the stats
262:58 - for example this monster has the element
263:00 - fire Max health max energy attack
263:03 - defense and so on there's a bit more
263:05 - data in there besides that we have the
263:08 - abilities and whenever the monster
263:10 - reaches a level we're going to unlock
263:12 - and ability finally we have an evolution
263:15 - although this monster doesn't have one
263:17 - but if you look at the next one Finster
263:19 - there we have an evolution we are going
263:21 - to get to gulfin at level 15 so
263:24 - essentially this is what we are going to
263:26 - import and then we have the level that
263:30 - one should be fairly straightforward and
263:32 - basically what we're going to do later
263:33 - on inside of the game data let's have a
263:36 - look at chamad again and let's say for
263:39 - now we only care about the health and
263:41 - this monster has a max health of 27 this
263:43 - is the basee health and that we're going
263:45 - to multiply with the level for example
263:48 - if the monster has a level of 10 then we
263:50 - are going to multiply that value with
263:52 - Max Health I.E 27 so the actual health
263:55 - is going to be
263:57 - 270 all of this data we have to store
264:01 - first of all I want to have self. name
264:04 - and self. level which is simply going to
264:07 - be the name and the level after that I
264:10 - want to get all of the stats of the
264:12 - monster first of all I want to have
264:15 - self.
264:16 - element this we're going to get from the
264:19 - monster data so let me import it all the
264:22 - way at the top I want from gamecore
264:28 - data import monster data and then I want
264:32 - to have monster data I want to use the
264:36 - name of the monster and then I want to
264:39 - go to Stats and finally in there I want
264:43 - to get the element besides that I also
264:47 - want to get all of the base stats which
264:51 - are going to be gotten in basically the
264:53 - same way I can copy the last line and I
264:56 - simply want to get all of the stats with
264:59 - that we have a monster with a name a
265:01 - level and some stats that we can use
265:04 - right away inside of
265:06 - main.py first of all in there I want
265:08 - from Monster import monster
265:12 - and then inside of the dunder init
265:15 - method let's do it all the way at the
265:17 - top I want to create the player
265:21 - monsters which we can store in a
265:23 - dictionary self. player
265:27 - monsters we have the first Monster and
265:30 - for that we need the monster class along
265:32 - with the name of the monster and the
265:34 - level let's say the first Monster could
265:36 - be charm mod pillow at level 30 after
265:41 - that we have monster number one this
265:43 - needs to be another monster what a name
265:45 - for this one let's go with
265:47 - frea and level 29 if I now Run the game
265:53 - we still get the same outcome and I
265:55 - should fix the start position but at the
265:57 - very least nothing is breaking that's a
265:59 - good start now I would recommend to
266:02 - create a few more monsters on your own
266:04 - if you look at game data you can find
266:06 - all of the available monster names in my
266:08 - case I can simply copy it in where we
266:11 - have a whole bunch more monsters also
266:14 - it's really important to keep an integer
266:15 - as the key that way we can sort the
266:18 - actual monsters that will become
266:19 - important very soon anyway at this point
266:22 - we have a bunch of monsters so we can
266:24 - start with the actual index for that I
266:27 - want to create a new python file and
266:30 - save it as monster uncore index don't
266:34 - forgetp and in there we need from
266:36 - settings and import everything then we
266:40 - can create a class I call this one
266:43 - monster
266:45 - index no need for inheritance but inside
266:48 - of the dunder init method we will need
266:50 - self we will need the monsters and then
266:53 - we are going to need some fonts for now
266:56 - after that we want to create self.
266:59 - displore surface which we're getting
267:02 - from pame do display doget uncore
267:07 - surface next up we have to store the
267:09 - font as an attribute self. font is going
267:12 - to to be the font oh and actually this
267:14 - should be self. fonts because we are
267:18 - going to have quite a few different ones
267:20 - in fact inside of main.py when we are
267:24 - importing the assets we want to import a
267:27 - few more I suppose we can do all of the
267:30 - ones that we are going to need for the
267:31 - rest of this
267:33 - tutorial just duplicate the line besides
267:35 - dialog we want to have a regular font
267:39 - which is going to have the same file
267:41 - path the only difference is that the
267:42 - font size is going to be
267:44 - 18 we can duplicate this one more time
267:47 - next up I want to have a small font and
267:50 - this one same font again except now the
267:53 - font size is going to be 14 and finally
267:56 - I want to have a bold font and this one
268:01 - is going to get a different font this
268:03 - one is called
268:05 - doic pixel bolt. ttf and the font size
268:10 - is going to be 20
268:13 - let's try to run all of this and we are
268:15 - getting an error probably because I have
268:18 - a typo in there somewhere let's double
268:20 - check inside of our Graphics font folder
268:24 - we have DOA pixel Boldt so I think the
268:28 - spelling is correct although the file
268:31 - type is wrong this one is an open type
268:33 - fun file which means the ending is going
268:36 - to be
268:38 - OTF let's try this again and there we go
268:41 - the game is running again now that we
268:43 - have that we can minimize this method
268:46 - and then inside of thunder in knit all
268:49 - the way at the bottom I want to create
268:51 - the overlays so in there we're going to
268:55 - have the monster index and the battle
268:57 - system along with the evolution system
268:59 - in fact the dialog tree could also be in
269:01 - there because it's technically an
269:04 - overlay I want to have a self. monstore
269:08 - index for which we are going to need the
269:11 - monster index
269:14 - class that we are not importing at the
269:16 - moment let's do it below here from
269:20 - monster uncore index I want to import
269:23 - the monster
269:27 - index after that we have to pass in I
269:31 - believe it was two arguments we need the
269:33 - monsters and the
269:35 - fonts monsters are going to be self.
269:38 - player
269:40 - monsters and the fonts are going to be
269:42 - self. fonts the thing we have just
269:45 - imported those
269:47 - ones let's try to run all of this the
269:49 - game doesn't crash that's a good start
269:52 - so with that we can start drawing the
269:54 - actual monster index for that first of
269:58 - all I want to create an update method
270:01 - with self and Delta time Delta time in
270:04 - case you're wondering is what we're
270:06 - going to need for the
270:07 - animation inside of this method there
270:10 - are four things that we want to do
270:13 - number one we want to get input number
270:16 - two we want to tint the main game so
270:20 - that we have a bit more of a separation
270:21 - between the game and the monster index
270:24 - after that we want to display the list
270:28 - and finally we want to
270:31 - display the main
270:34 - section just to explain the last two
270:36 - bits if this is our window our monster
270:40 - index is going to look something like
270:42 - this on the left side we are going to
270:45 - have a list of all of the monsters and
270:49 - this one is scrollable so if the player
270:50 - presses up or down we can select one of
270:53 - the monsters and then on the right side
270:56 - we have the actual information with the
270:57 - monster on top all of the stats and then
271:00 - all of the abilities and when I say
271:02 - tinting the game I am talking about
271:05 - tinting the entire rest of the screen
271:08 - and input is well
271:10 - input and I think the easiest thing to
271:14 - get started is with the tint screen that
271:17 - we can do in the dunder init method I
271:19 - want to create a tint surface section
271:22 - and in there I want to have self.
271:25 - tintore
271:27 - surface this is going to be just another
271:29 - surface so pame do surface with the same
271:34 - size as the original display
271:37 - surface I.E from settings I can copy the
271:40 - window width and the window height
271:42 - and then add them in there as a tuple
271:45 - the color of this surface we don't have
271:46 - to change because we want this thing to
271:48 - be black but we do want to change the
271:50 - tint surface Alpha that we do with zore
271:55 - Alpha and for the value in here I went
271:58 - with 200 once we have that all we need
272:01 - to do inside of the update method is
272:03 - call Self dot display surface dot blit
272:09 - we want to blit The Tint surface at
272:12 - position zero and zero that way we cover
272:15 - the entirety of the window after that
272:18 - inside of main.
272:19 - Pi in the run method let me get rid of
272:23 - the whes space inside of the overlays we
272:26 - want to add another section if self.
272:30 - monster
272:32 - index then we want to run self. monster
272:35 - index do update with Delta time if I now
272:40 - Run the game we can see we are tinting
272:43 - the entire screen so this is definitely
272:45 - working now obviously we don't want to
272:48 - display the monster index all the time
272:50 - for that we have to work with the input
272:54 - method inside of main.py at the moment
272:57 - we are only checking if the player is
272:59 - talking to another character besides
273:02 - that I also want to check if keys
273:07 - and pame do
273:10 - Kore turn that is the enter key if that
273:14 - one is pressed we want to display the
273:15 - monster index and there are basically
273:18 - two ways of approaching this either
273:20 - inside of the dunder method you could
273:23 - set none for the monster index and then
273:25 - as soon as the player presses this
273:27 - button we are creating a new monster
273:30 - index very similar compared to what we
273:32 - have done with the dialogue although
273:34 - that's a bit Overkill since the monster
273:37 - index doesn't have to change that much
273:39 - we can approach this in another way that
273:41 - is a bit easier I want to create another
273:44 - attribute self. index open which by
273:47 - default is going to be false and then
273:51 - inside of the run method instead of
273:53 - checking if the monster index class
273:55 - exists I want to check if self. index
273:58 - open and only if that is the case I want
274:01 - to run the update method on this monster
274:04 - index after that whenever we are
274:07 - pressing K return I want to toggle self.
274:11 - index open which you can do by setting
274:14 - it to what it is not I.E not self. index
274:18 - open with a Boolean value we are always
274:21 - going to get the opposite value I.E true
274:24 - becomes false and false becomes true and
274:27 - if I now press enter we can toggle the
274:31 - overlay that is working pretty well now
274:34 - the issue is while the monster index is
274:36 - open we can still walk around which is
274:38 - going to look really weird to fix that
274:41 - we have to do is get our self. player do
274:47 - locked and set it to what it currently
274:50 - is not I.E not self.
274:54 - player dot
274:56 - locked that way in the overboard I can
274:59 - run around if I press enter we get the
275:02 - overlay I cannot walk around anymore and
275:04 - if I press enter again we can walk
275:06 - around once more cool this part is
275:09 - working that covers the first part now
275:11 - we have a background tinting now we can
275:14 - work on the actual monster index and
275:17 - first of all I want to set the
275:21 - dimensions that we are going to do via
275:23 - self.
275:25 - mainor rectangle which is simply going
275:28 - to be pame do F rectangle where we are
275:32 - setting a left side a top side a width
275:36 - and the height now the left and top
275:39 - doesn't actually matter so I can set
275:40 - those to zero and and zero for the wi I
275:44 - want to get window wi and then multiply
275:47 - this with
275:49 - 0.6 I.E we're getting 60% of the window
275:53 - width for the height I want to get the
275:56 - window height and then multiply this
275:59 - with
276:00 - 0.8 or in other words we're getting 80%
276:03 - of the available window height now this
276:06 - rectangle has to be moved to the center
276:08 - and at the moment we are always placing
276:09 - the top left and I am too lazy to
276:12 - calculate the proper position for the
276:14 - top left to Center this rectangle but
276:17 - fortunately I don't have to do that I
276:19 - can simply use the move uncore 2 method
276:23 - and then set Center to window Wii over
276:27 - two and window height over two although
276:32 - all of this needs to be a tal with that
276:35 - we're getting the main rectangle in the
276:36 - center of the window let's try that part
276:39 - actually I want to run P game. draw.
276:43 - rectangle on self. display surface the
276:47 - color doesn't really matter let's go
276:48 - with black and then we want to draw
276:51 - self. main rectangle inside of main. Pi
276:55 - if I press enter we can see the
276:57 - available area for the monster index and
277:00 - that looks pretty good and if you want
277:01 - to have different dimensions go with it
277:03 - you can choose whatever you like in here
277:06 - next up I want to work on the actual
277:10 - list I.E with we're going to start by
277:12 - displaying the list of all of the
277:13 - available monsters for that actually
277:16 - we're going to need all of the monsters
277:18 - as an attribute let's do that at the top
277:20 - self. monsters is going to be monsters
277:24 - after that we can work on the list and
277:27 - there are quite a few attributes that we
277:28 - need to get I want to get self. visible
277:32 - items which I have set to six I.E how
277:35 - many monsters do we want to display at
277:37 - any point in time besides that we want
277:40 - to have self
277:42 - do
277:44 - listor wi this number we're going to get
277:47 - from self. Main rectangle do WID and I
277:51 - want this thing to be 1/3 of the entire
277:54 - available WID of the main rectangle
277:56 - although once again these numbers can be
277:58 - subjective so just choose later on what
278:00 - you think looks best after that I want
278:03 - to get another attribute self. itmore
278:07 - height which is going to be self. main
278:10 - wct do
278:12 - height divided by self. visible items
278:16 - the way you want to think about that is
278:18 - if this is our entire monster index the
278:22 - thing we are setting with main rectangle
278:24 - on this thing we want to create a list
278:27 - roughly on the left side the width of
278:30 - this thing we are setting with list
278:33 - width and then the item height is going
278:36 - to be the item height of all of the
278:38 - items in there and I think that's all we
278:40 - need for now so next up we can work
278:45 - on let's call this method display uncore
278:50 - list no need for custom parameters and
278:53 - in there we want to get four index and
278:57 - monster inself do monsters. items
279:01 - remember monsters is a dictionary that
279:04 - we have created earlier this one I.E the
279:08 - index is going to be zero and then the
279:09 - monster is going to be all of this for
279:11 - the first four Loop and that continues
279:13 - until we get all of the monsters most
279:16 - importantly in there we want to create
279:18 - an item
279:20 - rectangle which we create with pame do F
279:25 - rect where we have to set a left a top a
279:29 - WID and a height like we have done for
279:32 - the main rectangle WID is going to be
279:34 - self dot list wi and the height is going
279:39 - to be self. item height
279:42 - left is also going to be super easy this
279:45 - is simply going to be self. main
279:47 - rectangle do left the only thing that
279:51 - gets a bit more complicated will be the
279:53 - top argument because of that I want to
279:56 - store this in a separate
279:58 - variable imagine we have our list and on
280:01 - this thing we want to have a whole bunch
280:03 - of entries for each of those we have
280:06 - specified one rectangle which means we
280:09 - get a height we get a whift we are
280:12 - getting a starting position that's the
280:15 - left side and the only thing that's left
280:17 - to cover is the top side now we always
280:21 - want to start at the top of the main
280:23 - rectangle the one we have to finded
280:24 - earlier but then for each individual
280:27 - item we want to go a bit further down to
280:31 - actually get a list which essentially
280:34 - means we do want to start at self. main.
280:39 - toop but to that we want to add the
280:43 - index that we getting from the four Loop
280:45 - and this we want to multiply with self
280:47 - do item height that way on the first for
280:50 - Loop index is going to be zero I.E we
280:55 - stick to this top side however if the
280:59 - index goes to one then we are adding one
281:02 - times the item height I we are moving
281:05 - down by the height of one item and we
281:08 - are getting the top of the next item
281:13 - that's basically all that's happening in
281:14 - here after we have that we want to draw
281:17 - the result pame do draw.
281:20 - rectangle self. display surface the
281:24 - color should be red so we can see
281:25 - something and then the item rectangle
281:30 - after that inside of update I can get
281:33 - rid of the display list comment and it's
281:35 - that self. display
281:38 - list if I now try m not Pi I can press
281:41 - enter and we are getting something now
281:46 - this is very difficult to see because
281:48 - all of the items have the same
281:49 - background color but essentially we get
281:52 - one of those items here we get another
281:55 - item there another item down there and
281:58 - so on in total we are going to see six
282:01 - items that cover the height of the main
282:04 - rectangle but after that we are
282:06 - continuing because the player has more
282:08 - than six
282:09 - monsters in fact at least for now if we
282:13 - keep the monster size 26 this should
282:15 - actually work perfectly and there we go
282:18 - this is looking a bit cleaner now later
282:20 - on we're going to account for more
282:22 - monsters so I do want to keep them in
282:24 - there but at least at the moment we know
282:27 - this is working on the basic level and I
282:29 - suppose to make sure we can see things
282:31 - just a bit better I want to create a
282:34 - text surface which is going to be for
282:37 - the name of the monster for that I want
282:40 - to get self fonts and I want to get the
282:43 - regular
282:44 - font this I want to render with monster
282:48 - do
282:50 - name ntls should be fults and for the
282:53 - text color for now I want to use
282:56 - colors and the white color so inside of
283:00 - settings then we have a white color for
283:02 - this text surface we are also going to
283:04 - need a text rectangle text surface.
283:09 - getorf rectangle I want to place the mid
283:12 - left and this point should be the item
283:18 - rectangle do midle as
283:21 - well if this is the entire list we have
283:25 - currently one item
283:28 - rectangle this one
283:30 - here and the text should be let's say
283:33 - roughly here for that I want to place
283:36 - the mid left of the text to the mid left
283:39 - of the entire item rect angle and in
283:42 - just a bit we can add a bit of an offset
283:44 - to the right first of all though I want
283:47 - self. display surface do lit with the
283:51 - text surface and the text rectangle
283:54 - let's try all of that if I not press
283:56 - enter we are getting all of the monster
283:58 - names and that is looking much
284:02 - better and to add just a bit of offset I
284:05 - want to add a
284:07 - vector with 90 and zero that way if I
284:12 - remain. P again we are moving quite a
284:14 - bit further to the right and later on to
284:16 - the left of the name we have a Monster
284:18 - icon for every single Monster in fact if
284:21 - you look at the graphics folder there we
284:23 - have icons and this is going to contain
284:26 - all of the Monster icons we want to
284:28 - display next to the name that is a part
284:31 - we could do right now actually this
284:33 - could be an exercise I want you guys to
284:35 - import all of the Monster icons and then
284:38 - display the appropriate one next to the
284:40 - monster name
284:42 - pause the video now and see if you can
284:43 - figure this one
284:48 - out to get started we have to work
284:52 - inside of import assets because we have
284:54 - to import all of the Monster icons and
284:56 - to keep all of that a bit better
284:58 - organized I want to create another
284:59 - dictionary I call this one the monster
285:02 - uncore frames which is going to be a
285:05 - another dictionary that works basically
285:07 - like the Overworld frames first of all
285:10 - in there I want to have all of the icons
285:13 - and to import those we need our support
285:15 - file again meaning I want to open
285:17 - support. pi and in there we want to use
285:20 - one of those functions to import all of
285:23 - the icon surfaces and what is really
285:26 - important is that we want to keep the
285:28 - name of all of these graphics and for
285:30 - that import for the dictionary is the
285:33 - best one because this One Imports all of
285:35 - the graphics and then keeps the name so
285:37 - we are going to get a dictionary with
285:39 - the name and a graphic I want to import
285:42 - a folder dictionary and the folder path
285:44 - is going to be a folder up I want to go
285:47 - to Graphics then I want to go to icons
285:52 - and that's the folder I want to import
285:55 - then I can print self. monster frames
285:58 - and icons to see what we get if I now
286:01 - run all of
286:02 - this we are getting addictionary with
286:05 - the name of the file along with a
286:07 - surface that means next up when we are
286:11 - creating the monster index I also want
286:15 - to pass in self. Monster
286:18 - frames we don't need support. Pi anymore
286:22 - and inside of monster index I want to
286:24 - have the monster frames from that let me
286:28 - add another section with the frames for
286:31 - now I simply want to get self. iore
286:34 - frames which is going to be the monster
286:38 - frames and I want to get the
286:41 - icons after that inside of display list
286:46 - I want to create an icon surface which
286:50 - is going to be self. icon frames with
286:55 - the monster name next up I want to
286:59 - create an item rectangle which is going
287:02 - to be icon surface and then get F
287:05 - rectangle for this one I want to place
287:08 - this Center once again I want to get the
287:11 - item rectangle do mid left and to that I
287:15 - want to add a vector with 45 and zero to
287:20 - give it just a bit of an offset since
287:22 - the offset for the text is 90 this 45 is
287:26 - going to be right in the middle between
287:27 - the left side of the main container and
287:29 - the left side of the text the last thing
287:32 - we have to do is self. display surface
287:34 - do blit with icon surface and
287:38 - icon rectangle
287:41 - let's try main. p and there we go we can
287:44 - see all of the monsters and if we had a
287:46 - better background color this wouldn't
287:47 - look entirely terrible so instead of
287:50 - using the red color I want to get the
287:53 - colors and the color that I actually
287:55 - want to use is going to be
287:57 - gray next
287:59 - attempt and that is already feeling
288:02 - significantly better and while we are
288:04 - here we should also get rid of the
288:07 - overlap I.E monsters that are not inside
288:09 - of the main rectangle should not be
288:12 - displayed which is actually fairly
288:14 - simple we only want to draw an item if
288:18 - it is inside of the main rectangle which
288:21 - we can check with if item rectangle do
288:26 - Collide wed with self. main rectangle
288:31 - only if that is the case do we want to
288:33 - do all of that let's try this again and
288:36 - there we go now we can only see six of
288:39 - the monsters although the issue at the
288:41 - moment is that none of this is
288:43 - interactive for that we have to get some
288:46 - input I.E Define input no need for
288:50 - custom parameters and then there as
288:52 - usual we want to get all of the keys
288:55 - with pame DOT key and get uncore just
289:01 - uncore rest at the moment there are only
289:04 - two keys that I care about P game.
289:08 - Kore up and I care about py game. Kore
289:14 - down so what do we actually want to do
289:17 - inside of them and well we want to get
289:20 - an index and either increase it or
289:23 - decrease it if we are pressing up we
289:25 - want to decrease it by one and if we are
289:29 - pressing down we want to increase it by
289:31 - one now this index doesn't exist right
289:34 - now I suppose let's create it in the
289:36 - list section self. index is going to be
289:40 - Z by
289:41 - default and with that we can update an
289:45 - index and increase it or decrease it
289:48 - although first of all for that we have
289:50 - to call self.
289:53 - input and just to make sure that this is
289:55 - working let me print self. index if I
290:00 - now run m not Pi I open the index and we
290:03 - are getting a number that's increasing
290:06 - or decreasing so that's pretty good
290:09 - that's a good start with that we don't
290:11 - need to print statement anymore and next
290:14 - up there's one more thing that I really
290:16 - have to do inside of input and that is
290:19 - self do index is going to be self. index
290:27 - modulus and the length of self.
290:31 - monsters very soon we are going to
290:33 - change the color of one of these
290:36 - rectangles depending on their index and
290:39 - for that purpose the index index from
290:41 - the input cannot be greater than that
290:43 - number but that's all we need from input
290:46 - so next up we have to figure out and let
290:49 - me draw this imagine we have a list with
290:53 - at the moment a random number of entries
290:56 - let's say three for now they would all
290:58 - have the index that we are getting from
291:00 - the index in the for Loop I.E we would
291:02 - have zero 1 and two besides that we also
291:06 - have the index that we are getting from
291:08 - the
291:09 - input if those two numbers are the same
291:12 - I.E the input index and the rectangle
291:15 - index are the same then we want to
291:17 - change the color of this current
291:21 - rectangle that way it looks like it's
291:23 - selected for that I want to add a
291:27 - section that I called colors we want to
291:30 - have a custom BG color and later on we
291:33 - also want to have a text
291:36 - color I suppose the text color we can
291:39 - keep white for now let me paste it in
291:42 - there and then when we are rendering the
291:44 - text we want to have the text color for
291:48 - the BG color though right now we are
291:51 - using the gray color so let me copy it
291:53 - in there and then use the BG color when
291:57 - we are drawing the rectangle however
291:59 - this color we only want to get if the
292:02 - current index is different from the
292:05 - input index I.E we want to get gray if
292:08 - self. index is different from
292:13 - index and the name here might not be
292:15 - perfect but just to make sure you
292:17 - understand this index refers to the for
292:19 - Loop index while this self. index refers
292:22 - to the input index that's part of the
292:24 - class however if that is not the case so
292:27 - else then we can get a different color
292:29 - and I want to copy this one the color I
292:32 - want to use is called
292:35 - light and that should already do
292:37 - something if I now open the menu and
292:40 - there we go we can see that we have at
292:43 - least some basic ability to select the
292:46 - monster now this isn't perfect yet and
292:48 - if I go too far down the thing
292:51 - disappears that happens because further
292:54 - down there we have a few more monsters
292:56 - but those we cannot see that's going to
292:59 - be the next issue we will fix but for
293:00 - now this is working reasonably well so
293:03 - next up then imagine this is the entire
293:07 - index or in other words this is the main
293:09 - rectangle the one with have been using
293:11 - throughout on the left side of the Swing
293:13 - we have a list and this list contains a
293:16 - whole bunch of
293:18 - entries on top of that we have a few
293:21 - more entries at the bottom at the moment
293:23 - I believe there are two extra ones as a
293:26 - consequence when we are trying to get
293:27 - the color and we exceed this point we
293:30 - highlighting either this or this monster
293:33 - but since those aren't visible it
293:35 - doesn't really do anything now to fix
293:38 - that issue basically if the index goes
293:41 - too far down we want to lift up the
293:45 - entire list or rather we want to lift up
293:48 - every single rectangle and for that we
293:52 - are going to create a v
293:55 - offset that by default is going to be
293:58 - zero however when we are getting the top
294:01 - side of each of the rectangles we want
294:03 - to add this V offset so at the moment
294:07 - this is not going to do anything if I
294:10 - run all of this no
294:12 - change however if I set the V offset to
294:16 - let's say 200 and I run all of this
294:19 - again we are now drawing every element
294:22 - 200 pixels further down however if I
294:24 - make this number negative let's say 00
294:27 - and I run this again we are now able to
294:30 - see a few more elements at the bottom
294:33 - which means we have to make this V
294:35 - offset relative to the
294:38 - index I.E if we go too far down we want
294:42 - to make this offset negative or in other
294:45 - words by default this value should be
294:48 - zero but only if self. index is smaller
294:52 - than self. visible items if that is not
294:56 - the case else let's say for now 100 just
294:59 - to see what happens so if I now run may
295:02 - not Pi again in the menu I can move
295:04 - around just as before but if I go a bit
295:06 - further down we are now moving the
295:08 - entire list up and that's a good start
295:10 - and we can also reset it but this needs
295:12 - to be a bit more fine-tuned the way you
295:15 - want to approach this problem we once
295:17 - again have the list at the moment with
295:19 - six entries on top of that we are also
295:23 - checking if our V offset is below that
295:27 - point so our index would be further down
295:30 - here if that is the case we want to move
295:33 - the entire thing up by the height of one
295:37 - of those rectangles which means first of
295:40 - all we have to understand how many
295:42 - indexes we are below that list that
295:45 - number we can get and I want to put this
295:47 - in parenthesis right away self. index
295:51 - minus self. visible items and also this
295:55 - number needs to be negative all of that
295:59 - we want to multiply with self. item
296:01 - height let's try that and now if I go a
296:06 - bit further down this is almost working
296:09 - so we have to go
296:10 - two steps further down for this to
296:14 - work which means all we really have to
296:16 - do is to this number add a plus one and
296:21 - then it should be
296:23 - working and that is looking pretty good
296:26 - now we have a nice drop down
296:29 - menu that works just fine that covers
296:32 - the basic part of the list but there's
296:34 - one really important functionality that
296:36 - I also want to cover and that is that
296:38 - the player can rearrange all one of the
296:40 - monsters when a battle starts we are
296:43 - always going to select the first three
296:45 - monsters and the player should be able
296:47 - to choose what those are to implement
296:50 - that we want to look at the input first
296:53 - of all we want to check for another
296:54 - input if keys and py game.
296:59 - Kore
297:01 - space then we want to select one of the
297:04 - monsters for all that I want to create
297:06 - another attribute that we can put right
297:09 - below the index I want to have self.
297:12 - selected index which by default is going
297:16 - to be none basically as soon as we are
297:18 - selecting a monster we are selecting the
297:20 - index of that monster and by default
297:23 - this value shouldn't exist that value we
297:26 - can use because first of all we want to
297:28 - check if not self. selected index I.E at
297:33 - the moment we have not selected anything
297:36 - if that is the case self. selected index
297:39 - should Simply Be self. index that value
297:43 - by the way we can use right away because
297:45 - when we are displaying the list if a
297:47 - monster is selected we want to highlight
297:49 - it which we can do by changing the text
297:52 - color so by default the text color
297:54 - should be white but only if self.
297:58 - selected index is different from the
298:02 - index of the monster if that is not the
298:05 - case so else that I want to get
298:08 - colors and get the gold color let's try
298:12 - all of that if I open the index and
298:14 - select the first Monster by pressing
298:16 - space we get a gold color so that is
298:19 - working really well that means we can
298:23 - check the El's statement and I should
298:26 - explain the basic system is going or in
298:28 - other words we have a selected index
298:31 - then we want to switch those two
298:33 - monsters however if we are pressing
298:35 - space and monster has been selected
298:42 - for that we first of all want to get
298:45 - this selected monster which is going to
298:48 - be self. monsters with self. selected
298:53 - index and notice here we getting the
298:56 - actual monster on top of that we want to
298:59 - get the current
299:01 - monster which is going to be self.
299:03 - monsters with self. index once we have
299:08 - those two monsters we can assign them to
299:10 - a new index I.E self.
299:13 - monsters
299:15 - self.
299:16 - index is going to be the selected
299:20 - monster then I can duplicate all of this
299:23 - because
299:24 - self. selected index should be the
299:28 - current monster and finally self.
299:31 - selected index should go back to being
299:34 - none so inside of the game I can select
299:37 - a monster and then select another
299:39 - monster and this didn't work although if
299:41 - I now click on the first Monster again
299:44 - they do switch so logic does work but
299:46 - something else has gone wrong and I
299:49 - think I know why the issue is this if
299:52 - statement this one is going to trigger
299:54 - as soon as we have one selected monster
299:57 - but that's not exactly what I
299:59 - want instead I want to have if selected
300:03 - index is different from none if that is
300:07 - the case I want to get all of this
300:11 - with the El statement covering the
300:12 - monster being selected for the first
300:14 - time let's try this one now and if I
300:18 - select a monster and another monster
300:20 - they switch places so this system is
300:22 - working much better and I suppose I
300:25 - should go through all of this one more
300:27 - time imagine we have a list with a few
300:30 - entries they all have an index 0 1 2 and
300:34 - three if the player presses space on one
300:36 - of them we're getting a selected index
300:39 - let's say this one could be Z that way
300:41 - we are selecting the first Monster after
300:44 - that if the player presses space again
300:46 - we are triggering this if statement and
300:49 - let's say this happens on index 2 if
300:52 - that is the case we are first getting
300:54 - the monsters we have selected I.E the
300:57 - selected monster and then the monster we
300:59 - currently have targeted after we have
301:01 - that we are simply switching them around
301:04 - or in other words we are simply
301:05 - overwriting the
301:07 - indexes and after that we are getting
301:09 - rid of selected index and then we are
301:12 - done that covers the input there's just
301:15 - one more thing that I really want to do
301:16 - for the list actually two things I want
301:19 - to do for the list the first one is
301:21 - going to be rounded
301:23 - Corners if you look at this thing again
301:26 - it doesn't look amazing and the big
301:29 - reason for that are the really sharp
301:30 - Corners which usually do not look great
301:34 - those we can fix inside of the drawing
301:36 - logic let me add another comment check
301:39 - or
301:40 - nurse so what we want to check in here
301:43 - is if this is the entire main rectangle
301:47 - we have to check if an item rectangle is
301:50 - in the top left or in the bottom
301:54 - left if I of those is the case we want
301:57 - to have one rounded Corner either here
301:59 - or here which means we want to check if
302:04 - item rectangle do Collide point Enter
302:08 - point we want to check is cell
302:10 - main rectangle. toop left or in other
302:14 - words if the top left of the main
302:15 - rectangle collides with our current
302:17 - rectangle we know we are in the top left
302:21 - if that is the case we want py game.
302:24 - draw. rectangle self. display surface BG
302:29 - color item rectangle so all the stuff we
302:32 - have done already but then we want to
302:34 - set a corner radius that is going to be
302:37 - 0 0 and 12 and the logic for the drawing
302:41 - of the other rectangles we can put in an
302:43 - L statement although the text and the
302:46 - icon need to be always visible so let's
302:49 - add a bit of white space if I now run
302:51 - main Pi we are getting a rounded corner
302:54 - at the top left now this isn't perfect
302:57 - because we are also drawing the entire
303:01 - background main rectangle which we don't
303:03 - actually have to do so let's try this
303:06 - again and that is looking much better so
303:09 - next up I want to have an L if statement
303:13 - that checks if item rectangle. Collide
303:18 - point with self dot main rectangle
303:23 - bottom left although to this one I want
303:26 - to add a very minor
303:28 - offset of one and negative 1 I we're
303:32 - going one pixel to the right and one
303:34 - pixel up sometimes the bottom left
303:36 - wouldn't be properly detected by Collide
303:38 - Point don't know exactly why but it
303:41 - happened fairly
303:42 - consistently and if we had a minor
303:44 - Vector offset this problem disappears
303:46 - entirely so once we have that we want to
303:49 - draw a rectangle with a different Corner
303:53 - radius this one is going to get or zeros
303:56 - then a 12 and then another zero so let's
304:00 - try this one again and there we go if
304:02 - you now look at the bottom left we are
304:05 - getting around the corner and this one
304:07 - always seems to be working just fine
304:10 - now in case you're wondering what
304:12 - arguments you need for all of this if
304:14 - you look at the documentation for pame
304:16 - and you look at draw. rectangle you can
304:19 - see that we have a whole bunch of Border
304:22 - radi where you can for example set the
304:25 - top right radius the bottom left radius
304:28 - the bottom right radius and so on these
304:31 - numbers can be a bit confusing
304:33 - especially early on it even took me a
304:35 - few minutes to get this one right with
304:37 - that we have rounded Corners there's
304:39 - just one more thing that I would like to
304:40 - add and that is let me run all of this
304:43 - again actually in just a bit we're going
304:46 - to draw a whole extra thing to the
304:50 - right something like this and to
304:53 - separate these two areas I want to add a
304:56 - very minor
304:57 - Shadow down here so it looks like that
305:00 - all of these elements are a bit in the
305:02 - background now in practice all that we
305:04 - are going to do is we are going to draw
305:06 - a semi-transparent surface down on here
305:11 - and then we can call it a day which
305:13 - means all the way at the
305:16 - end and this one should be outside of
305:20 - this for Loop let me minimize the for
305:21 - Loop
305:23 - actually we want to draw a
305:27 - shadow for which we're going to need a
305:29 - shadow surface first of all pame do
305:35 - surf then we will need a whift and a
305:37 - height for the whift I simply went with
305:39 - four pixels and the height is going to
305:41 - be self do main rectangle do height and
305:45 - then we want to get self. display
305:47 - surface do blit where we are blitting
305:51 - the shadow surface in a certain position
305:54 - for which we are going to need an X and
305:56 - A Y point now Y is PR simple self. main.
306:01 - toop for X we're going to get self.
306:04 - mainr do left and to that we want to add
306:08 - self do
306:10 - list wi although don't forget to
306:12 - subtract four to actually show The
306:15 - Shadow surface actually let me run the
306:18 - entire thing without it if I now run
306:20 - may. Pi we have a thing to the right of
306:23 - the list and together to the right
306:26 - border of the list we want to subtract
306:28 - four or the width of the surface and
306:30 - there we go now it's on top of all of
306:32 - the other items that however isn't
306:35 - terribly visible because this Shadow
306:36 - surface doesn't have a transparency
306:39 - which we can change with Shadow surface
306:41 - and set Alpha and then set some kind of
306:45 - value let's go with 100 and if I now run
306:48 - M of Pi that is looking quite
306:52 - nice later on once we have the other
306:55 - part of the index you can customize this
306:57 - but I think for now this is working
306:58 - reasonably well cool that covers the
307:01 - first part of the index although there's
307:03 - one thing that I forgot if you run May
307:06 - notp again there should be a whole bunch
307:09 - of of lines separating all of these
307:11 - monsters stuff like this and that part
307:15 - could actually be a fairly interesting
307:17 - exercise or in other words try to draw
307:20 - lines between the monster entries the
307:22 - colors for now don't really matter
307:24 - simply choose something that works what
307:26 - is really important is that you
307:28 - understand the positioning so pause the
307:30 - video now and see how far you
307:36 - get to get started I want to minimize
307:39 - the for Loop and then add another
307:42 - section for the lines first of all we
307:45 - going to need another for Loop let's
307:47 - call it for I in range and this one is
307:51 - going to be self. visible items inside
307:55 - of there we want to go with py game.
307:58 - draw. line for which we're going to need
308:01 - a surface self. display surface and then
308:04 - we are going to need a color which we
308:07 - can get from colors and the one I want
308:09 - to choose is called light gray finally
308:13 - we need a start point and an end point
308:16 - to get those points we essentially need
308:19 - three numbers the Y position the left
308:22 - side and the right side now the left
308:26 - side is going to be really simple self.
308:28 - main re. left and the right side is
308:32 - going to be self. main R do left plus
308:37 - self. list Wii that way we are defining
308:41 - the left and the right side now we just
308:44 - have to figure out the actual y position
308:47 - now this one also isn't terbly difficult
308:49 - self. main re. toop plus self. item
308:55 - height multiplied by I the value we're
308:58 - getting from the for Loop and with that
309:00 - we have the three points that we need so
309:02 - for the start value I need X and Y the
309:07 - start point is always going to be the
309:08 - left side and Y is going to be the value
309:10 - we have just
309:11 - created then for the end point we want
309:15 - to get the right side and keep the same
309:17 - y the line we are going to draw is going
309:19 - to be horizontal so one point here is
309:21 - totally fine let's try all of this and
309:24 - there we go we have a line separating
309:26 - all of the monsters and this one also
309:28 - updates with the movement so this is
309:31 - looking pretty good however there's one
309:34 - thing that is going to mess this one up
309:36 - a bit if we don't have enough monsters
309:39 - to fill the entire list let's say we
309:41 - only have three monsters in total if I
309:44 - now run this again we are drawing way
309:46 - too many lines which is going to look
309:48 - really weird to fix that inside of the
309:51 - for Loop we want to look for the smaller
309:53 - number between the visible items and the
309:57 - length of self.
309:59 - monsters if we are doing
310:02 - that we are only drawing two lines so
310:06 - that is working pretty well now we are
310:08 - still dra drawing the entirety of the
310:10 - Shadow and I think that part is fine I
310:12 - suppose once we have the other elements
310:14 - we can look at this one again but I
310:15 - think it's not going to be an issue
310:17 - anyway with that I can uncomment the
310:19 - other monsters and we have the list part
310:21 - of the index next up we have to work on
310:24 - the monster display so for that one we
310:28 - don't need display list anymore instead
310:31 - I want to Define display underscore Main
310:36 - in there we are going to need Delta time
310:38 - because because we will have a monster
310:40 - animation in just a bit first of all we
310:43 - want to create the main
310:46 - background for that we will need another
310:48 - rectangle which is going to be py game.
310:50 - F rectangle with the usual arguments
310:54 - left top W and height left is going to
310:57 - be self. main w. left plus self. list
311:03 - Wii if this is the entire main rectangle
311:07 - we want to have a list on the side
311:10 - with the list with being defined by the
311:12 - attribute this is the part we already
311:14 - have and what we want to do now is to
311:16 - create or rather cover the entire rest
311:19 - of the main rectangle at the moment we
311:21 - have the left side which is going to be
311:23 - this line or the top we want to have
311:26 - this line and then all of this for the
311:28 - width and all of this for the
311:31 - height should be fairly straightforward
311:33 - top is simply going to be self. main.
311:37 - top the WID is going going to be self.
311:40 - main. wift minus self
311:44 - do list wift and the height is going to
311:47 - be self. main. height now I am running a
311:52 - little bit out of space but this is
311:54 - still doable it's not terribly
311:56 - complicated or at least I hope it isn't
311:58 - let's actually draw this with pam. draw.
312:02 - rectangle where we want to draw on the
312:04 - display surface the color is going to be
312:08 - from color and we want to get the dark
312:11 - color and we want to draw the rectangle
312:14 - after that inside of update self.
312:18 - display main with Delta time let's try
312:22 - main.
312:23 - pi and if I open this we have something
312:27 - that looks not too bad although we are
312:30 - going to need a corner radius up here
312:32 - and down here for that we have to add a
312:35 - few more arguments it's going to be zero
312:39 - 12
312:41 - 0 12 and
312:44 - zero with that inside of main.py we are
312:48 - getting rounded Corners that is looking
312:50 - pretty good next up we can work on the
312:53 - monster display I suppose to give a bit
312:57 - more context I want to separate this
313:00 - area broadly into two bits at the top we
313:04 - want to have one rectangle that displays
313:07 - the monster in the middle
313:09 - that's the part we are going to work on
313:10 - for now after that we have all of the
313:13 - stats down here and at the end we're
313:16 - going to add the abilities in the bottom
313:17 - right for all of this I want to create
313:20 - another rectangle I call this one the
313:22 - top rectangle which once again is going
313:25 - to be py game. F rectangle for this one
313:28 - we have to specify as always left top
313:30 - width and height or to keep this a bit
313:33 - more concise we want to specify a
313:35 - position and a size this is a bit easier
313:39 - because I want to get the rec. top left
313:42 - for the top left of this rectangle if
313:46 - this is the entire main rectangle we are
313:48 - currently working inside of this part
313:51 - that we defined via the rectangle in
313:53 - there we want to create a top rectangle
313:56 - that is covering roughly this area at
313:59 - the moment we have specified the
314:01 - starting position the top left which can
314:03 - be the same as the rectangle after that
314:06 - we need the size which needs to have the
314:08 - same WID as the rectangle and some
314:11 - fraction of the height in other case
314:14 - this has to be a tupal wi for the well
314:17 - width and then for the height I want to
314:19 - get w. height and multiply it with
314:24 - 0.4 this we want to draw right away py
314:27 - game. draw. rect on self. display
314:31 - surface let's say for now with a red
314:34 - color and then we want to get the top
314:37 - rectangle keep a mind mind though we are
314:39 - still going to need the corner radius
314:41 - for that we need 0 0 0 and
314:45 - 12 let's run main
314:47 - pi and then we can see we have a top
314:51 - rectangle and everything else still
314:53 - works just fine that's a good start but
314:56 - we need a bit more information basically
314:59 - for every monster element I want to have
315:01 - an appropriate color in other words if
315:04 - you look at settings there we have for
315:06 - example a color for plant a color for
315:08 - water and the color of fire and this we
315:10 - want to use for the background of the
315:12 - monster for that we first of all need an
315:14 - actual monster and that I want to do all
315:17 - the way at the top of display main let's
315:20 - call this part data all I really care
315:22 - about in here is the monster itself
315:24 - which we are getting from self. monsters
315:27 - and then self.
315:29 - index self. monsters as a reminder is
315:32 - simply going to be this and our index is
315:36 - number in there meaning via this we
315:38 - getting our currently selected monster
315:41 - after we have that we can use the colors
315:45 - and then get monster do
315:49 - element that is the element we have
315:51 - created earlier that is simply going to
315:53 - be fire water or plant which is going to
315:57 - be the same key that we are using in the
315:59 - colors dictionary so this should already
316:01 - be
316:02 - working if I open the thing then we are
316:05 - getting the different elements so that
316:06 - is working pretty well now after that we
316:09 - have to display an actual monster
316:11 - animation which at the moment we cannot
316:14 - do because we have not imported the
316:17 - monster surfaces themselves so inside of
316:21 - the project folder we want to go to
316:23 - graphics and in there we have all of the
316:26 - monsters this is what we want to import
316:28 - and just to open one of them let's go
316:30 - with this one we always have a tile set
316:34 - with eight parts where the top bit is an
316:36 - idle animation with the B one being the
316:39 - attack animation and to import all of
316:42 - that we want to reopen our support. PI
316:46 - file support dop and there we want to
316:50 - create another function let's put it
316:53 - just above the game functions I want to
316:55 - have a monster
316:57 - importer which is going to need the
316:59 - amount of columns the amount of rows and
317:03 - then a path that we are unpacking after
317:06 - that I want to create a monster
317:08 - dictionary
317:09 - that is going to be empty for now for
317:12 - the setup of this dictionary I want to
317:14 - have key value pairs where a key would
317:16 - be a
317:17 - monster the associated value is going to
317:20 - be a dictionary in which we have the
317:23 - tack key along with a list of surfaces
317:27 - and then we also have an idle entry with
317:30 - another list of surfaces that's we want
317:33 - to create although by default this thing
317:34 - should be empty now just as before we
317:37 - want to have four folder path
317:40 - subfolders and image names in walk
317:46 - join and the path unpacked in there we
317:50 - want to look at all of the images I.E
317:52 - for image in image names and for now
317:57 - let's simply print what we get I want to
317:59 - print the image after that inside of
318:03 - main.py when we are importing all of the
318:06 - assets inside of monster frames I want
318:09 - to create another entry for all of the
318:12 - actual monsters for this one we want to
318:14 - have the monster importer the folder
318:18 - path is going to be one folder up then
318:20 - we are going to graphics and in there we
318:24 - have the monsters let's run the entire
318:27 - game and we cannot see anything and I
318:31 - believe the issue is that when we are
318:33 - creating monster importer we have
318:35 - columns rows and then a path but when
318:38 - I'm calling function we are only
318:40 - specifying a path to fix that we have
318:43 - four columns and two rows and then we
318:45 - have the path let's try this again and
318:48 - now we are getting all of the file names
318:51 - and those are all of our
318:52 - monsters that feels much better first of
318:55 - all then we want to have an image uncore
318:59 - name which is simply going to be image
319:01 - dos split we want to split this wherever
319:04 - we have a DOT and then pick the first
319:06 - item that we can use right away inside
319:09 - of the Monster dictionary to create a
319:11 - new key value pair where the key is the
319:14 - image name and the associated value is
319:18 - an empty dictionary after that we need
319:20 - the actual import and we want to
319:22 - separate all of the images which we have
319:24 - already done by using import tile map
319:28 - which means for every single one of the
319:30 - monsters we want to create a new frame
319:33 - dictionary which we get from import tile
319:37 - map where we passing through the columns
319:40 - and the rows along with a file path that
319:44 - we are getting from the path along with
319:46 - the image name and just to make sure
319:49 - that you are still following along I
319:51 - want to print the Monster dictionary and
319:54 - I want to print the frame dictionary if
319:57 - we now run main. Pi nothing crashes good
320:00 - start and then we are getting a whole
320:03 - bunch of data first of all we are always
320:06 - getting the monster along with an empty
320:08 - Di AR that part's easy after that we're
320:11 - getting the return value from import
320:14 - tile map the way this one is going to
320:16 - work is we have a column and a row or X
320:19 - and Y along with a surface for this part
320:22 - which means we simply have to go through
320:24 - all of the keys and then sort all of
320:26 - these surfaces by their rows and as a
320:29 - reminder the first row is going to be
320:31 - the idle animation and the second row is
320:34 - going to be the attack animation or in
320:36 - other words I want for key
320:39 - and row in
320:43 - enumerate or the list idle and attack
320:49 - that way for of the monsters I'm going
320:50 - to get a key along with a row just to
320:54 - make sure you see what we are getting we
320:56 - always getting zero for idle and one for
320:58 - attack once we have that I simply want
321:00 - to get the Monster dictionary then the
321:04 - image
321:05 - name and then create a new key
321:09 - the associated value for this key is
321:10 - going to be a list of values that we
321:12 - getting via list comprehension since we
321:15 - already have the row we have to get the
321:17 - column I.E call for call in range FS
321:23 - that would give us a number from 0 to
321:25 - three or whatever our columns is that we
321:28 - can use with the frame dictionary the
321:30 - one we have just created this one we can
321:33 - Access Wireless comprehension with a
321:35 - tall that has X and Y or column and row
321:38 - to be a bit more
321:41 - specific which are the values we are
321:43 - already getting either via list
321:44 - comprehension or via the for Loop that's
321:47 - basically all we had to do if I now go
321:50 - back to main.py and after we are doing
321:52 - the import I want to print self. monster
321:56 - Rams with the
321:59 - monsters let's run main. pi and after a
322:02 - second of loading we are getting an
322:05 - error that we cannot find a certain key
322:07 - and you can see what what the issue here
322:09 - is at the moment we have a frame
322:10 - dictionary and we try to get one value
322:13 - the value python currently sees is zero
322:16 - and idle which does not exist inside of
322:19 - this dictionary now the issue here is
322:21 - that I simply switched around to these
322:23 - two values the row is what we're getting
322:26 - from enumerate so this one should be
322:27 - zero or one and then the actual name for
322:30 - the dictionary is going to be the key
322:34 - the one that we are getting from the
322:36 - tubal if we are now trying out of this
322:38 - again then it should work and we are
322:40 - getting none that's a very easy thing to
322:43 - fix it simply happens because we are not
322:45 - returning anything from the monster
322:47 - importer meaning we want to return the
322:49 - Monster dictionary and next attempt now
322:53 - we are getting something and once again
322:57 - massive amount of data but first of all
322:59 - we have the monster then we have a
323:01 - dictionary with Idol there we have a
323:04 - bunch of surfaces and then we have an
323:06 - attack animation which once again is
323:08 - another bunch of surfaces that looks
323:11 - pretty good so now we don't need the
323:13 - print statement anymore instead we have
323:16 - to work inside of monster index also we
323:18 - don't need support. Pi anymore next up I
323:21 - want to do the monster animation for
323:25 - this one first of all we're going to
323:26 - need a monster uncore surface for which
323:31 - we have to do a bit more inside of the
323:33 - dunder init method at the moment we only
323:35 - really have the icon frames besides that
323:38 - that I want to have self.
323:40 - monstore
323:42 - frames which we can get from Monster
323:46 - frames although from this thing we only
323:48 - want to get the monsters the key we have
323:51 - specified here after that to get the
323:54 - actual monster surface we want to get
323:57 - monster frames and then pick a key now
324:00 - that key is going to be a name which we
324:02 - have inside of the monster there we have
324:04 - a name which means we want to get our
324:06 - current monster and then a name
324:09 - although at the moment the return value
324:10 - for this one would be another dictionary
324:13 - where we have the attack or the idle
324:15 - frames now in my case I only want to get
324:19 - the idle frames and just for now to test
324:21 - things I want to get the first item that
324:25 - way we have one surface and just to
324:27 - print that this is working let's print
324:29 - the monster surface if I now try m. Pi
324:33 - we have to wait a second and I can run
324:35 - this and I always have one surface
324:38 - printed out next up I want to create a
324:41 - monster rectangle which is simply going
324:44 - to be the monster surface and then get F
324:49 - rectangle where we want to place the
324:51 - center and the target position should be
324:54 - the top
324:56 - W do Center finally all we have to do is
325:00 - self. display surface. blit with the
325:03 - monster surface and the monster
325:06 - rectangle let's try pi and in the menu
325:11 - we can now see all of the monsters
325:13 - that's coming together quite well
325:15 - although it could look better by
325:17 - animating all of this for that first of
325:20 - all we are going to need a frame index I
325:24 - suppose we could put that one all the
325:26 - way at the top self. frame uncore index
325:30 - which by default is going to be zero
325:33 - after that we don't need the dunder nit
325:35 - method anymore we want to increase self.
325:38 - frame index I.E plus equals some kind of
325:42 - Animation speed ideally the one we are
325:44 - getting from settings so plus equal
325:46 - animation speed multiplied with Delta
325:49 - time using this Frame index we then want
325:51 - to pick one of the surfaces from the
325:53 - idle frames I.E in there we want to get
325:57 - integer self. frame index that way we
326:01 - would get different frames although we
326:03 - would run out of frames really quickly
326:05 - to fix that we want to get the modulus
326:07 - the length of self
326:10 - monster frames we want to look at
326:13 - monster. name and then at the idle
326:16 - frames arguably this line is getting a
326:19 - bit long but the ultimate logic isn't
326:22 - too
326:24 - difficult we have seen all of this for
326:26 - the entities already so I hope it's not
326:28 - too confusing but anyway let's try main.
326:32 - pi and we are getting an
326:35 - animation not an amazing one but it
326:38 - definitely makes the entire thing feel
326:40 - much better that means next up we can
326:43 - add some text to all of this first of
326:45 - all I want to display the monster name
326:48 - for which we are going to need a name
326:50 - surface which we get with self. fonts we
326:54 - want to have the Bold font and this we
326:56 - want to render the text we want to
326:58 - display is going to be monster. name
327:01 - antialias should be faults and colors
327:04 - should be colors and the white color
327:08 - then we are going to need name.
327:10 - rectangle which will be the name surface
327:13 - get F rectangle I want to place the top
327:17 - left to the top W top
327:21 - left I we are placing the name all the
327:24 - way in the top left of the top rectangle
327:27 - and for that we are also not going to
327:28 - need a tuple but I do want to add a
327:32 - vector for an offset I want to move the
327:34 - name 10 pixels to the right and 10
327:36 - pixels down after that self. display
327:39 - surface dolit name surface and name
327:45 - rectangle let's try main note pi and
327:48 - then we getting the name of the monster
327:51 - that's looking pretty good after that we
327:54 - can work on the level for which we can
327:56 - do something fairly similar compared to
327:58 - the name I.E let me copy all of this but
328:01 - I do want to change the name to level
328:06 - like so after that for the font I want
328:09 - to have the regular font and the thing
328:12 - we want to render will be an F string
328:16 - into which we are entering monster.
328:18 - level nlas and colors can stay the same
328:21 - though for the positioning we want to
328:24 - get the bottom left and then place it in
328:29 - the top right dot bottom left plus the
328:33 - vector 10 and
328:36 - -10 if I now run main Pi you can see
328:40 - that we have the level in the bottom
328:42 - left although that is a bit sparse so I
328:46 - think what we could be adding is
328:47 - something like
328:50 - level and then this should be a bit more
328:54 - explanatory that feels nice there's one
328:57 - more really easy thing that we can add
328:59 - for that I want to copy all of this text
329:02 - one more time because I want to display
329:05 - the element and this element should in
329:08 - the bottom right of the top W container
329:11 - once again I want to replace the level
329:14 - in all of these lines with element for
329:18 - the font we can stick with regular for
329:21 - the text that we want to display we
329:23 - simply want to get monster. element
329:27 - color can stay white this one is totally
329:29 - fine after that for the position since
329:31 - we want to be in the bottom right the
329:33 - point that we want to place will be the
329:34 - bottom right then we want to get the top
329:37 - wck
329:38 - and the bottom right and give this thing
329:42 - an offset of vector -10 and
329:46 - -10 let's try all of that and the game
329:50 - doesn't crash and we get the element so
329:53 - with that we are displaying a whole
329:56 - bunch of text but there's one more thing
329:58 - that I want to do for the level and that
330:00 - should be an XP bar or in other words
330:05 - let's do this in the game right away
330:06 - actually
330:08 - if you look at the monsters below the
330:10 - level I want to display a bar that is
330:13 - going to show us how close we are to a
330:15 - level up and this bar should have a
330:18 - white part to show how much we have and
330:20 - then a darker bit to show how much is
330:22 - left meaning we have to figure out how
330:24 - to draw a bar and also this should be
330:28 - reusable because later on for the stats
330:30 - we want to draw a whole bunch of those
330:33 - all of that we can put in a function
330:35 - that I want to keep inside of support.
330:37 - Pi
330:39 - all the way at the bottom I want to have
330:42 - Define draw bar for which we're going to
330:46 - need a whole bunch of parameters first
330:49 - of all we want to have a surface to draw
330:51 - on then we will need a rectangle for the
330:53 - position we want to have a value a max
330:58 - value then we need a color a BG color
331:03 - and finally a radius although for this
331:05 - one we can set a default value of one
331:08 - now for the logic of drawing a bar
331:11 - there's only really one complicated
331:13 - thing and that is via dangle we're going
331:16 - to set the size of this thing so let's
331:19 - say we could have something like this
331:22 - where the width of the rectangle is 100
331:24 - pixels and the height could be 20 pixels
331:28 - the specific numbers here really do not
331:30 - matter the actual issue is for the value
331:34 - we might have something like 150
331:38 - so we have to figure out how to put 150
331:41 - Health points into 100 pixels or in
331:45 - other words if we have 150 we want to
331:47 - fill the entire 100 pixels and if we
331:51 - were at 75 then we would only want to
331:54 - cover 50% of the width something like
331:57 - this to get started with that we first
332:00 - of all need a ratio between the value
332:03 - and the width of the rectangle or in
332:05 - other words rect do width
332:08 - divided by Max value that is going to
332:11 - tell us how much value we get per pixel
332:14 - after that I want to create the BG
332:16 - rectangle which is simply going to be a
332:19 - copy of the rectangle that we are
332:21 - passing in via the argument on top of
332:23 - that we want to create a progress
332:27 - rectangle which is going to be py game.
332:30 - F rectangle with a position and a size
332:35 - the position is super easy we can simply
332:37 - get get re. top left we want this
332:41 - progress rectangle to be in the same
332:43 - position as the background rectangle or
332:45 - the rectangle we are passing in as an
332:47 - argument for the size we're going to
332:49 - need a width and a height the height is
332:52 - super easy we simply want to get the wct
332:54 - and the height of that one although for
332:57 - the width we want to get the value and
332:59 - multiply this with the ratio and that's
333:02 - basically all we need after that we can
333:05 - get pame do draw do rectangle we want to
333:10 - draw on the surface we want to draw with
333:13 - the background color and then BG
333:17 - rectangle we do not want to have any
333:19 - border width but we do want to include
333:21 - the radius the one that we have
333:23 - specified in the parameters as
333:25 - well that we can now duplicate next up I
333:28 - want to draw the progress rectangle I
333:31 - want to draw the progress rectangle with
333:33 - the color and the progress rectangle and
333:38 - that is actually all we need let's use
333:41 - it inside of monster. py first of all we
333:44 - will need from so Port import draw bar
333:50 - and then for the XP bar I want to call
333:54 - draw bar with all of the arguments that
333:56 - we have specified the surface is going
333:59 - to be self. display surface for the
334:02 - rectangle we have to create a whole new
334:05 - rectangle and I believe it would could
334:07 - be a bit cleaner to use named arguments
334:10 - over multiple lines and then for the
334:13 - rectangle we want to create py game do f
334:17 - rect for the top left of this rectangle
334:20 - we want to get the level rectangle do
334:24 - bottom left in other words the bottom
334:27 - left of this level rectangle and for the
334:30 - size we can go with 100 and four numbers
334:34 - that I thought just looked
334:36 - good next up we have the value and for
334:39 - that ideally we want to have something
334:40 - like monster.
334:42 - XP something that doesn't exist at the
334:45 - moment because in Monster we only have
334:47 - the name the level the element and the
334:49 - stats which means we want to add another
334:52 - section let's call it
334:54 - experience and there we will need self.
334:57 - XP which by default can be zero then we
335:00 - want to have self. levore up which is
335:04 - going to be self. level
335:08 - times
335:11 - 150 level up is going to be the amount
335:14 - of XP we need to get to the next level
335:17 - for level one it's going to be 150 for
335:18 - level two it's going to be 300 and then
335:20 - so on meaning with that we have monster.
335:23 - XP for the value and for the max value
335:26 - we want to have monster. levore up after
335:31 - that we are just going to need the
335:32 - colors and in there for the foreground
335:35 - color I want to get colors and white the
335:40 - same color we are using for the text and
335:42 - for the background color I want to have
335:46 - colors and dark also I am happy with a
335:50 - default radius of one so we can get rid
335:52 - of this part and now Run main.py the
335:55 - game doesn't crash and there we go we
335:58 - can see an XP bar that at the moment
336:01 - doesn't really show anything so what we
336:04 - could be doing after we are creating all
336:06 - of the monsters
336:08 - I want to give every single one of them
336:09 - a random amount of XP that we can do
336:12 - inside of monster. Pi by importing from
336:16 - random import Rand in and then XP is
336:22 - going to be a random integer between
336:24 - zero and a
336:26 - th000 for some monsters this is going to
336:29 - look a bit weird but if I now run all of
336:31 - this we can see that we have bars for
336:36 - all of the monsters that actually
336:37 - display something the problem is that
336:40 - some bars have way too much
336:42 - xp these monsters should have leveled up
336:45 - especially this one that is an issue we
336:47 - can fix later on when we have the
336:49 - evolution mechanic I suppose for now
336:51 - what we could be doing inside of the
336:54 - draw bar function we could set a minimum
336:57 - and a maximum value or in other words we
336:59 - want to make sure that this value time
337:02 - ratio never gets wider than this
337:04 - rectangle I want to create another local
337:07 - variable let's call it progress for that
337:10 - first of all we want to make sure that
337:12 - we never go below zero Max zero and then
337:16 - the value we have gotten from value
337:18 - times ratio let me cut it out actually
337:21 - and then fix my typo and then use
337:25 - progress in there for the width of the
337:27 - progress rectangle that way the
337:30 - rectangle can never go in the other
337:32 - direction which would happen if it was
337:34 - to become negative after that we have to
337:36 - set a maxim value which we do via the
337:39 - Min function we want to have either our
337:42 - value time ratio or we want to have the
337:46 - rect do
337:48 - WID re. WID would be the background
337:51 - rectangle and this should be our maximum
337:53 - width so now I can run main not Pi again
337:56 - and
337:58 - now we are never exceeding the bar so I
338:03 - think that looks pretty good this might
338:05 - have been a bad example let's try this
338:07 - again
338:09 - and there we go so this monster has a
338:11 - lot of XP this one as well and this one
338:13 - as well but we never exceed the length
338:16 - of the bar itself so quite happy with
338:19 - that that means we can work inside of
338:21 - the monster index again although there's
338:24 - one more minor change that I want to do
338:26 - at the moment this draw bar is a little
338:29 - bit below the element which I don't
338:31 - think looks good or in other words if I
338:33 - open the menu again if you look at the
338:36 - elements we have fire on this line and
338:39 - then the level is a bit below that
338:42 - ideally I want those to be on the same
338:45 - line it should be a bit high up for that
338:48 - first of all I want to display the level
338:50 - just a little bit higher which we can do
338:53 - by setting the offset to 10
338:56 - and6 that should already help quite a
338:58 - bit and yeah I think that looks better I
339:02 - suppose you could work with these
339:04 - numbers a bit more to get the perfect
339:06 - value but I I'm going to leave it as it
339:08 - is this is fine so with that we can
339:11 - start on the main part there are a
339:14 - couple of elements that we have to cover
339:16 - so once again this is our entire index
339:20 - and we already covered the list on the
339:22 - left side we are also covering the
339:25 - monster all the way on top after that I
339:28 - want to have a health bar and an energy
339:32 - bar roughly here and Below those I want
339:35 - to have all of the stats and all of the
339:39 - abilities and to go through it step by
339:41 - step let's start with the health and the
339:44 - energy bar now I guess main part isn't
339:46 - ideal in terms of naming let's call this
339:49 - health and energy for that I first of
339:52 - all want to create a dictionary with a
339:55 - few data points I call this one bar data
339:59 - and for this thing we want to get for
340:02 - example the Wii which would be the
340:06 - rectangle so our rectangle for the
340:09 - entire thing the main background I want
340:12 - to get the width of this and then
340:14 - multiply it with
340:16 - 0.45 and I want to have a height which
340:20 - would simply be 30 pixels with those two
340:23 - numbers we get the width and the height
340:25 - of the two bars on top of that I want to
340:28 - get the top for them as well which is
340:32 - going to be the
340:34 - top rectangle dot bottom
340:38 - plus let's say for now 50 pixels one
340:41 - more key value pair that we need for now
340:42 - and that is going to be the left
340:47 - side which will be re. left plus re do
340:53 - wi divided by four so just to
340:56 - contextualize these numbers once again
340:58 - we have the entire index we have the
341:00 - list and we have the top rectangle and
341:04 - at the moment we want to create the
341:06 - health bar
341:08 - for that we will need the
341:10 - width the height we will need a top
341:14 - position and we will need a left
341:16 - position the things that we have covered
341:19 - inside of this dictionary and later on
341:21 - those we want to reuse for the energy
341:23 - bar rectangle but step by step first of
341:25 - all I want to create a health bar
341:29 - rectangle which is going to be pame do F
341:34 - rectangle where we have to specify a
341:36 - position
341:37 - and a size position we're going to
341:40 - change in just a second for now this
341:43 - could be zero and zero for the size we
341:46 - also want to have a tuple with X and Y
341:49 - or rather width and height but same
341:52 - thing and there we want to get bar data
341:55 - with the width and I can copy all of
341:59 - this because for the height we want to
342:01 - have bar data and height to cover the
342:04 - position I want to use move two simply
342:08 - because I want to place the mid pop
342:11 - which is going to get the xy2 position
342:14 - of bar
342:16 - data we want to have the left side for x
342:22 - and we want to have the bar data top for
342:27 - y and just to make sure this is working
342:29 - let's run py game. draw. rectangle self.
342:33 - display surface we can go with a red
342:36 - color and then the health bar rectangle
342:40 - may not pi and there we go we have a
342:43 - health bar although it is quite far down
342:48 - that's not ideal in other words we want
342:51 - to change the top argument and in my
342:53 - case the number that I went with is the
342:56 - top w. bottom plus W do wift multiplied
343:00 - by
343:03 - 0.03 if I now run main. Pi that feels
343:06 - much cleaner
343:07 - and I suppose the important thing for
343:09 - this bar is that we have the same
343:10 - distance to the top and to the left
343:13 - because of that we are multiplying the
343:15 - top offset with the Wii cool with that
343:18 - we have the position and the size of the
343:20 - health bar rectangle which means next up
343:23 - we can call draw bar again and for that
343:27 - we're going to need all of these
343:29 - parameters we want to draw on self.
343:33 - display surface the rectangle will be
343:36 - the health bar rect rectangle after that
343:38 - we will need a value and a max value I
343:42 - suppose for now we can go with 25 and a
343:44 - max value could be a 100 for the main
343:48 - color I want to go to colors and in
343:50 - there we have a red color for the BG
343:53 - color I want to get colors and in there
343:57 - get
343:59 - black for the radius I want to have a
344:02 - corner radius of
344:03 - two let's try that
344:07 - and there we go this is definitely
344:10 - coming together the major thing missing
344:13 - is that we have to get the health and
344:15 - the maximum health of the monster at the
344:17 - moment this doesn't really exist we only
344:20 - have the max Health via the base stats
344:22 - but that doesn't really help us there
344:24 - isn't a good way right now to track the
344:26 - health of the monster to create that for
344:29 - now I want to create another attribute
344:31 - self. Health which is going to be self.
344:34 - Bas stats and then we want to get
344:39 - maxcore health and that we want to
344:42 - multiply with self. level that means by
344:46 - default the health of the monster is the
344:48 - same as the maximum health although for
344:51 - this part we do have to be careful
344:53 - inside of base stats Max Health could be
344:56 - something like let's say
344:59 - 25 and this value really importantly we
345:02 - are not multiplying with self. level at
345:04 - the moment that is because inside of
345:07 - stats we only want to have the base
345:08 - stats of the monster but for health we
345:11 - have to multiply it with the level right
345:13 - away because this value later on can
345:15 - change and we have to make sure we
345:17 - always have the correct amount of
345:19 - HP but that is a problem at the moment
345:22 - because if we simply went back to the
345:24 - monster index and for the value we could
345:28 - get monster. health and for the max
345:30 - value we could get
345:32 - monster.
345:34 - basore stats with maxcore health The
345:39 - Game Wouldn't crash but we would always
345:41 - have the full amount of Health simply
345:43 - because the actual health is way larger
345:45 - number than the max Health to fix this
345:48 - issue I want to create a method inside
345:52 - of the monster that I called get
345:55 - stat for this one we will need self and
345:57 - the stat that we want to
346:00 - get the only thing that this method is
346:02 - going to do it will return self. based
346:05 - stats with the stat we are currently
346:08 - looking at and then it's going to
346:09 - multiply all of this with self do level
346:13 - that way we get the correct amount which
346:16 - means instead of doing all of
346:19 - this I want to run the
346:23 - function monster. getet stat with Max
346:29 - Health now this is still going to look
346:31 - the same inside of the game since at the
346:34 - moment our health and our Max Health are
346:36 - the same value you this isn't going to
346:38 - do very much since inside of the monster
346:41 - the maximum health and the health are
346:42 - the same this is well not going to be
346:45 - particularly useful but what we could be
346:48 - doing is do self. Health minus equal a
346:52 - random amount let's say Rand int between
346:55 - zero and
346:58 - 200 if I now run main. Pi we are getting
347:03 - some health bars so that's looking
347:05 - pretty good now some monsters don't have
347:08 - enough health for this to really work
347:10 - those monsters would have been defeated
347:12 - but once again that's an issue for later
347:13 - for now I just want to have some random
347:16 - numbers although on top of that I also
347:18 - want to draw the HP text on top of this
347:22 - bar for that we will need self. fonts
347:26 - and the regular font and then render the
347:30 - output I want to render the F string
347:34 - that says HP
347:37 - with first of all the integer value of
347:42 - monster. health and then a forward slash
347:46 - after that we want to insert the integer
347:49 - of the maximum health which we have
347:51 - gotten up here I can just copy it and
347:54 - there we go with that we have the text
347:56 - we need to specify anti alas which
347:59 - should be faults and then a text
348:01 - color which in this case is going to be
348:04 - colors and white
348:07 - we are also going to need an HP
348:10 - rectangle which is going to be the
348:13 - HP text. getf
348:17 - rectangle in which we want to place the
348:19 - mid left
348:21 - point which is going to be the health
348:23 - bar rectangle do mid left although I do
348:26 - want to add an offset of vector and 10
348:28 - pixels and 0er
348:30 - pixels finally we can run self. display
348:34 - surface dolit with the HP text and HP
348:39 - rectangle let's try all of that and
348:43 - there we go we are now getting the
348:45 - proper values and you can see some
348:47 - monsters have negative
348:49 - values that we can fix later on for now
348:52 - it's not too much of an issue righty
348:55 - with that we have the health bar
348:57 - rectangle after that we want to have the
348:59 - energy
349:00 - rectangle which is going to be fairly
349:02 - similar compared to what we have done
349:04 - here so we can reuse a couple of of
349:06 - numbers width height and top can stay
349:09 - the same although for the X position we
349:11 - will need a right side which is going to
349:15 - be re. left plus re do whift multipied
349:21 - with 3 over four that way we are getting
349:24 - 75% of the WID next up I guess we could
349:27 - copy all of this although I do want to
349:31 - change this to the energy bar rectangle
349:34 - we need py game. fct and the size is
349:38 - still good although for the midtop I
349:41 - would have bar data and the right side
349:45 - top can stay the same though next up
349:48 - when we are drawing the bar I want to
349:50 - use the energy bar
349:52 - rectangle and then Monster Health and
349:54 - monster Max Health we can leave for now
349:56 - although for the color I want to use a
349:59 - blue
350:01 - color and also for now we can get rid of
350:04 - the text and let's see if this is
350:06 - working in the first place and that is
350:10 - looking like a pretty solid start now at
350:13 - the moment we are copying the health
350:15 - amount but at the very least we have a
350:17 - bar the issue is we using the same
350:20 - attributes of the monster for both bars
350:22 - which isn't ideal Instead This should be
350:25 - monster. energy and monster gets that
350:28 - Max Energy max energy does exist but
350:32 - energy does not which means inside of
350:35 - the monster we have to create self.
350:40 - energy which is going to work in a very
350:42 - similar way compared to the health I
350:44 - simply want to get the max stat
350:47 - and energy and multiply it with the
350:50 - level also while we are here I want to
350:53 - change the value of self. energy and
350:57 - subtract the value from 0 to let's say
350:59 - 100 after that I can run out of this and
351:03 - now we are getting different bar sizes
351:07 - that is looking pretty solid so after
351:11 - that we can work on the I call this one
351:15 - the energy points text and energy Point
351:18 - rectangle for the text itself we still
351:21 - want to render the regular font although
351:23 - now this should be EP and Monster Energy
351:28 - along with monster get that Max
351:32 - Energy antialiasing and color stay the
351:34 - same next up for the rectangle
351:37 - I want to get energy points text. get
351:41 - rectangle and the mid left should be the
351:44 - energy bar rectangle. mid left that
351:47 - looks good finally I want to display
351:50 - surface split the EP text and EP
351:54 - rectangle after that we are getting
351:57 - proper numbers for all of this so that
352:00 - is looking very good next up I want to
352:04 - work on the monster info
352:07 - I.E in there we have the monster stats
352:10 - and we have the monster abilities for
352:13 - both of those first of all we're going
352:16 - to need a bit of
352:18 - information number one is going to be
352:20 - the left side for either of them which
352:22 - can be a dictionary where we have the
352:24 - left side and we have a right side the
352:28 - left side is simply going to be the
352:29 - health bar rectangle do left and the
352:32 - right side is going to be the energy bar
352:35 - rectangle dot left if this is the energy
352:40 - bar rectangle I basically want to draw a
352:43 - vertical line and then have all of the
352:46 - abilities somewhere here with all of the
352:50 - elements being aligned to the left side
352:53 - on top of that I also want to know what
352:55 - our available height is which I have
352:57 - called info height or in other words I
353:00 - want to know rect do bottom minus health
353:04 - bar rect do
353:07 - bottom that would be the distance
353:08 - between the health bar and the bottom of
353:11 - the entire index or in other words our
353:14 - entire available space next up we can
353:18 - display all of the stats and the way
353:20 - this is going to work we already have a
353:23 - container that starts at the bottom of
353:26 - the health bar and ends at the bottom of
353:30 - the main rectangle the stuff we have to
353:32 - find here we also have a left side
353:35 - that's simply the left side of the
353:36 - health bar bar and then we can Define
353:37 - some kind of WID to get the entire
353:41 - available WID inside of this space we
353:43 - want to display some text this could be
353:46 - attack or defense or speed or stuff like
353:48 - that and then below this text we want to
353:51 - have a bar that shows how good this
353:53 - value actually is for that first of all
353:56 - I want to create a stats rectangle just
353:59 - as before pame do F
354:03 - rectangle with left top width and height
354:07 - left being sides and
354:11 - left the top being the health bar
354:16 - rectangle do
354:18 - bottom Whi would be health bar rectangle
354:22 - do WID and the height would be the info
354:27 - height that way we are getting a
354:29 - rectangle although we want to inflate
354:33 - this thing just a bit or rather we want
354:35 - to deflate it
354:37 - which basically just means that we want
354:39 - to change the size while keeping the
354:41 - center point on the horizontal axis this
354:43 - could be zero on the vertical one it
354:45 - should
354:47 - be60 and just to make sure this is
354:49 - working let's run py game.
354:52 - draw do rectangle with self. display
354:56 - surface a red color and the stats
355:00 - rectangle inside of main. Pi that looks
355:04 - pretty solid so essentially at the the
355:06 - moment we have created a rectangle that
355:09 - covers this entire area and then via the
355:13 - inflate method we have taken out this
355:16 - bit and this bit just to have a bit of
355:19 - padding that we don't want to draw
355:22 - though but I do want to get a stats text
355:26 - surface which is going to be self. fonts
355:30 - and
355:31 - regular that we want to
355:34 - render the word I want to rer is called
355:37 - stats then faults and
355:41 - colors with white this part is just
355:45 - going to be a title that we want to
355:47 - place on top of all of the stats to give
355:48 - a bit more context to place it we want
355:51 - to create a stats
355:54 - text
355:56 - rectangle via stats text surface. getet
356:00 - F rectangle where the bottom left is
356:04 - going to be stats right
356:06 - do top left finally self. display
356:10 - surface. blit stats text surface and
356:14 - stats text rectangle all that this is
356:17 - going to give us is inside of the game
356:19 - we now have stats so that looks a bit
356:22 - better after we have that we can come to
356:25 - actually displaying all of the stats and
356:27 - for that first of all we need a bit of
356:29 - data most importantly we want to get the
356:32 - monster stats which ideally I want to
356:35 - get from a method called monster. getet
356:39 - stats or in other words earlier we
356:42 - created a method to get one of the stat
356:45 - of the monster but now we want to get
356:47 - all of them which means inside of the
356:49 - monster I want to create theine get
356:53 - stats no need for custom parameters for
356:56 - this one and basically all that we want
356:58 - to return is a dictionary with the
357:02 - values that we want to display and for
357:04 - that I want to have quite a bit of
357:06 - control because the text is going to be
357:08 - visible meaning I want to display the
357:10 - health and then self. get stat with
357:15 - maxcore health I hope the system here
357:18 - makes sense when we are organizing the
357:20 - monster we have health and Max health
357:23 - and those two are separate attributes
357:25 - however when we are displaying all of
357:27 - the stats of the monster we only want to
357:29 - display the max health because of that
357:32 - we can rename it to health and the same
357:34 - we can also do to the energy
357:37 - meaning instead of Max do energy I
357:41 - simply want to get the energy the other
357:43 - attributes I want to display there are
357:45 - four
357:47 - more I want to have the attack the
357:52 - defense the speed and the recovery in
357:57 - case you're wondering recovery is how
357:59 - fast the monster regenerates energy
358:01 - points to get those attributes we want
358:03 - to have get that attack
358:07 - defense speed and
358:11 - Recovery that way we have control over
358:13 - what attributes we want to display which
358:16 - by using inside of the index so now we
358:18 - know what we want to display on top of
358:20 - that we also want to know the stat
358:22 - height which would be the available
358:24 - space for every element that we can get
358:26 - with stats w. height IE the entire
358:31 - available space divided by the length of
358:35 - the St St that we have monster stats
358:39 - once we have that we can create a for
358:41 - Loop to draw all of the elements and for
358:44 - that we want to have the data and the
358:47 - index which means we want to have index
358:49 - and data in
358:52 - enumerate monster stats do items just to
358:57 - make sure that this is working let's
358:59 - print index and data running main. pi
359:02 - and opening the index you can see in the
359:04 - bottom with we get the information for
359:07 - all of the monsters it's a bit hard to
359:09 - see but if I extend this you get a
359:13 - pretty good idea that we have the right
359:16 - bits of information available we just
359:19 - have to display them oh and also this we
359:21 - can make a bit more elegant instead of
359:23 - data I want to have a tupal with the
359:26 - stat and the
359:28 - value to get started inside of this for
359:31 - loop I want to create a rectangle for
359:33 - the positioning of every individual stat
359:36 - let's call it single stat
359:40 - rectangle for that we're going to need
359:42 - py game. F rectangle with left top width
359:46 - and height most of these numbers are
359:49 - going to be fairly simple the left side
359:51 - for example is the stats rectangle do
359:54 - left the top gets a bit more complex
359:57 - that we can cover in a second the width
359:59 - is simply going to be this stats W do
360:03 - WID and the height is going to be the
360:06 - stat height now for the top we want to
360:10 - get the stats rectangle. toop that way
360:14 - we would always be on top of this
360:16 - container although from there we want to
360:19 - go down depending on the index that we
360:21 - have IE plus index
360:24 - times stat
360:28 - height this will be fairly comparable to
360:30 - the list we created earlier after we
360:33 - have that there are three elements that
360:35 - we want to display I want to have an
360:37 - icon for every single stat I want to
360:40 - have some text and then I want to have
360:42 - the actual bar the easiest part is going
360:46 - to be the text let's start there for the
360:48 - name I'm going to go with text surface
360:50 - so I don't have to type too much and we
360:52 - want to get self. fonts the regular font
360:57 - that we want to render and the
361:00 - information that we want to render is
361:02 - simply going to be the stat the one that
361:04 - we are getting from the four
361:06 - loop after that we need faults and for
361:09 - the
361:10 - colors we want to get white next up I
361:13 - want to have a text
361:15 - rectangle which we get from text surface
361:19 - get F rectangle where we are placing the
361:22 - mid left to singles that rectangle do
361:27 - mid left just to make sure that all of
361:29 - this is working let's display that self.
361:32 - display surface. blit text surface and
361:37 - text
361:39 - rectangle so inside of main. Pi we are
361:42 - now getting all of the stats this isn't
361:45 - perfect yet but at the very least we can
361:48 - see something we basically have to
361:50 - update the positioning of the text to
361:52 - make all of this look better but for
361:54 - that to work properly we need the icon
361:56 - first of all or in other words in the
361:59 - project folder we have graphics and then
362:01 - UI and there for example we have an
362:04 - attack icon a defense icon and an energy
362:06 - icon and those we want to display next
362:09 - to the stat which means we have to do
362:12 - another import inside of the monster
362:17 - frames I have a key called UI which is
362:21 - just going to import all of the stuff
362:22 - you have just seen which is just going
362:25 - to import all of the UI icons which we
362:28 - can do with import folder dictionary for
362:31 - the path we want to go up a folder then
362:34 - we want to go to to graphics and in
362:37 - there we have the UI folder after that
362:40 - inside of monster index I want to have
362:44 - another attribute self.
362:47 - _
362:50 - frames monster frames and UI that way we
362:54 - have a bit easier access to it so now
362:58 - when we are
363:00 - drawing all of the stats inside of icons
363:03 - we can draw the appropriate icon for
363:06 - that first of all I want to get the icon
363:09 - surface which we get from self. uif
363:12 - frames and then this stat and just to
363:15 - explain how this is going to work inside
363:18 - of the graphics UI
363:20 - folder the icon we for example want to
363:23 - use is called attack which mirrors the
363:26 - attack stat name that way all of this is
363:28 - going to work fairly seamlessly after
363:30 - that we want to create an icon rectangle
363:35 - via IC can surface. getet f rectangle I
363:39 - want to place the mid left and the
363:42 - target position is going to be the
363:44 - single stat rectangle do midle plus an
363:48 - offset let's say Vector with five and
363:52 - zero or in other words we're moving five
363:54 - pixels to the right to display that we
363:56 - need the usual self. display surface.
363:58 - blit with icon surface and icon
364:01 - rectangle let's try that and we are are
364:05 - getting all of the icons although they
364:08 - are on top of the text at the moment for
364:11 - that when we are placing the text I want
364:13 - to update the rectangle
364:16 - positioning I want to place the top left
364:19 - to Icon w dot top left plus a vector of
364:27 - 30 and -10 let's try this again and that
364:33 - is looking much cleaner cool with that
364:35 - that we can work on the bar for which we
364:38 - first of all going to need a bar
364:41 - rectangle pame do F rectangle one more
364:44 - time with a position and a size the
364:48 - position is going to be for X the text
364:52 - rectangle do left and for y it's going
364:56 - to be text rectangle do
365:00 - bottom plus 2 pixels just for a bit of
365:03 - padding then for the size we want to
365:05 - have a width and a height the height can
365:08 - simply be four pixels and the width is
365:11 - going to be single stat w dot WID
365:16 - multiplied with
365:18 - 0.9 just for a bit of extra padding to
365:20 - the right with that finally we can draw
365:23 - the
365:24 - bar and as always we have to get all of
365:28 - these
365:29 - parameters surface is going to be self.
365:32 - display surface rectangle is going to be
365:35 - the bar
365:37 - rectangle value is going to be the value
365:40 - that we get from the for Loop that we
365:43 - don't have to change then we are also
365:45 - going to need a max value that we are
365:48 - going to ignore for now let's first
365:50 - cover the color this one is easy we
365:52 - simply want to get colors and white for
365:56 - the background color we want to have
365:59 - colors and black and the radius we can
366:02 - simply ignore after that we have to to
366:05 - figure out the max value and that part
366:08 - is going to be a bit more complex simply
366:11 - because from game data and let's UNL at
366:15 - the monsters here we have all of the
366:18 - monsters and for example for Max Health
366:21 - we want to get the highest possible
366:23 - value out of all of the monsters the
366:25 - same thing we want to do for Max Energy
366:27 - attack defense recovery and
366:30 - speed which means inside of the init
366:33 - method of monster index I I want to
366:36 - create another section for Max values
366:40 - which we are going to store in a
366:41 - dictionary self. Max stats by default
366:45 - this one can be empty and later on what
366:48 - I want to happen there is for example
366:51 - the health and then we are getting some
366:53 - amount here let's say
366:55 - 50 by default this one should be empty
366:58 - because these values we want to generate
367:00 - dynamically to get that we first of all
367:03 - need to have all of the monsters which
367:05 - which means for data in
367:08 - monstore
367:10 - dat. values and I don't believe we have
367:13 - monster data available we do not from
367:16 - game data import monster data with these
367:21 - values we are getting all of this or
367:25 - rather all of this and this and this and
367:29 - so on although we only care about the
367:32 - stats which means we want to a for loop
367:36 - with four stat and value in
367:42 - data
367:44 - stats and on this we want to get all of
367:46 - the items and just to make sure that you
367:48 - see what we are getting let's print stat
367:51 - and value if i r main. Pi we are getting
367:55 - things like Max health max energy attack
367:58 - defense recovery and speed or in other
368:00 - words in game data we are getting all of
368:03 - this now since we don't care about the
368:05 - element in fact we actively want to
368:07 - avoid that part we want to run if stat
368:12 - is different from element this we have
368:15 - to do because in just a bit we're going
368:18 - to compare the values which we cannot do
368:20 - for the element because that's not a
368:22 - number but essentially first of all I
368:25 - want to check if stat not in self. Max
368:30 - stats if that is the case we can simply
368:32 - create a new key self. Max stats with
368:37 - the
368:37 - stat is going to be the value that part
368:41 - is easy the next part is a bit more
368:43 - complex so at the moment we are looping
368:46 - through all of the stats of every single
368:48 - Monster and then we are encountering an
368:51 - element that already exists inside of
368:53 - Max stats if that is the case we want to
368:56 - compare the current stat value with the
368:59 - value inside of Max stats and then pick
369:01 - the larger one which means self. Max
369:04 - stats with the stat is going to be value
369:08 - if value is greater than self. Max stats
369:14 - and the stat if that is not the case
369:17 - else we simply want to keep the same
369:19 - thing IE the value we have started with
369:23 - that should actually be all if I now
369:25 - print self. Max stats and run main. Pi
369:31 - we are getting a dictionary that should
369:34 - always have the largest attribute value
369:37 - let's check for example for Max Health
369:39 - this value should be 29 and that I
369:43 - believe is chillo but we have a Max
369:46 - health of 29 and every other value is
369:49 - smaller than that so that looks good
369:52 - let's do another one for attack the
369:54 - largest value is six so there should be
369:57 - no other value larger than that so we
369:59 - have pluma with attack being six and
370:01 - every other value is smaller than that
370:04 - so that seems to be working just fine
370:07 - however there is an issue and let me run
370:09 - m p again when we are using these Max
370:12 - stats which happens in the for Loop down
370:17 - here the stat for Max health and Max
370:20 - Energy is simply called health or energy
370:23 - which means inside of Max stats we have
370:25 - to get rid of Max health and Max Energy
370:28 - or to be a bit more specific we have to
370:30 - remove the max in there
370:36 - now the easiest way to rename a key
370:38 - inside of a dictionary is to get the
370:40 - dictionary and then the new
370:43 - key the value for this one is going to
370:46 - be self. Max stats and then you pop the
370:50 - previous key which in our case is going
370:53 - to be maxcore Health the same thing we
370:57 - want to do for energy so energy is going
371:00 - to be Max
371:02 - Energy after that I can print cell
371:05 - do Max stats run main. pi and there we
371:10 - go now we are getting all of the max
371:13 - values with health and energy having the
371:15 - right name the order changed but that
371:17 - doesn't matter now we don't need the
371:19 - print statement anymore and we can
371:21 - collapse the init method after
371:25 - that all the way down here we can get
371:29 - the max value for every single stat what
371:31 - we want is self. Max stats along with
371:36 - the current stat that we are looking at
371:38 - and really important this we have to
371:40 - multiply with monster. level and that
371:44 - should be all if I now run may not Pi we
371:47 - get a whole bunch of bars and that I
371:50 - think is looking pretty
371:54 - good no complaints although I think we
371:57 - could move the entire thing just a bit
371:58 - further down for that inside of monster
372:02 - index when we are creating this step
372:05 - that's rectangle after inflate we also
372:08 - want to move it zero pixels left and
372:11 - right but 15 pixels down if I now run
372:14 - may not Pi this thing is a bit more
372:16 - centered which looks a lot better with
372:19 - that we have covered the stats after
372:22 - that we will need the abilities or in
372:25 - other words inside of game data we want
372:27 - to display all of these
372:30 - abilities now for some monsters I was a
372:33 - bit lazy and they don't have very many
372:35 - like those but if you go a bit further
372:37 - down for example for this one we have
372:39 - four Tech moves then we have a few more
372:41 - for this one then we have all of those
372:44 - and this is what we want to display for
372:46 - all of that first of all I want to
372:48 - create an ability rectangle which is
372:52 - basically going to be the same size as
372:54 - the stats rectangle so we can copy that
372:57 - one although we do want to move it to a
373:00 - different
373:01 - position or in other words I want to
373:04 - move the left side
373:05 - to sides
373:08 - and right the sides that we have to
373:11 - finded earlier that happens up here on
373:15 - top of that what will also be similar to
373:17 - the stats rectangle is the title which
373:20 - we have done with these lines so I can
373:22 - copy
373:23 - them basically we want to create an
373:27 - ability text surface and text rectangle
373:31 - now for that I do have to rename a few
373:33 - more things
373:35 - like this one and this one although we
373:39 - do have to change a couple of other
373:40 - things but let's go through it step by
373:42 - step first of all self. want. regular.
373:44 - render can stay the same although the
373:46 - text we want to render is ability next
373:49 - up for the rectangle we want to get the
373:51 - text surface and then place the bottom
373:53 - left in the ability rectangle. top
373:58 - left and I think that's going to be it
374:01 - if I now run main. Pi we getting ability
374:04 - to the right off it that looks pretty
374:06 - good which means afterwards we can
374:08 - create another for loop with index and
374:12 - ability in
374:14 - enumerate and then I basically want to
374:17 - get the monster and get uncore ability
374:22 - piece a method that does not exist at
374:24 - the moment to create that one we have to
374:27 - work inside of the monster where we want
374:30 - to create get
374:33 - ability inside of of this method we want
374:36 - to return all of the abilities that are
374:38 - available to The Monster at the moment
374:41 - if you look at game data we can look at
374:43 - let's say synal and in there we have an
374:46 - abilities dictionary the key defines
374:49 - when this ability is available or in
374:51 - other words on level 26 this monster
374:54 - gets the explosion ability so what we
374:56 - want to return is going to be a list
374:58 - with all of the abilities now first of
375:01 - all for all of that below the stats I
375:04 - want to store all of the abilities self.
375:08 - abilties is going to be monster data
375:12 - with the name and then we want to get
375:15 - the
375:16 - abilities I.E we are getting this
375:19 - dictionary and from that dictionary we
375:21 - want to get all of the available moves
375:23 - that part is actually fairly simple we
375:25 - want to get the ability for level and
375:30 - ability in self.
375:33 - abilities.
375:36 - items remember abilities is a dictionary
375:39 - where we have a level and the ability or
375:42 - all of this stuff and we only want to
375:45 - store an ability if self. level is
375:49 - greater or equal to the level required
375:53 - that way let me print the
375:58 - ability and let's have a look at the
375:59 - monsters so the first monster that we
376:02 - have is tramad Dillo and this one is
376:04 - level 30 at the moment inside of game
376:07 - data if we find shamad Dillo we should
376:10 - have all of these abilities but we
376:12 - should not have
376:14 - annihilate let's try if I run may not Pi
376:17 - open the
376:18 - index we can see all of the basic
376:21 - abilities I think they start here we can
376:24 - go up to explosion but we do not get
376:26 - annihilate I think that's looking good
376:29 - to display all of that I want to create
376:31 - a text
376:33 - surface which we do with self do fonts
376:36 - and regular I want to render the
376:42 - ability fs and the color is going to be
376:45 - black oh and there's one thing I did
376:47 - forgot to mention if this is the
376:49 - rectangle for all of the abilities the
376:51 - one we have to finded up here I want to
376:54 - have a two column layout I.E this is one
376:56 - ability then we have another ability
376:59 - then we have another ability and another
377:01 - one
377:02 - here essentially I want to avoid that we
377:04 - always have a list that displays all of
377:06 - the elements in a single Dimension it
377:09 - simply starts to look boring at some
377:10 - point now the way each individual
377:12 - ability will be displayed is we have the
377:15 - text itself with a black color and
377:18 - around that we're going to draw a
377:20 - rectangle for that we're going to need
377:22 - an X and A Y position I suppose for X we
377:27 - can start with ability rectangle do left
377:32 - although that we do have to change in
377:33 - just a bit but the top I want to have a
377:36 - top offset of let's say 20 pixels then I
377:39 - want to add the ability rectangle do top
377:43 - and then add the index multiply it with
377:46 - text surface and get uncore height once
377:50 - we have that we can create a
377:53 - rectangle where we want to get the text
377:56 - surface and call get F rectangle where
377:59 - we are placing the top left at position
378:02 - X and Y finally we can call py game.
378:07 - draw. rectangle on self.
378:11 - display
378:13 - surface what a color I want to have
378:16 - colors and white along with the
378:20 - rectangle let's try all of that if I now
378:23 - run m.p we are getting well we are
378:26 - getting something I suppose what I
378:29 - should be doing is also display the text
378:31 - then all of this is going to make a lot
378:32 - more sense self. dis playay surface do
378:36 - blit the text surface along with the
378:40 - rectangle let's have a look again and
378:43 - there we go we are getting all of the
378:45 - attack moves except this one doesn't
378:47 - look ideal now an easy thing that we
378:49 - could be doing here is wck dot inflate
378:53 - let's say by 10 and 10 pixels then we
378:56 - can set a border width of zero and a
378:58 - corner radius let's try this one and
379:02 - there we go this is already feeling
379:04 - quite a bit nicer although we are
379:06 - wasting a huge amount of space on the
379:08 - right side to fix that I want to move
379:10 - spark to this position roughly here to
379:14 - get those numbers I have to update the x
379:17 - value the way we are getting that is
379:19 - index modulus and two and that value we
379:24 - want to multiply with ability rectangle
379:28 - dot whift divided by
379:31 - two what we're getting from that if we
379:34 - run all of the is we are staggering the
379:37 - entire thing and the main thing that
379:39 - might cause you confusion is this index
379:42 - modulus two and let me actually print
379:44 - what we are getting if I now run all of
379:46 - this and open the thing we are getting a
379:49 - whole bunch of zeros and
379:51 - ones basically we are checking if index
379:54 - is even or odd and then we are getting
379:56 - zero or one returned which we are then
379:58 - multiplying with half of the width of
380:00 - the container that way an item is either
380:03 - on the left side or in the middle which
380:05 - is a good start but we still have the
380:09 - vertical positioning that we also have
380:11 - to update without that we would get this
380:13 - weird offset at the top which I do not
380:16 - like for that I want to work inside of
380:19 - the Y
380:20 - position and then divide index by two
380:25 - and get the integer from the result if I
380:29 - now run main. Pi that is feeling quite a
380:32 - bit better although we do need need a
380:34 - bit more padding between the elements or
380:37 - in other words at the moment our height
380:39 - separation is simply the text surface
380:41 - height this we want to increase by let's
380:43 - say 20 pixels let's try this again and
380:47 - there we go this is feeling much cleaner
380:51 - and with that we basically have the
380:53 - entirety of the
380:55 - index although there's one thing that I
380:57 - don't like and that is when we are
381:01 - displaying the attack we are only
381:03 - showing the name of the attack
381:05 - which is a good start but I also want to
381:07 - display the element of the attack for
381:10 - that we have to look at game data and
381:12 - come to the third dictionary attack
381:15 - data this one gives us all of the
381:17 - available attacks and then a whole bunch
381:20 - of information for example what we can
381:22 - Target the amount of damage or healing
381:25 - the cost of this move then we have the
381:27 - element and we have an animation for now
381:30 - we only care about the element there we
381:33 - have fire plant normal
381:35 - and water so when we are displaying the
381:37 - ability the background color should have
381:40 - the proper element
381:42 - color for that first of all we need to
381:44 - know what element we are working with
381:47 - which we get from a tech
381:50 - data and currently we don't have that
381:53 - one available so we want to import
381:55 - monster data and attack data that way
381:58 - we're getting this dictionary next up
382:01 - then all the way at the bottom attch
382:03 - data we we have the ability along with
382:07 - the element which is going to be this
382:11 - entry in the dictionary let's try all of
382:14 - this and the game doesn't crash so I
382:17 - assume it's going to
382:19 - work after that we have to link this
382:22 - element to a color which we can do via
382:25 - settings because for every element we
382:27 - have an Associated color although with
382:30 - one exception because I forgot to add
382:32 - the normal color which is simply going
382:34 - to to be a pure white color after that
382:38 - when we are drawing the rectangle I do
382:41 - not want to get the white color instead
382:43 - I want to get the element and with that
382:47 - if I now run main. Pi we're getting a
382:49 - whole bunch more color which is feeling
382:52 - significantly better now that was a
382:55 - larger section but we have made a whole
382:58 - bunch of progress so next up we can
383:01 - start working on the battle system while
383:03 - editing this part of the video I
383:05 - realized I have forgotten two things or
383:08 - rather I forgot one thing and I made a
383:10 - mistake inside of the
383:12 - game the first thing that I got wrong is
383:15 - the length of the stat bars all of those
383:19 - because those are too long I basically
383:21 - want them to end with the health bar all
383:24 - of this stuff here should disappear it
383:27 - just doesn't look good besides that the
383:30 - thing that I forgot to add is if we
383:32 - don't have enough monsters let's let's
383:34 - say we only have the first
383:37 - three if we then run the game we can
383:40 - only see part of the index which is
383:42 - going to look really weird and let's
383:44 - start with the background for that
383:46 - inside of monster index we want to go to
383:48 - display list before we are drawing
383:51 - anything I want to have a BG rectangle
383:55 - as always py game. F
383:59 - rectangle with left top WID and height
384:03 - left and top we can put together as
384:05 - position because for this one we want to
384:07 - get self. main. toop left this BG
384:11 - rectangle is going to be the background
384:13 - for the entire list for the width and
384:16 - height we want to have a tall the width
384:18 - is going to be self dot list wi and the
384:22 - height is going to be self. main re.
384:25 - height this PG rectangle we then want to
384:28 - draw with py game. draw. rectangle self.
384:33 - display surface let's say for now a red
384:36 - color and then the BG rectangle inside
384:40 - of main. Pi if I now open the index we
384:43 - are getting an
384:44 - error this should be called pame Draw
384:47 - rectangle and now inside of main. Pi we
384:51 - now have the background although we have
384:54 - to fix two things number one is the
384:56 - background color and number two is the
384:58 - corner radius for the background color I
385:01 - simply want to get the gray color so
385:04 - that's part's fairly easy let's try and
385:08 - that's already looking a lot better
385:11 - border Corner radius we want to go with
385:14 - zero for the Border WID then a general
385:17 - border radius is going to be zero then
385:20 - we have the top left border this one
385:22 - should be 12 next up is the top right
385:24 - border that one is zero then we have the
385:27 - bottom left border this one should be 12
385:29 - and then we have zero
385:31 - again let's try all of that
385:34 - and there we go I think this is looking
385:37 - pretty good although while doing this I
385:40 - have realized another minor issue and
385:42 - that is we have this line all the way at
385:45 - the top which shouldn't be there it
385:47 - looks a bit weird that part happens
385:50 - because of those lines down here for
385:53 - this one we have to make sure that we do
385:55 - not draw something on index zero or
385:58 - rather that index zero doesn't exist
386:00 - which we can insert by simply adding a
386:02 - one up to what whatever we are getting
386:05 - from all of this let's try that part and
386:08 - now we don't have the weird line all the
386:10 - way at the top anymore the rest still
386:12 - works just
386:13 - fine so we can reenable all the
386:18 - monsters and it's still looking pretty
386:22 - good cool very happy with that and that
386:25 - is making a noticeable
386:27 - difference after that we have to work
386:30 - inside of display Main and more
386:33 - specifically we want to work inside of
386:35 - the four Loop for the stats for the bar
386:38 - rectangles we are getting a single stat
386:42 - rectangle and then 90% of the width
386:46 - which turns out is a bit too far if we
386:48 - change this to 75 so 75% then this is
386:54 - looking a bit better but still not ideal
386:57 - or and other words I want this bar to
387:00 - extend to the length of the health bar
387:02 - something like this
387:04 - I think the best way to think about it
387:06 - is if this is the entire stats rectangle
387:10 - we have an icon then we have some text
387:13 - and then we have the bar and at the
387:15 - moment the bar is a bit too wide so this
387:17 - part we have to remove which means
387:20 - essentially we want the length of the
387:22 - bar to be the width of the entire
387:25 - rectangle minus this part which we can
387:29 - get with the entire rect of the single
387:31 - stat rectangle WID but from that we want
387:34 - the
387:34 - subtract text rectangle. left I.E the
387:39 - left side of the text
387:41 - rectangle minus the single stat
387:45 - rectangle do left that would give us the
387:48 - distance from the left side of the main
387:49 - rectangle to the text so with
387:54 - that we have the properly sized bar and
387:58 - that is making the entire thing feel
388:00 - much better so I am quite happy with
388:02 - that cool with that we have actually
388:04 - finished the index so next up we can
388:07 - work on the battle system righty then
388:10 - the battle system now this thing is
388:12 - going to become fairly complex we have a
388:15 - ton of animations we have lots of timers
388:17 - we have to capture input there are just
388:19 - a bunch of things that we have to do so
388:22 - let's go through it step by step and
388:24 - start by setting up the entire thing
388:26 - first of all we are going to need some
388:28 - opponents which we can create right
388:31 - below the player monsters self Dot let's
388:34 - call it dummy
388:37 - monsters this is going to be a
388:39 - dictionary very similar compared to the
388:41 - player and let me literally copy a
388:43 - couple of entries I want all of those
388:46 - monsters although we do have to fix the
388:49 - indexes this should always be a list
388:52 - that starts from zero and then goes in a
388:53 - sequence also let me change the levels
388:56 - to something that is a bit more
388:59 - noticeable so with that we have a couple
389:01 - of opponents that we could fight
389:04 - which means next up we have to figure
389:06 - out the actual battle system and
389:09 - essentially what we are going to do if I
389:11 - minimize everything and then look at the
389:14 - Run Loop we already have a dialogue tree
389:18 - and an index for the overlays in there I
389:21 - want to add one more if self. battle
389:25 - exists then we want to run self. battle.
389:30 - update with Delta time also let me align
389:33 - all of this that's going to look a fair
389:35 - bit better there we go so basically for
389:38 - the battle system we are just creating a
389:41 - whole bunch of Sprites on top of the
389:43 - entire level while also making sure that
389:45 - the player cannot move that way our
389:47 - transitions are going to be a bit
389:49 - simpler but anyway first of all for all
389:51 - of this we want to create inside of
389:55 - overlays in another attribute self.
389:57 - battle which by default is going to be
390:00 - none meaning if we are running the game
390:02 - now nothing is going to change
390:05 - however what we can do is create a new
390:07 - python file which I want to save as
390:10 - battle do high and then we need the
390:13 - usual stuff from settings import
390:18 - everything on top of that we want to
390:21 - have class B till without any
390:24 - inheritance for the Thunder init method
390:28 - self the player
390:31 - monsters along with the op opponent
390:35 - monsters we are going to need all of the
390:38 - Monster uncore frames I.E all of the
390:40 - graphics and we want to have a BG
390:44 - surface also we want to have a whole
390:46 - bunch of fonts I.E fonts first of all in
390:50 - there then we want to get self.
390:55 - displore surface which we get with py
390:57 - game. display doget uncore surface we
391:02 - want to store self. BG surface as an
391:05 - attribute the same we want to do with
391:07 - self. monster frames because we're going
391:11 - to use them quite a bit also the fonts
391:14 - we need to store so self the fonts is
391:17 - fonts after that I want to have all of
391:20 - the monsters inside of a dictionary I.E
391:23 - monster undor data is going to be a
391:27 - dictionary where we have the
391:29 - player with the player monsters then we
391:33 - have the opponent with the opponent
391:37 - monsters this part is necessary because
391:39 - sometimes we want to update all of the
391:41 - monsters in the battle and having all of
391:44 - them in a single dictionary is going to
391:46 - make that a bit easier so with that we
391:49 - have the setup next up the most
391:51 - important thing in this class is going
391:53 - to be an update method with self and
391:56 - Delta time and for now just to make sure
391:59 - that this is working I want to get self.
392:02 - display surface and then
392:04 - L self. BG surface at position 0 and Z
392:11 - inside of the project folder in graphics
392:14 - we have backgrounds those are the battle
392:18 - backgrounds those we first of all need
392:20 - to import which once again happens
392:22 - inside of main.py in import
392:25 - assets I wasn't really sure where to put
392:29 - them so I have simply created a separate
392:31 - attribute self. BG underscore
392:35 - frames which we get with import folder
392:38 - dictionary aut paath we want to go upper
392:41 - folder then to Graphics in which we have
392:45 - the
392:46 - backgrounds let's run out of this and we
392:49 - are not getting an error so the Imports
392:51 - seem to work just fine so with that we
392:55 - can all the way at the top import from
392:59 - battle the battle class
393:03 - and then when we are initializing the
393:06 - entire game instead of setting battle To
393:09 - None I want to create an instance of the
393:12 - battle class for which we are going to
393:14 - need a whole bunch of arguments let me
393:17 - copy the parameters player monsters is
393:19 - going to be self. player Monsters the
393:23 - opponent monsters are the ones we have
393:25 - just created the dummy monsters for
393:28 - Monster frames we want to have self.
393:31 - monster frames for the BG Sur we want to
393:34 - pick one item from these PG frames I.E
393:38 - if you look at them we at the moment
393:41 - have a dictionary with the keys for
393:43 - Forest Ice and sand so the one that we
393:46 - could be using is self do BG
393:51 - frames with the
393:54 - forest finally the last thing we need is
393:57 - self. fonts for the fonts if I now Run
394:00 - the game we have the background for the
394:03 - battle so so that's looking pretty good
394:05 - now the problem is that well the player
394:08 - behind all of this can still walk around
394:11 - which we cannot really see but if this
394:14 - was the case in the game it might cause
394:15 - some issues or at the very least it
394:17 - would be super weird one thing we could
394:20 - do already about that inside of input we
394:24 - are already checking if we do have a
394:26 - dialog tree or rather if we don't have a
394:28 - dialog tree only then should the player
394:31 - be able to do all of this this system we
394:34 - can extend right away we also want to
394:36 - check and not self. battle that way if
394:41 - we are in a battle we cannot talk to
394:43 - anyone and we cannot open the index
394:46 - although the player can still walk
394:47 - around which isn't ideal and for now
394:50 - it's not really easily fixable simply
394:53 - keep it in mind later on once we have a
394:55 - monster encounter we want to block the
394:56 - player movement like we have done for
394:58 - the dialog system but for now I think
395:00 - this is all right anyway with that we
395:03 - have have a battle system or at the very
395:06 - least we have the background for the
395:07 - battle which means next up I want to run
395:12 - a setup
395:14 - method no need for custom parameters for
395:17 - this one and basically what we want to
395:20 - do for entity and monster in self.
395:26 - Monster data do items IE we are going
395:31 - through this dictionary then we're
395:33 - getting the entity do we have a player
395:34 - or an opponent and then we are getting
395:36 - all of the
395:38 - monsters or rather we get the monster
395:41 - data and that is a really important
395:43 - thing to understand for this battle
395:45 - system we have the monster data which is
395:48 - going to be all the stuff we are getting
395:50 - from the monster this stores the actual
395:52 - monster information but to display the
395:55 - monster we have to create a Sprite this
395:57 - one is actually going to be visible but
396:00 - step by step first of all I want to get
396:02 - the first three monsters from the player
396:05 - and from the opponent or in other words
396:07 - I want to pick these three monsters or
396:10 - these threee monsters that we can get
396:13 - with for index and monster in I want to
396:18 - create a new dictionary via dictionary
396:21 - comprehension where I have a key and a
396:24 - value for K and v in Monster do
396:31 - items and with that we would duplicate
396:34 - the dictionary that we already have for
396:36 - the player or the opponent I.E all of
396:39 - this but this we only want to do if the
396:42 - key is smaller or equal to
396:46 - two and from this new dictionary we want
396:49 - to get all of the items if I print the
396:53 - result we have index and monster and
396:56 - also I want to run self. setup if I run
397:01 - m.p we are get
397:03 - [Music]
397:05 - getting 01 and two for the player
397:07 - monsters and 01 and two for the opponent
397:10 - monsters a bit hard to see but you get
397:13 - the idea I suppose what we could be
397:15 - doing at this point which is generally
397:17 - good practice inside of the monster
397:19 - class I want to create another Dunder
397:22 - method Define Dunder
397:25 - repper this is going to Define what we
397:28 - are doing when this class is being
397:30 - printed no need for custom parameters
397:33 - and basically we have to return some
397:35 - kind of string if this one is monster
397:38 - and I run m not Pi again instead of
397:40 - seeing the object in memory we get the
397:43 - string Monster not a bad start but not
397:46 - exactly helpful so instead I want to
397:48 - have a monster with self. name along
397:53 - with let's say the level which is self
397:57 - do
397:58 - level if I now remain. Pi we are getting
398:03 - the index and then the monster along
398:05 - with the level and there you can see we
398:08 - have the first three player monsters
398:10 - along with the first three dummy
398:12 - monsters using that information we want
398:14 - to create a monster or rather we want to
398:17 - create a whole bunch of monsters which
398:20 - I'm going to do inside of a method
398:22 - called create
398:24 - monster which is going to need a bunch
398:27 - of parameters let's create the method
398:30 - right away create monster after self we
398:34 - will need the monster data then we want
398:36 - to have the index on top of that we want
398:39 - to have a position index and finally we
398:43 - need the entity I.E player or opponent
398:46 - and I should explain index is to
398:48 - identify the monster so for
398:53 - example we could have two monsters with
398:56 - the same name and the same level it is
398:59 - totally possible to have something like
399:00 - charma d twice with the same level which
399:04 - would be inconvenient for us because
399:07 - they would be really hard to separate
399:09 - hence we are going to use the index of
399:11 - the monster to make sure that we always
399:13 - have a unique monster ID that is the
399:15 - purpose of this index besides that we
399:19 - have a position index to understand this
399:21 - one you want to look at settings because
399:24 - in there we have the battle
399:27 - positions if this is the window for the
399:31 - left side we have a position roughly
399:33 - here here and here and then for the
399:37 - right side we have another set of
399:39 - positions for here here and here or
399:41 - something like that those positions have
399:44 - indexes I.E top would be zero Center
399:47 - would be one and bottom would be two 0o
399:51 - 1 and two keeping track of these numbers
399:54 - is going to be really important because
399:56 - that way we can ensure that we always
399:58 - have the monster in the right place
400:00 - although for now I simply want to add
400:02 - pass in there because before we can work
400:04 - on this method we have to add all of the
400:07 - arguments monster is simply going to be
400:09 - the monster the index is going to be the
400:13 - index and the position index will also
400:15 - be the index and finally for the entity
400:19 - we want to get the entity all of the
400:21 - stuff we are getting from the four Loops
400:22 - basically also I am using index here
400:25 - twice because the first index is to keep
400:27 - track of the monster the second index is
400:30 - stand for the positioning and for this
400:32 - number I'm expecting number that is
400:33 - either Z one or two which I am getting
400:37 - from these indexes as well I.E the first
400:40 - Monster will always be on the top
400:42 - position or index zero the second
400:44 - monster will be in the middle index one
400:47 - and the third monster will be on index
400:48 - two or the bottom also let me get back
400:50 - the original monster that makes a lot
400:52 - more sense cool with that we can create
400:54 - a monster first of all we want to have
400:58 - the frames for this monster which we get
401:00 - from self. monster frames we want to get
401:04 - the actual monsters from this thing and
401:07 - then we want to pick one of the items
401:09 - which we are getting from monster. name
401:13 - that information we then want to use to
401:16 - create a monster
401:18 - Sprite Which is going to need a whole
401:21 - bunch of arguments we want to have a
401:23 - position we want the frames we want a
401:25 - couple of groups then we want to have
401:28 - the monster for data we want to have the
401:31 - index along with the position index and
401:34 - we need to know What entity it belongs
401:37 - to I.E is it a player or an opponent
401:40 - monster this monster Sprite does not
401:43 - exist at the moment for that we have to
401:45 - look at Sprites which I do not have open
401:47 - right now and also we don't need the
401:49 - monster index at the moment instead I
401:51 - want to have the
401:53 - Sprites we don't need any of the stuff
401:56 - we have already
401:57 - created I want to create the battle
402:01 - Sprites all of those are going to be the
402:03 - Overworld Sprites for the battle Sprites
402:07 - I want to create a class called Monster
402:11 - Sprite the parent is going to be pygame
402:13 - dos sprite. Sprite and then we're going
402:16 - to need a thunder init
402:19 - method for which we're going to need a
402:21 - parameter for all of these arguments on
402:25 - top of that we're going to need self
402:28 - after that I want to call Super with
402:30 - thunder in knit with all of groups along
402:34 - with self. index being the index self.
402:40 - position index is going to be the
402:42 - position index self. entity is going to
402:46 - be the entity and self. monster is going
402:51 - to be the monster that covers the basic
402:54 - data after that we need this bright
402:58 - setup you want to be a bit better with
403:00 - comments actually we can put this super
403:03 - in it in there and this part is going to
403:05 - be data for the Sprite itself we are
403:09 - going to need self. image and self.
403:12 - rectangle at the moment we don't really
403:14 - have a single image we only have a whole
403:17 - bunch of frames which means inside of
403:20 - data we need a few more attributes self.
403:23 - frame index self. frames and I also want
403:27 - to have self.
403:29 - state which is going to be zero Rams and
403:34 - the string idle that information we can
403:37 - then use for the image we are going to
403:40 - get self dot rames with self dot State
403:47 - and then we are going to use indexing
403:49 - one more time with self. frame
403:52 - index that should give us a single
403:55 - surface for the rectangle we want to
403:57 - have self. image. getet F
404:01 - rectangle where we are setting a center
404:03 - to a position that should be a pretty
404:06 - good setup next up then inside of battle
404:10 - we first of all have to from Sprites
404:13 - import the monster Sprite also since we
404:17 - are working with Sprites we have to
404:19 - create a bunch of groups before we are
404:21 - calling the setup method once again I
404:24 - want to have a couple of comments this
404:26 - is groups and this part is general what
404:30 - groups I want to have self do
404:34 - battlecore Sprites which for now can be
404:38 - pame dos sprite. group this I want to
404:41 - duplicate two times because I want to
404:44 - have a Sprite group for the player
404:46 - Sprites and another one for the opponent
404:52 - Sprites and I want to align all of this
404:55 - up so it looks
404:56 - nicer and with that we can finally
404:59 - create a monster Sprite now for that
405:02 - we're going to need a whole bunch of
405:03 - arguments and most of them we already
405:05 - have frames we are getting from what we
405:08 - have just done before groups we can set
405:11 - in just a second and the remaining
405:13 - arguments are coming from the parameters
405:16 - so that's quite
405:18 - simple all we really have to figure out
405:20 - is the position and the
405:23 - groups which means I want to have two
405:27 - more variables position and groups and
405:31 - those are going to change depending on
405:32 - the side which means I want an if
405:35 - statement if entity is equal to the
405:39 - player then I want to create one set of
405:42 - variables and if that is not the case
405:45 - else then I want to do the same thing
405:49 - although for now let's comment it out so
405:51 - we're not getting an error for the
405:53 - position I want to create a list with
405:57 - all the available positions And then use
406:00 - the monster position index to pick one
406:03 - of them in other words inside of
406:05 - settings I want to get this position
406:09 - this position and this position put it
406:13 - in a list and then select one of those
406:16 - via the index for that we will need the
406:20 - battlecore positions that we're getting
406:22 - from settings so this entire dictionary
406:25 - we currently want to look on the left
406:27 - side of this thing because the monster
406:29 - should always be on the left side and
406:31 - from that we want to get all of the
406:34 - values that way we only get the actual
406:38 - position while ignoring the key then for
406:40 - the groups I want to have self. battle
406:44 - Sprites and self. player
406:47 - Sprites and with that we should have a
406:50 - setup which means inside of the update
406:52 - method I need self. battles Sprites do
406:56 - raw on self. display surface if I now
407:00 - run m.p which we are getting an Unbound
407:04 - local error inside of the setup method
407:08 - that happens here and the issue is we
407:12 - are only creating a position if the
407:15 - entity is on the player side if we are
407:18 - on the opponent side we do not have a
407:20 - position so this position doesn't exist
407:22 - when we are trying to create a monster
407:25 - Sprite to avoid that issue for now I
407:27 - want to indent the monster Sprite so we
407:29 - are only creating a Sprite if we are on
407:32 - the player side side for which we always
407:34 - have a position and groups or in other
407:36 - words all of these arguments are
407:38 - available let's try of this again and
407:41 - there we go we have a couple of monsters
407:44 - now this isn't ideal they're not
407:46 - animated they're facing the wrong
407:48 - direction and we do not have the
407:50 - opponents so loads of things to work on
407:53 - that part is going to be an exercise I
407:55 - want you guys to do three things number
407:57 - one flip the player monsters on the
408:00 - horizontal axis so they're facing to the
408:02 - right
408:03 - after that add the opponent monsters and
408:06 - finally animate all of the
408:08 - monsters should be doable but you do
408:10 - have to write a couple of lines of code
408:12 - pause the video now and see how what you
408:18 - get I think the easiest thing to get
408:21 - started with are the opponent monsters
408:24 - meaning I want to uncomment the El
408:26 - statement and then remove one
408:28 - indentation from the monster Sprite next
408:31 - up we have to get the position which is
408:34 - going to work fairly similar compared to
408:36 - what we have done for the player the
408:38 - only difference is that now we want to
408:40 - get the right side for the groups we
408:43 - want to have self. battle Sprites and
408:45 - self. opponent Sprites with that inside
408:49 - of M Pi we are getting a whole bunch
408:52 - more monsters that's already feeling
408:54 - better although we have to flip all of
408:57 - the frames for the player and the thing
409:00 - you really have to understand when you
409:01 - are looking at all of of the monster
409:03 - Sprites all of them are facing to the
409:06 - left which means if one of them is on
409:09 - the left side of the screen we have to
409:11 - flip them to always face to the right or
409:13 - in other words when we have the player
409:16 - entities we want to create frames that
409:19 - are flipped which has to be a new
409:22 - dictionary where we have a state along
409:26 - with a couple of frames and at the
409:29 - moment we can go for state and frame
409:33 - in frames. items that would simply
409:37 - duplicate this list so so far not
409:39 - particularly useful but with that we
409:42 - have access to all of the frames which
409:45 - means in there we can run a list
409:48 - comprehension in which we want to go
409:50 - through all of the frames I.E frame for
409:54 - frame in frames so now we have access to
409:58 - every individual frame and this we want
410:00 - to flip on the horizontal axis which we
410:02 - can do with py game.
410:05 - transform. flip we want to have a frame
410:09 - we want to flip it on the horizontal
410:11 - axis but not on the vertical
410:13 - one if I now run main. Pi we have all of
410:17 - the Monster frames facing in the right
410:19 - direction so that's looking really good
410:21 - finally then inside of monster Sprite we
410:24 - want to animate all of this for that I
410:27 - want to create an animate method with
410:29 - self and Delta time we want to get self.
410:33 - frame index plus equal animation speed
410:37 - multipli it with Delta time and then
410:41 - self. image is going to be self. frames
410:46 - along with self. State and then we can
410:50 - pick the integer of self. frame index
410:54 - with modulus of the length of self.
410:57 - frames with the current self. state this
411:02 - animate method we have to call inside of
411:05 - an update method which needs self and
411:07 - data time there self.
411:11 - animate also don't forget Delta time in
411:15 - there next up inside of battle. Pi
411:18 - before we are drawing all of the battle
411:20 - Sprites we want to call self. battle
411:22 - Sprites do update and pass thata time in
411:25 - there now inside of May Pi we have
411:29 - animations this isn't terrible but also
411:32 - not ideal because at the moment all of
411:34 - the monsters animate at the exact same
411:36 - frame rate which can look a bit weird to
411:39 - make that a bit more interesting I want
411:41 - to create in the dunder init method a
411:44 - self.
411:46 - animation speed which is going to be the
411:50 - animation speed plus a random amount
411:54 - that we getting from uniform which I
411:57 - believe we don't have at the moment we
412:00 - want from random import
412:03 - uniform uniform is basically the float
412:07 - equivalent of random integer I.E we have
412:10 - to set a start and endpoint and then
412:13 - python is going to give us a random
412:14 - floating point value between those two
412:17 - in my case I want to go from -1 to 1 and
412:22 - then let me print a result if I now run
412:25 - may not
412:26 - Pi we get a bit more variation and if
412:30 - you look at the print statements now our
412:33 - animation speed has a bit more diversity
412:36 - not a lot but enough to make the game
412:38 - feel a bit more random and organic
412:40 - righty with that we have the monster but
412:43 - we are also going to need the UI and
412:46 - there are three classes that I want to
412:48 - create we want to have a monster name
412:51 - Sprite we want to have a monster level
412:55 - Sprite and a monster stats Sprite to
412:59 - understand these classes in the right
413:01 - you can see the
413:03 - result monster name Sprite is going to
413:06 - be the name it's going to be a rectangle
413:09 - up there monster level Sprite is right
413:12 - below this one shows the level of the
413:14 - monster and it's not in this image but
413:17 - in the bottom of this Sprite we're going
413:20 - to have the level progress I.E how far
413:22 - we are from the next level up both of
413:24 - these are fairly straightforward the
413:26 - slightly more complex one is the monster
413:28 - stat Sprite that's the stuff at the
413:31 - bottom that shows the health of the
413:33 - monster the energy of the monster and
413:35 - the Readiness of the monster that's the
413:37 - black bar at the bottom that's going to
413:40 - show you how far the monster is away
413:42 - from being able to attack or defend or
413:44 - do basically anything those three
413:47 - classes we have to create and let's do
413:49 - it step by step starting with the
413:51 - monster named Sprite for this class
413:53 - we're going to need a couple of
413:54 - arguments we want to have a position we
413:57 - want to have the monster Sprite we will
414:01 - need the groups and finally we will need
414:03 - a font these numbers we can get fairly
414:06 - easily although before that inside of
414:08 - Sprites we have to create a class first
414:10 - of all I want to have a class monster
414:15 - name Sprite with the parent being pame
414:17 - do sprite.
414:19 - Sprite for this one in the dunder init
414:22 - method we want to have a position the
414:25 - monster uncore
414:28 - Sprite the groups and the font most
414:31 - importantly we have to cause super
414:33 - Thunder init with the groups that part
414:36 - is easy after that we want to have self.
414:39 - image and self. rectangle the rectangle
414:43 - is fairly easy we simply want to get
414:44 - self. image. getet F
414:48 - rectangle where we are placing the
414:50 - midtop to the
414:53 - position the image is going to be a bit
414:56 - more complicated because essentially we
414:58 - want to render some text and this is
415:00 - going to be the size of this Sprite kind
415:03 - of similar compared to what we have done
415:04 - with the dialogue Sprite first of all we
415:07 - want to create a textor
415:10 - surface which is going to be font do
415:13 - render the text that we want to render
415:15 - would be the monster Sprite do monster.
415:20 - name and this brings us to something
415:23 - that we are going to see a lot monster
415:26 - Sprite is going to be the monster class
415:28 - we have created up here inside of that
415:31 - thing we have the actual monster data
415:33 - and only in there do we have the name
415:36 - what you always have to remember is that
415:38 - this monster class contains the actual
415:41 - information the monster Sprite at the
415:43 - moment is basically just there to
415:45 - display a Sprite and animate it that's
415:47 - all it
415:48 - does also I don't want to print the
415:50 - animation speed anymore that's not
415:53 - needed righty for antias we want to set
415:57 - fults and for the text color I want to
416:00 - have the colors
416:02 - and the black
416:04 - one on top of that I want to set some
416:07 - padding of 20 pixels for self. image we
416:11 - can create pame do surface for which we
416:15 - are going to need a width and a height
416:17 - for the whift I want to get the text
416:20 - surface and get
416:22 - underscore whift plus two times the
416:28 - padding one for the left side and one
416:31 - for the right side
416:33 - for the height we are doing basically
416:34 - the same thing I want to have the Tex
416:36 - surface get underscore height don't
416:39 - forget to call this one and to that we
416:42 - want to add two times the padding with
416:45 - that at the very least we should be able
416:47 - to see something although for that first
416:49 - of all inside of battle. Pi we have to
416:52 - import the monster name
416:57 - Sprite then we can create all of this
416:59 - but first of all we will need a position
417:01 - the monster Sprite groups and font font
417:05 - is the easiest part although for
417:08 - that we need to get all of the fonts
417:11 - those we already have and then we want
417:13 - to call Self do
417:16 - fonts the font name that I want to use
417:19 - is going to be
417:21 - regular for the groups we can simply go
417:23 - with self. battles
417:26 - Sprites the monster Sprite is going to
417:28 - be the monster Sprite we have just
417:31 - created to get this one we first of all
417:33 - want to create a local variable monster
417:36 - Sprite that way we can get the monster
417:38 - Sprite in there finally we're going to
417:41 - need a position let's rename this
417:43 - actually to name position to make it a
417:46 - bit more understandable now for that I
417:49 - want to create a local variable with the
417:51 - same name and basically what I want to
417:54 - do is I want to get the monster Sprite
417:57 - then W and then mid left order to that I
418:01 - want to add a a vector of 16
418:07 - and7 that is going to cover all of the
418:10 - arguments let's try to run main not pi
418:13 - and we are getting something so that's
418:16 - not a bad start the thing is entirely
418:18 - black though that's not ideal and we
418:20 - cannot see the text also for the
418:23 - opponents the Box should be on the right
418:27 - instead of the
418:28 - left let's work on that first of all we
418:32 - only want to get this position if
418:35 - entert is equal to player and if that is
418:39 - not the case so
418:42 - else then I want to get the monster
418:45 - Sprite dot wct do mid right along with a
418:52 - vector offset
418:55 - of-40 and
418:58 - 70 and by the way those are numbers I
419:00 - simply got from playing around there's
419:02 - no real science behind it it just looked
419:05 - good cool but that I'm quite happy with
419:08 - after that inside of the Sprites we
419:10 - first of all want to fill the entire
419:12 - surface I.E self. image. fill colors and
419:18 - a white color that is already looking
419:21 - much better although I think the box is
419:23 - a bit
419:25 - large let's change padding to 10 pixels
419:29 - I think that's going to be better yeah
419:31 - that looks much more reasonable finally
419:34 - we have to add the actual name of the
419:37 - monster that currently we have inside of
419:40 - the text surface to display it self.
419:43 - image. blit we want to display the text
419:47 - surface and then we have to get a
419:49 - position which in our case is going to
419:52 - be petting and petting if I now run all
419:56 - of this again we get the name of the
419:58 - monster in the center of the text box so
420:00 - that is looking pretty good now in case
420:03 - you're wondering about these two
420:05 - paddings the way you want to think about
420:06 - it is that this is the entire self.
420:10 - image and on there we have a whole bunch
420:14 - of paddings so it's always 10 pixels
420:16 - there 10 pixels there 10 pixels there
420:19 - and 10 pixels there when we are blitting
420:23 - the text surface we are looking for the
420:26 - top left which in our case is going to
420:28 - be this point here because all of this
420:32 - is what we have gotten from the width
420:34 - and the height of the actual text which
420:37 - means via this top left point we are
420:39 - centering the text perfectly and that is
420:42 - all we need from Monster name Sprite we
420:44 - can now minimize it and create another
420:47 - class with monster level Sprite Which is
420:51 - also going to be a pame Dos sprite.
420:54 - Sprite for this one let me uncomment the
420:58 - class name because now we have to figure
421:01 - out the argument ments I want to get the
421:04 - entity and an anchor I'll explain this
421:07 - one in just a second besides that we
421:10 - want to have the monster
421:12 - Sprite we want to have the groups which
421:15 - we can change right away to self. battle
421:17 - Sprites and finally we want to have
421:19 - self. fonts and the small font to
421:24 - display some text the last three
421:26 - arguments are fairly straightforward I
421:28 - don't think I have to explain them
421:31 - entity is is also fairly simple do we
421:33 - have a monster on the player side or on
421:35 - the opponent's side the only
421:37 - complication is the anchor so what is up
421:40 - with this one if we have a monster on
421:42 - the player side then we want to have the
421:45 - monster named Sprite on the top left
421:47 - roughly here the monster level Sprite I
421:51 - want to be right below here those two
421:54 - should have the same left side and also
421:57 - the level Sprite should be right below
421:58 - the name that way it looks like we have
422:01 - one connected Sprite but we do have to
422:05 - be careful this is only for the player
422:07 - side for the opponent monsters we want
422:11 - to have the entire thing mirrored it
422:12 - should look something like this where we
422:15 - have the name on the top this we already
422:18 - have but on the bottom we want to have
422:20 - the level so now they share the same
422:22 - right side for that we have to Define an
422:24 - anchor that part is slightly more
422:26 - complex so let's create another local
422:28 - variable I want to get either the bottom
422:30 - left or the bottom right of this monster
422:33 - name Sprite which means we need to store
422:36 - this in a variable as well let's call it
422:38 - name
422:39 - Sprite and then the anchor is going to
422:42 - be named. w. bottom left but only if the
422:51 - enter is the layer if that is not the
422:55 - case we want to get name. rec. bottom
422:59 - right that is going to give us all of
423:02 - the arguments next up we have to make
423:04 - sure that we are importing monster level
423:07 - Sprite and then we have to create the
423:09 - class which we start with by creating a
423:12 - thunder init method let me copy in all
423:16 - of the
423:18 - arguments like so self. battle Sprites
423:22 - is going to be the groups and self. font
423:26 - small is going to be the font as always
423:29 - do not forget to cause super Thunder
423:31 - init
423:32 - with the groups and also self. monster
423:36 - Sprite is going to be the monster Sprite
423:41 - we always want to connect this monster
423:43 - level Sprite to the monster Sprite
423:44 - itself because if the monster dies we
423:46 - want to get rid of this Sprite as well
423:49 - and I believe this I haven't done for
423:51 - the monster name Sprite in there we are
423:54 - only using the monster Sprite for the
423:55 - monster
423:56 - name we also want to have a self.
423:59 - monster Sprite attribute which which is
424:01 - going to be the monster Sprite anyway
424:03 - with that we have the monster Sprite
424:05 - next up we will need self. font which is
424:08 - going to be the font after that we're
424:11 - going to need self. image and self.
424:15 - rectangle for this monster level Sprite
424:17 - you do have to be careful because during
424:20 - the fight the level of the monster could
424:22 - update meaning we couldn't simply create
424:24 - the image once with the text and then
424:26 - call it a day we have to create an
424:29 - update method with self and Delta time
424:32 - although Delta time we're not going to
424:34 - use so an underscore instead inside of
424:37 - this update method we are displaying the
424:40 - text that way if the monster level
424:42 - increases during a battle we are still
424:44 - displaying the right information
424:46 - although I suppose for now we can simply
424:48 - get self. image and fill the entire
424:51 - thing with colors and white so now we
424:56 - have to figure out an image and a
424:57 - rectangle now for the image I was a
425:00 - little bit lazy and simply went with
425:02 - pame do surface and then added 60 and 26
425:06 - we always have a static size for the
425:08 - image and this number simply looked good
425:10 - and fit right in although if you're
425:13 - using a different dimension then this
425:15 - might have to change next up for the
425:17 - rectangle we want to get self. image.
425:19 - getet F
425:21 - rectangle where we are placing the top
425:25 - left to the
425:27 - position but only if the entity is equal
425:31 - to to the player if that is not the case
425:34 - then we want to get self. image. getet F
425:38 - rectangle where we are placing the top
425:41 - right although the position is still
425:43 - going to be the same and just to explain
425:46 - what this line means from the monster
425:49 - name Sprite we are getting a rectangle
425:52 - like this and if we on the player side
425:54 - we want to create the new Sprite right
425:57 - below with the same left side and the
426:00 - bottom of the name is the top of the
426:01 - level however if we are on the other
426:04 - side I.E the opponent then I want this
426:07 - level Sprite to be on the right side so
426:10 - here where we are sharing the right side
426:14 - although the vertical position is still
426:15 - going to be the same anyway let's try
426:18 - all of this if I run m. Pi we are
426:20 - getting an error that name is not
426:22 - defined this happens inside of this line
426:27 - because we are getting name. rec. bottom
426:29 - left this should be name underscore
426:32 - Sprite next attempt and another error we
426:37 - expect five arguments but we are giving
426:40 - six that usually happens because you
426:42 - have forgotten self in the dunder init
426:44 - method like I have just done next
426:47 - attempt and we are getting another name
426:49 - error that the position is not defined
426:53 - and that is
426:55 - because the position is going to be the
426:57 - anchor so instead of position I want to
427:00 - use the anchor
427:02 - although I guess name here would be a
427:04 - better argument but anyway now we are
427:08 - getting the right Sprite that looks
427:10 - pretty good and anchor here really isn't
427:13 - a good name let's call this one the
427:16 - levelor position and then inside of
427:19 - Sprites instead of anchor it's going to
427:22 - be a position for all of
427:27 - them let's try it again and that's much
427:30 - better sorry about
427:32 - now we have to display the level of the
427:34 - monster inside of the update method
427:37 - first of all for that I want to create a
427:39 - text surface local variable with self.
427:43 - font. render an F string with
427:49 - level and then self. Monsters sprite.
427:54 - monster. level I already talked about
427:57 - this but make sure to include the
427:59 - monster only in there do we have the ACT
428:01 - ual monster information after that
428:04 - antialias should be fals and for the
428:07 - colors I want to have the black color
428:10 - next up we need a text
428:13 - rectangle which is going to be the text
428:17 - surface. getf rectangle I want to place
428:21 - the center to the center point of this
428:24 - surface or in other words self. re. wift
428:28 - divided by two and self. re do height
428:32 - divided by two and finally self. image
428:37 - dolit with the text surface and the text
428:41 - rectangle let's try out of that and
428:44 - there we go now we have the level for
428:46 - all of the
428:47 - monsters there's just one more thing
428:49 - that I do want if this is the monster
428:53 - level Sprite at the bottom I want to
428:56 - have a level progress bar that shows us
428:59 - how far away we are from a level up now
429:02 - we already have a way to create a bar
429:05 - inside of support. Pi we have a draw Bar
429:10 - Method this we can reuse let me copy all
429:13 - of the parameters and then inside of
429:15 - Sprites don't forget from support import
429:19 - draw uncore
429:21 - bar inside of monster level Sprite I
429:24 - want to draw a bar with all of these
429:28 - arguments surface is going to be self.
429:31 - image
429:32 - rectangle we can ignore for now that's
429:34 - going to come in a second for the
429:36 - current value we want to get self.
429:39 - moners sprite.
429:40 - monster. XP max value is going to be
429:45 - also from the monster class inside of
429:47 - the monster Sprite although this one
429:49 - will be level uncore
429:52 - up for the main color I want to go with
429:56 - black I.E colors and black and BG color
430:01 - should be a white color so it looks like
430:03 - there's no background I.E background and
430:06 - white and the radius should be zero
430:11 - nearly done the last thing we need to
430:13 - get is the rectangle this I want to
430:15 - create in a separate variable XP
430:19 - rectangle which is going to be a pame f
430:23 - rectangle with left top width and height
430:27 - the height can simply be two pixels the
430:29 - width is going to be self. re. wift the
430:34 - left is going to be zero and top is
430:37 - going to be self. re do height minus
430:41 - 2 and also this XP rectangle we only
430:45 - have to create once I.E we can do it
430:48 - inside of the dunder init method and
430:51 - then call it self. XP
430:55 - rectangle this we can now insert into
430:58 - draw bar and if I run m. Pi again
431:02 - we can see a couple of XP bars now for
431:04 - the third monster Lavia we have a full
431:07 - XP bar this monster should have leveled
431:09 - up that mechanic we do not have at the
431:11 - moment but we can work on that later
431:14 - first of all though I want to display
431:16 - all of the Monster stats that part is
431:18 - more important for now for all of that
431:21 - we want to work inside of Sprites a
431:24 - monster stats Sprite as a parent we need
431:28 - pygame dos sprite. Sprite just as before
431:31 - for this one in the dunder init method
431:35 - we will need a position the monster
431:39 - Sprite the size that we want to use the
431:42 - groups and the font then the usual super
431:46 - Dunder init with the
431:49 - groups and we want to store self do
431:52 - monster Sprite as an attribute monster
431:55 - Sprite after that I want to create self.
432:00 - image and and self. rectangle so we
432:04 - actually have the stuff for the Sprite
432:05 - for self. image I simply want to create
432:08 - a py game surface with the size that we
432:11 - are getting from the parameter once we
432:14 - have that the rec we are getting with
432:16 - self. image. getet f
432:19 - rectangle and I want to place the mid
432:22 - bottom to the position finally while we
432:26 - are here self. font is going to be the
432:29 - font that's a good start with that we
432:32 - can inside of battle create the monster
432:35 - stat Sprite although first of all all
432:38 - the way at the top we need to import the
432:40 - class and also let me minimize things so
432:43 - it's a bit easier to see what's going on
432:45 - so to create an instance of this class
432:48 - we need these arguments the position
432:52 - will be the monster sprite. w. mid
432:57 - bottom I.E the bottom of all of the
433:00 - monsters do that I want to add an offset
433:03 - of zero pixels on the horizontal axis
433:05 - and 20 pixels on the vertical one we are
433:08 - going 20 pixels down the monster Sprite
433:11 - Remains the monster Sprite for the size
433:14 - I want to have a static number I went
433:16 - with 150 and 48 once again a number that
433:21 - simply looked good if you like something
433:23 - else just go with
433:25 - that for the groups I want to have self.
433:29 - battles Sprites and for the font it's
433:31 - going to be self. fonts from which we
433:34 - want to pick this small font with that I
433:38 - can run m not pi and we get a bottom bar
433:41 - below all of the monsters that's looking
433:43 - pretty good doesn't do very much at the
433:45 - moment though for that we have to work
433:47 - inside of monster stats Sprite
433:50 - specifically we will need an update
433:53 - method with self and Delta time although
433:56 - Delta time we're not going to use so I
433:58 - will add an underscore first of all we
434:00 - want to fill the entire image with
434:03 - colors and white after that we basically
434:08 - want to draw three bars one for the
434:10 - health one for the energy and one for
434:12 - the Readiness or in other words if this
434:16 - is the entire image or rectangle I have
434:19 - of those we want to have some health
434:22 - text here and then a health bar below
434:26 - that we want to have the energy text
434:29 - along with the energy G bar and finally
434:33 - all the way at the bottom so this line
434:37 - here I want to have a Readiness bar so
434:41 - how far away the monster is from being
434:42 - ready to attack now two of these
434:44 - attributes we already have all of the
434:47 - monsters have health and energy but
434:50 - there's no attribute to track how ready
434:52 - the monster is for that below the energy
434:57 - I want self dot I call this one the
435:00 - initiate
435:01 - if which by default is going to be zero
435:04 - and later on we will increase this
435:07 - number once it reaches 100 then the
435:09 - monster is ready to attack the speed by
435:12 - which that happens is defined for each
435:14 - Monster by the speed I.E if you look at
435:17 - all of the monsters there we have a
435:20 - speed attribute but that's going to come
435:22 - later for now initiative can always be
435:25 - zero after that inside of the update
435:28 - method we want to look for free
435:31 - attributes which we are going to do via
435:33 - a for loop I want for data in self.
435:38 - moners sprite. Monster and then get the
435:42 - info that I need which is a method that
435:45 - doesn't exist right now which means we
435:48 - have to work inside of the monster and
435:50 - then create a method called get
435:54 - info no need for custom parameters on
435:57 - this one and basically what we want to
436:00 - get and let me return the value right
436:02 - away we want to get a
436:04 - tupal that consists of three other tbls
436:08 - in which we first of all have self.
436:10 - health and then self.
436:15 - get stat with the max
436:19 - Health the next entry is going to be
436:22 - another tupal that is going to be very
436:25 - similar in fact I can copy
436:27 - it we want to have self. energy and
436:31 - self. Max Energy finally for the
436:36 - Readiness or the initiative we want to
436:38 - get self. initiative and the max value
436:41 - for this one is going to be 100 or in
436:44 - other words since we want to display a
436:46 - bar for this info we always need the
436:49 - current value and the max value which is
436:52 - what we are getting from this get info
436:55 - on top of that I want to know what index
436:58 - we are on for which I can use
437:01 - en numerate after which I'm getting an
437:04 - index along with the data the data here
437:07 - we can separate right away into a value
437:10 - and a max value just to keep all of this
437:14 - a bit more readable after that I want to
437:16 - get the color for each of the bars for
437:20 - which first of all I want to create a
437:22 - list where the first entry is colors and
437:26 - red then colors and blue
437:31 - finally colors and gray this is simply
437:36 - going to give us three of the colors
437:38 - that we have to find inside of settings
437:40 - one of those colors from that I want to
437:43 - pick one item via the
437:46 - index now we know from get info the
437:49 - first item that we are getting is going
437:51 - to be the health IE via the color here
437:54 - we getting the first element which is a
437:56 - red
437:57 - color after that I want to have two sep
438:00 - seate pieces of logic for the bars the
438:03 - health bar and the energy bar or in
438:05 - other words the first two bars are going
438:07 - to be drawn with text in the center is
438:10 - of the Sprite which means we first of
438:13 - all want to check if index is smaller
438:15 - than two in which case we would get
438:18 - health and
438:19 - energy but now let's add pass in here
438:23 - and then we can add els for the
438:27 - initiative although this one also gets
438:29 - passed for now
438:31 - inside all of this for the health and
438:34 - energy bar we will need a text surface a
438:40 - text rectangle and a bar rectangle
438:44 - whereas for the initiative we will only
438:47 - need a let's call it the init rectangle
438:51 - and that we can then use to draw a bar
438:53 - using draw bar from support all the way
438:55 - at to the bottom there we want to use
438:57 - draw bar again which means we have to
439:00 - get a few numbers this part could
439:02 - actually be a good exercise I want you
439:04 - guys to display the stats for each
439:06 - monster the end result should look
439:08 - something like this for all of the
439:09 - monsters pause the video now and see if
439:12 - we can figure this one
439:16 - out for the text surface we want to get
439:19 - self. font and then render all of that
439:23 - for the text we want to display I want
439:25 - to have an F string with the integer of
439:30 - the Cur value after which we are getting
439:32 - the max
439:34 - value antialias should be false and for
439:38 - the colors I want colors and black next
439:42 - up we need the rectangle and for that I
439:45 - want the text surface get F rectangle in
439:49 - which I want to place the top
439:51 - left for that I will need a tuper with
439:54 - an X and A Y position for X I basically
439:58 - want the text to be on left side with a
440:00 - bit of padding which in my case I have
440:03 - set to self. re. wift Multiplied with
440:07 - 0.05 I we have 5% of whift to the left
440:11 - side or why I want to get the index and
440:15 - multiply it with self. rect do height
440:19 - divided by two now for the first item
440:22 - where index is zero this value is going
440:24 - to be zero I.E this text rectangle will
440:26 - be in the top left for the second item
440:29 - index is going to be one
440:31 - which would put this number in the
440:32 - middle of the Sprite finally for the bar
440:35 - rectangle I want to have py game. f
440:40 - rect with text rectangle do bottom
440:45 - left plus a vector of Z and minus 2 I.E
440:51 - the top left of this F rectangle starts
440:54 - in the bottom left with a bit of an
440:56 - offset then we need another tupo with
440:59 - the width and the height for the height
441:01 - I simply went with four pixels because
441:03 - it looked good for the Wii I went with
441:06 - self. dowi but I only want to get 0.9 of
441:12 - that I.E
441:13 - 90% after we have all of that we can get
441:17 - self. image.
441:19 - blit with the text surface and the text
441:23 - rectangle also we can draw the
441:28 - bar for which we are going to need a
441:32 - whole bunch of arguments let me copy the
441:36 - parameters surface is going to be self
441:38 - dot image rectangle will be the bar
441:42 - rectangle that we have just
441:45 - created value is going to be the value
441:48 - and so will be the max value also for
441:50 - the color I want to have the color we
441:52 - created up here and for BG
441:55 - color I want to get colors and black for
442:00 - the radio here I want to go with two and
442:04 - that should be all we need although I
442:06 - already spotted one mistake this
442:08 - shouldn't be gray with an E this should
442:10 - be gray with an
442:11 - a other than that if I now run main Pi
442:15 - we are getting a name error that in nit
442:17 - direct is not defined let's have a
442:20 - look we have to comment out this part
442:23 - and then add a pass in there that part
442:26 - we can cover in a second next attempt
442:28 - and there we go we have health along
442:31 - with a bar that is looking pretty good
442:34 - next up then for the ended rectangle we
442:37 - don't need pass anymore and now we have
442:39 - to create the init rectangle which once
442:41 - again is going to be a pame f rectangle
442:44 - for which we have a position and a size
442:49 - the size is actually the easier part
442:50 - let's start there the WID is simply
442:53 - going to be self. Rec do width and
442:55 - height is going to be two pixels I.E we
442:58 - are covering the entire width of the
442:59 - rectangle and then for the height we
443:01 - have a number that looks good for the
443:03 - position then the left side has to be
443:06 - zero and for the top I want to have an
443:08 - offset of two pixels from the bottom of
443:10 - the Sprite in other words self. rec.
443:13 - height minus 2 that is all we need for
443:16 - this part after that we can draw the bar
443:20 - for which we are going to need a whole
443:22 - bunch of arguments once again let me
443:25 - copy them we still want to draw on self.
443:28 - image although the rectangle is not now
443:30 - going to be the a knit
443:33 - rectangle we are still getting a value
443:36 - and a max value along with a color
443:39 - although for the background color I want
443:41 - to have colors and white also for this
443:43 - one the corner radius should be zero so
443:47 - let's try all of that and we cannot see
443:50 - anything that is because inside of
443:53 - monster the initiative is zero but once
443:57 - again we can define a random integer
443:59 - between zero and and 100 and
444:02 - then we can see some amount of Readiness
444:06 - for all of the monsters which is a
444:08 - really good start that means we are
444:10 - nearly done with the setup for the
444:11 - entire thing there's just one more thing
444:13 - that I want to do and for that let me
444:15 - run the game again I want to work a bit
444:18 - more with the drawing order or in other
444:20 - words the Sprite for the name at the
444:22 - level I want to have behind the monsters
444:24 - it just looks better later on this will
444:27 - become very important and generally for
444:28 - a game you always want to have control
444:31 - what is being drawn on top and what is
444:33 - being drawn in the background for that
444:35 - like we have done for the Overworld the
444:38 - main Sprite group at the moment is
444:40 - Battle Sprites and this is just a
444:42 - regular Sprite group that I want to
444:45 - customize so instead of a generic group
444:48 - I want to have a battle Sprites class
444:51 - which we have to create inside of groups
444:54 - we already have all Sprites in there but
444:56 - that we can collapse because next up I
444:58 - want to have a class called battle
445:01 - Sprites which has a parent class of py
445:04 - game. sprite. group we as always will
445:08 - need a Dunder init method with self and
445:12 - that's about it and in there we have to
445:14 - initialize the parent
445:16 - class and then I also want to get self.
445:19 - display surface which we get with py
445:21 - game. display. getor surface that's all
445:25 - we need in there next up I want to have
445:27 - a custom draw method inside of this draw
445:30 - method we will need a for loop with for
445:32 - sprite in self and just to reestablish
445:35 - the basic mechanic we want to get self.
445:38 - display surface. blit with Sprite do
445:42 - image and sprite.
445:44 - wct with that inside of battle. piy we
445:49 - can from groups import battle Sprites
445:54 - after that the game should still work
445:56 - just fine except now when we are calling
445:59 - the draw method
446:00 - we don't need to add in the surface we
446:03 - want to draw on I down here we don't
446:06 - want to display surface anymore after
446:08 - that things should be working and they
446:11 - don't we get the issue that the battle
446:13 - spread object has no attribute display
446:15 - surface that happens inside of group so
446:18 - we do not have this display
446:20 - surface and I see the issue the init
446:23 - method has two many
446:25 - underscores but now there we go
446:28 - everything works just as before that is
446:30 - a good start so now we can work on the
446:34 - drawing logic I.E we can sort all of the
446:37 - Sprites which we are going to do once
446:39 - again by using a sorted method for which
446:43 - we already have a list that can remain
446:45 - self after that we will need a key which
446:48 - is going to be a Lambda function with a
446:50 - Sprite and then for every single Sprite
446:52 - we want to get a sprite. z attribute and
446:55 - Via that we are sorting all of the
446:57 - Sprites now at the moment the Sprites do
447:00 - not have a z attribute that part we do
447:03 - have to add which means at the moment we
447:07 - have four Sprites inside of this class
447:10 - and also inside of settings we have
447:13 - battle layers which is going to work
447:16 - kind of like the world layers in the
447:18 - sense that we're going to give every
447:19 - monster a number and then the higher the
447:21 - number is the later the monster will be
447:23 - rendered IE the fervet is going to be on
447:25 - top you use that inside of Sprites the
447:29 - monster Sprite is going to get self. Z
447:33 - which we get from
447:34 - battlecore layers and monsters should
447:38 - always be on the monster layer after
447:41 - that we can copy the entire line next up
447:43 - inside of monster name Sprite in the
447:46 - dund method I want to put this Sprite on
447:49 - the name layer which is going to be
447:52 - below the monsters next up the monster
447:54 - level Sprite is also going to get a z
447:58 - attribute and we are going to keep this
448:00 - this on the name
448:01 - layer finally for Monster stat Sprites
448:05 - we will need to that attribute again
448:07 - although this one we always want to have
448:09 - on top of the monster I.E on the overlay
448:11 - layer which is going to be on top of
448:15 - everything else that way we can always
448:17 - see the stats of the monster which is
448:19 - probably a good
448:20 - idea so with that if I now run main. Pi
448:24 - we can see that the name and the level
448:27 - are behind the monster also with that we
448:29 - have more control which is going to
448:31 - become important later on but anyway
448:34 - this is some pretty good progress next
448:35 - up we can work on making all of this
448:38 - interactive all right so at this point
448:40 - we have set up the entire thing how can
448:42 - we make it interactive and that is going
448:45 - to involve quite a few different things
448:48 - most importantly for now we have to make
448:50 - sure that the monsters update their
448:52 - initiative and then once they are ready
448:54 - we can select different
448:56 - options there's going to be an attack
448:59 - defense switching a monster or catching
449:01 - a monster and if we select attack or
449:04 - switch then we should get another menu
449:06 - with all of the available attacks or all
449:09 - of the available monsters that's what we
449:11 - are going to work on for now it's going
449:12 - to be quite a bit let's Jump Right In
449:15 - inside of the code we want to look at
449:17 - our monster because in there we have the
449:20 - initiative and this number we have to
449:22 - update Also let's set it to Zero by
449:25 - default to update this number I want to
449:28 - create an update method all the way at
449:30 - the bottom Define update for which we
449:35 - are going to need self and Delta time in
449:38 - there we want to check if not
449:41 - self. I.E later on we want to have
449:43 - control if the monster is updating or
449:45 - not which we're doing via an attribute
449:48 - which does not exist at the moment let's
449:50 - create it in the dunder Ed method self
449:53 - dop is by default going to be false
449:56 - although I guess this pause should be
449:58 - all the way in the top that it's a bit
450:00 - better organized anyway after we have
450:03 - that if the monster is not paused we
450:07 - want to update self.
450:10 - initiative and increase it by self.
450:13 - getet stat and the speed multiplied with
450:17 - Delta time this method we now have to
450:20 - call which is going to happen inside of
450:23 - the Sprite that contains it I.E monster
450:26 - Sprite this thing already has an update
450:28 - method which we can use
450:30 - self. monster. update with Delta time
450:35 - that should already be it to see
450:37 - something in the game and there we go
450:39 - now all of the monsters are getting
450:40 - ready with some getting ready faster
450:42 - than others and Lavia especially takes
450:44 - forever but that's okay with that in
450:47 - place I want to add a comment inside of
450:51 - the battle class let's call this one the
450:52 - actual battle system and the first
450:55 - important part that we have to work on
450:57 - is a method called check underscore
451:00 - active no need for custom parameters and
451:03 - in there we basically want to look at
451:05 - all of the monsters and then check if
451:07 - they are active for that first of all we
451:09 - want to get all of the Monster uncore
451:13 - Sprites which we get from self. player
451:16 - Sprites do Sprites plus
451:20 - self. opponent Sprites do Sprites
451:24 - Sprites you have to add so you can add
451:27 - two of these groups together without
451:29 - that it wouldn't work next up for all of
451:31 - the monsters we want to check if monster
451:33 - sprite. monster.
451:37 - initiative is greater or equal to a 100
451:41 - if that is the case we want to do
451:42 - something and during that time all of
451:44 - the monsters should be
451:46 - paused for which we first of all want to
451:49 - self. update all monsters and then put
451:54 - them in a pause State this update all
451:57 - monsters doesn't exist at the moment
451:59 - which means Define update all
452:03 - monsters with self and the option that
452:07 - we want to go for this one can only
452:09 - really be pause or resume that's all we
452:11 - are doing in here for that once again I
452:13 - want to get all of the Sprites which I
452:15 - have already done so let me copy the
452:18 - line I want to get the monster Sprite do
452:21 - monster and in there update the PA
452:24 - attribute it will be true if the option
452:28 - is equal to F if that is not the case we
452:32 - only have two option it's going to be
452:34 - false this method we now have to call
452:36 - inside of update and let's organize this
452:39 - method just a bit better I first of all
452:42 - want to do all of the updates and then
452:44 - I'm going to draw things so to add some
452:46 - comments we have the updates and we have
452:49 - the drawing
452:51 - logic after we are updating all of the
452:53 - Sprites we want to self. check
452:56 - active with that if I run main.py
453:00 - we are getting an error that happens
453:02 - inside of check active because this
453:03 - should be monster Sprite next
453:07 - attempt and there we go the first
453:10 - monster has reached the ready state so
453:13 - all of the other monsters are pausing
453:15 - that is looking pretty good that means
453:17 - we don't need update all monsters
453:19 - anymore and next up I want to do a bit
453:22 - more inside of check active first of all
453:25 - monsters sprite.
453:28 - monster. initiative
453:30 - should go back to zero after that I want
453:33 - to do two things first of all I want to
453:36 - get the monster Sprite and then
453:39 - highlight it which I'm doing via a
453:41 - method set uncore highlight and this one
453:44 - should be true on top of that I want to
453:47 - get a self. current uncore monster and
453:52 - set the monster Sprite to it this is
453:55 - going to become important in just a bit
453:57 - because that way we are controlling the
453:59 - current
454:00 - monster for that inside of Thunder init
454:03 - I want to create another section let's
454:06 - call it
454:07 - control in there at the moment we only
454:10 - want to have self. current monster which
454:13 - by default is going to be
454:15 - none but later on once the monster is
454:18 - ready it's going to be inside of this
454:20 - attribute and that way we have a bit
454:22 - more control over it so for example we
454:24 - can get the attack moves from it we can
454:26 - switch it we can kill it things like
454:28 - that that's going to come later for now
454:30 - though we want to highlight the current
454:33 - monster once it gets
454:35 - ready which means we will need a set
454:37 - highlight method that doesn't exist
454:39 - inside of the Sprite right now so we
454:41 - have to create it although it's not a
454:44 - terribly difficult method set underscore
454:49 - highlight with self and a value and
454:54 - ultimately all that we are doing is self
454:57 - do highlight is going to be the value
455:01 - for that we will need self. highlight as
455:03 - an attribute by default it's going to be
455:06 - false let's run main notp to make sure
455:09 - things aren't crashing and that is still
455:11 - looking pretty good but obviously we
455:15 - can't see anything so once the monster
455:17 - is ready I want to give it a white
455:20 - outline to highlight the monster I want
455:22 - to have something like this where we
455:24 - have a white outline for every single
455:26 - one of the monsters once they get
455:28 - active now creating this isn't the
455:31 - easiest thing in the world let's cover
455:32 - the theory first we will start by
455:35 - getting all of the Sprites of the
455:37 - monster and then we are filling every
455:39 - visible pixel with a white color and
455:41 - then finally we are going to move that
455:44 - new Sprite in all eight directions IE if
455:48 - this is the original monster we are
455:51 - moving it by some pixels to the top left
455:53 - and then we are getting a new monster
455:56 - image that is something like this after
455:58 - that we are going going to the top and
456:01 - then we have another monster that is
456:02 - somewhere here and this we're going to
456:04 - do for all of the eight possible
456:07 - directions the end result of that is
456:09 - going to be that we have an expanded
456:13 - Sprite that is going to look something
456:14 - like this I.E for all of the sides we
456:17 - have a few extra pixels which is going
456:20 - to give us this outline if we have the
456:22 - new Sprite behind the monster that's all
456:24 - that we are doing in here to create all
456:27 - of that I want to work in side of import
456:31 - assets specifically in the monster
456:34 - frames and I want to add an entry after
456:37 - we have created all of the Monster
456:38 - frames I.E monster frames and then I
456:41 - want to have the
456:44 - outlines or which we are going to create
456:47 - an outline
456:51 - Creator which is going to need two
456:53 - arguments the frames you want to get and
456:55 - then the width I eat the width of the
456:59 - white line around it the frames are
457:02 - going to be self. monster frames and we
457:06 - want to get all of the monsters for the
457:09 - WID I went with four pixels but that you
457:12 - can customize on your own I want to work
457:14 - on the outline Creator which I have put
457:17 - inside of support all the way at the
457:19 - bottom of the import functions Define
457:22 - outline Creator which has a frame
457:26 - dictionary parameter and then the with
457:31 - just as before we want to start by
457:33 - creating a new dictionary I call this
457:36 - one the outline frame dictionary by
457:40 - default this one is going to be empty
457:43 - and then for monster and the monster
457:47 - uncore frames in frame dictionary do
457:52 - items just to make sure you see what we
457:54 - are getting let me print the monster and
457:57 - the monster frames if I now run all of
458:01 - this we get a pretty substantial
458:04 - dictionary but in there we first of all
458:07 - have the monster itself the associated
458:09 - key is then going to be a dictionary
458:12 - with an idle animation and with an
458:14 - attack animation and basically we want
458:17 - to go through every single one of these
458:18 - surfaces and then fill them with a white
458:20 - color and expand them first of all
458:22 - though I want to get the outline frame
458:25 - dictionary create a new entry with the
458:28 - monster and Associated value is for now
458:30 - going to be an empty
458:32 - dictionary after that we can go with
458:36 - another for Loop for state and frames in
458:40 - Monster frames do items i. we're getting
458:44 - out of the states and the associated
458:46 - frames from the monster frames once we
458:49 - have that we want to get the outline
458:51 - frame dictionary again along with the
458:54 - monster inside of this new dictionary we
458:57 - can create a state key along with an
459:00 - empty list in this list we are going to
459:03 - store all of the frames for that first
459:05 - of all though we have to work with all
459:07 - of the frames which we do with four
459:09 - frame in
459:11 - frames and then we want to create a new
459:15 - Surface which we do with pame DOs
459:18 - surface for this thing we will need a
459:20 - tuple with width and height and
459:24 - essentially we want to have the same
459:26 - size as the frame in the original
459:28 - animation but since we are going to
459:30 - expand it it should be slightly larger
459:33 - as a consequence I want to create a
459:36 - vector of frame. getor size and do not
459:40 - forget to call this one to that number I
459:43 - want to add a vector with WID divided by
459:47 - two that way we are getting the size of
459:50 - the original surface via get size and to
459:53 - all of the sizes we are adding a Whi I.E
459:56 - we have a Whi up there there there and
460:00 - there after that we want to get a white
460:03 - I call this the white frame because we
460:07 - are basically taking all of the frames
460:09 - and then making every visible pixel
460:11 - white which we can do via a mask I.E py
460:15 - game. mask. from uncore surface the
460:19 - surface we want to use is the frame and
460:22 - this we want to straight away convert to
460:24 - a surface Now using a mask in py game is
460:28 - slightly more Advanced and I have made a
460:30 - whole tutorial on it if you want to know
460:32 - all of the details check that one out
460:35 - but essentially a mask is simply going
460:37 - to be a silhouette of a surface I.E if
460:41 - we have a visible pixel we have a white
460:43 - color and if we don't then we're getting
460:45 - a black color most of the time you're
460:47 - using this for Collision detection but
460:49 - you can also turn it back into a surface
460:51 - and then you have a black and white
460:53 - image which is what we have gotten from
460:55 - the white frame although we want to get
460:58 - rid of all of the black pixels which
461:00 - means white frame do setor color key and
461:05 - we want to get rid of all of the black
461:07 - pixels after we have that I want to get
461:10 - the new Surface and then blit the white
461:16 - frame in a certain position the first
461:19 - one would be zero and zero that would be
461:22 - the top left and I really want to draw
461:25 - what we are doing here so we have a new
461:28 - Surface that is a bit larger than the
461:31 - original frame I.E we have something
461:34 - like this and there at the moment we are
461:37 - taking the white frame and pasting it
461:39 - all the way in the top left this would
461:41 - look something like
461:44 - this so if the original Monster was
461:47 - right in the middle then this offset
461:49 - would give us an outline in the top left
461:52 - something like
461:55 - this in fact I believe the best way to
461:58 - demonstrate how this is working
461:59 - is by first of all returning the outline
462:03 - frame dictionary that way we have one
462:07 - part of the outline inside of the
462:09 - monster frames that we can use in the
462:12 - battle class we don't need check active
462:15 - anymore but when we are creating a
462:17 - monster I want to create one more class
462:20 - which is going to contain all of the
462:22 - outlines so right below the monster
462:25 - Sprite I want to create a monster out
462:29 - line Sprite Which is going to need the
462:32 - monster Sprite it will be in self.
462:36 - battle Sprites for the frames I want to
462:39 - have the outline
462:42 - underscore frames that's all we need in
462:45 - there although first of all we will need
462:47 - the outline
462:48 - frames those we are going to get like we
462:51 - have gotten the frames for all of the
462:53 - monsters in the first place I and there
462:55 - I want to have the outline frames which
462:58 - we first of all forget with self.
463:00 - monster frames there we have
463:04 - out
463:06 - lines from which we want to pick
463:08 - monster. name also really important if
463:12 - we are on the monster side we want to
463:14 - flip all of that which means we want to
463:17 - overwrite the outline frames with
463:20 - basically the same thing we have done
463:22 - for the original frames in fact I can
463:24 - copy all of this the only difference is
463:27 - that we now want to look at the outline
463:31 - frames.
463:33 - items so with that we have all of the
463:36 - arguments for the monster outline Sprite
463:39 - that means inside of Sprites right below
463:42 - the monster Sprite I want to have
463:44 - another class monster outline Sprite
463:47 - Which once again is pam. sprite. Sprite
463:50 - for Dunder init
463:52 - method I want to have self a monster
463:55 - Sprite the groups and the frames we want
463:58 - to dis play next up I want to have super
464:02 - Thunder innit with the groups and we're
464:06 - also going to need self. Z which we are
464:09 - getting from the battle layers and this
464:11 - one should be on the outline layer we
464:14 - want to store self. monsters Sprite as
464:17 - Monster Sprite and then self. frames is
464:21 - going to be frames once we have that we
464:24 - can actually create the Sprite we want
464:26 - to have self. image and self.
464:29 - rectangle for the image we want to have
464:32 - self. frames now for the state I want to
464:36 - look at the monster Sprite basically for
464:38 - this monster outline Sprite I always
464:41 - want to have the same state and the same
464:43 - frame index from the monster Sprite that
464:45 - why we are linking the
464:47 - animations which means for frames we
464:50 - will need self. monsters sprite. State
464:54 - and basically we getting this state next
464:58 - up we we will need the frame index and
465:00 - for that we have to change a few more
465:02 - things although that we can do inside of
465:05 - the animation first of all for the
465:08 - indexing I want
465:10 - self. monster sprite. frame
465:14 - index after that for the rectangle self.
465:19 - image. getf
465:22 - rectangle I want to place this Center to
465:24 - wherever self. moners sprite. rec.
465:28 - Center is now we just have to figure out
465:30 - inside of battle. Pi once a monster is
465:34 - ready we want to display the outline
465:37 - that we are going to do inside of the
465:39 - groups basically we want to check for
465:42 - all of the
465:44 - Sprites if sprite. Z is on
465:50 - battlecore
465:52 - layers and the outline I.E we are only
465:55 - looking at the outline
465:57 - layers and if and if it is not the case
465:59 - we are simply drawing all of the
466:03 - Sprites however if that is the case we
466:06 - want to get the Sprite and then look at
466:08 - the monster uncore
466:12 - Sprite remember Sprite is the outline
466:15 - Sprite the one we have just created
466:18 - which we don't really care about we want
466:19 - to know if the monster Sprite is
466:22 - selected if this one is equal to the
466:27 - current monster
466:30 - Sprite then we want to self. display
466:34 - surface. blit with sprite. image and
466:37 - sprite.
466:39 - rectangle now current monster Sprite we
466:41 - do not have available although that we
466:44 - can get via the parameter I.E inside of
466:48 - battle. Pi when we are drawing
466:50 - everything we want to pass in self.
466:53 - current monster after that we should be
466:56 - good to go although I did realize that
466:58 - we are not importing the
467:01 - monster outline Sprite but once we have
467:05 - that inside of main.
467:07 - Pi we are getting list index out of
467:10 - range that happens inside of this line
467:14 - where we are trying to assign a surface
467:17 - to the
467:18 - image to diagnose what's going wrong
467:20 - here let's print self. frames if I now
467:24 - run main.
467:25 - pi and scroll up a bit we can see that
467:29 - we have a dictionary for the frames but
467:31 - there are no surfaces inside of the list
467:34 - that is an issue that happens inside of
467:37 - the outline Creator function to fix that
467:40 - all we have to do is get the outline
467:42 - frame
467:44 - dictionary then the monster along with
467:48 - the
467:49 - state and append the new Surface the one
467:54 - with the outline and the white monster
467:57 - let's try off this again
467:59 - and now there we can see something so
468:03 - this is definitely making
468:06 - progress and also when we are printing
468:08 - the dictionary we are getting a whole
468:10 - bunch of surfaces that is definitely
468:12 - making progress and let me run all of
468:14 - this again once the first monster gets
468:16 - ready we get a whole bunch of black
468:19 - stuff around it that we can get rid of
468:21 - in just a second they really important
468:23 - part for now though is that we have a
468:25 - surface with a minor offset that is what
468:27 - we actually want
468:29 - and I think this part is getting a bit
468:31 - confusing so let me go over it once
468:33 - again we start with an outline Creator
468:36 - in there inside of support we are
468:38 - looking at all of the Monster frames and
468:41 - for all of those we are basically
468:42 - expanding the original surface and
468:44 - filling it with a white color these new
468:46 - surfaces we are then passing into
468:49 - another class monster outline Sprite
468:53 - which in turn is linked to monster
468:56 - Sprite also we don't need to print
468:58 - statement anymore so this monster
469:00 - outline Sprite has basically the same
469:02 - frames as the monster Sprite I.E the
469:06 - frames inside of this class are the same
469:08 - as the monster Sprite except they're
469:10 - white and a bit expanded after that once
469:13 - a monster is ready we are setting it to
469:17 - the current monster and then when we are
469:19 - drawing all of the Sprites inside of
469:21 - groups we are checking if a monster is
469:24 - currently selected and then we are
469:26 - displaying the outline Sprite behind it
469:28 - for for the logic you might have to go
469:29 - over it a couple of times it does get a
469:31 - bit more complex anyway the first thing
469:35 - that I want to do is get rid of the
469:37 - black background that doesn't look good
469:40 - for that inside of the new Surface I
469:42 - want to add another argument pame do
469:46 - SRC
469:48 - ala after that new
469:51 - surface. bill with a tup of 0 0 0 and
469:57 - zero I this new Surface is entirely
470:00 - invisible if I now run main Pi again we
470:04 - only get the white color and that's
470:06 - already looking pretty good we just have
470:09 - to get all of the other sides as well so
470:11 - inside of support I want to duplicate
470:15 - this line and then cover another side
470:18 - which I can for example get with whift
470:20 - and zero if I now remain not P again we
470:25 - are getting two sides and well this we
470:28 - basically want to do for all of the
470:29 - other sides and let me get rid of the
470:33 - comment besides whiff I also want to get
470:36 - wi time 2 that way we getting to the top
470:40 - right next up wi * 2 and wi that would
470:45 - be the center right and after that with
470:47 - * two for both arguments this will be
470:50 - the bottom right Next Step we want to
470:53 - have the bottom this would be whift and
470:55 - whift time 2 after that I want to have
470:59 - zero and wi * 2 and finally zero and Wii
471:05 - this would be the left side those are
471:07 - going to be all of the eight sides so 1
471:09 - 2 3 4 five 6 7even and eight looks good
471:13 - if I now run main. pie and the monster
471:16 - is ready we get a white outline that
471:18 - isn't animated yet so we do have a start
471:22 - but we need just a bit more inside of
471:25 - the monster outline Sprite we want to
471:28 - add an update method so Define update
471:32 - self and Delta time although Delta time
471:35 - we don't actually need let me add an
471:37 - underscore instead after that we want to
471:40 - get self. image which we're getting from
471:43 - self do frames then I want to have self.
471:48 - monsters Sprite do state and you might
471:52 - also be tempted to use self.
471:55 - monster sprite. frame index although for
472:00 - all of that to work we will also have to
472:03 - cover the integer and the modulus I.E
472:07 - let me copy actually all of this and
472:10 - then paste it in there now this we have
472:13 - to update we want to get the frame index
472:15 - from self.
472:18 - monstore sprite. frame index after that
472:22 - let me copy this self dooners sprite.
472:25 - frames and then also self dooners
472:27 - sprite.
472:29 - state with all of that we are already
472:31 - getting a really long line which isn't
472:34 - ideal but inside of main.
472:37 - Pi we are getting an animation so this
472:40 - is kind of working but not exactly
472:43 - something I like because this just feels
472:45 - a bit
472:46 - clunky instead inside of the monster
472:50 - Sprite when we are animating all of that
472:53 - I want to get a frame index that we can
472:55 - use inside of the outline Sprite all we
472:58 - really need in there is self do I call
473:01 - this one the adjusted frame index which
473:05 - is going to be the integer of self.
473:08 - frame index with
473:12 - modulus of the length of self.
473:15 - frames with self. State this is
473:19 - basically the same that we are doing on
473:20 - the next line in fact we can simply pass
473:23 - self. adjusted frame index in
473:26 - there and now that we have that we can
473:28 - get this self. adjusted frame index and
473:31 - pass it into this indexing
473:35 - [Music]
473:36 - operation by self. monster Sprite do
473:41 - adjusted frame index the result should
473:44 - be the
473:45 - same and that is looking pretty good and
473:48 - now the logic inside of the monster
473:51 - outline Sprite is also much more
473:53 - readable cool with that we know if a
473:56 - monster is selected however there's one
473:58 - more thing that I do want to do and
474:00 - that's going to happen inside of the
474:02 - monster
474:04 - Sprite you might actually be wondering
474:07 - why did we set set highlight because
474:09 - inside of the group when we are
474:12 - highlighting the monster we are checking
474:14 - if the monster Sprite is the current
474:15 - monster Sprite why don't we just check
474:18 - if the monster is highlighted or not the
474:20 - reason for that is that later on we are
474:22 - going to have quite a few more
474:23 - conditions in there and this is going to
474:25 - be the most efficient way of doing
474:27 - things we are however still going to use
474:29 - the Highlight value although only for a
474:32 - short bit once the monster is selected I
474:35 - want to always display the outline and
474:37 - then make the entire monster flash for a
474:39 - short bit let's say around half a second
474:42 - for that I want to work inside of
474:46 - animate if the monster is highlighted
474:48 - I.E if self. highlight then I want to
474:52 - get a mask again I.E I want to have
474:55 - let's call this one a white surface
474:58 - which we are once again getting from
474:59 - pame mask do from undor surface this
475:06 - surface that we want to convert is self.
475:08 - image and after we have all of that I
475:11 - want to go straight back to surface that
475:14 - way we are getting the silhouette from
475:17 - this silhouette we want to remove all of
475:19 - the black pixels I.E set uncore color
475:23 - key and I want to remove black finally
475:27 - self Dot image is going to be the White
475:31 - surface with that if I now run main. Pi
475:36 - we left the battle and now the selected
475:38 - monster becomes Pure White that is
475:40 - looking decent after we of that inside
475:45 - of the monster Sprite I want to create a
475:48 - bunch of timers timers and in there I
475:51 - want to have self. timers which is going
475:54 - to be a dictionary in which for now we
475:57 - have one timer to remove the
476:01 - Highlight this is going to be a timer
476:04 - that I don't think we have at the moment
476:07 - all the way at the top from timer import
476:11 - timer for a duration let's say half a
476:14 - second for the function we essentially
476:18 - want to call set highlight and then pass
476:21 - in the Boolean false value which we can
476:25 - do via a Lambda function in which want
476:28 - to call self.
476:30 - set
476:32 - highlight with a false value that way we
476:35 - can insert arguments without calling
476:37 - them after that inside of set highlight
476:40 - I want to check if value is truthy I.E
476:44 - if we are activating the Highlight if
476:46 - that is the case I want to get self.
476:50 - timers with the remove highlight timer
476:55 - and then activate all of that also
476:59 - what's really important inside of the
477:01 - update method we have to go for timer
477:05 - in. timers do
477:08 - values and then timer.
477:12 - update with that inside of
477:16 - main.py we are getting a white flash for
477:19 - a short amount of time and this might
477:20 - even be a bit too long let's change the
477:23 - duration to 300
477:26 - milliseconds and now
477:28 - yeah I think that looks a bit better but
477:30 - once again play around with the numbers
477:32 - and just see what looks good anyway with
477:34 - that we can work inside of the battle
477:38 - class and I want to keep on working
477:41 - inside of check active I want to check
477:43 - if the currently ready monster is one of
477:46 - the players that I can do with if self.
477:50 - layer Sprites in Monster sprite.
477:53 - groups this means we are looking at the
477:56 - monster Sprite the one we getting for
477:58 - from the four Loop and we are checking
478:00 - all of the groups and if the player
478:03 - Sprites are inside of that group then we
478:05 - know that a monster Sprite of the player
478:07 - is currently ready just to test if this
478:09 - is working let's print player monster
478:14 - ready I can run main pi and now we get
478:17 - player monster ready that looks good so
478:20 - inside of this if statement we want to
478:22 - get some kind of option to display a
478:25 - menu which I have done via another ATT
478:28 - rute self.
478:30 - selection uncore mode which I have
478:34 - called General now for that to work we
478:37 - have to work a bit more inside of Dunder
478:39 - in it under control because in there we
478:42 - will need a few attributes the one we
478:44 - have already seen is self. selection
478:48 - mode which by default is going to be
478:50 - none and later on this one could also be
478:52 - attack it could be switching a monster
478:55 - things like that after that I want to
478:57 - have self. selection uncore site which
479:01 - by default is going to be player it
479:03 - could also be opponent if that's the
479:05 - case we can select the opponent monsters
479:08 - should be straightforward and finally I
479:11 - want to create self. index C which is
479:14 - going to be a dictionary with a bunch of
479:17 - values we have General with zero then I
479:22 - can duplicate this a few times because
479:24 - besides that we want to have a monster
479:27 - in index we want to have an aex index
479:33 - along with a switch index and finally a
479:38 - Target index all of this is going to
479:41 - make sense in just a bit but just to
479:43 - explain the outlines imagine for
479:45 - selection mode we have General the one
479:48 - we are setting a bit further down if
479:50 - that is the case we have the monster and
479:54 - then we want to display a couple of
479:57 - icons
479:58 - like so those will be for the attacks
480:01 - defense switching a monster and catching
480:04 - a monster the indexes we are then going
480:07 - to use to select one of these options or
480:11 - in other words if selection mode is
480:13 - general and the general index is zero we
480:15 - want to be up here in fact now that we
480:19 - have that I want to add another
480:23 - section I call this one the UI and there
480:27 - I want to Define
480:28 - draw General only for custom parameters
480:32 - in there we want to draw all of the
480:34 - general
480:35 - options and just for some extra context
480:38 - this is the end result where we have the
480:40 - four icons right next to the active
480:42 - monster for that we want to create a for
480:45 - Loop that covers every individual item
480:49 - and those we are getting from settings
480:50 - because in there we have battle
480:54 - choices we getting the full choice if we
480:56 - are fighting a random mon monster and
480:58 - we're getting a limited choice if we are
481:00 - fighting a trainer the reason for that
481:03 - is if we are fighting a trainer there
481:04 - shouldn't be a catch option that one is
481:06 - only available for random monsters we
481:09 - want to get the battle choices but now
481:12 - let's call this data in battle
481:17 - choices and print what we get although
481:21 - to actually see the output we have to
481:23 - figure out when to call this method and
481:26 - for that I want to have another method
481:29 - Define draw UI basically in there I want
481:33 - to check if self. current monster exists
481:37 - and if that is the case I want to check
481:40 - if self. selection mode is equal to
481:45 - General if that is the case I want to
481:47 - call self. draw General this draw UI
481:51 - method we are then going to call inside
481:54 - of the update method on top of
481:56 - everything else self. draw UI well now
482:01 - if I run the code and the monster gets
482:03 - ready we are getting the different keys
482:06 - inside of the dictionary so at the very
482:09 - least we get something but this isn't
482:11 - ideal I suppose for a bit more detail we
482:14 - could add items and then we get a little
482:17 - bit more information but we have the
482:19 - other dictionary with all of the
482:21 - positions along with an icon at the
482:23 - moment I always want to get the full
482:27 - amount on top of that I want to get the
482:30 - index via enumerate that way I will get
482:33 - the index and then inside of a tupo the
482:38 - option and a
482:40 - data dictionary and just to visualize
482:43 - all of that I have the index I have an
482:46 - option and I have a data dictionary oh
482:49 - and also don't forget after the full
482:51 - dictionary we want to get the
482:54 - items if I now run main. pi we are
482:58 - getting all of the options so in there
483:00 - we have zero fight one defend two switch
483:03 - and three catch along with a position
483:06 - and an icon we want to display that is
483:09 - all the information we need so now we
483:11 - can draw a bunch of surfaces and those
483:14 - surfaces we actually already have
483:16 - because inside of main.py we have
483:20 - imported all of the UI icons if you look
483:23 - at the project folder under graphics and
483:27 - you are
483:28 - we already imported this folder and in
483:31 - there we for example have the hand we
483:33 - have a hand highlight we have a shield a
483:35 - shield highlight and a sword and a sword
483:38 - highlight oh and also the arrows for
483:40 - switching a
483:41 - monster those are the icons that we want
483:44 - to use which means I want to get a
483:47 - Surface and this I get via self. monster
483:51 - frames and then I want to get the UI the
483:55 - key I want to pick is what I'm getting
483:57 - from data dictionary and the icon so if
484:02 - you look at settings there we have a
484:03 - dictionary with a position and an icon
484:06 - after that we can create a rectangle
484:10 - which is going to be surface. getet
484:13 - uncore F rectangle where we are placing
484:17 - this Center and essentially I want to
484:19 - get self. current monster. rec. mid
484:24 - right Plus data dictionary
484:28 - and then the key position the position
484:31 - here might not be the best name it's
484:33 - more of an offset where we getting the
484:36 - right side of the monster and then
484:37 - adding these numbers anyway once we have
484:40 - all of that we can call self. display
484:42 - surface do blit with the surface and the
484:47 - rectangle if I now run main. pi and the
484:50 - monster gets ready we get the options
484:53 - they don't do anything at the moment but
484:54 - at the very least we can see something
484:57 - now before recover the input there are
484:58 - two more things that I want to do number
485:01 - one the currently selected icon should
485:03 - have an outline and then every other
485:06 - icon should be grade out so the player
485:09 - has an idea of what is being selected
485:11 - now this is going to be much easier
485:13 - compared to what we have done with the
485:14 - monsters because if you look at the UI
485:17 - folder there we have for example the
485:20 - shield and then a shield highlight or in
485:22 - other words if the current index is
485:25 - equal to the selected index then we
485:27 - wanton want to display the icon with the
485:29 - outline and then gray out everything
485:31 - else for that we have to work a bit more
485:35 - with the surface for which I want to add
485:37 - an if statement if the index is equal to
485:43 - self. indexes and the general index
485:49 - which at the moment is this one so we're
485:52 - getting a zero I.E the first item should
485:55 - be selected which means this surface
485:58 - should be the data icon this would give
486:01 - us a value like sword or Shield but to
486:04 - that we want to add an underscore I
486:08 - think the easiest way of doing that is
486:09 - to turn all of this into an F string and
486:13 - then select the icon along with
486:16 - underscore highlight and if that is not
486:19 - the case else the surface should be
486:24 - simply the icon for now and then we also
486:27 - are not going to need the F string let's
486:30 - see if this one is
486:31 - working and this is a bit hard to see
486:33 - but now around the sword we have a white
486:36 - outline I suppose we could change the
486:39 - general index to a two and
486:42 - now we are getting a white outline
486:45 - around the switch symbol so that's
486:47 - working pretty well although this value
486:49 - should be Zero by
486:50 - default next up for this surface that is
486:54 - not selected I want to wrap all of this
486:57 - into py game. transform.
487:01 - grayscale that way if I run M notp again
487:04 - any icon that's not selected will be
487:06 - great out that's looking pretty good so
487:09 - now we can draw the general options but
487:11 - they don't do anything for that we will
487:13 - need an input method which I have put a
487:16 - bit further up I want to have Define
487:20 - input and I guess I should add another
487:23 - comment for all of this the first four
487:26 - methods would be the methods for input I
487:29 - want to have self and no other
487:31 - parameters and then we want to get all
487:34 - of the keys as always which we are
487:37 - getting with pygame dokey doget uncore
487:41 - justor press which we can then use with
487:45 - keys and for example py game.
487:49 - Kore down but now let's add pass in here
487:54 - because first of all I want to outline
487:55 - all of the keys that we need
487:58 - there aren't very many we have key down
488:00 - key up and py game. key space these are
488:07 - the only input options and the space key
488:10 - we can ignore for now essentially if the
488:13 - player presses K down then I want to get
488:16 - self.
488:18 - indexes along with self. selection mode
488:23 - I.E at the moment our selection mode is
488:25 - general that means we are working with
488:27 - this number which we want to increase by
488:32 - one if we are pressing up we are doing
488:34 - the same thing except this number should
488:36 - get minus equal 1 although we do have to
488:39 - be careful here if we don't have a
488:41 - selection mode which is the case by
488:43 - default this would give us an error so
488:46 - we want to only check all of this if
488:49 - self. selection mode and just to be sure
488:52 - self. current
488:54 - monster there should only be an input if
488:57 - both of these are
488:59 - true so all of this gets indented one
489:02 - more time and then we have to make sure
489:05 - that we are actually calling the input
489:07 - method let's do it before we are doing
489:09 - anything else self. input if I now run
489:14 - main.py we're getting the options and if
489:16 - I press down or up we are selecting a
489:20 - different icon that works reasonably
489:22 - well but I can go outside of this
489:24 - selection which shouldn't be the case so
489:26 - if you press up too much or down too
489:29 - much nothing is being selected to cover
489:32 - that part we will need a limiter which
489:36 - is going to happen inside of input
489:39 - basically what I want to check is via a
489:42 - match case statement I want to know what
489:44 - our current self. selection mode is if
489:49 - there is the case
489:52 - General then I want to create a limiter
489:55 - which would be the length of
489:58 - battle
490:00 - choices with the full amount so at the
490:04 - moment this number would be a four which
490:07 - is a good sign because I want to limit
490:09 - this number to a four so if we go to a
490:12 - five we want to go back to a one the way
490:15 - we are going to achieve that is we want
490:17 - to assign a new value which is going to
490:21 - be self. indexes and the general index
490:26 - and this we want to increase by one but
490:29 - on all of this we want to use modulus
490:32 - with the limiter this we want to do for
490:35 - down and up except for up it should
490:38 - become a minus one that should actually
490:41 - cover everything although I realize I
490:43 - have a typo there shouldn't be a white
490:45 - space before General let's run my. pi
490:49 - and then I can go down and if I go to
490:52 - index 5 we are starting from the
490:54 - beginning again so that is working
490:57 - really well now the UI is working
490:59 - significantly
491:01 - better once we have that we can check
491:04 - for the space
491:06 - key first of all in there we want to
491:08 - check what kind of selection mode we
491:10 - currently have which we do with if self
491:13 - do selection mode is equal to
491:18 - General if that is the case we can add a
491:21 - few more if statements to check what the
491:23 - current index is for example if self do
491:28 - indexes
491:29 - and general is equal to zero then we
491:34 - want to print a
491:36 - attack if this number is a one then we
491:40 - want to print defense if the number is a
491:43 - two then we want to print switch and
491:47 - finally if the number is a three then we
491:50 - want to print catch let's try that
491:54 - one and if I print space on Z we get
491:57 - attack then defense then switch and
492:00 - catch so we can select one of the
492:03 - options and that works Fairly reliable
492:07 - what we can already work on is the
492:09 - defense so the index being one if that
492:13 - is the case I want to self. update all
492:17 - monsters and then resume things on top
492:20 - of that self. current monster and self.
492:23 - selection mode should be none fin
492:27 - self. indexes and
492:31 - general is going to be zero that way we
492:35 - are resetting everything and now if I
492:37 - run main. Pi I can select defense and
492:40 - the game continues and then we are
492:43 - selecting an opponent that's not ideal
492:45 - for testing
492:47 - purposes that we can change inside of
492:49 - main. Pi for all of the opponent
492:52 - monsters I want to have a lower level
492:54 - let's say we can go with five three
492:57 - three and
492:59 - two that way our monsters should always
493:01 - be
493:02 - faster and then I get the other monster
493:05 - and this can also defend and we get our
493:08 - first Monster again so this part is
493:11 - already working quite well we are making
493:13 - some decent progress so next up we can
493:16 - work on the attack and the switch logic
493:20 - if the player selects the first option
493:22 - we want to set self. selection mode to
493:27 - a attack and then if the player selects
493:30 - number two we want to go with switch
493:34 - although I think the selection mode for
493:36 - attack is actually called attacks the
493:38 - one I have outlined up here so with that
493:41 - we can pick one selection mode which
493:43 - means we have to draw a few more UI
493:46 - elements we want to have Define draw a
493:52 - text with pass for
493:55 - now and we want to have the L
493:58 - raw
494:00 - switch with self and pass as well to
494:04 - select one of those we have to work
494:06 - inside of draw UI if self. selection
494:11 - mode is equal to a
494:15 - text then we want to call self. draw it
494:19 - text and if self. selection mode is
494:24 - equal to switch then we want to call
494:28 - self. draw switch and let's get started
494:32 - with the attacks for that we have to
494:35 - start by getting the abilities in the
494:37 - first
494:38 - place for which we want to get the
494:41 - current monster then monster and get
494:46 - ability the method that we already have
494:49 - inside of the monster we have use that
494:51 - for the index after that I want to set a
494:55 - height for the box which is going to be
494:57 - 200 I want to set the amount of visible
495:00 - attacks which I want to keep at four
495:03 - next up I want to set an item height
495:07 - which is simply going to be the height
495:10 - divided by visible attacks also we are
495:14 - going to need a v offset which for now
495:18 - is going to be zero and by the way the
495:20 - system that we are going to create will
495:22 - be very similar compared to the list
495:24 - that we have made for the index so so
495:27 - first of all we need the data after that
495:31 - I want to create the
495:34 - background for which we are going to
495:36 - need a BG
495:39 - rectangle which is going to be a pame f
495:43 - wct with a position and a size the
495:48 - position we're going to ignore for now
495:49 - so zero and zero for the size I want to
495:54 - have width and height with the height be
495:56 - being the height and I realized I didn't
495:59 - set a Whi let's do it in the data part
496:02 - Wii and height and this should be 150
496:06 - and
496:07 - 200 that way we can set Whi and height
496:10 - in there right away this rectangle we
496:13 - then want to move to a position the
496:16 - point I want to place is the mid left
496:20 - which is going to be self. current
496:21 - monster. w. mid right plus and offset
496:27 - that I have set to Vector of 20 and zero
496:32 - I.E we are placing the mid left of this
496:34 - option to the right side of the monster
496:36 - plus 20 pixels once we have that we can
496:40 - call py game. draw. rectangle we want to
496:44 - draw on self. display
496:48 - surface the color we are getting from
496:51 - colors and white then we want to draw
496:55 - the BG rectangle we want to have zero
496:57 - for the Border width and then five for
497:00 - Border radius with that if I run main.
497:04 - pi and I select attack we are getting an
497:07 - area that we can use for the attacks
497:10 - very good start next up we want to
497:12 - display the actual attack options for
497:15 - that we will need for index and ability
497:18 - in enumerate
497:21 - ability for this one we want to have a
497:25 - text we want to have have a rectangle
497:28 - and then we want to draw all of this
497:31 - first of all though we want to know if
497:33 - the current item is selected which we
497:36 - are getting via index is equal to self.
497:40 - indexes and attex and for the text I
497:43 - want to have a text color and a text
497:47 - underscore surface for now for the text
497:50 - color let's simply go with colors and
497:53 - the one that I want to choose is called
497:55 - light then for the Tex text
497:58 - surface I want to get self. fonts with
498:02 - the regular font and render it with the
498:08 - ability then fults and the text color
498:12 - that way we are getting some text that
498:14 - we can display next up we will need to
498:17 - position that text which we're doing
498:19 - with text
498:21 - rectangle I want to get the text surface
498:24 - and then get f rectang
498:27 - angle in which I'm placing the center I
498:30 - want to get BG rectangle IE the
498:33 - background rectangle for the entire bit
498:36 - and the midtop of this point plus a
498:39 - vector that goes zero pixels left and
498:42 - right and to that I want to add the item
498:48 - height divided by
498:50 - two plus the index multiplied with the
498:54 - item height also Al to all of this we
498:57 - want to add the V offset although this
499:00 - one is zero at the moment and just to
499:03 - explain the numbers if this is the
499:06 - background rectangle we want to place
499:08 - the attack options let's say one here
499:11 - one here one here and one here and they
499:14 - should distribute the area equally so
499:17 - that we always have the same distance
499:19 - between them the way I have approached
499:22 - that is I first of all set a starting
499:24 - position which is the this distance and
499:28 - then to that we are adding index
499:30 - multiplied by the item height I.E if
499:33 - this is zero we are staying here if this
499:35 - is one we are going there if this is two
499:37 - we are going down here and so on with
499:39 - that we have a text surface and a text
499:42 - rectangle so now we can self. display
499:44 - surface do blit with the text surface
499:48 - and the text rectangle let's try main.
499:51 - pi and if I select the options we can
499:55 - see something although we already have
499:57 - the issue that there's an extra option
499:59 - at the bottom also nothing is selected
500:02 - and if I press down the game crashes
500:05 - because we do not have the limiter
500:07 - variable so let's go through all of this
500:09 - step by step first of all we have to
500:11 - reenable the input at the moment this
500:14 - limiter does not exist because inside of
500:17 - match case we are not checking for
500:19 - attacks that we can fix fairly easily
500:22 - case it attacks the limiter that we want
500:26 - to create create is the length of self.
500:29 - current
500:30 - monster. monster. getet abilities that
500:34 - way if I run main.
500:37 - Pi I can at the very least press up and
500:40 - down although it doesn't do anything at
500:41 - the moment but at least the game doesn't
500:44 - crash
500:45 - anymore inside of draw attacks there are
500:49 - two things that I want to do to
500:51 - highlight the currently selected attack
500:53 - I want to change the Tex's color and
500:56 - then add a
500:57 - background for that we want to check if
501:02 - selected then we want to get a specific
501:05 - color however if that is not the case
501:07 - else then we have the basic text color
501:10 - for more specific color I want to get
501:13 - colors and then use the element of the
501:16 - attack let's store that one in a
501:19 - separate variable element this one we
501:22 - can get from the attack data that's
501:26 - currently not available for that all the
501:28 - way at the top I want from gamecore
501:32 - data import a TCH data we are importing
501:38 - this
501:39 - dictionary that we can use and let me
501:42 - minimize
501:43 - everything inside of draw
501:47 - attacks we have the attack data and then
501:50 - we have the ability from that we want to
501:53 - get the string element and that ele
501:56 - element we can now use inside of the
501:58 - colors to create a textor color or
502:03 - rather a more specific text color for
502:05 - the text surface let's try main. pi and
502:10 - now inside of attack we are getting
502:13 - something but the selection doesn't
502:16 - really work something has gone wrong and
502:19 - I believe I know what the issue is
502:22 - inside of input when we are assigning a
502:25 - new Index this shouldn't be General
502:27 - Instead This should be self. selection
502:32 - mode that way we can use different kinds
502:35 - of selection modes or rather different
502:37 - selection indexes or Draw attacks we are
502:40 - using the attack index so with all of
502:43 - that let's try it again and now I can
502:47 - kind of select all of the attacks
502:50 - there's just one issue and that is the
502:52 - color for the normal attack just doesn't
502:53 - work well that is because the element
502:56 - color for the normal attack is a pure
502:58 - white which I don't really like to fix
503:01 - that I only want to get the element
503:03 - color if the element is different from
503:08 - normal if that is not the case else I
503:11 - want to get colors and
503:15 - black and with that if I now run main.
503:19 - Pi we're getting a black color which
503:21 - feels much better although I also want
503:25 - to have a background color below the
503:28 - text rectangle I want to create a text
503:31 - BG rectangle pame dot f wct for which we
503:37 - will need a position and a size position
503:40 - doesn't really matter so we can go with
503:42 - zero and zero for the size I want to
503:45 - have the width of the entire thing and
503:48 - then the item height after we have all
503:50 - of that I want to call move to to move
503:53 - the center to the text rectangle
503:57 - Center this rectangle we then want to
503:59 - draw which we do with py game. draw.
504:02 - rectangle self. display surface for now
504:06 - let's go with a red color and then text
504:11 - BG
504:12 - rectangle after
504:15 - that we have a bit too much
504:18 - red the issue here is that we are
504:21 - drawing this rectangle for every single
504:23 - element which is incorrect we only want
504:25 - to draw it if
504:28 - selected let's try that one again and
504:31 - now there we go this looks much more
504:33 - noticeable it doesn't look great but
504:36 - well we have something the most notable
504:39 - issue is that the red color just doesn't
504:41 - fit well to get a better one I want to
504:43 - access the colors dictionary I want to
504:46 - use the light color for this one and now
504:48 - inside of main.
504:51 - Pi we are getting a color although I
504:53 - think this one is quite dark so maybe
504:56 - not ideal instead inside of settings I
505:00 - want to add another entry that you are
505:02 - already going to have I call this one
505:05 - dark white with a hex code of F0 F0 and
505:11 - F0 you should already have this entry I
505:14 - simply forgot to add it that's right now
505:17 - and that is looking much better there
505:21 - are two more things that we have to
505:22 - cover number one is this last item at
505:25 - the bottom shouldn't be visible and if
505:28 - we go further down there should be a
505:29 - scroll effect like we have done for the
505:32 - list inside of the index first of all
505:34 - when we are drawing all of the elements
505:37 - we only want to draw things that are
505:38 - inside of the BG
505:41 - rectangle which means I want to check if
505:45 - BG rectangle do Collide point with text
505:51 - rectangle do Center on top of that we
505:54 - want to check and
505:56 - [Music]
505:58 - seed inside of this if statement we
506:00 - still want to check if an item is
506:02 - selected and then there we also want to
506:04 - do the blit operation that should
506:06 - already do a bit if I now run this again
506:10 - we cannot see the last element anymore
506:12 - so progress but not ideal to fix all of
506:16 - that we have to work with the V offset
506:19 - this one should only be zero if self.
506:22 - indexes and it Xs
506:26 - is smaller than the visible attacks if
506:30 - that is not the case else it should be
506:33 - negative self. indexes and
506:39 - attacks minus the visible attacks plus
506:42 - one all of that we want to multiply with
506:45 - the item height the very same thing we
506:48 - have done for the index let's try this
506:50 - [Music]
506:52 - one and now if I scroll down we are
506:55 - getting all of the elements so that is
506:57 - looking really good perfect the last
507:01 - thing that is a bit weird is the corner
507:03 - radius that we have to fix inside of the
507:06 - drawing when we are drawing the text BG
507:09 - rectangle inside of selected we want to
507:11 - check if text BG rectangle. Collide
507:17 - point with BG rect do top left I we know
507:22 - we are at the top if that is the case we
507:25 - want to draw the entire thing with a
507:28 - border width of zero a general Corner
507:31 - radius of zero as well then five and
507:33 - five for the top left and top right next
507:36 - up we have an L if statement where we
507:39 - are checking if the text PG rectangle
507:42 - collides with the BG rectangled mid
507:45 - bottom although to that I want to add a
507:49 - vector of 0 and -1 if that is the case I
507:55 - want to draw another
507:57 - rectangle we want to have zero for the
507:59 - Border WID the top left and top right
508:02 - should be zero and zero but the bottom
508:04 - border radi should be five and five
508:07 - after we have all of that
508:09 - else we simply want to draw the general
508:14 - text BG
508:16 - rectangle and with that I can run all of
508:19 - this again and that is feeling pretty
508:24 - good so with that we're getting all the
508:26 - attacks and we get the attack type that
508:28 - is making a lot of progress there's just
508:30 - one more thing that I do want to cover
508:32 - and that is that all of these attacks
508:34 - have a cost and we should only display
508:37 - the attacks that are available or in
508:40 - other words if you look at game data
508:43 - they can see that all of the attacks
508:45 - have a cost and if this cost is greater
508:48 - than monster dot energy then this attack
508:52 - should not be displayed to implement
508:54 - that mechanic we want to look at get
508:58 - abilities I want to add another
509:00 - parameter all that by default is going
509:02 - to be true and then if all is the case
509:07 - then I want to return what we are
509:09 - already returning however if that is not
509:11 - the case so else then I want to return
509:15 - all of the abilities that are available
509:18 - for this level but then I'm going to add
509:21 - a second condition and a tagore
509:26 - data something that we currently don't
509:28 - have available so all the way at the top
509:30 - from game data import monster data and
509:33 - attack
509:34 - data we want to check the one ability
509:38 - and then the
509:40 - cost only if that value is below self.
509:45 - energy then we want to return it which
509:48 - means inside of the battle when we are
509:51 - getting all of the abilities that
509:54 - happens all the way down here
509:57 - I want to set all to BS the same thing
510:01 - we have to do inside of input when we
510:04 - are getting the abilities there all
510:07 - should also be false now inside of the
510:09 - game this is going to be a bit hard to
510:11 - see simply because this monster has a
510:14 - huge amount of energy and all of these
510:16 - attacks don't take very much but for
510:19 - example for heal we could increase the
510:21 - amount by a lot so that to heal cost
510:25 - could be 600 more than the monster even
510:29 - has so now if we run main. Pi this one
510:32 - shouldn't be
510:33 - visible and it is not so this one is
510:37 - working and also with that we have
510:40 - finished the draw attacks method it
510:43 - doesn't actually do anything at the
510:44 - moment but that we're going to cover in
510:46 - the next part before that I want to
510:48 - cover draw switch that part is going to
510:52 - be your exercise I want you to create
510:54 - the switch menu
510:56 - you only have to display it like we have
510:58 - done for the attack menu the actual
511:00 - functionality is going to come later and
511:03 - the end result should look something
511:04 - like
511:05 - this so pause the video now and try this
511:08 - one on your
511:12 - own to get started we want to declare
511:15 - some data I want to set a height and a
511:19 - width those numbers can be fairly
511:21 - subjective but I went with 300 and 320
511:26 - then we want to have the amount of
511:28 - visible
511:30 - monsters which I have set to
511:33 - four after that once again we want to
511:35 - have an item height which is the height
511:38 - of the entire menu divided by the
511:42 - visible
511:44 - monsters next up we will need a v offset
511:47 - that we have done a couple of times by
511:49 - now so I can implement the entire thing
511:51 - straight away zero if self. indexes and
511:55 - now we are working inside of the switch
511:58 - index and we only want to get zero if
512:00 - this number is below the
512:03 - visible not attacks but
512:06 - monsters else we want to get Negative
512:09 - self. indexes
512:13 - and
512:15 - switch minus the visible monsters + one
512:20 - which we want to multiply with the
512:23 - item I after that we can create a BG
512:28 - rectangle which is a pame f
512:33 - rectangle for the position we can as
512:35 - always go with zero and zero and for the
512:38 - size I want to have the width along with
512:40 - the height then I want to move this
512:43 - thing to a certain position which in
512:45 - this case will be the mid left is self.
512:49 - current monster do W do mid right plus a
512:55 - Vector of 20 and zero that is going to
512:59 - give us a BG
513:02 - rectangle let's draw it right away py.
513:05 - draw. rectangle self. display
513:08 - surface the color is going to be colors
513:12 - and
513:14 - white and finally we want to draw the BG
513:17 - rectangle let's try main. pi and now if
513:21 - I select switch we are getting an error
513:25 - because of a typo this should be Pi
513:28 - game. F rectangle next
513:32 - attempt and there we go that looks
513:35 - pretty all right I suppose the one thing
513:37 - that we do want to add is zero for
513:39 - Border width and then five for Corner
513:42 - radius after that we want to get all of
513:45 - the available Monsters the way I have
513:48 - approached that first of all I want to
513:50 - get all of the active monsters inside of
513:53 - a list or in other words I want to have
513:56 - the monster Sprite for Monster Sprite in
514:00 - self. player Sprites although I don't
514:04 - actually care about the Sprite itself
514:07 - that I want to have monster sprite.
514:11 - index and monsters
514:13 - sprite.
514:15 - monster that way we get the index of the
514:18 - monster and the actual monster data
514:20 - basically the same thing that we are
514:23 - getting up here
514:26 - or rather we're getting something like
514:28 - this where we have a monster along with
514:31 - an index to identify
514:33 - it that is really important because
514:35 - later on we want to switch to monsters
514:37 - so we have to know exactly what kind of
514:39 - monster we are working with although if
514:41 - you didn't include it for this part in
514:43 - the exercise don't worry too much about
514:44 - it that wasn't really part of the
514:46 - exercise after that I want to get self.
514:50 - available uncore monsters which has to
514:54 - be an attribute l on inside of the input
514:57 - that will become
514:58 - important we want to create a dictionary
515:02 - with an index and a monster for index
515:07 - monster in self
515:09 - Doge monster data of the layer with that
515:15 - we are copying all of the Monster
515:18 - data but that we only want to do if a
515:21 - certain condition is true and also from
515:24 - the player monsters we want to get the
515:27 - items but we only want to get all of
515:29 - that if the index and the
515:34 - monster are not in active
515:38 - monsters and I suppose also while we are
515:40 - here and
515:42 - monster.
515:44 - health is greater than zero if the
515:48 - monster has been defeated there's no
515:50 - point showing it but that's not too
515:52 - important for now anyway with that we
515:54 - are getting of the available monsters
515:57 - which we can then use inside of a for
515:59 - Loop for index and monster in a
516:04 - numerate self. available monsters.
516:08 - values to get started we want to know
516:11 - what item is selected which we're
516:13 - getting with index equal self do indexes
516:18 - and
516:20 - switch next up we will need an item BG
516:24 - rectangle
516:27 - this is the equivalent of the text PG
516:28 - rectangle of the last part I.E I want to
516:31 - have an F rectangle the position is
516:33 - going to be zero and zero and the size
516:36 - is going to be width and the item
516:41 - height this we want to move to a
516:44 - specific
516:45 - point or in other words I want to place
516:47 - the mid left of this rectangle the X
516:51 - position is always going to be the left
516:53 - side of the background I.E BG rectangle
516:55 - do left for the Y position I want to
516:59 - have the BG rectangle do
517:02 - top plus item height divided by two to
517:06 - set a start point and to that I want to
517:09 - add the index multiplied by the item
517:13 - height and don't forget to all of that
517:16 - we want to add the V of set quite a long
517:19 - line but I hope at this point you
517:21 - understand the logic after that I want
517:23 - to create an icon
517:26 - surface and I can
517:29 - rectangle a text underscore surface and
517:33 - a text uncore rectangle we want to
517:37 - display the icon of the monster and then
517:38 - its
517:39 - name for the icon surface I want to get
517:43 - self. monster frames with the icons the
517:47 - data we have imported
517:48 - earlier and then get monster. name for
517:53 - the icon rectangle I want to get the
517:56 - icon surface get F rectangle and place
518:00 - the mid left point for the Target
518:02 - position I want to have a BG rectangle
518:05 - dot top
518:07 - left plus a vector of 10 for x or why I
518:13 - want to get basically all of the stuff
518:15 - that we have done here except BG re. top
518:19 - so let me copy it in there that way we
518:22 - always getting to the vertical Center
518:25 - for each
518:26 - increment next up we have to text
518:29 - surface that one's a bit easier we
518:31 - simply want to get a font self. fonts
518:34 - and I want to use the regular one and
518:37 - then render an F
518:40 - string with the monster.
518:44 - name and then in
518:48 - parentheses monster.
518:51 - level for antialias we want to have
518:54 - faults and for the color I want to get
518:57 - colors red but only if selected and else
519:03 - it should be
519:05 - colors black or in other words we are
519:08 - simply picking one of two colors
519:09 - depending on the monster being selected
519:11 - or not finally we have a text
519:15 - rectangle which we're getting from the
519:17 - text surface. get F wed we want to place
519:22 - the top left to BG re. left Plus
519:28 - 90 and for the vertical point I can rect
519:32 - dot pop now for the drawing logic I want
519:36 - to have a for loop with surface and
519:38 - rectangle in the Tuple that contains two
519:42 - TS I can Surface and I can rectangle
519:47 - after that we have the text surface and
519:51 - the text
519:54 - rectangle in inside of this for Loop we
519:56 - can then run self. display surface. blit
520:01 - with the surface and the rectangle quite
520:04 - a bit of stuff let's run main.py and
520:06 - let's see what crashes first if I go to
520:09 - switch we can see them monsters but if I
520:11 - press down the limiter doesn't exist so
520:14 - not ideal for that we have to work
520:17 - inside of
520:19 - input and then add another case for
520:24 - switch
520:25 - for the limiter I want to get the length
520:28 - of self. available
520:31 - monsters let's try all of this again if
520:34 - I may now go to switch we can see all of
520:38 - the monsters that are available let's
520:41 - looking pretty good also the selection
520:43 - works just fine quite happy with that I
520:47 - suppose the one minor thing that doesn't
520:48 - look terribly good is when we are
520:51 - getting the monster name X surface I
520:54 - want to have a space between the monster
520:56 - name and the level a super minor point I
521:00 - suppose there are two more major points
521:02 - that I want to cover first of all I want
521:04 - to have a selection
521:06 - background so it's a bit more visible
521:09 - what is being selected for that if
521:12 - selected is the
521:15 - case then I want to check if the item BG
521:20 - rectangle do Collide
521:24 - point with with BG rectangle. toop left
521:28 - or any point at the top to be honest if
521:31 - that is the case I want to run pame do
521:34 - draw. rectangle self. display surface
521:38 - for the color I want to have colors and
521:41 - dark white finally then we want to have
521:45 - the item BG rectangle and there's one
521:48 - dot too much of Z
521:52 - and-1 if that is the case I want to draw
521:55 - another rectangle although now zero for
521:59 - top left and zero for top right that way
522:03 - only the bottom has a corner radius
522:06 - finally if neither of those conditions
522:08 - are true then I want to draw the item
522:12 - backround rectangle without any Corner
522:17 - radius let's try all of that
522:21 - and there we go so with that we can see
522:27 - a bit better what item is being selected
522:30 - next up then I first of all want to make
522:32 - sure that we don't see more than four
522:34 - monsters which at the moment isn't
522:36 - really the case because we only have
522:37 - four more monsters and most of them
522:39 - don't have any health I suppose I could
522:42 - add a few more with a high
522:45 - level like so and if I now run all of
522:48 - this again when we are selecting the
522:50 - monsters we can see too much so this
522:53 - isn't great
522:55 - to fix that we want to have another if
522:58 - statement if BG rectangle do Collide
523:02 - Point item BG rectangle Dot
523:08 - Center or in other words only if the
523:10 - center of the BG rectangle is inside of
523:13 - the main rectangle do we want to draw
523:16 - anything with
523:18 - that I can only see the monsters inside
523:21 - of the rectangle so that's working
523:23 - pretty well finally the last thing I
523:26 - want to do in here is I want to display
523:28 - the health rectangle and the energy
523:30 - rectangle for which we're going to need
523:32 - two rectangles Health rectangle
523:36 - and energy
523:38 - rectangle for both of those I want to
523:41 - have a pame do F rectangle for the
523:45 - position of the health rectangle I want
523:47 - to have the text rectangle do bottom
523:51 - left and to that I want to add a vector
523:54 - of0 and
523:56 - four simply to add a bit more
523:59 - padding and then for the size I want to
524:02 - have 100 and
524:04 - four once again numbers that simply look
524:07 - good for the energy
524:10 - rectangle the position is going to be
524:12 - the health rectangle dot bottom
524:17 - left with a vector offset of 0 and two
524:22 - the size of this one is going to be a
524:23 - bit less let's say 8 80
524:26 - and4 finally we can call draw uncore bar
524:30 - again which I don't think we have at the
524:32 - moment which means I want from support
524:36 - import draw
524:38 - bar and this class is already getting
524:41 - quite massive but anyway for a draw bar
524:45 - we are going to need a whole bunch of
524:46 - arguments so let me do both at the same
524:49 - time we want to draw on self. display
524:53 - surface the rectangle is going to be
524:55 - either the health rectangle or the
524:58 - energy rectangle the two rectangles we
525:02 - have just created for the value we will
525:04 - need monster. health and monster do
525:10 - energy then we will need the max value
525:13 - which is going to be monster. getet stat
525:16 - with the maxcore health for energy we
525:21 - want to get the same thing except it
525:24 - should be Max
525:26 - Energy and then we need to color for the
525:28 - value which is going to be
525:30 - colors with something that we will cover
525:33 - in a second and then the background
525:35 - color for both of those is going to be
525:39 - black now for the health bar rectangle I
525:41 - want to have a red color and for the
525:43 - energy one I want to have a blue color
525:46 - that should be it if I now run main.
525:51 - pi and I select switch we are getting
525:54 - all of the monsters along with the
525:56 - health and their energy so that is
525:59 - looking pretty good quite happy with
526:01 - that we are nearly done the last thing
526:04 - that I want to cover is going to be
526:06 - inside of
526:09 - input the issue that I want to fix is if
526:11 - the player is inside of the attack mode
526:13 - or the switch mode and then wants to go
526:16 - back then well there's no way of doing
526:19 - that to fix that we want to add one more
526:22 - input statement which is to be on this
526:24 - same indentation level as the space key
526:28 - I want to check if keys and py game.
526:32 - kcore escape and in there I want to
526:36 - check if self. selection mode is
526:40 - in a
526:42 - text
526:43 - switch or Target this one we haven't
526:47 - seen yet but it's basically for
526:49 - targeting an opponent or one of your own
526:51 - monsters for healing if this if
526:54 - statement triggers
526:55 - then we want to set self. selection mode
526:58 - back to
527:01 - General so with that I can run the
527:03 - entire thing I can click on attack we
527:06 - still got the same options but if I
527:08 - press Escape we go back to the selection
527:10 - menu and then we can select other things
527:13 - like defend and this still works really
527:15 - well cool with that we are done with
527:17 - this part and for the next bit we can
527:19 - start implementing actual functionality
527:22 - in this section we are going to finish
527:24 - up the the outlines of the battle system
527:26 - I.E we are actually able to attack the
527:29 - opponents the opponents can also attack
527:31 - us we can switch monsters we can catch
527:34 - an opponent monster we can defend and
527:36 - all the basic parts of the battle system
527:39 - so by the end of this part we basically
527:41 - have a game to get started I want to
527:43 - keep on working inside of battle
527:46 - specifically inside of the input
527:49 - method at the moment we can go from the
527:53 - general selection to the attack mode but
527:56 - then inside of attack we can't really do
527:59 - anything which means I want to add
528:01 - another if statement and this one has to
528:03 - come before this if statement for the
528:06 - general mode I'll explain in a second
528:08 - why in there I want to check if self.
528:11 - selection mode is equal to a Tex if that
528:16 - is the case there are three things that
528:18 - we want to do we want to set this
528:21 - selection mode and this we can do right
528:22 - away in code self. selection mode should
528:25 - now be Target I.E we are targeting
528:29 - either an opponent or one of our own
528:31 - monsters besides that we want to have a
528:34 - self.
528:37 - selected this one doesn't exist yet and
528:39 - we want to have self dot
528:43 - selection site this one we have created
528:46 - earlier inside of thunder in it
528:48 - selection site by default this one is
528:50 - player and just to add the one
528:53 - additional attribute self do selected
528:56 - attack by default this one is
528:59 - none so we don't need thunder in it and
529:03 - then we have to figure out the selected
529:05 - attack and the selected side to get this
529:07 - selected attack we want to get self.
529:11 - current monster monster get
529:14 - abilities and for this one we only want
529:17 - to have the available ones I.E all
529:20 - should be
529:21 - false this is going to give us the same
529:24 - list for the tag moves that we have seen
529:26 - in the menu which means if we are using
529:29 - indexing with self. indexes and a
529:35 - tack then we are going to get the same
529:38 - attack let me comment out selection s
529:41 - and simply print self. selected attack
529:46 - if I now run main.
529:49 - Pi the game doesn't crash that's a good
529:51 - start and if I now press space we get
529:53 - scratch and then things disappear and we
529:56 - are getting a limit problem because now
529:59 - we have switched to the selection mode
530:02 - Target let's comment this one out for
530:04 - now actually and run all of this
530:07 - again now I can select different attack
530:09 - moves and they line up with what we are
530:12 - seeing in the menu so this part is
530:14 - working quite well let's try another
530:17 - monster we get scratch fire battlecry
530:21 - and
530:21 - explosion so that is working well
530:25 - with that we can get the selection mode
530:27 - for Target again remove the print
530:30 - statement and then I want to select a
530:33 - selection site I.E are we targeting the
530:37 - opponents or our own monsters that we
530:39 - can get via attack data and then self.
530:44 - selected attack if you look at attack
530:47 - data there we have a Target which can
530:50 - either be opponent or the player and
530:53 - well the only two attacks that we have
530:55 - that Target the player a heal and
530:57 - battlecry everything else targets the
530:59 - opponent either way we want to get the
531:04 - Target and if that selection mode is
531:06 - selected then we don't want to have a UI
531:09 - element we simply want to pick one of
531:10 - the opponent monsters but first of all
531:13 - for that we will need another case for a
531:16 - new limiter the case I want to Target is
531:20 - called well
531:21 - Target and then we need to create a
531:24 - limiter which should be the length of
531:27 - self. opponent Sprites but only if self.
531:31 - selection not mode but side is equal to
531:37 - opponent if that is not the case else we
531:40 - want to get the length of self. player
531:44 - Sprites or in other words we want to
531:46 - know how many opponent monsters there
531:47 - are or how many player monsters there
531:49 - are that is all we need in here there's
531:52 - just one more thing that I do want to
531:53 - cover and that is that we will need this
531:57 - selection mode for attacks before the
531:59 - selection mode for General let's go
532:01 - through this thing step by step first of
532:03 - all we are pressing space while having
532:06 - some kind of index by this index inside
532:10 - of selection mode we know what option we
532:13 - want to pick for example if the index is
532:15 - zero we want to go to attack and let's
532:18 - stick with that case so at the moment
532:21 - once we get to this point we are
532:24 - continuing the code and nothing is going
532:26 - to happen but on the next for Loop of
532:28 - the game we are getting to the attack
532:31 - mode and none of the selection mode
532:33 - General is being triggered however if
532:37 - that was flipped around if we did all of
532:39 - this first and then this part second we
532:43 - would still check for pame dospace along
532:46 - with an index then we would trigger the
532:49 - attack but then we are going straight to
532:53 - the attacks because those come right
532:55 - after and because of that we would
532:57 - trigger an attack right away and having
533:00 - the right order of the if statements is
533:02 - I think the easiest way to solve that
533:04 - you could also work with L if statements
533:06 - but that could cause some other issues
533:08 - down the line anyway for now we want to
533:11 - Target some opponent
533:13 - monsters we don't have to worry about
533:15 - attacks anymore and general we also
533:18 - don't need next up I want to have if
533:21 - self. selection mode is is equal to
533:27 - Target for that first of all we want to
533:30 - know what spreite group we are targeting
533:32 - IE Sprite group should be a local
533:35 - variable that we're going to get from
533:37 - self. opponent
533:39 - Sprites if self.
533:43 - selection site is equal to the opponent
533:48 - if that is not the case else we want to
533:50 - have self.
533:52 - layer rights so now we have a couple of
533:55 - Sprites that we are looking at but then
533:58 - we have to be careful so imagine we have
534:01 - three opponent monsters one two and
534:05 - three and we want to select them via
534:07 - their index so this would be index 0 1
534:10 - and two at this point you might be
534:13 - tempted to take this Sprite group turn
534:15 - it into a list and then use indexing so
534:18 - if our Target index is zero we get this
534:21 - one if the target index is one we get
534:23 - this one and so on
534:25 - that would not be a good approach simply
534:27 - because later on it is totally possible
534:30 - to defeat one of the monsters so this
534:33 - one wouldn't exist anymore and if we
534:35 - then had an index one we would get
534:38 - really confused so essentially we have
534:41 - to take this Sprite group and then
534:43 - create a custom list from that that has
534:46 - to be dynamic I call this one the
534:49 - Sprites and that is going to be a
534:51 - dictionary where we get Sprite and then
534:54 - the position underscore
534:57 - index as a key and the associated value
535:00 - is the Sprite itself for sprite in
535:04 - Sprite group the thing we have just
535:07 - created after that we can get an actual
535:10 - monster uncore Sprite Which we can get
535:14 - via the Sprites and indexing I want to
535:18 - have the list of Sprites do keys and on
535:23 - that use index in by yourself do
535:26 - indexes along with the Target and just
535:30 - to make sure this is working let me
535:32 - print it and then I will explain it in a
535:34 - bit more detail but let's try main. Pi
535:38 - if I have a monster ready I can attack
535:40 - and if I press space we get a monster
535:42 - another monster and another monster
535:44 - Sprite although we can't really see the
535:47 - difference I suppose what we should
535:49 - rather print is Monster Sprite do
535:52 - monster that's going to make much more
535:54 - sense if I now attack we get monster
535:57 - monster and monster along with the right
536:00 - name so that is looking pretty good that
536:03 - backs the question what happened here
536:06 - especially the last line I think is
536:08 - going to be confusing let's do a few
536:10 - examples the most important thing to
536:12 - understand is this Sprites which is
536:14 - going to be a dictionary where we have
536:17 - the position index and then the monster
536:19 - Sprite for example we could have a
536:21 - dictionary with 0 1 and two for the
536:24 - indexes and then each of those have a
536:27 - monster attached that is essentially
536:30 - what we have at the moment in our game
536:32 - the keys of this dictionary we are then
536:34 - going to turn into a list which means we
536:37 - have a list with zero one and two after
536:40 - that we're going to pick one of those
536:42 - keys via indexes from our Target index
536:46 - let's imagine our Target index is one
536:49 - that way we would get a one if our
536:52 - Target index was two we would get get a
536:54 - two so that way we're not really
536:56 - changing the number however let's do
536:59 - another example where this dictionary is
537:02 - going to have only two values we have
537:05 - one at index zero with a monster and
537:07 - then one at index two with a monster we
537:10 - only have a monster on top and a monster
537:12 - on the bottom the middle monster has
537:14 - been defeated after that once again we
537:17 - are turning the keys into a list so now
537:19 - we have a list with zero and two and now
537:22 - imagine that our index is one I.E we
537:26 - want to pick the second monster via this
537:28 - system this one is now becoming a two
537:32 - while an index of zero for the selection
537:34 - would still be a zero that way we always
537:37 - pick the right monster even if there are
537:39 - gaps among the opponent monsters or
537:41 - amongst the player monsters could also
537:43 - be a case anyway with that we don't need
537:46 - the print statement anymore and next up
537:49 - we have to actually highlight the
537:51 - targeted monster for that part we don't
537:54 - need input anymore and we want to work
537:57 - inside of battles Sprites do raw with
538:00 - the current monster so essentially the
538:02 - monster that we are currently targeting
538:04 - should have a white outline like we have
538:07 - done for the currently active
538:11 - monster to make that work we will first
538:13 - of all need a whole bunch more arguments
538:16 - and let's create the parameters first of
538:19 - all inside of the draw method besides
538:21 - the current monster Sprite I want to
538:24 - have the site I want to have the mode
538:27 - then I want to have a Target uncore
538:30 - index and finally I want to have the
538:33 - player uncore Sprites along with the
538:37 - opponent Sprites after that let me copy
538:40 - all of the parameters and then paste
538:42 - them after self. current monster the
538:46 - side that we are working on we're
538:47 - getting from self.
538:49 - selection site the mode is going to be
538:52 - self. SEL section mode Target index will
538:57 - be self. indexes along with the target
539:02 - after that we will need self. player
539:04 - Sprites and self. opponent Sprites quite
539:08 - a bit of data but that is what we need
539:10 - to highlight the currently targeted
539:12 - monster first of all though we have to
539:15 - do some setup like we have done before I
539:17 - want to get the available positions I
539:21 - want to get this Sprite uncore G Group
539:25 - which is going to be the opponent
539:26 - Sprites if side is equal to
539:32 - opponent and else layer Sprites with
539:37 - that we know what Sprites to Target and
539:40 - then like before we want to create a
539:44 - dictionary with Sprite
539:47 - Doos index and the Sprite for sprite in
539:52 - Sprite group and and finally I want to
539:55 - get the actual monster Sprite that is
539:58 - currently
539:59 - targeted Sprites stand indexing with the
540:03 - list of Sprites do
540:07 - ke along with the target index cool and
540:13 - with that we have a monster Sprite that
540:16 - means inside of this if condition we
540:19 - want to add a second line via
540:22 - or I want to check if the Sprite do
540:28 - monster Sprite and once again as a
540:31 - reminder the Sprite that we are working
540:33 - with here is the monster outline Sprite
540:36 - Which has one attribute that stores the
540:38 - monster Sprite itself which is what we
540:41 - actually care about if this is equal to
540:43 - the monster Sprite that we have gotten
540:46 - up here then we want to create an
540:49 - outline as well let's try that part if I
540:53 - now run all of this
540:54 - and I can select a monster we get an
540:58 - outline for the targeted monster so that
541:01 - is working really
541:03 - well quite happy with that so we are
541:06 - making progress also if I now press
541:09 - Escape we getting back to the attack
541:11 - options let's use the shield because I
541:13 - think this monster has battlecry this
541:16 - one should only target our own monsters
541:19 - that is also working well although for
541:21 - this part I want to disable build the
541:24 - monster highlight for the currently
541:25 - selected
541:26 - monster because without that the
541:28 - selection here looks a bit
541:30 - weird for that inside of groups when we
541:34 - have the first condition we want to
541:36 - disable this part if the player is
541:38 - selecting the player monsters which we
541:41 - can do via an end
541:44 - not I want to check if the mode is equal
541:48 - to Target and
541:51 - site is equal to the
541:54 - player or in other words we only want to
541:57 - highlight the current
541:58 - monster if we are not in Target mode and
542:02 - deci side is the player let's try that
542:06 - part and now we want to get to Chad
542:10 - Dillo and use battlecry and that is
542:14 - working really well now if I press space
542:17 - nothing is going to happen but we have a
542:19 - nice selection system which means next
542:22 - up inside of battle. Pi we want to work
542:26 - in the input method and let me hide all
542:30 - of the if statements that we don't need
542:34 - to make this a bit less confusing we
542:36 - still want to work inside of Target at
542:39 - the moment we are only getting the
542:40 - current monster Sprite that we have to
542:43 - use the player's pressing space and we
542:46 - are in the Target mode after that we
542:48 - getting a monster Sprite to Target and
542:51 - then we want to check if self do
542:54 - selected attack if that is the case we
542:57 - want to attack a monster because
543:00 - remember inside of selection mode attack
543:03 - we have gotten a selected attack later
543:05 - on we can also catch a monster then we
543:08 - have an else statement that for now is
543:11 - going to be pass we have selected a
543:14 - monster Sprite and we have an attack
543:16 - that means we want to attack that
543:18 - monster that unfortunately we cannot do
543:21 - immediately instead I want to get self
543:23 - current
543:24 - monster.
543:26 - activate uncore attack or in other words
543:30 - what we are going to do once we get to
543:33 - this part we want the monster to play an
543:36 - attack animation once that animation is
543:39 - over we actually trigger the attack
543:42 - which means we have to work inside of
543:43 - the monster and give it two arguments we
543:46 - want to have the monster Sprite or in
543:48 - other words the Target and then we want
543:50 - to have self. selected attack
543:54 - I.E the attack that the monster is
543:56 - supposed to execute after that
543:59 - self.
544:00 - selected attack self. current monster
544:05 - and self. selection mode should all be
544:09 - none that way we can continue to the
544:12 - next Monster so inside of the monster
544:15 - Sprite we will need a method called
544:17 - activate attack when Sprites monster
544:20 - Sprite we want to have let's do it right
544:23 - above update Define activate attack with
544:28 - self a Target
544:30 - Sprite and the attack and also let me
544:34 - minimize all the other methods so it's
544:36 - easier to see what's going on if that is
544:39 - the case I want to set self. state of
544:42 - the monster to ATT attack on top of that
544:46 - we want to set the frame index to zero
544:50 - that way we ensure we are always playing
544:52 - the attack animation from the beginning
544:54 - also we want to set self. Target undor
544:59 - Sprite to the Target Sprite that way we
545:03 - can reuse it later on and self. current
545:07 - uncore attack is going to be the attack
545:11 - both of these values we have to reuse in
545:14 - just a bit hence we want to store them
545:16 - inside of an attribute and for that to
545:18 - work properly I want to create them as
545:20 - well inside of the dunder init method
545:23 - which means in there I want to have
545:25 - self. Target Sprite none by default and
545:28 - self. current attack which is also none
545:31 - by default that covers this part and the
545:35 - last thing that I want to do is I want
545:38 - self dot monster.
545:41 - reduce
545:43 - energy depending on what attack we are
545:46 - using I.E once the monster has attacked
545:49 - we want to reduce the energy and that
545:51 - happens inside of the monster remember
545:54 - in here we are storing the actual
545:56 - information and for that we will need
545:59 - another
546:00 - method Define reduce underscore
546:04 - energy with an a attack and also we will
546:09 - need self the only thing that we have to
546:11 - do in here is self do energy minus equal
546:17 - the attack data e
546:20 - attack and then the cost of that attack
546:24 - which has to be a string or in other
546:26 - words inside of game data for the attack
546:28 - data we are subtracting this cost from
546:30 - the energy of the monster and that was
546:33 - quite a bit of code let's try
546:36 - main.py I can still select an attack and
546:40 - I can select opponents if I now Target
546:43 - one of them the energy of the monster
546:45 - should decrease once I execute that and
546:48 - it does we now have a bit less energy
546:51 - and the monster is playing an attack
546:53 - animation
546:54 - so that is working but now the game
546:56 - doesn't do anything
546:58 - anymore small steps I suppose we
547:01 - continue we have to work a bit more
547:03 - inside of the monster Sprite and we have
547:06 - to expand the animate method basically
547:09 - what we have to do if the monster is
547:12 - animating we want to apply the attack
547:14 - after an attack
547:16 - animation which means after we are
547:19 - increasing the frame index I want to
547:22 - check if if self.
547:25 - state is equal to a tag on top of that
547:30 - and self
547:32 - frame index is greater or equal to the
547:36 - length of self.
547:39 - frames and a attack so basically with
547:43 - this if statement we are checking if the
547:44 - monster is playing the attack animation
547:46 - and the animation has finished if that
547:48 - is the case we want to actually apply
547:51 - the attack which we cannot do at the
547:54 - moment but what we can do is set this
547:56 - state back to idle that way we are only
548:01 - playing the attack animation once let's
548:03 - try that part if I now attack a monster
548:07 - with a different attack we get an attack
548:09 - animation exactly once so that part is
548:12 - working so how can we actually apply the
548:16 - attack for that part we have a bit of an
548:18 - issue because we want to apply the
548:20 - attack inside of the battle class and
548:23 - there we have follow of the monsters now
548:24 - I guess inside of Sprites we would have
548:26 - the target Sprite that we are getting
548:28 - from activate attack we would have a
548:31 - Target but we also want to have the
548:33 - animations inside of battle really we
548:36 - should have the actual attack logic in
548:38 - there it also makes a whole bunch more
548:39 - sense for that I want to create another
548:44 - method Define apply underscore attack
548:49 - for which we want to have self a Target
548:53 - bright the attack that we want to choose
548:56 - along with the amount of damage for now
548:58 - let's simply print the target Sprite the
549:03 - attack and the amount of damage now this
549:06 - apply attack we have to get into the
549:09 - monster Sprite Which we're going to do
549:12 - when we are creating the monster there
549:15 - we have a monster Sprite Which is going
549:19 - to get one more argument which is apply
549:22 - attack for that to work inside of this
549:25 - class we will need apply a attack as
549:29 - well that we then want to store as an
549:32 - attribute self. apply attack is apply
549:36 - attack that way once the attack
549:38 - animation is finished we can call self.
549:41 - apply
549:42 - attack with the parameters we have just
549:45 - created Target Sprite attack and
549:49 - amount Target Sprite is going to be
549:51 - self. Target Sprite the attack will be
549:55 - self. current attack and then we need an
549:58 - amount for that we have to look at the
550:00 - monster because in there we have the
550:02 - attack damage let's call itself. monster
550:05 - get base uncore damage and for this part
550:10 - we want to know what attack we have
550:11 - selected I.E self. current attack as an
550:14 - argument and then inside of the monster
550:17 - class I want to have theine get base
550:20 - damage with self and an attack the value
550:26 - that we want to return is going to be
550:29 - self. get stat and attack I.E we're
550:35 - getting the attack damage and this we
550:37 - want to multiply with attack data of the
550:42 - attack and then we want to get the
550:45 - amount of damage or healing it does I.E
550:48 - if you look at game data we have the
550:51 - amount
550:53 - this we're going to multiply with the
550:54 - base damage of the monster or in other
550:57 - words self do gets that and attack is
550:59 - what we're getting from up here where we
551:03 - are getting the base set of the monster
551:04 - and multiplying it with the level this
551:07 - we are then going to multiply with the
551:08 - damage of the attack and then inside of
551:11 - Sprites we are applying that amount
551:15 - which means inside of battle we should
551:18 - get a value let's try and we are getting
551:22 - an error that name apply attack is not
551:25 - defined and that happens when we are
551:29 - creating a monster this should be self.
551:32 - apply attack when we are creating the
551:34 - monster Sprite next
551:38 - attempt and now if I choose scratch we
551:41 - get one attack animation and then we are
551:44 - printing the target Sprite the attack
551:47 - and the amount of damage cost or at
551:49 - least the base damage this doesn't
551:51 - include defense or elements
551:54 - yet but at the very least we have
551:56 - something so now we don't need setup or
551:59 - create monster and we can work inside of
552:02 - a Ply attack to cover what we want to do
552:05 - number one we want to play an animation
552:09 - for the attack then we want to get the
552:13 - correct attack damage amount or in other
552:18 - words we want to include the defense of
552:20 - the monster and the element type
552:23 - for example if a fire attack hits a
552:26 - plant then we should double the damage
552:28 - and if a fire attack hits a water
552:30 - monster then we should have the damage
552:33 - next up we want to update the Monster
552:36 - Health and then we want to resume the
552:39 - game and I guess we can go through this
552:41 - step by step number one we want to play
552:44 - an animation for that I want to create
552:47 - an another a Sprite called attack Sprite
552:50 - this we have to create inside of the
552:51 - Sprites I want to have class attack
552:55 - Sprite for parent class this one is
552:58 - going to get the animated Sprite the one
553:02 - we created ages ago this one here
553:05 - because ultimately all that this attack
553:07 - Sprite is going to be is it will plays
553:10 - an
553:11 - animation but this animation it's only
553:13 - going to play once and then disappear or
553:15 - to visualize all of this a bit better if
553:18 - you look at the graphics folder there we
553:20 - have the attacks which contains a couple
553:23 - of animations those we want to play once
553:26 - after the monster has attacked we also
553:28 - need to import them but that's going to
553:30 - come later first of all Define a knit
553:33 - with self a position frames and
553:37 - groups then Super Thunder init where we
553:42 - are initializing the animated Sprite
553:45 - which means we want to have position
553:47 - frames and groups after that we are also
553:50 - going to need a z layer that we are this
553:53 - time getting from the battle layers and
553:57 - on there we want to get the overlay also
554:01 - when we are creating this animated
554:02 - Sprite we are setting the rectangle
554:05 - position to the top
554:07 - left which I don't want to do anymore
554:10 - instead I want to update self. wct and
554:15 - place the center to the position that
554:18 - way we can place the attack right in the
554:20 - middle of the Target Monster after that
554:23 - we need an animate method with self and
554:25 - Delta
554:26 - time in the original Sprite we are
554:29 - simply playing the animation forever
554:31 - which works in the Overworld but for
554:33 - this monster we want to play the
554:35 - animation once and then destroy the
554:37 - Sprite for that we want to get the frame
554:41 - index and increase it by the animation
554:45 - speed multiplied with dat time after
554:48 - that if self. frame index is is smaller
554:54 - than the length of self.
554:58 - frames if that is the case we want to
555:00 - update self. image which is going to be
555:03 - self.
555:05 - frames with the integer of self. frame
555:10 - index no need for modulus because we are
555:13 - already checking if we are inside of the
555:15 - length of the list if that is not the
555:18 - case else we simply want to destroy the
555:20 - Sprite using the kill method and finally
555:24 - we have to call update with self and
555:26 - Delta time and then call animate in
555:29 - there with Delta time and do not forget
555:32 - self that way we have an attack Sprite
555:35 - it's fundamentally a fairly simple class
555:38 - after that inside of battle dop we have
555:41 - to import it so import attack Sprite
555:46 - Which means to apply the attack Sprite I
555:49 - want to get the target Sprite wrecked do
555:53 - center for the position after that we
555:57 - will need the attack frames which we
555:59 - don't have at the moment but we're going
556:02 - to get them in a bit self Doge monster
556:04 - frames they're going to be in that
556:06 - dictionary and there we have the attacks
556:10 - or in other words in just a bit when we
556:12 - are importing the assets inside of the
556:15 - monster frames we're going to add one
556:17 - more key value pair to pick one
556:20 - animation from that we want to get the
556:22 - attack data along with the current
556:26 - attack and then from this entry we get
556:29 - an animation or in other words if you
556:32 - look at the attack data at the end we
556:34 - have an animation finally we going to
556:37 - need the groups all the way at the end
556:39 - self. battle
556:41 - Sprites so that's going to cover the
556:44 - attack Sprite the one thing that we
556:46 - don't have yet are the frames for the
556:48 - attack for that we want to look at
556:51 - main.py and add
556:54 - an attacks key along with a value and
556:58 - for this one I want to create an attack
557:01 - importer for the file path we want to go
557:04 - up a folder then to graphics and then we
557:08 - have the
557:11 - X so next up we have to create one more
557:15 - import method which is going to be
557:19 - Define a
557:21 - techcore importer
557:23 - for which we are only going to need a
557:25 - path then we are going to create a new
557:28 - dictionary for all of the frames that is
557:30 - empty by default after that for folder
557:34 - path the subfolders we don't care about
557:37 - and the image names in walk join and the
557:43 - path
557:44 - unpacked after that for image in image
557:49 - names and then we get all of the image
557:51 - names inside of this folder first of all
557:55 - in there I want to get the image name
557:58 - which is going to be image. split
558:01 - wherever we have a DOT and then we want
558:04 - to pick the first item that way we get
558:07 - rid of PNG at the end and then we can
558:10 - get the attack dictionary and assign a
558:14 - new key value pair the key is going to
558:16 - be the image name the actual value we
558:20 - are going to get from import tile map
558:24 - because once again if I open this thing
558:26 - we have tile Maps each animation is four
558:29 - frames that we want to isolate which
558:32 - means for import tile map we have four
558:34 - columns one row and the path to this
558:37 - folder is going to be the folder path
558:40 - along with the image name this would
558:43 - return another dictionary with key value
558:45 - pairs where the key would be the column
558:47 - and the row and the value would be the
558:49 - actual surface and in this case we are
558:52 - lucky because because we don't care
558:53 - about the keys at all we only want to
558:55 - get the values and all of that we want
558:58 - to turn into a list that is simply
559:02 - because when you look at all of the
559:04 - animations they always in one row hence
559:08 - the position doesn't actually
559:10 - matter and finally I can return the
559:14 - attack
559:15 - dictionary and that should be it if I
559:18 - now run main. pi and I attack a monster
559:22 - we get an attack animation and that is
559:24 - looking really good that took a while
559:27 - but we got there in the end so with that
559:30 - we can play an attack animation and I
559:32 - suppose we should try this a second time
559:35 - with anothera
559:37 - monster let's try this one and let's go
559:40 - with explosion and that's also working
559:43 - pretty
559:44 - well finally one more attempt is going
559:47 - to be not this monster but the second
559:50 - one because in there we have Battle Cry
559:53 - and let's try to heal this monster and
559:55 - that is working also notice for this one
559:58 - we getting a negative amount that means
560:01 - later on we are going to heal so next up
560:05 - we want to get the correct attack damage
560:09 - for that first of all we will need the
560:12 - attack element which we can get from
560:15 - Attack data the attack and then the
560:20 - element
560:23 - for the Target element we want to get
560:27 - the target Sprite in there we have the
560:30 - monster and the monster has the element
560:33 - after that I want to double the attack
560:37 - if the attack element for example is
560:42 - fire and the target element is equal to
560:47 - B that would be one condition if that is
560:50 - the case we want to get the amount and
560:52 - multiply it by two or in other words the
560:55 - damage we're getting from the monster is
560:57 - now twice as
560:59 - strong and well for this part we have to
561:02 - cover the other conditions as well there
561:05 - are only three in
561:06 - total we want to check if attack element
561:10 - is fire and the target element is plant
561:13 - if the attack element is water and the
561:16 - target element is fire and
561:21 - finally if the the attack element is
561:24 - plant and the target element is water if
561:28 - any of these conditions are met then we
561:30 - are doubling the attack damage and the
561:32 - opposite we can do
561:34 - half attack for that let me simply copy
561:38 - the if
561:40 - statements in which we want to multiply
561:42 - the attack damage with 0.5 so for
561:45 - example if the attack element is fire
561:47 - and the taret element is water then the
561:50 - attack is going to be weaker
561:53 - this could also apply if the attack
561:55 - element is water and the target element
561:57 - is plant or if the attack element is
562:00 - planned and the target is fire so with
562:03 - that we are incorporating all of the
562:06 - elements and this system is only going
562:08 - to work if you have very few elements if
562:10 - you have more than that it's going to
562:12 - cause issues but I think for our
562:14 - purposes this is still totally fine
562:17 - although we do not include the defense
562:19 - of the monster or in other words if you
562:21 - look at the game die
562:23 - and monster data all of the monsters
562:25 - have a defense stat this we also have to
562:28 - include the way I Incorporated that one
562:31 - is I have created a
562:34 - Target uncore
562:37 - defense which I want to be a value
562:40 - between zero and one the higher the
562:43 - defense of the monster is the lower of a
562:45 - multiplier we want to have first of all
562:48 - I'm getting the target Sprite do monster
562:51 - doget
562:53 - underscore stat and I want to look at
562:56 - the defense of the monster just to
562:58 - demonstrate what we are getting let me
563:00 - print the target defense if I now run
563:04 - all of this we are getting an unexpected
563:07 - character I think it just doesn't like
563:09 - this slashy speaking of which The Ore
563:12 - shouldn't be there
563:14 - either next attempt main P the game
563:17 - doesn't crash anymore good start and now
563:20 - if I Target a monster we get getting
563:22 - name element not defined things are
563:25 - going great that happens because the
563:27 - element here should be a string next
563:31 - attempt if I now attack
563:33 - again we are getting something these
563:37 - numbers we are getting from these four
563:40 - print statements where the first one is
563:43 - the target defense for this monster it's
563:46 - 20 or in other words the monster we have
563:50 - is going to be this one at Rox at level
563:54 - two and inside of game data if you find
563:57 - at Rox we have a defense of 10 and this
564:01 - we multiply it by two that way we are
564:03 - getting 20 now this 20 I want to turn
564:07 - into a fraction something like 0.8 or
564:11 - 0.9 that if the monster has a very low
564:14 - defense value we want to get 90
564:16 - something per of the attack damage for
564:18 - that I want to subtract the value from
564:22 - one
564:23 - that way we would get -19 at the
564:26 - moment to fix that I want to divide this
564:30 - value by 2,000 that way this 20 is going
564:33 - to become a really small number and that
564:36 - we are then subtracting from the one
564:39 - let's try this again and if I attack the
564:41 - monster with the same attack we're
564:44 - getting
564:45 - 0.99 since this monster is super weak
564:49 - the defense shouldn't really matter that
564:50 - much however if if we increase the level
564:53 - of the monster to let's say
564:56 - 15 and run all of this again if I now
565:00 - attack the monster this is
565:04 - 0.925 which I think is pretty good now
565:07 - this 2,000 here you can play around with
565:09 - depending on how strong you want the
565:11 - defense to be but that you can do in
565:13 - your own time in my case I want to get
565:16 - the target defense again because we have
565:18 - to make sure that this number doesn't
565:20 - become negative if that was the case and
565:22 - attack would heal the monster which well
565:25 - would be weird for that I want to use
565:27 - max with zero along with Min just to be
565:31 - sure that we stay between one and the
565:35 - target defense with that we have the
565:39 - proper Target defense amount finally
565:42 - with that we can update the
565:46 - target sprite. monster. Health minus
565:51 - equal the amount multiplied with the
565:55 - target
565:56 - defense that should actually be visible
565:59 - in the game if I now run out of this and
566:01 - I attack this monster the only one with
566:03 - health we are reducing the amount of
566:06 - health and now that we have that inside
566:09 - of the monster we don't need the random
566:13 - amount for health and energy
566:15 - anymore if I now run main Pi again we
566:18 - have the full amount for everything and
566:21 - if I attack this monster we are reducing
566:23 - the amount of health so that is working
566:25 - really
566:26 - well although after that nothing is
566:29 - going to happen and we also don't need a
566:31 - print statement
566:33 - anymore instead what we want is to
566:35 - resume the game which we do with self
566:37 - update all monsters and
566:40 - resume so next
566:42 - attempt and I can still attack and after
566:47 - that the game continues so let's try a
566:50 - different monster this one on and it's a
566:53 - low level so it takes a lot of damage
566:56 - but the game itself is working really
566:58 - well I suppose what we should be doing
567:02 - after we are applying the damage I also
567:04 - want to self. check uncore death that's
567:09 - going to be another method and we don't
567:11 - need apply attack
567:13 - anymore but below that we will need
567:15 - Define check death no need for custom
567:20 - parameters and there we want to look at
567:23 - all of the Sprites for Monster Sprite in
567:26 - self. opponent Sprites do Sprites plus
567:31 - self. layer Sprites do Sprites we know a
567:35 - monster is that if Monster sprite.
567:38 - monster. Health is below zero after that
567:43 - we want to separate the opponent
567:45 - monsters from the player monsters which
567:48 - we can check if self. player Sprites in
567:52 - monsters Sprites dog
567:54 - groups once again player Sprites is the
567:57 - Sprite for all of the player monsters if
568:00 - that is in any of the groups of the
568:02 - currently selected monster Sprite then
568:04 - we know we are on the player side let me
568:06 - at a comment player now this case we
568:09 - want to ignore for now so let me add a
568:12 - pass in here what we care about are the
568:14 - opponent monsters which are going to
568:16 - live inside of the El's statement but
568:19 - now what we can do is simply monster
568:21 - Sprite do kill although that is not
568:25 - going to work perfectly yet but let's
568:27 - try if I attack this monster and attack
568:30 - it a second time okay needs a third
568:34 - attempt there we go now it disappears
568:37 - but well there's lots of stuff missing
568:39 - let's go through it one by one when we
568:42 - are checking death we already know if
568:45 - the monster is below zero in terms of
568:47 - health so we know if the monster is
568:49 - supposed to be dead or not and if that
568:51 - is the case we want to create a new
568:54 - monster that way once we are killing a
568:56 - monster we are replacing it but only if
568:59 - there's a monster so for example for the
569:01 - dummy monsters we can only see these
569:03 - three monsters so if one is selected we
569:06 - should select the next available one but
569:08 - that we can cover later also later on I
569:12 - want to implement an XP mechanic but
569:14 - that we can ignore for now and there's
569:16 - another issue and that is when you look
569:18 - at Sprites once monster Sprite has been
569:21 - defeated we can still see monster name
569:23 - Sprite monster level Sprite and monster
569:26 - stat Sprite Which obviously is not what
569:28 - we want to fix that let's start with
569:31 - monster named Sprite this one is going
569:33 - to need an update method with self and
569:37 - Delta time we can ignore so
569:40 - underscore we basically want to check if
569:42 - this monster Sprite has been killed or
569:44 - not or rather in terms of monster Sprite
569:47 - we want to know if this monster Sprite
569:49 - is still around now what you have to be
569:52 - aware of when we are calling the kill
569:54 - method on a Sprite we don't actually
569:56 - destroy the Sprite instead what we do is
569:59 - we are removing it from all of the
570:01 - groups that way it doesn't really do
570:03 - anything anymore that behavior we can
570:05 - use because inside of update we want to
570:08 - check if not self. moners sprite. groups
570:14 - sprite. groups is going to give you all
570:16 - of the groups inside of a Sprite if the
570:18 - Sprite isn't any groups this will give
570:20 - you an empty list which would trigger
570:22 - this if statement if that is the case we
570:25 - want to call self. kill the same logic
570:28 - we want to apply to all of the other
570:30 - Sprites as well which means inside of
570:33 - monster level Sprite let's do it all the
570:35 - way at the bottom I want to check for
570:38 - death and then
570:40 - finally inside of the update method of
570:43 - the stat Sprite I also want to check for
570:45 - the same condition there we go and make
570:48 - sure you don't accidentally put this if
570:51 - statement inside of this is for Loop
570:53 - cool with that we have the monster stat
570:55 - Sprite the monster level Sprite and the
570:57 - monster name Sprite now we should also
571:00 - put the same thing inside of monster
571:02 - outline Sprite just so we don't have
571:03 - some random Sprites in the game with
571:06 - that I can now run main.py again and if
571:09 - I attack with the splash attack this
571:12 - monster it's fire it should disappear
571:14 - and there we go now we have gotten rid
571:16 - of the monster entirely also if I now
571:19 - select one of the other monsters
571:22 - we are getting the proper selection
571:24 - behavior that is because of the logic we
571:26 - implemented earlier that part is working
571:30 - pretty good cool so next up I want to
571:33 - check if we have a new monster which I
571:36 - will store in a variable new monster
571:39 - data this is going to be a tupal that
571:42 - has a monster it has an index a position
571:47 - index along with a site or rather an
571:51 - entity
571:52 - so player or
571:54 - opponent although for that to work we
571:57 - need to do a bit of groundwork when
571:59 - you're looking at the dummy monsters we
572:01 - have five monsters in total and three
572:03 - are on the battlefield if one of them
572:06 - dies let's say this one goes away we
572:08 - want to replace it with the first
572:10 - available monster in this case jakana
572:13 - with level two in other words the first
572:16 - thing that we need is to isolate these
572:19 - two monsters or in other words words
572:22 - what I actually did when we are running
572:24 - the setup method we are creating all of
572:27 - the
572:28 - monsters but on top of that I want to
572:31 - remove the opponent monster
572:35 - data since the opponent can't really
572:38 - change monsters once a monster is on
572:40 - field that monster will get deleted from
572:43 - the monster data or in other words I
572:46 - want to look at for I in range length
572:50 - and self do opponent Sprites let me
572:54 - print what we get I if I now run M Pi we
572:58 - getting the indexes 0 one and two using
573:02 - those indexes I want to delete self.
573:05 - monster
573:07 - data with the
573:10 - opponent and then using the
573:13 - index as a
573:16 - consequence after we are setting
573:17 - everything up I want to print self.
573:20 - monster data
573:22 - with the
573:24 - opponent and now inside of main. Pi we
573:28 - are only
573:29 - getting monster three and monster 4 and
573:33 - then if one of the Monsters has been
573:35 - defeated we want to pick the first one
573:38 - and store it inside of monster data in
573:41 - other words I want to get self. monster
573:46 - data with the
573:49 - opponent and from that I only care about
573:52 - the
573:53 - values all of that we want to turn into
573:57 - a list and then pick the first one to
574:03 - get the index and the position index I
574:04 - simply want to get the monster unor
574:07 - Sprite that was defeated and then get
574:10 - their index and position index which we
574:12 - are already storing in there finally The
574:16 - Entity since we know that this El
574:19 - statement is only triggering for the
574:21 - opponents
574:22 - this one is always going to be
574:25 - opponent there's one more thing that we
574:27 - have to do all the way at the end we
574:29 - only want to run this entire
574:32 - line if self. monster data and opponent
574:39 - doeses exist if it does not else we
574:42 - should get none for this value or in
574:45 - other words we only want to get a new
574:47 - monster if there are any values left
574:49 - inside of the Dummy monster dictionary
574:53 - or whatever dictionary we have for the
574:55 - opponent now that we have a new monster
574:57 - we also have to make sure that we
574:59 - getting rid of this monster from the
575:01 - monster data dictionary for that I want
575:03 - to check if self. monster data with the
575:07 - opp
575:08 - opponent and if that is the case I want
575:11 - to delete self. monster
575:16 - data of the opponent and I always want
575:19 - to get rid of the lowest key I.E minimum
575:23 - self Doge monster data and the
575:28 - opponent that way we can get a new
575:31 - monster and remove the previous one so
575:34 - with that we have to create a new
575:36 - monster after we have killed the current
575:38 - one but there's one more thing that I
575:41 - want to do I don't want to kill the
575:42 - monster immediately because it looks a
575:44 - bit weird let me run main. Pi again if
575:48 - we kill a monster let's say this one it
575:51 - is a appears way too fast which doesn't
575:54 - look good so instead of killing the
575:56 - monster right away I want to call
575:59 - monster sprite. delayed uncore Hill and
576:05 - then pass in the new monster data also
576:09 - really important this delayed kill is
576:11 - going to apply to the player and the
576:13 - opponent monster hence it shouldn't be
576:15 - inside of this if statement but it
576:17 - should be inside of this if statement to
576:19 - check if the health is below zero so I
576:22 - have to indent it one more time although
576:24 - the XP comment does need to be inside of
576:27 - the El statement like so now we have to
576:29 - figure out a delayed kill method inside
576:33 - of the monster
576:36 - Sprite I want to minimize all of the
576:39 - methods and then create fine delate kill
576:43 - with self and a new monster there are
576:47 - two things we want to do in here first
576:49 - of all self dot let's call this one the
576:51 - next Monster data which is going to be
576:55 - the new monster after that we want to
576:58 - start a timer that we are getting from
577:01 - Thunder in knit that we already have a
577:03 - remove highlight timer besides that I
577:06 - want to have a kill
577:10 - timer which is going to be a timer with
577:12 - a duration that I have set to
577:15 - 600 the function we want to call once it
577:19 - times out is self do
577:22 - destroy inside of delay kill self.
577:25 - timers with kill and
577:30 - activate on top of that I want to make
577:32 - sure that we don't accidentally call
577:34 - this one multiple times which we can do
577:36 - with if not self do
577:40 - timers the kill timer and active I.E we
577:46 - only want to run out of this if the kill
577:48 - timer currently is not active uh after
577:51 - that Define destroy no need for custom
577:56 - parameters all we really want to do in
577:58 - here is to call the kill method and on
578:02 - top of that if self. nextt monster
578:06 - data then we want to self. create a
578:11 - monster which is the method that we have
578:14 - inside of the battle class create
578:17 - monster for this one we're going to need
578:20 - monster index position position index
578:22 - and
578:23 - entity which coincidentally are the same
578:27 - methods that we
578:30 - have inside of the new monster and there
578:32 - we have a monster index position index
578:35 - and the entity which means to create
578:38 - this monster we simply have to unpack
578:40 - self. next Monster data although before
578:44 - that we have to get create monster into
578:47 - the monster Sprite Which we can do via
578:50 - another parameter
578:51 - create monster and don't forget to St it
578:54 - as an attribute self. creat monster is
578:57 - create monster also when you are
579:00 - creating a new
579:02 - monster inside of the monster Sprite we
579:05 - have to add self. create monster that
579:10 - should actually be it if I now run
579:14 - main.py and I kill the second monster it
579:17 - disappears and after a while we're
579:19 - getting a new monster
579:21 - we can defeat that one as well and some
579:25 - point we should run out of enemies oh
579:28 - well we're getting list index out of
579:30 - range but we're getting something now to
579:32 - fix this error we want to look at groups
579:35 - and then work inside of this if
579:38 - statement in which we are checking for
579:40 - the outlines the second part of that if
579:43 - statement this line is causing the issue
579:45 - and to fix it we want to add a bit more
579:49 - sprite. Monster
579:52 - sprite.
579:53 - entity is equal to the site that way we
579:57 - are checking if we are on the player or
579:59 - the opponent side on top of that I want
580:02 - to check if mode exists and if mode is
580:06 - equal to Target that way we have quite a
580:10 - bit more so now let's try to run the
580:13 - game again it doesn't crash and if I get
580:17 - rid of enemies they still disappear
580:23 - and it doesn't seem like we are crashing
580:27 - anymore although now an opponent is
580:29 - active so we can't do anything anymore
580:32 - so that we can work on next now for the
580:35 - monster attacks we want to work inside
580:38 - of the battle class let me collapse
580:39 - everything and then look at check active
580:43 - at the moment we only do something if
580:45 - the player monster is ready however if
580:47 - the opponent monster is ready at the
580:49 - moment we simply stop the game and this
580:51 - we want to extend via an El's statement
580:55 - I want to get self.
580:57 - timers with let's call this one opponent
581:01 - delay and that timer I want to
581:04 - activate if this is the timeline of the
581:08 - battle at some point one of the
581:10 - opponents can attack but that I don't
581:13 - want to happen right away instead I want
581:15 - to highlight this monster for let's say
581:18 - around half a second and only after that
581:21 - I we going to trigger the attack because
581:23 - of that we have a timer that is going to
581:26 - trigger after 600 milliseconds and
581:29 - before that we are highlighting this
581:31 - opponent monster so the player is aware
581:33 - that there is going to be an attack that
581:35 - being said though timer doesn't exist
581:38 - inside of the battle class at the moment
581:40 - or at least I don't think it does no it
581:42 - doesn't let's create it all the way at
581:44 - the top I want to have some timers self.
581:49 - timers it's going to be a dictionary and
581:53 - the timer that we have just created is
581:55 - called opponent delay the associated
581:59 - value will be a timer with a duration of
582:02 - 600 and the function we want to trigger
582:05 - once it times out is self. opponent
582:08 - uncore attack although I think we also
582:11 - have to import from
582:13 - timer the timer
582:16 - class so right at the end of the battle
582:20 - system I want to have
582:22 - Define
582:24 - opponent attack there are three things
582:27 - that we want to do in this method we
582:29 - want to get the ability of the monster
582:32 - then we want to get a random underscore
582:35 - Target and finally we want to get self.
582:39 - current monster and then activate attack
582:43 - with the random Target and the ability
582:47 - and as a reminder activate attack is
582:49 - what we already have inside of of the
582:51 - monster Sprite so somewhere in there we
582:53 - have activate attack that way we are
582:56 - reusing the logic from the player
582:58 - monsters which is quite handy although
583:01 - before we are going to work on that
583:02 - there's one more thing that I do want to
583:04 - do inside of the main section and that
583:07 - is going to be
583:08 - update timers all we are going to do in
583:12 - there is for timer inself do timers do
583:17 - values and then timer. update as a
583:21 - reminder for all of the timers that we
583:23 - have at the moment it's only one but
583:25 - there are going to be more we have to
583:27 - call the update method on every single
583:28 - timer otherwise nothing is going to
583:31 - happen that we can do via a method and
583:34 - that method we have to call inside of
583:36 - the update method let's do it right
583:38 - after the input self. update timers with
583:43 - that we can get the ability and the
583:45 - random Target after that we should have
583:48 - a monster attack from the opponent
583:51 - that part will be your exercise I want
583:53 - you guys to get the opponent monster
583:55 - ability and the target pause the video
583:57 - now and see if you can figure this one
584:03 - out for the ability I want to get self.
584:08 - current monster do monster and then get
584:12 - underscore abilities and from that I
584:15 - want to get a random value which I get
584:18 - via
584:19 - choice that we have to import via from
584:23 - random import
584:27 - choice that would give us the ability
584:30 - and let's simply try for now if this is
584:32 - working at all meaning I want to print
584:35 - the
584:36 - ability and then inside of main.py in
584:39 - the dunder init method the first Monster
584:42 - can get a level of 50 so it gets ready
584:45 - really fast let's
584:47 - try and there we are getting one of the
584:50 - abilities
584:51 - let's try it again we should get a
584:53 - different attack and we do that looks
584:55 - good after that we will need the random
584:58 - Target for this one we do have to be a
585:01 - bit careful because if you look at
585:04 - attack data and let me minimize
585:07 - everything if we get an attack like burn
585:10 - or spark or scratch we now want to
585:13 - Target the player whereas if we have
585:15 - heal or battlecry we want to Target our
585:18 - own team the naming here isn't ideal but
585:21 - I hope you get the idea I want to first
585:23 - of all get the side which we get from
585:27 - Attack data we're using the ability to
585:30 - pick the data and after that we want to
585:33 - get the Target and once we have that we
585:35 - can check if side is equal to layer then
585:40 - we want to get a random Target of our
585:43 - own team meaning random Target will be
585:46 - choice of self. opponent Sprites do
585:51 - Sprites and else we want to get a random
585:54 - Target that will be choice of self.
585:58 - layer Sprites do Sprites that way we're
586:01 - getting a random Target let's print it
586:04 - random
586:06 - Target and run all of this
586:10 - again we are getting a monster Sprite in
586:13 - two Sprites okay that wasn't
586:15 - particularly
586:16 - helpful we could instead print random
586:19 - target. monster that should be
586:22 - better and now we're getting a monster
586:25 - which is friolera level 29 one of our
586:28 - monsters and just to test the other side
586:30 - inside of game data for the monster data
586:34 - when we are looking at
586:36 - atro this one we can change its
586:38 - abilities to only be able to heal that
586:41 - way if I now run m not P again and this
586:44 - thing is running we are getting monster
586:46 - gfin level five so that is also working
586:50 - although this I don't actually want to
586:52 - do with that I can get rid of the print
586:55 - statement and I think five lines for
586:57 - something so simple isn't really
586:59 - necessary so let's reorganize this a bit
587:02 - I want to assign the random Target to
587:04 - the opponent Sprites but only if attack
587:08 - data ability and the target is equal to
587:14 - player if that is not the case
587:17 - else we want to assign a random value
587:20 - from from the player Sprites and if you
587:22 - have a bit more space this is also still
587:24 - readable but well the same logic applies
587:28 - finally we can get self. Corin monster.
587:31 - activate attack with a random Target and
587:33 - an ability let's try
587:36 - that and we're getting attack and
587:39 - something happens and now I can do
587:40 - something as well and things are coming
587:44 - together
587:51 - and with that we getting to the next
587:52 - eror where we don't have a new monster
587:55 - data that happens because when we are
587:58 - checking the death and one of our
588:00 - Monsters has died because when the
588:02 - player monster dies nothing is really
588:04 - specified yet that we do have to work on
588:06 - for that we want to get all of the
588:08 - active
588:10 - monsters which needs to be in a list
588:12 - where we have an index and the monster
588:16 - that we can get via list comprehension I
588:18 - want to get a monster Sprite for monster
588:21 - Sprite in self. player Sprites do
588:26 - Sprites that being said I don't want to
588:28 - get the monster Sprite itself I want to
588:31 - get a tuple with monsters sprite. index
588:34 - and monsters sprite. monster I suppose
588:38 - remember for new monster data we want to
588:41 - get the actual monster and the index and
588:44 - that's what we are getting in here after
588:47 - that we also need to know the available
588:50 - monster
588:51 - ERS which is going to be another list
588:54 - comprehension where we getting a tupal
588:56 - with an index and a monster that we can
588:59 - get quite easily because we can do for
589:02 - index and monster in self. Monster data
589:07 - of the player and from that we want to
589:10 - get all of the
589:13 - items however there are a few conditions
589:16 - that apply here which means if moner
589:21 - do health is greater than zero I.E we
589:24 - don't want to place a dead monster and
589:28 - we want to check if index and monster is
589:32 - not in active
589:35 - monsters or in other words we don't want
589:37 - to pick a monster that's already on the
589:39 - field once we have all of that we can
589:42 - create new monster data for that we can
589:46 - use list comprehension a third time and
589:48 - I want to create a tupo
589:51 - with a monster the
589:54 - index the position index and then the
589:59 - entity I.E the player to get that I want
590:02 - to use for index and monster in
590:06 - available monsters I.E we are looking at
590:10 - all of the available monsters and then
590:11 - we are reorganizing the
590:15 - data monster we can keep index we can
590:17 - also keep although for the position
590:19 - index we want to have have the current
590:22 - monster uncore Sprite and then get the
590:25 - position index from that one now this
590:27 - would give us a list and we only care
590:30 - about the first value I.E index zero
590:34 - however this I only want to do if we
590:36 - have available monsters in the first
590:38 - place I.E if available Monsters has any
590:41 - kind of value then we want to create a
590:44 - new monster data if that is not the case
590:47 - else new monster data is simply going to
590:50 - be none let's try that and if I now Run
590:55 - the game we can get attacked so let me
590:58 - defend and at some point one monster
591:00 - should die and we get another monster
591:02 - that looks pretty good also if I destroy
591:05 - one of the opponent
591:07 - monsters they also get a new one so that
591:09 - is looking pretty good
591:11 - cool with that in place we can work on
591:14 - the XP mechanic meaning if we defeat one
591:17 - of the opponents we're getting some XP
591:21 - for that first of all we have to figure
591:23 - out the XP amount which we can get from
591:27 - the current monster Sprite do monster.
591:30 - level and I simply multiply this with
591:34 - 100 and this value I want to spread
591:36 - equally across all of our player
591:38 - monsters that are currently on the
591:40 - battlefield I.E divide by the length of
591:44 - self. player Sprites and after we have
591:49 - that I can simply do for player Sprite
591:55 - in self. player
591:59 - Sprites layers sprite. monster and then
592:03 - update XP with the XP amount this method
592:08 - does not exist inside of the monster
592:10 - which means in the monster I want to
592:12 - minimize everything and then create a
592:16 - new method Define update XP with self
592:20 - and an amount in the most basic sense
592:24 - all that we want to do in here is self.
592:27 - XP plus equal the amount and I think we
592:32 - already have XP yeah we do so and there
592:34 - at the moment we only have a random
592:36 - value but this one by default should be
592:39 - zero and let's try all of that if I run
592:43 - the game and we defeat one of the
592:46 - opponents all of our monsters get a bit
592:49 - of XP this might be hard to see but if
592:51 - you look at a black bar now we get a
592:53 - very small amount if I defeat another
592:56 - opponent this might be more
592:59 - visible there we go if you look for it
593:01 - you can definitely see
593:05 - it so that part is
593:08 - working and also I want to set the level
593:10 - of at Roos back to something like 10 so
593:13 - the game runs a bit faster after that I
593:16 - want to expand the update XP method to
593:19 - incorporate a level up the way I
593:22 - approach that is I first of all
593:25 - check if self. level up minus self. XP
593:33 - is greater than the
593:35 - amount if that is the case we simply
593:37 - want to add the XP to the amount and
593:39 - nothing else is going to happen we are
593:41 - not going to level up however if that is
593:43 - not the case else then we know via the
593:46 - current XP amount we are going to reach
593:49 - the next level
593:51 - which means self. level plus equal 1 on
593:57 - top of that we have to increase self.
594:00 - level up which is simply going to be
594:02 - self. level multiplied with
594:06 - 150 and finally we want to retain some
594:10 - of the XP self. XP or in other words for
594:13 - a monster to level up let's say we need
594:16 - 200 XP and at the moment the monster is
594:20 - at
594:22 - 150 and then
594:24 - gains 100 additional XP we are going to
594:28 - level up at XP 200 but then we also want
594:33 - to retain the XP that are overshooting
594:36 - which we can get via the amount minus
594:41 - self. LEL up and minus self. XP and that
594:47 - part is going to be a bit difficult to
594:49 - visualize but but let's see how far we
594:51 - get so I want to defeat some
594:54 - opponents and you can see for Lavia at
594:57 - the bottom this should happen fairly
594:59 - soon let's defeat this one and we are
595:02 - nearly at the level up let's defeat this
595:05 - one and there we go Lavia leveled up
595:08 - that's a good start but we don't get any
595:10 - more XP and we get list index out of
595:13 - range so two things that we have to
595:16 - cover number one the XP mechanic for
595:19 - that in side of the monster we have to
595:22 - change XP before we are updating level
595:25 - up that way if I run main. pi and let's
595:30 - kill this
595:32 - one then we can kill this one we are
595:37 - very close to a level
595:40 - up okay bit
595:43 - more I guess we can defeat this one and
595:47 - then and there we go Lavia l up and we
595:51 - retain the extra
595:53 - XP although now if I defeat the other
595:56 - enemy we're getting an error message
595:58 - that we have list index out of range and
596:01 - that happens for two reasons number one
596:04 - inside of the groups we're getting an
596:07 - error because inside of the Sprites the
596:10 - ones that we have created here we have
596:12 - no content or actually there are two
596:15 - possible cases where this could go wrong
596:17 - number one is when there are no more
596:19 - enemy monsters this value is empty so
596:21 - any indexing operation would give us an
596:23 - error that is an issue we can fix right
596:26 - away simply by adding if Sprites and if
596:30 - that is not the case none so in other
596:32 - words we only do all of this if there
596:34 - are any Sprites left
596:36 - whatsoever and that is going to do
596:39 - something but there's still another
596:40 - issue and that is if I only destroy the
596:43 - middle enemy so let me always Target the
596:46 - one in the
596:47 - middle like so at some point Point once
596:50 - we run out of monsters we're going to
596:53 - get an
596:54 - error that is list index out of range in
596:58 - this same line that error happens inside
597:00 - of battle. Pi when we are updating the
597:03 - target index basically the way you have
597:05 - to think about it is that when we have
597:07 - three enemies and we're getting rid of
597:09 - one of them we have to update the index
597:11 - as
597:12 - well otherwise we're getting this eror
597:15 - here where we are trying to get a number
597:17 - too large for the list
597:20 - the way I have approached that inside of
597:23 - input all the way at the bottom after we
597:26 - have gotten the last General I want to
597:28 - set all of the indexes back to zero I.E
597:31 - we are doing let me minimize this we are
597:34 - checking for all of the different inputs
597:36 - and then we are setting self.
597:39 - indexes 2 K and zero 4K inself do
597:48 - indexes so other words we are taking
597:52 - this dictionary we are copying all of
597:55 - the keys and then for the value we
597:57 - always have a zero that way after we
598:00 - have done any kind of input and we go to
598:02 - the next monster we start again from
598:04 - scratch oh also this indexes we only
598:06 - want to trigger when we are pressing
598:08 - space let's try all of that and I'm
598:12 - going to start by always attacking the
598:14 - middle
598:16 - monster cuz that earlier caused the most
598:18 - issues however I also want to has to pay
598:20 - attention to when I'm selecting one of
598:22 - these attacks earlier we always kept the
598:25 - same index if I select the fourth item
598:28 - or the one with index three Ander us it
598:32 - when we selected the next monster we got
598:34 - the same index but now we always start
598:36 - at the top which fits much cleaner so
598:40 - let me oh that was the wrong monster but
598:42 - this seems to be working reasonably
598:45 - well so for the final one disappears and
598:49 - there we go now we can't really do
598:51 - anything anymore and we're getting an
598:54 - error but that doesn't really matter
598:56 - once we get to this case we want to end
598:57 - the battle anyway although that is going
598:59 - to come later first of all though I can
599:02 - minimize the
599:04 - input and the dander in nit method and
599:08 - then work on the next part which
599:10 - actually happens inside of input because
599:13 - in there we currently can attack a
599:15 - monster but we cannot catch one so that
599:18 - we have to account for as well to
599:20 - explain that mechanic let me run the
599:22 - game again and essentially once a
599:24 - monster is ready I want to select the
599:27 - Target Monster and then at the moment we
599:30 - are only printing catch so that doesn't
599:32 - do
599:34 - anything which means inside of
599:37 - battle once we get to catch we want to
599:42 - do more than just print catch I want to
599:45 - set self. selection mode to Target
599:50 - and self. selection s should be the
599:56 - opponent that should already do quite a
599:58 - bit if I now Run the game and I go to
600:02 - catch we can select one of the opponent
600:04 - monsters although if I press space we
600:06 - don't really do anything and for that
600:09 - we're going to need this El statement so
600:12 - basically at the moment we are in
600:14 - selection mode Target but we do not have
600:16 - a selected attack and in there I
600:19 - basically want to check if monster
600:21 - sprite. monster and health is below 10%
600:26 - of the max Health which we can get via
600:30 - monstore sprite. monster and get Stat
600:36 - maxcore Health and that we can multiply
600:38 - with 0.1 or whatever number you think
600:41 - works well if that is the case I want to
600:44 - update self. monster data with the layer
600:49 - and then add add a new index and assign
600:52 - the
600:53 - monster the monster we can get from
600:57 - monster
600:58 - sprite. monster and the index is simply
601:02 - going to be the next number or in other
601:04 - words at the moment we have 11 monsters
601:07 - meaning the next index should be 11 to
601:10 - get that inside of the monster I simply
601:12 - want to get the length of self. monster
601:15 - data of the player on top of that I want
601:19 - to get the monster Sprite and run the
601:23 - delayed kill method with none that way
601:26 - the monster disappears after a few
601:29 - milliseconds and finally we have to
601:31 - self. update all monsters and resume the
601:36 - game if that is not the case else we
601:39 - want to do something else but for now I
601:40 - simply want to print cannot catch
601:44 - monster let's try all of this first and
601:46 - while we are testing things I want to
601:48 - set the catch rate to let's say below
601:52 - 90% that's going to make things much
601:54 - easier to test if I now run main. pi and
601:59 - I attack one of the stronger monsters
602:01 - that should be good and now if I catch
602:03 - this one it disappears and if I switch
602:07 - the monsters all the way at the bottom
602:09 - we should have enough a monster that
602:11 - looks good although if I press space
602:13 - nothing is going to happen at the moment
602:15 - so that we do have to work on but step
602:17 - by step first of all this is working
602:20 - next up though if the player tries to
602:24 - catch a monster with too much health
602:26 - then I want to create a timed
602:30 - Sprite or in other words I want to
602:32 - display a Sprite for a very short amount
602:34 - of time now the image that I want to
602:37 - display is going to be inside of
602:39 - Graphics in
602:41 - UI there we have a cross if the player
602:45 - tries to catch a monster with too much
602:46 - health I want to display this cross over
602:48 - the monster for a short period of time
602:51 - and for that we are going to use the
602:52 - time Sprite in terms of arguments I want
602:56 - to have a center position I want to have
603:00 - a frame or rather a surface since this
603:02 - one isn't animated then we will need a
603:06 - groups and a duration argument none of
603:10 - these are terribly difficult for the
603:11 - center position I want to get the
603:13 - monster sprite. wct do Center this
603:17 - surface I want to use we already have
603:19 - self. battles Sprites in there we have
603:23 - UI
603:25 - Sprites and this one contains a cross
603:29 - this is already
603:31 - imported for the groups I simply want to
603:33 - have self. battles Sprites and the
603:36 - duration could be let's say 1,000
603:39 - milliseconds or 1 second with that we
603:42 - can create a Time Sprite although before
603:44 - we do that I want to import it right
603:47 - away with that inside side of the
603:50 - Sprites I want to create another class
603:53 - time Sprite and the parent class for
603:55 - this one is going to be a
603:58 - Sprite after that I'm going to call
604:01 - Define thunder in knit with self a
604:05 - position surface groups and
604:10 - duration I want to call this super
604:12 - Dunder init method and as a reminder we
604:16 - are going to initialize this init method
604:20 - which means we need these
604:23 - parameters where we have position
604:25 - already covered surface covered groups
604:28 - covered and the one more thing that we
604:30 - need is the Z parameter for which we are
604:33 - going to use our batt layers and this
604:37 - one should always be on overlay after
604:40 - that we do have to update self. rect do
604:44 - Center which should be the
604:47 - position and that's the same issue we
604:49 - have already seen with the attack Sprite
604:51 - we have done the same thing in there so
604:54 - essentially for the original Sprite and
604:56 - animated Sprite we have a rectangle and
604:59 - via the position we are placing the top
605:02 - left which is not what we want to do for
605:05 - the attack Sprite and the time Sprite we
605:07 - always want to place the center which we
605:10 - achieve via these lines on top of that
605:14 - for the time Sprite we will need a self.
605:17 - Deathcore timer
605:20 - which will be a timer with the duration
605:23 - that we getting from the parameter all
605:25 - the way up there I want to set auto
605:28 - start to true and then the function I
605:31 - want to call once it triggers is going
605:34 - to be self. kill the inbuilt function of
605:37 - any Sprite and after we have that I
605:41 - simply want to call update with self and
605:43 - Delta time although Delta time we don't
605:46 - actually need so an underscore here is
605:48 - totally fine
605:50 - and then self. death timer. update is
605:54 - all we need and that should be it if I
605:58 - now try main. pi and I try to catch a
606:01 - monster with full health we are getting
606:04 - an error because battle Sprites object
606:06 - is not
606:07 - subscriptable let's have a look I think
606:10 - that happened when we are creating the
606:12 - time Sprite so there we have the error
606:14 - and I can see it already we want to get
606:16 - the graphic not from Battle Sprites but
606:19 - from monster frames this one actually
606:22 - contains the
606:24 - graphics next attempt and now if I try
606:28 - to catch a
606:30 - monster we are getting the error symbol
606:33 - message thingy that's working reasonably
606:36 - well that covers catching a monster and
606:39 - I am going to leave it at 0.9 for now
606:42 - although later on this one should be
606:44 - switched back perfect we are making
606:48 - progress so with that we have
606:51 - covered quite a few states there are two
606:55 - more the next one if self do selection
606:59 - mode is equal to switch I.E we are
607:03 - trying to switch the monsters if that is
607:06 - the case I want to get an index and a
607:09 - new
607:11 - monster which I can get from the list
607:15 - self. available monsters. items don't
607:18 - forget to call this one and then use
607:21 - indexing with self. indexes and the
607:26 - switch Also let's print index and new
607:29 - monster just to make sure we have
607:31 - something to look at if I now run
607:35 - main.py and I try to switch a monster
607:38 - let's go with this one we can see the
607:41 - monster we have selected is four and spu
607:44 - we can try another one that still looks
607:46 - pretty good let's this one as well so
607:50 - yep that seems to be working quite well
607:53 - which means at this point we simply want
607:55 - to get the current monster and kill it
607:58 - that way we're getting rid of the Sprite
608:00 - and next up we can create a new monster
608:05 - with the new monster that we have just
608:07 - gotten then we want to have the index
608:11 - and self. corn monster do position index
608:15 - and you might be wondering why can we
608:18 - still access this corn monster even
608:20 - though we have just killed it the reason
608:22 - for that is that killing a Sprite
608:24 - doesn't actually destroy the Sprite it
608:26 - simply removes it from all of the groups
608:28 - that way you can still access all of the
608:30 - attributes which is super handy the last
608:33 - thing we are then going to need is the
608:36 - entity or the site of the monster which
608:38 - is always going to be player for this
608:39 - one after that I want to get self.
608:43 - selection mode and set it to none and
608:46 - then self. update all monsters
608:50 - and resume things that should be all we
608:53 - need in here if I now run main. Pi I can
608:58 - select another monster let's go with
609:01 - this one and we get another
609:04 - monster also if I now try to attack
609:07 - another monster and then try to catch
609:12 - it that part still works and now if I
609:16 - try to switch monsters with the one we
609:18 - have just C that part also works just
609:21 - fine so that is looking pretty good so
609:25 - with that we have covered all of the
609:27 - major States but there's one that we
609:29 - haven't covered yet inside of selection
609:31 - mode General index one this is telling a
609:35 - monster to defend and at the moment this
609:37 - doesn't really do anything to fix that
609:40 - before we are doing anything else inside
609:42 - of the if statement self. current
609:45 - monster do monster and then defending
609:50 - is going to be true that we can then
609:54 - use when we are applying an attack we
609:59 - are already calculating the damage
610:01 - mechanic in quite some detail here and
610:04 - essentially after we are calculating the
610:06 - target defense I want to check if
610:11 - Target
610:13 - Sprite Dot Monster dot
610:17 - defending if that is the case then
610:20 - Target
610:21 - defense is going to be Reduce by
610:25 - 0.2 oh and also we should create this
610:28 - defending attribute inside of the
610:30 - monster in the DED method let's do it
610:33 - under stats we want to have self.
610:37 - defending which by default is going to
610:39 - be
610:40 - false on top of that after the monster
610:43 - gets ready again we want to disable this
610:45 - defending attribute which means when we
610:49 - checking for active and one of the
610:51 - monsters does get ready then we also
610:53 - want to set monster sprite. monster.
610:57 - defending to bols although this part is
611:01 - now very difficult to visualize because
611:04 - we have to wait for the other monsters
611:06 - to attack
611:08 - us let me just always choose defend and
611:12 - let's hope we get the right monster to
611:15 - be attacked
611:20 - and well they always attack the weakest
611:22 - one at the moment and there we go rolera
611:25 - got attacked and the damage is actually
611:26 - really low although that might not mean
611:29 - very much but well basically inside of a
611:34 - Ply attack we know that this number is
611:36 - going to update so play around with it
611:39 - if you want to change the numbers but I
611:41 - am fairly confident that it works
611:43 - reasonably well righty with that we have
611:46 - apply attack which means there's just
611:49 - one more thing that I want to do in this
611:51 - section and that is for the battle
611:53 - system I want to check end of the
611:59 - battle so we know when either the
612:01 - opponent or the player has been defeated
612:04 - for that we donate custom parameters and
612:07 - then we have to check two conditions
612:09 - number one is opponents have been
612:13 - defeated and number two his player has
612:16 - been defeated I suppose we could start
612:19 - with the player because that part is a
612:21 - bit easier all we really want to check
612:23 - is if length of self and player
612:27 - Sprites and if that number is equal to
612:31 - zero and just to test that for now let's
612:34 - print game over after that inside of the
612:39 - update method I want to check self.
612:43 - check and battle and I guess this we
612:45 - should be doing before we are doing
612:47 - anything else that should be a bit safer
612:50 - righty now to test this one inside of
612:53 - main.py when we are creating the monster
612:55 - the player shouldn't have three monsters
612:57 - with level 100 although for the opponent
612:59 - monsters I want to have three monsters
613:01 - with a level of 100 and just so we don't
613:05 - have to wait for too long let me comment
613:07 - out most of the monsters and let's try
613:10 - this again and now we should be losing
613:12 - pretty quickly simply because the
613:15 - opponents are way
613:17 - stronger so there we losing one monster
613:20 - there another monster and we should be
613:24 - gone well this has nearly worked we are
613:27 - getting game over but after that we are
613:31 - getting an error message that we cannot
613:33 - choose from an empty sequence which is
613:36 - okay this line is not going to run
613:37 - anymore but basically what happened is
613:40 - when we are checking the opponent attack
613:43 - we cannot pick a random Target anymore
613:46 - simply because there are no player
613:47 - monsters left but that's okay because
613:49 - we're not going to get to this
613:51 - line so instead we want to run py game.
613:56 - quit and
613:58 - exit and since we are importing py game
614:02 - and sis inside of settings these two
614:04 - lines should work pretty well let's try
614:07 - to run out of this
614:08 - again and we should be defeated pretty
614:14 - quickly cool and the game just ends so
614:17 - we are good to go
614:19 - this covers one part next up we have to
614:22 - work on the
614:23 - opponents which is going to work in a
614:25 - fairly similar fashion I want to check
614:28 - if the length of self. opponent
614:32 - Sprites is equal to zero if that is the
614:36 - case I simply want to print battle
614:40 - one on top of that I want to get for
614:44 - monster in self. Monster
614:49 - data and the layer monsters so dot
614:54 - values and then reset all of the Monster
614:57 - initiatives I.E monster. initiative is
615:00 - going to be
615:01 - zero that way when the next battle
615:04 - starts we don't have some random value
615:06 - already but that should be it if I now
615:08 - go back to main.py and for the opponents
615:11 - I want to have more reasonable levels
615:14 - let's say five six and seven
615:19 - and now we can try this
615:20 - [Music]
615:21 - again and if I just defeat them randomly
615:25 - I use the proper attack type but you get
615:28 - the
615:37 - idea and there we go all of the
615:39 - opponents have disappeared and we get
615:41 - Battle one although this we get many
615:44 - many times which might cause an issue
615:46 - down the line to account for that I want
615:48 - to add and not self. battle
615:54 - over and then once this if statement
615:58 - triggers I want to set battle over to
616:00 - through on top of that in the dunder
616:03 - init method I want to create another
616:06 - attribute self. battle over which by
616:08 - default is going to be false that way
616:11 - and let me comment out most of the
616:13 - monsters we should only see battle over
616:16 - once which is going to be much safer
616:21 - and there we go we have won the battle
616:24 - and everything still works just fine
616:27 - perfect so with that we have basically
616:29 - all of the battle logic there's just one
616:32 - minor final thing that I want to cover
616:34 - and that is when a monster gets defeated
616:36 - you can see something like minus 50
616:38 - Health which is kind of a cool effect
616:41 - and if you want to keep it just skip
616:42 - this part but I want to limit the lowest
616:45 - Health to
616:47 - zero and for that inside of the monster
616:50 - let me minimize everything I want to
616:54 - insert a stat limiter in which we are
616:58 - setting self. health and self. energy
617:03 - and basically for both what we are going
617:04 - to do we're going to make sure that we
617:06 - have a max value of either zero or a Min
617:10 - value of self. health and self. getet
617:14 - Stat with
617:16 - maxcore health or another words we first
617:19 - get the larger value between zero and
617:22 - the smaller value between self. health
617:24 - and self. Max Health that way self.
617:28 - Health can never go beyond the max
617:31 - health or below
617:33 - zero and the same thing we want to do
617:35 - for energy so let me copy all of this
617:39 - the only change that we have to make is
617:40 - this needs to be self. energy and the
617:43 - max value should be Max
617:46 - Energy after that we have to make sure
617:48 - that we are calling the stat limiter
617:51 - that's going to happen inside of the
617:52 - update method you can put it basically
617:54 - wherever you want self. stat
617:57 - limiter and with that if I now run m p
618:00 - again and let me try to hit I have a
618:04 - monster with water attack so we do lots
618:06 - of damage and we always keep it at zero
618:10 - so that looks pretty good perfect and
618:13 - with that we have finished the battle
618:15 - system now later on we have to add some
618:17 - sounds but that's a fairly minor part
618:20 - what is much more important for now is
618:22 - to connect the battle system to the
618:23 - Overworld which will be the next part
618:25 - I'll see you
618:26 - there so with the Overworld and the
618:29 - battle system in place we have to
618:31 - connect the two and that's going to be
618:33 - the last major part that we have to work
618:35 - on although on top of that there are a
618:38 - few more minor things that I also want
618:39 - to cover most importantly in there we
618:42 - have the evolution system so if a
618:45 - monster Hits a certain level we want to
618:47 - switch it to another monster
618:49 - besides that for the characters I want
618:50 - to have a nurse that heals all of the
618:52 - player monsters and finally I want to
618:55 - add all of the sounds that part should
618:56 - be fairly straightforward once we have
618:58 - covered all of that we have the entirety
619:01 - of the game so let's Jump Right In and
619:04 - get started with the easiest part the
619:07 - nurse system so here we are back in the
619:09 - code and I have cleaned up the tabs a
619:12 - bit the python files that we will need
619:14 - are main.py entities. Pi battle. Pi
619:18 - along with support pi and game data
619:20 - although the first three are the most
619:21 - important ones and to get started I want
619:24 - to implement a nurse so that when the
619:26 - player goes to a hospital we can get
619:29 - healed for that when we are creating the
619:33 - characters that happens in there in the
619:36 - setup method I want to add one more
619:39 - argument which is going to be nurse the
619:43 - value for this is going to be a Boolean
619:45 - and basically what I want to check is or
619:49 - bj.
619:50 - properties and then we have a character
619:54 - uncore id if that value is equal to this
619:59 - string nurse then we know we have a
620:02 - nurse now to understand what that means
620:05 - in TI we have to find a nurse in the
620:08 - Overworld we don't have a nurse but if
620:10 - you go to hospital. TMX we have one
620:13 - nurse here and there you can see
620:15 - character id is nurse that is what we we
620:18 - are looking for also this nurse should
620:20 - be a bit further down so the player can
620:23 - actually reach it oh and by the way
620:25 - while we are here inside of world TMX
620:28 - the player shouldn't be in the top left
620:30 - he should rather be further down here
620:34 - with that we know if a character is a
620:36 - nurse or not which means next up we want
620:39 - to work inside of the character class
620:43 - first of all we have to give this one
620:45 - another
620:47 - parameter nurse
620:50 - and then inside of Thunder init turn
620:52 - this into an attribute self do nurse is
620:56 - going to be
620:58 - nurse that's all we need in here next up
621:01 - we want to work inside of main.py more
621:05 - specifically in and dialogue at the
621:08 - moment we are only getting rid of the
621:10 - dialogue tree and then unblocking the
621:12 - player not very much so far and in this
621:15 - section we're going to expand this
621:16 - method quite a bit
621:19 - first of all I want to check if
621:23 - character. nurse and if that happens to
621:26 - be I want to cycle through all of the
621:28 - player monsters I.E for Monster inself
621:31 - dopler monsters. values and then set
621:37 - monster. Health to monster
621:41 - getor
621:43 - stat with the
621:45 - maxcore
621:47 - health that way we are setting Health to
621:49 - the maximum value and the same thing we
621:51 - want to do for the energy except now we
621:54 - want to set it to max energy that way we
621:58 - are healing all of the monsters and only
622:00 - after that is the case do I want to
622:02 - unblock the player and with that we have
622:05 - the nurse now to test this inside of
622:08 - thunder in knit I want to comment out
622:12 - battle but we will need the attribute
622:15 - self. battle although it should be by
622:18 - now keep the instant sync of this battle
622:21 - class we are going to need it in just a
622:23 - second and it's going to save you some
622:24 - writing anyway if I now run main. Pi we
622:29 - are not getting an error and if I go to
622:31 - the
622:32 - hospital I can talk to a nurse and we
622:36 - are getting our monsters have been
622:38 - healed now this isn't really something
622:40 - we can observe right now because our
622:42 - monsters have the full amount of Health
622:45 - but what we can do after we created all
622:47 - of the monsters
622:49 - for Monster inself dopler monsters.
622:54 - values
622:56 - monster. Health multiply equal
623:00 - 0.5 that way if I run the game again we
623:04 - get 50% health for all of the monsters
623:07 - so now if we go to a hospital and get
623:12 - healed all of the monsters have the full
623:15 - amount of health so that is working
623:17 - really well with that we don't need this
623:20 - for Loop anymore and we have covered one
623:22 - part now we have a
623:24 - nurse after that if the character we are
623:28 - talking to is not a
623:30 - nurse so L if and we want to check not
623:36 - character do character data and then we
623:40 - want to check for
623:43 - defeated or in other words when we are
623:45 - finishing a dialogue we want to check if
623:47 - the character we talk to is a trainer
623:49 - that hasn't been defeated if that is the
623:52 - case we want to start a battle although
623:55 - for now let's simply print start
624:00 - battle if I run the code and talk to a
624:06 - character we should be getting start
624:08 - battle in the bottom left and we do that
624:11 - is looking pretty
624:12 - good which means if this is the case we
624:15 - actually want to create one instance of
624:18 - the battle class which we can do by
624:20 - copying the values that we have created
624:23 - earlier and then we don't need thiss
624:25 - after battle anymore we want to create a
624:28 - battle class and I think all of this
624:31 - should happen over multiple lines so
624:33 - it's a bit easier to read we have the
624:36 - player
624:37 - monsters then we have the
624:41 - opponent
624:42 - monsters next up we have the monster
624:45 - underscore frames we are getting a BG
624:50 - surface and finally I think this one is
624:52 - simply called the fonts so with that we
624:56 - are creating one instance of the battle
624:57 - class and there's one thing we already
625:00 - have to change we want to get for the
625:02 - opponent Monsters the actual Monsters of
625:04 - this trainer and I should actually do a
625:07 - reminder if we're looking at the
625:09 - entities and the character there are two
625:12 - data points we are working with at the
625:13 - moment the first one is this character
625:16 - data defeated this can find inside of
625:19 - the character in character data but
625:22 - ultimately what we are referencing is
625:24 - inside of game data there we have the
625:26 - trainer data and this one contains the
625:29 - defeated key value Pair by default all
625:31 - of these values are faults but once the
625:33 - trainer has been defeated we are going
625:35 - to set this to True besides that all of
625:38 - the trainers have some monsters those we
625:41 - have to get into the character which
625:44 - means for the character I want to create
625:46 - another attribute self do
625:49 - monsters which is going to be a
625:51 - dictionary comprehension where we want
625:53 - to have an index and then a monster all
625:58 - of the data is going to come from for I
626:01 - and data in character data and we want
626:06 - to get the monsters and from that we
626:09 - want to get the items if you look at
626:11 - game data monsters is simply a
626:14 - dictionary where we have the index of
626:16 - the monster and then the monster along
626:18 - with the
626:20 - level that we want to convert to an
626:22 - actual index with the monster class for
626:26 - that we want to call the monster class
626:28 - and then pass in the monster name and
626:30 - the monster level that we can make quite
626:33 - explicit because data right now is a
626:35 - tuple with the monster name and the
626:37 - monster level which are the two points
626:40 - of data we want to pass into monster so
626:43 - name and level that should be it for
626:46 - this part although if I run main. pip we
626:49 - are going to get an error that we have a
626:51 - name error monster is not defined that
626:54 - happens because some trainers do not
626:56 - have monsters because they are nurses so
626:59 - if I go down a bit further at some point
627:02 - there should be a nurse and the nurse
627:04 - obviously doesn't have
627:06 - monsters to account for that when we are
627:08 - creating the monsters I want to check
627:12 - that we are only creating this
627:14 - dictionary if there are
627:16 - monsters in
627:19 - the character data if that is not the
627:21 - case else we want to attach none to this
627:24 - value so we now run the entire
627:28 - thing we are getting the same error and
627:31 - I just realized I made a mistake when I
627:34 - talked about this error that monsters is
627:36 - not inside of character data this would
627:38 - have been the next step the actual error
627:41 - that we have gotten is that this monster
627:42 - class doesn't exist inside of this
627:44 - python file at the moment which we can
627:47 - change quite easily from Monster import
627:51 - monster and now if we try off this again
627:54 - there we go now this all works just fine
627:57 - that means next up when we are creating
628:00 - a battle class for the opponent monsters
628:03 - we can get the character and the
628:08 - Monsters besides that we also have to
628:11 - cover the background surface at the
628:13 - moment we are always using the forest
628:15 - but that we can make more flexible by
628:17 - using character do character data and in
628:21 - there if you look at game data we have a
628:24 - biome I want to use that is all we need
628:26 - to get started if we now store this
628:29 - instance in self. battle and Run the
628:34 - game and we are getting to a fight we
628:38 - can also still attack and everything is
628:40 - working just
628:42 - fine so definitely doing some progress
628:49 - but obviously there's no way for us to
628:51 - leave this window which isn't ideal also
628:55 - I want to have a transition from the
628:56 - Overworld to the battle at the moment we
628:59 - are switching a bit too
629:00 - abruptly as a consequence instead of
629:03 - assigning battle to the attribute right
629:05 - away I want to set battle to the
629:07 - transition Target and after we have done
629:11 - that set self. tint mode to H now this
629:18 - is a system we have implemented way
629:20 - earlier when we have switched between
629:23 - different levels so this tint screen is
629:25 - what we're going to work in essentially
629:28 - what we are going to check is if the
629:30 - tint progress is greater than 255
629:33 - meaning we are covering the entire
629:35 - window after that we want to check if
629:40 - type of self. transition Target if that
629:45 - is equal to the battle class
629:48 - then we know we want to create self.
629:51 - battle and set it to self. transition
629:56 - Target meaning now we are setting battle
629:59 - and getting all of this while we are
630:02 - here we can also set an L if statement
630:05 - self. transition Target is equal to
630:11 - level then self. battle is simply going
630:14 - to be none so this would be the other
630:17 - way around where we are going from a
630:18 - battle to the Overworld which simply
630:21 - means that we want to set battle To None
630:24 - finally if nether of those are the case
630:26 - else then we want to run the setup
630:28 - method to create another level and
630:31 - that's all we need to get started with
630:33 - this part so if I now talk to a trainer
630:36 - again we should have a nicer
630:39 - transition and that is looking much
630:42 - better the rest still works just fine
630:45 - cool so with that we can get from the
630:48 - Overworld to a battle but how can we get
630:51 - back for that we will need another
630:54 - method that I have called
630:57 - [Music]
630:58 - endore battle besides self we will need
631:02 - a character parameter in this method I
631:05 - want to get self. transition Target and
631:08 - set it to level then I want to set self.
631:13 - tint
631:14 - mode and tint the screen and and then
631:18 - check if we have a character in which
631:21 - case we want to set character do
631:24 - character
631:25 - data
631:27 - defe and this one should now be
631:31 - true on top of that self. create
631:35 - dialogue with this
631:37 - character or in other words once the
631:40 - battle ends which means inside of the
631:42 - battle class we are going to call check
631:47 - and battle so on there instead of
631:49 - printing battle one we want to call this
631:52 - end battle method and then check if we
631:54 - have a character if that's the case we
631:56 - want to set this character to defeated
631:58 - and then display the defeated dialogue
632:01 - that's all we need for now so next up we
632:04 - have to make sure that this end battle
632:06 - is inside of the battle class or rather
632:10 - when we are creating an instance of this
632:12 - class we have access to this method
632:15 - which we can do via another parameter I
632:18 - want to add endore battle the value is
632:22 - going to be self. endore
632:26 - battle that means inside of battle. Pi
632:30 - we have to add one more parameter _
632:34 - battle and turn all of that into an
632:37 - attribute self. end battle is going to
632:40 - be end battle on top of that when we go
632:44 - down a bit instead of printing battle
632:47 - one I want to call Self Dot and battle
632:52 - and now we have to get the character in
632:54 - there which we also going to do via a
632:57 - parameter so we want to have a character
633:00 - or a trainer doesn't really matter what
633:02 - you call it for that we have to once
633:05 - again work inside of main. Pi and then
633:07 - add another named argument we want to
633:09 - have a character that part is really
633:12 - easy because we already get the
633:14 - character so that we have to pass in
633:16 - there character
633:18 - and then we are good to go although we
633:20 - do have to store that as an attribute as
633:21 - well self. character is going to be
633:26 - character so quite a bit more data but
633:29 - now when we are checking for the end of
633:32 - the battle we can call self. end battle
633:35 - and pass through self.
633:38 - character which means we are calling
633:42 - this and battle we are setting the
633:45 - transition Target to level then tint
633:47 - mode to tint
633:48 - and we are creating a new
633:50 - dialogue after that we are going to tint
633:53 - screen we are tinting everything so
633:56 - things are going to Black and once we
633:57 - are reaching the full value so
634:00 - 255 we get to this if statement and we
634:03 - know that transition Target is level
634:06 - which means by the end of it battle is
634:07 - going to be
634:09 - none let's
634:11 - try if I now let's talk to this
634:13 - character I think it's a bit easier to
634:16 - defeat so we should netive transition
634:18 - that looks good and now if I defeat the
634:22 - monsters really
634:25 - quick there we go we get a transition we
634:28 - get a
634:29 - dialogue and that is working really well
634:32 - although afterwards we are not able to
634:34 - walk anymore but we are making
634:37 - progress first of all then once the
634:40 - battle is over and we are ending the
634:43 - dialogue we have to unlock the player
634:46 - which we can do via an l
634:48 - statement self. player.
634:52 - unlock that should be all we need next
634:56 - attempt okay we are making progress and
635:00 - I can walk around perfectly fine again
635:02 - and now if I talk to this character
635:04 - again we are always getting the defeated
635:06 - dialogue perfect that is working quite
635:08 - well so next up we need to system that
635:11 - if the player walks in t grass we want
635:13 - to have random monster encounters or in
635:16 - other words there should be a random Tim
635:18 - that if we are in to grass after some
635:21 - random period of time we should be
635:23 - attacked imagine that this is the
635:25 - timeline of the game and our player
635:28 - currently is here meaning a random
635:30 - amount of time has passed this specific
635:32 - number doesn't really
635:34 - matter what we want to check is if the
635:37 - player has touched some grass then we
635:40 - want to create a timer that runs for a
635:42 - short amount of time and if this timer
635:45 - runs out and the player is still in Tall
635:48 - Grass then we want to start a fight
635:51 - which means we have to do two things
635:53 - number one once the player gets into
635:56 - Tall Grass we want to start a timer and
635:59 - after this timer is finished if we are
636:00 - still in Tall Grass then we want to
636:02 - start a
636:04 - battle I have organized all of that via
636:07 - two
636:09 - methods let's put all of that in a
636:11 - separate section monster and counters
636:16 - first of all I have Define check
636:19 - underscore let's Call it Monster no need
636:22 - for custom parameters and we basically
636:24 - want to check if the hitbox of the
636:26 - player is inside of any of the grass
636:29 - patches for that first of all we need to
636:31 - know where all of the Monster grass
636:33 - patches are meaning we have to create
636:35 - another Sprite group self.
636:38 - monstore Sprites a better name here
636:42 - might be grass patch or something like
636:44 - that but I think you get the idea now
636:47 - now we have monster Sprites that means
636:50 - next up when we are creating the entire
636:54 - level we want to check for all of the
636:59 - grass patches those they should be
637:01 - inside of all Sprites and they should be
637:04 - inside of self. monster
637:07 - Sprites that way we always know where
637:10 - all of them are that's a good start so
637:13 - next up when we are checking for the
637:15 - monsters we want to check if the list
637:19 - comprehension Sprite for sprite
637:22 - in. monster
637:25 - Sprites I.E we are getting all of the
637:27 - Monster Sprites but we only want to get
637:29 - the ones that are colliding with the
637:30 - player hitbox I.E sprite. w.
637:35 - cidere with self. player.
637:40 - hitbox on top of that I want to check
637:43 - and not self. battle and self do player.
637:50 - Direction so in other words we are
637:52 - checking three things if the player is
637:55 - colliding with tall grass if there's not
637:57 - currently a battle and if the player is
637:59 - moving I think all of them are fairly
638:01 - straightforward if that is the case I
638:04 - want to start a timer let's call this
638:05 - one self.
638:07 - encounter timer this is what I want to
638:12 - activate also want to make sure this
638:14 - timer is not currently running which we
638:16 - can do with another by if statement if
638:19 - not self. encounter timer.
638:23 - active only if that is not the case do
638:25 - we want to start the timer now this
638:28 - timer doesn't exist at the moment which
638:30 - means inside of Thunder init all the way
638:33 - at the top I want to create the
638:35 - encounter timer which will be a timer
638:39 - with a duration of 2,000 for now and if
638:43 - this thing times out I want to call a
638:45 - function which is going to be self
638:48 - monstore encounter this method does not
638:51 - exist at the moment and we'll create it
638:53 - in just a second first of all though we
638:56 - have to from timer import timer cool
639:01 - next up we can call this timer and
639:05 - besides that we will need Define monster
639:08 - uncore
639:10 - encounter no need for custom parameters
639:12 - and for now let's simply print monster
639:16 - and counter
639:18 - now before we can test all of this
639:19 - there's one more thing that you
639:20 - shouldn't forget and that is we have to
639:23 - update the timer that's going to happen
639:24 - inside of the update method before we
639:26 - are doing anything else self. encounter
639:29 - timer. update on top of that what you
639:32 - shouldn't forget inside of update
639:35 - self. check
639:38 - monster I.E we are calling this
639:41 - method with that if I run everything and
639:44 - we are touching grass after some time we
639:47 - should should get monster encounter at
639:49 - the moment this happens every 2 seconds
639:51 - so that is looking reasonably well that
639:54 - means check monster is working we are
639:56 - not going to need it anymore but we do
639:58 - have to write some logic inside of
640:00 - monster encounter first of all we want
640:02 - to check the collisions again which we
640:04 - are doing via Sprites and another list
640:07 - comprehension Sprite for sprite in self.
640:11 - Monster Sprites but only if sprite. w.
640:16 - collide cor with self. player. hitbox
640:20 - the same thing we have done inside of
640:22 - check monster basically dless
640:25 - comprehension although now we want to
640:27 - check if we have some Sprites and self.
640:32 - player.
640:34 - Direction which means we know that this
640:37 - method is only going to be called once
640:39 - the timer is timed out meaning we know
640:41 - that the player has been moving in grass
640:43 - for 2 seconds after this timer we want
640:46 - to check if the player is still in grass
640:49 - and if the player is moving if that is
640:51 - the case I want to set self. player do
640:56 - block and create a new self. transition
641:00 - Target which will be another instance of
641:02 - the battle class and for the arguments
641:05 - for this one just to get started we can
641:07 - look at the transition Target for the
641:10 - character and paste it in there although
641:14 - we will have to make some changes the
641:16 - two AR arents we have to customize are
641:18 - the monsters and the background to get
641:21 - both we have to look at tiled and
641:23 - specifically we want to look at the
641:25 - monster layer because in there and let
641:28 - me hide everything else we get all of
641:31 - the Monster encounter patches and if you
641:34 - look at one of them we're getting a
641:37 - biome a level and the Monsters notice
641:40 - here that the monsters are simply a
641:41 - string with comma separated values tile
641:45 - doesn't allow you to have a list which
641:46 - is a bit annoying but we can work with
641:48 - it so what we want to do is get all of
641:50 - this into P game and then create custom
641:53 - monsters and access the background
641:55 - surface and for that actually we do have
641:58 - to work inside of the
642:02 - Sprites if you scroll down a bit there
642:04 - we have a monster patch Sprite Which at
642:08 - the moment doesn't do very much and
642:10 - adding all of the details and then
642:12 - creating a battle once we are in tall
642:14 - grass is going to be your exercise there
642:16 - are two two parts to the exercise number
642:19 - one I want you guys to import the tile
642:21 - data into the monster patch Sprite you
642:24 - will need a level a biome and a monster
642:27 - names after that once the play is on top
642:29 - of one of those patches use the data to
642:32 - start a
642:33 - battle should be reasonably doable pause
642:36 - the video now and see how far you
642:41 - get first of all we have to work inside
642:45 - of setup and then work a bit more with
642:48 - the grass Patches at the moment we are
642:51 - looping over the layer of the monsters
642:54 - and then create a monster patch Sprite
642:57 - in there we are actually already passing
642:59 - in the biome which should give you a
643:01 - hint of how we can access the other data
643:04 - you can simply copy obj properties
643:06 - because we also want to have the
643:08 - monsters and then the level once we have
643:12 - that inside of Sprites we will need
643:15 - after biome the monster
643:17 - and the level and for now let's simply
643:21 - print what we get I want to print
643:24 - monsters and I want to print the
643:28 - level let's try out of that we are
643:30 - getting the names of the monsters and
643:32 - the average level so that is looking
643:35 - pretty
643:36 - good although that data we have to
643:38 - organize a bit better which means inside
643:42 - of the Sprites I first off I want to
643:44 - create self. biome which're is a biome
643:48 - we are already getting we want to store
643:50 - to monsters but this should be a list
643:53 - which I can get with monsters do split
643:55 - and then split this string wherever we
643:58 - have a period and finally self. level is
644:01 - simply going to be level just to make
644:04 - sure that all of this is working let's
644:06 - print self
644:08 - do biome self do monsters and self dot
644:14 - levil if I now run main. pi we're not
644:17 - crashing and we are getting a whole
644:20 - bunch of data now you can see I was
644:23 - quite lazy when it comes to the grass
644:25 - patches we basically always have the
644:27 - same monsters and the same level but the
644:29 - data is working that's the important
644:31 - part which means we don't need this
644:33 - print statement anymore and next up we
644:35 - can work inside of main. Pi specifically
644:39 - in the monster encounter because this
644:42 - Sprites is going to contain all of these
644:45 - monster patch Sprites or at the ones the
644:47 - player is colliding with so for example
644:49 - to get the background surface we still
644:51 - want to get all of the BG frames but
644:53 - then for the key we want to get Sprites
644:56 - and the first one and on this we have
644:59 - the biome attribute besides that we need
645:03 - a couple of monsters which we are going
645:05 - to create via dictionary comprehension
645:07 - and just as before we want to have a
645:09 - dictionary with an index and a
645:13 - monster which we can get via a for Loop
645:16 - for index
645:17 - and monster in in
645:21 - numerate Sprites zero and then we have
645:26 - the monsters that means for the key we
645:30 - can get the index and for the monster we
645:32 - want to create one instance of the
645:34 - monster class in which we are going to
645:36 - need the name of the monster that we're
645:38 - getting from the four Loop and then we
645:40 - will need a level which we get from
645:42 - Sprites Z do level and and this I want
645:47 - to randomize just a bit meaning I want
645:50 - to add a random integer that goes from
645:52 - -3 to 3 that way we don't always get the
645:56 - same level although I don't think we
645:58 - have Rand in available at the moment we
646:01 - do not so all the way at the top from
646:04 - random import Rand
646:07 - int that is almost all we need the last
646:10 - thing that we have to change is for the
646:11 - character we want to have none so with
646:14 - all of that let's try the game and let's
646:17 - see if something
646:18 - crashes so at the moment the player
646:21 - simply stops walking but we do not get a
646:23 - battle something has gone wrong and I
646:25 - can see it right away we have to set
646:28 - self. tint mode to tint next attempt if
646:33 - I now walk around in the Tall Grass
646:36 - we're getting to a battle and I can
646:39 - still attack the monsters let me use
646:42 - their weak
646:45 - types and after that we go back to the
646:48 - Overworld and we are not able to move
646:50 - anymore but that is a thing we can fix
646:52 - quite easily we simply have to look at
646:55 - end battle and then check if we don't
646:59 - have a character if that is not the case
647:02 - self. player.
647:05 - unblock next
647:07 - attempt and now should get a
647:12 - battle we can still defeat all of the
647:15 - monsters and and after
647:19 - that we can walk around again also now
647:23 - we are getting some experience that is
647:24 - looking pretty good cool that is looking
647:28 - really good there's just one more thing
647:30 - that I want to do when we are
647:32 - encountering a monster I want to set
647:35 - self. encounter timer and switch up the
647:38 - duration which we're going to do via
647:41 - Rand in again and then get a random
647:44 - value I went with a value between 800
647:46 - 100 and
647:48 - 2,500 so the next encounter could be
647:50 - really fast or quite a bit away that
647:53 - means if I now try all of this again I
647:56 - can walk around and we getting a
648:00 - battle so let's defeat the monsters
648:02 - really
648:06 - quick and then we can walk around again
648:08 - and now we get a battle much faster and
648:11 - our monsters do not update their
648:13 - initiative only after we get attacked so
648:16 - something has G wrong but we are
648:17 - definitely making progress so let's fix
648:20 - this bug really quick basically inside
648:24 - of battle. Pi when we are creating a
648:27 - monster I want to make sure that monster
648:30 - do host is equal to fults that way if I
648:36 - run my not Pi again and let me speed all
648:38 - of this
648:42 - up and now we get another battle and
648:45 - there we go we are getting getting the
648:47 - proper
648:48 - behavior everything else is also working
648:50 - just fine so this is looking pretty good
648:54 - so with that we have the entire
648:57 - transition between the battle system and
648:59 - the Overworld we are making a ton of
649:02 - progress the last major chunk then is
649:05 - going to be the evolution system for
649:07 - which I want to create a new python file
649:09 - so a new file and then let's call it
649:13 - Evolution dot High we will need from
649:18 - settings and import everything also we
649:23 - are going to need a timer meaning from
649:25 - timer import timer once we have that I
649:28 - want to create a class called
649:31 - Evolution and then we will need a Dunder
649:33 - init method with a whole bunch of
649:37 - parameters we will need frames a start
649:41 - monster and end monster a font and then
649:46 - we want to end the evolution to get back
649:49 - to the Overworld in there we will first
649:53 - of all need a display uncore surface
649:56 - that we are getting from py game.
649:59 - display. getor surface then we will need
650:03 - self. start monstore surface and an end
650:09 - monster surface the way the system is
650:12 - going to work we're going to show the
650:14 - first Monster and then slowly f faded
650:16 - out to White and once we have reached
650:18 - the full amount of white we are
650:20 - switching to the evolution so in
650:22 - practice we are simply showing two
650:23 - different surfaces which we can get via
650:26 - the frames and both start and end
650:29 - monster are simply monster names which
650:31 - means those we can use inside of the
650:33 - frames so I want the start monster then
650:36 - get the idle State and the first frame
650:41 - now this is going to be very small and
650:44 - to make this a bit more visual
650:47 - I want to put it inside of py game.
650:50 - transform. scale to X that will make it
650:53 - twice as large the same thing I want to
650:55 - do for the end monster with the only
650:58 - difference being that we want to now use
651:00 - the end monster on top of that I want to
651:03 - create a timer dictionary where we have
651:07 - a start timer which would be a timer
651:10 - with a duration of 800 milliseconds and
651:13 - auto start will be
651:17 - besides that I want to have an end timer
651:20 - which is going to get a duration of
651:23 - 1,800 and the function we are going to
651:25 - call is going to be end Evolution or in
651:29 - other words when we are starting the
651:31 - evolution we will show the monster or
651:33 - the start monster for 800 milliseconds
651:36 - and once the evolution is done we're
651:38 - going to show the end monster for 1.8
651:40 - seconds with that we can already get
651:42 - started with a basic update method for
651:45 - which we need self and Delta time and
651:47 - first of all there I want for timer in.
651:51 - timers do
651:54 - values and then timer. update that way
651:57 - the timers are going to work next up I
652:01 - want to check if not self. timers and
652:06 - start is active that is going to be the
652:10 - start timer and only after this timer is
652:12 - over do we want to do
652:14 - stuff and the thing that we want to do
652:17 - is self. display surface do blit and
652:22 - then I want to tint the entire window
652:24 - which we're going to do via self.
652:26 - tintore surface at position Z and zero
652:31 - this tint surface doesn't exist at the
652:33 - moment but we can create it quite
652:36 - easily and for that I want to create a
652:38 - section called screen tint we simply
652:41 - want to create pame do
652:44 - surface with the same Dimensions as the
652:47 - display surface so self. display surface
652:51 - and get underscore
652:53 - size this surface we want to make
652:56 - semi-transparent I.E self. tint surface
653:00 - setor Alpha and I went with a value of
653:03 - 200 but you can play around with it that
653:06 - was quite a bit of setup but now that we
653:09 - have that inside of main. Pi I want to
653:12 - import From
653:14 - Evolution the
653:17 - Evolution
653:18 - class and now we have to figure out when
653:21 - to display this thing and for that I
653:25 - have created another method Define check
653:29 - uncore Evolution no need for custom
653:32 - parameters and basically we want to
653:34 - check for index and monster in self.
653:39 - player monsters. items we first of all
653:43 - want to check if a monster has an EV
653:46 - ution in the first place for that let's
653:49 - have a look at the monster class so we
653:53 - have quite a few python files at the
653:55 - moment we don't have an evolution value
653:57 - in here so we have to create it self.
654:01 - Evolution this value we are getting from
654:04 - the monster data then self. name and in
654:09 - there we have
654:11 - evolve so if you look at game data and
654:13 - the monster data
654:16 - inside of monster data if you look at
654:18 - the first Monster plumet you can see we
654:20 - have an evolv property with the name of
654:22 - the monster and the level needed to
654:25 - reach that Evolution if a monster has
654:27 - reached the final stage then evolve is
654:30 - going to be none so just to make sure
654:32 - you see what we are getting from self.
654:34 - Evolution let's print the value self.
654:38 - Evolution and if I now run m. Pi we are
654:42 - getting an error because I have to add
654:44 - pass in there but next attempt and now
654:47 - we're getting either none or a tupal
654:50 - with the name of the monster and a level
654:52 - that's looking good if a monster has an
654:55 - evolution we want to check if monster.
654:59 - level is equal to
655:02 - monster.
655:03 - Evolution and we want to get the first
655:06 - index that would be the level so inside
655:09 - of game data we would for example get
655:12 - 15 if we have reached that level we want
655:15 - to the evolution
655:17 - animation for which we want to block the
655:20 - player IE self. player. block and then
655:24 - self. evolution is going to be one
655:27 - instance of the evolution class for that
655:31 - we are going to need all of those
655:34 - parameters frames are going to be self.
655:37 - monster frames and we only really care
655:40 - about the monsters here the start
655:42 - monster will simply be monster. name and
655:46 - the end monster is going to be monster.
655:50 - Evolution with value zero the font that
655:55 - we want to use is going to be self.
655:58 - fonts along with the Bold font end
656:01 - Evolution will become a method that we
656:03 - will create in just a second self. end
656:05 - Evolution that we have to create right
656:08 - away fine and evolution with self
656:12 - following this method we'll set self.
656:15 - Evolution to do none and unblock the
656:17 - player I self. player.
656:21 - unblock finally inside of the run method
656:25 - we want to have one more
656:28 - overlay If self.
656:31 - evolution then self.
656:34 - evolution. update with Delta time and
656:38 - now to test this system if you look at
656:41 - the player
656:42 - monsters there we have Lavia which is
656:45 - level three and inside of game data if I
656:49 - find it really quick there we have Lavia
656:52 - and this one evolves to cleave on level
656:54 - four so we should get this one quite
656:57 - easily which means if I run main. Pi we
657:01 - are getting an error message that there
657:03 - is no attribute
657:05 - Evolution that happened because when we
657:08 - are creating the dunder ined method we
657:12 - don't have an
657:14 - evolution that we can add quite easily
657:16 - at the end self. evolution is going to
657:19 - be
657:20 - none next attempt the game doesn't crash
657:23 - and now if I encounter random
657:26 - monsters I can defeat them really quick
657:29 - and look at laia's level we should be
657:32 - reaching level four and we do and
657:37 - now we do not get anything so something
657:41 - went wrong and well the thing that went
657:44 - wrong is we are not calling this this
657:46 - check Evolution method to fix that we
657:49 - want to look at end battle and instead
657:51 - of an El statement I want to check L if.
657:56 - self do
658:00 - Evolution then I want to unblock the
658:02 - player and self. check
658:07 - Evolution so next
658:14 - attempt and now now we are getting a
658:17 - tinted screen which means that the
658:20 - evolution system does work although at
658:23 - the moment it well doesn't do anything
658:26 - first of all I want to create a
658:28 - rectangle via self. start monster
658:31 - surface and get F
658:36 - rectangle I want to place the center
658:38 - right in the middle of the window which
658:40 - means a tupal with window uncore Wii
658:44 - divided by two and window
658:47 - uncore height divided by two as well
658:51 - after that self. display surface. blit
658:55 - with self. start monster surface and a
658:59 - rectangle and while we are testing all
659:01 - of this to make things a bit easier
659:04 - inside of the dunder init method I want
659:07 - to set the level of Lavia to four right
659:11 - away and also we don't need the dummy
659:13 - monsters
659:15 - anymore and then after we are creating
659:17 - everything else I want to call self.
659:20 - check
659:22 - Evolution that way once the game is
659:25 - starting we are getting the evolution
659:27 - screen right away and at the moment
659:29 - nothing's going to happen but that we
659:31 - can work on at least we can see the
659:33 - Monster also before we continue this
659:36 - print statement is getting a bit
659:37 - annoying in fact I don't think we need
659:40 - the monster class at all anymore next up
659:43 - inside of evolution. Pi
659:47 - we are already displaying a monster but
659:49 - this I want to tint or to be a bit more
659:53 - specific I want to apply a white tint to
659:56 - the surface for that we will need self.
660:00 - start
660:02 - monster surface white quite a long name
660:07 - but basically what we're going to do
660:09 - we're going to get pame dok and then
660:11 - from uncore surface the self start
660:15 - monster surface
660:17 - which we are then going to turn into a
660:20 - surface right away to see what we are
660:23 - getting from that let me blit this start
660:27 - monster surface white right away with
660:29 - that if I now run MP again we are
660:32 - getting something like this a good start
660:35 - but we want to get rid of the black
660:37 - background that is not a problem at all
660:40 - self. start monster surface white then
660:43 - set uncore color key
660:46 - with a black
660:48 - value next attempt and that is looking
660:52 - good now this monster surface should
660:55 - fade in very slowly for which we're
660:57 - going to need two more values self dot
661:02 - tintore amount and self.
661:06 - tintore
661:08 - speed those values I have set to zero
661:11 - and
661:13 - 50 The Tint amount has to start at zero
661:16 - Al do tin speed you can
661:19 - customize after we have that I want to
661:22 - get self. start monster surface white
661:26 - and set the alpha value to self. Tin
661:32 - amount that way it's not going to be
661:34 - visible in the beginning but what we can
661:38 - do when the timer has timed out and we
661:41 - are actually displaying things I want to
661:44 - get self. start monster surface and that
661:47 - would display the monster
661:49 - itself after that I want to get self.
661:52 - tint amount and increase the value by
661:56 - self. tint speed multiplied with Delta
662:01 - time and now that we have that value
662:03 - self. start monster surface white we
662:06 - want to change the alpha of this other
662:09 - surface with self. tint Mount once again
662:13 - or in other words for this white surface
662:16 - we are setting the alpha value in the
662:17 - init method to zero so it's not going to
662:20 - be visible but in the update method we
662:23 - are increasing the tint amount value and
662:25 - then updating the alpha value that way
662:28 - it will slowly fade
662:30 - in that we do have to display bya self.
662:33 - display surface. blit with self. start
662:37 - surface monster white along with the
662:40 - rectangle let's try all of
662:44 - that and the monster is slowly becoming
662:48 - white so Death part is working it might
662:50 - be a bit slow let's change to 50 to and
662:55 - 80 it might be better so now all of this
662:59 - happens quite a bit faster but once
663:02 - again choose whatever value you think
663:03 - looks good in my case I want to go to
663:06 - the next step and that is going to be
663:08 - that we only want to do all of this if a
663:11 - condition is true if self. tint
663:16 - is smaller than
663:17 - [Music]
663:20 - 255 if that is not the case else then we
663:24 - want to display the Evolution for which
663:26 - we're going to need another rectangle
663:28 - which we can get via self. end monster
663:32 - surface and get a
663:34 - rectangle where we are placing the
663:36 - center right in the middle of the window
663:38 - for that we can duplicate those
663:41 - values afterwards self. display surface
663:44 - dolit
663:48 - with self do and monster surface and the
663:51 - rectangle next
663:54 - attempt we are getting the monster and
663:57 - after it gets completely white we're
663:59 - getting the evolution that looks really
664:01 - good once we have all of that we can
664:03 - also get self. timers and the end timer
664:08 - and
664:10 - activated remember for this timer once
664:13 - it times out we are calling end
664:16 - Evolution that way we're getting back to
664:18 - the Overworld although this timer I only
664:21 - want to call if it is not currently
664:23 - running meaning if not self. tim. end.
664:28 - active and with that if I now run main.
664:31 - Pi we're getting the evolution after a
664:33 - short amount of time then we are
664:36 - evolving and then we can walk around
664:39 - again although if you look at the
664:42 - monster index nothing has changed that
664:44 - we can work on in a second
664:47 - first of all I want to finish the
664:48 - evolution
664:51 - screen because I also want to have some
664:54 - text in there that's going to happen
664:56 - inside of the dander init method I want
664:58 - to have
664:59 - text specifically I want to have two
665:02 - text surfaces start text
665:07 - surface along with an end text surface
665:13 - both of those we are going to create bya
665:15 - cell
665:16 - do
665:17 - render where we will need some text then
665:22 - fults and then colors with the black
665:27 - color the text for the start surface is
665:30 - going to be an F string with the start
665:34 - monster and is evolving and make sure
665:37 - that all of this is actually a string
665:39 - and pay close attention here start
665:41 - monster is what we're getting from the
665:44 - parameters we are not actually storing
665:46 - this inside of the class we are turning
665:48 - it right away into a surface or into a
665:50 - piece of text for the end surface I want
665:53 - to have another F
665:55 - string with the start monster and
665:59 - evolved
666:00 - into the end
666:03 - monster that way we have two surfaces
666:06 - that we want to
666:07 - display the first one is going to be in
666:10 - the first if statement where we are
666:13 - still displaying the original monster I
666:15 - want to create a textor
666:19 - rectangle with self. start text surface
666:23 - and get F
666:26 - rectangle I want to place the mid top to
666:30 - rect do mid bottom plus a vector for an
666:34 - offset of 0 and 20 pixels after that
666:37 - self. display surface. blit with self.
666:42 - start text surface and the text rect
666:46 - angle also before we are displaying the
666:49 - text I want to have some background
666:51 - which we will create via py game. draw.
666:54 - rectangle I want to draw on the display
666:57 - surface the color is going to be
667:00 - colors and white then I want to get the
667:04 - text rectangle and inflated by 20
667:07 - pixels and then finally zero for the
667:10 - Border width and five for the Border
667:13 - radius that should be all we need for
667:15 - one part of the text let's try all of
667:18 - that and we get Evolution has no
667:20 - attribute
667:22 - render that happened up
667:25 - here instead of self. render this should
667:28 - be self. font. render the font we're
667:31 - getting from up there and in fact this
667:34 - shouldn't be self at all this should
667:36 - just be font.
667:37 - render next
667:39 - attempt we are still getting the
667:41 - evolution and now we're getting some
667:43 - text as well
667:45 - good start so next up we have to display
667:49 - text in the El
667:50 - statement we can simply copy the
667:52 - original piece of
667:55 - text and paste it in
667:58 - there for the text rectangle I want to
668:01 - get the end text surface although the
668:04 - rest can stay the same then for py game.
668:07 - draw. direct we can keep all of this the
668:09 - same as well and finally we want to
668:12 - display self. end text so surface along
668:16 - with the text rectangle that should be
668:18 - all we need next attempt we get the
668:22 - evolution and after that we get another
668:25 - piece of text and then we can walk
668:27 - around again perfect that nearly
668:30 - finishes the animation for the evolution
668:32 - there's just one more thing that I want
668:34 - to do if you look at the folder for the
668:37 - project in graphics and other we have a
668:42 - star animation this I want to play once
668:45 - we get to the
668:46 - evolution it's not terribly complicated
668:49 - we simply have a whole bunch of stars
668:50 - and that's basically it to play those
668:53 - first of all we will need an import and
668:57 - that happens in the dunder init method
668:59 - under import assets right below the BG
669:02 - frames I want to have self
669:05 - dot star
669:10 - animation underscore frames which we can
669:14 - get via Port underscore folder then we
669:18 - want to go up a folder to
669:21 - Graphics then to other and there we have
669:25 - the star
669:28 - animation let me run the code to make
669:30 - sure this is working and it does that's
669:33 - looking good after that we want to look
669:37 - at check
669:39 - Evolution down there and if a monster is
669:43 - evolving when we are creating one
669:45 - instance of the animation I want to pass
669:47 - in self. Star animation frames that
669:51 - means next up inside of evolution we
669:54 - want to get the star
669:58 - animation frames or I guess we could
670:00 - just call it star frames that's a bit
670:03 - easier for those I want to add another
670:06 - section with this star
670:12 - and in there we want to have self do
670:15 - star frames which is going to be star
670:20 - frames also we will need a self do
670:24 - frame index and before we continue I
670:28 - want to scale up all of the frames
670:30 - inside of this list like we have done
670:33 - for the start and end monster
670:36 - surface which means a list comprehension
670:39 - with
670:40 - pame do transform. scale to X with the
670:45 - frame for frame in Star
670:49 - frames that way the entire thing looks a
670:52 - bit more coherent cool once we have that
670:56 - when we are seeing the final monster I
670:58 - want to run a method called self.
671:02 - display Stars along with Delta time this
671:07 - method doesn't exist right now so we
671:09 - have to create Define display stars with
671:13 - self and Delta time this is just going
671:16 - to be a basic animation I.E self. frame
671:19 - index plus equal some kind of Animation
671:23 - speed I think I went with 20 and
671:25 - multiply it with Delta time and then if
671:29 - self. frame index is smaller than the
671:33 - length of self. star
671:37 - frames we want to get a frame we want to
671:40 - get a rectangle and then self. display
671:44 - so
671:46 - surface with the frame and the
671:51 - rectangle the frame is simply going to
671:53 - be self. star frames with integer of
671:58 - self. frame
672:00 - index the rectangle is going to be frame
672:03 - and get F rectangle that we want to
672:06 - place right in the center of the window
672:08 - which we have already done a couple of
672:10 - times I can copy the line and that
672:13 - should be it if I now run main. Pi we
672:16 - get the evolution and once we are done
672:20 - we're getting an error message this
672:22 - surface is not callable that happens
672:25 - because I forgot to add dot lit so next
672:33 - attempt and that is looking really good
672:37 - everything else also works just fine so
672:40 - I am quite happy with the animation that
672:42 - means we can close evolution. pi
672:45 - and the next important part is that we
672:47 - actually get another monster so we are
672:49 - applying the evolution after the
672:52 - evolution animation I want to get self.
672:55 - player
672:56 - monsters along with the index that we
673:00 - are currently on and with that we are
673:02 - overwriting the current monster which is
673:05 - totally fine because we want to create a
673:07 - new monster with monster
673:10 - dot Evolution and zero I eat the
673:13 - evolution monster and then the monster
673:16 - do level that way if I now run all of
673:19 - this again we get the
673:22 - evolution and at some point we get a new
673:25 - monster if I now open the index we have
673:27 - a whole another monster and to test all
673:30 - of this just a bit more inside of
673:33 - thunder in it I want to set the level of
673:35 - Lavia back to
673:36 - three so now if I am over a grass patch
673:40 - we should still get a battle and I can
673:44 - defeat the enemy
673:45 - quite
673:48 - quickly that part is working and now we
673:50 - get the
673:51 - evolution and then we have another
673:54 - monster and we can continue the game
673:57 - that is working quite well also at this
674:00 - point we shouldn't check Evolution
674:03 - anymore inside of Thunder init and also
674:07 - once we finish fighting a trainer we
674:09 - should check for an evolution which
674:11 - means inside of end dialogue
674:16 - once we have defeated a trainer self.
674:19 - check Evolution don't forget to call it
674:23 - and in the game let's try to find this
674:28 - trainer shouldn't take too
674:36 - long we get some dialogue and afterwards
674:40 - we're getting the evolution this part
674:42 - still works just fine and then and we
674:45 - can once again continue everything cool
674:48 - with that we have the evolution that
674:51 - means we are basically done besides the
674:54 - audio so let's get started with that
674:57 - first of all we have to import a couple
675:00 - of files and that's going to happen
675:02 - inside of import
675:05 - assets at the bottom I want to have
675:09 - self.
675:12 - audio for which I want to have an audio
675:16 - importer with a file path up a folder
675:21 - then we want to go to audio and that's
675:23 - actually it if you look at the project
675:26 - folder inside of audio we have a whole
675:29 - bunch of files that we want to import
675:32 - for that we want to work inside of
675:34 - support. piy and let me minimize
675:37 - everything at the bottom of the Importer
675:40 - functions I want to have an audio
675:43 - importer along with a path and for all
675:46 - of that we have already seen something
675:48 - similar except now I want to have a
675:50 - dictionary with the files then for
675:53 - folder underscore path the subfolders we
675:56 - don't care about so underscore and then
675:58 - we have the file names in walk and
676:04 - join of the path after that we want to
676:07 - look at all of the file names I.E for
676:11 - file name in file names
676:15 - next up we want to create a full path
676:17 - using the join
676:19 - method and then stitch together to fold
676:22 - the path with the file name and once we
676:26 - have that I want to get the file's
676:28 - dictionary and create a new key value
676:30 - pair the key is going to be the file
676:33 - name and this we want to split to get
676:36 - rid of the file ending which means
676:38 - wherever we have a DOT we're going to
676:40 - split it and then pick the first value
676:43 - the value we are going to assign to this
676:44 - key will be py game. mixer.
676:48 - sound along with the full path at the
676:51 - end of all of this I want to return the
676:54 - files dictionary at the end of all of
676:57 - this I can print self. audio run the
677:01 - entire game it doesn't crash and we get
677:04 - a dictionary with a whole bunch of sound
677:06 - files that's a really good
677:08 - start that means we don't need the print
677:11 - statement and we can collapse import
677:13 - Assets Now we have to figure out when to
677:16 - play the sounds and the first sound I
677:18 - want to play is if one of the characters
677:20 - notices the player I want to play the
677:22 - notice sound for that when we are
677:25 - setting up all of the characters down
677:28 - here I want to add a notice uncore sound
677:34 - which is going to be self. audio and
677:38 - notice after that inside of entities.
677:42 - pipe when we are creating the character
677:44 - we need one final parameter notice
677:48 - uncore
677:50 - sound that we want to store all the way
677:53 - at the end self.
677:55 - notice sound is going to be the notice
678:00 - sound after that inside of the
678:03 - raycast once the character sees the
678:07 - player we want to get self. Noti sound.
678:13 - playay and with that if I now run main.
678:18 - Pi we should be able to hear a
678:21 - sound and we do that is working pretty
678:24 - well so that covers the entities we also
678:28 - don't need the Sprites anymore the next
678:31 - important part is going to be the battle
678:34 - there we want to have a whole bunch of
678:36 - sounds that we are going to pass into it
678:39 - when we are creating one instance of the
678:41 - class and this happens in two spots so
678:45 - when we are ending the dialogue we want
678:47 - to have the sounds which we're getting
678:51 - from self. audio this I can copy because
678:56 - next up when we have a monster
679:01 - encounter we want to have the same
679:05 - value and after that we have to make
679:09 - sure that we are storing all of this as
679:11 - an attribute and let's place it all the
679:13 - way at the beginning do sounds is going
679:17 - to be
679:18 - sounds and to make sure you can see
679:20 - what's going on let me print what we are
679:22 - getting self do
679:26 - sounds if I now run main. pi and we are
679:30 - getting into a
679:32 - fight the game doesn't crash and we can
679:34 - see a whole bunch of
679:37 - sounds now for the battle the only
679:39 - sounds that we are going to use are
679:41 - going to be for different attack moves
679:43 - for example we have fire we have ice we
679:46 - have green for healing and then a few
679:50 - more the way this system is going to
679:52 - work if you look at game data and hide
679:55 - everything besides the attack data every
679:58 - attack has an animation for example
680:01 - there we have fire green scratch and so
680:03 - on the name of the animation is also
680:06 - going to be the name of the sound we
680:07 - want to play so if we have the fire
680:09 - animation we also want to play the fire
680:12 - sound fairly straightforward
680:15 - when we are applying an attack that
680:18 - happens down there right below the
680:21 - attack Sprite we also want to get self.
680:25 - sounds and then get the attack data Al
680:31 - with the attack and then we have I call
680:34 - this one the animation that way we get
680:37 - the name of the file we want to play and
680:39 - well this we want to play if I now run
680:43 - main. pi and and we can get into a
680:51 - fight that sound is working and the fire
680:55 - sound is working let's try one more for
680:59 - ice that is also working cool so with
681:02 - that we have all of the sound effects
681:05 - that leaves us only with the background
681:07 - music and that we have to work with
681:10 - inside of the game class so we don't
681:12 - need battles support or game data first
681:15 - of all in the dunder Ed method after we
681:17 - are doing all of the
681:19 - Imports I also want to self. audio and
681:24 - get the Overworld and play that one also
681:28 - for an argument I want to add a negative
681:30 - one to play this one
681:32 - continuously the argument we're
681:33 - specifying here is for the loops if you
681:36 - set this to five You'll Play the audio
681:38 - five times a negative 1 plays it forever
681:47 - cool that is working well so with that
681:49 - we have an overwhel sound that means we
681:52 - don't need Dunder in knit anymore and
681:55 - next up if we are ending a dialogue and
681:59 - then starting a
682:01 - battle we want to do two things number
682:04 - one we want to get self. audio with the
682:08 - Overworld and then stop that track on
682:11 - top of that I can actually duplicate the
682:13 - entire line
682:15 - because we now want to get the battle
682:17 - music and play it once again with
682:21 - negative one so we are playing this
682:23 - continuously also this we have to do for
682:26 - the end dialogue and for Monster
682:30 - encounter meaning before we are starting
682:32 - the battle we want to stop the Overworld
682:34 - Music and start the battle sound let's
682:37 - try all of that
682:39 - [Music]
682:56 - okay this works reasonably well but once
682:58 - the battle is over we do not stop the
683:00 - battle music for that we want to look at
683:03 - end battle and then once the battle is
683:07 - over we want to get self. audio battle
683:12 - and stop the music after that that is
683:14 - the case we want to check if we have an
683:17 - evolution then we want to play The
683:19 - Evolution sound if not we want to play
683:21 - the Overworld sound for that we want to
683:24 - look at check Evolution and if there's
683:28 - an evolution we know that we have a
683:30 - value for self.
683:32 - evolution however if we don't have self.
683:37 - Evolution then we simply want to get
683:39 - self. audio the Overworld
683:44 - and play that one on the other hand if
683:47 - we do have an evolution then inside of
683:50 - this if statement I want to get self.
683:53 - Evolution and play that sound finally
683:56 - then inside of end Evolution I.E the
683:59 - evolution has finished we want to get
684:02 - the overwat sound and play that one with
684:04 - negative one this should also happen up
684:07 - here and on top of that we want to get
684:10 - the evolution sound and stop it
684:15 - and I usually put the stop sound before
684:17 - the play sound that just feels a bit
684:19 - better and I think that's it if I now
684:22 - run all of this again
684:24 - [Music]
684:49 - all right and that part is working as
684:52 - well so with that we have the entirety
684:55 - of the game and this was a longer
684:58 - tutorial I hope you found it useful and
685:00 - I'll see you around

Cleaned transcript:

n hello there in this tutorial we will create a Pok√©mon inspired RPG in there you can explore an Overworld full of characters and you can fight trainers and wild monsters the battle system is also quite complex you are able to choose a range of attacks switch monsters and even catch Wild Ones the entire thing includes a lot of animations and visual details to make it look nice also monsters can level up and evolve they also learn new attacks on some levels to visualize all of that information there will be a monster index that shows you the attacks stats and abilities of all of them all combined this will become a fairly large tutorial but you are going to learn how to organize complex projects how to manage databases and how to build your own user interfaces from scratch skills that can be incredibly useful now creating these projects requires a broad range of skills for example in this game I have relied heavily on Vector math and geometry if you want to practice these Concepts more thoroughly check out the sponsor of this video brilliant.org they offer courses on all of these Concepts that are full of interactive lessons and HandsOn problem solving skills not only is this approach uniquely effective at learning it is also much more fun than just passively reading a book or watching a lecture it is also really good at getting you to build problem solving skills since this is what you will doing from day one on top of that all of the content has been made by awardwinning teachers researchers and professionals with industry experience you can access brilliant via a website or an app and spending just a few minutes on it every day will help you learn a lot so instead of scrolling idly on the bus or at the gym you can build a powerful habit that will make you a more competent thinker brilliant also recently added a lot more content like programming with python data visualization and how llms work and they regularly add more content if you head over to brilliant.org clear code you can get 20% off a subscription and the first 30 days are free so not much to lose and if you subscribe you also help me make more videos so thanks again to brilliant for sponsoring this video let's get started with the game and the first thing that we need is the Overworld with all of the characters this will include a lot of imports since we have to to cover quite a bit of artwork so I suppose let's start by looking at the project folder in which we have four subfolders audio code graphics and data the only folder that we will work in is the code folder this one actually already contains a few python files I will talk about them once they are needed besides that we have a data folder with a whole bunch of tiled Maps those store the various layouts of the Overworld finally the graphics folder contains well all of the graphics it's probably a good idea to have a quick look at all of these files just so you have an idea of what we are working with although I will also talk about it when we import them into pame you can get the start folder and the folder for each stage of the tutorial on GitHub and from Google Drive just check the video description now to get started I want to go to the code folder and open main.py and settings.py here we are inside of m.p and at the moment nothing is really happening we are simply importing everything from settings let's have a look at that one all the way at the top we have a couple of imports the most important one is py game but on top of that we are importing from py MAF a vector 2 as a vector for this project we are going to rely very heavily on vectors so I want to have them available quite easily this part isn't strictly necessary but it makes our life a bit easier finally from CIS import exit is going to be used to close down the game later on after that we are defining a couple of basic constants like the window width and the window height the tile size the animation speed and so on none of this is too complicated or at least I hope it isn't after that we have a couple of dictionaries for example this one defines all of the colors in the game these dictionaries aren't too important for now so don't worry too much about them I'll cover them in more detail later so that's the basics of settings. Pi although before we continue there's one really important thing for this project I am going to use py game C or pame Community Edition not the regular or traditional pame that is because there are two versions of pame the traditional pame and py game c and the version that you want to use is py game CE this one has frequent updates it has more features it runs faster and it is 100% backwards compatible there really isn't any reason to use the old py game anymore and if you want to install it you either go to the Powershell or The Terminal and type pip install py game CE that's all you need to install it in my case I already have it installed so I don't have to do it now the one important thing you want to keep in mind is that inside of python you are importing pame and pame C in the same way both are imported with import py game that is important to ensure backwards compatibility for pame C but if you have both versions installed then this is going to cause some problems so I would recommend to get rid of the old pame entirely and only use pame C you are retaining all of the features and you get some additional ones so you're not losing anything and all of your old projects are still going to work just fine righty with that we have the setup that means we can work inside of main.py and create the basic game class let's call it class game no need for inheritance but we will need a thunder init method in which we first of all want to initialize py game with pygame do init next up we will need a display surface let's call it self. display uncore surface this one we are creating with py game. display. set uncore mode this one wants to have a tupile with the window WID and the window height which we are getting from the settings there we have window Wii and window height and those we want to pass into a tupal inside of set mode also while we are here we can set a window title with py game. display. setor caption and to make sure that I am not getting sued let's Call it Monster Hunter cool with that we have the basic setup next up we want to have a run method in which we are going to run the game Loop meaning while true then we want to get an event Loop and we want to run the game logic the event Loop is fairly simple for event in py game. event. getet at the moment the only event that we care about is if event. type pame dowi if that is the case we want to run pame do quit and the exit method that we are getting from settings this one that way we are able to close down the game after that inside of the game logic at the moment we can't really do anything but I want to set py game. display. update so we're making sure that whatever we are drawing inside of this run Loop is going to be displayed and that is it to get started all we have to do now is inside of the global scope check if Dunder name is equal to the string Dunder main so we are checking that we are in the main file if that is the case we want to create one instance of the game class and on that class called the run method if I now Run the game we should be seeing a window and there we go that looks good we can also close it so all of this is working just fine oh and by the way if you have no idea what these terms are so if you don't know what a display surface is or what an event Loop is I should mention that this tutorial is for more advanced users I will already assume that you have a basic understanding of P game G if you are entirely new to it check out my ultimate introduction to pame this one is going to cover all of the basics the next part that we have to work on is going to be the Imports for the level and for that let's have a look at the project folder in there we want to look at data and then there we have all of the maps those contain the data for every level inside of the game and the most important one is world. TMX and by the way all of the files have been created en tied which is an open Source map editor if you have that one and you open a map there you can for example see the Overworld now for this tutorial you don't have to know tiled in too much detail although if you want to expand the game on your own you should probably know the basics of it and I have made a tutorial specifically on it so check this one out if you are interested but the basic gist of it is if you look on the top right there we have a whole bunch of layers like terrain terrain top entities and so on the layout that we care about for now is called terrain so let me hide everything else like so this is going to be the background for the level and this is basically a grd if I go to view and show GD you can see we are simply dragging from the layers specific Graphics into a position I could for example select this mountain and then place it in these positions that's all that's happening in here here so ultimately what we want to do is import all of these graphics and then display them via py game so inside of py game I want to create two more methods the first one is called import assets no need for custom parameters and in there we going to import all of the assets for now the only one that we really care about is going to be self. TMX maps and this is going to be a dictionary with key value pairs where we have a world and then an Associated TMX map now to import this TMX map we need a specific python module or rather one specific part of a custom module we want from PMX do _ pame import load uncore iame PMX is a module that is really good to import TM X Files into py game and this specific method that we are looking for is called load py game now if you run the code you should not be getting an error message from this line if you do you have to install PMX which you do inside of the Powershell you want to type pip install py TMX and that's all you have to do with that we can import PMX maps and we using this with load py game and then a file path in our case we want to go upper folder then we want to go to data in there we have the maps and in there we have world. DMX so if you look at a project folder we are starting inside of the code folder in main.py then we want to go up to project to data maps and then world. TMX that is the relative path we have just created that being said approaching file paths like this isn't ideal because some operating systems use a forward slash others use a backward slash and if you have a hardcoded relative path this might cause some problems to fix that we can use another python module from os. paath import join and all that join does is it creates custom paths the way you use it is instead of one hardcoded path you simply specify the folders or the notes you want to go through you want to go up a folder then we want to go to data then we want to go to maps and finally we want to go to world. TMX and that is all we need those two things for windows are basically going to be identical but depending on the operating system you might get a different kind of slash now we don't need the original path anymore and we can print self. TMX maps on top of that inside of the done ended method I want to run self. import assets if I now run the entire code after a second we are getting a dictionary with a tile map so that is looking really good that means we don't need to print statement anymore and next up we can create a setup method which is going to need two custom parameters the first one is the TMX map that we want to use the second one will be the player start position later on this setup method is going to load different kinds of levels depending on what TMX map we are putting into it but for now we only have a single one so this one isn't too complicated all that we want to do for now is Loop through one of the layers of our TMX map and if I open tiled you can see that the one layer we care about for now is called terrain this is the one that we want to import we getting that with TMX map and then get underscore layer uncore byor name the layer name for this one is terrain and it's essentially going to be a list with all of the positions and the images that we have laid out inside of til although to access all of that we need dot tiles afterwards with that we can put this data inside of a for Loop for x y and the surface in this particular layer that way we can print x y and the surface and we would get access to the position so X and Y and the surface and that is all we need in the setup method for now so next up we can call self. set up with two arguments the first one is the TMX map which we get with self. TMX maps and this one has the key world the one we have just created the player stop position doesn't matter too much but later on this is going to be house if I now run the code we can't see anything but we are getting positions and then a surface and quite a few of those the way to read this information is the surface is simply the graphic that we have placed and then the numbers next to it are going to be the column and the row keep in mind for this one we are at the moment working inside of a grp we do not have pixel positions or in other words if we are inside of til I can zoom out and if we go all the way to the top left this tile here would be tile zero and zero the one to the right of it would be tile one and zero or in other words x would be one and Y would be zero that would be the position inside of the grid but it's not a pixel position since our tile size is 64 pixels this tile would start 6 64 pixels to the right of the origin Point that's an important thing to keep in mind and something that we want to use right away so instead of using X and Y we want to multiply both of these values with the tile size that we are getting from the settings and there we have tile size I want to multiply X and Y with the tile underscore size and then we should have the correct position if I run this again you can see that we get much much larger numbers and that does look quite a bit more accurate so ultimately our map is going to be 4,500 by 4,900 pixels so with that we know what graphic we want to display and where to display it but we don't actually show it and for that I want to create a Sprite Which I'm going to do in a new python file let's save this one as Sprite dop and first of all in there we want from settings import everything and then I want to create a class called Sprite Which has to inherit from py game. sprite. Sprite and be careful on this one about the spelling the second Sprite should have an uppercase s inside of the Sprite we want to call a thunder inage method and then Define a couple of basic parameters we for now want to define a position a surface and the groups after that we want to Calla super Dunder init to initialize the parent class and then pass the groups in there as an argument in case you don't know how Sprites work you should really check out the basics of py game but basically a Sprite is a simple class that contains a position rectangle and a graphic that we are placing inside of a group then via the group we have updating and drawing the Sprite to make all of that work we have to Define self. image and self. rectangle the image is simply going to be the surface that we getting from the parameters meaning we are simply passing this thing right through and saving it as a parameter for the rectangle we want to get self. image and then get underscore F rectangle where we are defining the top left and setting this to the position that we are getting from the parameters once again and I should mention get fct is short for G floating Point rectangle which is something unique to pame C if you're using the traditional pame this would get you an error hence make sure to update the reason why you want to use a floating Point rectangle is because in the traditional rectangle you are storing all of the points via integers for example the top left could be a position of one and two two very simple numbers and importantly those are both integers which are a good start but very often you want to be a bit more precise and for that you want to have floating Point rectangles which work exactly like the old rectangles except now you can store floating Point values for the position so the top left could be for example 1.5 and 2.13 significantly more precise and that's basically the entire difference but this ision can be incredibly useful so I would generally recommend to use floating Point rectangles but anyway with that we have a basic Sprite inside of main. Pi first of all we want from Sprites import the basic Sprite after that inside of the dunder init method let's do it all the way at the top we want to create a whole bunch of groups or Well for now we only want to create a single group self. allore Sprites which is going to be pam. sprite. group this group all Sprites is going to contain well all of the Sprites or at least all of the visible Sprites and then via this group we're going to display and update all of these Sprites so after we have that inside of the setup method when we are looping through all of the terrain tiles I want to create a Sprite and then we want to get a position a surface and a groups let me paste it in position is going to be a dupal that we have just created with X multipli by tile size and Y multiplied by tile size the surface is the surface we are simply going to get from the for Loop I.E we are taking this surface and we are passing it into the class finally for the groups we only have a single group self. all Sprites and with that we have a basic Sprite if I now run the code we getting an error message that's a good sign but we still can't see anything the reason for that is that we have to draw this all Sprites which is going to happen inside of the run method before we updating the screen we want to run self. or Sprites do draw and the argument we have to pass in there is the surface we want to draw on in our case we want to draw on self. display surface if I now run the code we can see the top left of the map so if you look at til we are currently drawing this top left part more or less and I realized there's one graphical issue this part here that isn't looking correct that we can fix right away so I want to select this one tile and then place it in there and that looks much better if I now save the tile map go back to my code editor and run all of this now we have fixed this corner much better that covers the basic Imports but that's still not really useful simply because we want to display more than this top left corner we have a huge map that we want to display to make all of this visible we have to create a basic player along with a camera to create the player I want to create a new python file and save this as entities. Pi besides the player later on we are also going to store all of the other characters in there but that is going to come later but now I first off I want from settings import everything and then create a class called player like the Sprite this one has to inherit from py game. sprite. Sprite and then we will need a thunder in it method with self a position and the groups for now after that we will need Super Thunder init along with the groups after that we will need self. image and self. rectangle the image isn't too important for now later on we are going to have proper graphics for now I simply want to create pame do surface with a size of let's say 100 by 100 also this self. image I want to fill with a color so it looks a little bit better let's say red for the rectangle I want to get self. image and getorf rectangle where I am setting the center to the position that we're getting from the parameters with that we have a basic player that is very similar compared to the Sprite we have just created which means inside of main.py I can from entities import layer and then we can use that class inside of the setup method although for that we need another for Loop because the player is not inside of the terrain layer if you look at all of the layers inside of til we have one object layer called entities and you know it's an object layer because of these purple dots next to it if you enable that one you can see two things oh well you can see all of these markers those can do two things if you look on the left side a name could either be player or a name could be a character a character would either be a trainer or a hospital nurse but now we don't really care about either we only care about the player notes and if I display all of the objects they're going to make a bit more sense so for example this note here for the player would be the start position if we just came from the planned Arena and if we go for example to this point it is Hospital 2 and the marker right in front of it would be the start position if the player just came from this Hospital 2 and so on basically we have a whole bunch of start positions for the player and the one that we want to start with is is this one which at the moment is not in the right position it should be in front of this house inside of your project it should have been in the right position I was simply testing things this should be the starting position for the player where we have a position so house and the direction that way we can identify this particular marker now inside of the code first of all we have to Loop through this particular layer from tiled and since we have an object layer we have to approach this just a little bit differently compared to the styled layer instead we want for obj in TMX map do get layer by name and the name we want to look at is called is enter no need for DOT tiles afterwards and now we could print obj if I run the code we are getting a print out of all of the objects on this layer we have a name either player or a character at the moment we only care about the player once which means we want to run some code if objname is equal to player if that is the case for now let's say I want to print the object node so if I run all of this we are only getting all of the player start positions that's that's a good start now from this object we can get quite a bit of information for example we can get X and Y for the position or we can get the properties that we have to find if you look at til the custom properties I'm talking about are in this case the direction and the position direction for now doesn't really matter the one that we care about is the position and this one would Define where the player came from this case the starting position would be the house or this house to be a bit more specific if you go to another start position this one it will be planned for this planned Arena now back in the code when we are calling the setup method early on I have passed in the house for the starting position and we basically want to look at all of the objects and then find the object that has the custom property house for the position to get that one we want to get the properties and then look for the position if I run the code like that we can see we have all of the starting positions and the one we care about is the house which means to single out this one object we want to expand this if statement if obj name is player and obj do properties with the position is equal to the player start position if that is the case we want to get obj dox and obj doy I can now run the code and we should only be getting one position that looks really good perfect that also means now that we have a position we can start working on the player because this one needs a position and groups both of which we have meaning I want to create a player objx and obj Y will be the position and then for the groups I want to have self. all Sprites and if I fix my typo this should also work if I now run the code we are not getting an error message but we also cannot see the player simply because at the moment we are only displaying the top left of the map and to see the player we have to create a camera that being said inside of til if you move this player start position all the way to the top left like this save the tile map return to pame and then run this again we can see the player so this one does indeed work which means we have everything we need to get started with the camera although before that there's one more thing that I would like to do the player should be able to move around without that the camera is going to look a little bit weird now moving around is going to involve two parts number one we have to capture input let me add a pass in there for now and the second part is is going to be the actual move method which will need self and Delta time I'll explain that one in just a second although for now I will simply add pass in there to get started with input we first of all want to get all of the keys being pressed which we get with pame dokey. getor pressed that we can use for example via keys and py game. Kore up which is a constant inside of pame that tells us that we are pressing the up Arrow key if that is the case I want to for example print up and that logic should be sound but we have to call the input method for it to work in the first place and that we do via an update method which for now is only going to accept self as a parameter in there we want to call Self do input now to call this update method we have to look at the all Sprites group because this one can draw all of the Sprites and it can call the update method which is quite easily done before we are drawing all of the game logic we want to get self. all Sprites and then call the update Method All That update is doing is it looks at all of the Sprites inside of all Sprites or whatever group you have and then call the update method in our case this will only apply to the player because the Sprites do not have an update method but other than that if I now run the code we are getting an error that inside of pame I have a typo this should be py game if I now run all of this and I press the up Arrow key we can see up so that is looking really good we can now capture keyboard input we just have to use it inside of the game and the way I usually approach that is by first of all creating another Vector that I call input Vector which is simply going to be a vector without any values the default value for a vector is zero and Zer for X and Y meaning if if you simply create a vector like this you're getting zero and zero this Vector I want to update for example if we press the up Arrow then I want to get the input Vector update Y and subtract one from it all of this I want to copy because next up we want to check the down arrow if that is the case we want to increase y by one I can do this once more next up we want to look at left and if that is the case we want to get the export of the vector and reduce it by one finally we want to walk to the right which means we want to increase X by one the end result if I print the input vector and run main. Pi you can see if I press different arrows on my keyboard we are getting the various directions so that's looking really good one thing that I do want to mention before we continue this input Vector is quite important because it gives us a blank Vector with values of 0 and zero that way whatever we're doing here simply gives us the keyboard input and nothing else if the input Vector already had any other value this would cause some problems hence I want to keep this inside of the input method and not have anything else influence it but that causes another issue because we're getting the input in there but we want to use it inside of the move method to actually move the player I.E we have to connect these two and this I do via another attribute of the class that I'm going to call self. Direction which by default is going to be another Vector now after we're doing all of the input I am updating self. Direction and set it to the input Vector that way we can use Direction inside of the move method and I think for now we don't actually need Delta time so let me get rid of it to move the entire Sprite all we really need to do at least for now is self. w. Center plus equal self do Direction multiplied with some kind of speed for now let's go with 250 and that is it if I now run self. move after the input run may not Pi again I can move around but you can see that the player is moving way too fast fast if I run this again and simply tap right once we are going way too far to the right I suppose if I reduce the speed to something like five and that is looking significantly better at least now we can see the player movement this is still not ideal simply because this update is not frame rate independent that means inside of the game we have some kind of frame rate that we can actually measure via a self. loock which we get with py game. time. clock that clock inside of the game Loop we have to call self. clock. Tick this simply tracks the frame rate and once we have that we can measure the frame rate and print it out self. clock doget uncore FPS and don't forget to call this one if I now run all of this you can see that our frame rate is around 250 frames a little bit more than that meaning we are running this while loop 270 times per second and then apply this update to the player position by the same amount so 270 times per second we are changing the center of the player which is fine on its own however it does not work when the frame rate changes which we can emulate by adding an integer into the tick method if you leave it empty the game tries to run as fast as possible but if you add a 60 in there then our frame rate is going to be 60 and now our player is going to move significantly slower which is not ideal our movement problem at the moment is that the game tries to run as fast as possible and then update the player position since we are doing this by default very often the player is going to move really fast however some levels especially the smaller ones like the hospital are going to run even faster because we don't have to render as many elements not to mention that the game is going to run on a variety of computers some more powerful than others and because of all of that the frame rate of the game is not really going to be predictable on some computers it might run at 30 frames per second on other computers you might get a thousand frames and we want to account for all of that and that we are going to do via Delta time or DT in short now I am not going to cover Delta time in detail in this tutorial that being said I have made an entire video on Delta time so check this one out if you want to learn about all the details essentially we want to run our game as fast as possible no arguments inside of the take method and then capture the return value of the take method and stored inside of DT this DT is now going to give us the time difference between the current frame and the last frame or in other words how long it took in seconds to render the current frame and this we want to have in milliseconds at the moment we have all of this in seconds so we want to divide it by a th since they're 1,000 milliseconds in a second and just to print out what we are getting I want to print Delta time run this entire thing again and now if I run around for a bit you can see on the last frame we had a frame rate of 270 and a Delta time of 0.003 which means that it took my computer about 0.003 seconds render the current frame which by itself isn't particularly useful but we can use that information inside of the update method so I want to pass it in there although for that to work inside of the update method in the player we have to create another parameter Delta time which we then want to pass into the move method so now we can recreate the Delta time parameter basically all we have to do to use Delta time is to multiply it with the update of the movement and now I can use a speed of 250 again because if I run main. Pi even though our speed is 250 we are moving at a reasonable speed which is going to be the same speed regardless of the frame rate if I set for example the frame rate to 10 really low we are still moving at the same speed now the game is going to look really choppy because the frame rate is terrible but the actual movement is the same cool so with that we have some very basic player movement that's all we need for this part which means next up we can work work on an actual camera because at the moment the player can simply move outside of the window and then it disappears so we want to create a camera to follow the player and the way that works in pame is by creating a custom group for that I'm going to create a new python file that I want to save as groups. Pi and there first of all we will need from settings and I want to import everything then we can create a class called all Sprites which needs to inherit from pygame dos sprite. Group after that we will need it under init method with self and nothing else for now the only thing that we will need in there is super Thunder init to initialize the parent class and with that we have basically created a copy of the inbuilt Sprite Group which means inside of main. Pi I can from group import all Sprites and then instead of assigning py game. sprite. group to all Sprites I can simply assign it all Sprites if I now run out of this we cannot see a difference the game runs just as before that being said we are now able to customize the drawing logic basically what we want to do we want to create a custom draw method which by default will need self and a surface to to draw on so this draw method is what we are already using down here so if I don't to anything in there and simply add pass I can run main not P again and now we can't see anything anymore simply because this draw method doesn't do anything to recreate the default Behavior we will need a for Loop for sprite in this one would give us all of the Sprites inside of this group self is going to return all of the Sprites that are contained inside of it now by default all that pame really does in there is it takes the surface and then runs the blit method with sprite. image and sprite. rect I can now run all of this again and we get the default behavior that looks good except now we can customize this quite a bit more for example in our case we always want to draw on the display surface meaning we don't really want to pass a surface in there instead in the dunder init method I want to get self. display uncore surface which I'm going to get with py game. display doget uncore surface only on this surface do I want to blit all of the Sprites because of that I don't need the surface parameter anymore I want to get rid of it in there and then inside of main. pi as well if I now run the code everything still works just as before that's the first step the next one that we need is to offset all of these Graphics by default we are placing the Sprite image always in the position of the rectangle but that we don't have to do for example we could Define self. offset which would just be a vector and let me add in a default value let's say 100 by 20 that value I can use to offset all of the Sprites which I'm doing by getting the top left of the rectangle and then adding self. offset I can now run my not Pi again you can see that we are drawing Everything 100 pixels forever to the right and 20 pixels further down which means all that we really have to do is somehow connect this offset to the player position so that we are always centering the player for that first of all we need to get access to the player itself which I want to do via a parameter let's call it player uncore Center that we can get inside of main.py although for that we will have to store the player inside of an attribute self. player is going to be the player that way inside of the draw method I can get self. player. rec. center after that inside of groups I can update self. offset let's say for now self. offset dox is going to be player Center and zero remember this player Center is a tup with X and Y which means to get the offset y we want to get player Center one also by default the offset shouldn't have any values if I now run m not Pi again and I move the player around we are getting something this isn't working perfectly yet but well we are making progress the way you want to approach all of this if this is the entirety of the window our offset position by default is going to be in the top left or Zer and zero we want the player to always be in the center of the window which means this offset point should have a distance to the center of half the window width like this and then half the window height on the vertical axis like this which means on the X part I want to subtract window on _ WID divided by two and then on the vertical axis I want to get window height and now if I run this again we are getting something well that is working a little bit better the only thing that's left to do is to get the negative value for both of these let me put it inside of parentheses and then add negative now all of this is going to work just fine so that is looking much better I can move around freely the camera is working now the reason why we have to get the negative values is imagine once again we have the window we have the player in the center and then we have a whole bunch of tiles around it let me just draw them in something like this and there are some elements outside of the window all that the camera is really going to do if the player is moving down we are moving all of the elements up by the same amount or in other words we always want to move the camera in the opposite direction compared to the movement that way we keep the player in the center of the window and well that is all we need to get started with the camera which means back inside of til I can move the starting position of the player back to the original Point here is and now inside of main P we are starting in a really nice spot so that is working much better although you can see if we go outside of the map everything still falls apart that is because we are not filling the background what is happening here is that py game doesn't discard the previous frame it simply draws on top of it because of that we're getting all of the fragments if we're not filling the background that is an issue we can fix quite easily before we are drawing all of the Sprites using the draw method I want to get self dot display surface and then fill it with a black color I can now run this again and now we don't see the fragments anymore which is feeling much better now later on we're going to fill this area with a coastline and with water and the player is never going to see the black background simply because we're going to have collisions for example here with the rocks and the player will then not be able to see any of the black areas but that's a problem for later and I think this part has gone on long enough so let's do an exercise and then we have finished with this part what I want you guys to do is number one place all of the objects from til and make them visible inside of P game in other words if you look at TI we have an object layer called objects which contains all of the houses trees rocks and so on this one is quite extensive I want you guys to display all of these elements inside of the game after that import the hospital TMX map and also display all of the tiles on the terrain top layer inside of til you want to open hospital. TMX this one contains a level very similar compared to the Overworld I want you guys to launch this level inside of the game and also we have terrain top which contains the countertop thingy this I also want you guys to display inside of the game this is going to take you a little bit of time so try to go through it slowly and if you can't do it don't worry too much about it I will go through it in just a second pause the video now and try to figure this one out on your own to get started I want to work inside of the setup method and add a few comments to make this thing a bit more readable we have the terrain tiles and then we have the entities besides that I also want to have the objects which we're getting via another for loop I want to have for obj in TMX map doget layer by name the layer name for this one is objects all we want to do in there is to create a Sprite at least for now which like before is going to need three arguments position surface and groups the position we can get from obj dox and obj doy the surface we get from the object as well obj do surface the surface we can get from the object as well obj do image and finally for the groups we only have a single one self. all Sprites and that should be it if I now Run the game we can see all of the objects now this isn't perfect for example this tree is on top of the house and also if you go a bit further down we have a few more issues so this isn't working perfectly yet but it's good enough to get started which means we have covered the first part so next up I want to work on the hospital first of all for that we have to import it inside of import assets I want to add a second entry to the dictionary and let me do this over multiple lines in fact I can duplicate all of this and add a second key value pair the key is going to be hospital and we want to import data maps and hospital. TMX after we have that inside of the setup method I want to load TMX map and Hospital although if I run the code now we are going to get an error that game object has no attribute player that is because inside of the hospital we don't have a house starting position to get the actual starting position you want to look at tiled and then the entities let me hide everything else this marker is going to be the starting position of the player and that position is called World which means for this part we want to start the player in the world position if I now run the code we get the hospital hit so that is working pretty well there's just one more thing that we have to do we want to display terrain top this one contains the counter on top of all of the other tiles so that part is going to be fairly similar compared to the terrain which means we can literally copy the entire four Loop and then change the layer name to terrain pop if I now run all of this we have a counter that is later going to have collisions now that being said there's one important thing you do want to keep in mind for all of this and that is the drawing order at the moment we are sorting all of the Sprites by the time of their creation which means the terrain tiles were created first so they are always at the bottom then we are creating terrain top then the objects and then the entities meaning the entities are always on top of everything else however if I create ter top before the terrain and run this again we cannot see terrain top anymore that is because the terrain is now on top of the rain toop which shouldn't be the case now later on we going to create a much better system to sort all of the spres in fact if you look at settings there we have World layers this one we will later on use to sort all of the Sprites but for now that's a bit more advanced and we don't have to worry about it too much the one thing you want to keep in mind point is that you want to have the terrain tiles first then terrain top then objects and then the entities if you couldn't see some Sprites that was probably the reason but all right with that we have a basic level set up there's just one last thing that I want to do to clean this thing up just a bit because we have two four Loops that basically do the same thing that we can simplify with another for Loop we want for layer in and then we have the rain and ter rain pop which needs to be a string inside of this for Loop we want to have the for Loop that actually creates the Sprite except we don't want to have the terrain name we want to have the layer that way we shouldn't need the second for Loop anymore and now if I fix my typo this should be terrain all of this should also work just as before and that looks really good cool perfect with that we have covered the basic outline of the level the next major part are going to be the Overworld animations specifically we want to have a coast animation and a water animation that is going to make everything look significantly nicer for these animations we have to go through two steps the first part is the actual animation itself and this part is fairly easy inside of a Sprite we're going to store multiple surfaces and then cycle through them for example we could have four Sprites like this and we we are simply going to play one after the other and that way we are getting an animation what is actually a bit more difficult is to get all of the data because for these animations we have to import a lot of data and this we cannot do manually so we want to create a couple of functions to mass import data and that is going to be the main part of this section as a matter of fact we already have a couple of functions ready but step by step first of all let's have a look at the project folder in there we want to look at graphics and for now we only care about the water animation and the coast animation I want to start by looking at the tile sets and in there we have a folder called water and then a graphic called Coast those two we want to work with and they are different styles of graphic if you look at the water folder we have four graphics and if you combine them you get a water animation besides that for the coast we want to import all of this and then take it apart if I make this full screen the way you want to think about all of this is we have a tile here a tile here a tile here and a tile here and if you play all of those in sequence so with 0o 1 two and three then you would get one Coast animation or this style of Coast if you then go a bit further to the right you can import all of the center tiles and get another kind of animation for the same Coast type but for a different section of the coast so when we are importing this graphic we have to take it apart and then store it in a way that is more easily usable that will be the most complicated part of this section although ultimately it's not going to be too hard back inside of the code I want to first of all go back to the Overworld meaning TMX map. world and the start position is going to be house if I now run the code we are back in the overw world and we can move around that still looks just fine with have that covered we have to talk about the Imports and for that we actually have already a python file so in my case I want to open up support. Pi in there we have five functions that take care of the Imports the first one is the easiest one this one simply Imports a single image and there are two things it simplifies number one when we are creating the path for the import we are using the join method meaning this is going to work across operating systems without a problem and on top of that we are also specifying a default format so when you're using this import image it's a bit easier to use than py game. image. load not terribly but it's a bit more convenient after that we have import folder and this one basically goes through a have and then Imports all of the images inside of that folder now for this function we are only storing the surfaces but if you want to retain the name you would look at import folder dictionary this one stores the file name and the actual Surface after that we have import subfolders this one goes through a folder with lots of subfolders and then Imports all of the images inside of each subfolder and finally we have import tile map This One Imports a tile map and slices it up depending on how many columns and rows we have now these functions I am not going to explain in too much detail because I have made a separate video on them so if you want to know all about them check out that video but for now I want to work with import folder because if you look at our title set folder inside of Graphics there we want to import the water folder this one simply contains four surfaces and we don't really care about the inside of main.py I first of all want from support import everything and then in the import assets method create another dictionary self. Overworld uncore frames for the key I want to go with water and for the value I want to use import underscore folder the function function I've just talked about this one and then we have to specify a path with comma separated values we want to go upper folder then we want to go to Graphics in there we have a folder called tile sets finally we have the water folder so the folder path we have just specified is upper folder Graphics title sets and water if I now run the code we not getting an error message that is a really good sign on top of that I could print self. Overworld frames and if I then run the code we are getting a dictionary with one key called water and the associated value is a list with surfaces these are going to be our water surfaces so this one is working just fine now we have to figure out how to display them and for that we will need a new type of sprite animated Sprite Which will need to inherit from the Sprite we have already created IE this Sprite will be the parent class of the animated Sprite Which means when we are creating the dunder init method with self we will need a position surface and groups to also satisfy the parameters of the parent class which we are doing by calling super Thunder init then pass in the position surface and groups that way we would simply duplicate the Sprite although that's not actually what we want to do instead of a single surface for animated Sprite we want to have a list of surfaces that I usually call frames and then when we are initializing the parent class so the Sprite I want to get frames and for now use the first item inside of the list now that is not going to create an animation but at least with that setup we will not get an error message so we can get started with this class right away which means next up inside of tiled we have to figure out where water actually is and for that we have another layer called water if I make this one visible you can see we have a whole bunch of objects that are going to Define where water is all of those are going to be rectangles in various sizes the way we are going to use them is we are always going to separate each area for example this would be one area that we are going to import a simple rectangle this we are then going to separate into three individual Parts this would be one this would be the second one and this would be the third one by that system we're getting the proper position for every water Animation Sprite Which means back inside of the code and I want to move support. Pi all the way to the right that just feels a bit cleaner next up inside of main. Pi in this setup method I want to add another section we can do that one all the way at the bottom for the water and there we want for obj in TMX map and then get layer by name the layer name is water and just to see what we are getting let me print obj do WID obj do height obj dox and obj do y if I now run the code we are getting a whole bunch of output so we have a lot of areas for the water but the way you want to think about it we always have triple values with an exp position a y position a height and a width these numbers we have to use to create the proper areas so what we want to do is first of all a for Loop where we are going through all of the x positions which we're getting for X in and then a range where we need a start position an end position and a step size imagine that this is the entirety of the map area and we for example have one Water Area here at the moment we want to splice this thing up into columns and rows something like this at the moment inside of our four Loop we are simply looking at the columns meaning we want to start here and there and then jump by these column sizes that would be our step size and also the easiest part that one is simply going to be the tile size we always want to move an increments of 64 pixels also let me clean this one up a bit so we can see what's going on next up we have to figure out the start and the end position and those are going to be fairly simple because the start position is this one and the end position is this one which we can get with obj dox and this at the moment is a floating point value which the range function does not like meaning we have to convert this to an integer right away but that way we're getting the left side of the object area or other words this line next up we have to figure out the end point which is simply going to be the start point plus the WID of the entire area this one also has to be an integer we want to get obj dox which is the left side plus obj do wi that way we're getting the right side next up we have to do all of that for the vertical part so for y in range in obj doy that's the start then integer obj doy plus obj do height that would give us the endp point or the bottom of the rectangle area and finally for the step we want to use the tile size and now we have an XY position which we want to use inside of the animated Sprite the one we have just created although for that to work all the way at the top we have to import the animated sprite from Sprites that way we can use it and we have to pass in a position the frames and the groups the position is super easy that one is simply going to be X and Y the frames are going to be self. Overworld frames and water the one we have just imported this one and finally for groups we only have a single one self. all Sprites and now if I run all of this and move a bit down we can see the water and at the moment the water is on top of the player because we are creating it after the player that's going to be an issue we have to deal with later on but for now that is looking pretty good and by the way this black area between the sand and the water is going to be for the coastline that's the intentionally first of all though we have to create an animation for that I want to create two more attributes self. frame uncore index and self. Frames we can do all of that on a single line because the frame index is going to be zero and the frames are going to be the frames we are getting from the parameters these frames here self. frames is simply going to store the frames so we can reuse them and we are going to pick one frame via the frame index for example when we are initializing the parent class we don't want to have a static integer we want to have self. frame index which is not going to change anything this value is still zero but if we increase the frame index we would get a different kind of graphic that system we can use by creating an animate method which will need self and Delta time all that we are going to do in there is self. frame index plus equal some animation speed let's for now say four and this we have to multiply with Delta time that way all of the animations are going to be at the same speed regardless of the frame rate and that we can then use to update self. image for which we want to get self. frames and then pick one of the self. frame index values that however is not going to work for two reasons number one self. frame index after this line is going to be a floating point value remember Delta time is a really small value something like 0.004 if you add that to the frame index which at the moment is zero you are going to get a value that will not be an integer which we we have to fix right away by turning this into an integer that's the first issue after that we have to account for this number growing without any kind of constraint but we have a limited number of frames at the moment for water we have four animation frames so the frame index cannot exceed that and that we can Implement via modulus where we want to get the length of self dot frames that way if the frame index exceeds the length of the animation frames we are starting back from the beginning and that is all you need for the animation it's ultimately very simple all we have to do now is to create an update method with self and Delta time and then call anate or more specifically self. animate Biff Delta time that should be all we need if I our run made of Pi we have animated water and that is looking pretty good cool the only thing I want to change is instead of using this four I want to go to settings and then use the animation speed let's paste it in there and now main.py looks about the same but now we have more control over it or rather we know a bit more what's happening inside of this method this feels more readable that's the first part next up we have to work on the coast tiles for that we are still going to use the animated Sprite class but we have to figure out a few more things the first thing that we have to work on is what frames to use and for that let's have a look again at the graphic I talked about earlier this is what we want to import and then take apart so that we can use it for animations after that we need to figure out which of these tiles to play so do we want this grassland this inverted grassland the beach the snow or any of these other graphics on top of that we also need to know where to place that animation all of that you can find inside of til let's have a look at the moment we don't need the water anymore and we also don't care about the objects instead we want to look at the coast layer let me make this one visible and this is going to give us a whole bunch of object areas that all have the same size that part actually doesn't matter very much what we really care about is the X and Y position along with their custom properties there we have the site and the terrain the terrain should be fairly straightforward this one could either be sand or it could be something like up here where we have grass inverted and just to explain inverted if I maximize this all of these tiles would be the grass tile sets and all of those tiles would be grass inverted so with that we know where to place this tile and what kind of graphic we want which means we can now go through the entire process step by step and let's start with the Imports that is going to happen inside of support. Pi in there we already have one function that can import a tile map it's called import tile map for this one we have to specify the amount of columns rows and then a path that function we are going to use but we need a bit more extra functionality which means I want to create a function called Coast importer for which we are going to specify the amount of columns the amount of rows and then once again a path that information we are going to use right away to create a frin dictionary which will be the return value of import tile map let me copy it and then we have to pass through the columns the rows and then the path that we also want to unpack right away and just to make sure you see what's going on on let me print the frame dictionary right away after we have that I want to copy Coast importer and then inside of import Assets in the overbo frames we want to create post tiles which is going to store the return value from import folder for which we will need the columns the rows and the path to look at the graphic once again this one is going to have 24 columns and 12 rows it's a bit hard to see but basically every single one of these individual tile groups like one of those is going to be 3x3 tiles and we have eight of those in total and each of those has four iterations which means we have 3 * 8 on the WID and 3 * 4 on the height I.E 24 by 12 meaning 2 4 by 12 and the file path is going to be a folder up then we want to go to Graphics then we want to go to tile sets and the actual file that we want to import is called Coast if I now run all of this P game is going to load for a second and then we are getting a pretty substantial dictionary so what happened here well we are getting a dictionary where each of the keys is a tall that has an X and A Y value or rather a column and a row value with the associated key being a surface what that means if I open up the graphic again all the way in the top left this first tile is going to have the key zero and zero if we then go one field further to the right this one we would have a column of one and a row of zero that would be the key for for this surface and this we're going to do for every single one of these tiles until we reach the end of the graphic which is going to result in this entire dictionary it is actually quite long that's a good start but not actually what we want what we instead want is a list with surfaces let's say this one then this one then this one and finally this one along with an appropriate name that is going to give us the position on the tile set and the kind of tile we are working with for that we are going to write a bit more logic inside of Coast importer first of all I want to create a new dictionary which for now is simply going to be an empty dictionary and then we're going to create a list of terrains for that value let me paste it in so you don't have to watch me type we're going to have a list with all of the types of terrain that we are working with I.E if I open the graphic once again the first tile set would be grass that is this one the second one would be grass inverted that's this one then we have sand inverted that's this one and we keep on going until we reach the end of the tile set after that we will need the sites that we are working with and for that we will need a dictionary that gets a bit more extensive so let me copy this one in as well it's going to look like this and this should happen over multiple lines I guess we can do do it like this that looks good for this one we are looking at the various sides of the coastline for example in the top left we have this part and that is zero and zero then we have the top which is going to be the one right next to it where we have column one and row zero however if we take another example the bottom right one this one would be the one in the bottom right where we have the second column and the second row the way you want to think about the sides is that we are looking at the first eight tiles or rather the first tile group and that can be really useful because if we are offsetting all of these numbers for example to go three columns further to the right then we are getting all of these tiles while still keeping the same top left the same left side the same bottom side and so on also in the description of this video I'm going to add a note with all of these values so you can copy them right in anyway after we have that we can work on the actual logic and essentially what we want to do we want to look for Terrain in uh Reigns The List we have just created although on this one we also want to know the index we are on which we get via enumerate and then we can expand the for Loop we want to have the index and the terrain which means what we're going to get is index and terrain let me print it run main. pi and we can see we get zero for grass one for grass inverted and so on after we have that inside of the new dictionary I want to create a new key which means I want to get the new dictionary and the new key is going to be the terrain which itself is going to have a value of a dictionary and this dictionary we're going to fill with key value pairs where the key is the S side and the values are the associated Graphics that we need for that we're going to need another for Loop for key and position in sites do items after we have that I want to work inside of the dictionary we have just created which we can now access via this value and then we want to create a new key value pair where the key is going to be the key I.E top left top top right and so on with the associated value being a list of frames those frames we are going to get from the frame dictionary the values we imported all the way in the beginning now this is a dictionary meaning if we specify a tupal with a column and a row we are going to get a value for example what we want to do at the moment we are inside of this for Loop and have some kind of a position let's say we have the top left that would be this top left tile from this tile we want to jump down three tiles to get this one then three more tiles to get this one then three more to get to this part these are the four tiles that we actually want to store which means first of all we need to figure out the row and that we can do via a for Loop and by the way we are going to use list comprehension I already started doing that we want to use for row in a range for this one we always want to start all the way at the top so zero then we want to go to the amount of rows that we have that's the number we have specified in the parameters for the step size we want to go with three that would almost give us the row the one thing we have to add is we want to get position one the position we getting from the for Loop and then add the row to it this position one is really important because in the top left we get a default value of zero so in there it's not going to do anything but if we are going to go a bit further down for example to bottom right there the start row is going to be two this we have to account for and after that we have to work with the column for which we once again will need a start position which is going to be position zero we want to add the index and multiplied with three the index is what we're getting from the enumerate of the parent for Loop if we are on grass this would be a zero if we are on grass inverted this would be one and so on that way if we are on grass has inverted the column wouldn't be zero anymore it would be three because we are multiplying one with the number three that is always going to give us the right column and with that we are done all we have to do now is at the end of the function return the new dictionary then we can work inside of the Overworld frames and print self. Overworld frames and we only care about the coast if I now run all of the is we are getting an error and that is a really easy one to fix I have simply made a typo inside of the dictionary let's try this again and there we go this is looking much better now we still have a massive dictionary but now the first key is going to be grass the associated value is a another a dictionary where the first key is top left and then we have a list of surfaces and those we can use for the animation that is a really good start now we just have to figure out how to use all of these Graphics that is going to happen inside of setup specifically after the water I want to have a section for the coast and figuring this part out is going to be your exercise I want you guys to use the coast tiles we have just imported to actually display the graphics all of that information you can get from the TMX map first the video now and see if you can figure this one out on your own we are going to need another for Loop for obj in TMX map doget layer by name the layer we want to work with is called Coast for each of those objects we want to get a Terrain and a side for that inside of til you want to look at the properties because there we literally have a side and a Terrain those values we can access via obj do properties and for the terrain we want to get the terrain and for the site we want to get the site finally we can create an animated Sprite Which is going to need three parameters position frames and groups groups is the really easy part we only have a single one all Sprites position is also fairly easy it's simply going to be a tuple with objx and obj doy the only thing that's a bit more complicated is going to be the frames for that we will want to get self. Overworld frames then we want to have the ter Rin and finally we want to have the right side and that's basically it if I now run all of this we are getting an error and I hope you can see the problem at the moment I am getting all of overbo frames that would be this dictionary which at the moment has only two Keys Water and Coast but I am trying to get the terrain right away to fix that what we have to add is first of all we want to get the dictionary coast and now this should work and now we have an animated coast line so that is looking pretty good now the coast is on top of the playup which looks a bit weird but that's an issue for later I think for now this is working pretty well and let's try and check the other Coastline should come up there we go this is looking pretty good so I am quite happy with that perfect I hope this section wasn't too complicated basically the Imports can get a bit confusing but ultimately when you're looking at this again we not doing anything fundamentally complicated we are simply writing in nested for Loop so I would really recommend to go over this thing a couple of times to make sure you understand it mastering list comprehensions and python is a really important skill and something you definitely want to practice for the next part we are going to start with the characters meaning we are going to animate the player and we're going to create all of the other characters they are not going to do anything and we have no collisions but at the very least we are making some solid progress now for the logic of this part the player and all of the NPCs share quite a few attributes meaning we can rely on inheritance where we have a parent entity class this one for example covers the animations and the setup of the character this will then be the parent class for the player and for all of the characters after that for example for the player we are going to capture user input and check collisions while for the characters they're going to get some other code for example to look around or for the dialogue should be a fairly straightforward section although before we get to any of that we have to do a few more Imports because if you look at the project in graphics there we have the characters and we have to import all of this let's get started with that part for that I want to work inside of import assets besides the water and the coast I want to have another key value pair which is going to be for the characters and essentially I want to have a function called all character import where we simply have to specify the parent folder which is going to be going one folder up then we are going to go to graphics and finally we want to go to characters that would get us to the folder I just talked about this one now this all character import doesn't exist at the moment so let me copy it and inside of support I want to minimize everything so we have a bit more space and then below the import tile map I want to Define all character import where we have to specify a path for this one like we have done with the coast tiles we want to create a new dictionary where for example we have a character like the player and then the associated value is going to be another dictionary for example one key could be called downcore Idol and this would be a list with a single surface so basically this is going to be our player and the down idle key is going to get a list with this surface only so if the player is facing down and not moving this is the animation we are going to play now since we have an animation with a single frame we are only going to play this individual frame so that's not going to do very much however another key that we are going to add could be for example down where we want to have a list of frames specifically we want to import the entire first row if you play all four of those frames in sequence you get a down walking animation that's all we have to do and by default I do not want to have any value inside of the new dictionary instead first of all I want to get all of the characters meaning I want to get all of those images to get that we could look at the other functions we have already in there for example if you look at import folder we have a for Loop for folder path subfolders and image names in the walk function this one simply walks through a folder and then gives you all of the content this is what we want to do as well for this one as a matter of fact I can literally copy this line and just to demonstrate what we are getting let me print the folder path the subfolders and we want to get the image names if I now run may not Pi we are getting some data the first entry is the folder name that we don't really care about because we already have that one then we get an empty list and this is what we're getting from the subfolders since in the folder we are currently looking at there are no subfolders we are getting an empty list returned that's also not a part we care about so we can just ignore it finally the only value that we really care about is image names that would be a list with all of the images inside of the folder or to be a bit more specific this is going to be a list with the name of every single file in that folder in our case it just happens to only have image files now this is the only value that we actually care about meaning I can replace the folder path with an underscore and the subfolders with a double underscore to indicate that I don't care about these values all I want to look at is the image names this is a list that I want to cycle through which we do before image in image names if I print the result we only care about the image we are getting the file name for every single one of these files this data I want to retain and use it as the key for the new dictionary although I do want to get rid of the PNG let's create a new local variable I guess we can call it image name which we're getting with image and then using this split method we can separate the string wherever we have a DOT and then only pick the first value that way we are getting rid of anything after the dot once we have that we can get the new dictionary and create a new key which would be the image name the value we want to assign to it is going to be another dictionary where for example we have a key with down and then a couple of frames along with it but this we can't do easily right now now you could use the import kle map function the one we already have and we know if you look at the folder or any of these Graphics we have four columns and four rows for every single one of the characters meaning we can get four and four along with a file path that file path we can get from the parameters the one all the way at the top along with the image name that we have created here if I now run m Pi we are not going to get an error and if I print self. Overworld frames with the characters I can run this again and now we are getting none that is because at the end of this function we are not returning anything so return new dictionary and now let's try this again that looks a bit better basically the first entry is called blonde and then we have all of the frames that we have gotten from the tile map importer then we get the second character fire boss and a similar kind of dictionary that's a good start but we have to organize this better inside of support. Pi I don't want to use import tile map so let me cut it out and instead I want to create another function that I called character importer where we are specifying rows and columns just as before and then we are assigning a path let me create that function right away actually define character importer where we have the columns the rows and a path inside of that function we are still going to use import tile map although now we are only going to need a path Because the actual path we are creating inside of all character import all we have to change is that instead of A4 we want to have the columns and the rows and then we should get roughly the same result if we are returning the values from this tile map function so so far we haven't really achieved anything but what we can now do is instead of returning the value right away I want to for now store it inside of a local variable called frame dictionary now this value we want to change quite a bit so I want to create a new dictionary which for now is going to be entirely empty and now to separate the graphics let's have a look at it if you look at the first row you can see that we are just moving down so on zero we get all the down animations then on the second row or Row one we are going to the left on the one with index two we're going to the right and on index 3 we are going up that information we can use right away inside of a for Loop you want to have for row and direction in a numerate and then we can add a tuple with the values down left right and up just to demonstrate what we are getting if I print the row and directions I can run main. pi and we are getting for every character zero down one left two right and three up meaning we're getting the right row along with the state of the character for that row that information we want to use to create a new key value pair inside of our dictionary which means new dictionary and the direction is going to be a list of frames where we are looking at our frame dictionary the one we are getting from import tile map and for this one we have to specify a tuple with a column and a row the row is the easy part because this is what we're getting from the for Loop that part we don't have to worry about the only thing we have to worry about is the column and for that part we can use the list comprehension once again because I want to go for column in range alss very much a similar thing compared to what we have done with the coast importer this stuff down here with that we are getting a new value inside of our dictionary so at the end of the function I want to return the new dictionary which we are capturing inside of this other dictionary which we are then storing inside of the Overworld frames in the characters key let me print the result self. Overworld frames we want to get the characters and now if I run all of this we don't need the output for the blond character we still have a dictionary but now the first value is going to be down with a list of surfaces there should be four in total those four and then we get the left movement there we have four more entries then we get right and so on that is looking really good but we want to have just a little bit more this is only going to give us the walking animation besides that I also want the idle animation which is always going to be the first frame of the walking animation for each individual Direction the way we're going to get that I want to get a new dick entry where we're going to get the direction but now this part is going to be inside of an F string where we are going to add underscore idle at the end the value for this one and this is really important has to be a list even though we are only going to add a single surface in there we still need to have this inside of a list that will simplify the animation logic a lot but other than that we want to get the frame dictionary again for which we have to specify a tuple with the column and the row the row once again we are getting from the four Loop and the column is always going to be zero and that is it if I now run m. Pi we get the dictionary printed out and you can already see at the bottom we're getting right idle that has a list with only a single surface inside and well then we have a whole bunch more Valu I am pretty sure that this is working well cool so with that we have done a lot of importing let's minimize this and now we can actually create the characters that's going to happen inside of entities. Pi in there all the way at the top I first of all want to create a class called entity that is the class I talked about in the beginning which will become the parent for the player and for all of the other characters for this one we we want to inherit from pygame dos sprite. Sprite we also want to create a thunder init method where we are specifying self then a position frames and the groups also we have to initialize the parent class which we do with super Dunder in it and pass the groups in there now this entity class will become the parent of the player which means the player shouldn't inherit from a Sprite it should inherit from the entity mean meaning we have to update the super Dunder init method or in other words we have to get a position frames and groups let me copy all of those parameters actually now position and groups are fairly straightforward we're getting those for the player right away via the dunder init method although frames we do not have at the moment to fix that the player's going to need another parameter frames which means inside of main.py when we are running the setup method and create the player that happens here we have to add another argument in there we want to get self. Overworld frames in there we have the characters which is going to be a dictionary on its own which has the key layer also I am running out of space and later on we're going to add more values into the player I want to use multiple lines and then named arguments we have the position we have the frames and finally we have the groups that is much more readable cool with that inside of entities we get all of the arguments for the player and to initialize the parent entity class which means if I run main.py the code runs just as before we are not using any of the data but at the very least the game doesn't crash so that's a good start next up then inside of the entity class we want to organize the animation or in other words I want to set up the graphics for that like in the animated Sprite we will need two attributes a frame uncore index and self. Frames the frame index will always going to be Zero by default and the frames are simply going to be the frames after we have that we can cover the actual Sprite setup for which we are going to need self. image and self do rectangle the image is going to be self. frames and from that we want to pick a single surface however that we can't do immediately because these frames are different compared to the frames we using inside of animated Sprite inside of that class frames are simply going to be a list with surfaces so indexing is very easy we simply have to specify a value like 0 1 or two and so on for entities this gets more complicated because this one has a dictionary where we have a state like down and only then do we get a list with all of the surfaces which means to get a single surface we first of all have to get the state of the animation and then we want to get self. frame uncore index I suppose to get started the state could simply be down for now although later on this we are going to change next up we have the rectangle this is quite simple self. image. getet F rectangle we want to set this Center to the position after we have that inside of the player since entity is already covering the image and rectangle the player doesn't need that part anymore let's try main.py and now we can see the player there's no animation yet but at the very least we have a basic graphic to animate all of that we have to create an animate method meod with self and Delta time for this one we want to get self. frame index and then plus equal the animation underscore speed multiplied with Delta time after that self. image needs to be updated where we are going to get self. frames then don't forget we will need the state and then we can pick one surface from the list of surfaces via the frame index which is going to happen basically in the same way compared to what we have seen inside of the animated Sprite class we want to get an integer with self. frame index then the modulus operator along with the length of self. frames although once again this is a dictionary to get the actual frames we need the state again cool that looks pretty good next up we need an update method with self and Delta time in which we are going to call self do animate with Delta time let's try out of that and nothing is happening the reason for that is that we don't actually have an entity class we have a player class and we are only calling the update method on that class or on the instance of that class meaning in there we have to call self. animate with Delta time we do not have to do that inside of the entity class what happened there is that we have this this update method inside of the entity class but since we also have an update method inside of the player this update method overwrites this update method we can actually get rid of it entirely it's not needed but if I now run main.py we get a walking animation we are only walking down so not amazing but at the very least we have something to actually have a proper animation we will need another method that I called get uncore State no need for custom parameter in this one and then there we basically want to get the state of the player I.E if the player is going down left right if the player's idle or not things like that and the way this function is going to work is we're going to have a whole bunch of logic and by the end of it we are returning the proper state for example this one could be right and then instead of always having a default value let me select all of them so all of the down values should instead be self. get underscore state with that if I run the code now the player is always walking to the right we could also change this to return right uncore idle then the player is always going to idle in the right direction that is looking pretty good now we just have to figure out the logic to make this get State interactive this get State needs to know in what direction The Entity is moving and that's actually a really good start this self. direction should be inside of the entity class not inside of the player let me add another section in there for the movement there we have self. direction also while we are here at the moment for the player we have a generic number for the speed this should be an attribute that we are going to store inside of the parent class self. speeed which can be 200 and 50 this self. speed we actually want to use for this move method that just feels a bit cleaner after that we have to figure out the logic for the get State method and the first issue we have to address here is that we only want to update the state if the player is moving which we can do by creating a local variable moving that is going to be the Boolean value of self. Direction the reason why this is necessary imagine that our player is moving and we are currently moving to the right and then we are stopping if that is the case we do not want to play the animation anymore but we still want the player to look to the right which means we want to store the last thing the player has done when he was moving and then use that information when the player is idling which we can do by only updating the movement Direction when the player is moving so when the player stops moving and we have been moving to the right then the player is still going to face to the right when we are idling I hope that makes sense I suppose to do this a bit more practically inside of the graphics I want to create another attribute self. facing underscore Direction by default this one could be down this is the value we actually want to update for example inside of get State we want to return an F string where the first value is always going to be the direction or self. facing direction to be a bit more precise but after that we want to add another value which is going to be empty if we are moving that way we would simply get down left right or up which is going to be the walking animation however if we're not moving so else then we want to add underscore idle that way if I run main. Pi we are currently not moving so the player is idling but if I start moving we are getting to walk in animation now this at the moment only works in a single Direction so not great but we are making progress what we now want to do is to check if the player is moving then we can check if self. direction dox is different from zero if that is the case we know we are moving on the horizontal axis which means self. direction is going to be right if we are moving to the right I.E if self. direction dox is greater than zero if that is not the case else we know we are moving left that we can already try if I now Run the game and I move to the right we are getting an error that the string object has no attribute X and I think I can see the issue so the error happened on this line but the actual problem happens on the next one because on this line we are overwriting self Direction which is supposed to be a vector where we get X and Y but we are now assigning a string to it either left or right this is simply a typo I meant to update self. facing Direction now this should be working if I move to the right or to the left we get the walking animation for that state so that's looking pretty good however down and up don't work yet that we can fix quite easily by simply duplicating this if St statement and check if self. Direction doy is different from zero it is going to be down if self. Direction doy is greater than zero and if that's not the case we are going up and now I can walk around and we are getting the proper animation for each Direction so that is looking pretty good that means we can minimize both of these methods and then we can start working on the other character s for that if you look at tiled we don't need the coast anymore and we only really care about the entities so let me hide everything else basically we have in the Overworld a whole bunch of markers some of these markers are going to be just for the player you can identify all of those via the name if the name is player we don't really care about them for this part we only care about the markers with the name character for those we also get a graphic Like Straw for example and this graphic is simply the file name for example straw would be this character on top of that we're getting a direction and this will be the starting direction of this character we have all the information we need to create a character so this is going to be your exercise create a new class for all of the characters and then display them via this class inside of the game with the correct start facing Direction the one that you're getting from til pause the video now and see how how you get first of all inside of entities. Pi I want to create another class called character which needs to inherit from The Entity class then we will need a thunder in it method self a position frames and groups later on we will also add the facing Direction in there but let's keep it focused for now next up we have to initialize the parent class with super thunder in nich and pass through the position frames and the groups now at this point we don't need to animate the characters meaning there's no need for an update method which makes our life a bit easier meaning next up inside of main.py inside of the setup method we want to look at all of the character markers we are already isolating the player if we add an else statement then we can print objname and let's see what we get we are getting mostly characters but there are some players in there that is because for this if statement we have two conditions which is not ideal let me take the second condition cut it out and then add an inner if statement we only want to create a player if obj name is player and we are on this starting position after that we can indent self the player one more time and now if we run this we are only getting characters that looks pretty good so now we can create an actual instance of the character class although for that first of all all the way at the top from entities we want to import the character and the character class next up for each character we're going to need a position frames and groups now these arguments are going to be fairly similar compared to what we are doing with the player hence we can literally copy all of the named arguments from the player so I have to write just a little bit less there we go now we have a character class with position frames and groups this is actually already going to work if I run the code we can see there's one NPC and if I go a bit further down here there we have another one there's one more and that's a good start but the graphic isn't right that is because we are always using the player graphic from the Overworld frames for this one I want to get obj do properties and then get a graphic let's thr off this again and now this is working much better we're getting a whole range of different characters so I am quite happy with that cool the last thing that we have to figure out is the start facing direction for each entity at the moment this one is always going to be downwards but that we want to customize via another parameter let's call it facing Direction and this value we are assigning to the self. facing Direction attribute that means when we are creating the characters and a player we have to add one more argument facing Direction which we are getting when we are creating this class so for the dunder init method for both of these classes we will need a another a parameter facing Direction once we have that we can work inside of main. Pi and to both of those class Constructors we want to add facing underscore direction if we set this one to right we should always have a right starting Direction so that is working pretty well cool to make this Mo interactive let's have a look at til in there when you look at the markers for the characters you can see that we have a direction this one for example should Face Down by default this one should face left by default and so on we got a few more this one for example faces up and then for all of the player starting markers we also have a direction which we can use this one would be down then we have one here for down as well and I think all of the markers in the Overworld are down but if you look at the hospital or the marker for the player the direction is going to be right although this this one should actually be up anyway you get the idea back inside of the code for the player we are currently working with a marker that's our object and on this one we can get obj do properties along with the direction the same thing we want to do for all of the characters it's actually the same property if I now run this again the player looks down by default this character looks to the left this character looks down and this character also looks down and if we go a bit further up then we should see a character looking up as well this one here and that is working pretty good cool so with that we have a pretty good start to all of the characters they don't do anything at the moment and we have no collisions but at the very least we are making some pretty solid progress so at this point we do have a basic level but there are a couple of things that could be improved and that is what we are going to work on in this section number one we are going to add all of the grass tiles those we are later going to use from Monster encounters but for now they're simply part of the Overworld number two is going to be a better drawing order that way we don't have trees on top of houses or the player below the water anymore and finally we're going to add collisions which is going to make the game feel significantly more realistic that should be fairly straightforward let's get started with the first point the monster grass patches for that we have to first of all look at til here we are and at the moment we only have the terrain visible on top of that we have a layer called monsters if you make this one visible we have a whole bunch of grass tiles also if you look at the top left there we have a few ice grass tiles also what is very easy to miss if you look at the beach and select this section there we have a bunch of beach tiles those are not going to be visible but we can use them to control where monster encounters happens when the players on the beach sadly there's no grass on the beach available but anyway if you look at one of these grass tiles you can see we have a couple of custom properties the biome the monster level and the Monsters available although for now this isn't really information that we care about we simply want to have the graphic that we can use inside of the code I want to work in the setup method and in there we can create below objects although the actual position is not going to matter in just a bit I want to add the grass patches for that we will need a for Loop for opj and TMX map doget layer by name the layer we want to look at is called Monster and I suppose for now we can simply create a Sprite for which we are going to need let me copy the parameters a position surface and groups position is super easy we have obj dox and obj doy for the surface we want to get obj do image and for the groups self. all Sprites if I now run main. Pi we are getting an error because this layer is called monsters if I now run the code you can see that we have the grass patches so that is looking pretty good and if you go all the way to the top left there should also be the ice grass patches there we go that is looking pretty good so we are making progress but it's still not ideal because there should be some overlaps and that is going to bring us very nicely to the next part that would be the drawing order so for example if you look at these two trees right next to the player the drawing order here is a bit messed up because the shadow of this tree is on top of this other tree the same same happens to this tree as well and if you walk a bit more around you can see that this is a very common problem you can see it here as well you can see it here in particular because the player is below the water and finally with the houses it becomes incredibly noticeable so on there the tree is on top of the house and the issue here is that at the moment we are sorting all of the Sprites by the time of their creation I.E the stuff that we are doing in the setup method which is not a reliable solution at all what is going to be a much better approach is to give each Sprite a layer and then when we display the game we are going layer by layer or in other words what we are going to do is we are first going to draw the water then we're going to draw the backgrounds and then we're going to draw the characters with all of the other objects like the houses and the trees now this system isn't terribly difficult to implement but there are going to be two complications number one is that each character should have a shadow and this we have to incorporate with the layout approach to drawing besides that there's one object that should always be on top of everything else and that is the top bit of the pillars or in other words if I run the game again and I go down a bit this pillar thingy here should always be on top of the player that way we can walk below it and it looks like there's a bit of threedimensional depth in the game so how can we start approaching this kind of problem and first of all if you look at settings there we have a dictionary code World layers this is going to define the drawing order I.E we're going to draw water first then we're drawing the background then we are drawing the Shadows then Main and then top because of that since water is drawn first everything else will always be drawn on top of it so what we need to get started is to tell each Sprite what layer it is on and for that inside of Sprites I want to give every single Sprite a z parameter which is going to get a default value we want to get the dictionary World layers the one I just talked about this one and by default a Sprite should be on the main layer so dictionary indexing and Main this value we now have to store as an attribute self. Z is going to be Z after that we also have to update the animated Sprite and for that I can duplicate the parameter and don't forget to pass it through to the parent class so we want to add Z in there as well with that we can store the Z parameter that means inside of the setup method we have to actually pass in that information when we are creating the terrain we want to have worldcore layers and those will always be BG our after that we can work with the water and with the coast because for those we have World layers and water and then we have for the coast World layers and BG and I realized while recording you could combine the water layer and the BG layer since they're both simply going to be in the background it's not going to make a massive difference but in practice this isn't going to make a difference although what I do want to do is to copy all of these lines and then move them up just a bit so we have the terrain the water and the coast all in one place like so you don't have to do that but it just feels cleaner all righty next up we have to cover the objects the grass patches and the entities and while we are here I realized the character objects do not have a z parameter this we have to fix right away and each entity should have a z parameter I suppose we can put it all the way at the top self do Z and this one is really easy because an entity should always be on the main layer World layers and we want to go with main no need for a parameter for this one that way we have finished the entities as well and the grass patches we don't have to touch those will always be on the main layer as well the one thing that we do have to care about is the object objects because for those we have to be a bit careful to understand why let's have a look at til and I want to look at all of the objects so in there we have a whole bunch of trees and houses and then random objects like the rocks and those pillars and the top thingy now basically all of the objects should be on the main layer with one exception and that is this top part this one should always be on top of everything else that way the player can walk below it and this object we can identify by its name it is called name top and this is unique no other object has any name which means inside of this for Loop for the objects we can add an if statement if obj dotame is equal to top if that is the case we want to create a Sprite that has all of the same arguments that we have used before so let me copy them and then add World layers with the layer at top however if that is not the case else then I want to create the Sprite we have already created later on for the collisions we have to add a bit more logic in here hence I do want to have a proper if statement anyway let's try and the game is still running as before but we do not have any update to the drawing method because so far we only added a single attribute it's not actually used yet for that we have to look at the groups because in here we are drawing everything this is the part that we have to refine and essentially I want to create three lists of Sprites I want to have the BG Sprites I want to have the main Sprites and I want to have FG Sprites after we have that inside of the for Loop for the actual drawing we're going to go through all of these lists and then draw them one by one I.E we're going to first draw all of the background Sprites then the main Sprites and then the FG Sprites because of that the FG Sprites will always be on top of everything and the main Sprites will be on top of the background Sprites for the background Sprites I want to use list comprehension with Sprite for sprite inself that way we are simply going to copy all of the Sprites inside of the class but there's going to be a condition I only want to get a Sprite if Sprite doz is smaller than worldcore layers and Main i e I want to get all of the background Sprites that come before the main layer we can do the same thing for the main Sprites because in there we simply want to check if we are on the main layer and finally for the FG Sprites we want to check if we are greater than the main layer that we can now use with another four loop I want to have four layer in the tupal BG Sprites main Sprites and FG Sprites and the order here is really important BG Sprites has to come first then we have main Sprites and then we have FG Sprites the for Loop is going to go through those in order and this is really important for our purposes once we have that we want to go through every Sprite inside of the layer and for that we already have have this for Loop we simply have to indent it remove the white space that should be all we need to get started if I now fix the extra character here and run main. Pi you can see that so far not much has changed however if I go a bit further down the player should at very least be below this part and that is working really well also if I now walk over the water the player is always going to be on top so that is working pretty pretty well we are definitely making progress and I hope the logic for all of this makes sense ultimately we are simply splitting up all of the Sprites into three separate groups and then draw the groups in order but we are not entirely done yet if I run the game again we still have this kind of issue where for example the trees are on top of the house this issue here that happens because this tree this tree and this house are all on the same layer meaning we still have the same issue that they are being drawn by the time of their creation it simply happens to be that this house was created first and then we created those two trees which means when we are creating the main Sprites layer we want to sort them in a different way which we can do with the python sorted method we just have to figure out a specific e to sort and by and let me talk about the logic here really quick imagine we have two characters although it could be any two objects for those we want to have a criteria to figure out which character should be drawn on top and which one should be drawn in the background and usually the best approach is to Simply use the vertical position we have the vertical center for the player and for the other character you put some actual numbers on this let's say the player centery is a 100 and for the other character it is 120 all we really have to do is to look at the largest number I.E the character has a greater white position so it should be drawn on top of the player that's literally all we have to do that way the further down an object is the later it is going to be drawn inside of python the key we want to assign is a Lambda function with one parameter that I usually call Sprite or and by the way what is going to happen in here the sorted method wants to have a list that we already have it will then go through every single element of this list and pass that element into this Lambda function or whatever function you specify from that Lambda function it is then expecting some kind of return value ideally some kind of integer all of those integers are then stored in the list and this list will be sorted from the lowest all the way to the highest value or in other words what we want to do this Lambda function is going to get a Sprite whatever Sprite we getting from the list and the value that we want to get from the Sprite is sprite. rec. Center y bya that system we are extracting all of the vertical Center points and then sorting them from the lowest to the highest value and well that's literally all we need for this part if I now run main. Pi again you can see that the trees look significantly better and if the player walks through the house at some point the player disappears and with that we have a much better looking game this feels drastically better also you can see with the grass patches they are starting to come together but we do have to refine things just a bit because something like this shouldn't happen in the game now to fix that we want to work inside of the Sprite class in there I will add another parameter self underscore let's call it y sort for now this can simply be self. re. Center y that way when we are sorting all of these Sprites we don't need sprite. rec. Center y instead we can simply get sprite. Yore sort although once again I forgot that we have to do the same thing for the entities I.E below self. z i also want to have self. Yore sort which is going to be self. re. Center y if I now run may not Pi we are getting an error that happens because when we are running this y sword erect does not exist yet we only create this one down there so I guess we have to move y sword all the way to the bottom with that I can run all of this again and now we are getting something weird the player is always on top of these Sprites but he will always be below all of the others so what happened here y sword is not being updated and when the player is moving around y sword is always going to remain the same that way the player sorting doesn't really work but for that for the player when we are updating everything first of all we can update self. y sword if I now run of this again the player should integrate much better and that is looking good also if we're now walking over the grass this is working perfectly fine again all righty so with that we haven't really achieved very much the game still looks the same but what we are able to do now is to customize this y sword or in other words we have a bit more control over what kind of sorting Behavior we have for example if you reduce the center Y for the Sprite by by 40 and run m. Pi again now this grass is going to overlap with the player much much faster which is going to look a lot better now for the other objects this is going to look a little bit weird but we are making some progress basically what we are going to do I want to have one kind of drawing Logic for the grass and then another drawing Logic for everything else and by drawing logic I simply mean mean that we have a different offset for the Y sword and for that I have actually created a whole another class although for now this isn't going to be the most useful part I want to have a monster patch Sprite Which has the Sprite as the parent which means in there we will need position surface groups and z and we don't need Z in the dund ended method of the class itself with that we can pass position surface and groups right through and Z at least for now is going to be World layers and Main and only in there do we want to update self.y sort and we simply want to reduce it by 40 pixels we don't need to do that in the original anymore and now inside of main. Pi when we are creating the grass I don't want to create a Sprite I want to create a monster patch Sprite although this we have to first of all import all the way at the top I want to import Sprite animated Sprite and monster patch Sprite let's try this one now and the grass is still looking much better but if I look at the other objects there the player disappears once we are behind the object and once we have collisions that is also going to look much better cool so with that we we have quite a nice overlapping Behavior there's just one issue we do have to work on and that is here we have the sand monster Sprites overlapping with the player and this shouldn't happen those tiles should always be behind the player that is an easy part to fix inside of Sprites dop when we are setting the Z layer for the monster patch Sprite it should only be main if we are on grass or ice grass if we are in the sand it should always be in the background now for that we have to know what kind of monster patch we have or in other words inside of til if we're looking at the monster layer again we want to look at the biome because in there we have have a forest we have sand or if you look all the way in the top left we have ice which means if we are on the sand layer we want to change the layer for the drawing now for that we will need to know the biome that will happen inside of main. pipe when we are creating all of the grass patches in there I want to get obj do properties and then the biome property with that inside of Sprites after groups I want to have a biome and for now let's simply print what we get so if I run m.p again we are getting sand ice and Forest and that is looking pretty good that information we want to store right away so self. biome is going to be biome that will become important later on although for now I simply want to update the world layers this one should be main if biome is different from Sand and if that is not the case then we want to have the BG layer let's run main notp again the game doesn't crash the overlapping still works but now there should not be any visible sand patches here anymore and there aren't so this is working perfectly well cool so with that we have the drawing logic that is going to work much better and ultimately the only really important part is inside of the groups because in there we are separating the Sprites via the world layer and then we are drawing the layers one by one that part alone will make the game feel significantly nicer that nearly finishes this part there's just one more thing that I would like to add and that is a shadow below all of the characters something like this a shadow below all of them now this Shadow needs to follow all of the characters in fact it needs to be in the same place and also it needs to respect the drawing order or in other words it has to be on top of all of the BG Sprites but below the main Sprites because in there we have all of the characters but let's go through it step by step first of all we will need an import and since the graphic is fairly simple we can do it right away and by the way what we want to import is inside of Graphics there we have I believe it's an other we have a shadow that is what we want to import let's save it as the attribute self. shadowcore surface and this we are going to import via support and import image which means from support I want to import import image then we are going to need a file path I want to go up a folder Graphics then I want to go to other and finally we have Shadow let's try to run main.py and the game is not crashing so the UT is working cool next up when we are drawing the entirety of the game we want to draw a shadow before we are drawing any of the entities I.E before we are drawing a player or a character the easiest way I think to approach this problem is inside of this for Loop to check if we have an entity and if that is the case before we are drawing the actual Sprite we're going to draw a shadow for that we have to do one more import I want from enti import entity or in other words I want to import this class that allows me before we are blitting the image to check if is instance the Sprite and the entity class if that is the case then we know the Sprite that we are currently getting from the for Loop is an entity which means it would be this entity it could be a character or it could be a player since character and player inherit from entity they would also fall into this is instance and if that is the case I want to get self. display surface and then blit self. Shadow surface after that we are just going to need the position let's go with sprite. re. toop left plus self. offset basically the same thing we have done right below if I now run main. Pi we are getting an error because inside of groups this shouldn't be entity this should be entities let's try it again and there we go now we have a shadow below all of the entities let's have a look at another one there we go so this is working but the shadow is in the wrong position now to fix the shadow we could do a couple of things we could create a rectangle around the shadow surface and then place the center or to keep things a bit more simple we could add another vector door 2 with a certain position I found that the numbers 40 and 110 work really well if I now run myp again the shadow is right below where it's supposed to be and that is working pretty well and now the game just feels a lot better and all of the other characters are also looking really good perfect so with that we have finally covered the entirety of the drawing order which means now we can work on the collisions and before we start working on the actual logic we need to do a bit of groundwork number one the player can collide with other characters the objects I.E houses and trees and rocks and with Collision rectangles those we are getting from tiled now the last part I do have to explain and let's do that in tiled right away here we are inside of tiles and at the moment we have the object layer and the entities layer don't those are what really matters at the moment and when it comes to Collision I think there are some fairly easy parts for example we want to have a collision with the tree we want to have a collision with the house or generally any kind of object we want to have a collision with on top of that if there is a character like the one here we want to have another collision with that one as well all of those are going to be fairly simple because they have a simple area that we can work with however what is going to be a bit more complicated are these Cliffy areas all of this stuff here because those don't really have a regular shape we could have one area here then we have another one here we have a weird one here all of those are kind of annoying to work with as a consequence to make our life a bit easier I created another layer that is called collisions and this one is full of let me isolate it it is full of of very small areas all of those are also going to be collidable and if you combine it with the terrain you can see that those collisions are basically there for all of the walls and the cliffs and things like that could also be a safety area like this one so the player cannot exit the window those are the three kinds of object that the player can collide with on top of that I want to have a Custom Collision size so at the moment this is our player and the rectangle around the player looks like this it is quite large since we imported the player via a tile set which I should probably explain here we have the graphics folder again and in there we have the characters with the player although this applies to all of the characters we are importing all of this and then we are cutting out one part for the player this would be the rectangle of the player which as you can see is quite large which for collisions is going to look really weird so what would be much better is a smaller rectangle for the hitbox that doesn't even cover the entirety of the player that way since we have an overlap these parts and these parts are going to give additional depth to the game which looks really good you're going to see in a second what that means in detail but first of all we have to get all of our areas I we have to get the player hitbox and the character hit boxes in general and then all of the collidable areas and I suppose we could start with the entities for all of those I want to create another attribute self. hitbox which is going to get self. wct do inflate and in case you don't know all that the inflate method does is it takes a rectangle and then expands it or shrinks it and all of that happens around a center point for example in my case I want to get Negative self. rec. wift divided by two this would be the horizontal size change and for the vertical one I want to go with 60 what is happening here is we are taking the original rectangle which would look something like this and then via the inflate method we are looking at the center point and then we are creating a new rectangle from these numbers for example self. rec. WID and this is negative really important so we are shrinking the new rectangle in this case we are getting half of the width of the original rectangle so the new rectangle would have a width of something like this and then on the vertical axis we have 60 so we are removing 30 pixels at the bottom and 30 pixels at the top at the end we have a rectangle that looks something like this and this rectangle is what we actually want to use for the collisions for that since the characters are not moving we can ignore them for now but for the player we have to make sure that when we are moving the player we are also updating the hitbox otherwise the hitbox would always remain in the starting position of the player which would obviously look very silly now luckily that part is fairly simple we simply want to get self. hitbox and place this Center to where ever self. w. Center happens to be and that is all we need for now if I now try to run main. Pi again the game doesn't crash that's a good sign but we can't really see the hitbox and I suppose that's okay for now we are going to make all of this a lot more visual in just a second first of all though we have to get all of the collidable objects those I want to store in another Sprite group I usually call this one self. Collision uncore Sprites and this one can just be a normal pygame dos sprite. group it is just there to identify all of the collidable Sprites so it doesn't have to actually do anything speaking of which when we are setting up the Overworld we have all of these objects the top one we can safely ignore this one is not going to have any Collision however for the Sprite we do want to have a cision because of that this Sprite will be in self. all Sprites and self. collision Sprites besides that the other collidable object is going to be the character meaning for the group or this one we have all Sprites and collision Sprites as well this would give us the objects and the characters that leaves us with the collidable areas those we first of all have to import I suppose the best place would be right below the object but for this one the position really does not matter we want to have the Collision objects as always for obj in TMX map. getet layer by name the layer name we're looking for is called collisions this Sprite that I want to create I called a border Sprite that is going to get a position a surface groups and that's all we need for this one now this border Sprite does not exist at the moment so let's create it by first of all importing it and then inside of Sprites below this Sprite I want to create a class border Sprite Which will inherit from the Sprite class then we need Thunder init with self position surface and groups we also have to initialize the parent plus with super Dunder in it and pass through the position surface and groups now those border Sprites are not going to be visible so the that layer doesn't actually matter we can just keep it with the main one the one really important thing that we have to add to this one is self. hitbox which for the Border Sprite is simply going to be self. w. copy we want to have for the hitbox the same size as the rectangle at least for the Border Sprite however later on when we are placing the objects so all of those we want to have a custom hitbox for the Sprites as well for now I am not going to do that because that way it's a bit easier to see what's going on but what we do want to do is we only want to check collisions between the hitboxes so all of the collidable Sprites will need a hitbox so inside of the Sprite class we also need self. hitbox which for now can be self. rec. hoopy so with that we have all of the hitboxes I think the last thing that we have to do is to actually add proper arguments in here for the position we want to have obj dox and obj doy for the surface we want to create pygame dot surface with obj do WID and obj do height finally for the groups this one is only going to be in self. Collision Sprites and that is really important if this Sprite was inside of all Sprites it would be visible which we really want to avoid as a matter of fact I can actually demonstrate I want to place this Sprite inside of collision Sprites and self do all Sprites on top of that when we are creating this surface there should be Pi game do surface and we have to add a tupal in there as an argument now the game should work and there you can see we have all of the Collision shapes that looks pretty good there we have a few more and those we can work with now obviously those we do not want to see hence Collision Sprites should not be inside of all Sprites rights that way if I run the game we can only see the actual objects so with that we have all of the collidable Sprites and those we have to make accessible inside of the player because only in there are we going to run Collision logic meaning I want to give the player another named argument Collision Sprites is going to be self. Collision Sprites after that inside of entities the players going to need another argument Collision underscore Sprites those we want to store as an attribute self. Collision Sprites is going to be Collision Sprites and now that we have that we can create a method to check collisions for the parameters we will need self and the AIS that we are looking at this could be either horizontal or vertical and before we continue let's talk about Collision Logic for the Collision we are first of all going to split the axis meaning we do first of all the horizontal collisions and then the vertical ones now the order does not matter but separating them is going to make our math a lot easier after we have that we are going to check for overlaps for example if we're doing this on the horizontal axis we have one object that we can collide with and our player so in the the current example we have an overlap on this side which would indicate that we have a collision on the right side of the player or the left side of the obstacle but this doesn't necessarily have to be the case because it could be that the player came from the right side and simply moved really fast the correct answer could also be that the player actually collided on the right side of the obstacle we simply don't know yet so we need one more piece of information which is going to be the direction of the player let's say if the player is currently moving to the right and we have a collision on the right side of the player then we know we are on this side that's kind of all we need to know so in other wordss the direction of the moving object tells us on which side the Collision happened now this is a very easy Collision method to implement it does however have the downside that it only ever works with one moving object which for this game is the case the only object that can move and Collide is going to be the player all of the other characters aren't really going to move or rather when they are moving we're going to block the player so they can never overlap although if you want to learn more about complex Collision behaviors check out this tutorial of mine it goes into much more detail or if you want to do all of this in practice I have also made a Mario Style platformer that is going to do a lot of collision logic anyway in inside of the Collision method we first of all want to go through all of the Sprites for sprite in. Collision Sprites after that we want to check if sprite. hitbox do Collide rectangle remember we only want to check the collision between the hitboxes of all of the Sprites so at the moment we are checking the hitbox of the Sprites and we want to check that against self dot hit box if that is the case we know we have an overlap as a matter of fact we can print that I want to print Collision this we want to call inside of the move method self. collisions we also have to add the axis and this one could for example be horizontal if I now run main. Pi by default nothing is going to happen but if we are overlapping with the house we're getting Collision the same would happen to the tree or any of these objects we always get a collision that is a really good start so now we know that we have an overlap but that's not a collision so basically once we have an overlap we want to resolve that overlap and place the player in the new position and for that we have to go through the logic I just talked about and the first step was to separate the axes which is also going to involve the movement which means in this case we want to update self. re. Center X and to this we want to add self. direction. X multiply it with self. speeed and Delta time after that the hitbox is also going to be updated to only include the horizontal movement and after we are doing that we are covering the horizontal collisions now this at the moment means that we can only move left or right there's no up or down movement which I think for now is okay so we can focus on one Collision axis the way we want to approach this one is inside of this if statement if we have an overlap we want to check if self. direction dox is greater than zero if that is the case we know we are moving to the right which means self. hitbox do WR is going to be sprite. hitbox do left the way you want to think about this one imagine we have the player and the player is moving to the right or in other words self. direction dox is greater than zero this means we're moving right and then we are overlapping with some kind of object that information we are getting from this line if that is the case we basically want to move the right side of the player and move it to the left side of the obstacle that way it looks like the player is stuck on this side and then we have an actual collision and that's literally it although at the moment there's one more thing that we have to do currently we are only updating the hitbox but what is actually displaying the player is the rectangle which means at the end of this line we have to get self. rec. Center X and set it to self. hitbox do Center x with that we should have a collision on the right side and if I move to the right that looks pretty good so we now have one side which means we only have to cover three more and then we also have to give all of the Sprites a smaller hitbox this part is going to be your exercise for this one I want you guys to first of all finish the other three Collision sides and on top of that create another class called collidable Sprite this one should be for all of the collidable objects I.E the trees and the houses and the Rocks this class is going to be basically identical to a Sprite with one major difference and that is that the hitbox should be 100% of the width but only 60% of the height with the same Center Point once we have that we should be done with the collisions so pause the video now and see if you can figure this one out I suppose we should start with the player or more specifically the player movement so that we can move around freely again I want to copy all of this for the horizontal logic and then change it to be vertical this should be self. re. Center y self. direction doy and then Center Y and Center Y and after that we want to do the vertical collisions that means inside of collisions we actually want to check if we have a vertical or a horizontal Collision for that we are going to need another if statement if AIS is equal to horizontal only if that is the case do we want to do all of this and if that is not the case else then we want to do something else let's say pass for now because on the horizontal Collision we have to check if the player is moving left or in other words if self. direction dox is smaller than zero then we want to set self. hitbox do left to sprite. hitbox do right and that is pretty much it next up for the vertical side I want to check if self. Direction doy is greater than zero that means we are moving down and if that is the case self. hitbox do bottom should be sprite. hitbox dotop finally and for this point I can simply duplicate these two lines I want to check if self. Direction doy is smaller than zero meaning we are moving up and if that is the case we want to check the top of the player hitbox and if there's an overlab we want to set it to the bottom of the colliding object and finally we want to update self. rec. Center y to self. hitbox do Center y that should give us proper movement again I can move in all directions and now we have collisions so there is the house there is a tree and we have a hospital we should also try the characters that looks pretty good and cool I am quite happy with that now there is a bit of an issue that I don't really like and that is let me find a single tree this one the collision with the tree happens right here or here on the side or here at the top and I think there is a bit too much of a space between these two objects or in other words the Collision side of the tree looks something like this and for the player the Collision hitbox looks something like this because of that we have just a little bit of overlap right here which which is looking really good and I want to have more of that and to get that we want to reduce the size of the hitbox of the tree to make it something like this in fact for the tree you could even create a smaller horizontal hitbox so you get this part for an overlap as well which is probably going to look really good but that you can do in your own time what I want to do when we are creating the objects that we can collide with all of those I want to create a collidable Sprite that does not exist at the moment so once again we want to from Sprites import the collidable Sprite and then inside of Sprites we have to create that class since it's going to be fairly similar to The Border Sprite let me copy this one and then create a collidable Sprite nearly done the last thing that we have to do is for the rectangle we don't want to create a one toone copy instead we want to use inflate to keep 100% of the width and 60% of the height which means for the width we want to have zero pixels in change but for the height we want to get Negative self. wct do height and multiply it with 0.4 that way we are reducing 40% or 20% at the top and 20% at the bottom and now if I run M do PI let's move back to the tree this one over there now we get quite a bit more overlap I think it's easier to see here now the player is much more behind the tree and I think we could push this even more inside of Sprites let's go with 0.6 and see how good that is going to look so let's try this tree we are quite close to the center but I think it's working fairly well let's try this one and yeah now we get a ton of overlap which is actually looking pretty good and yeah I am quite happy with this one but once again play around with the numbers and just see what looks good on your end either way we have finished another important part although before we finish up there's one more thing that I do want to cover and that is if the player is simply moving left and right we have one kind of speed the same if we are moving up and down however once the player starts moving in the diagonal direction we actually moving quite a bit faster and this is a noticeable change so I think you can see it fairly well the reason why the player is moving faster when we are moving diagonally is because inside of the input this line here we are not normalizing the input vector if our direction is one and zero I.E we are moving to the right if that is the case our speed is just going to be one multiplied by whatever speed we have which is totally fine however if our direction is one and one so we are moving right and down then the actual movement is actually going to be 1.4 multiplied by the speed that we have simply because we are moving on two axes via speed speed and those two add up together the way around that is to normalize the vector that way we are setting the length of the vector always to one all we have to do is to use the normalize method this however if I run the code is not going to work we're going to get an error right away that we cannot normalize a vector of length zero and that should actually make sense if you think about it imagine you are Python and we are telling python that we have an arrow that looks like this or like this we are moving to the right or we are moving down and right all that normalize is going to do is it takes this vector and it sets the length of it to one so if we're going down and right or simply right it is always going to work but now imagine we have a vector with zero and zero this thing doesn't really move in any direction it's simply a point hence python cannot set the length of this thing to a one it's simply not possible it doesn't know which way to go as a consequence we are getting an error now the way around that is fortunately fairly simple we simply want to check if we have an input Vector if this Vector is zero and zero which it is by default then we want to do something else which in our case is going to be the input Vector on its own if I now Run the game again I can move left right up down and if I move diagonally we still get the same speed which feels much more consistent well and with that we have made a whole bunch of progress for the game now we actually have a proper Overworld and the player cannot leave the game anymore oh and also I didn't mention for the beach we have collisions so there's no way for the player to see the black background of the map perfect so at this point we have basically finished the Overworld which means next up we can start working on the dialog tree that way the entire game is starting to become interactive and to get the dialogue system we Broly need two things number one we have to check if dialogue is available in the first place and number two once we have that we need some kind of dialog tree system I'll buy a fairly simple one first of all we have to check if dialogue is available in the first place and this will involve a couple of things first of all we we want to check if the trainer and the player are on the same axis for example if this is the trainer we want to check if the player is roughly on this Axis or on this Axis or in other words if the player is for example here or here or here or here only then should the player be able to talk to this character after we have that we want to make the entities face each other that should be fairly straightforward then we have to block player movement and then we can start the actual dialogue none of this should be too difficult so let's Jump Right In back in the code first of all we have to get access to all of the trainers easily and for that I want to create another Sprite group on the groups I can duplicate the Collision Sprites because besides that I want to have a character sprites Group which like the Collision Sprites doesn't have to do very much it's simply there to get easy access to all of the characters when which means when we are creating all of the characters which happens down here we have to place them in three groups all Sprites Collision Sprites and self. character sprites that's all we need in here next up inside of the Overworld I want to check input as well at the moment the only input that we have is inside of the player class to move the player itself but I also want in the actual main game class have an input method let's place it right above run I want to check for input no need for custom parameters on this one and just as before I want to get all of the keys which we are getting with pame dokey doget rest and the key I care about is keys and pame Dot aore space and if I spell this correctly this could also work much better now if the player presses the space button I want to print for now dialogue now don't forget to run this method that is going to happen before we are doing anything else self. input now if I run all of this we getting an error because this should be key and Dot get pressed if I now press space we getting dialogue that means input is working but it's not working as intense it because even though I only pressed space once we got dialogue a few hundred times that is because of the frame rate all that py game really checks is if this button is pressed and then it prints dialogue and this happens on every frame of the game in our case our frame rate is probably around 2 to 300 meaning this method runs way too often and we getting way too much output if we had actual dialogue and we press space then we would skip dialogue 200 times so that's not ideal and there are broadly two ways to get around this number one you could create a timer that after Keys was pressed we have to wait let's say half a second to press the button again could be implemented and later on we are going to do something like that but for now an easier way of solving this is get just pressed if I now Run the game and I press space we only ever get a single dialogue output essentially get just pressed is only going to return newly pressed Keys which for any kind of UI work is incredibly useful so that is what I'm going to use also get just pressed is a pame c feature if you're using traditional py game you would get an error at this point so do be careful and make sure you have the most recent version of py game anyway after the play has pressed space we want to check if we are close to one of the characters for that we will need four character in self. character sprites this would give us all of the characters and basically what we want to do is we want to check the connection now this check connection is going to involve two parts imagine this is the trainer and this is the player first of all what we want to check is the distance between the two I.E if the player is within a certain radius of the character these two entities should only be able to interact if they are close enough should be fairly straightforward and on top of that we want to check if they are roughly on the same axis I.E if the player is either roughly here let's say with a margin of error or on this axis now this kind of check connection we are going to reuse a couple of times meaning I will keep this as a function and then actually keep it inside of support So in there let me minimize everything and all the way at the bottom I want to have some game functions while all the other stuff is import functions which means in here I want to have a function check uncore connections the same function we are using here and in there I want to have three arguments the radius the player and the character radius for this is always going to be 100 and player is going to be self. player after that inside of support we want to have a radius we need an entity and we will need a Target also we can set a tolerance that by default is going to be 30 pixels inside of this function first of all I want to get the relationship between the entity and the target which we can do via vectors very easily I want to get the vector of target. rect do Center and from that that subtract the vector of entity. rect do Center if this is our current entity and we have a Target their relation would be an arrow pointing from the center of one to the center of the other like this which is already really useful because on this thing we can get the length and then check how far apart these two entities are which we actually are going to do right now I want to check if relation do length is smaller than the radius if that is the case for now I want to return through and if we don't return anything this function is going to return none which is going to be falsy hence we only need a single return value now with that inside of main. Pi we can check if these two entities are nearby and if that's the case only then do I want to allow the dialogue output meaning now if I run all of this again I press space and we are getting an error because this should be check connections let's try it again if I press space nothing happens but if I get close to this character I can press space and we are getting dialogue I can move away if I press space nothing happens but if I get to this other character I can press space and we are getting dialogue once again so this is working really well that means next up we can work on the second part where we are checking if the player and the character are on the same horizontal or vertical axis now to understand how this is going to work imagine once again we have the player and we have the target with an arrow between the centers of these two ultimately all that we really have to check to for example test if those two are on the same horizontal axis we simply need to know the height of this line if it is below 30 then we know it is inside of the tolerance although we do have to be careful because below 30 could be any negative number which means what we actually want to check is the absolute value of relation doy if that value is below the tolerance only then do we want to return true with that I can run main. Pi I can press space nothing happens if I am on the left side of the character we are getting dialogue but if I go on top I can press space and nothing is going to happen because of the collisions this is a bit hard to see let me try another character this one so at the moment I'm on top of the character I can press space nothing is going to happen but if I am on the side we're getting dialogue so the system is working so this is kind of working but at the moment it looks a bit weird because the player is facing downwards and what I would rather want to check is if the player is is on the same horizontal axxis and if the player is facing the opponent only if those conditions are met as well then I want to allow dialogue now we do know which direction the player is facing that we are getting from get State we have a facing Direction this we want to use again which means what we actually want to check is first of all if entity dot facing underscore direction if that is for example left then we know the player is facing left on top of that we want to check relation dox is smaller than zero that way we know the player is facing to the left and we are to the right of the opponent and then finally we are also on the same horizontal plane only if these three conditions are met then I want to allow dialogue so at the moment we should only be able to talk to an opponent if we are on the left side and if we are facing that character so for this one there's no way to talk to her at the moment but if I go to the other character and I'm on the right side and I'm facing left I am getting a dialogue but if I am on any other side it doesn't work and if I'm facing the wrong way we also do not get a dialogue but if I'm facing her and the other conditions are met then we are getting a working system system cool so with that we have one side this we just have to expand a bit to cover the other sides as well for that I can actually just copy all of this because we only have to change a few things for the second line I want to check if we are facing right then we want to check if we are currently on the left side of the opponent and we still want to check if we are on the same horizontal plane that's the next part after that we have to do up and down I want to check if we are let's start with facing up then we want to check if relation doy is smaller than zero and we want to check if relation. x the absolute value is smaller than the tolerance nearly done the last thing that we have to cover is going to be if the player is facing down relation doy is greater than zero and the tolerance part is still just fine that should actually be all we need so we don't need the or at the end anymore and for once let's try a different character this one I can talk to him from this side from this side from this side and from this side but if I face another way or I am diagonally compared to him we are not getting a dialog so that system is looking to be working pretty good cool that also covers the check connections function we are going to reuse it later on but for now this is all we need from this one we want to block ler input after that we want to make the entities face each other and then finally we can create the dialogue to go through it step by step let's start with blocking the player input for that we have to work inside of the entities and let me minimize all of this so it's a bit easier to see inside of the entity under movement I want to add another parameter self. locked which by default is going to be false on top of that I'm going to create two more methods Define block with self which is going to set self. blocked to through and on top of that self. direction is going to become a vector with zero and zero that is definitely going to stop player on top of that I want another method unblock with self and all that this one is going to do is self. blocked is going to be false with those attributes in place I can look at the player input essentially what we want to do if the player is blocked we don't want to allow any input and we also do not want to allow anything inside of the move method which means inside of update these two methods should only run if not self. blocked I suppose we could put animate in there as well it's not really going to make a difference with that we can go back to main.py and then if there's a connection self. player. block let's try and if I talk to this character the player cannot move anymore although you do get some weird Behavior we simply stopped mid animation so actually I was wrong this animate does care about being inside of self do blocked if we take it out of it and try all of this again now we are getting the player blocked and we also getting back to the default State let's try this one again just to make sure it wasn't an accident with that we can block the player next up we want to make the enti face each other or in other words if the player talks to this Buck catcher the buck catcher should start facing the player for that we want to get the character and then call a function change underscore facing uncore direction for which we will need a Target position which will be self. player. rec. center now this method doesn't exist right now and we want to create it inside of the entity class it is going to be used both for the player and for the characters let's place it right below get State Define change facing Direction with self and a Target position like we have done with check connections we first of all want to get the relation between the Target and the current character the same thing we have done here I can actually just copy the line although we do have to update it because now the tar Target is going to be the target position and instead of entity. rec. Center we want to have self. re. center after that we want to check if they are on the same horizontal plane if absolute relation doy is smaller than 30 if that is the case we have to decide if we're going to face right or left in either case we want to update facing Direction and let's say by default we are going to go with right that should already work at least for One Direction if I now talk to this guy nothing is going to happen that is because this change. facing direction is being called but inside of the character simply nothing is going to happen the character never updates so it doesn't really matter what this attribute is doing it's not being used inside of the character all we need to fix that is Define update with self and Delta time and proper spelling and then call self. animate with Delta time the character already has the animate method because this one is part of the entity class if I now try this again we should be seeing an update and there we go this is working really well so next up let's finish up this method we only want this character to face right if the player is to the right of it or in other words if relation dox is greater than zero if that is not the case else it should be left after that we want to check if the player is on another plane I.E on the vertical one if that is the case self. facing direction is going to be let's say down by default if relation do y is greater than zero if that is not the case else it should be f facing up and with that let's try another character and make her face down that is working well and one more attempt let's try the character down here and she is facing up so that seems to be working just fine cool so finally we can start working on the actual dialogue which we want to initiate with create dialog a method we have to create let's do it right below Define create dialogue for the parameters we want to have self and the character which means when we are calling this create method we have to pass in the character that we currently have after that we want to create a dialogue tree class that is going to get the character it is going to get self. player it will need self. Sprites so we can show things and then it is also going to need a font now the font we don't have at the moment and that's the easiest part to fix after we have that we can create the actual class but let's first of all import some fonts that is going to happen inside of import Assets in there I want to have another dictionary self. FS now later on we are going to have quite a few key value pairs for now though I only want to have one for the dialogue which we create with py game. font do font then we will need the join method for the path and I want to go up a folder then I want to go to Graphics in there we have a folder called fonts and in there we have a file called pixel lloy ss. ttf for the font size I want to go with 30 now if I run the game we are not getting an error message so that is looking really good with that we have a font and that we want to paste into the dialogue tree right away which we do with self. fonts and we want to have the dialogue font next up we have to actually create this dialogue tree for that I want to create a new python file that I saved as dialog dopy as always we will need from settings and we want to import everything after that we can create a class called dialogue tree no need for inheritance and then inside of the dunder init method we have to cover all of the arguments I just talked about these ones here we want to have a character we want to have the player we want to have all Sprites and then we want to have let's call this one simply the font all of those need to become attributes so self. player is going to be player self do character will become the character self. font will become the font and self. all Sprites will be all Sprites with that the game is not going to crash anymore once we are talking to a character but fundamentally we're not really doing anything so how can we actually display some text for each of the characters well first of all for that we have to get some data and for that we need to import a file I haven't really talked about yet that one is called game data which is a massive dictionary so let me hide everything for now we only want to look at trainer data and this is a giant dictionary with the data for all of the trainers in the game and if we look at the first one 01 stands for Overworld one in fact if you look at all of the entities inside of the Overworld I believe the first character is this one yeah this one is called 01 or in other words via the character id we're going to associate this marker in the tile map with this entry inside of trainer data now in there we have quite a bit of information we have the monsters of this character we have the dialogue options we have the looking around directions and if the player looks around I.E if this character is looking out for the player then we're checking if this player was defeated and what biome he is in that could be Forest sand or a bit further down we have ice as well like this one now that is quite a bit of data and I suppose before we continue we have to get this data into the character class I.E inside of entities we have to get all of the data into this thing here for that I want to create another parameter character data for now I suppose let's simply print what we are getting after that inside of main.py when we are setting up the entirety of the Overworld inside of the characters we will need another named argument character data now the value from this one we are getting from game data this one and there we have trainer data although I suppose a better name would be character data but I guess both work just fine and from this dictionary we want to pick one item which we're getting via obj do properties the property we want to look at is called character uncore id or in other words this character id I just talked about if I now Run the game we are getting trainer data is not defined that's an easy thing to fix all the way at the top we need from gamecore data import everything now let's try this again and there we go we are getting the data for all of the trainers for example for the first trainer we have monsters then we have the dialogue options they start here we have directions defeated biome and so on that looks really good this character data we do want to store as an attribute self. character data is going to be character data on top of that I want to create a method for get dialogue no need for custom parameters and then we want to return the data for this character although this could be one of two options if you look at game data for example trainer 01 has a dialogue option for default and for defeated we want to get the right option depending on the character being defeated or not which means we want to return self. character data and the dialogue but then we want to create an F string which is going to be the defeated if self. character data is indeed defeated if that is not the case so else then we want to get default inside of game data we are simply checking if this value is true or false oh and by the way it's really important to keep all of the data inside of this dictionary I.E later on once the character is defeated this value changes we do not keep that data inside of this class that is important later on because when the player changes the map for example to go from an arena back to the Overworld then we are going to recreate this class and any attribute would be reset so we cannot keep data in here it wouldn't be persistent anyway with that we have get dialogue this we can use inside of the dialogue because in there we have the character so we can print character and get under score dialogue let's try this one if I now talk to the blonde girl we are getting an error that dialog tree is not defined that is quite fixable I want from dialogue import dialogue three let's try this again and if I talk to her one more time we're getting one more error that we are taking four positional arguments but five were given that is because I forgot self in there next attempt and there we go we are getting an actual dialogue output and I realized I was really bad with consistent quotation marks but doesn't really matter I suppose we should try another character this one here and this one also has a dialogue that looks pretty good cool next up instead of Simply printing the dialogue I want to store it as an attribute self. dialogue I suppose works on top of that I also want to have self. dialog number which is simply going to be the length of self. dialogue and finally I want to have self. dialog index which by default is always going to be zero once we have all of that I want to create self. Curren uncore dialogue which is going to be a dialogue Sprite this one doesn't exist just yet but we are going to create it in just a second for that we want to have a message we want to have the trainer we want to have groups and we want to have a font this dialog Sprite is what will actually display the message let's create it right away plus dialog Sprite Which has to have a parent of pygame Dos sprite. Sprite there we want to initialize the class with the message we want to display the trainer the groups and the font with that we can add actual arguments into this class for the message I want to have self. dialogue and then pick one of the options with self. dialog index trainer is quite easy this one should be self. character and I suppose I should always call this character groups is super easy this one is simply going to be self. all Sprites and for the font we want to have self. font we only have a single one inside of the dialogue Sprite then first of all we want to have super Dunder init and initialize the groups we will also need self. Z which is going to be World underscore layers and these Brides should always be on top after that we have to create the actual text I want to have a text underscore surface which we create with self. font. render we want to render the message nlas should be fults and the colors we're getting from settings in there we have a colors dictionary which means inside of dialogue I want to get colors and for this one I want to have a black color so that would give us the text surface but what we actually need is self. image I suppose for now we can simply set the text surface to the image just so we have something but this we do have to change anyway next up we want to create self. rectangle which will be self. image. getorf rectangle where we are placing the mid bottom to character do rect do mid up and we could add a bit of an offset let's say Vector 0 and 10 that should give us something if I now run main. pi and I talk to the girl we are getting an error message that we do not have a font that is because this font is not an attribute let's try this again and there we go I don't like sand we are getting one dialogue output now unfortunately it doesn't look particularly good for that inside of dialogue we have to work more with the Sprite the problem that we have to fix is that the image is simply going to be a text surface hence we have no background whatsoever after we are creating the text surface I want to set the width and the height of the background both of those should be basically the Tex surface and then we add some padding to it that padding by the way should probably be a local variable padding and I went with five pixels but simply choose what you like the most for the WID we want to get the text surface and then get underscore WID this would give us the width of the text surface this we want to increase by self. padding multiplied by two I.E this is our text and we want to have padding to the left and to the right and we're multiplying padding with two now there's one more thing that I do want to do and that is to set a minimum width which I'm doing with Max and then 30 that way our width is either 30 pixels or the text width that's the padding which every one is larger that way even if we don't have much text we always have a bubble that is noticeable for the height we have to do something fairly similar I want to get the Tex surface then get underscore height and to that I want to add self. padding multiplied by two there's no need to set a minimum height like we have done for the width because the height is always defined even if we only have a single character we always getting a sufficient amount of height next up we can create the background this is going to be a surface which we are creating with pame do surface for the two BS I want to have Whi and height and for now I want to fill the surface with a color self. fill color then I want to get my colors and the bubble color should be a pure white one of the colors we are specifying inside of settings this one this surface will then become the surface we are actually going to display which is a good start but with this system we're not going to see the text anymore we are simp getting a surface with the same size as the text which means we have to put the text on the surface which we do with serve. blit I want to blit the text surface in the center of this surface I want to get the text surface and then get F rectangle where we are setting the center to the center point of this surface or in other words we're getting the width and the height and the div either of those values by two we have a tuple with width divided by two and height divided by two and that should be it although I did realize that this shouldn't be self do padding it should just be pading because pading is a local variable if I now go to the character and I can talk to him we are getting a speech bubble that looks pretty good although it is very blocky that happens because this surface is simply going to be a rectangle and we are going to fix that by adding another argument pame do SRC Alpha that way we can set an alpha value for the surface and by default I want to fill the surface with well nothing I.E a tupo with z z and zero for RGB this value doesn't actually matter because we are going to specify another value for Alpha which is zero so we going to see anything of the surface let's try this one and there we go now we cannot see the background anymore which is totally fine because before we are drawing the text I want to go with py game. draw. rectangle I want to draw on the surface I want to draw with colors and pure white the rectangle I want to draw is surface and get F rectangle where we can set a top left of 0 and zero that way we are simply covering the entire surface with a rectangle so far that isn't going to do very much but what we are now able to do is specify two more arguments a border width of zero and then a corner radius of four with that if I run my Pi again and I talk to a character we are getting rounded Corners so that is looking pretty good and I suppose with that we can close the dialogue Sprite for now we will not need it for a while instead we have to figure out how to get to the next dialogue option at the moment we are only ever getting the first one for that inside of the dialogue tree I want to look for input just as before I want to get all of the press keys with py game. key get uncore just underscore rest then I want to check if keys and P game. Kore space if that is the case first of all I want to get rid of the current dialogue self. Curren dialogue. kill that way we are not going to see a dialogue anymore after that I want to get to the next dialogue index I.E the dialogue index we are using to pick one of the dialogue options this one we simply want to increase by one self. dialog index plus equal one finally we have to make a choice if self. dialog index is smaller than self. dialogue number if that is the case we know there is a next dialogue option available which means we can create another self. Curren dialogue which will be another dialogue Sprite with the same options we have specified up here I can literally just copy all of them and paste them in here however if that is not the case else then we want to end the dialogue although for now we can't really do that so I'm going to add pass in here also to make sure that we are actually calling the input method we will need Define update with self and in there we want to call Self do input however now we have an issue inside of this dialog tree we are checking for the space bar but inside of the main game we are also checking the space bar here so we have a bit of a problem at the moment we would activate both of those options meaning we would get the next dialogue option but we would also get an entirely new dialogue which we want to avoid I only want to check this input if not self. dialog tree only if we do not have a dialog tree do we want to check for this input although at the moment this attribute does not exist but we can fix that very easily when we are creating a dialogue I want to assign the dialogue tree to this attribute and then inside of the dunder init method and let me clean this one up a bit inside of the dunder init method I want to create self. dialog tree which by default is none and once we are creating a dialogue we want to assign the dialog tree to this value that way this if statement is going to run and give us all of this there's just one more thing I do want to do and that is we only want to create a new dialog tree if we currently don't have one I.E if not self. dialog Tree in here as well just as a safeguard that we don't create two dialog trees at the same time cool so with that we have our dialogue tree we just have to make sure that we are actually calling this update method for that inside of the game logic I want to create another section for the overlay and then check if self. dialog tree exists that I want to run self. dialog tree. update let's try I can now go to this character talk to him and we get some updates although this is way too fast let's try it again actually just so we can go through this one by one I am standing next to the character and if I now press space we very quickly go to the second dialogue option although if I press space again we get progress and then the dialogue disappears so this works but we cannot move we do have something but this is not ideal to start with the first issue when we are starting a dialogue we almost immediately switch to the second dialogue option that is because when we are creating the dialogue we are checking this input for the last time but then we also immediately get this input that way we are switching right away to the second dialogue index to avoid that we are going to need a timer that way we are ensuring that we only get this input let's say once every half second unfortunately the inbuilt pame timers aren't particularly flexible however I have made a timer class so if you open the file explorer and go to timer you can open this one and there we have a fairly simple timer class for which you can set a duration repeat auto start and a function you want to call once this thing times out now the class itself isn't terribly complicated and if you want to know more about it check out this video it builds the entire class up from scratch now in our case I am simply going to use it which we start doing by from timer import time and then we want to create one instance of a timer which I want to store in self. dialogue timer for that we want to create a timer class and the one argument we will always need is the duration in milliseconds which in my case is 500 or half a second after that I want to specify one named argument which is auto start true once we have that inside of the input method I only want to skip to the next dialogue if we are pressing the space key and not self. dialogue timer is active also whenever we are getting a new dialogue in this if statement I want to activate the timer which we do with self. dialogue timer and activate that way after we're getting a new dialog timer we have to wait for half a second to get to the next option finally the last thing that we have to do is call self. dialogue timer. update the entire logic of the class is basically inside of this update method if you look at the timer class in there we are basically checking our current time and then a start time if that difference is greater than a duration we want to deactivate the timer that's basically all that's happening inside of the class because of that we always have to call the update method to make sure that this class actually does something but with that if I now try the dialogue again we are getting Hi how are you do you want to fight and fight and then we are finishing the dialogue although we cannot move anymore and later on we also want to start a battle but for now I simply want to end the dialogue below create dialogue I want to Define end dialogue which will need self and the character we have for now we are simply going to set self. dialog tree To None also we want to get self. player and unblock the entire class so we can move around again with that when we are creating a dialogue I want to pass in self dot end dialogue for that to work inside of the dialogue we have to add another parameter and underscore dialogue and then save this one as an attribute let's do it all the way at the top self do and dialogue is and dialogue and then inside of the input if we are exceeding the number of messages we want to call self. end dialogue also this method expects one argument the current character which we have inside of an attribute so we simply have to pass in self. character so with that let's try to have a dialogue with this guy and while I'm talking with him I cannot walk around and we get to the next dialogue option and afterwards I can move around freely again so that is looking pretty good let's try the other lady this one and that is also working pretty well cool so with that we have a basic dialogue system there's just one more thing that we do need and that is if the player is walking in front of any of these characters I want them to talk to the player or a bit more generally for all of the characters I want to check their view Direction and if the player crosses it like we are doing right now then I want the character to move towards the player and start a dialogue for that we have to work inside of the entities and let me minimize things because we only care about the character at the moment to get started we first of all need a bit more information inside of the class we will need the location of the player we will need the ability to create a dialogue and we going to need the Collision Sprites now in case you're wondering we do need Collision Sprites because if this is the character and this is the player we might get a line of site between the two but this we want to block if there's an obstacle between the two which we are getting from the Collision Sprites now first of all we have to create a few more attributes self. player is going to be the player self. create dialogue will be create dialogue and finally for self. Collision Sprites we don't actually care about the Sprites themselves instead we want to have a list of collision rectangles which we can get via sprite. rect or Sprite in Collision Sprites although for this one we do have to be careful because we do not want to get the character itself remember all of the characters are also collidable objects meaning they are in inside of collision Sprites I.E we want to have all of the Collision Sprites if Sprite is not self with that we have the basic setup afterwards we will need a couple of movement attributes self do has underscore moved by default should be faults self. cancore rotate should be true by default and self. has underscore noticed which is going to be false has moved it's going to check if the player has already walked can rotate is going to tell us if this character can rotate around to look in different directions and has noticed is going to tell us if this character has noticed a player or not on top of that we will need two more attributes self. radius and we will need what I called view directions which is going to be list that for example contains left and right meaning this character is going to look left or right at random the radius we can get from til if you look at that and you click on any of the markers if they are a character they always have a radius although I think I was a bit lazy for this one because every single marker has a radius of 400 customize this in your own time for the game it's not going to make that much of a difference anyway in our case we want to get the radius that we put into the Class via the parameter radius for the view directions we have to look at game data in there for example for trainer 01 we have directions down so this character can only look down but for trainer O2 this one can look left or down and trainer 03 can look in all four directions this one we can get a bit more easily because we have the character data I want to get the character data and then get the directions with that we just have to figure out all of these extra parameters that we do inside of main. P when we are setting up the character down here we will need a whole bunch more arguments we will need a player this one is going to be self dot player then we will need create underscore dialogue I believe I called it which is self and create dialogue and make sure to not call this method after that we will need the Collision Sprites and the radius Collision Sprites are simply going to be self. Collision Sprites and finally the radius is going to be obj do properties and I think I C this want the radius let's run the entire thing and we are not crashing and if I talk to a character it's still working just fine cool good start but still the characters don't actually do anything meaning we have to add just a bit more Logic for that I have created a method that I have called Ray cast because ultimately what we are going to do is well we're going to cast AR Ray from the current character in the viewing Direction direction for example if this character is looking to the right we are casting out array in this direction if the player intersects with it then we want to do some more stuff that for now isn't too important we have to go through this step by step for this rast method we don't need any custom parameters and basically what we want to do in there is we want to check our connections once again the same method we have used inside of main. pipe when the player wants to talk to to a character this one or in other words the one that we have created inside of support. Pi this check connections for which we are going to need a radius entity and Target radius is going to be self. radius entity is going to be self and the target is going to be self. layer if that is the case for now to test it let's print layer also we have to make sure that we are calling self. rcast oh and finally we also have to make sure that we are from support import check connections after that inside of main.py we are getting an error that we cannot do a comparison between a float and a string that happens inside of entities with raycast and check Connections in there we are getting a problem on this this line and the issue is fairly simple when we are importing the radius this one is coming from til in there the radius if you look at the data type it is a string for some reason that is my mistake and not terribly easy to fix simply because we have a whole bunch of characters or rather I would say it's not easy to fix inside of tiled inside of pame we can simply convert all of the radi into integers and then this should be working so if I now go in front of this Buck catcher we can see player and if I go to other lady down here for all of the sides nothing is going to happen but if I am below her then we are getting player and finally if I go to this lady we can be below nothing happens but if I am to her left then we get more player output so if that is the case I want to get self. player and block the player also I want to update the player facing Direction which we do with self. player and then change facing Direction the method that we have created earlier inside of entity this one we can reuse that quite easily all we have to do is change the target which in this case is going to be self. re. Center self in this case is referring to the character let's try that one and if I now walk in front of the buck catcher the player cannot walk anymore and we are facing the character cool although the issue is that this is going to work even if there's an obstacle so even if we walking here the player is going to stop and face the opponent but this shouldn't happen because we have an obstacle in the way that we do have to check for to incorporate that I will create another method that I called hasore Lo short for line of sight no need for custom parameters in this one and basically all we want to check first of all if the vector of self. Rec do Center and then distance to self. layer. rect do Center if that value is below self. radius I.E we are only doing stuff if the player is inside of the character radius if that is the case we want to check for all of the collisions between these two entities which should be a list of Boolean values I.E we only really care about if there's an object in the way or not we do not care about the size or the position we simply care if there's an object in the way that is all we need to know I.E this this should be a list of either true or false values but step by step first of all I want to get W for re in self. Collision rectangles the list we created in the dunder init method early on and on this rectangle we want to run a method called clip line this one wants to have two points a starting point and an end point our starting point is self. do Center and our end point point is self. player. rec. Center and clip line is basically going to check if we have a line if it passes through a rectangle if that is the case it will give us the line inside of the rectangle which we don't really care about we just want to know if this line exists in the first place which means we can wrap the return value into a Boolean function that way we ever get true or false and after that we can return not any and the collisions any is going to check if there's any True Value inside of the list if that is the case it is going to return true overall and in our case via this list we're getting lots of true or false values if there's even a single obstacle between the player and the character all of this is going to evaluate to true or to be a bit more precise because of this not we're getting the very opposite I.E if there are no collisions whatsoever this value is going to be true however once we have a single obstacle this value will become false that way we will know if we have line of sight or not which we can use inside of raycast I want to check the connection and self. L if I now try to run the game and walk below this obstacle we we do not get anything but if I walk on top of it so there's no obstacle we once again get the player block and we are facing the character so we can start working on the next issue and that is that I want the character to start walking towards the player for which we're going to need two methods the first one will be start underscore move with no custom parameters and in there we want to set a direction for this character so in other words self. direction is going to get a value self. Direction by the way already exists inside of the character because the parent class entity has a direction this one which means all that we have to find is the direction from the character to the player let's do that on the line before I want to get the relation between the character and the player for that I want to get the vector with self. player. re. Center and then subtract another Vector with self. re. Center this value we need to normalize or in other words we want to call the normalize method now for the direction I do not want to set the relation right away because imagine that this is the character and we have a line of sight going straight down but there is a bit of tolerance so the ual line is something like this and if the player collides with it like so our relation would be an arrow that tilts a bit to the right which might be okay for the game but I want the character to only move up or down or left or right there should not be any diagonal movement to get that I want to create a new Vector with relation dox and relation doy and then the trick is to round both values after that if the player gets into the ray casting area we want to start move now this is not going to do anything because the direction is not being used there's no move method inside of the character so let's create one no need for custom parameters we want to self. rec. Center plus equal self do Direction multiplied with self do speed multiplied with Delta time oh and for that we do need Delta time as a parameter so when we are calling self. move we can pass in Delta Time by default direction is going to be zero so there shouldn't be any movement let's try main. pi and if I go in front of the character it is well it's doing something the issue is we never stop moving but this part at the very least works now to fix that issue while the character is moving we're going to create another larger rectangle around it and if this area coll lights with the player then we are going to stop moving or in other words we want to check if not self. hitbox do inflate and let's go with 10 and 10 if this new hitbox collide rects with self. player. hitbox then we know we have a collision so we only want to move if this is not the case else I want to set self. Direction back to a vector with default values I.E 0 and zero and also I want to wrap all of this inside of another if statement we only want to do all of this if not self dot has moved and if there is a self dot Direction now self dot has moved we haven't touched yet but basically after this if statement is correct we know that the character has moved I.E inside of the El statement we can set has moved to R after that the character should not be able to move anymore all of the characters should only be able to move once so with all of that let's try main. p and the buck catcher should only work to the player and that didn't work and I think I know why when we are updating the rectangle of the buck catcher we are not updating the hitbox that is the same issue we had with the player because in there after moving the rectangle we also had to update the hitbox which at the moment we are not doing but we can fix that quite easily self. hitbox do Center is going to be self. rec. center now this should be working let's try and and the buck catcher is walking to the player and then keeps on walking nearly done we just have to fix the animation the issue we have at the moment is that the character spots the player inside of raycast and then moves towards the player and once we have reached a player we keep on checking the ray cast and then we are starting to move again and we're calling to move method and this keeps on going forever we have to break the loop which we can do with another condition in the if statement and not self do has moved let's try this again now and we should not be getting a walking animation that looks good also what we can do at this point after the character has reached the player we want to initialize the dialogue with self. create dialogue as an argument we have to pass in the character itself let's try that part and now we are getting dialogue and I can go to the next option fight and then walk around that is looking pretty good let's try another character this lady and this part is also working perfectly fine there's not that much more that we have to do and I think at this point we should do an exercise number one make the characters look around using the values inside of self. view directions on top of that create a timer that changes this direction I call this one the look around timer but you could call it whatever you want after this exercise you should have characters that look around in random directions and that should make the game feel much better so pause the video now and see if you can figure this one out inside of the character class I first of all want to create a timer for that all the way at the top we need from timer import timer next up in the dunder init method of the character I want to create self. timers this is going to be a dictionary because in just a bit I want to add a second timer but for now I simply want to have the look around timer which is going to be a timer with a bunch of values we want to have a duration auto start repeat and a function called once the timer times out now the duration is going to be 1,500 so the character rotates every 1.5 seconds auto start should be set to True repeat should also be set to true and then for the function that we are going to call once this timer times out I want to get self. random view Direction a method that does not exist right now so let's create it I guess we can do it right below random view Direction without any c parameters in there first of all we want to check if this character can rotate so this attribute if self dot can rotate if that is the case we want to update the facing Direction I.E self. facing direction is going to be one value of self. view directions for that we can use the choice method that we have to import all the way at the top I want from random import choice and that's more or less all you need to get some rotation although you do have to keep in mind that we have to update all of the timers for that inside of the update method before we are doing anything else we can do for timer in self. timers Dov values don't forget to call this one and then timer. update that should be it if I now run main.py and I look at the lady although I think she can only look left I don't there you can see she's looking e left or down so that is working pretty well let's have a look at this character I think she can look in all four directions and that is working pretty well cool and finally we have this guy who can only look down now the next question is is the dialogue thing still working and yep that looks good although you can see once the character is starting to talk to us it is still rotating that we need to fix which is going to happen inside of the raycast method once the character has notice the player we want to set self dot can rotate to false that way if I talk to a character again let's go to the lady at the bottom because she has more rotate options he's still talking to us and now she always looks in the player Direction so that is working pretty well also while we are here I want to incorporate the has noticed attribute once the character has noticed the player self do has noticed is going to be true and then we only want to check the raycast if the character hasn't noticed the player yet I.E and not self. has noticed on occasion I get a buck without this one where the character kept on looking for the player but any anyway we are making some pretty good progress there are just two more things that I want to implement the first one is if you look at the game data you can see that some characters can look around While others cannot look around for example character O2 should not be looking around for the player or in other words if the player walks in their line of sight they shouldn't start to talk to the player only the player can talk to them the way we are going to implement that is we only want to call rast and move if that condition is true I.E if self. character data and we are looking for look around only if that is the case do we want to call these two methods if I now run all of this we are getting an error because inside of game data I call this look underscore around let's fix that one really quick look underscore around and now main pi I think this one is character two and now even though I'm in her line of sight we are not getting any kind of dialogue but if I talk to her we are still getting the dialogue but she keeps on rotating so that we have to fix I suppose the easiest way of doing that is once we have start talking with the character this if statement we want to get the character and then set can underscore rotate to false or in other words we are only rotating if this can rotate is true if I talk to the character she's pointing at us and she stops the rotation that looks pretty good that was the first point and for the second Point let me run the game again imagine that this lady has line of sight and actually wants to talk to the player if that is the case I want the player to stop for a little bit let's say a second and also have a notice symbol at the top so the player notices that he was well noticed for that we have to implement a couple of things number one inside of the entities I want to work in the player for just a second in there I want to create self. noticed which by default is going to be false after that we can work inside of the character and once the player has been noted inside of this if statement I want to get self. player and then set noticed to grp that way we know that the player was noticed and if that is the case I want to display an exclamation mark on top of the player or rather if I look at a graphics folder inside of UI we have a notice graphic this is what I want to display above the player once the player has been noticed the easiest way to implement that is in inside of the all Sprites group first of all in there I want to get self. notice uncore surface which we get with import image I want to go up a folder then I want to go to graphics and there we have UI and the graphic I want to import is called notice after that basically after we are drawing all of this I want to add another check if Sprite is equal to player and player do noticed in that case I want to get self. display surface and then blit self. notice surface after that we will need a position for that first of all I want to create a rectangle which we get with self. notice Surf and then get underscore F rectangle where we want to place the mid bottom the the position for this one should be sprite. w. midtop which should be the midtop of the player remember the Sprite is going to be the player after that for the position I want to get the rectangle and don't forget we have to add self do offset for the camera and with that we are getting an error that player is not defined and that I believe happens inside of groups ah there we have the issue the player at the moment does not exist inside of this draw method I suppose the easiest way of getting the player is for the one parameter we don't want the player Center we just want to have the player IE inside of main. Pi we are not passing in player. rec. Center we are simply passing in the player itself and then when we getting the player Center this would be player. rec. centerx and for player Center one we would simply get player Center y after that the game does work again the camera also works that's a good sign and now if I walk into the notice radius we are getting another error that we are inside of groups uh adding an offset to a rectangle this should be re. top left next attempt and there we go now we have the exclamation Mark although the character starts walking way too fast so you can't really see it very well first of all I want to create another timer I call this one noce it's going to be another timer the duration for this one is 500 and we want to declare a function which is going to be self. start move the start move we already have so the idea is once the RAS triggers then we want to start the timer and once the timer triggers out we are calling start move or in other words we do not want to cause. move right away instead we want to get self. timers and notice and then activate the timer also there should be a comma at the end of this and that's basically all we have to do this function is now going to be called after the timer times out and then means if I walk in front of a character we have to wait half a second for anything to happen but the rest still works just fine although the notice sign doesn't disappear not ideal after the character has walked towards the player we want to set self. player. noticed back to vaults I can walk in front of him again we have to wait we are talking and that looks pretty good cool we can try this again with another character down here there we go that looks pretty good and we are getting dialogue and with that we have finished the character dialogue this was a larger section but now the game is much more interactive another really important part of the game will be a transition system so for example we can transition from the Overworld to an arena or we can transition from a dialogue to a battle scene for that let's start with a level transition the basic logic is actually fairly simple number one we are going to fade to a black screen during this black scene we are going to delete all of the Sprites and then we are going to rerun self. setup with another titled map by the time the player can see the level again we have a whole new level although before we can start with that we need to get the level transition areas for that inside of til let me display all of the objects and then we have another layer called transition this one you have to zoom in a bit is basically just a layup full of very small areas which are going to be the entrance areas for the doors for example this one gets us to the hospital this one would get us to the house or if you look at another one a bit further up we have the entrance for the arena this one all of those transition areas have two custom properties a position and a target the target is going to be the tile map we want to load and the position is the position within the tile map where the player should start that means inside of main. Pi we need to do two things number one inside of the setup method I want to add another let's do it below the objects I want to have my transition objects just as before we will need a for loop with for obj in TMX map. getet layer by name the we want to get is called transition for this one we want to have a very specific kind of sprite one that doesn't exist yet which means inside of sprite I want to collapse all of this and then create a new class transition Sprite Which will inherit from the Sprite class fundamentally nothing too complicated is going to happen in here we want to have self we want to have a position we want to have a a size then we will need a Target and we will need groups notice for this one we are not going to load a surface simply because we don't need to those tiles are not going to be visible we can simply create a surface with pame do surface right inside of the dunder init method using the size next up we can call Super Dunder init and pass in the position the surface and the groups on top of that we we want to store the target IE the ti map we want to load as an attribute self. Target is going to be Target that is all we need next up inside of main.py I want to import the transition Sprite as well with that inside of the for loop I want to create a transition Sprite for every single one of the objects let's copy all of the parameters we need all of this position is fairly simple obj dox and obj doy for the size it's not going to be much more complicated obj do WID and obj do height now for the Target we want to have it Tuple that is going to contain both of these properties IE which map we want to load and the starting position of the player for that we will need obj do properties and we want to get the Target and then obj do properties with the position nearly done the last thing we need is the groups and for that I want to have all of those Sprites inside of self. transition uncore Sprites this group does not exist yet so all the way at the top in the dunder init method I want to create self. transition Sprites which once again is going to be pame dos sprite. group like with Collision Sprites and character sprites we are only using this group to identify the transition Sprites that's all it needs to do which means next up I want to create another method although before that I think we should organize the game class just a bit better for example the input along with create dialogue and end dialogue should all be the dialog log system under init import assets and setup is going to be General stuff after that I want to have a transition system I think that organizes the entire thing just a little bit better anyway I first of all want to do a transition underscore check no need for custom parameters and really all we want to do in there is first of all check if the player is colliding with any of the transition Sprites or to be a bit more specific I want to check if the hitbox of the player collides with any of these areas I want to store them inside of a sprite's variable and for that we can use list comprehension Sprite for sprite in self. transition Sprites if sprite. rec. collide rect with self. player. hitbox or in other words we are are looking at all of the Sprites inside of transition Sprites and pick the Sprites that are colliding with the player hit box if there are any Sprites then we want to get the player and block it let's check if this is working in the first place meaning inside of the run method sometime before we are drawing everything I want self. transition check and I think this part could also be a bit better organized we first of all want to fill the entire surface with a black color and this could even be all the way at the top there we have Delta time and self. display surface. fill then we are updating the game in there we check input transition check and all of the updates after that we are doing the drawing then we're doing the overlays and then we are updating the screen that feels much cleaner anyway let's try all of this and if the player goes to this area we cannot walk anymore that is working pretty well so now we have to work on a transition Logic for that first of all we are going to need a few more attributes I suppose right below the groups we can add a transition or screen tint system first of all we want to have a transition uncore Target which by default is going to be none this target we can update right away actually because what once the player is colliding with any of the transition Sprites then we want to set self. transition Target to sprite. Target although we do have to be careful Sprites at the moment is a list and we only want to get the first item of this list I.E Sprite index zero and then the Target also this should be Sprites next up we have to work on the tinting logic first of all for that we will need a tintore surface which is simply going to be pame do surface with the same Dimension as the actual window I.E the display surface which means I can copy the window width and window height and paste it in there I also want to have self. tint mode which by default is going to be untint if we are tinting the screen we're going to Black and if we are unting it we're going from black to transparent after that we want to have self. tintore progress which by default is going to be 255 we want to have self. pintore Direction which by default will be negative 1 and finally self. hore speed which I have set to 600 that will give us all of the basic attributes that we need now we have to implement the system although first of all once the player collides with a transition Sprite we also want to set self. tint mode to tint with that we can actually start with the system I call this method tintore screen this one is going to need self and Delta time we want to check if self. tint mode is equal to tint the value we are setting inside of the transition check if that is the case we want to get self. tint progress and increase it by self. tint speed multiplied with Delta time Delta time is really important so we have the same transition speed regardless of the frame rate that way we are increasing the tint progress although by default it is 255 let's set it to zero for now that's going to make debugging a bit easier I want to use the tint progress to update to transparency of the tint surface self. tint surface do set uncore Alpha to self. tint progress in case you haven't used set Alpha all it does is it well sets the alpha value I.E the transparency of a surface and the value goes from zero all the way to 2055 at the moment our tin progress is going to be zero but because because of this line we are going to increase it and to actually see it we will need self. display surface do blit with self. tint surface with the starting position being zero and zero this tin screen we actually have to call which needs to happen on top of everything else I did it right below the display update self. tint screen that part is really important because if there's any other element on top of the tinting it's going to look really weird also don't forget we need Delta time in there let's try and if the player collides with a transition Sprite we are fading out so this system is more or less working we just have to add a few more parts to it most importantly we want to check if self. tint progress is greater or equal to 255 I.E our screen is entirely black if that is the case I want to call self. setup again and remember for the arguments we will need a TMX map and a starting position for the player for the TMX map I want to get self. TMX Maps along with self. transition Target and this one should be zero for the player starting position I want to get self do Transition Target with one remember transition Target is simply going to be a tupal the first value is the map we want to load and the second value is the player starting position inside of that map on top of that we want to set self. tint mode to untint and also we want to clear the transition Target I.E self. transition Target is going to be none next up we have to implement the logic for the UN tinting I suppose we can do that one all the way at the Top If self. htin mode is equal to untint if that is the case self. tin progress is going to be minus equal self. tin speed multiplied with Delta time let's try all of that and now if I get to a door we are getting a key error the reason for that is inside of import assets we only have two TMX Maps world and Hospital let's try to hospital instead if I get to this part we first of all get a huge waiting time and then we're getting a key error so step by step the first issue is when we are calling self do untint the tint progress is actually a really large number in fact let me print self. tint progress if I now Run the game this number becomes increasingly negative and only once we reach the door then this number reverses and it becomes larger and larger but we have to wait for it to become positive for actually something to happen to fix that I want to limit self. tin progress to a value between 0 and 255 which we can do by setting self. tin progress we are using the max function with a floor value this one would be zero and the other value would be self. tint progress with Max we are selecting the larger of the two numbers I.E we are never going to go below zero after that I want to use the mint function for a ceiling via that we are always going to pick the lower value which can be tint progress or 255 with that we can never go beyond 255 or below zero let's try this one and now we get zero at our lowest value and if I hit the hospital we are getting to 255 at the most not even that however then we're getting a key error direction for that error we want to look at the character because in there we are not getting a Direction and that is an error inside of the tile map if you look at the TMX map that we want to load for our player starting position we have a direction and a position that part is fine but for the mark 2D for the nures we don't have a direction or radius now that we can fix quite easily by adding a property we need a direction which should be down by default and we will need a radius which can be zero for nurse after we have that I want to run the game again and now if I go to a hospital we get well we get something so the issue is we have the hospital but we also have the arena and well that's not ideal the problem we have is that when we are calling the setup method we are not getting rid of all of the previous Sprites I.E we can still see the original Overworld which is going to look incredibly weird and to fix that we want to First of all clear the map all we need to do for that is for group in self do for Sprites self. Collision Sprites self. transition Sprites and self. character sprites we want to call group. Mt that way if I try all of this again we are only able to see the level although other than that we still get collisions and that is working pretty good and we can also go back to the overw world so quite happy with that now the issue is if we try to go to another area we're getting a key error to fix that we have to import all of the TMX maps that is going to happen inside of support. Pi and let me minimize everything I want to create a TMX importer which is going to need a path unpacked and then we want to create a TMX dictionary which by default is going to be entirely empty after that I want to have the for Loop that we have already seen in which I am getting the folder PA the sub folders and then in this case the file uncore names this this will be all of the TMX files in walk with join and the path we are getting from the parameters after that we want for file in file names and I suppose for now let's simply print what we are getting that way inside of main.py I want to print the return value of TMX importer for the path we want to go up folder then we want to go to data and in there we have our Maps if I now run all of this we are getting all of the TMX Maps also we are getting a whole bunch of zeros that happens because of this print statement that we don't need anymore so at the moment we can get all of the names of the TMX maps that we want to import that we can use to create a new ENT tree inside of the TMX dictionary I simply want to get the file and then split it wherever we have a DOT and then pick the first value that way we are getting rid of the TMX ending the value Associated is going to be ladore py game the method we have already used inside of the Overworld this one this we want to reuse and we already have the import statement I want to create a path via the join method I want to get the folder path and then the actual file after that I can return TMX dictionary and now if I run main.py again we are getting a dictionary with all of the tiled maps that value we want to store inside of the attribute TMX Maps I want to cut this part out and then get rid of this entire dictionary and simply use the return value for from TMX importer felds significantly cleaner and now that we have that let's try the game and if I go into a house we have a house along with the collisions and that's kind of all we can do in here so if I go out again we are back in the Overworld I can try the hospital again and this one is also working we cannot talk to the nurse at the moment but that we can cover later anyway for now I think this is looking pretty good what you can also do at this point is you can take the start position and then drag it let's say all the way up here to test the water Arena don't forget to save if you not run the code you can check out the water Arena and there you go looks pretty good we can also leave again and then we could check out the other Arenas do that in your own time and with that we have finished the entirety of the Overworld now in dat bits we have to come back to add some additional Parts like the nurses or the dialogue to battle system but I think for now we have a pretty good setup which means next up we can actually start working on the monsters now that we have the Overworld we can start with the actual monsters and there are three things we have to cover the most important part is the actual battle system and this one will become quite large besides that we have the monster index and we have the evolution system now these three system systems work kind of independently so we can approach one at a time and I think the best way to get started is with the monster index this one is going to show us what monsters we have and all of their stats along with their abilities on top of that we are also going to create a pretty fancy UI although before we can get started with that there is a bit of groundwork we have to cover most importantly for all of the monsters there will always be a dedicated monster class that stores the data and there we are going to keep the health the energy the level the XP all of the stats and abilities and so on now this monster class will never be visible we are always going to create a dedicated Sprite or an animation for example in the battle we have a monster Sprite that is connected to the monster class and inside of the monster index we simply have to play an animation by add that system we can keep all of the stats inside of the class and then simply use them in different parts of the game let's start with that part here we are in the code and I do have quite a few tabs open I don't really need them anymore we don't need the dialogue we don't need the timer we are going to need the game data we are not going to need the groups at least for now we don't need the entities we are not going to need the Sprites and we are not going to need support So at the moment I only have main.py game data and settings.py open although I do want to create a new python file that is going to be monster do I in there I want to create a class called Monster no need for inheritance and also notice here we are not using py game since this class is only going to store data there's nothing we need from py game for this I want to create a Dunder init method with self I want to have the name of the monster and then I want to have the level of the monster now the way the system is going to work to get all of the stats and graphics for the monster via the name from game data we're going to pick one of the monsters so if you look at Monster data there we have all of the monsters and if you look at one of those let's say chamad there you have all of the stats for example this monster has the element fire Max health max energy attack defense and so on there's a bit more data in there besides that we have the abilities and whenever the monster reaches a level we're going to unlock and ability finally we have an evolution although this monster doesn't have one but if you look at the next one Finster there we have an evolution we are going to get to gulfin at level 15 so essentially this is what we are going to import and then we have the level that one should be fairly straightforward and basically what we're going to do later on inside of the game data let's have a look at chamad again and let's say for now we only care about the health and this monster has a max health of 27 this is the basee health and that we're going to multiply with the level for example if the monster has a level of 10 then we are going to multiply that value with Max Health I.E 27 so the actual health is going to be 270 all of this data we have to store first of all I want to have self. name and self. level which is simply going to be the name and the level after that I want to get all of the stats of the monster first of all I want to have self. element this we're going to get from the monster data so let me import it all the way at the top I want from gamecore data import monster data and then I want to have monster data I want to use the name of the monster and then I want to go to Stats and finally in there I want to get the element besides that I also want to get all of the base stats which are going to be gotten in basically the same way I can copy the last line and I simply want to get all of the stats with that we have a monster with a name a level and some stats that we can use right away inside of main.py first of all in there I want from Monster import monster and then inside of the dunder init method let's do it all the way at the top I want to create the player monsters which we can store in a dictionary self. player monsters we have the first Monster and for that we need the monster class along with the name of the monster and the level let's say the first Monster could be charm mod pillow at level 30 after that we have monster number one this needs to be another monster what a name for this one let's go with frea and level 29 if I now Run the game we still get the same outcome and I should fix the start position but at the very least nothing is breaking that's a good start now I would recommend to create a few more monsters on your own if you look at game data you can find all of the available monster names in my case I can simply copy it in where we have a whole bunch more monsters also it's really important to keep an integer as the key that way we can sort the actual monsters that will become important very soon anyway at this point we have a bunch of monsters so we can start with the actual index for that I want to create a new python file and save it as monster uncore index don't forgetp and in there we need from settings and import everything then we can create a class I call this one monster index no need for inheritance but inside of the dunder init method we will need self we will need the monsters and then we are going to need some fonts for now after that we want to create self. displore surface which we're getting from pame do display doget uncore surface next up we have to store the font as an attribute self. font is going to to be the font oh and actually this should be self. fonts because we are going to have quite a few different ones in fact inside of main.py when we are importing the assets we want to import a few more I suppose we can do all of the ones that we are going to need for the rest of this tutorial just duplicate the line besides dialog we want to have a regular font which is going to have the same file path the only difference is that the font size is going to be 18 we can duplicate this one more time next up I want to have a small font and this one same font again except now the font size is going to be 14 and finally I want to have a bold font and this one is going to get a different font this one is called doic pixel bolt. ttf and the font size is going to be 20 let's try to run all of this and we are getting an error probably because I have a typo in there somewhere let's double check inside of our Graphics font folder we have DOA pixel Boldt so I think the spelling is correct although the file type is wrong this one is an open type fun file which means the ending is going to be OTF let's try this again and there we go the game is running again now that we have that we can minimize this method and then inside of thunder in knit all the way at the bottom I want to create the overlays so in there we're going to have the monster index and the battle system along with the evolution system in fact the dialog tree could also be in there because it's technically an overlay I want to have a self. monstore index for which we are going to need the monster index class that we are not importing at the moment let's do it below here from monster uncore index I want to import the monster index after that we have to pass in I believe it was two arguments we need the monsters and the fonts monsters are going to be self. player monsters and the fonts are going to be self. fonts the thing we have just imported those ones let's try to run all of this the game doesn't crash that's a good start so with that we can start drawing the actual monster index for that first of all I want to create an update method with self and Delta time Delta time in case you're wondering is what we're going to need for the animation inside of this method there are four things that we want to do number one we want to get input number two we want to tint the main game so that we have a bit more of a separation between the game and the monster index after that we want to display the list and finally we want to display the main section just to explain the last two bits if this is our window our monster index is going to look something like this on the left side we are going to have a list of all of the monsters and this one is scrollable so if the player presses up or down we can select one of the monsters and then on the right side we have the actual information with the monster on top all of the stats and then all of the abilities and when I say tinting the game I am talking about tinting the entire rest of the screen and input is well input and I think the easiest thing to get started is with the tint screen that we can do in the dunder init method I want to create a tint surface section and in there I want to have self. tintore surface this is going to be just another surface so pame do surface with the same size as the original display surface I.E from settings I can copy the window width and the window height and then add them in there as a tuple the color of this surface we don't have to change because we want this thing to be black but we do want to change the tint surface Alpha that we do with zore Alpha and for the value in here I went with 200 once we have that all we need to do inside of the update method is call Self dot display surface dot blit we want to blit The Tint surface at position zero and zero that way we cover the entirety of the window after that inside of main. Pi in the run method let me get rid of the whes space inside of the overlays we want to add another section if self. monster index then we want to run self. monster index do update with Delta time if I now Run the game we can see we are tinting the entire screen so this is definitely working now obviously we don't want to display the monster index all the time for that we have to work with the input method inside of main.py at the moment we are only checking if the player is talking to another character besides that I also want to check if keys and pame do Kore turn that is the enter key if that one is pressed we want to display the monster index and there are basically two ways of approaching this either inside of the dunder method you could set none for the monster index and then as soon as the player presses this button we are creating a new monster index very similar compared to what we have done with the dialogue although that's a bit Overkill since the monster index doesn't have to change that much we can approach this in another way that is a bit easier I want to create another attribute self. index open which by default is going to be false and then inside of the run method instead of checking if the monster index class exists I want to check if self. index open and only if that is the case I want to run the update method on this monster index after that whenever we are pressing K return I want to toggle self. index open which you can do by setting it to what it is not I.E not self. index open with a Boolean value we are always going to get the opposite value I.E true becomes false and false becomes true and if I now press enter we can toggle the overlay that is working pretty well now the issue is while the monster index is open we can still walk around which is going to look really weird to fix that we have to do is get our self. player do locked and set it to what it currently is not I.E not self. player dot locked that way in the overboard I can run around if I press enter we get the overlay I cannot walk around anymore and if I press enter again we can walk around once more cool this part is working that covers the first part now we have a background tinting now we can work on the actual monster index and first of all I want to set the dimensions that we are going to do via self. mainor rectangle which is simply going to be pame do F rectangle where we are setting a left side a top side a width and the height now the left and top doesn't actually matter so I can set those to zero and and zero for the wi I want to get window wi and then multiply this with 0.6 I.E we're getting 60% of the window width for the height I want to get the window height and then multiply this with 0.8 or in other words we're getting 80% of the available window height now this rectangle has to be moved to the center and at the moment we are always placing the top left and I am too lazy to calculate the proper position for the top left to Center this rectangle but fortunately I don't have to do that I can simply use the move uncore 2 method and then set Center to window Wii over two and window height over two although all of this needs to be a tal with that we're getting the main rectangle in the center of the window let's try that part actually I want to run P game. draw. rectangle on self. display surface the color doesn't really matter let's go with black and then we want to draw self. main rectangle inside of main. Pi if I press enter we can see the available area for the monster index and that looks pretty good and if you want to have different dimensions go with it you can choose whatever you like in here next up I want to work on the actual list I.E with we're going to start by displaying the list of all of the available monsters for that actually we're going to need all of the monsters as an attribute let's do that at the top self. monsters is going to be monsters after that we can work on the list and there are quite a few attributes that we need to get I want to get self. visible items which I have set to six I.E how many monsters do we want to display at any point in time besides that we want to have self do listor wi this number we're going to get from self. Main rectangle do WID and I want this thing to be 1/3 of the entire available WID of the main rectangle although once again these numbers can be subjective so just choose later on what you think looks best after that I want to get another attribute self. itmore height which is going to be self. main wct do height divided by self. visible items the way you want to think about that is if this is our entire monster index the thing we are setting with main rectangle on this thing we want to create a list roughly on the left side the width of this thing we are setting with list width and then the item height is going to be the item height of all of the items in there and I think that's all we need for now so next up we can work on let's call this method display uncore list no need for custom parameters and in there we want to get four index and monster inself do monsters. items remember monsters is a dictionary that we have created earlier this one I.E the index is going to be zero and then the monster is going to be all of this for the first four Loop and that continues until we get all of the monsters most importantly in there we want to create an item rectangle which we create with pame do F rect where we have to set a left a top a WID and a height like we have done for the main rectangle WID is going to be self dot list wi and the height is going to be self. item height left is also going to be super easy this is simply going to be self. main rectangle do left the only thing that gets a bit more complicated will be the top argument because of that I want to store this in a separate variable imagine we have our list and on this thing we want to have a whole bunch of entries for each of those we have specified one rectangle which means we get a height we get a whift we are getting a starting position that's the left side and the only thing that's left to cover is the top side now we always want to start at the top of the main rectangle the one we have to finded earlier but then for each individual item we want to go a bit further down to actually get a list which essentially means we do want to start at self. main. toop but to that we want to add the index that we getting from the four Loop and this we want to multiply with self do item height that way on the first for Loop index is going to be zero I.E we stick to this top side however if the index goes to one then we are adding one times the item height I we are moving down by the height of one item and we are getting the top of the next item that's basically all that's happening in here after we have that we want to draw the result pame do draw. rectangle self. display surface the color should be red so we can see something and then the item rectangle after that inside of update I can get rid of the display list comment and it's that self. display list if I now try m not Pi I can press enter and we are getting something now this is very difficult to see because all of the items have the same background color but essentially we get one of those items here we get another item there another item down there and so on in total we are going to see six items that cover the height of the main rectangle but after that we are continuing because the player has more than six monsters in fact at least for now if we keep the monster size 26 this should actually work perfectly and there we go this is looking a bit cleaner now later on we're going to account for more monsters so I do want to keep them in there but at least at the moment we know this is working on the basic level and I suppose to make sure we can see things just a bit better I want to create a text surface which is going to be for the name of the monster for that I want to get self fonts and I want to get the regular font this I want to render with monster do name ntls should be fults and for the text color for now I want to use colors and the white color so inside of settings then we have a white color for this text surface we are also going to need a text rectangle text surface. getorf rectangle I want to place the mid left and this point should be the item rectangle do midle as well if this is the entire list we have currently one item rectangle this one here and the text should be let's say roughly here for that I want to place the mid left of the text to the mid left of the entire item rect angle and in just a bit we can add a bit of an offset to the right first of all though I want self. display surface do lit with the text surface and the text rectangle let's try all of that if I not press enter we are getting all of the monster names and that is looking much better and to add just a bit of offset I want to add a vector with 90 and zero that way if I remain. P again we are moving quite a bit further to the right and later on to the left of the name we have a Monster icon for every single Monster in fact if you look at the graphics folder there we have icons and this is going to contain all of the Monster icons we want to display next to the name that is a part we could do right now actually this could be an exercise I want you guys to import all of the Monster icons and then display the appropriate one next to the monster name pause the video now and see if you can figure this one out to get started we have to work inside of import assets because we have to import all of the Monster icons and to keep all of that a bit better organized I want to create another dictionary I call this one the monster uncore frames which is going to be a another dictionary that works basically like the Overworld frames first of all in there I want to have all of the icons and to import those we need our support file again meaning I want to open support. pi and in there we want to use one of those functions to import all of the icon surfaces and what is really important is that we want to keep the name of all of these graphics and for that import for the dictionary is the best one because this One Imports all of the graphics and then keeps the name so we are going to get a dictionary with the name and a graphic I want to import a folder dictionary and the folder path is going to be a folder up I want to go to Graphics then I want to go to icons and that's the folder I want to import then I can print self. monster frames and icons to see what we get if I now run all of this we are getting addictionary with the name of the file along with a surface that means next up when we are creating the monster index I also want to pass in self. Monster frames we don't need support. Pi anymore and inside of monster index I want to have the monster frames from that let me add another section with the frames for now I simply want to get self. iore frames which is going to be the monster frames and I want to get the icons after that inside of display list I want to create an icon surface which is going to be self. icon frames with the monster name next up I want to create an item rectangle which is going to be icon surface and then get F rectangle for this one I want to place this Center once again I want to get the item rectangle do mid left and to that I want to add a vector with 45 and zero to give it just a bit of an offset since the offset for the text is 90 this 45 is going to be right in the middle between the left side of the main container and the left side of the text the last thing we have to do is self. display surface do blit with icon surface and icon rectangle let's try main. p and there we go we can see all of the monsters and if we had a better background color this wouldn't look entirely terrible so instead of using the red color I want to get the colors and the color that I actually want to use is going to be gray next attempt and that is already feeling significantly better and while we are here we should also get rid of the overlap I.E monsters that are not inside of the main rectangle should not be displayed which is actually fairly simple we only want to draw an item if it is inside of the main rectangle which we can check with if item rectangle do Collide wed with self. main rectangle only if that is the case do we want to do all of that let's try this again and there we go now we can only see six of the monsters although the issue at the moment is that none of this is interactive for that we have to get some input I.E Define input no need for custom parameters and then there as usual we want to get all of the keys with pame DOT key and get uncore just uncore rest at the moment there are only two keys that I care about P game. Kore up and I care about py game. Kore down so what do we actually want to do inside of them and well we want to get an index and either increase it or decrease it if we are pressing up we want to decrease it by one and if we are pressing down we want to increase it by one now this index doesn't exist right now I suppose let's create it in the list section self. index is going to be Z by default and with that we can update an index and increase it or decrease it although first of all for that we have to call self. input and just to make sure that this is working let me print self. index if I now run m not Pi I open the index and we are getting a number that's increasing or decreasing so that's pretty good that's a good start with that we don't need to print statement anymore and next up there's one more thing that I really have to do inside of input and that is self do index is going to be self. index modulus and the length of self. monsters very soon we are going to change the color of one of these rectangles depending on their index and for that purpose the index index from the input cannot be greater than that number but that's all we need from input so next up we have to figure out and let me draw this imagine we have a list with at the moment a random number of entries let's say three for now they would all have the index that we are getting from the index in the for Loop I.E we would have zero 1 and two besides that we also have the index that we are getting from the input if those two numbers are the same I.E the input index and the rectangle index are the same then we want to change the color of this current rectangle that way it looks like it's selected for that I want to add a section that I called colors we want to have a custom BG color and later on we also want to have a text color I suppose the text color we can keep white for now let me paste it in there and then when we are rendering the text we want to have the text color for the BG color though right now we are using the gray color so let me copy it in there and then use the BG color when we are drawing the rectangle however this color we only want to get if the current index is different from the input index I.E we want to get gray if self. index is different from index and the name here might not be perfect but just to make sure you understand this index refers to the for Loop index while this self. index refers to the input index that's part of the class however if that is not the case so else then we can get a different color and I want to copy this one the color I want to use is called light and that should already do something if I now open the menu and there we go we can see that we have at least some basic ability to select the monster now this isn't perfect yet and if I go too far down the thing disappears that happens because further down there we have a few more monsters but those we cannot see that's going to be the next issue we will fix but for now this is working reasonably well so next up then imagine this is the entire index or in other words this is the main rectangle the one with have been using throughout on the left side of the Swing we have a list and this list contains a whole bunch of entries on top of that we have a few more entries at the bottom at the moment I believe there are two extra ones as a consequence when we are trying to get the color and we exceed this point we highlighting either this or this monster but since those aren't visible it doesn't really do anything now to fix that issue basically if the index goes too far down we want to lift up the entire list or rather we want to lift up every single rectangle and for that we are going to create a v offset that by default is going to be zero however when we are getting the top side of each of the rectangles we want to add this V offset so at the moment this is not going to do anything if I run all of this no change however if I set the V offset to let's say 200 and I run all of this again we are now drawing every element 200 pixels further down however if I make this number negative let's say 00 and I run this again we are now able to see a few more elements at the bottom which means we have to make this V offset relative to the index I.E if we go too far down we want to make this offset negative or in other words by default this value should be zero but only if self. index is smaller than self. visible items if that is not the case else let's say for now 100 just to see what happens so if I now run may not Pi again in the menu I can move around just as before but if I go a bit further down we are now moving the entire list up and that's a good start and we can also reset it but this needs to be a bit more finetuned the way you want to approach this problem we once again have the list at the moment with six entries on top of that we are also checking if our V offset is below that point so our index would be further down here if that is the case we want to move the entire thing up by the height of one of those rectangles which means first of all we have to understand how many indexes we are below that list that number we can get and I want to put this in parenthesis right away self. index minus self. visible items and also this number needs to be negative all of that we want to multiply with self. item height let's try that and now if I go a bit further down this is almost working so we have to go two steps further down for this to work which means all we really have to do is to this number add a plus one and then it should be working and that is looking pretty good now we have a nice drop down menu that works just fine that covers the basic part of the list but there's one really important functionality that I also want to cover and that is that the player can rearrange all one of the monsters when a battle starts we are always going to select the first three monsters and the player should be able to choose what those are to implement that we want to look at the input first of all we want to check for another input if keys and py game. Kore space then we want to select one of the monsters for all that I want to create another attribute that we can put right below the index I want to have self. selected index which by default is going to be none basically as soon as we are selecting a monster we are selecting the index of that monster and by default this value shouldn't exist that value we can use because first of all we want to check if not self. selected index I.E at the moment we have not selected anything if that is the case self. selected index should Simply Be self. index that value by the way we can use right away because when we are displaying the list if a monster is selected we want to highlight it which we can do by changing the text color so by default the text color should be white but only if self. selected index is different from the index of the monster if that is not the case so else that I want to get colors and get the gold color let's try all of that if I open the index and select the first Monster by pressing space we get a gold color so that is working really well that means we can check the El's statement and I should explain the basic system is going or in other words we have a selected index then we want to switch those two monsters however if we are pressing space and monster has been selected for that we first of all want to get this selected monster which is going to be self. monsters with self. selected index and notice here we getting the actual monster on top of that we want to get the current monster which is going to be self. monsters with self. index once we have those two monsters we can assign them to a new index I.E self. monsters self. index is going to be the selected monster then I can duplicate all of this because self. selected index should be the current monster and finally self. selected index should go back to being none so inside of the game I can select a monster and then select another monster and this didn't work although if I now click on the first Monster again they do switch so logic does work but something else has gone wrong and I think I know why the issue is this if statement this one is going to trigger as soon as we have one selected monster but that's not exactly what I want instead I want to have if selected index is different from none if that is the case I want to get all of this with the El statement covering the monster being selected for the first time let's try this one now and if I select a monster and another monster they switch places so this system is working much better and I suppose I should go through all of this one more time imagine we have a list with a few entries they all have an index 0 1 2 and three if the player presses space on one of them we're getting a selected index let's say this one could be Z that way we are selecting the first Monster after that if the player presses space again we are triggering this if statement and let's say this happens on index 2 if that is the case we are first getting the monsters we have selected I.E the selected monster and then the monster we currently have targeted after we have that we are simply switching them around or in other words we are simply overwriting the indexes and after that we are getting rid of selected index and then we are done that covers the input there's just one more thing that I really want to do for the list actually two things I want to do for the list the first one is going to be rounded Corners if you look at this thing again it doesn't look amazing and the big reason for that are the really sharp Corners which usually do not look great those we can fix inside of the drawing logic let me add another comment check or nurse so what we want to check in here is if this is the entire main rectangle we have to check if an item rectangle is in the top left or in the bottom left if I of those is the case we want to have one rounded Corner either here or here which means we want to check if item rectangle do Collide point Enter point we want to check is cell main rectangle. toop left or in other words if the top left of the main rectangle collides with our current rectangle we know we are in the top left if that is the case we want py game. draw. rectangle self. display surface BG color item rectangle so all the stuff we have done already but then we want to set a corner radius that is going to be 0 0 and 12 and the logic for the drawing of the other rectangles we can put in an L statement although the text and the icon need to be always visible so let's add a bit of white space if I now run main Pi we are getting a rounded corner at the top left now this isn't perfect because we are also drawing the entire background main rectangle which we don't actually have to do so let's try this again and that is looking much better so next up I want to have an L if statement that checks if item rectangle. Collide point with self dot main rectangle bottom left although to this one I want to add a very minor offset of one and negative 1 I we're going one pixel to the right and one pixel up sometimes the bottom left wouldn't be properly detected by Collide Point don't know exactly why but it happened fairly consistently and if we had a minor Vector offset this problem disappears entirely so once we have that we want to draw a rectangle with a different Corner radius this one is going to get or zeros then a 12 and then another zero so let's try this one again and there we go if you now look at the bottom left we are getting around the corner and this one always seems to be working just fine now in case you're wondering what arguments you need for all of this if you look at the documentation for pame and you look at draw. rectangle you can see that we have a whole bunch of Border radi where you can for example set the top right radius the bottom left radius the bottom right radius and so on these numbers can be a bit confusing especially early on it even took me a few minutes to get this one right with that we have rounded Corners there's just one more thing that I would like to add and that is let me run all of this again actually in just a bit we're going to draw a whole extra thing to the right something like this and to separate these two areas I want to add a very minor Shadow down here so it looks like that all of these elements are a bit in the background now in practice all that we are going to do is we are going to draw a semitransparent surface down on here and then we can call it a day which means all the way at the end and this one should be outside of this for Loop let me minimize the for Loop actually we want to draw a shadow for which we're going to need a shadow surface first of all pame do surf then we will need a whift and a height for the whift I simply went with four pixels and the height is going to be self do main rectangle do height and then we want to get self. display surface do blit where we are blitting the shadow surface in a certain position for which we are going to need an X and A Y point now Y is PR simple self. main. toop for X we're going to get self. mainr do left and to that we want to add self do list wi although don't forget to subtract four to actually show The Shadow surface actually let me run the entire thing without it if I now run may. Pi we have a thing to the right of the list and together to the right border of the list we want to subtract four or the width of the surface and there we go now it's on top of all of the other items that however isn't terribly visible because this Shadow surface doesn't have a transparency which we can change with Shadow surface and set Alpha and then set some kind of value let's go with 100 and if I now run M of Pi that is looking quite nice later on once we have the other part of the index you can customize this but I think for now this is working reasonably well cool that covers the first part of the index although there's one thing that I forgot if you run May notp again there should be a whole bunch of of lines separating all of these monsters stuff like this and that part could actually be a fairly interesting exercise or in other words try to draw lines between the monster entries the colors for now don't really matter simply choose something that works what is really important is that you understand the positioning so pause the video now and see how far you get to get started I want to minimize the for Loop and then add another section for the lines first of all we going to need another for Loop let's call it for I in range and this one is going to be self. visible items inside of there we want to go with py game. draw. line for which we're going to need a surface self. display surface and then we are going to need a color which we can get from colors and the one I want to choose is called light gray finally we need a start point and an end point to get those points we essentially need three numbers the Y position the left side and the right side now the left side is going to be really simple self. main re. left and the right side is going to be self. main R do left plus self. list Wii that way we are defining the left and the right side now we just have to figure out the actual y position now this one also isn't terbly difficult self. main re. toop plus self. item height multiplied by I the value we're getting from the for Loop and with that we have the three points that we need so for the start value I need X and Y the start point is always going to be the left side and Y is going to be the value we have just created then for the end point we want to get the right side and keep the same y the line we are going to draw is going to be horizontal so one point here is totally fine let's try all of this and there we go we have a line separating all of the monsters and this one also updates with the movement so this is looking pretty good however there's one thing that is going to mess this one up a bit if we don't have enough monsters to fill the entire list let's say we only have three monsters in total if I now run this again we are drawing way too many lines which is going to look really weird to fix that inside of the for Loop we want to look for the smaller number between the visible items and the length of self. monsters if we are doing that we are only drawing two lines so that is working pretty well now we are still dra drawing the entirety of the Shadow and I think that part is fine I suppose once we have the other elements we can look at this one again but I think it's not going to be an issue anyway with that I can uncomment the other monsters and we have the list part of the index next up we have to work on the monster display so for that one we don't need display list anymore instead I want to Define display underscore Main in there we are going to need Delta time because because we will have a monster animation in just a bit first of all we want to create the main background for that we will need another rectangle which is going to be py game. F rectangle with the usual arguments left top W and height left is going to be self. main w. left plus self. list Wii if this is the entire main rectangle we want to have a list on the side with the list with being defined by the attribute this is the part we already have and what we want to do now is to create or rather cover the entire rest of the main rectangle at the moment we have the left side which is going to be this line or the top we want to have this line and then all of this for the width and all of this for the height should be fairly straightforward top is simply going to be self. main. top the WID is going going to be self. main. wift minus self do list wift and the height is going to be self. main. height now I am running a little bit out of space but this is still doable it's not terribly complicated or at least I hope it isn't let's actually draw this with pam. draw. rectangle where we want to draw on the display surface the color is going to be from color and we want to get the dark color and we want to draw the rectangle after that inside of update self. display main with Delta time let's try main. pi and if I open this we have something that looks not too bad although we are going to need a corner radius up here and down here for that we have to add a few more arguments it's going to be zero 12 0 12 and zero with that inside of main.py we are getting rounded Corners that is looking pretty good next up we can work on the monster display I suppose to give a bit more context I want to separate this area broadly into two bits at the top we want to have one rectangle that displays the monster in the middle that's the part we are going to work on for now after that we have all of the stats down here and at the end we're going to add the abilities in the bottom right for all of this I want to create another rectangle I call this one the top rectangle which once again is going to be py game. F rectangle for this one we have to specify as always left top width and height or to keep this a bit more concise we want to specify a position and a size this is a bit easier because I want to get the rec. top left for the top left of this rectangle if this is the entire main rectangle we are currently working inside of this part that we defined via the rectangle in there we want to create a top rectangle that is covering roughly this area at the moment we have specified the starting position the top left which can be the same as the rectangle after that we need the size which needs to have the same WID as the rectangle and some fraction of the height in other case this has to be a tupal wi for the well width and then for the height I want to get w. height and multiply it with 0.4 this we want to draw right away py game. draw. rect on self. display surface let's say for now with a red color and then we want to get the top rectangle keep a mind mind though we are still going to need the corner radius for that we need 0 0 0 and 12 let's run main pi and then we can see we have a top rectangle and everything else still works just fine that's a good start but we need a bit more information basically for every monster element I want to have an appropriate color in other words if you look at settings there we have for example a color for plant a color for water and the color of fire and this we want to use for the background of the monster for that we first of all need an actual monster and that I want to do all the way at the top of display main let's call this part data all I really care about in here is the monster itself which we are getting from self. monsters and then self. index self. monsters as a reminder is simply going to be this and our index is number in there meaning via this we getting our currently selected monster after we have that we can use the colors and then get monster do element that is the element we have created earlier that is simply going to be fire water or plant which is going to be the same key that we are using in the colors dictionary so this should already be working if I open the thing then we are getting the different elements so that is working pretty well now after that we have to display an actual monster animation which at the moment we cannot do because we have not imported the monster surfaces themselves so inside of the project folder we want to go to graphics and in there we have all of the monsters this is what we want to import and just to open one of them let's go with this one we always have a tile set with eight parts where the top bit is an idle animation with the B one being the attack animation and to import all of that we want to reopen our support. PI file support dop and there we want to create another function let's put it just above the game functions I want to have a monster importer which is going to need the amount of columns the amount of rows and then a path that we are unpacking after that I want to create a monster dictionary that is going to be empty for now for the setup of this dictionary I want to have key value pairs where a key would be a monster the associated value is going to be a dictionary in which we have the tack key along with a list of surfaces and then we also have an idle entry with another list of surfaces that's we want to create although by default this thing should be empty now just as before we want to have four folder path subfolders and image names in walk join and the path unpacked in there we want to look at all of the images I.E for image in image names and for now let's simply print what we get I want to print the image after that inside of main.py when we are importing all of the assets inside of monster frames I want to create another entry for all of the actual monsters for this one we want to have the monster importer the folder path is going to be one folder up then we are going to graphics and in there we have the monsters let's run the entire game and we cannot see anything and I believe the issue is that when we are creating monster importer we have columns rows and then a path but when I'm calling function we are only specifying a path to fix that we have four columns and two rows and then we have the path let's try this again and now we are getting all of the file names and those are all of our monsters that feels much better first of all then we want to have an image uncore name which is simply going to be image dos split we want to split this wherever we have a DOT and then pick the first item that we can use right away inside of the Monster dictionary to create a new key value pair where the key is the image name and the associated value is an empty dictionary after that we need the actual import and we want to separate all of the images which we have already done by using import tile map which means for every single one of the monsters we want to create a new frame dictionary which we get from import tile map where we passing through the columns and the rows along with a file path that we are getting from the path along with the image name and just to make sure that you are still following along I want to print the Monster dictionary and I want to print the frame dictionary if we now run main. Pi nothing crashes good start and then we are getting a whole bunch of data first of all we are always getting the monster along with an empty Di AR that part's easy after that we're getting the return value from import tile map the way this one is going to work is we have a column and a row or X and Y along with a surface for this part which means we simply have to go through all of the keys and then sort all of these surfaces by their rows and as a reminder the first row is going to be the idle animation and the second row is going to be the attack animation or in other words I want for key and row in enumerate or the list idle and attack that way for of the monsters I'm going to get a key along with a row just to make sure you see what we are getting we always getting zero for idle and one for attack once we have that I simply want to get the Monster dictionary then the image name and then create a new key the associated value for this key is going to be a list of values that we getting via list comprehension since we already have the row we have to get the column I.E call for call in range FS that would give us a number from 0 to three or whatever our columns is that we can use with the frame dictionary the one we have just created this one we can Access Wireless comprehension with a tall that has X and Y or column and row to be a bit more specific which are the values we are already getting either via list comprehension or via the for Loop that's basically all we had to do if I now go back to main.py and after we are doing the import I want to print self. monster Rams with the monsters let's run main. pi and after a second of loading we are getting an error that we cannot find a certain key and you can see what what the issue here is at the moment we have a frame dictionary and we try to get one value the value python currently sees is zero and idle which does not exist inside of this dictionary now the issue here is that I simply switched around to these two values the row is what we're getting from enumerate so this one should be zero or one and then the actual name for the dictionary is going to be the key the one that we are getting from the tubal if we are now trying out of this again then it should work and we are getting none that's a very easy thing to fix it simply happens because we are not returning anything from the monster importer meaning we want to return the Monster dictionary and next attempt now we are getting something and once again massive amount of data but first of all we have the monster then we have a dictionary with Idol there we have a bunch of surfaces and then we have an attack animation which once again is another bunch of surfaces that looks pretty good so now we don't need the print statement anymore instead we have to work inside of monster index also we don't need support. Pi anymore next up I want to do the monster animation for this one first of all we're going to need a monster uncore surface for which we have to do a bit more inside of the dunder init method at the moment we only really have the icon frames besides that that I want to have self. monstore frames which we can get from Monster frames although from this thing we only want to get the monsters the key we have specified here after that to get the actual monster surface we want to get monster frames and then pick a key now that key is going to be a name which we have inside of the monster there we have a name which means we want to get our current monster and then a name although at the moment the return value for this one would be another dictionary where we have the attack or the idle frames now in my case I only want to get the idle frames and just for now to test things I want to get the first item that way we have one surface and just to print that this is working let's print the monster surface if I now try m. Pi we have to wait a second and I can run this and I always have one surface printed out next up I want to create a monster rectangle which is simply going to be the monster surface and then get F rectangle where we want to place the center and the target position should be the top W do Center finally all we have to do is self. display surface. blit with the monster surface and the monster rectangle let's try pi and in the menu we can now see all of the monsters that's coming together quite well although it could look better by animating all of this for that first of all we are going to need a frame index I suppose we could put that one all the way at the top self. frame uncore index which by default is going to be zero after that we don't need the dunder nit method anymore we want to increase self. frame index I.E plus equals some kind of Animation speed ideally the one we are getting from settings so plus equal animation speed multiplied with Delta time using this Frame index we then want to pick one of the surfaces from the idle frames I.E in there we want to get integer self. frame index that way we would get different frames although we would run out of frames really quickly to fix that we want to get the modulus the length of self monster frames we want to look at monster. name and then at the idle frames arguably this line is getting a bit long but the ultimate logic isn't too difficult we have seen all of this for the entities already so I hope it's not too confusing but anyway let's try main. pi and we are getting an animation not an amazing one but it definitely makes the entire thing feel much better that means next up we can add some text to all of this first of all I want to display the monster name for which we are going to need a name surface which we get with self. fonts we want to have the Bold font and this we want to render the text we want to display is going to be monster. name antialias should be faults and colors should be colors and the white color then we are going to need name. rectangle which will be the name surface get F rectangle I want to place the top left to the top W top left I we are placing the name all the way in the top left of the top rectangle and for that we are also not going to need a tuple but I do want to add a vector for an offset I want to move the name 10 pixels to the right and 10 pixels down after that self. display surface dolit name surface and name rectangle let's try main note pi and then we getting the name of the monster that's looking pretty good after that we can work on the level for which we can do something fairly similar compared to the name I.E let me copy all of this but I do want to change the name to level like so after that for the font I want to have the regular font and the thing we want to render will be an F string into which we are entering monster. level nlas and colors can stay the same though for the positioning we want to get the bottom left and then place it in the top right dot bottom left plus the vector 10 and 10 if I now run main Pi you can see that we have the level in the bottom left although that is a bit sparse so I think what we could be adding is something like level and then this should be a bit more explanatory that feels nice there's one more really easy thing that we can add for that I want to copy all of this text one more time because I want to display the element and this element should in the bottom right of the top W container once again I want to replace the level in all of these lines with element for the font we can stick with regular for the text that we want to display we simply want to get monster. element color can stay white this one is totally fine after that for the position since we want to be in the bottom right the point that we want to place will be the bottom right then we want to get the top wck and the bottom right and give this thing an offset of vector 10 and 10 let's try all of that and the game doesn't crash and we get the element so with that we are displaying a whole bunch of text but there's one more thing that I want to do for the level and that should be an XP bar or in other words let's do this in the game right away actually if you look at the monsters below the level I want to display a bar that is going to show us how close we are to a level up and this bar should have a white part to show how much we have and then a darker bit to show how much is left meaning we have to figure out how to draw a bar and also this should be reusable because later on for the stats we want to draw a whole bunch of those all of that we can put in a function that I want to keep inside of support. Pi all the way at the bottom I want to have Define draw bar for which we're going to need a whole bunch of parameters first of all we want to have a surface to draw on then we will need a rectangle for the position we want to have a value a max value then we need a color a BG color and finally a radius although for this one we can set a default value of one now for the logic of drawing a bar there's only really one complicated thing and that is via dangle we're going to set the size of this thing so let's say we could have something like this where the width of the rectangle is 100 pixels and the height could be 20 pixels the specific numbers here really do not matter the actual issue is for the value we might have something like 150 so we have to figure out how to put 150 Health points into 100 pixels or in other words if we have 150 we want to fill the entire 100 pixels and if we were at 75 then we would only want to cover 50% of the width something like this to get started with that we first of all need a ratio between the value and the width of the rectangle or in other words rect do width divided by Max value that is going to tell us how much value we get per pixel after that I want to create the BG rectangle which is simply going to be a copy of the rectangle that we are passing in via the argument on top of that we want to create a progress rectangle which is going to be py game. F rectangle with a position and a size the position is super easy we can simply get get re. top left we want this progress rectangle to be in the same position as the background rectangle or the rectangle we are passing in as an argument for the size we're going to need a width and a height the height is super easy we simply want to get the wct and the height of that one although for the width we want to get the value and multiply this with the ratio and that's basically all we need after that we can get pame do draw do rectangle we want to draw on the surface we want to draw with the background color and then BG rectangle we do not want to have any border width but we do want to include the radius the one that we have specified in the parameters as well that we can now duplicate next up I want to draw the progress rectangle I want to draw the progress rectangle with the color and the progress rectangle and that is actually all we need let's use it inside of monster. py first of all we will need from so Port import draw bar and then for the XP bar I want to call draw bar with all of the arguments that we have specified the surface is going to be self. display surface for the rectangle we have to create a whole new rectangle and I believe it would could be a bit cleaner to use named arguments over multiple lines and then for the rectangle we want to create py game do f rect for the top left of this rectangle we want to get the level rectangle do bottom left in other words the bottom left of this level rectangle and for the size we can go with 100 and four numbers that I thought just looked good next up we have the value and for that ideally we want to have something like monster. XP something that doesn't exist at the moment because in Monster we only have the name the level the element and the stats which means we want to add another section let's call it experience and there we will need self. XP which by default can be zero then we want to have self. levore up which is going to be self. level times 150 level up is going to be the amount of XP we need to get to the next level for level one it's going to be 150 for level two it's going to be 300 and then so on meaning with that we have monster. XP for the value and for the max value we want to have monster. levore up after that we are just going to need the colors and in there for the foreground color I want to get colors and white the same color we are using for the text and for the background color I want to have colors and dark also I am happy with a default radius of one so we can get rid of this part and now Run main.py the game doesn't crash and there we go we can see an XP bar that at the moment doesn't really show anything so what we could be doing after we are creating all of the monsters I want to give every single one of them a random amount of XP that we can do inside of monster. Pi by importing from random import Rand in and then XP is going to be a random integer between zero and a th000 for some monsters this is going to look a bit weird but if I now run all of this we can see that we have bars for all of the monsters that actually display something the problem is that some bars have way too much xp these monsters should have leveled up especially this one that is an issue we can fix later on when we have the evolution mechanic I suppose for now what we could be doing inside of the draw bar function we could set a minimum and a maximum value or in other words we want to make sure that this value time ratio never gets wider than this rectangle I want to create another local variable let's call it progress for that first of all we want to make sure that we never go below zero Max zero and then the value we have gotten from value times ratio let me cut it out actually and then fix my typo and then use progress in there for the width of the progress rectangle that way the rectangle can never go in the other direction which would happen if it was to become negative after that we have to set a maxim value which we do via the Min function we want to have either our value time ratio or we want to have the rect do WID re. WID would be the background rectangle and this should be our maximum width so now I can run main not Pi again and now we are never exceeding the bar so I think that looks pretty good this might have been a bad example let's try this again and there we go so this monster has a lot of XP this one as well and this one as well but we never exceed the length of the bar itself so quite happy with that that means we can work inside of the monster index again although there's one more minor change that I want to do at the moment this draw bar is a little bit below the element which I don't think looks good or in other words if I open the menu again if you look at the elements we have fire on this line and then the level is a bit below that ideally I want those to be on the same line it should be a bit high up for that first of all I want to display the level just a little bit higher which we can do by setting the offset to 10 and6 that should already help quite a bit and yeah I think that looks better I suppose you could work with these numbers a bit more to get the perfect value but I I'm going to leave it as it is this is fine so with that we can start on the main part there are a couple of elements that we have to cover so once again this is our entire index and we already covered the list on the left side we are also covering the monster all the way on top after that I want to have a health bar and an energy bar roughly here and Below those I want to have all of the stats and all of the abilities and to go through it step by step let's start with the health and the energy bar now I guess main part isn't ideal in terms of naming let's call this health and energy for that I first of all want to create a dictionary with a few data points I call this one bar data and for this thing we want to get for example the Wii which would be the rectangle so our rectangle for the entire thing the main background I want to get the width of this and then multiply it with 0.45 and I want to have a height which would simply be 30 pixels with those two numbers we get the width and the height of the two bars on top of that I want to get the top for them as well which is going to be the top rectangle dot bottom plus let's say for now 50 pixels one more key value pair that we need for now and that is going to be the left side which will be re. left plus re do wi divided by four so just to contextualize these numbers once again we have the entire index we have the list and we have the top rectangle and at the moment we want to create the health bar for that we will need the width the height we will need a top position and we will need a left position the things that we have covered inside of this dictionary and later on those we want to reuse for the energy bar rectangle but step by step first of all I want to create a health bar rectangle which is going to be pame do F rectangle where we have to specify a position and a size position we're going to change in just a second for now this could be zero and zero for the size we also want to have a tuple with X and Y or rather width and height but same thing and there we want to get bar data with the width and I can copy all of this because for the height we want to have bar data and height to cover the position I want to use move two simply because I want to place the mid pop which is going to get the xy2 position of bar data we want to have the left side for x and we want to have the bar data top for y and just to make sure this is working let's run py game. draw. rectangle self. display surface we can go with a red color and then the health bar rectangle may not pi and there we go we have a health bar although it is quite far down that's not ideal in other words we want to change the top argument and in my case the number that I went with is the top w. bottom plus W do wift multiplied by 0.03 if I now run main. Pi that feels much cleaner and I suppose the important thing for this bar is that we have the same distance to the top and to the left because of that we are multiplying the top offset with the Wii cool with that we have the position and the size of the health bar rectangle which means next up we can call draw bar again and for that we're going to need all of these parameters we want to draw on self. display surface the rectangle will be the health bar rect rectangle after that we will need a value and a max value I suppose for now we can go with 25 and a max value could be a 100 for the main color I want to go to colors and in there we have a red color for the BG color I want to get colors and in there get black for the radius I want to have a corner radius of two let's try that and there we go this is definitely coming together the major thing missing is that we have to get the health and the maximum health of the monster at the moment this doesn't really exist we only have the max Health via the base stats but that doesn't really help us there isn't a good way right now to track the health of the monster to create that for now I want to create another attribute self. Health which is going to be self. Bas stats and then we want to get maxcore health and that we want to multiply with self. level that means by default the health of the monster is the same as the maximum health although for this part we do have to be careful inside of base stats Max Health could be something like let's say 25 and this value really importantly we are not multiplying with self. level at the moment that is because inside of stats we only want to have the base stats of the monster but for health we have to multiply it with the level right away because this value later on can change and we have to make sure we always have the correct amount of HP but that is a problem at the moment because if we simply went back to the monster index and for the value we could get monster. health and for the max value we could get monster. basore stats with maxcore health The Game Wouldn't crash but we would always have the full amount of Health simply because the actual health is way larger number than the max Health to fix this issue I want to create a method inside of the monster that I called get stat for this one we will need self and the stat that we want to get the only thing that this method is going to do it will return self. based stats with the stat we are currently looking at and then it's going to multiply all of this with self do level that way we get the correct amount which means instead of doing all of this I want to run the function monster. getet stat with Max Health now this is still going to look the same inside of the game since at the moment our health and our Max Health are the same value you this isn't going to do very much since inside of the monster the maximum health and the health are the same this is well not going to be particularly useful but what we could be doing is do self. Health minus equal a random amount let's say Rand int between zero and 200 if I now run main. Pi we are getting some health bars so that's looking pretty good now some monsters don't have enough health for this to really work those monsters would have been defeated but once again that's an issue for later for now I just want to have some random numbers although on top of that I also want to draw the HP text on top of this bar for that we will need self. fonts and the regular font and then render the output I want to render the F string that says HP with first of all the integer value of monster. health and then a forward slash after that we want to insert the integer of the maximum health which we have gotten up here I can just copy it and there we go with that we have the text we need to specify anti alas which should be faults and then a text color which in this case is going to be colors and white we are also going to need an HP rectangle which is going to be the HP text. getf rectangle in which we want to place the mid left point which is going to be the health bar rectangle do mid left although I do want to add an offset of vector and 10 pixels and 0er pixels finally we can run self. display surface dolit with the HP text and HP rectangle let's try all of that and there we go we are now getting the proper values and you can see some monsters have negative values that we can fix later on for now it's not too much of an issue righty with that we have the health bar rectangle after that we want to have the energy rectangle which is going to be fairly similar compared to what we have done here so we can reuse a couple of of numbers width height and top can stay the same although for the X position we will need a right side which is going to be re. left plus re do whift multipied with 3 over four that way we are getting 75% of the WID next up I guess we could copy all of this although I do want to change this to the energy bar rectangle we need py game. fct and the size is still good although for the midtop I would have bar data and the right side top can stay the same though next up when we are drawing the bar I want to use the energy bar rectangle and then Monster Health and monster Max Health we can leave for now although for the color I want to use a blue color and also for now we can get rid of the text and let's see if this is working in the first place and that is looking like a pretty solid start now at the moment we are copying the health amount but at the very least we have a bar the issue is we using the same attributes of the monster for both bars which isn't ideal Instead This should be monster. energy and monster gets that Max Energy max energy does exist but energy does not which means inside of the monster we have to create self. energy which is going to work in a very similar way compared to the health I simply want to get the max stat and energy and multiply it with the level also while we are here I want to change the value of self. energy and subtract the value from 0 to let's say 100 after that I can run out of this and now we are getting different bar sizes that is looking pretty solid so after that we can work on the I call this one the energy points text and energy Point rectangle for the text itself we still want to render the regular font although now this should be EP and Monster Energy along with monster get that Max Energy antialiasing and color stay the same next up for the rectangle I want to get energy points text. get rectangle and the mid left should be the energy bar rectangle. mid left that looks good finally I want to display surface split the EP text and EP rectangle after that we are getting proper numbers for all of this so that is looking very good next up I want to work on the monster info I.E in there we have the monster stats and we have the monster abilities for both of those first of all we're going to need a bit of information number one is going to be the left side for either of them which can be a dictionary where we have the left side and we have a right side the left side is simply going to be the health bar rectangle do left and the right side is going to be the energy bar rectangle dot left if this is the energy bar rectangle I basically want to draw a vertical line and then have all of the abilities somewhere here with all of the elements being aligned to the left side on top of that I also want to know what our available height is which I have called info height or in other words I want to know rect do bottom minus health bar rect do bottom that would be the distance between the health bar and the bottom of the entire index or in other words our entire available space next up we can display all of the stats and the way this is going to work we already have a container that starts at the bottom of the health bar and ends at the bottom of the main rectangle the stuff we have to find here we also have a left side that's simply the left side of the health bar bar and then we can Define some kind of WID to get the entire available WID inside of this space we want to display some text this could be attack or defense or speed or stuff like that and then below this text we want to have a bar that shows how good this value actually is for that first of all I want to create a stats rectangle just as before pame do F rectangle with left top width and height left being sides and left the top being the health bar rectangle do bottom Whi would be health bar rectangle do WID and the height would be the info height that way we are getting a rectangle although we want to inflate this thing just a bit or rather we want to deflate it which basically just means that we want to change the size while keeping the center point on the horizontal axis this could be zero on the vertical one it should be60 and just to make sure this is working let's run py game. draw do rectangle with self. display surface a red color and the stats rectangle inside of main. Pi that looks pretty solid so essentially at the the moment we have created a rectangle that covers this entire area and then via the inflate method we have taken out this bit and this bit just to have a bit of padding that we don't want to draw though but I do want to get a stats text surface which is going to be self. fonts and regular that we want to render the word I want to rer is called stats then faults and colors with white this part is just going to be a title that we want to place on top of all of the stats to give a bit more context to place it we want to create a stats text rectangle via stats text surface. getet F rectangle where the bottom left is going to be stats right do top left finally self. display surface. blit stats text surface and stats text rectangle all that this is going to give us is inside of the game we now have stats so that looks a bit better after we have that we can come to actually displaying all of the stats and for that first of all we need a bit of data most importantly we want to get the monster stats which ideally I want to get from a method called monster. getet stats or in other words earlier we created a method to get one of the stat of the monster but now we want to get all of them which means inside of the monster I want to create theine get stats no need for custom parameters for this one and basically all that we want to return is a dictionary with the values that we want to display and for that I want to have quite a bit of control because the text is going to be visible meaning I want to display the health and then self. get stat with maxcore health I hope the system here makes sense when we are organizing the monster we have health and Max health and those two are separate attributes however when we are displaying all of the stats of the monster we only want to display the max health because of that we can rename it to health and the same we can also do to the energy meaning instead of Max do energy I simply want to get the energy the other attributes I want to display there are four more I want to have the attack the defense the speed and the recovery in case you're wondering recovery is how fast the monster regenerates energy points to get those attributes we want to have get that attack defense speed and Recovery that way we have control over what attributes we want to display which by using inside of the index so now we know what we want to display on top of that we also want to know the stat height which would be the available space for every element that we can get with stats w. height IE the entire available space divided by the length of the St St that we have monster stats once we have that we can create a for Loop to draw all of the elements and for that we want to have the data and the index which means we want to have index and data in enumerate monster stats do items just to make sure that this is working let's print index and data running main. pi and opening the index you can see in the bottom with we get the information for all of the monsters it's a bit hard to see but if I extend this you get a pretty good idea that we have the right bits of information available we just have to display them oh and also this we can make a bit more elegant instead of data I want to have a tupal with the stat and the value to get started inside of this for loop I want to create a rectangle for the positioning of every individual stat let's call it single stat rectangle for that we're going to need py game. F rectangle with left top width and height most of these numbers are going to be fairly simple the left side for example is the stats rectangle do left the top gets a bit more complex that we can cover in a second the width is simply going to be this stats W do WID and the height is going to be the stat height now for the top we want to get the stats rectangle. toop that way we would always be on top of this container although from there we want to go down depending on the index that we have IE plus index times stat height this will be fairly comparable to the list we created earlier after we have that there are three elements that we want to display I want to have an icon for every single stat I want to have some text and then I want to have the actual bar the easiest part is going to be the text let's start there for the name I'm going to go with text surface so I don't have to type too much and we want to get self. fonts the regular font that we want to render and the information that we want to render is simply going to be the stat the one that we are getting from the four loop after that we need faults and for the colors we want to get white next up I want to have a text rectangle which we get from text surface get F rectangle where we are placing the mid left to singles that rectangle do mid left just to make sure that all of this is working let's display that self. display surface. blit text surface and text rectangle so inside of main. Pi we are now getting all of the stats this isn't perfect yet but at the very least we can see something we basically have to update the positioning of the text to make all of this look better but for that to work properly we need the icon first of all or in other words in the project folder we have graphics and then UI and there for example we have an attack icon a defense icon and an energy icon and those we want to display next to the stat which means we have to do another import inside of the monster frames I have a key called UI which is just going to import all of the stuff you have just seen which is just going to import all of the UI icons which we can do with import folder dictionary for the path we want to go up a folder then we want to go to to graphics and in there we have the UI folder after that inside of monster index I want to have another attribute self. _ frames monster frames and UI that way we have a bit easier access to it so now when we are drawing all of the stats inside of icons we can draw the appropriate icon for that first of all I want to get the icon surface which we get from self. uif frames and then this stat and just to explain how this is going to work inside of the graphics UI folder the icon we for example want to use is called attack which mirrors the attack stat name that way all of this is going to work fairly seamlessly after that we want to create an icon rectangle via IC can surface. getet f rectangle I want to place the mid left and the target position is going to be the single stat rectangle do midle plus an offset let's say Vector with five and zero or in other words we're moving five pixels to the right to display that we need the usual self. display surface. blit with icon surface and icon rectangle let's try that and we are are getting all of the icons although they are on top of the text at the moment for that when we are placing the text I want to update the rectangle positioning I want to place the top left to Icon w dot top left plus a vector of 30 and 10 let's try this again and that is looking much cleaner cool with that that we can work on the bar for which we first of all going to need a bar rectangle pame do F rectangle one more time with a position and a size the position is going to be for X the text rectangle do left and for y it's going to be text rectangle do bottom plus 2 pixels just for a bit of padding then for the size we want to have a width and a height the height can simply be four pixels and the width is going to be single stat w dot WID multiplied with 0.9 just for a bit of extra padding to the right with that finally we can draw the bar and as always we have to get all of these parameters surface is going to be self. display surface rectangle is going to be the bar rectangle value is going to be the value that we get from the for Loop that we don't have to change then we are also going to need a max value that we are going to ignore for now let's first cover the color this one is easy we simply want to get colors and white for the background color we want to have colors and black and the radius we can simply ignore after that we have to to figure out the max value and that part is going to be a bit more complex simply because from game data and let's UNL at the monsters here we have all of the monsters and for example for Max Health we want to get the highest possible value out of all of the monsters the same thing we want to do for Max Energy attack defense recovery and speed which means inside of the init method of monster index I I want to create another section for Max values which we are going to store in a dictionary self. Max stats by default this one can be empty and later on what I want to happen there is for example the health and then we are getting some amount here let's say 50 by default this one should be empty because these values we want to generate dynamically to get that we first of all need to have all of the monsters which which means for data in monstore dat. values and I don't believe we have monster data available we do not from game data import monster data with these values we are getting all of this or rather all of this and this and this and so on although we only care about the stats which means we want to a for loop with four stat and value in data stats and on this we want to get all of the items and just to make sure that you see what we are getting let's print stat and value if i r main. Pi we are getting things like Max health max energy attack defense recovery and speed or in other words in game data we are getting all of this now since we don't care about the element in fact we actively want to avoid that part we want to run if stat is different from element this we have to do because in just a bit we're going to compare the values which we cannot do for the element because that's not a number but essentially first of all I want to check if stat not in self. Max stats if that is the case we can simply create a new key self. Max stats with the stat is going to be the value that part is easy the next part is a bit more complex so at the moment we are looping through all of the stats of every single Monster and then we are encountering an element that already exists inside of Max stats if that is the case we want to compare the current stat value with the value inside of Max stats and then pick the larger one which means self. Max stats with the stat is going to be value if value is greater than self. Max stats and the stat if that is not the case else we simply want to keep the same thing IE the value we have started with that should actually be all if I now print self. Max stats and run main. Pi we are getting a dictionary that should always have the largest attribute value let's check for example for Max Health this value should be 29 and that I believe is chillo but we have a Max health of 29 and every other value is smaller than that so that looks good let's do another one for attack the largest value is six so there should be no other value larger than that so we have pluma with attack being six and every other value is smaller than that so that seems to be working just fine however there is an issue and let me run m p again when we are using these Max stats which happens in the for Loop down here the stat for Max health and Max Energy is simply called health or energy which means inside of Max stats we have to get rid of Max health and Max Energy or to be a bit more specific we have to remove the max in there now the easiest way to rename a key inside of a dictionary is to get the dictionary and then the new key the value for this one is going to be self. Max stats and then you pop the previous key which in our case is going to be maxcore Health the same thing we want to do for energy so energy is going to be Max Energy after that I can print cell do Max stats run main. pi and there we go now we are getting all of the max values with health and energy having the right name the order changed but that doesn't matter now we don't need the print statement anymore and we can collapse the init method after that all the way down here we can get the max value for every single stat what we want is self. Max stats along with the current stat that we are looking at and really important this we have to multiply with monster. level and that should be all if I now run may not Pi we get a whole bunch of bars and that I think is looking pretty good no complaints although I think we could move the entire thing just a bit further down for that inside of monster index when we are creating this step that's rectangle after inflate we also want to move it zero pixels left and right but 15 pixels down if I now run may not Pi this thing is a bit more centered which looks a lot better with that we have covered the stats after that we will need the abilities or in other words inside of game data we want to display all of these abilities now for some monsters I was a bit lazy and they don't have very many like those but if you go a bit further down for example for this one we have four Tech moves then we have a few more for this one then we have all of those and this is what we want to display for all of that first of all I want to create an ability rectangle which is basically going to be the same size as the stats rectangle so we can copy that one although we do want to move it to a different position or in other words I want to move the left side to sides and right the sides that we have to finded earlier that happens up here on top of that what will also be similar to the stats rectangle is the title which we have done with these lines so I can copy them basically we want to create an ability text surface and text rectangle now for that I do have to rename a few more things like this one and this one although we do have to change a couple of other things but let's go through it step by step first of all self. want. regular. render can stay the same although the text we want to render is ability next up for the rectangle we want to get the text surface and then place the bottom left in the ability rectangle. top left and I think that's going to be it if I now run main. Pi we getting ability to the right off it that looks pretty good which means afterwards we can create another for loop with index and ability in enumerate and then I basically want to get the monster and get uncore ability piece a method that does not exist at the moment to create that one we have to work inside of the monster where we want to create get ability inside of of this method we want to return all of the abilities that are available to The Monster at the moment if you look at game data we can look at let's say synal and in there we have an abilities dictionary the key defines when this ability is available or in other words on level 26 this monster gets the explosion ability so what we want to return is going to be a list with all of the abilities now first of all for all of that below the stats I want to store all of the abilities self. abilties is going to be monster data with the name and then we want to get the abilities I.E we are getting this dictionary and from that dictionary we want to get all of the available moves that part is actually fairly simple we want to get the ability for level and ability in self. abilities. items remember abilities is a dictionary where we have a level and the ability or all of this stuff and we only want to store an ability if self. level is greater or equal to the level required that way let me print the ability and let's have a look at the monsters so the first monster that we have is tramad Dillo and this one is level 30 at the moment inside of game data if we find shamad Dillo we should have all of these abilities but we should not have annihilate let's try if I run may not Pi open the index we can see all of the basic abilities I think they start here we can go up to explosion but we do not get annihilate I think that's looking good to display all of that I want to create a text surface which we do with self do fonts and regular I want to render the ability fs and the color is going to be black oh and there's one thing I did forgot to mention if this is the rectangle for all of the abilities the one we have to finded up here I want to have a two column layout I.E this is one ability then we have another ability then we have another ability and another one here essentially I want to avoid that we always have a list that displays all of the elements in a single Dimension it simply starts to look boring at some point now the way each individual ability will be displayed is we have the text itself with a black color and around that we're going to draw a rectangle for that we're going to need an X and A Y position I suppose for X we can start with ability rectangle do left although that we do have to change in just a bit but the top I want to have a top offset of let's say 20 pixels then I want to add the ability rectangle do top and then add the index multiply it with text surface and get uncore height once we have that we can create a rectangle where we want to get the text surface and call get F rectangle where we are placing the top left at position X and Y finally we can call py game. draw. rectangle on self. display surface what a color I want to have colors and white along with the rectangle let's try all of that if I now run m.p we are getting well we are getting something I suppose what I should be doing is also display the text then all of this is going to make a lot more sense self. dis playay surface do blit the text surface along with the rectangle let's have a look again and there we go we are getting all of the attack moves except this one doesn't look ideal now an easy thing that we could be doing here is wck dot inflate let's say by 10 and 10 pixels then we can set a border width of zero and a corner radius let's try this one and there we go this is already feeling quite a bit nicer although we are wasting a huge amount of space on the right side to fix that I want to move spark to this position roughly here to get those numbers I have to update the x value the way we are getting that is index modulus and two and that value we want to multiply with ability rectangle dot whift divided by two what we're getting from that if we run all of the is we are staggering the entire thing and the main thing that might cause you confusion is this index modulus two and let me actually print what we are getting if I now run all of this and open the thing we are getting a whole bunch of zeros and ones basically we are checking if index is even or odd and then we are getting zero or one returned which we are then multiplying with half of the width of the container that way an item is either on the left side or in the middle which is a good start but we still have the vertical positioning that we also have to update without that we would get this weird offset at the top which I do not like for that I want to work inside of the Y position and then divide index by two and get the integer from the result if I now run main. Pi that is feeling quite a bit better although we do need need a bit more padding between the elements or in other words at the moment our height separation is simply the text surface height this we want to increase by let's say 20 pixels let's try this again and there we go this is feeling much cleaner and with that we basically have the entirety of the index although there's one thing that I don't like and that is when we are displaying the attack we are only showing the name of the attack which is a good start but I also want to display the element of the attack for that we have to look at game data and come to the third dictionary attack data this one gives us all of the available attacks and then a whole bunch of information for example what we can Target the amount of damage or healing the cost of this move then we have the element and we have an animation for now we only care about the element there we have fire plant normal and water so when we are displaying the ability the background color should have the proper element color for that first of all we need to know what element we are working with which we get from a tech data and currently we don't have that one available so we want to import monster data and attack data that way we're getting this dictionary next up then all the way at the bottom attch data we we have the ability along with the element which is going to be this entry in the dictionary let's try all of this and the game doesn't crash so I assume it's going to work after that we have to link this element to a color which we can do via settings because for every element we have an Associated color although with one exception because I forgot to add the normal color which is simply going to to be a pure white color after that when we are drawing the rectangle I do not want to get the white color instead I want to get the element and with that if I now run main. Pi we're getting a whole bunch more color which is feeling significantly better now that was a larger section but we have made a whole bunch of progress so next up we can start working on the battle system while editing this part of the video I realized I have forgotten two things or rather I forgot one thing and I made a mistake inside of the game the first thing that I got wrong is the length of the stat bars all of those because those are too long I basically want them to end with the health bar all of this stuff here should disappear it just doesn't look good besides that the thing that I forgot to add is if we don't have enough monsters let's let's say we only have the first three if we then run the game we can only see part of the index which is going to look really weird and let's start with the background for that inside of monster index we want to go to display list before we are drawing anything I want to have a BG rectangle as always py game. F rectangle with left top WID and height left and top we can put together as position because for this one we want to get self. main. toop left this BG rectangle is going to be the background for the entire list for the width and height we want to have a tall the width is going to be self dot list wi and the height is going to be self. main re. height this PG rectangle we then want to draw with py game. draw. rectangle self. display surface let's say for now a red color and then the BG rectangle inside of main. Pi if I now open the index we are getting an error this should be called pame Draw rectangle and now inside of main. Pi we now have the background although we have to fix two things number one is the background color and number two is the corner radius for the background color I simply want to get the gray color so that's part's fairly easy let's try and that's already looking a lot better border Corner radius we want to go with zero for the Border WID then a general border radius is going to be zero then we have the top left border this one should be 12 next up is the top right border that one is zero then we have the bottom left border this one should be 12 and then we have zero again let's try all of that and there we go I think this is looking pretty good although while doing this I have realized another minor issue and that is we have this line all the way at the top which shouldn't be there it looks a bit weird that part happens because of those lines down here for this one we have to make sure that we do not draw something on index zero or rather that index zero doesn't exist which we can insert by simply adding a one up to what whatever we are getting from all of this let's try that part and now we don't have the weird line all the way at the top anymore the rest still works just fine so we can reenable all the monsters and it's still looking pretty good cool very happy with that and that is making a noticeable difference after that we have to work inside of display Main and more specifically we want to work inside of the four Loop for the stats for the bar rectangles we are getting a single stat rectangle and then 90% of the width which turns out is a bit too far if we change this to 75 so 75% then this is looking a bit better but still not ideal or and other words I want this bar to extend to the length of the health bar something like this I think the best way to think about it is if this is the entire stats rectangle we have an icon then we have some text and then we have the bar and at the moment the bar is a bit too wide so this part we have to remove which means essentially we want the length of the bar to be the width of the entire rectangle minus this part which we can get with the entire rect of the single stat rectangle WID but from that we want the subtract text rectangle. left I.E the left side of the text rectangle minus the single stat rectangle do left that would give us the distance from the left side of the main rectangle to the text so with that we have the properly sized bar and that is making the entire thing feel much better so I am quite happy with that cool with that we have actually finished the index so next up we can work on the battle system righty then the battle system now this thing is going to become fairly complex we have a ton of animations we have lots of timers we have to capture input there are just a bunch of things that we have to do so let's go through it step by step and start by setting up the entire thing first of all we are going to need some opponents which we can create right below the player monsters self Dot let's call it dummy monsters this is going to be a dictionary very similar compared to the player and let me literally copy a couple of entries I want all of those monsters although we do have to fix the indexes this should always be a list that starts from zero and then goes in a sequence also let me change the levels to something that is a bit more noticeable so with that we have a couple of opponents that we could fight which means next up we have to figure out the actual battle system and essentially what we are going to do if I minimize everything and then look at the Run Loop we already have a dialogue tree and an index for the overlays in there I want to add one more if self. battle exists then we want to run self. battle. update with Delta time also let me align all of this that's going to look a fair bit better there we go so basically for the battle system we are just creating a whole bunch of Sprites on top of the entire level while also making sure that the player cannot move that way our transitions are going to be a bit simpler but anyway first of all for all of this we want to create inside of overlays in another attribute self. battle which by default is going to be none meaning if we are running the game now nothing is going to change however what we can do is create a new python file which I want to save as battle do high and then we need the usual stuff from settings import everything on top of that we want to have class B till without any inheritance for the Thunder init method self the player monsters along with the op opponent monsters we are going to need all of the Monster uncore frames I.E all of the graphics and we want to have a BG surface also we want to have a whole bunch of fonts I.E fonts first of all in there then we want to get self. displore surface which we get with py game. display doget uncore surface we want to store self. BG surface as an attribute the same we want to do with self. monster frames because we're going to use them quite a bit also the fonts we need to store so self the fonts is fonts after that I want to have all of the monsters inside of a dictionary I.E monster undor data is going to be a dictionary where we have the player with the player monsters then we have the opponent with the opponent monsters this part is necessary because sometimes we want to update all of the monsters in the battle and having all of them in a single dictionary is going to make that a bit easier so with that we have the setup next up the most important thing in this class is going to be an update method with self and Delta time and for now just to make sure that this is working I want to get self. display surface and then L self. BG surface at position 0 and Z inside of the project folder in graphics we have backgrounds those are the battle backgrounds those we first of all need to import which once again happens inside of main.py in import assets I wasn't really sure where to put them so I have simply created a separate attribute self. BG underscore frames which we get with import folder dictionary aut paath we want to go upper folder then to Graphics in which we have the backgrounds let's run out of this and we are not getting an error so the Imports seem to work just fine so with that we can all the way at the top import from battle the battle class and then when we are initializing the entire game instead of setting battle To None I want to create an instance of the battle class for which we are going to need a whole bunch of arguments let me copy the parameters player monsters is going to be self. player Monsters the opponent monsters are the ones we have just created the dummy monsters for Monster frames we want to have self. monster frames for the BG Sur we want to pick one item from these PG frames I.E if you look at them we at the moment have a dictionary with the keys for Forest Ice and sand so the one that we could be using is self do BG frames with the forest finally the last thing we need is self. fonts for the fonts if I now Run the game we have the background for the battle so so that's looking pretty good now the problem is that well the player behind all of this can still walk around which we cannot really see but if this was the case in the game it might cause some issues or at the very least it would be super weird one thing we could do already about that inside of input we are already checking if we do have a dialog tree or rather if we don't have a dialog tree only then should the player be able to do all of this this system we can extend right away we also want to check and not self. battle that way if we are in a battle we cannot talk to anyone and we cannot open the index although the player can still walk around which isn't ideal and for now it's not really easily fixable simply keep it in mind later on once we have a monster encounter we want to block the player movement like we have done for the dialog system but for now I think this is all right anyway with that we have have a battle system or at the very least we have the background for the battle which means next up I want to run a setup method no need for custom parameters for this one and basically what we want to do for entity and monster in self. Monster data do items IE we are going through this dictionary then we're getting the entity do we have a player or an opponent and then we are getting all of the monsters or rather we get the monster data and that is a really important thing to understand for this battle system we have the monster data which is going to be all the stuff we are getting from the monster this stores the actual monster information but to display the monster we have to create a Sprite this one is actually going to be visible but step by step first of all I want to get the first three monsters from the player and from the opponent or in other words I want to pick these three monsters or these threee monsters that we can get with for index and monster in I want to create a new dictionary via dictionary comprehension where I have a key and a value for K and v in Monster do items and with that we would duplicate the dictionary that we already have for the player or the opponent I.E all of this but this we only want to do if the key is smaller or equal to two and from this new dictionary we want to get all of the items if I print the result we have index and monster and also I want to run self. setup if I run m.p we are get getting 01 and two for the player monsters and 01 and two for the opponent monsters a bit hard to see but you get the idea I suppose what we could be doing at this point which is generally good practice inside of the monster class I want to create another Dunder method Define Dunder repper this is going to Define what we are doing when this class is being printed no need for custom parameters and basically we have to return some kind of string if this one is monster and I run m not Pi again instead of seeing the object in memory we get the string Monster not a bad start but not exactly helpful so instead I want to have a monster with self. name along with let's say the level which is self do level if I now remain. Pi we are getting the index and then the monster along with the level and there you can see we have the first three player monsters along with the first three dummy monsters using that information we want to create a monster or rather we want to create a whole bunch of monsters which I'm going to do inside of a method called create monster which is going to need a bunch of parameters let's create the method right away create monster after self we will need the monster data then we want to have the index on top of that we want to have a position index and finally we need the entity I.E player or opponent and I should explain index is to identify the monster so for example we could have two monsters with the same name and the same level it is totally possible to have something like charma d twice with the same level which would be inconvenient for us because they would be really hard to separate hence we are going to use the index of the monster to make sure that we always have a unique monster ID that is the purpose of this index besides that we have a position index to understand this one you want to look at settings because in there we have the battle positions if this is the window for the left side we have a position roughly here here and here and then for the right side we have another set of positions for here here and here or something like that those positions have indexes I.E top would be zero Center would be one and bottom would be two 0o 1 and two keeping track of these numbers is going to be really important because that way we can ensure that we always have the monster in the right place although for now I simply want to add pass in there because before we can work on this method we have to add all of the arguments monster is simply going to be the monster the index is going to be the index and the position index will also be the index and finally for the entity we want to get the entity all of the stuff we are getting from the four Loops basically also I am using index here twice because the first index is to keep track of the monster the second index is stand for the positioning and for this number I'm expecting number that is either Z one or two which I am getting from these indexes as well I.E the first Monster will always be on the top position or index zero the second monster will be in the middle index one and the third monster will be on index two or the bottom also let me get back the original monster that makes a lot more sense cool with that we can create a monster first of all we want to have the frames for this monster which we get from self. monster frames we want to get the actual monsters from this thing and then we want to pick one of the items which we are getting from monster. name that information we then want to use to create a monster Sprite Which is going to need a whole bunch of arguments we want to have a position we want the frames we want a couple of groups then we want to have the monster for data we want to have the index along with the position index and we need to know What entity it belongs to I.E is it a player or an opponent monster this monster Sprite does not exist at the moment for that we have to look at Sprites which I do not have open right now and also we don't need the monster index at the moment instead I want to have the Sprites we don't need any of the stuff we have already created I want to create the battle Sprites all of those are going to be the Overworld Sprites for the battle Sprites I want to create a class called Monster Sprite the parent is going to be pygame dos sprite. Sprite and then we're going to need a thunder init method for which we're going to need a parameter for all of these arguments on top of that we're going to need self after that I want to call Super with thunder in knit with all of groups along with self. index being the index self. position index is going to be the position index self. entity is going to be the entity and self. monster is going to be the monster that covers the basic data after that we need this bright setup you want to be a bit better with comments actually we can put this super in it in there and this part is going to be data for the Sprite itself we are going to need self. image and self. rectangle at the moment we don't really have a single image we only have a whole bunch of frames which means inside of data we need a few more attributes self. frame index self. frames and I also want to have self. state which is going to be zero Rams and the string idle that information we can then use for the image we are going to get self dot rames with self dot State and then we are going to use indexing one more time with self. frame index that should give us a single surface for the rectangle we want to have self. image. getet F rectangle where we are setting a center to a position that should be a pretty good setup next up then inside of battle we first of all have to from Sprites import the monster Sprite also since we are working with Sprites we have to create a bunch of groups before we are calling the setup method once again I want to have a couple of comments this is groups and this part is general what groups I want to have self do battlecore Sprites which for now can be pame dos sprite. group this I want to duplicate two times because I want to have a Sprite group for the player Sprites and another one for the opponent Sprites and I want to align all of this up so it looks nicer and with that we can finally create a monster Sprite now for that we're going to need a whole bunch of arguments and most of them we already have frames we are getting from what we have just done before groups we can set in just a second and the remaining arguments are coming from the parameters so that's quite simple all we really have to figure out is the position and the groups which means I want to have two more variables position and groups and those are going to change depending on the side which means I want an if statement if entity is equal to the player then I want to create one set of variables and if that is not the case else then I want to do the same thing although for now let's comment it out so we're not getting an error for the position I want to create a list with all the available positions And then use the monster position index to pick one of them in other words inside of settings I want to get this position this position and this position put it in a list and then select one of those via the index for that we will need the battlecore positions that we're getting from settings so this entire dictionary we currently want to look on the left side of this thing because the monster should always be on the left side and from that we want to get all of the values that way we only get the actual position while ignoring the key then for the groups I want to have self. battle Sprites and self. player Sprites and with that we should have a setup which means inside of the update method I need self. battles Sprites do raw on self. display surface if I now run m.p which we are getting an Unbound local error inside of the setup method that happens here and the issue is we are only creating a position if the entity is on the player side if we are on the opponent side we do not have a position so this position doesn't exist when we are trying to create a monster Sprite to avoid that issue for now I want to indent the monster Sprite so we are only creating a Sprite if we are on the player side side for which we always have a position and groups or in other words all of these arguments are available let's try of this again and there we go we have a couple of monsters now this isn't ideal they're not animated they're facing the wrong direction and we do not have the opponents so loads of things to work on that part is going to be an exercise I want you guys to do three things number one flip the player monsters on the horizontal axis so they're facing to the right after that add the opponent monsters and finally animate all of the monsters should be doable but you do have to write a couple of lines of code pause the video now and see how what you get I think the easiest thing to get started with are the opponent monsters meaning I want to uncomment the El statement and then remove one indentation from the monster Sprite next up we have to get the position which is going to work fairly similar compared to what we have done for the player the only difference is that now we want to get the right side for the groups we want to have self. battle Sprites and self. opponent Sprites with that inside of M Pi we are getting a whole bunch more monsters that's already feeling better although we have to flip all of the frames for the player and the thing you really have to understand when you are looking at all of of the monster Sprites all of them are facing to the left which means if one of them is on the left side of the screen we have to flip them to always face to the right or in other words when we have the player entities we want to create frames that are flipped which has to be a new dictionary where we have a state along with a couple of frames and at the moment we can go for state and frame in frames. items that would simply duplicate this list so so far not particularly useful but with that we have access to all of the frames which means in there we can run a list comprehension in which we want to go through all of the frames I.E frame for frame in frames so now we have access to every individual frame and this we want to flip on the horizontal axis which we can do with py game. transform. flip we want to have a frame we want to flip it on the horizontal axis but not on the vertical one if I now run main. Pi we have all of the Monster frames facing in the right direction so that's looking really good finally then inside of monster Sprite we want to animate all of this for that I want to create an animate method with self and Delta time we want to get self. frame index plus equal animation speed multipli it with Delta time and then self. image is going to be self. frames along with self. State and then we can pick the integer of self. frame index with modulus of the length of self. frames with the current self. state this animate method we have to call inside of an update method which needs self and data time there self. animate also don't forget Delta time in there next up inside of battle. Pi before we are drawing all of the battle Sprites we want to call self. battle Sprites do update and pass thata time in there now inside of May Pi we have animations this isn't terrible but also not ideal because at the moment all of the monsters animate at the exact same frame rate which can look a bit weird to make that a bit more interesting I want to create in the dunder init method a self. animation speed which is going to be the animation speed plus a random amount that we getting from uniform which I believe we don't have at the moment we want from random import uniform uniform is basically the float equivalent of random integer I.E we have to set a start and endpoint and then python is going to give us a random floating point value between those two in my case I want to go from 1 to 1 and then let me print a result if I now run may not Pi we get a bit more variation and if you look at the print statements now our animation speed has a bit more diversity not a lot but enough to make the game feel a bit more random and organic righty with that we have the monster but we are also going to need the UI and there are three classes that I want to create we want to have a monster name Sprite we want to have a monster level Sprite and a monster stats Sprite to understand these classes in the right you can see the result monster name Sprite is going to be the name it's going to be a rectangle up there monster level Sprite is right below this one shows the level of the monster and it's not in this image but in the bottom of this Sprite we're going to have the level progress I.E how far we are from the next level up both of these are fairly straightforward the slightly more complex one is the monster stat Sprite that's the stuff at the bottom that shows the health of the monster the energy of the monster and the Readiness of the monster that's the black bar at the bottom that's going to show you how far the monster is away from being able to attack or defend or do basically anything those three classes we have to create and let's do it step by step starting with the monster named Sprite for this class we're going to need a couple of arguments we want to have a position we want to have the monster Sprite we will need the groups and finally we will need a font these numbers we can get fairly easily although before that inside of Sprites we have to create a class first of all I want to have a class monster name Sprite with the parent being pame do sprite. Sprite for this one in the dunder init method we want to have a position the monster uncore Sprite the groups and the font most importantly we have to cause super Thunder init with the groups that part is easy after that we want to have self. image and self. rectangle the rectangle is fairly easy we simply want to get self. image. getet F rectangle where we are placing the midtop to the position the image is going to be a bit more complicated because essentially we want to render some text and this is going to be the size of this Sprite kind of similar compared to what we have done with the dialogue Sprite first of all we want to create a textor surface which is going to be font do render the text that we want to render would be the monster Sprite do monster. name and this brings us to something that we are going to see a lot monster Sprite is going to be the monster class we have created up here inside of that thing we have the actual monster data and only in there do we have the name what you always have to remember is that this monster class contains the actual information the monster Sprite at the moment is basically just there to display a Sprite and animate it that's all it does also I don't want to print the animation speed anymore that's not needed righty for antias we want to set fults and for the text color I want to have the colors and the black one on top of that I want to set some padding of 20 pixels for self. image we can create pame do surface for which we are going to need a width and a height for the whift I want to get the text surface and get underscore whift plus two times the padding one for the left side and one for the right side for the height we are doing basically the same thing I want to have the Tex surface get underscore height don't forget to call this one and to that we want to add two times the padding with that at the very least we should be able to see something although for that first of all inside of battle. Pi we have to import the monster name Sprite then we can create all of this but first of all we will need a position the monster Sprite groups and font font is the easiest part although for that we need to get all of the fonts those we already have and then we want to call Self do fonts the font name that I want to use is going to be regular for the groups we can simply go with self. battles Sprites the monster Sprite is going to be the monster Sprite we have just created to get this one we first of all want to create a local variable monster Sprite that way we can get the monster Sprite in there finally we're going to need a position let's rename this actually to name position to make it a bit more understandable now for that I want to create a local variable with the same name and basically what I want to do is I want to get the monster Sprite then W and then mid left order to that I want to add a a vector of 16 and7 that is going to cover all of the arguments let's try to run main not pi and we are getting something so that's not a bad start the thing is entirely black though that's not ideal and we cannot see the text also for the opponents the Box should be on the right instead of the left let's work on that first of all we only want to get this position if entert is equal to player and if that is not the case so else then I want to get the monster Sprite dot wct do mid right along with a vector offset of40 and 70 and by the way those are numbers I simply got from playing around there's no real science behind it it just looked good cool but that I'm quite happy with after that inside of the Sprites we first of all want to fill the entire surface I.E self. image. fill colors and a white color that is already looking much better although I think the box is a bit large let's change padding to 10 pixels I think that's going to be better yeah that looks much more reasonable finally we have to add the actual name of the monster that currently we have inside of the text surface to display it self. image. blit we want to display the text surface and then we have to get a position which in our case is going to be petting and petting if I now run all of this again we get the name of the monster in the center of the text box so that is looking pretty good now in case you're wondering about these two paddings the way you want to think about it is that this is the entire self. image and on there we have a whole bunch of paddings so it's always 10 pixels there 10 pixels there 10 pixels there and 10 pixels there when we are blitting the text surface we are looking for the top left which in our case is going to be this point here because all of this is what we have gotten from the width and the height of the actual text which means via this top left point we are centering the text perfectly and that is all we need from Monster name Sprite we can now minimize it and create another class with monster level Sprite Which is also going to be a pame Dos sprite. Sprite for this one let me uncomment the class name because now we have to figure out the argument ments I want to get the entity and an anchor I'll explain this one in just a second besides that we want to have the monster Sprite we want to have the groups which we can change right away to self. battle Sprites and finally we want to have self. fonts and the small font to display some text the last three arguments are fairly straightforward I don't think I have to explain them entity is is also fairly simple do we have a monster on the player side or on the opponent's side the only complication is the anchor so what is up with this one if we have a monster on the player side then we want to have the monster named Sprite on the top left roughly here the monster level Sprite I want to be right below here those two should have the same left side and also the level Sprite should be right below the name that way it looks like we have one connected Sprite but we do have to be careful this is only for the player side for the opponent monsters we want to have the entire thing mirrored it should look something like this where we have the name on the top this we already have but on the bottom we want to have the level so now they share the same right side for that we have to Define an anchor that part is slightly more complex so let's create another local variable I want to get either the bottom left or the bottom right of this monster name Sprite which means we need to store this in a variable as well let's call it name Sprite and then the anchor is going to be named. w. bottom left but only if the enter is the layer if that is not the case we want to get name. rec. bottom right that is going to give us all of the arguments next up we have to make sure that we are importing monster level Sprite and then we have to create the class which we start with by creating a thunder init method let me copy in all of the arguments like so self. battle Sprites is going to be the groups and self. font small is going to be the font as always do not forget to cause super Thunder init with the groups and also self. monster Sprite is going to be the monster Sprite we always want to connect this monster level Sprite to the monster Sprite itself because if the monster dies we want to get rid of this Sprite as well and I believe this I haven't done for the monster name Sprite in there we are only using the monster Sprite for the monster name we also want to have a self. monster Sprite attribute which which is going to be the monster Sprite anyway with that we have the monster Sprite next up we will need self. font which is going to be the font after that we're going to need self. image and self. rectangle for this monster level Sprite you do have to be careful because during the fight the level of the monster could update meaning we couldn't simply create the image once with the text and then call it a day we have to create an update method with self and Delta time although Delta time we're not going to use so an underscore instead inside of this update method we are displaying the text that way if the monster level increases during a battle we are still displaying the right information although I suppose for now we can simply get self. image and fill the entire thing with colors and white so now we have to figure out an image and a rectangle now for the image I was a little bit lazy and simply went with pame do surface and then added 60 and 26 we always have a static size for the image and this number simply looked good and fit right in although if you're using a different dimension then this might have to change next up for the rectangle we want to get self. image. getet F rectangle where we are placing the top left to the position but only if the entity is equal to to the player if that is not the case then we want to get self. image. getet F rectangle where we are placing the top right although the position is still going to be the same and just to explain what this line means from the monster name Sprite we are getting a rectangle like this and if we on the player side we want to create the new Sprite right below with the same left side and the bottom of the name is the top of the level however if we are on the other side I.E the opponent then I want this level Sprite to be on the right side so here where we are sharing the right side although the vertical position is still going to be the same anyway let's try all of this if I run m. Pi we are getting an error that name is not defined this happens inside of this line because we are getting name. rec. bottom left this should be name underscore Sprite next attempt and another error we expect five arguments but we are giving six that usually happens because you have forgotten self in the dunder init method like I have just done next attempt and we are getting another name error that the position is not defined and that is because the position is going to be the anchor so instead of position I want to use the anchor although I guess name here would be a better argument but anyway now we are getting the right Sprite that looks pretty good and anchor here really isn't a good name let's call this one the levelor position and then inside of Sprites instead of anchor it's going to be a position for all of them let's try it again and that's much better sorry about now we have to display the level of the monster inside of the update method first of all for that I want to create a text surface local variable with self. font. render an F string with level and then self. Monsters sprite. monster. level I already talked about this but make sure to include the monster only in there do we have the ACT ual monster information after that antialias should be fals and for the colors I want to have the black color next up we need a text rectangle which is going to be the text surface. getf rectangle I want to place the center to the center point of this surface or in other words self. re. wift divided by two and self. re do height divided by two and finally self. image dolit with the text surface and the text rectangle let's try out of that and there we go now we have the level for all of the monsters there's just one more thing that I do want if this is the monster level Sprite at the bottom I want to have a level progress bar that shows us how far away we are from a level up now we already have a way to create a bar inside of support. Pi we have a draw Bar Method this we can reuse let me copy all of the parameters and then inside of Sprites don't forget from support import draw uncore bar inside of monster level Sprite I want to draw a bar with all of these arguments surface is going to be self. image rectangle we can ignore for now that's going to come in a second for the current value we want to get self. moners sprite. monster. XP max value is going to be also from the monster class inside of the monster Sprite although this one will be level uncore up for the main color I want to go with black I.E colors and black and BG color should be a white color so it looks like there's no background I.E background and white and the radius should be zero nearly done the last thing we need to get is the rectangle this I want to create in a separate variable XP rectangle which is going to be a pame f rectangle with left top width and height the height can simply be two pixels the width is going to be self. re. wift the left is going to be zero and top is going to be self. re do height minus 2 and also this XP rectangle we only have to create once I.E we can do it inside of the dunder init method and then call it self. XP rectangle this we can now insert into draw bar and if I run m. Pi again we can see a couple of XP bars now for the third monster Lavia we have a full XP bar this monster should have leveled up that mechanic we do not have at the moment but we can work on that later first of all though I want to display all of the Monster stats that part is more important for now for all of that we want to work inside of Sprites a monster stats Sprite as a parent we need pygame dos sprite. Sprite just as before for this one in the dunder init method we will need a position the monster Sprite the size that we want to use the groups and the font then the usual super Dunder init with the groups and we want to store self do monster Sprite as an attribute monster Sprite after that I want to create self. image and and self. rectangle so we actually have the stuff for the Sprite for self. image I simply want to create a py game surface with the size that we are getting from the parameter once we have that the rec we are getting with self. image. getet f rectangle and I want to place the mid bottom to the position finally while we are here self. font is going to be the font that's a good start with that we can inside of battle create the monster stat Sprite although first of all all the way at the top we need to import the class and also let me minimize things so it's a bit easier to see what's going on so to create an instance of this class we need these arguments the position will be the monster sprite. w. mid bottom I.E the bottom of all of the monsters do that I want to add an offset of zero pixels on the horizontal axis and 20 pixels on the vertical one we are going 20 pixels down the monster Sprite Remains the monster Sprite for the size I want to have a static number I went with 150 and 48 once again a number that simply looked good if you like something else just go with that for the groups I want to have self. battles Sprites and for the font it's going to be self. fonts from which we want to pick this small font with that I can run m not pi and we get a bottom bar below all of the monsters that's looking pretty good doesn't do very much at the moment though for that we have to work inside of monster stats Sprite specifically we will need an update method with self and Delta time although Delta time we're not going to use so I will add an underscore first of all we want to fill the entire image with colors and white after that we basically want to draw three bars one for the health one for the energy and one for the Readiness or in other words if this is the entire image or rectangle I have of those we want to have some health text here and then a health bar below that we want to have the energy text along with the energy G bar and finally all the way at the bottom so this line here I want to have a Readiness bar so how far away the monster is from being ready to attack now two of these attributes we already have all of the monsters have health and energy but there's no attribute to track how ready the monster is for that below the energy I want self dot I call this one the initiate if which by default is going to be zero and later on we will increase this number once it reaches 100 then the monster is ready to attack the speed by which that happens is defined for each Monster by the speed I.E if you look at all of the monsters there we have a speed attribute but that's going to come later for now initiative can always be zero after that inside of the update method we want to look for free attributes which we are going to do via a for loop I want for data in self. moners sprite. Monster and then get the info that I need which is a method that doesn't exist right now which means we have to work inside of the monster and then create a method called get info no need for custom parameters on this one and basically what we want to get and let me return the value right away we want to get a tupal that consists of three other tbls in which we first of all have self. health and then self. get stat with the max Health the next entry is going to be another tupal that is going to be very similar in fact I can copy it we want to have self. energy and self. Max Energy finally for the Readiness or the initiative we want to get self. initiative and the max value for this one is going to be 100 or in other words since we want to display a bar for this info we always need the current value and the max value which is what we are getting from this get info on top of that I want to know what index we are on for which I can use en numerate after which I'm getting an index along with the data the data here we can separate right away into a value and a max value just to keep all of this a bit more readable after that I want to get the color for each of the bars for which first of all I want to create a list where the first entry is colors and red then colors and blue finally colors and gray this is simply going to give us three of the colors that we have to find inside of settings one of those colors from that I want to pick one item via the index now we know from get info the first item that we are getting is going to be the health IE via the color here we getting the first element which is a red color after that I want to have two sep seate pieces of logic for the bars the health bar and the energy bar or in other words the first two bars are going to be drawn with text in the center is of the Sprite which means we first of all want to check if index is smaller than two in which case we would get health and energy but now let's add pass in here and then we can add els for the initiative although this one also gets passed for now inside all of this for the health and energy bar we will need a text surface a text rectangle and a bar rectangle whereas for the initiative we will only need a let's call it the init rectangle and that we can then use to draw a bar using draw bar from support all the way at to the bottom there we want to use draw bar again which means we have to get a few numbers this part could actually be a good exercise I want you guys to display the stats for each monster the end result should look something like this for all of the monsters pause the video now and see if we can figure this one out for the text surface we want to get self. font and then render all of that for the text we want to display I want to have an F string with the integer of the Cur value after which we are getting the max value antialias should be false and for the colors I want colors and black next up we need the rectangle and for that I want the text surface get F rectangle in which I want to place the top left for that I will need a tuper with an X and A Y position for X I basically want the text to be on left side with a bit of padding which in my case I have set to self. re. wift Multiplied with 0.05 I we have 5% of whift to the left side or why I want to get the index and multiply it with self. rect do height divided by two now for the first item where index is zero this value is going to be zero I.E this text rectangle will be in the top left for the second item index is going to be one which would put this number in the middle of the Sprite finally for the bar rectangle I want to have py game. f rect with text rectangle do bottom left plus a vector of Z and minus 2 I.E the top left of this F rectangle starts in the bottom left with a bit of an offset then we need another tupo with the width and the height for the height I simply went with four pixels because it looked good for the Wii I went with self. dowi but I only want to get 0.9 of that I.E 90% after we have all of that we can get self. image. blit with the text surface and the text rectangle also we can draw the bar for which we are going to need a whole bunch of arguments let me copy the parameters surface is going to be self dot image rectangle will be the bar rectangle that we have just created value is going to be the value and so will be the max value also for the color I want to have the color we created up here and for BG color I want to get colors and black for the radio here I want to go with two and that should be all we need although I already spotted one mistake this shouldn't be gray with an E this should be gray with an a other than that if I now run main Pi we are getting a name error that in nit direct is not defined let's have a look we have to comment out this part and then add a pass in there that part we can cover in a second next attempt and there we go we have health along with a bar that is looking pretty good next up then for the ended rectangle we don't need pass anymore and now we have to create the init rectangle which once again is going to be a pame f rectangle for which we have a position and a size the size is actually the easier part let's start there the WID is simply going to be self. Rec do width and height is going to be two pixels I.E we are covering the entire width of the rectangle and then for the height we have a number that looks good for the position then the left side has to be zero and for the top I want to have an offset of two pixels from the bottom of the Sprite in other words self. rec. height minus 2 that is all we need for this part after that we can draw the bar for which we are going to need a whole bunch of arguments once again let me copy them we still want to draw on self. image although the rectangle is not now going to be the a knit rectangle we are still getting a value and a max value along with a color although for the background color I want to have colors and white also for this one the corner radius should be zero so let's try all of that and we cannot see anything that is because inside of monster the initiative is zero but once again we can define a random integer between zero and and 100 and then we can see some amount of Readiness for all of the monsters which is a really good start that means we are nearly done with the setup for the entire thing there's just one more thing that I want to do and for that let me run the game again I want to work a bit more with the drawing order or in other words the Sprite for the name at the level I want to have behind the monsters it just looks better later on this will become very important and generally for a game you always want to have control what is being drawn on top and what is being drawn in the background for that like we have done for the Overworld the main Sprite group at the moment is Battle Sprites and this is just a regular Sprite group that I want to customize so instead of a generic group I want to have a battle Sprites class which we have to create inside of groups we already have all Sprites in there but that we can collapse because next up I want to have a class called battle Sprites which has a parent class of py game. sprite. group we as always will need a Dunder init method with self and that's about it and in there we have to initialize the parent class and then I also want to get self. display surface which we get with py game. display. getor surface that's all we need in there next up I want to have a custom draw method inside of this draw method we will need a for loop with for sprite in self and just to reestablish the basic mechanic we want to get self. display surface. blit with Sprite do image and sprite. wct with that inside of battle. piy we can from groups import battle Sprites after that the game should still work just fine except now when we are calling the draw method we don't need to add in the surface we want to draw on I down here we don't want to display surface anymore after that things should be working and they don't we get the issue that the battle spread object has no attribute display surface that happens inside of group so we do not have this display surface and I see the issue the init method has two many underscores but now there we go everything works just as before that is a good start so now we can work on the drawing logic I.E we can sort all of the Sprites which we are going to do once again by using a sorted method for which we already have a list that can remain self after that we will need a key which is going to be a Lambda function with a Sprite and then for every single Sprite we want to get a sprite. z attribute and Via that we are sorting all of the Sprites now at the moment the Sprites do not have a z attribute that part we do have to add which means at the moment we have four Sprites inside of this class and also inside of settings we have battle layers which is going to work kind of like the world layers in the sense that we're going to give every monster a number and then the higher the number is the later the monster will be rendered IE the fervet is going to be on top you use that inside of Sprites the monster Sprite is going to get self. Z which we get from battlecore layers and monsters should always be on the monster layer after that we can copy the entire line next up inside of monster name Sprite in the dund method I want to put this Sprite on the name layer which is going to be below the monsters next up the monster level Sprite is also going to get a z attribute and we are going to keep this this on the name layer finally for Monster stat Sprites we will need to that attribute again although this one we always want to have on top of the monster I.E on the overlay layer which is going to be on top of everything else that way we can always see the stats of the monster which is probably a good idea so with that if I now run main. Pi we can see that the name and the level are behind the monster also with that we have more control which is going to become important later on but anyway this is some pretty good progress next up we can work on making all of this interactive all right so at this point we have set up the entire thing how can we make it interactive and that is going to involve quite a few different things most importantly for now we have to make sure that the monsters update their initiative and then once they are ready we can select different options there's going to be an attack defense switching a monster or catching a monster and if we select attack or switch then we should get another menu with all of the available attacks or all of the available monsters that's what we are going to work on for now it's going to be quite a bit let's Jump Right In inside of the code we want to look at our monster because in there we have the initiative and this number we have to update Also let's set it to Zero by default to update this number I want to create an update method all the way at the bottom Define update for which we are going to need self and Delta time in there we want to check if not self. I.E later on we want to have control if the monster is updating or not which we're doing via an attribute which does not exist at the moment let's create it in the dunder Ed method self dop is by default going to be false although I guess this pause should be all the way in the top that it's a bit better organized anyway after we have that if the monster is not paused we want to update self. initiative and increase it by self. getet stat and the speed multiplied with Delta time this method we now have to call which is going to happen inside of the Sprite that contains it I.E monster Sprite this thing already has an update method which we can use self. monster. update with Delta time that should already be it to see something in the game and there we go now all of the monsters are getting ready with some getting ready faster than others and Lavia especially takes forever but that's okay with that in place I want to add a comment inside of the battle class let's call this one the actual battle system and the first important part that we have to work on is a method called check underscore active no need for custom parameters and in there we basically want to look at all of the monsters and then check if they are active for that first of all we want to get all of the Monster uncore Sprites which we get from self. player Sprites do Sprites plus self. opponent Sprites do Sprites Sprites you have to add so you can add two of these groups together without that it wouldn't work next up for all of the monsters we want to check if monster sprite. monster. initiative is greater or equal to a 100 if that is the case we want to do something and during that time all of the monsters should be paused for which we first of all want to self. update all monsters and then put them in a pause State this update all monsters doesn't exist at the moment which means Define update all monsters with self and the option that we want to go for this one can only really be pause or resume that's all we are doing in here for that once again I want to get all of the Sprites which I have already done so let me copy the line I want to get the monster Sprite do monster and in there update the PA attribute it will be true if the option is equal to F if that is not the case we only have two option it's going to be false this method we now have to call inside of update and let's organize this method just a bit better I first of all want to do all of the updates and then I'm going to draw things so to add some comments we have the updates and we have the drawing logic after we are updating all of the Sprites we want to self. check active with that if I run main.py we are getting an error that happens inside of check active because this should be monster Sprite next attempt and there we go the first monster has reached the ready state so all of the other monsters are pausing that is looking pretty good that means we don't need update all monsters anymore and next up I want to do a bit more inside of check active first of all monsters sprite. monster. initiative should go back to zero after that I want to do two things first of all I want to get the monster Sprite and then highlight it which I'm doing via a method set uncore highlight and this one should be true on top of that I want to get a self. current uncore monster and set the monster Sprite to it this is going to become important in just a bit because that way we are controlling the current monster for that inside of Thunder init I want to create another section let's call it control in there at the moment we only want to have self. current monster which by default is going to be none but later on once the monster is ready it's going to be inside of this attribute and that way we have a bit more control over it so for example we can get the attack moves from it we can switch it we can kill it things like that that's going to come later for now though we want to highlight the current monster once it gets ready which means we will need a set highlight method that doesn't exist inside of the Sprite right now so we have to create it although it's not a terribly difficult method set underscore highlight with self and a value and ultimately all that we are doing is self do highlight is going to be the value for that we will need self. highlight as an attribute by default it's going to be false let's run main notp to make sure things aren't crashing and that is still looking pretty good but obviously we can't see anything so once the monster is ready I want to give it a white outline to highlight the monster I want to have something like this where we have a white outline for every single one of the monsters once they get active now creating this isn't the easiest thing in the world let's cover the theory first we will start by getting all of the Sprites of the monster and then we are filling every visible pixel with a white color and then finally we are going to move that new Sprite in all eight directions IE if this is the original monster we are moving it by some pixels to the top left and then we are getting a new monster image that is something like this after that we are going going to the top and then we have another monster that is somewhere here and this we're going to do for all of the eight possible directions the end result of that is going to be that we have an expanded Sprite that is going to look something like this I.E for all of the sides we have a few extra pixels which is going to give us this outline if we have the new Sprite behind the monster that's all that we are doing in here to create all of that I want to work in side of import assets specifically in the monster frames and I want to add an entry after we have created all of the Monster frames I.E monster frames and then I want to have the outlines or which we are going to create an outline Creator which is going to need two arguments the frames you want to get and then the width I eat the width of the white line around it the frames are going to be self. monster frames and we want to get all of the monsters for the WID I went with four pixels but that you can customize on your own I want to work on the outline Creator which I have put inside of support all the way at the bottom of the import functions Define outline Creator which has a frame dictionary parameter and then the with just as before we want to start by creating a new dictionary I call this one the outline frame dictionary by default this one is going to be empty and then for monster and the monster uncore frames in frame dictionary do items just to make sure you see what we are getting let me print the monster and the monster frames if I now run all of this we get a pretty substantial dictionary but in there we first of all have the monster itself the associated key is then going to be a dictionary with an idle animation and with an attack animation and basically we want to go through every single one of these surfaces and then fill them with a white color and expand them first of all though I want to get the outline frame dictionary create a new entry with the monster and Associated value is for now going to be an empty dictionary after that we can go with another for Loop for state and frames in Monster frames do items i. we're getting out of the states and the associated frames from the monster frames once we have that we want to get the outline frame dictionary again along with the monster inside of this new dictionary we can create a state key along with an empty list in this list we are going to store all of the frames for that first of all though we have to work with all of the frames which we do with four frame in frames and then we want to create a new Surface which we do with pame DOs surface for this thing we will need a tuple with width and height and essentially we want to have the same size as the frame in the original animation but since we are going to expand it it should be slightly larger as a consequence I want to create a vector of frame. getor size and do not forget to call this one to that number I want to add a vector with WID divided by two that way we are getting the size of the original surface via get size and to all of the sizes we are adding a Whi I.E we have a Whi up there there there and there after that we want to get a white I call this the white frame because we are basically taking all of the frames and then making every visible pixel white which we can do via a mask I.E py game. mask. from uncore surface the surface we want to use is the frame and this we want to straight away convert to a surface Now using a mask in py game is slightly more Advanced and I have made a whole tutorial on it if you want to know all of the details check that one out but essentially a mask is simply going to be a silhouette of a surface I.E if we have a visible pixel we have a white color and if we don't then we're getting a black color most of the time you're using this for Collision detection but you can also turn it back into a surface and then you have a black and white image which is what we have gotten from the white frame although we want to get rid of all of the black pixels which means white frame do setor color key and we want to get rid of all of the black pixels after we have that I want to get the new Surface and then blit the white frame in a certain position the first one would be zero and zero that would be the top left and I really want to draw what we are doing here so we have a new Surface that is a bit larger than the original frame I.E we have something like this and there at the moment we are taking the white frame and pasting it all the way in the top left this would look something like this so if the original Monster was right in the middle then this offset would give us an outline in the top left something like this in fact I believe the best way to demonstrate how this is working is by first of all returning the outline frame dictionary that way we have one part of the outline inside of the monster frames that we can use in the battle class we don't need check active anymore but when we are creating a monster I want to create one more class which is going to contain all of the outlines so right below the monster Sprite I want to create a monster out line Sprite Which is going to need the monster Sprite it will be in self. battle Sprites for the frames I want to have the outline underscore frames that's all we need in there although first of all we will need the outline frames those we are going to get like we have gotten the frames for all of the monsters in the first place I and there I want to have the outline frames which we first of all forget with self. monster frames there we have out lines from which we want to pick monster. name also really important if we are on the monster side we want to flip all of that which means we want to overwrite the outline frames with basically the same thing we have done for the original frames in fact I can copy all of this the only difference is that we now want to look at the outline frames. items so with that we have all of the arguments for the monster outline Sprite that means inside of Sprites right below the monster Sprite I want to have another class monster outline Sprite Which once again is pam. sprite. Sprite for Dunder init method I want to have self a monster Sprite the groups and the frames we want to dis play next up I want to have super Thunder innit with the groups and we're also going to need self. Z which we are getting from the battle layers and this one should be on the outline layer we want to store self. monsters Sprite as Monster Sprite and then self. frames is going to be frames once we have that we can actually create the Sprite we want to have self. image and self. rectangle for the image we want to have self. frames now for the state I want to look at the monster Sprite basically for this monster outline Sprite I always want to have the same state and the same frame index from the monster Sprite that why we are linking the animations which means for frames we will need self. monsters sprite. State and basically we getting this state next up we we will need the frame index and for that we have to change a few more things although that we can do inside of the animation first of all for the indexing I want self. monster sprite. frame index after that for the rectangle self. image. getf rectangle I want to place this Center to wherever self. moners sprite. rec. Center is now we just have to figure out inside of battle. Pi once a monster is ready we want to display the outline that we are going to do inside of the groups basically we want to check for all of the Sprites if sprite. Z is on battlecore layers and the outline I.E we are only looking at the outline layers and if and if it is not the case we are simply drawing all of the Sprites however if that is the case we want to get the Sprite and then look at the monster uncore Sprite remember Sprite is the outline Sprite the one we have just created which we don't really care about we want to know if the monster Sprite is selected if this one is equal to the current monster Sprite then we want to self. display surface. blit with sprite. image and sprite. rectangle now current monster Sprite we do not have available although that we can get via the parameter I.E inside of battle. Pi when we are drawing everything we want to pass in self. current monster after that we should be good to go although I did realize that we are not importing the monster outline Sprite but once we have that inside of main. Pi we are getting list index out of range that happens inside of this line where we are trying to assign a surface to the image to diagnose what's going wrong here let's print self. frames if I now run main. pi and scroll up a bit we can see that we have a dictionary for the frames but there are no surfaces inside of the list that is an issue that happens inside of the outline Creator function to fix that all we have to do is get the outline frame dictionary then the monster along with the state and append the new Surface the one with the outline and the white monster let's try off this again and now there we can see something so this is definitely making progress and also when we are printing the dictionary we are getting a whole bunch of surfaces that is definitely making progress and let me run all of this again once the first monster gets ready we get a whole bunch of black stuff around it that we can get rid of in just a second they really important part for now though is that we have a surface with a minor offset that is what we actually want and I think this part is getting a bit confusing so let me go over it once again we start with an outline Creator in there inside of support we are looking at all of the Monster frames and for all of those we are basically expanding the original surface and filling it with a white color these new surfaces we are then passing into another class monster outline Sprite which in turn is linked to monster Sprite also we don't need to print statement anymore so this monster outline Sprite has basically the same frames as the monster Sprite I.E the frames inside of this class are the same as the monster Sprite except they're white and a bit expanded after that once a monster is ready we are setting it to the current monster and then when we are drawing all of the Sprites inside of groups we are checking if a monster is currently selected and then we are displaying the outline Sprite behind it for for the logic you might have to go over it a couple of times it does get a bit more complex anyway the first thing that I want to do is get rid of the black background that doesn't look good for that inside of the new Surface I want to add another argument pame do SRC ala after that new surface. bill with a tup of 0 0 0 and zero I this new Surface is entirely invisible if I now run main Pi again we only get the white color and that's already looking pretty good we just have to get all of the other sides as well so inside of support I want to duplicate this line and then cover another side which I can for example get with whift and zero if I now remain not P again we are getting two sides and well this we basically want to do for all of the other sides and let me get rid of the comment besides whiff I also want to get wi time 2 that way we getting to the top right next up wi * 2 and wi that would be the center right and after that with * two for both arguments this will be the bottom right Next Step we want to have the bottom this would be whift and whift time 2 after that I want to have zero and wi * 2 and finally zero and Wii this would be the left side those are going to be all of the eight sides so 1 2 3 4 five 6 7even and eight looks good if I now run main. pie and the monster is ready we get a white outline that isn't animated yet so we do have a start but we need just a bit more inside of the monster outline Sprite we want to add an update method so Define update self and Delta time although Delta time we don't actually need let me add an underscore instead after that we want to get self. image which we're getting from self do frames then I want to have self. monsters Sprite do state and you might also be tempted to use self. monster sprite. frame index although for all of that to work we will also have to cover the integer and the modulus I.E let me copy actually all of this and then paste it in there now this we have to update we want to get the frame index from self. monstore sprite. frame index after that let me copy this self dooners sprite. frames and then also self dooners sprite. state with all of that we are already getting a really long line which isn't ideal but inside of main. Pi we are getting an animation so this is kind of working but not exactly something I like because this just feels a bit clunky instead inside of the monster Sprite when we are animating all of that I want to get a frame index that we can use inside of the outline Sprite all we really need in there is self do I call this one the adjusted frame index which is going to be the integer of self. frame index with modulus of the length of self. frames with self. State this is basically the same that we are doing on the next line in fact we can simply pass self. adjusted frame index in there and now that we have that we can get this self. adjusted frame index and pass it into this indexing operation by self. monster Sprite do adjusted frame index the result should be the same and that is looking pretty good and now the logic inside of the monster outline Sprite is also much more readable cool with that we know if a monster is selected however there's one more thing that I do want to do and that's going to happen inside of the monster Sprite you might actually be wondering why did we set set highlight because inside of the group when we are highlighting the monster we are checking if the monster Sprite is the current monster Sprite why don't we just check if the monster is highlighted or not the reason for that is that later on we are going to have quite a few more conditions in there and this is going to be the most efficient way of doing things we are however still going to use the Highlight value although only for a short bit once the monster is selected I want to always display the outline and then make the entire monster flash for a short bit let's say around half a second for that I want to work inside of animate if the monster is highlighted I.E if self. highlight then I want to get a mask again I.E I want to have let's call this one a white surface which we are once again getting from pame mask do from undor surface this surface that we want to convert is self. image and after we have all of that I want to go straight back to surface that way we are getting the silhouette from this silhouette we want to remove all of the black pixels I.E set uncore color key and I want to remove black finally self Dot image is going to be the White surface with that if I now run main. Pi we left the battle and now the selected monster becomes Pure White that is looking decent after we of that inside of the monster Sprite I want to create a bunch of timers timers and in there I want to have self. timers which is going to be a dictionary in which for now we have one timer to remove the Highlight this is going to be a timer that I don't think we have at the moment all the way at the top from timer import timer for a duration let's say half a second for the function we essentially want to call set highlight and then pass in the Boolean false value which we can do via a Lambda function in which want to call self. set highlight with a false value that way we can insert arguments without calling them after that inside of set highlight I want to check if value is truthy I.E if we are activating the Highlight if that is the case I want to get self. timers with the remove highlight timer and then activate all of that also what's really important inside of the update method we have to go for timer in. timers do values and then timer. update with that inside of main.py we are getting a white flash for a short amount of time and this might even be a bit too long let's change the duration to 300 milliseconds and now yeah I think that looks a bit better but once again play around with the numbers and just see what looks good anyway with that we can work inside of the battle class and I want to keep on working inside of check active I want to check if the currently ready monster is one of the players that I can do with if self. layer Sprites in Monster sprite. groups this means we are looking at the monster Sprite the one we getting for from the four Loop and we are checking all of the groups and if the player Sprites are inside of that group then we know that a monster Sprite of the player is currently ready just to test if this is working let's print player monster ready I can run main pi and now we get player monster ready that looks good so inside of this if statement we want to get some kind of option to display a menu which I have done via another ATT rute self. selection uncore mode which I have called General now for that to work we have to work a bit more inside of Dunder in it under control because in there we will need a few attributes the one we have already seen is self. selection mode which by default is going to be none and later on this one could also be attack it could be switching a monster things like that after that I want to have self. selection uncore site which by default is going to be player it could also be opponent if that's the case we can select the opponent monsters should be straightforward and finally I want to create self. index C which is going to be a dictionary with a bunch of values we have General with zero then I can duplicate this a few times because besides that we want to have a monster in index we want to have an aex index along with a switch index and finally a Target index all of this is going to make sense in just a bit but just to explain the outlines imagine for selection mode we have General the one we are setting a bit further down if that is the case we have the monster and then we want to display a couple of icons like so those will be for the attacks defense switching a monster and catching a monster the indexes we are then going to use to select one of these options or in other words if selection mode is general and the general index is zero we want to be up here in fact now that we have that I want to add another section I call this one the UI and there I want to Define draw General only for custom parameters in there we want to draw all of the general options and just for some extra context this is the end result where we have the four icons right next to the active monster for that we want to create a for Loop that covers every individual item and those we are getting from settings because in there we have battle choices we getting the full choice if we are fighting a random mon monster and we're getting a limited choice if we are fighting a trainer the reason for that is if we are fighting a trainer there shouldn't be a catch option that one is only available for random monsters we want to get the battle choices but now let's call this data in battle choices and print what we get although to actually see the output we have to figure out when to call this method and for that I want to have another method Define draw UI basically in there I want to check if self. current monster exists and if that is the case I want to check if self. selection mode is equal to General if that is the case I want to call self. draw General this draw UI method we are then going to call inside of the update method on top of everything else self. draw UI well now if I run the code and the monster gets ready we are getting the different keys inside of the dictionary so at the very least we get something but this isn't ideal I suppose for a bit more detail we could add items and then we get a little bit more information but we have the other dictionary with all of the positions along with an icon at the moment I always want to get the full amount on top of that I want to get the index via enumerate that way I will get the index and then inside of a tupo the option and a data dictionary and just to visualize all of that I have the index I have an option and I have a data dictionary oh and also don't forget after the full dictionary we want to get the items if I now run main. pi we are getting all of the options so in there we have zero fight one defend two switch and three catch along with a position and an icon we want to display that is all the information we need so now we can draw a bunch of surfaces and those surfaces we actually already have because inside of main.py we have imported all of the UI icons if you look at the project folder under graphics and you are we already imported this folder and in there we for example have the hand we have a hand highlight we have a shield a shield highlight and a sword and a sword highlight oh and also the arrows for switching a monster those are the icons that we want to use which means I want to get a Surface and this I get via self. monster frames and then I want to get the UI the key I want to pick is what I'm getting from data dictionary and the icon so if you look at settings there we have a dictionary with a position and an icon after that we can create a rectangle which is going to be surface. getet uncore F rectangle where we are placing this Center and essentially I want to get self. current monster. rec. mid right Plus data dictionary and then the key position the position here might not be the best name it's more of an offset where we getting the right side of the monster and then adding these numbers anyway once we have all of that we can call self. display surface do blit with the surface and the rectangle if I now run main. pi and the monster gets ready we get the options they don't do anything at the moment but at the very least we can see something now before recover the input there are two more things that I want to do number one the currently selected icon should have an outline and then every other icon should be grade out so the player has an idea of what is being selected now this is going to be much easier compared to what we have done with the monsters because if you look at the UI folder there we have for example the shield and then a shield highlight or in other words if the current index is equal to the selected index then we wanton want to display the icon with the outline and then gray out everything else for that we have to work a bit more with the surface for which I want to add an if statement if the index is equal to self. indexes and the general index which at the moment is this one so we're getting a zero I.E the first item should be selected which means this surface should be the data icon this would give us a value like sword or Shield but to that we want to add an underscore I think the easiest way of doing that is to turn all of this into an F string and then select the icon along with underscore highlight and if that is not the case else the surface should be simply the icon for now and then we also are not going to need the F string let's see if this one is working and this is a bit hard to see but now around the sword we have a white outline I suppose we could change the general index to a two and now we are getting a white outline around the switch symbol so that's working pretty well although this value should be Zero by default next up for this surface that is not selected I want to wrap all of this into py game. transform. grayscale that way if I run M notp again any icon that's not selected will be great out that's looking pretty good so now we can draw the general options but they don't do anything for that we will need an input method which I have put a bit further up I want to have Define input and I guess I should add another comment for all of this the first four methods would be the methods for input I want to have self and no other parameters and then we want to get all of the keys as always which we are getting with pygame dokey doget uncore justor press which we can then use with keys and for example py game. Kore down but now let's add pass in here because first of all I want to outline all of the keys that we need there aren't very many we have key down key up and py game. key space these are the only input options and the space key we can ignore for now essentially if the player presses K down then I want to get self. indexes along with self. selection mode I.E at the moment our selection mode is general that means we are working with this number which we want to increase by one if we are pressing up we are doing the same thing except this number should get minus equal 1 although we do have to be careful here if we don't have a selection mode which is the case by default this would give us an error so we want to only check all of this if self. selection mode and just to be sure self. current monster there should only be an input if both of these are true so all of this gets indented one more time and then we have to make sure that we are actually calling the input method let's do it before we are doing anything else self. input if I now run main.py we're getting the options and if I press down or up we are selecting a different icon that works reasonably well but I can go outside of this selection which shouldn't be the case so if you press up too much or down too much nothing is being selected to cover that part we will need a limiter which is going to happen inside of input basically what I want to check is via a match case statement I want to know what our current self. selection mode is if there is the case General then I want to create a limiter which would be the length of battle choices with the full amount so at the moment this number would be a four which is a good sign because I want to limit this number to a four so if we go to a five we want to go back to a one the way we are going to achieve that is we want to assign a new value which is going to be self. indexes and the general index and this we want to increase by one but on all of this we want to use modulus with the limiter this we want to do for down and up except for up it should become a minus one that should actually cover everything although I realize I have a typo there shouldn't be a white space before General let's run my. pi and then I can go down and if I go to index 5 we are starting from the beginning again so that is working really well now the UI is working significantly better once we have that we can check for the space key first of all in there we want to check what kind of selection mode we currently have which we do with if self do selection mode is equal to General if that is the case we can add a few more if statements to check what the current index is for example if self do indexes and general is equal to zero then we want to print a attack if this number is a one then we want to print defense if the number is a two then we want to print switch and finally if the number is a three then we want to print catch let's try that one and if I print space on Z we get attack then defense then switch and catch so we can select one of the options and that works Fairly reliable what we can already work on is the defense so the index being one if that is the case I want to self. update all monsters and then resume things on top of that self. current monster and self. selection mode should be none fin self. indexes and general is going to be zero that way we are resetting everything and now if I run main. Pi I can select defense and the game continues and then we are selecting an opponent that's not ideal for testing purposes that we can change inside of main. Pi for all of the opponent monsters I want to have a lower level let's say we can go with five three three and two that way our monsters should always be faster and then I get the other monster and this can also defend and we get our first Monster again so this part is already working quite well we are making some decent progress so next up we can work on the attack and the switch logic if the player selects the first option we want to set self. selection mode to a attack and then if the player selects number two we want to go with switch although I think the selection mode for attack is actually called attacks the one I have outlined up here so with that we can pick one selection mode which means we have to draw a few more UI elements we want to have Define draw a text with pass for now and we want to have the L raw switch with self and pass as well to select one of those we have to work inside of draw UI if self. selection mode is equal to a text then we want to call self. draw it text and if self. selection mode is equal to switch then we want to call self. draw switch and let's get started with the attacks for that we have to start by getting the abilities in the first place for which we want to get the current monster then monster and get ability the method that we already have inside of the monster we have use that for the index after that I want to set a height for the box which is going to be 200 I want to set the amount of visible attacks which I want to keep at four next up I want to set an item height which is simply going to be the height divided by visible attacks also we are going to need a v offset which for now is going to be zero and by the way the system that we are going to create will be very similar compared to the list that we have made for the index so so first of all we need the data after that I want to create the background for which we are going to need a BG rectangle which is going to be a pame f wct with a position and a size the position we're going to ignore for now so zero and zero for the size I want to have width and height with the height be being the height and I realized I didn't set a Whi let's do it in the data part Wii and height and this should be 150 and 200 that way we can set Whi and height in there right away this rectangle we then want to move to a position the point I want to place is the mid left which is going to be self. current monster. w. mid right plus and offset that I have set to Vector of 20 and zero I.E we are placing the mid left of this option to the right side of the monster plus 20 pixels once we have that we can call py game. draw. rectangle we want to draw on self. display surface the color we are getting from colors and white then we want to draw the BG rectangle we want to have zero for the Border width and then five for Border radius with that if I run main. pi and I select attack we are getting an area that we can use for the attacks very good start next up we want to display the actual attack options for that we will need for index and ability in enumerate ability for this one we want to have a text we want to have have a rectangle and then we want to draw all of this first of all though we want to know if the current item is selected which we are getting via index is equal to self. indexes and attex and for the text I want to have a text color and a text underscore surface for now for the text color let's simply go with colors and the one that I want to choose is called light then for the Tex text surface I want to get self. fonts with the regular font and render it with the ability then fults and the text color that way we are getting some text that we can display next up we will need to position that text which we're doing with text rectangle I want to get the text surface and then get f rectang angle in which I'm placing the center I want to get BG rectangle IE the background rectangle for the entire bit and the midtop of this point plus a vector that goes zero pixels left and right and to that I want to add the item height divided by two plus the index multiplied with the item height also Al to all of this we want to add the V offset although this one is zero at the moment and just to explain the numbers if this is the background rectangle we want to place the attack options let's say one here one here one here and one here and they should distribute the area equally so that we always have the same distance between them the way I have approached that is I first of all set a starting position which is the this distance and then to that we are adding index multiplied by the item height I.E if this is zero we are staying here if this is one we are going there if this is two we are going down here and so on with that we have a text surface and a text rectangle so now we can self. display surface do blit with the text surface and the text rectangle let's try main. pi and if I select the options we can see something although we already have the issue that there's an extra option at the bottom also nothing is selected and if I press down the game crashes because we do not have the limiter variable so let's go through all of this step by step first of all we have to reenable the input at the moment this limiter does not exist because inside of match case we are not checking for attacks that we can fix fairly easily case it attacks the limiter that we want to create create is the length of self. current monster. monster. getet abilities that way if I run main. Pi I can at the very least press up and down although it doesn't do anything at the moment but at least the game doesn't crash anymore inside of draw attacks there are two things that I want to do to highlight the currently selected attack I want to change the Tex's color and then add a background for that we want to check if selected then we want to get a specific color however if that is not the case else then we have the basic text color for more specific color I want to get colors and then use the element of the attack let's store that one in a separate variable element this one we can get from the attack data that's currently not available for that all the way at the top I want from gamecore data import a TCH data we are importing this dictionary that we can use and let me minimize everything inside of draw attacks we have the attack data and then we have the ability from that we want to get the string element and that ele element we can now use inside of the colors to create a textor color or rather a more specific text color for the text surface let's try main. pi and now inside of attack we are getting something but the selection doesn't really work something has gone wrong and I believe I know what the issue is inside of input when we are assigning a new Index this shouldn't be General Instead This should be self. selection mode that way we can use different kinds of selection modes or rather different selection indexes or Draw attacks we are using the attack index so with all of that let's try it again and now I can kind of select all of the attacks there's just one issue and that is the color for the normal attack just doesn't work well that is because the element color for the normal attack is a pure white which I don't really like to fix that I only want to get the element color if the element is different from normal if that is not the case else I want to get colors and black and with that if I now run main. Pi we're getting a black color which feels much better although I also want to have a background color below the text rectangle I want to create a text BG rectangle pame dot f wct for which we will need a position and a size position doesn't really matter so we can go with zero and zero for the size I want to have the width of the entire thing and then the item height after we have all of that I want to call move to to move the center to the text rectangle Center this rectangle we then want to draw which we do with py game. draw. rectangle self. display surface for now let's go with a red color and then text BG rectangle after that we have a bit too much red the issue here is that we are drawing this rectangle for every single element which is incorrect we only want to draw it if selected let's try that one again and now there we go this looks much more noticeable it doesn't look great but well we have something the most notable issue is that the red color just doesn't fit well to get a better one I want to access the colors dictionary I want to use the light color for this one and now inside of main. Pi we are getting a color although I think this one is quite dark so maybe not ideal instead inside of settings I want to add another entry that you are already going to have I call this one dark white with a hex code of F0 F0 and F0 you should already have this entry I simply forgot to add it that's right now and that is looking much better there are two more things that we have to cover number one is this last item at the bottom shouldn't be visible and if we go further down there should be a scroll effect like we have done for the list inside of the index first of all when we are drawing all of the elements we only want to draw things that are inside of the BG rectangle which means I want to check if BG rectangle do Collide point with text rectangle do Center on top of that we want to check and seed inside of this if statement we still want to check if an item is selected and then there we also want to do the blit operation that should already do a bit if I now run this again we cannot see the last element anymore so progress but not ideal to fix all of that we have to work with the V offset this one should only be zero if self. indexes and it Xs is smaller than the visible attacks if that is not the case else it should be negative self. indexes and attacks minus the visible attacks plus one all of that we want to multiply with the item height the very same thing we have done for the index let's try this one and now if I scroll down we are getting all of the elements so that is looking really good perfect the last thing that is a bit weird is the corner radius that we have to fix inside of the drawing when we are drawing the text BG rectangle inside of selected we want to check if text BG rectangle. Collide point with BG rect do top left I we know we are at the top if that is the case we want to draw the entire thing with a border width of zero a general Corner radius of zero as well then five and five for the top left and top right next up we have an L if statement where we are checking if the text PG rectangle collides with the BG rectangled mid bottom although to that I want to add a vector of 0 and 1 if that is the case I want to draw another rectangle we want to have zero for the Border WID the top left and top right should be zero and zero but the bottom border radi should be five and five after we have all of that else we simply want to draw the general text BG rectangle and with that I can run all of this again and that is feeling pretty good so with that we're getting all the attacks and we get the attack type that is making a lot of progress there's just one more thing that I do want to cover and that is that all of these attacks have a cost and we should only display the attacks that are available or in other words if you look at game data they can see that all of the attacks have a cost and if this cost is greater than monster dot energy then this attack should not be displayed to implement that mechanic we want to look at get abilities I want to add another parameter all that by default is going to be true and then if all is the case then I want to return what we are already returning however if that is not the case so else then I want to return all of the abilities that are available for this level but then I'm going to add a second condition and a tagore data something that we currently don't have available so all the way at the top from game data import monster data and attack data we want to check the one ability and then the cost only if that value is below self. energy then we want to return it which means inside of the battle when we are getting all of the abilities that happens all the way down here I want to set all to BS the same thing we have to do inside of input when we are getting the abilities there all should also be false now inside of the game this is going to be a bit hard to see simply because this monster has a huge amount of energy and all of these attacks don't take very much but for example for heal we could increase the amount by a lot so that to heal cost could be 600 more than the monster even has so now if we run main. Pi this one shouldn't be visible and it is not so this one is working and also with that we have finished the draw attacks method it doesn't actually do anything at the moment but that we're going to cover in the next part before that I want to cover draw switch that part is going to be your exercise I want you to create the switch menu you only have to display it like we have done for the attack menu the actual functionality is going to come later and the end result should look something like this so pause the video now and try this one on your own to get started we want to declare some data I want to set a height and a width those numbers can be fairly subjective but I went with 300 and 320 then we want to have the amount of visible monsters which I have set to four after that once again we want to have an item height which is the height of the entire menu divided by the visible monsters next up we will need a v offset that we have done a couple of times by now so I can implement the entire thing straight away zero if self. indexes and now we are working inside of the switch index and we only want to get zero if this number is below the visible not attacks but monsters else we want to get Negative self. indexes and switch minus the visible monsters + one which we want to multiply with the item I after that we can create a BG rectangle which is a pame f rectangle for the position we can as always go with zero and zero and for the size I want to have the width along with the height then I want to move this thing to a certain position which in this case will be the mid left is self. current monster do W do mid right plus a Vector of 20 and zero that is going to give us a BG rectangle let's draw it right away py. draw. rectangle self. display surface the color is going to be colors and white and finally we want to draw the BG rectangle let's try main. pi and now if I select switch we are getting an error because of a typo this should be Pi game. F rectangle next attempt and there we go that looks pretty all right I suppose the one thing that we do want to add is zero for Border width and then five for Corner radius after that we want to get all of the available Monsters the way I have approached that first of all I want to get all of the active monsters inside of a list or in other words I want to have the monster Sprite for Monster Sprite in self. player Sprites although I don't actually care about the Sprite itself that I want to have monster sprite. index and monsters sprite. monster that way we get the index of the monster and the actual monster data basically the same thing that we are getting up here or rather we're getting something like this where we have a monster along with an index to identify it that is really important because later on we want to switch to monsters so we have to know exactly what kind of monster we are working with although if you didn't include it for this part in the exercise don't worry too much about it that wasn't really part of the exercise after that I want to get self. available uncore monsters which has to be an attribute l on inside of the input that will become important we want to create a dictionary with an index and a monster for index monster in self Doge monster data of the layer with that we are copying all of the Monster data but that we only want to do if a certain condition is true and also from the player monsters we want to get the items but we only want to get all of that if the index and the monster are not in active monsters and I suppose also while we are here and monster. health is greater than zero if the monster has been defeated there's no point showing it but that's not too important for now anyway with that we are getting of the available monsters which we can then use inside of a for Loop for index and monster in a numerate self. available monsters. values to get started we want to know what item is selected which we're getting with index equal self do indexes and switch next up we will need an item BG rectangle this is the equivalent of the text PG rectangle of the last part I.E I want to have an F rectangle the position is going to be zero and zero and the size is going to be width and the item height this we want to move to a specific point or in other words I want to place the mid left of this rectangle the X position is always going to be the left side of the background I.E BG rectangle do left for the Y position I want to have the BG rectangle do top plus item height divided by two to set a start point and to that I want to add the index multiplied by the item height and don't forget to all of that we want to add the V of set quite a long line but I hope at this point you understand the logic after that I want to create an icon surface and I can rectangle a text underscore surface and a text uncore rectangle we want to display the icon of the monster and then its name for the icon surface I want to get self. monster frames with the icons the data we have imported earlier and then get monster. name for the icon rectangle I want to get the icon surface get F rectangle and place the mid left point for the Target position I want to have a BG rectangle dot top left plus a vector of 10 for x or why I want to get basically all of the stuff that we have done here except BG re. top so let me copy it in there that way we always getting to the vertical Center for each increment next up we have to text surface that one's a bit easier we simply want to get a font self. fonts and I want to use the regular one and then render an F string with the monster. name and then in parentheses monster. level for antialias we want to have faults and for the color I want to get colors red but only if selected and else it should be colors black or in other words we are simply picking one of two colors depending on the monster being selected or not finally we have a text rectangle which we're getting from the text surface. get F wed we want to place the top left to BG re. left Plus 90 and for the vertical point I can rect dot pop now for the drawing logic I want to have a for loop with surface and rectangle in the Tuple that contains two TS I can Surface and I can rectangle after that we have the text surface and the text rectangle in inside of this for Loop we can then run self. display surface. blit with the surface and the rectangle quite a bit of stuff let's run main.py and let's see what crashes first if I go to switch we can see them monsters but if I press down the limiter doesn't exist so not ideal for that we have to work inside of input and then add another case for switch for the limiter I want to get the length of self. available monsters let's try all of this again if I may now go to switch we can see all of the monsters that are available let's looking pretty good also the selection works just fine quite happy with that I suppose the one minor thing that doesn't look terribly good is when we are getting the monster name X surface I want to have a space between the monster name and the level a super minor point I suppose there are two more major points that I want to cover first of all I want to have a selection background so it's a bit more visible what is being selected for that if selected is the case then I want to check if the item BG rectangle do Collide point with with BG rectangle. toop left or any point at the top to be honest if that is the case I want to run pame do draw. rectangle self. display surface for the color I want to have colors and dark white finally then we want to have the item BG rectangle and there's one dot too much of Z and1 if that is the case I want to draw another rectangle although now zero for top left and zero for top right that way only the bottom has a corner radius finally if neither of those conditions are true then I want to draw the item backround rectangle without any Corner radius let's try all of that and there we go so with that we can see a bit better what item is being selected next up then I first of all want to make sure that we don't see more than four monsters which at the moment isn't really the case because we only have four more monsters and most of them don't have any health I suppose I could add a few more with a high level like so and if I now run all of this again when we are selecting the monsters we can see too much so this isn't great to fix that we want to have another if statement if BG rectangle do Collide Point item BG rectangle Dot Center or in other words only if the center of the BG rectangle is inside of the main rectangle do we want to draw anything with that I can only see the monsters inside of the rectangle so that's working pretty well finally the last thing I want to do in here is I want to display the health rectangle and the energy rectangle for which we're going to need two rectangles Health rectangle and energy rectangle for both of those I want to have a pame do F rectangle for the position of the health rectangle I want to have the text rectangle do bottom left and to that I want to add a vector of0 and four simply to add a bit more padding and then for the size I want to have 100 and four once again numbers that simply look good for the energy rectangle the position is going to be the health rectangle dot bottom left with a vector offset of 0 and two the size of this one is going to be a bit less let's say 8 80 and4 finally we can call draw uncore bar again which I don't think we have at the moment which means I want from support import draw bar and this class is already getting quite massive but anyway for a draw bar we are going to need a whole bunch of arguments so let me do both at the same time we want to draw on self. display surface the rectangle is going to be either the health rectangle or the energy rectangle the two rectangles we have just created for the value we will need monster. health and monster do energy then we will need the max value which is going to be monster. getet stat with the maxcore health for energy we want to get the same thing except it should be Max Energy and then we need to color for the value which is going to be colors with something that we will cover in a second and then the background color for both of those is going to be black now for the health bar rectangle I want to have a red color and for the energy one I want to have a blue color that should be it if I now run main. pi and I select switch we are getting all of the monsters along with the health and their energy so that is looking pretty good quite happy with that we are nearly done the last thing that I want to cover is going to be inside of input the issue that I want to fix is if the player is inside of the attack mode or the switch mode and then wants to go back then well there's no way of doing that to fix that we want to add one more input statement which is to be on this same indentation level as the space key I want to check if keys and py game. kcore escape and in there I want to check if self. selection mode is in a text switch or Target this one we haven't seen yet but it's basically for targeting an opponent or one of your own monsters for healing if this if statement triggers then we want to set self. selection mode back to General so with that I can run the entire thing I can click on attack we still got the same options but if I press Escape we go back to the selection menu and then we can select other things like defend and this still works really well cool with that we are done with this part and for the next bit we can start implementing actual functionality in this section we are going to finish up the the outlines of the battle system I.E we are actually able to attack the opponents the opponents can also attack us we can switch monsters we can catch an opponent monster we can defend and all the basic parts of the battle system so by the end of this part we basically have a game to get started I want to keep on working inside of battle specifically inside of the input method at the moment we can go from the general selection to the attack mode but then inside of attack we can't really do anything which means I want to add another if statement and this one has to come before this if statement for the general mode I'll explain in a second why in there I want to check if self. selection mode is equal to a Tex if that is the case there are three things that we want to do we want to set this selection mode and this we can do right away in code self. selection mode should now be Target I.E we are targeting either an opponent or one of our own monsters besides that we want to have a self. selected this one doesn't exist yet and we want to have self dot selection site this one we have created earlier inside of thunder in it selection site by default this one is player and just to add the one additional attribute self do selected attack by default this one is none so we don't need thunder in it and then we have to figure out the selected attack and the selected side to get this selected attack we want to get self. current monster monster get abilities and for this one we only want to have the available ones I.E all should be false this is going to give us the same list for the tag moves that we have seen in the menu which means if we are using indexing with self. indexes and a tack then we are going to get the same attack let me comment out selection s and simply print self. selected attack if I now run main. Pi the game doesn't crash that's a good start and if I now press space we get scratch and then things disappear and we are getting a limit problem because now we have switched to the selection mode Target let's comment this one out for now actually and run all of this again now I can select different attack moves and they line up with what we are seeing in the menu so this part is working quite well let's try another monster we get scratch fire battlecry and explosion so that is working well with that we can get the selection mode for Target again remove the print statement and then I want to select a selection site I.E are we targeting the opponents or our own monsters that we can get via attack data and then self. selected attack if you look at attack data there we have a Target which can either be opponent or the player and well the only two attacks that we have that Target the player a heal and battlecry everything else targets the opponent either way we want to get the Target and if that selection mode is selected then we don't want to have a UI element we simply want to pick one of the opponent monsters but first of all for that we will need another case for a new limiter the case I want to Target is called well Target and then we need to create a limiter which should be the length of self. opponent Sprites but only if self. selection not mode but side is equal to opponent if that is not the case else we want to get the length of self. player Sprites or in other words we want to know how many opponent monsters there are or how many player monsters there are that is all we need in here there's just one more thing that I do want to cover and that is that we will need this selection mode for attacks before the selection mode for General let's go through this thing step by step first of all we are pressing space while having some kind of index by this index inside of selection mode we know what option we want to pick for example if the index is zero we want to go to attack and let's stick with that case so at the moment once we get to this point we are continuing the code and nothing is going to happen but on the next for Loop of the game we are getting to the attack mode and none of the selection mode General is being triggered however if that was flipped around if we did all of this first and then this part second we would still check for pame dospace along with an index then we would trigger the attack but then we are going straight to the attacks because those come right after and because of that we would trigger an attack right away and having the right order of the if statements is I think the easiest way to solve that you could also work with L if statements but that could cause some other issues down the line anyway for now we want to Target some opponent monsters we don't have to worry about attacks anymore and general we also don't need next up I want to have if self. selection mode is is equal to Target for that first of all we want to know what spreite group we are targeting IE Sprite group should be a local variable that we're going to get from self. opponent Sprites if self. selection site is equal to the opponent if that is not the case else we want to have self. layer rights so now we have a couple of Sprites that we are looking at but then we have to be careful so imagine we have three opponent monsters one two and three and we want to select them via their index so this would be index 0 1 and two at this point you might be tempted to take this Sprite group turn it into a list and then use indexing so if our Target index is zero we get this one if the target index is one we get this one and so on that would not be a good approach simply because later on it is totally possible to defeat one of the monsters so this one wouldn't exist anymore and if we then had an index one we would get really confused so essentially we have to take this Sprite group and then create a custom list from that that has to be dynamic I call this one the Sprites and that is going to be a dictionary where we get Sprite and then the position underscore index as a key and the associated value is the Sprite itself for sprite in Sprite group the thing we have just created after that we can get an actual monster uncore Sprite Which we can get via the Sprites and indexing I want to have the list of Sprites do keys and on that use index in by yourself do indexes along with the Target and just to make sure this is working let me print it and then I will explain it in a bit more detail but let's try main. Pi if I have a monster ready I can attack and if I press space we get a monster another monster and another monster Sprite although we can't really see the difference I suppose what we should rather print is Monster Sprite do monster that's going to make much more sense if I now attack we get monster monster and monster along with the right name so that is looking pretty good that backs the question what happened here especially the last line I think is going to be confusing let's do a few examples the most important thing to understand is this Sprites which is going to be a dictionary where we have the position index and then the monster Sprite for example we could have a dictionary with 0 1 and two for the indexes and then each of those have a monster attached that is essentially what we have at the moment in our game the keys of this dictionary we are then going to turn into a list which means we have a list with zero one and two after that we're going to pick one of those keys via indexes from our Target index let's imagine our Target index is one that way we would get a one if our Target index was two we would get get a two so that way we're not really changing the number however let's do another example where this dictionary is going to have only two values we have one at index zero with a monster and then one at index two with a monster we only have a monster on top and a monster on the bottom the middle monster has been defeated after that once again we are turning the keys into a list so now we have a list with zero and two and now imagine that our index is one I.E we want to pick the second monster via this system this one is now becoming a two while an index of zero for the selection would still be a zero that way we always pick the right monster even if there are gaps among the opponent monsters or amongst the player monsters could also be a case anyway with that we don't need the print statement anymore and next up we have to actually highlight the targeted monster for that part we don't need input anymore and we want to work inside of battles Sprites do raw with the current monster so essentially the monster that we are currently targeting should have a white outline like we have done for the currently active monster to make that work we will first of all need a whole bunch more arguments and let's create the parameters first of all inside of the draw method besides the current monster Sprite I want to have the site I want to have the mode then I want to have a Target uncore index and finally I want to have the player uncore Sprites along with the opponent Sprites after that let me copy all of the parameters and then paste them after self. current monster the side that we are working on we're getting from self. selection site the mode is going to be self. SEL section mode Target index will be self. indexes along with the target after that we will need self. player Sprites and self. opponent Sprites quite a bit of data but that is what we need to highlight the currently targeted monster first of all though we have to do some setup like we have done before I want to get the available positions I want to get this Sprite uncore G Group which is going to be the opponent Sprites if side is equal to opponent and else layer Sprites with that we know what Sprites to Target and then like before we want to create a dictionary with Sprite Doos index and the Sprite for sprite in Sprite group and and finally I want to get the actual monster Sprite that is currently targeted Sprites stand indexing with the list of Sprites do ke along with the target index cool and with that we have a monster Sprite that means inside of this if condition we want to add a second line via or I want to check if the Sprite do monster Sprite and once again as a reminder the Sprite that we are working with here is the monster outline Sprite Which has one attribute that stores the monster Sprite itself which is what we actually care about if this is equal to the monster Sprite that we have gotten up here then we want to create an outline as well let's try that part if I now run all of this and I can select a monster we get an outline for the targeted monster so that is working really well quite happy with that so we are making progress also if I now press Escape we getting back to the attack options let's use the shield because I think this monster has battlecry this one should only target our own monsters that is also working well although for this part I want to disable build the monster highlight for the currently selected monster because without that the selection here looks a bit weird for that inside of groups when we have the first condition we want to disable this part if the player is selecting the player monsters which we can do via an end not I want to check if the mode is equal to Target and site is equal to the player or in other words we only want to highlight the current monster if we are not in Target mode and deci side is the player let's try that part and now we want to get to Chad Dillo and use battlecry and that is working really well now if I press space nothing is going to happen but we have a nice selection system which means next up inside of battle. Pi we want to work in the input method and let me hide all of the if statements that we don't need to make this a bit less confusing we still want to work inside of Target at the moment we are only getting the current monster Sprite that we have to use the player's pressing space and we are in the Target mode after that we getting a monster Sprite to Target and then we want to check if self do selected attack if that is the case we want to attack a monster because remember inside of selection mode attack we have gotten a selected attack later on we can also catch a monster then we have an else statement that for now is going to be pass we have selected a monster Sprite and we have an attack that means we want to attack that monster that unfortunately we cannot do immediately instead I want to get self current monster. activate uncore attack or in other words what we are going to do once we get to this part we want the monster to play an attack animation once that animation is over we actually trigger the attack which means we have to work inside of the monster and give it two arguments we want to have the monster Sprite or in other words the Target and then we want to have self. selected attack I.E the attack that the monster is supposed to execute after that self. selected attack self. current monster and self. selection mode should all be none that way we can continue to the next Monster so inside of the monster Sprite we will need a method called activate attack when Sprites monster Sprite we want to have let's do it right above update Define activate attack with self a Target Sprite and the attack and also let me minimize all the other methods so it's easier to see what's going on if that is the case I want to set self. state of the monster to ATT attack on top of that we want to set the frame index to zero that way we ensure we are always playing the attack animation from the beginning also we want to set self. Target undor Sprite to the Target Sprite that way we can reuse it later on and self. current uncore attack is going to be the attack both of these values we have to reuse in just a bit hence we want to store them inside of an attribute and for that to work properly I want to create them as well inside of the dunder init method which means in there I want to have self. Target Sprite none by default and self. current attack which is also none by default that covers this part and the last thing that I want to do is I want self dot monster. reduce energy depending on what attack we are using I.E once the monster has attacked we want to reduce the energy and that happens inside of the monster remember in here we are storing the actual information and for that we will need another method Define reduce underscore energy with an a attack and also we will need self the only thing that we have to do in here is self do energy minus equal the attack data e attack and then the cost of that attack which has to be a string or in other words inside of game data for the attack data we are subtracting this cost from the energy of the monster and that was quite a bit of code let's try main.py I can still select an attack and I can select opponents if I now Target one of them the energy of the monster should decrease once I execute that and it does we now have a bit less energy and the monster is playing an attack animation so that is working but now the game doesn't do anything anymore small steps I suppose we continue we have to work a bit more inside of the monster Sprite and we have to expand the animate method basically what we have to do if the monster is animating we want to apply the attack after an attack animation which means after we are increasing the frame index I want to check if if self. state is equal to a tag on top of that and self frame index is greater or equal to the length of self. frames and a attack so basically with this if statement we are checking if the monster is playing the attack animation and the animation has finished if that is the case we want to actually apply the attack which we cannot do at the moment but what we can do is set this state back to idle that way we are only playing the attack animation once let's try that part if I now attack a monster with a different attack we get an attack animation exactly once so that part is working so how can we actually apply the attack for that part we have a bit of an issue because we want to apply the attack inside of the battle class and there we have follow of the monsters now I guess inside of Sprites we would have the target Sprite that we are getting from activate attack we would have a Target but we also want to have the animations inside of battle really we should have the actual attack logic in there it also makes a whole bunch more sense for that I want to create another method Define apply underscore attack for which we want to have self a Target bright the attack that we want to choose along with the amount of damage for now let's simply print the target Sprite the attack and the amount of damage now this apply attack we have to get into the monster Sprite Which we're going to do when we are creating the monster there we have a monster Sprite Which is going to get one more argument which is apply attack for that to work inside of this class we will need apply a attack as well that we then want to store as an attribute self. apply attack is apply attack that way once the attack animation is finished we can call self. apply attack with the parameters we have just created Target Sprite attack and amount Target Sprite is going to be self. Target Sprite the attack will be self. current attack and then we need an amount for that we have to look at the monster because in there we have the attack damage let's call itself. monster get base uncore damage and for this part we want to know what attack we have selected I.E self. current attack as an argument and then inside of the monster class I want to have theine get base damage with self and an attack the value that we want to return is going to be self. get stat and attack I.E we're getting the attack damage and this we want to multiply with attack data of the attack and then we want to get the amount of damage or healing it does I.E if you look at game data we have the amount this we're going to multiply with the base damage of the monster or in other words self do gets that and attack is what we're getting from up here where we are getting the base set of the monster and multiplying it with the level this we are then going to multiply with the damage of the attack and then inside of Sprites we are applying that amount which means inside of battle we should get a value let's try and we are getting an error that name apply attack is not defined and that happens when we are creating a monster this should be self. apply attack when we are creating the monster Sprite next attempt and now if I choose scratch we get one attack animation and then we are printing the target Sprite the attack and the amount of damage cost or at least the base damage this doesn't include defense or elements yet but at the very least we have something so now we don't need setup or create monster and we can work inside of a Ply attack to cover what we want to do number one we want to play an animation for the attack then we want to get the correct attack damage amount or in other words we want to include the defense of the monster and the element type for example if a fire attack hits a plant then we should double the damage and if a fire attack hits a water monster then we should have the damage next up we want to update the Monster Health and then we want to resume the game and I guess we can go through this step by step number one we want to play an animation for that I want to create an another a Sprite called attack Sprite this we have to create inside of the Sprites I want to have class attack Sprite for parent class this one is going to get the animated Sprite the one we created ages ago this one here because ultimately all that this attack Sprite is going to be is it will plays an animation but this animation it's only going to play once and then disappear or to visualize all of this a bit better if you look at the graphics folder there we have the attacks which contains a couple of animations those we want to play once after the monster has attacked we also need to import them but that's going to come later first of all Define a knit with self a position frames and groups then Super Thunder init where we are initializing the animated Sprite which means we want to have position frames and groups after that we are also going to need a z layer that we are this time getting from the battle layers and on there we want to get the overlay also when we are creating this animated Sprite we are setting the rectangle position to the top left which I don't want to do anymore instead I want to update self. wct and place the center to the position that way we can place the attack right in the middle of the Target Monster after that we need an animate method with self and Delta time in the original Sprite we are simply playing the animation forever which works in the Overworld but for this monster we want to play the animation once and then destroy the Sprite for that we want to get the frame index and increase it by the animation speed multiplied with dat time after that if self. frame index is is smaller than the length of self. frames if that is the case we want to update self. image which is going to be self. frames with the integer of self. frame index no need for modulus because we are already checking if we are inside of the length of the list if that is not the case else we simply want to destroy the Sprite using the kill method and finally we have to call update with self and Delta time and then call animate in there with Delta time and do not forget self that way we have an attack Sprite it's fundamentally a fairly simple class after that inside of battle dop we have to import it so import attack Sprite Which means to apply the attack Sprite I want to get the target Sprite wrecked do center for the position after that we will need the attack frames which we don't have at the moment but we're going to get them in a bit self Doge monster frames they're going to be in that dictionary and there we have the attacks or in other words in just a bit when we are importing the assets inside of the monster frames we're going to add one more key value pair to pick one animation from that we want to get the attack data along with the current attack and then from this entry we get an animation or in other words if you look at the attack data at the end we have an animation finally we going to need the groups all the way at the end self. battle Sprites so that's going to cover the attack Sprite the one thing that we don't have yet are the frames for the attack for that we want to look at main.py and add an attacks key along with a value and for this one I want to create an attack importer for the file path we want to go up a folder then to graphics and then we have the X so next up we have to create one more import method which is going to be Define a techcore importer for which we are only going to need a path then we are going to create a new dictionary for all of the frames that is empty by default after that for folder path the subfolders we don't care about and the image names in walk join and the path unpacked after that for image in image names and then we get all of the image names inside of this folder first of all in there I want to get the image name which is going to be image. split wherever we have a DOT and then we want to pick the first item that way we get rid of PNG at the end and then we can get the attack dictionary and assign a new key value pair the key is going to be the image name the actual value we are going to get from import tile map because once again if I open this thing we have tile Maps each animation is four frames that we want to isolate which means for import tile map we have four columns one row and the path to this folder is going to be the folder path along with the image name this would return another dictionary with key value pairs where the key would be the column and the row and the value would be the actual surface and in this case we are lucky because because we don't care about the keys at all we only want to get the values and all of that we want to turn into a list that is simply because when you look at all of the animations they always in one row hence the position doesn't actually matter and finally I can return the attack dictionary and that should be it if I now run main. pi and I attack a monster we get an attack animation and that is looking really good that took a while but we got there in the end so with that we can play an attack animation and I suppose we should try this a second time with anothera monster let's try this one and let's go with explosion and that's also working pretty well finally one more attempt is going to be not this monster but the second one because in there we have Battle Cry and let's try to heal this monster and that is working also notice for this one we getting a negative amount that means later on we are going to heal so next up we want to get the correct attack damage for that first of all we will need the attack element which we can get from Attack data the attack and then the element for the Target element we want to get the target Sprite in there we have the monster and the monster has the element after that I want to double the attack if the attack element for example is fire and the target element is equal to B that would be one condition if that is the case we want to get the amount and multiply it by two or in other words the damage we're getting from the monster is now twice as strong and well for this part we have to cover the other conditions as well there are only three in total we want to check if attack element is fire and the target element is plant if the attack element is water and the target element is fire and finally if the the attack element is plant and the target element is water if any of these conditions are met then we are doubling the attack damage and the opposite we can do half attack for that let me simply copy the if statements in which we want to multiply the attack damage with 0.5 so for example if the attack element is fire and the taret element is water then the attack is going to be weaker this could also apply if the attack element is water and the target element is plant or if the attack element is planned and the target is fire so with that we are incorporating all of the elements and this system is only going to work if you have very few elements if you have more than that it's going to cause issues but I think for our purposes this is still totally fine although we do not include the defense of the monster or in other words if you look at the game die and monster data all of the monsters have a defense stat this we also have to include the way I Incorporated that one is I have created a Target uncore defense which I want to be a value between zero and one the higher the defense of the monster is the lower of a multiplier we want to have first of all I'm getting the target Sprite do monster doget underscore stat and I want to look at the defense of the monster just to demonstrate what we are getting let me print the target defense if I now run all of this we are getting an unexpected character I think it just doesn't like this slashy speaking of which The Ore shouldn't be there either next attempt main P the game doesn't crash anymore good start and now if I Target a monster we get getting name element not defined things are going great that happens because the element here should be a string next attempt if I now attack again we are getting something these numbers we are getting from these four print statements where the first one is the target defense for this monster it's 20 or in other words the monster we have is going to be this one at Rox at level two and inside of game data if you find at Rox we have a defense of 10 and this we multiply it by two that way we are getting 20 now this 20 I want to turn into a fraction something like 0.8 or 0.9 that if the monster has a very low defense value we want to get 90 something per of the attack damage for that I want to subtract the value from one that way we would get 19 at the moment to fix that I want to divide this value by 2,000 that way this 20 is going to become a really small number and that we are then subtracting from the one let's try this again and if I attack the monster with the same attack we're getting 0.99 since this monster is super weak the defense shouldn't really matter that much however if if we increase the level of the monster to let's say 15 and run all of this again if I now attack the monster this is 0.925 which I think is pretty good now this 2,000 here you can play around with depending on how strong you want the defense to be but that you can do in your own time in my case I want to get the target defense again because we have to make sure that this number doesn't become negative if that was the case and attack would heal the monster which well would be weird for that I want to use max with zero along with Min just to be sure that we stay between one and the target defense with that we have the proper Target defense amount finally with that we can update the target sprite. monster. Health minus equal the amount multiplied with the target defense that should actually be visible in the game if I now run out of this and I attack this monster the only one with health we are reducing the amount of health and now that we have that inside of the monster we don't need the random amount for health and energy anymore if I now run main Pi again we have the full amount for everything and if I attack this monster we are reducing the amount of health so that is working really well although after that nothing is going to happen and we also don't need a print statement anymore instead what we want is to resume the game which we do with self update all monsters and resume so next attempt and I can still attack and after that the game continues so let's try a different monster this one on and it's a low level so it takes a lot of damage but the game itself is working really well I suppose what we should be doing after we are applying the damage I also want to self. check uncore death that's going to be another method and we don't need apply attack anymore but below that we will need Define check death no need for custom parameters and there we want to look at all of the Sprites for Monster Sprite in self. opponent Sprites do Sprites plus self. layer Sprites do Sprites we know a monster is that if Monster sprite. monster. Health is below zero after that we want to separate the opponent monsters from the player monsters which we can check if self. player Sprites in monsters Sprites dog groups once again player Sprites is the Sprite for all of the player monsters if that is in any of the groups of the currently selected monster Sprite then we know we are on the player side let me at a comment player now this case we want to ignore for now so let me add a pass in here what we care about are the opponent monsters which are going to live inside of the El's statement but now what we can do is simply monster Sprite do kill although that is not going to work perfectly yet but let's try if I attack this monster and attack it a second time okay needs a third attempt there we go now it disappears but well there's lots of stuff missing let's go through it one by one when we are checking death we already know if the monster is below zero in terms of health so we know if the monster is supposed to be dead or not and if that is the case we want to create a new monster that way once we are killing a monster we are replacing it but only if there's a monster so for example for the dummy monsters we can only see these three monsters so if one is selected we should select the next available one but that we can cover later also later on I want to implement an XP mechanic but that we can ignore for now and there's another issue and that is when you look at Sprites once monster Sprite has been defeated we can still see monster name Sprite monster level Sprite and monster stat Sprite Which obviously is not what we want to fix that let's start with monster named Sprite this one is going to need an update method with self and Delta time we can ignore so underscore we basically want to check if this monster Sprite has been killed or not or rather in terms of monster Sprite we want to know if this monster Sprite is still around now what you have to be aware of when we are calling the kill method on a Sprite we don't actually destroy the Sprite instead what we do is we are removing it from all of the groups that way it doesn't really do anything anymore that behavior we can use because inside of update we want to check if not self. moners sprite. groups sprite. groups is going to give you all of the groups inside of a Sprite if the Sprite isn't any groups this will give you an empty list which would trigger this if statement if that is the case we want to call self. kill the same logic we want to apply to all of the other Sprites as well which means inside of monster level Sprite let's do it all the way at the bottom I want to check for death and then finally inside of the update method of the stat Sprite I also want to check for the same condition there we go and make sure you don't accidentally put this if statement inside of this is for Loop cool with that we have the monster stat Sprite the monster level Sprite and the monster name Sprite now we should also put the same thing inside of monster outline Sprite just so we don't have some random Sprites in the game with that I can now run main.py again and if I attack with the splash attack this monster it's fire it should disappear and there we go now we have gotten rid of the monster entirely also if I now select one of the other monsters we are getting the proper selection behavior that is because of the logic we implemented earlier that part is working pretty good cool so next up I want to check if we have a new monster which I will store in a variable new monster data this is going to be a tupal that has a monster it has an index a position index along with a site or rather an entity so player or opponent although for that to work we need to do a bit of groundwork when you're looking at the dummy monsters we have five monsters in total and three are on the battlefield if one of them dies let's say this one goes away we want to replace it with the first available monster in this case jakana with level two in other words the first thing that we need is to isolate these two monsters or in other words words what I actually did when we are running the setup method we are creating all of the monsters but on top of that I want to remove the opponent monster data since the opponent can't really change monsters once a monster is on field that monster will get deleted from the monster data or in other words I want to look at for I in range length and self do opponent Sprites let me print what we get I if I now run M Pi we getting the indexes 0 one and two using those indexes I want to delete self. monster data with the opponent and then using the index as a consequence after we are setting everything up I want to print self. monster data with the opponent and now inside of main. Pi we are only getting monster three and monster 4 and then if one of the Monsters has been defeated we want to pick the first one and store it inside of monster data in other words I want to get self. monster data with the opponent and from that I only care about the values all of that we want to turn into a list and then pick the first one to get the index and the position index I simply want to get the monster unor Sprite that was defeated and then get their index and position index which we are already storing in there finally The Entity since we know that this El statement is only triggering for the opponents this one is always going to be opponent there's one more thing that we have to do all the way at the end we only want to run this entire line if self. monster data and opponent doeses exist if it does not else we should get none for this value or in other words we only want to get a new monster if there are any values left inside of the Dummy monster dictionary or whatever dictionary we have for the opponent now that we have a new monster we also have to make sure that we getting rid of this monster from the monster data dictionary for that I want to check if self. monster data with the opp opponent and if that is the case I want to delete self. monster data of the opponent and I always want to get rid of the lowest key I.E minimum self Doge monster data and the opponent that way we can get a new monster and remove the previous one so with that we have to create a new monster after we have killed the current one but there's one more thing that I want to do I don't want to kill the monster immediately because it looks a bit weird let me run main. Pi again if we kill a monster let's say this one it is a appears way too fast which doesn't look good so instead of killing the monster right away I want to call monster sprite. delayed uncore Hill and then pass in the new monster data also really important this delayed kill is going to apply to the player and the opponent monster hence it shouldn't be inside of this if statement but it should be inside of this if statement to check if the health is below zero so I have to indent it one more time although the XP comment does need to be inside of the El statement like so now we have to figure out a delayed kill method inside of the monster Sprite I want to minimize all of the methods and then create fine delate kill with self and a new monster there are two things we want to do in here first of all self dot let's call this one the next Monster data which is going to be the new monster after that we want to start a timer that we are getting from Thunder in knit that we already have a remove highlight timer besides that I want to have a kill timer which is going to be a timer with a duration that I have set to 600 the function we want to call once it times out is self do destroy inside of delay kill self. timers with kill and activate on top of that I want to make sure that we don't accidentally call this one multiple times which we can do with if not self do timers the kill timer and active I.E we only want to run out of this if the kill timer currently is not active uh after that Define destroy no need for custom parameters all we really want to do in here is to call the kill method and on top of that if self. nextt monster data then we want to self. create a monster which is the method that we have inside of the battle class create monster for this one we're going to need monster index position position index and entity which coincidentally are the same methods that we have inside of the new monster and there we have a monster index position index and the entity which means to create this monster we simply have to unpack self. next Monster data although before that we have to get create monster into the monster Sprite Which we can do via another parameter create monster and don't forget to St it as an attribute self. creat monster is create monster also when you are creating a new monster inside of the monster Sprite we have to add self. create monster that should actually be it if I now run main.py and I kill the second monster it disappears and after a while we're getting a new monster we can defeat that one as well and some point we should run out of enemies oh well we're getting list index out of range but we're getting something now to fix this error we want to look at groups and then work inside of this if statement in which we are checking for the outlines the second part of that if statement this line is causing the issue and to fix it we want to add a bit more sprite. Monster sprite. entity is equal to the site that way we are checking if we are on the player or the opponent side on top of that I want to check if mode exists and if mode is equal to Target that way we have quite a bit more so now let's try to run the game again it doesn't crash and if I get rid of enemies they still disappear and it doesn't seem like we are crashing anymore although now an opponent is active so we can't do anything anymore so that we can work on next now for the monster attacks we want to work inside of the battle class let me collapse everything and then look at check active at the moment we only do something if the player monster is ready however if the opponent monster is ready at the moment we simply stop the game and this we want to extend via an El's statement I want to get self. timers with let's call this one opponent delay and that timer I want to activate if this is the timeline of the battle at some point one of the opponents can attack but that I don't want to happen right away instead I want to highlight this monster for let's say around half a second and only after that I we going to trigger the attack because of that we have a timer that is going to trigger after 600 milliseconds and before that we are highlighting this opponent monster so the player is aware that there is going to be an attack that being said though timer doesn't exist inside of the battle class at the moment or at least I don't think it does no it doesn't let's create it all the way at the top I want to have some timers self. timers it's going to be a dictionary and the timer that we have just created is called opponent delay the associated value will be a timer with a duration of 600 and the function we want to trigger once it times out is self. opponent uncore attack although I think we also have to import from timer the timer class so right at the end of the battle system I want to have Define opponent attack there are three things that we want to do in this method we want to get the ability of the monster then we want to get a random underscore Target and finally we want to get self. current monster and then activate attack with the random Target and the ability and as a reminder activate attack is what we already have inside of of the monster Sprite so somewhere in there we have activate attack that way we are reusing the logic from the player monsters which is quite handy although before we are going to work on that there's one more thing that I do want to do inside of the main section and that is going to be update timers all we are going to do in there is for timer inself do timers do values and then timer. update as a reminder for all of the timers that we have at the moment it's only one but there are going to be more we have to call the update method on every single timer otherwise nothing is going to happen that we can do via a method and that method we have to call inside of the update method let's do it right after the input self. update timers with that we can get the ability and the random Target after that we should have a monster attack from the opponent that part will be your exercise I want you guys to get the opponent monster ability and the target pause the video now and see if you can figure this one out for the ability I want to get self. current monster do monster and then get underscore abilities and from that I want to get a random value which I get via choice that we have to import via from random import choice that would give us the ability and let's simply try for now if this is working at all meaning I want to print the ability and then inside of main.py in the dunder init method the first Monster can get a level of 50 so it gets ready really fast let's try and there we are getting one of the abilities let's try it again we should get a different attack and we do that looks good after that we will need the random Target for this one we do have to be a bit careful because if you look at attack data and let me minimize everything if we get an attack like burn or spark or scratch we now want to Target the player whereas if we have heal or battlecry we want to Target our own team the naming here isn't ideal but I hope you get the idea I want to first of all get the side which we get from Attack data we're using the ability to pick the data and after that we want to get the Target and once we have that we can check if side is equal to layer then we want to get a random Target of our own team meaning random Target will be choice of self. opponent Sprites do Sprites and else we want to get a random Target that will be choice of self. layer Sprites do Sprites that way we're getting a random Target let's print it random Target and run all of this again we are getting a monster Sprite in two Sprites okay that wasn't particularly helpful we could instead print random target. monster that should be better and now we're getting a monster which is friolera level 29 one of our monsters and just to test the other side inside of game data for the monster data when we are looking at atro this one we can change its abilities to only be able to heal that way if I now run m not P again and this thing is running we are getting monster gfin level five so that is also working although this I don't actually want to do with that I can get rid of the print statement and I think five lines for something so simple isn't really necessary so let's reorganize this a bit I want to assign the random Target to the opponent Sprites but only if attack data ability and the target is equal to player if that is not the case else we want to assign a random value from from the player Sprites and if you have a bit more space this is also still readable but well the same logic applies finally we can get self. Corin monster. activate attack with a random Target and an ability let's try that and we're getting attack and something happens and now I can do something as well and things are coming together and with that we getting to the next eror where we don't have a new monster data that happens because when we are checking the death and one of our Monsters has died because when the player monster dies nothing is really specified yet that we do have to work on for that we want to get all of the active monsters which needs to be in a list where we have an index and the monster that we can get via list comprehension I want to get a monster Sprite for monster Sprite in self. player Sprites do Sprites that being said I don't want to get the monster Sprite itself I want to get a tuple with monsters sprite. index and monsters sprite. monster I suppose remember for new monster data we want to get the actual monster and the index and that's what we are getting in here after that we also need to know the available monster ERS which is going to be another list comprehension where we getting a tupal with an index and a monster that we can get quite easily because we can do for index and monster in self. Monster data of the player and from that we want to get all of the items however there are a few conditions that apply here which means if moner do health is greater than zero I.E we don't want to place a dead monster and we want to check if index and monster is not in active monsters or in other words we don't want to pick a monster that's already on the field once we have all of that we can create new monster data for that we can use list comprehension a third time and I want to create a tupo with a monster the index the position index and then the entity I.E the player to get that I want to use for index and monster in available monsters I.E we are looking at all of the available monsters and then we are reorganizing the data monster we can keep index we can also keep although for the position index we want to have have the current monster uncore Sprite and then get the position index from that one now this would give us a list and we only care about the first value I.E index zero however this I only want to do if we have available monsters in the first place I.E if available Monsters has any kind of value then we want to create a new monster data if that is not the case else new monster data is simply going to be none let's try that and if I now Run the game we can get attacked so let me defend and at some point one monster should die and we get another monster that looks pretty good also if I destroy one of the opponent monsters they also get a new one so that is looking pretty good cool with that in place we can work on the XP mechanic meaning if we defeat one of the opponents we're getting some XP for that first of all we have to figure out the XP amount which we can get from the current monster Sprite do monster. level and I simply multiply this with 100 and this value I want to spread equally across all of our player monsters that are currently on the battlefield I.E divide by the length of self. player Sprites and after we have that I can simply do for player Sprite in self. player Sprites layers sprite. monster and then update XP with the XP amount this method does not exist inside of the monster which means in the monster I want to minimize everything and then create a new method Define update XP with self and an amount in the most basic sense all that we want to do in here is self. XP plus equal the amount and I think we already have XP yeah we do so and there at the moment we only have a random value but this one by default should be zero and let's try all of that if I run the game and we defeat one of the opponents all of our monsters get a bit of XP this might be hard to see but if you look at a black bar now we get a very small amount if I defeat another opponent this might be more visible there we go if you look for it you can definitely see it so that part is working and also I want to set the level of at Roos back to something like 10 so the game runs a bit faster after that I want to expand the update XP method to incorporate a level up the way I approach that is I first of all check if self. level up minus self. XP is greater than the amount if that is the case we simply want to add the XP to the amount and nothing else is going to happen we are not going to level up however if that is not the case else then we know via the current XP amount we are going to reach the next level which means self. level plus equal 1 on top of that we have to increase self. level up which is simply going to be self. level multiplied with 150 and finally we want to retain some of the XP self. XP or in other words for a monster to level up let's say we need 200 XP and at the moment the monster is at 150 and then gains 100 additional XP we are going to level up at XP 200 but then we also want to retain the XP that are overshooting which we can get via the amount minus self. LEL up and minus self. XP and that part is going to be a bit difficult to visualize but but let's see how far we get so I want to defeat some opponents and you can see for Lavia at the bottom this should happen fairly soon let's defeat this one and we are nearly at the level up let's defeat this one and there we go Lavia leveled up that's a good start but we don't get any more XP and we get list index out of range so two things that we have to cover number one the XP mechanic for that in side of the monster we have to change XP before we are updating level up that way if I run main. pi and let's kill this one then we can kill this one we are very close to a level up okay bit more I guess we can defeat this one and then and there we go Lavia l up and we retain the extra XP although now if I defeat the other enemy we're getting an error message that we have list index out of range and that happens for two reasons number one inside of the groups we're getting an error because inside of the Sprites the ones that we have created here we have no content or actually there are two possible cases where this could go wrong number one is when there are no more enemy monsters this value is empty so any indexing operation would give us an error that is an issue we can fix right away simply by adding if Sprites and if that is not the case none so in other words we only do all of this if there are any Sprites left whatsoever and that is going to do something but there's still another issue and that is if I only destroy the middle enemy so let me always Target the one in the middle like so at some point Point once we run out of monsters we're going to get an error that is list index out of range in this same line that error happens inside of battle. Pi when we are updating the target index basically the way you have to think about it is that when we have three enemies and we're getting rid of one of them we have to update the index as well otherwise we're getting this eror here where we are trying to get a number too large for the list the way I have approached that inside of input all the way at the bottom after we have gotten the last General I want to set all of the indexes back to zero I.E we are doing let me minimize this we are checking for all of the different inputs and then we are setting self. indexes 2 K and zero 4K inself do indexes so other words we are taking this dictionary we are copying all of the keys and then for the value we always have a zero that way after we have done any kind of input and we go to the next monster we start again from scratch oh also this indexes we only want to trigger when we are pressing space let's try all of that and I'm going to start by always attacking the middle monster cuz that earlier caused the most issues however I also want to has to pay attention to when I'm selecting one of these attacks earlier we always kept the same index if I select the fourth item or the one with index three Ander us it when we selected the next monster we got the same index but now we always start at the top which fits much cleaner so let me oh that was the wrong monster but this seems to be working reasonably well so for the final one disappears and there we go now we can't really do anything anymore and we're getting an error but that doesn't really matter once we get to this case we want to end the battle anyway although that is going to come later first of all though I can minimize the input and the dander in nit method and then work on the next part which actually happens inside of input because in there we currently can attack a monster but we cannot catch one so that we have to account for as well to explain that mechanic let me run the game again and essentially once a monster is ready I want to select the Target Monster and then at the moment we are only printing catch so that doesn't do anything which means inside of battle once we get to catch we want to do more than just print catch I want to set self. selection mode to Target and self. selection s should be the opponent that should already do quite a bit if I now Run the game and I go to catch we can select one of the opponent monsters although if I press space we don't really do anything and for that we're going to need this El statement so basically at the moment we are in selection mode Target but we do not have a selected attack and in there I basically want to check if monster sprite. monster and health is below 10% of the max Health which we can get via monstore sprite. monster and get Stat maxcore Health and that we can multiply with 0.1 or whatever number you think works well if that is the case I want to update self. monster data with the layer and then add add a new index and assign the monster the monster we can get from monster sprite. monster and the index is simply going to be the next number or in other words at the moment we have 11 monsters meaning the next index should be 11 to get that inside of the monster I simply want to get the length of self. monster data of the player on top of that I want to get the monster Sprite and run the delayed kill method with none that way the monster disappears after a few milliseconds and finally we have to self. update all monsters and resume the game if that is not the case else we want to do something else but for now I simply want to print cannot catch monster let's try all of this first and while we are testing things I want to set the catch rate to let's say below 90% that's going to make things much easier to test if I now run main. pi and I attack one of the stronger monsters that should be good and now if I catch this one it disappears and if I switch the monsters all the way at the bottom we should have enough a monster that looks good although if I press space nothing is going to happen at the moment so that we do have to work on but step by step first of all this is working next up though if the player tries to catch a monster with too much health then I want to create a timed Sprite or in other words I want to display a Sprite for a very short amount of time now the image that I want to display is going to be inside of Graphics in UI there we have a cross if the player tries to catch a monster with too much health I want to display this cross over the monster for a short period of time and for that we are going to use the time Sprite in terms of arguments I want to have a center position I want to have a frame or rather a surface since this one isn't animated then we will need a groups and a duration argument none of these are terribly difficult for the center position I want to get the monster sprite. wct do Center this surface I want to use we already have self. battles Sprites in there we have UI Sprites and this one contains a cross this is already imported for the groups I simply want to have self. battles Sprites and the duration could be let's say 1,000 milliseconds or 1 second with that we can create a Time Sprite although before we do that I want to import it right away with that inside side of the Sprites I want to create another class time Sprite and the parent class for this one is going to be a Sprite after that I'm going to call Define thunder in knit with self a position surface groups and duration I want to call this super Dunder init method and as a reminder we are going to initialize this init method which means we need these parameters where we have position already covered surface covered groups covered and the one more thing that we need is the Z parameter for which we are going to use our batt layers and this one should always be on overlay after that we do have to update self. rect do Center which should be the position and that's the same issue we have already seen with the attack Sprite we have done the same thing in there so essentially for the original Sprite and animated Sprite we have a rectangle and via the position we are placing the top left which is not what we want to do for the attack Sprite and the time Sprite we always want to place the center which we achieve via these lines on top of that for the time Sprite we will need a self. Deathcore timer which will be a timer with the duration that we getting from the parameter all the way up there I want to set auto start to true and then the function I want to call once it triggers is going to be self. kill the inbuilt function of any Sprite and after we have that I simply want to call update with self and Delta time although Delta time we don't actually need so an underscore here is totally fine and then self. death timer. update is all we need and that should be it if I now try main. pi and I try to catch a monster with full health we are getting an error because battle Sprites object is not subscriptable let's have a look I think that happened when we are creating the time Sprite so there we have the error and I can see it already we want to get the graphic not from Battle Sprites but from monster frames this one actually contains the graphics next attempt and now if I try to catch a monster we are getting the error symbol message thingy that's working reasonably well that covers catching a monster and I am going to leave it at 0.9 for now although later on this one should be switched back perfect we are making progress so with that we have covered quite a few states there are two more the next one if self do selection mode is equal to switch I.E we are trying to switch the monsters if that is the case I want to get an index and a new monster which I can get from the list self. available monsters. items don't forget to call this one and then use indexing with self. indexes and the switch Also let's print index and new monster just to make sure we have something to look at if I now run main.py and I try to switch a monster let's go with this one we can see the monster we have selected is four and spu we can try another one that still looks pretty good let's this one as well so yep that seems to be working quite well which means at this point we simply want to get the current monster and kill it that way we're getting rid of the Sprite and next up we can create a new monster with the new monster that we have just gotten then we want to have the index and self. corn monster do position index and you might be wondering why can we still access this corn monster even though we have just killed it the reason for that is that killing a Sprite doesn't actually destroy the Sprite it simply removes it from all of the groups that way you can still access all of the attributes which is super handy the last thing we are then going to need is the entity or the site of the monster which is always going to be player for this one after that I want to get self. selection mode and set it to none and then self. update all monsters and resume things that should be all we need in here if I now run main. Pi I can select another monster let's go with this one and we get another monster also if I now try to attack another monster and then try to catch it that part still works and now if I try to switch monsters with the one we have just C that part also works just fine so that is looking pretty good so with that we have covered all of the major States but there's one that we haven't covered yet inside of selection mode General index one this is telling a monster to defend and at the moment this doesn't really do anything to fix that before we are doing anything else inside of the if statement self. current monster do monster and then defending is going to be true that we can then use when we are applying an attack we are already calculating the damage mechanic in quite some detail here and essentially after we are calculating the target defense I want to check if Target Sprite Dot Monster dot defending if that is the case then Target defense is going to be Reduce by 0.2 oh and also we should create this defending attribute inside of the monster in the DED method let's do it under stats we want to have self. defending which by default is going to be false on top of that after the monster gets ready again we want to disable this defending attribute which means when we checking for active and one of the monsters does get ready then we also want to set monster sprite. monster. defending to bols although this part is now very difficult to visualize because we have to wait for the other monsters to attack us let me just always choose defend and let's hope we get the right monster to be attacked and well they always attack the weakest one at the moment and there we go rolera got attacked and the damage is actually really low although that might not mean very much but well basically inside of a Ply attack we know that this number is going to update so play around with it if you want to change the numbers but I am fairly confident that it works reasonably well righty with that we have apply attack which means there's just one more thing that I want to do in this section and that is for the battle system I want to check end of the battle so we know when either the opponent or the player has been defeated for that we donate custom parameters and then we have to check two conditions number one is opponents have been defeated and number two his player has been defeated I suppose we could start with the player because that part is a bit easier all we really want to check is if length of self and player Sprites and if that number is equal to zero and just to test that for now let's print game over after that inside of the update method I want to check self. check and battle and I guess this we should be doing before we are doing anything else that should be a bit safer righty now to test this one inside of main.py when we are creating the monster the player shouldn't have three monsters with level 100 although for the opponent monsters I want to have three monsters with a level of 100 and just so we don't have to wait for too long let me comment out most of the monsters and let's try this again and now we should be losing pretty quickly simply because the opponents are way stronger so there we losing one monster there another monster and we should be gone well this has nearly worked we are getting game over but after that we are getting an error message that we cannot choose from an empty sequence which is okay this line is not going to run anymore but basically what happened is when we are checking the opponent attack we cannot pick a random Target anymore simply because there are no player monsters left but that's okay because we're not going to get to this line so instead we want to run py game. quit and exit and since we are importing py game and sis inside of settings these two lines should work pretty well let's try to run out of this again and we should be defeated pretty quickly cool and the game just ends so we are good to go this covers one part next up we have to work on the opponents which is going to work in a fairly similar fashion I want to check if the length of self. opponent Sprites is equal to zero if that is the case I simply want to print battle one on top of that I want to get for monster in self. Monster data and the layer monsters so dot values and then reset all of the Monster initiatives I.E monster. initiative is going to be zero that way when the next battle starts we don't have some random value already but that should be it if I now go back to main.py and for the opponents I want to have more reasonable levels let's say five six and seven and now we can try this again and if I just defeat them randomly I use the proper attack type but you get the idea and there we go all of the opponents have disappeared and we get Battle one although this we get many many times which might cause an issue down the line to account for that I want to add and not self. battle over and then once this if statement triggers I want to set battle over to through on top of that in the dunder init method I want to create another attribute self. battle over which by default is going to be false that way and let me comment out most of the monsters we should only see battle over once which is going to be much safer and there we go we have won the battle and everything still works just fine perfect so with that we have basically all of the battle logic there's just one minor final thing that I want to cover and that is when a monster gets defeated you can see something like minus 50 Health which is kind of a cool effect and if you want to keep it just skip this part but I want to limit the lowest Health to zero and for that inside of the monster let me minimize everything I want to insert a stat limiter in which we are setting self. health and self. energy and basically for both what we are going to do we're going to make sure that we have a max value of either zero or a Min value of self. health and self. getet Stat with maxcore health or another words we first get the larger value between zero and the smaller value between self. health and self. Max Health that way self. Health can never go beyond the max health or below zero and the same thing we want to do for energy so let me copy all of this the only change that we have to make is this needs to be self. energy and the max value should be Max Energy after that we have to make sure that we are calling the stat limiter that's going to happen inside of the update method you can put it basically wherever you want self. stat limiter and with that if I now run m p again and let me try to hit I have a monster with water attack so we do lots of damage and we always keep it at zero so that looks pretty good perfect and with that we have finished the battle system now later on we have to add some sounds but that's a fairly minor part what is much more important for now is to connect the battle system to the Overworld which will be the next part I'll see you there so with the Overworld and the battle system in place we have to connect the two and that's going to be the last major part that we have to work on although on top of that there are a few more minor things that I also want to cover most importantly in there we have the evolution system so if a monster Hits a certain level we want to switch it to another monster besides that for the characters I want to have a nurse that heals all of the player monsters and finally I want to add all of the sounds that part should be fairly straightforward once we have covered all of that we have the entirety of the game so let's Jump Right In and get started with the easiest part the nurse system so here we are back in the code and I have cleaned up the tabs a bit the python files that we will need are main.py entities. Pi battle. Pi along with support pi and game data although the first three are the most important ones and to get started I want to implement a nurse so that when the player goes to a hospital we can get healed for that when we are creating the characters that happens in there in the setup method I want to add one more argument which is going to be nurse the value for this is going to be a Boolean and basically what I want to check is or bj. properties and then we have a character uncore id if that value is equal to this string nurse then we know we have a nurse now to understand what that means in TI we have to find a nurse in the Overworld we don't have a nurse but if you go to hospital. TMX we have one nurse here and there you can see character id is nurse that is what we we are looking for also this nurse should be a bit further down so the player can actually reach it oh and by the way while we are here inside of world TMX the player shouldn't be in the top left he should rather be further down here with that we know if a character is a nurse or not which means next up we want to work inside of the character class first of all we have to give this one another parameter nurse and then inside of Thunder init turn this into an attribute self do nurse is going to be nurse that's all we need in here next up we want to work inside of main.py more specifically in and dialogue at the moment we are only getting rid of the dialogue tree and then unblocking the player not very much so far and in this section we're going to expand this method quite a bit first of all I want to check if character. nurse and if that happens to be I want to cycle through all of the player monsters I.E for Monster inself dopler monsters. values and then set monster. Health to monster getor stat with the maxcore health that way we are setting Health to the maximum value and the same thing we want to do for the energy except now we want to set it to max energy that way we are healing all of the monsters and only after that is the case do I want to unblock the player and with that we have the nurse now to test this inside of thunder in knit I want to comment out battle but we will need the attribute self. battle although it should be by now keep the instant sync of this battle class we are going to need it in just a second and it's going to save you some writing anyway if I now run main. Pi we are not getting an error and if I go to the hospital I can talk to a nurse and we are getting our monsters have been healed now this isn't really something we can observe right now because our monsters have the full amount of Health but what we can do after we created all of the monsters for Monster inself dopler monsters. values monster. Health multiply equal 0.5 that way if I run the game again we get 50% health for all of the monsters so now if we go to a hospital and get healed all of the monsters have the full amount of health so that is working really well with that we don't need this for Loop anymore and we have covered one part now we have a nurse after that if the character we are talking to is not a nurse so L if and we want to check not character do character data and then we want to check for defeated or in other words when we are finishing a dialogue we want to check if the character we talk to is a trainer that hasn't been defeated if that is the case we want to start a battle although for now let's simply print start battle if I run the code and talk to a character we should be getting start battle in the bottom left and we do that is looking pretty good which means if this is the case we actually want to create one instance of the battle class which we can do by copying the values that we have created earlier and then we don't need thiss after battle anymore we want to create a battle class and I think all of this should happen over multiple lines so it's a bit easier to read we have the player monsters then we have the opponent monsters next up we have the monster underscore frames we are getting a BG surface and finally I think this one is simply called the fonts so with that we are creating one instance of the battle class and there's one thing we already have to change we want to get for the opponent Monsters the actual Monsters of this trainer and I should actually do a reminder if we're looking at the entities and the character there are two data points we are working with at the moment the first one is this character data defeated this can find inside of the character in character data but ultimately what we are referencing is inside of game data there we have the trainer data and this one contains the defeated key value Pair by default all of these values are faults but once the trainer has been defeated we are going to set this to True besides that all of the trainers have some monsters those we have to get into the character which means for the character I want to create another attribute self do monsters which is going to be a dictionary comprehension where we want to have an index and then a monster all of the data is going to come from for I and data in character data and we want to get the monsters and from that we want to get the items if you look at game data monsters is simply a dictionary where we have the index of the monster and then the monster along with the level that we want to convert to an actual index with the monster class for that we want to call the monster class and then pass in the monster name and the monster level that we can make quite explicit because data right now is a tuple with the monster name and the monster level which are the two points of data we want to pass into monster so name and level that should be it for this part although if I run main. pip we are going to get an error that we have a name error monster is not defined that happens because some trainers do not have monsters because they are nurses so if I go down a bit further at some point there should be a nurse and the nurse obviously doesn't have monsters to account for that when we are creating the monsters I want to check that we are only creating this dictionary if there are monsters in the character data if that is not the case else we want to attach none to this value so we now run the entire thing we are getting the same error and I just realized I made a mistake when I talked about this error that monsters is not inside of character data this would have been the next step the actual error that we have gotten is that this monster class doesn't exist inside of this python file at the moment which we can change quite easily from Monster import monster and now if we try off this again there we go now this all works just fine that means next up when we are creating a battle class for the opponent monsters we can get the character and the Monsters besides that we also have to cover the background surface at the moment we are always using the forest but that we can make more flexible by using character do character data and in there if you look at game data we have a biome I want to use that is all we need to get started if we now store this instance in self. battle and Run the game and we are getting to a fight we can also still attack and everything is working just fine so definitely doing some progress but obviously there's no way for us to leave this window which isn't ideal also I want to have a transition from the Overworld to the battle at the moment we are switching a bit too abruptly as a consequence instead of assigning battle to the attribute right away I want to set battle to the transition Target and after we have done that set self. tint mode to H now this is a system we have implemented way earlier when we have switched between different levels so this tint screen is what we're going to work in essentially what we are going to check is if the tint progress is greater than 255 meaning we are covering the entire window after that we want to check if type of self. transition Target if that is equal to the battle class then we know we want to create self. battle and set it to self. transition Target meaning now we are setting battle and getting all of this while we are here we can also set an L if statement self. transition Target is equal to level then self. battle is simply going to be none so this would be the other way around where we are going from a battle to the Overworld which simply means that we want to set battle To None finally if nether of those are the case else then we want to run the setup method to create another level and that's all we need to get started with this part so if I now talk to a trainer again we should have a nicer transition and that is looking much better the rest still works just fine cool so with that we can get from the Overworld to a battle but how can we get back for that we will need another method that I have called endore battle besides self we will need a character parameter in this method I want to get self. transition Target and set it to level then I want to set self. tint mode and tint the screen and and then check if we have a character in which case we want to set character do character data defe and this one should now be true on top of that self. create dialogue with this character or in other words once the battle ends which means inside of the battle class we are going to call check and battle so on there instead of printing battle one we want to call this end battle method and then check if we have a character if that's the case we want to set this character to defeated and then display the defeated dialogue that's all we need for now so next up we have to make sure that this end battle is inside of the battle class or rather when we are creating an instance of this class we have access to this method which we can do via another parameter I want to add endore battle the value is going to be self. endore battle that means inside of battle. Pi we have to add one more parameter _ battle and turn all of that into an attribute self. end battle is going to be end battle on top of that when we go down a bit instead of printing battle one I want to call Self Dot and battle and now we have to get the character in there which we also going to do via a parameter so we want to have a character or a trainer doesn't really matter what you call it for that we have to once again work inside of main. Pi and then add another named argument we want to have a character that part is really easy because we already get the character so that we have to pass in there character and then we are good to go although we do have to store that as an attribute as well self. character is going to be character so quite a bit more data but now when we are checking for the end of the battle we can call self. end battle and pass through self. character which means we are calling this and battle we are setting the transition Target to level then tint mode to tint and we are creating a new dialogue after that we are going to tint screen we are tinting everything so things are going to Black and once we are reaching the full value so 255 we get to this if statement and we know that transition Target is level which means by the end of it battle is going to be none let's try if I now let's talk to this character I think it's a bit easier to defeat so we should netive transition that looks good and now if I defeat the monsters really quick there we go we get a transition we get a dialogue and that is working really well although afterwards we are not able to walk anymore but we are making progress first of all then once the battle is over and we are ending the dialogue we have to unlock the player which we can do via an l statement self. player. unlock that should be all we need next attempt okay we are making progress and I can walk around perfectly fine again and now if I talk to this character again we are always getting the defeated dialogue perfect that is working quite well so next up we need to system that if the player walks in t grass we want to have random monster encounters or in other words there should be a random Tim that if we are in to grass after some random period of time we should be attacked imagine that this is the timeline of the game and our player currently is here meaning a random amount of time has passed this specific number doesn't really matter what we want to check is if the player has touched some grass then we want to create a timer that runs for a short amount of time and if this timer runs out and the player is still in Tall Grass then we want to start a fight which means we have to do two things number one once the player gets into Tall Grass we want to start a timer and after this timer is finished if we are still in Tall Grass then we want to start a battle I have organized all of that via two methods let's put all of that in a separate section monster and counters first of all I have Define check underscore let's Call it Monster no need for custom parameters and we basically want to check if the hitbox of the player is inside of any of the grass patches for that first of all we need to know where all of the Monster grass patches are meaning we have to create another Sprite group self. monstore Sprites a better name here might be grass patch or something like that but I think you get the idea now now we have monster Sprites that means next up when we are creating the entire level we want to check for all of the grass patches those they should be inside of all Sprites and they should be inside of self. monster Sprites that way we always know where all of them are that's a good start so next up when we are checking for the monsters we want to check if the list comprehension Sprite for sprite in. monster Sprites I.E we are getting all of the Monster Sprites but we only want to get the ones that are colliding with the player hitbox I.E sprite. w. cidere with self. player. hitbox on top of that I want to check and not self. battle and self do player. Direction so in other words we are checking three things if the player is colliding with tall grass if there's not currently a battle and if the player is moving I think all of them are fairly straightforward if that is the case I want to start a timer let's call this one self. encounter timer this is what I want to activate also want to make sure this timer is not currently running which we can do with another by if statement if not self. encounter timer. active only if that is not the case do we want to start the timer now this timer doesn't exist at the moment which means inside of Thunder init all the way at the top I want to create the encounter timer which will be a timer with a duration of 2,000 for now and if this thing times out I want to call a function which is going to be self monstore encounter this method does not exist at the moment and we'll create it in just a second first of all though we have to from timer import timer cool next up we can call this timer and besides that we will need Define monster uncore encounter no need for custom parameters and for now let's simply print monster and counter now before we can test all of this there's one more thing that you shouldn't forget and that is we have to update the timer that's going to happen inside of the update method before we are doing anything else self. encounter timer. update on top of that what you shouldn't forget inside of update self. check monster I.E we are calling this method with that if I run everything and we are touching grass after some time we should should get monster encounter at the moment this happens every 2 seconds so that is looking reasonably well that means check monster is working we are not going to need it anymore but we do have to write some logic inside of monster encounter first of all we want to check the collisions again which we are doing via Sprites and another list comprehension Sprite for sprite in self. Monster Sprites but only if sprite. w. collide cor with self. player. hitbox the same thing we have done inside of check monster basically dless comprehension although now we want to check if we have some Sprites and self. player. Direction which means we know that this method is only going to be called once the timer is timed out meaning we know that the player has been moving in grass for 2 seconds after this timer we want to check if the player is still in grass and if the player is moving if that is the case I want to set self. player do block and create a new self. transition Target which will be another instance of the battle class and for the arguments for this one just to get started we can look at the transition Target for the character and paste it in there although we will have to make some changes the two AR arents we have to customize are the monsters and the background to get both we have to look at tiled and specifically we want to look at the monster layer because in there and let me hide everything else we get all of the Monster encounter patches and if you look at one of them we're getting a biome a level and the Monsters notice here that the monsters are simply a string with comma separated values tile doesn't allow you to have a list which is a bit annoying but we can work with it so what we want to do is get all of this into P game and then create custom monsters and access the background surface and for that actually we do have to work inside of the Sprites if you scroll down a bit there we have a monster patch Sprite Which at the moment doesn't do very much and adding all of the details and then creating a battle once we are in tall grass is going to be your exercise there are two two parts to the exercise number one I want you guys to import the tile data into the monster patch Sprite you will need a level a biome and a monster names after that once the play is on top of one of those patches use the data to start a battle should be reasonably doable pause the video now and see how far you get first of all we have to work inside of setup and then work a bit more with the grass Patches at the moment we are looping over the layer of the monsters and then create a monster patch Sprite in there we are actually already passing in the biome which should give you a hint of how we can access the other data you can simply copy obj properties because we also want to have the monsters and then the level once we have that inside of Sprites we will need after biome the monster and the level and for now let's simply print what we get I want to print monsters and I want to print the level let's try out of that we are getting the names of the monsters and the average level so that is looking pretty good although that data we have to organize a bit better which means inside of the Sprites I first off I want to create self. biome which're is a biome we are already getting we want to store to monsters but this should be a list which I can get with monsters do split and then split this string wherever we have a period and finally self. level is simply going to be level just to make sure that all of this is working let's print self do biome self do monsters and self dot levil if I now run main. pi we're not crashing and we are getting a whole bunch of data now you can see I was quite lazy when it comes to the grass patches we basically always have the same monsters and the same level but the data is working that's the important part which means we don't need this print statement anymore and next up we can work inside of main. Pi specifically in the monster encounter because this Sprites is going to contain all of these monster patch Sprites or at the ones the player is colliding with so for example to get the background surface we still want to get all of the BG frames but then for the key we want to get Sprites and the first one and on this we have the biome attribute besides that we need a couple of monsters which we are going to create via dictionary comprehension and just as before we want to have a dictionary with an index and a monster which we can get via a for Loop for index and monster in in numerate Sprites zero and then we have the monsters that means for the key we can get the index and for the monster we want to create one instance of the monster class in which we are going to need the name of the monster that we're getting from the four Loop and then we will need a level which we get from Sprites Z do level and and this I want to randomize just a bit meaning I want to add a random integer that goes from 3 to 3 that way we don't always get the same level although I don't think we have Rand in available at the moment we do not so all the way at the top from random import Rand int that is almost all we need the last thing that we have to change is for the character we want to have none so with all of that let's try the game and let's see if something crashes so at the moment the player simply stops walking but we do not get a battle something has gone wrong and I can see it right away we have to set self. tint mode to tint next attempt if I now walk around in the Tall Grass we're getting to a battle and I can still attack the monsters let me use their weak types and after that we go back to the Overworld and we are not able to move anymore but that is a thing we can fix quite easily we simply have to look at end battle and then check if we don't have a character if that is not the case self. player. unblock next attempt and now should get a battle we can still defeat all of the monsters and and after that we can walk around again also now we are getting some experience that is looking pretty good cool that is looking really good there's just one more thing that I want to do when we are encountering a monster I want to set self. encounter timer and switch up the duration which we're going to do via Rand in again and then get a random value I went with a value between 800 100 and 2,500 so the next encounter could be really fast or quite a bit away that means if I now try all of this again I can walk around and we getting a battle so let's defeat the monsters really quick and then we can walk around again and now we get a battle much faster and our monsters do not update their initiative only after we get attacked so something has G wrong but we are definitely making progress so let's fix this bug really quick basically inside of battle. Pi when we are creating a monster I want to make sure that monster do host is equal to fults that way if I run my not Pi again and let me speed all of this up and now we get another battle and there we go we are getting getting the proper behavior everything else is also working just fine so this is looking pretty good so with that we have the entire transition between the battle system and the Overworld we are making a ton of progress the last major chunk then is going to be the evolution system for which I want to create a new python file so a new file and then let's call it Evolution dot High we will need from settings and import everything also we are going to need a timer meaning from timer import timer once we have that I want to create a class called Evolution and then we will need a Dunder init method with a whole bunch of parameters we will need frames a start monster and end monster a font and then we want to end the evolution to get back to the Overworld in there we will first of all need a display uncore surface that we are getting from py game. display. getor surface then we will need self. start monstore surface and an end monster surface the way the system is going to work we're going to show the first Monster and then slowly f faded out to White and once we have reached the full amount of white we are switching to the evolution so in practice we are simply showing two different surfaces which we can get via the frames and both start and end monster are simply monster names which means those we can use inside of the frames so I want the start monster then get the idle State and the first frame now this is going to be very small and to make this a bit more visual I want to put it inside of py game. transform. scale to X that will make it twice as large the same thing I want to do for the end monster with the only difference being that we want to now use the end monster on top of that I want to create a timer dictionary where we have a start timer which would be a timer with a duration of 800 milliseconds and auto start will be besides that I want to have an end timer which is going to get a duration of 1,800 and the function we are going to call is going to be end Evolution or in other words when we are starting the evolution we will show the monster or the start monster for 800 milliseconds and once the evolution is done we're going to show the end monster for 1.8 seconds with that we can already get started with a basic update method for which we need self and Delta time and first of all there I want for timer in. timers do values and then timer. update that way the timers are going to work next up I want to check if not self. timers and start is active that is going to be the start timer and only after this timer is over do we want to do stuff and the thing that we want to do is self. display surface do blit and then I want to tint the entire window which we're going to do via self. tintore surface at position Z and zero this tint surface doesn't exist at the moment but we can create it quite easily and for that I want to create a section called screen tint we simply want to create pame do surface with the same Dimensions as the display surface so self. display surface and get underscore size this surface we want to make semitransparent I.E self. tint surface setor Alpha and I went with a value of 200 but you can play around with it that was quite a bit of setup but now that we have that inside of main. Pi I want to import From Evolution the Evolution class and now we have to figure out when to display this thing and for that I have created another method Define check uncore Evolution no need for custom parameters and basically we want to check for index and monster in self. player monsters. items we first of all want to check if a monster has an EV ution in the first place for that let's have a look at the monster class so we have quite a few python files at the moment we don't have an evolution value in here so we have to create it self. Evolution this value we are getting from the monster data then self. name and in there we have evolve so if you look at game data and the monster data inside of monster data if you look at the first Monster plumet you can see we have an evolv property with the name of the monster and the level needed to reach that Evolution if a monster has reached the final stage then evolve is going to be none so just to make sure you see what we are getting from self. Evolution let's print the value self. Evolution and if I now run m. Pi we are getting an error because I have to add pass in there but next attempt and now we're getting either none or a tupal with the name of the monster and a level that's looking good if a monster has an evolution we want to check if monster. level is equal to monster. Evolution and we want to get the first index that would be the level so inside of game data we would for example get 15 if we have reached that level we want to the evolution animation for which we want to block the player IE self. player. block and then self. evolution is going to be one instance of the evolution class for that we are going to need all of those parameters frames are going to be self. monster frames and we only really care about the monsters here the start monster will simply be monster. name and the end monster is going to be monster. Evolution with value zero the font that we want to use is going to be self. fonts along with the Bold font end Evolution will become a method that we will create in just a second self. end Evolution that we have to create right away fine and evolution with self following this method we'll set self. Evolution to do none and unblock the player I self. player. unblock finally inside of the run method we want to have one more overlay If self. evolution then self. evolution. update with Delta time and now to test this system if you look at the player monsters there we have Lavia which is level three and inside of game data if I find it really quick there we have Lavia and this one evolves to cleave on level four so we should get this one quite easily which means if I run main. Pi we are getting an error message that there is no attribute Evolution that happened because when we are creating the dunder ined method we don't have an evolution that we can add quite easily at the end self. evolution is going to be none next attempt the game doesn't crash and now if I encounter random monsters I can defeat them really quick and look at laia's level we should be reaching level four and we do and now we do not get anything so something went wrong and well the thing that went wrong is we are not calling this this check Evolution method to fix that we want to look at end battle and instead of an El statement I want to check L if. self do Evolution then I want to unblock the player and self. check Evolution so next attempt and now now we are getting a tinted screen which means that the evolution system does work although at the moment it well doesn't do anything first of all I want to create a rectangle via self. start monster surface and get F rectangle I want to place the center right in the middle of the window which means a tupal with window uncore Wii divided by two and window uncore height divided by two as well after that self. display surface. blit with self. start monster surface and a rectangle and while we are testing all of this to make things a bit easier inside of the dunder init method I want to set the level of Lavia to four right away and also we don't need the dummy monsters anymore and then after we are creating everything else I want to call self. check Evolution that way once the game is starting we are getting the evolution screen right away and at the moment nothing's going to happen but that we can work on at least we can see the Monster also before we continue this print statement is getting a bit annoying in fact I don't think we need the monster class at all anymore next up inside of evolution. Pi we are already displaying a monster but this I want to tint or to be a bit more specific I want to apply a white tint to the surface for that we will need self. start monster surface white quite a long name but basically what we're going to do we're going to get pame dok and then from uncore surface the self start monster surface which we are then going to turn into a surface right away to see what we are getting from that let me blit this start monster surface white right away with that if I now run MP again we are getting something like this a good start but we want to get rid of the black background that is not a problem at all self. start monster surface white then set uncore color key with a black value next attempt and that is looking good now this monster surface should fade in very slowly for which we're going to need two more values self dot tintore amount and self. tintore speed those values I have set to zero and 50 The Tint amount has to start at zero Al do tin speed you can customize after we have that I want to get self. start monster surface white and set the alpha value to self. Tin amount that way it's not going to be visible in the beginning but what we can do when the timer has timed out and we are actually displaying things I want to get self. start monster surface and that would display the monster itself after that I want to get self. tint amount and increase the value by self. tint speed multiplied with Delta time and now that we have that value self. start monster surface white we want to change the alpha of this other surface with self. tint Mount once again or in other words for this white surface we are setting the alpha value in the init method to zero so it's not going to be visible but in the update method we are increasing the tint amount value and then updating the alpha value that way it will slowly fade in that we do have to display bya self. display surface. blit with self. start surface monster white along with the rectangle let's try all of that and the monster is slowly becoming white so Death part is working it might be a bit slow let's change to 50 to and 80 it might be better so now all of this happens quite a bit faster but once again choose whatever value you think looks good in my case I want to go to the next step and that is going to be that we only want to do all of this if a condition is true if self. tint is smaller than 255 if that is not the case else then we want to display the Evolution for which we're going to need another rectangle which we can get via self. end monster surface and get a rectangle where we are placing the center right in the middle of the window for that we can duplicate those values afterwards self. display surface dolit with self do and monster surface and the rectangle next attempt we are getting the monster and after it gets completely white we're getting the evolution that looks really good once we have all of that we can also get self. timers and the end timer and activated remember for this timer once it times out we are calling end Evolution that way we're getting back to the Overworld although this timer I only want to call if it is not currently running meaning if not self. tim. end. active and with that if I now run main. Pi we're getting the evolution after a short amount of time then we are evolving and then we can walk around again although if you look at the monster index nothing has changed that we can work on in a second first of all I want to finish the evolution screen because I also want to have some text in there that's going to happen inside of the dander init method I want to have text specifically I want to have two text surfaces start text surface along with an end text surface both of those we are going to create bya cell do render where we will need some text then fults and then colors with the black color the text for the start surface is going to be an F string with the start monster and is evolving and make sure that all of this is actually a string and pay close attention here start monster is what we're getting from the parameters we are not actually storing this inside of the class we are turning it right away into a surface or into a piece of text for the end surface I want to have another F string with the start monster and evolved into the end monster that way we have two surfaces that we want to display the first one is going to be in the first if statement where we are still displaying the original monster I want to create a textor rectangle with self. start text surface and get F rectangle I want to place the mid top to rect do mid bottom plus a vector for an offset of 0 and 20 pixels after that self. display surface. blit with self. start text surface and the text rect angle also before we are displaying the text I want to have some background which we will create via py game. draw. rectangle I want to draw on the display surface the color is going to be colors and white then I want to get the text rectangle and inflated by 20 pixels and then finally zero for the Border width and five for the Border radius that should be all we need for one part of the text let's try all of that and we get Evolution has no attribute render that happened up here instead of self. render this should be self. font. render the font we're getting from up there and in fact this shouldn't be self at all this should just be font. render next attempt we are still getting the evolution and now we're getting some text as well good start so next up we have to display text in the El statement we can simply copy the original piece of text and paste it in there for the text rectangle I want to get the end text surface although the rest can stay the same then for py game. draw. direct we can keep all of this the same as well and finally we want to display self. end text so surface along with the text rectangle that should be all we need next attempt we get the evolution and after that we get another piece of text and then we can walk around again perfect that nearly finishes the animation for the evolution there's just one more thing that I want to do if you look at the folder for the project in graphics and other we have a star animation this I want to play once we get to the evolution it's not terribly complicated we simply have a whole bunch of stars and that's basically it to play those first of all we will need an import and that happens in the dunder init method under import assets right below the BG frames I want to have self dot star animation underscore frames which we can get via Port underscore folder then we want to go up a folder to Graphics then to other and there we have the star animation let me run the code to make sure this is working and it does that's looking good after that we want to look at check Evolution down there and if a monster is evolving when we are creating one instance of the animation I want to pass in self. Star animation frames that means next up inside of evolution we want to get the star animation frames or I guess we could just call it star frames that's a bit easier for those I want to add another section with this star and in there we want to have self do star frames which is going to be star frames also we will need a self do frame index and before we continue I want to scale up all of the frames inside of this list like we have done for the start and end monster surface which means a list comprehension with pame do transform. scale to X with the frame for frame in Star frames that way the entire thing looks a bit more coherent cool once we have that when we are seeing the final monster I want to run a method called self. display Stars along with Delta time this method doesn't exist right now so we have to create Define display stars with self and Delta time this is just going to be a basic animation I.E self. frame index plus equal some kind of Animation speed I think I went with 20 and multiply it with Delta time and then if self. frame index is smaller than the length of self. star frames we want to get a frame we want to get a rectangle and then self. display so surface with the frame and the rectangle the frame is simply going to be self. star frames with integer of self. frame index the rectangle is going to be frame and get F rectangle that we want to place right in the center of the window which we have already done a couple of times I can copy the line and that should be it if I now run main. Pi we get the evolution and once we are done we're getting an error message this surface is not callable that happens because I forgot to add dot lit so next attempt and that is looking really good everything else also works just fine so I am quite happy with the animation that means we can close evolution. pi and the next important part is that we actually get another monster so we are applying the evolution after the evolution animation I want to get self. player monsters along with the index that we are currently on and with that we are overwriting the current monster which is totally fine because we want to create a new monster with monster dot Evolution and zero I eat the evolution monster and then the monster do level that way if I now run all of this again we get the evolution and at some point we get a new monster if I now open the index we have a whole another monster and to test all of this just a bit more inside of thunder in it I want to set the level of Lavia back to three so now if I am over a grass patch we should still get a battle and I can defeat the enemy quite quickly that part is working and now we get the evolution and then we have another monster and we can continue the game that is working quite well also at this point we shouldn't check Evolution anymore inside of Thunder init and also once we finish fighting a trainer we should check for an evolution which means inside of end dialogue once we have defeated a trainer self. check Evolution don't forget to call it and in the game let's try to find this trainer shouldn't take too long we get some dialogue and afterwards we're getting the evolution this part still works just fine and then and we can once again continue everything cool with that we have the evolution that means we are basically done besides the audio so let's get started with that first of all we have to import a couple of files and that's going to happen inside of import assets at the bottom I want to have self. audio for which I want to have an audio importer with a file path up a folder then we want to go to audio and that's actually it if you look at the project folder inside of audio we have a whole bunch of files that we want to import for that we want to work inside of support. piy and let me minimize everything at the bottom of the Importer functions I want to have an audio importer along with a path and for all of that we have already seen something similar except now I want to have a dictionary with the files then for folder underscore path the subfolders we don't care about so underscore and then we have the file names in walk and join of the path after that we want to look at all of the file names I.E for file name in file names next up we want to create a full path using the join method and then stitch together to fold the path with the file name and once we have that I want to get the file's dictionary and create a new key value pair the key is going to be the file name and this we want to split to get rid of the file ending which means wherever we have a DOT we're going to split it and then pick the first value the value we are going to assign to this key will be py game. mixer. sound along with the full path at the end of all of this I want to return the files dictionary at the end of all of this I can print self. audio run the entire game it doesn't crash and we get a dictionary with a whole bunch of sound files that's a really good start that means we don't need the print statement and we can collapse import Assets Now we have to figure out when to play the sounds and the first sound I want to play is if one of the characters notices the player I want to play the notice sound for that when we are setting up all of the characters down here I want to add a notice uncore sound which is going to be self. audio and notice after that inside of entities. pipe when we are creating the character we need one final parameter notice uncore sound that we want to store all the way at the end self. notice sound is going to be the notice sound after that inside of the raycast once the character sees the player we want to get self. Noti sound. playay and with that if I now run main. Pi we should be able to hear a sound and we do that is working pretty well so that covers the entities we also don't need the Sprites anymore the next important part is going to be the battle there we want to have a whole bunch of sounds that we are going to pass into it when we are creating one instance of the class and this happens in two spots so when we are ending the dialogue we want to have the sounds which we're getting from self. audio this I can copy because next up when we have a monster encounter we want to have the same value and after that we have to make sure that we are storing all of this as an attribute and let's place it all the way at the beginning do sounds is going to be sounds and to make sure you can see what's going on let me print what we are getting self do sounds if I now run main. pi and we are getting into a fight the game doesn't crash and we can see a whole bunch of sounds now for the battle the only sounds that we are going to use are going to be for different attack moves for example we have fire we have ice we have green for healing and then a few more the way this system is going to work if you look at game data and hide everything besides the attack data every attack has an animation for example there we have fire green scratch and so on the name of the animation is also going to be the name of the sound we want to play so if we have the fire animation we also want to play the fire sound fairly straightforward when we are applying an attack that happens down there right below the attack Sprite we also want to get self. sounds and then get the attack data Al with the attack and then we have I call this one the animation that way we get the name of the file we want to play and well this we want to play if I now run main. pi and and we can get into a fight that sound is working and the fire sound is working let's try one more for ice that is also working cool so with that we have all of the sound effects that leaves us only with the background music and that we have to work with inside of the game class so we don't need battles support or game data first of all in the dunder Ed method after we are doing all of the Imports I also want to self. audio and get the Overworld and play that one also for an argument I want to add a negative one to play this one continuously the argument we're specifying here is for the loops if you set this to five You'll Play the audio five times a negative 1 plays it forever cool that is working well so with that we have an overwhel sound that means we don't need Dunder in knit anymore and next up if we are ending a dialogue and then starting a battle we want to do two things number one we want to get self. audio with the Overworld and then stop that track on top of that I can actually duplicate the entire line because we now want to get the battle music and play it once again with negative one so we are playing this continuously also this we have to do for the end dialogue and for Monster encounter meaning before we are starting the battle we want to stop the Overworld Music and start the battle sound let's try all of that okay this works reasonably well but once the battle is over we do not stop the battle music for that we want to look at end battle and then once the battle is over we want to get self. audio battle and stop the music after that that is the case we want to check if we have an evolution then we want to play The Evolution sound if not we want to play the Overworld sound for that we want to look at check Evolution and if there's an evolution we know that we have a value for self. evolution however if we don't have self. Evolution then we simply want to get self. audio the Overworld and play that one on the other hand if we do have an evolution then inside of this if statement I want to get self. Evolution and play that sound finally then inside of end Evolution I.E the evolution has finished we want to get the overwat sound and play that one with negative one this should also happen up here and on top of that we want to get the evolution sound and stop it and I usually put the stop sound before the play sound that just feels a bit better and I think that's it if I now run all of this again all right and that part is working as well so with that we have the entirety of the game and this was a longer tutorial I hope you found it useful and I'll see you around
