With timestamps:

00:17 - [Music]
00:28 - hello in this video you are going to
00:31 - learn how to create a Mario Maker Style
00:32 - game in Python using pi game you will be
00:36 - able to build huge levels with lots of
00:37 - monsters and decorations and then you
00:40 - can play them too while making this game
00:42 - you are going to learn how to manage a
00:45 - pretty large project with lots of data
00:47 - attached you will learn how to create an
00:49 - auto tiling system for the terrain and I
00:51 - will also cover the logic for a 2d
00:53 - platformer with a camera and basic enemy
00:55 - Behavior along with lots of other topics
00:58 - there's a reason this video is 10 hours
01:00 - long
01:01 - I do have to mention though that this is
01:04 - not a beginner's project I expect that
01:06 - you already know the basics of Pi game
01:08 - if you don't check out my ultimate
01:10 - introduction to pie game on YouTube or
01:12 - my paid udemy course the latter one
01:15 - teaches you pie game by making four
01:16 - advanced games and by purchasing it you
01:19 - also help me make more free stuff the
01:21 - last thing before I start the entire
01:23 - project is organized by a free folders
01:25 - one for the code one for the graphics
01:27 - and one for the audio the code folder
01:30 - contains the actual logic of the game
01:32 - you can download all of this from GitHub
01:34 - a quick note on that though inside of
01:37 - the GitHub project there are multiple
01:39 - code folders each of those corresponds
01:42 - to one chapter inside of the video that
01:44 - should make it quite a bit easier to
01:46 - follow along with all of that out of the
01:49 - way we can work on the intro and the
01:52 - editor of this project let's Jump Right
01:54 - In and let's have a look
01:56 - here is the code I already have there
01:59 - are two python files we have main.pi and
02:02 - settings.pi
02:03 - settings.pi let me minimize everything
02:06 - is quite an extensive file the most
02:10 - important one in here is edited data and
02:12 - in there we have a very chunky
02:15 - dictionary although for now just don't
02:18 - worry about it all we need for now are
02:21 - these bits up here more specifically the
02:23 - window width and the window height the
02:25 - rest you can ignore at least for now
02:28 - what is much more important inside
02:30 - main.pi in here if I run everything
02:33 - we can see a black window that right now
02:36 - doesn't do anything
02:38 - let's go over it really quick all the
02:40 - way at the bottom down here we are first
02:42 - checking if we are in the main file we
02:45 - are going to have quite a few different
02:47 - files so this one is important next up
02:50 - we are creating an instance of the class
02:53 - Main and this class we are creating up
02:56 - here I'll talk about it in just a second
02:59 - finally on this object we are calling
03:01 - main.run which is this run method here
03:04 - inside of that we are running the actual
03:07 - game meaning this here is going to
03:09 - become quite a bit more extensive
03:12 - and that would be a basic overview now
03:15 - inside of the main class we have an init
03:18 - method and we have the run method the
03:21 - init method initializes Pi game this
03:24 - happens here then we are creating a
03:26 - display surface and we are creating a
03:28 - clock
03:29 - I guess the important bit here is that
03:31 - when the width and window height come
03:34 - from the settings this is what we have
03:36 - created here and this is why this is
03:38 - important right now
03:39 - besides that nothing really happens
03:41 - inside of the initi method so I can
03:43 - minimize it at least for now
03:46 - inside of the run method all we're
03:48 - really doing is we are creating a while
03:50 - loop this one here and inside of that
03:53 - we're getting Delta time we are getting
03:55 - the events and finally we are drawing a
03:59 - frame this is a really simple setup for
04:02 - pi game
04:03 - let's talk about what we have to do
04:06 - right now we have a main object and
04:09 - later on for the game we are going to
04:11 - need two different states we have the
04:14 - editor State and we have the level State
04:16 - I assume the names here are quite
04:18 - self-evident editor is for editing the
04:20 - game and level is for actually playing
04:22 - the game the important thing we have to
04:24 - figure out for this is how we can switch
04:27 - between these two different states
04:29 - meaning how do we get from the editor to
04:32 - the level and how do we get from the
04:34 - level back to the editor and this is not
04:36 - going to happen straight between the two
04:38 - instead what is going to happen is that
04:40 - main is going to organize everything
04:42 - meaning that if we want to go to a level
04:45 - we go to the main file and then to level
04:48 - and the other way around if we want to
04:51 - go back from the level we go back to
04:53 - main and then to the editor although for
04:55 - quite some time we are only going to
04:57 - talk about editor because this one is
04:59 - the more extensive part
05:01 - so let's start working on that one at
05:03 - least for the basic setup here we are
05:06 - back in the code editor and I want to
05:08 - create a new file
05:09 - this one I'm going to save as editor dot
05:13 - pi
05:14 - in here as always we have to import Pi
05:18 - game
05:20 - besides that let me copy it from main.pi
05:23 - actually I also want from settings to
05:26 - import everything which means we have
05:28 - all of this here available inside of the
05:30 - editor as well
05:32 - once we have that I want to create a
05:35 - class called editor there's no
05:37 - inheritance and in here I want to first
05:40 - of all create a Dunder init method
05:43 - this one itself and nothing else at
05:46 - least for now and finally in here let me
05:49 - add a comment this is going to be the
05:51 - main setup for now all I want is self
05:54 - dot display underscore surface
05:58 - this we get with
06:01 - pygame.display.get underscore surface
06:04 - that allows us to draw on the display
06:06 - surface so what the player sees right
06:09 - away we don't have to go over main.pi
06:11 - and besides that I want to create a run
06:15 - method this one needs self and we also
06:18 - need Delta time
06:19 - Delta time we are getting from DT here
06:23 - and this one is really important to keep
06:25 - our game frame rate independent
06:28 - if you have no idea what that means
06:29 - check out this tutorial it explains all
06:31 - of that
06:32 - although for now inside of run all I
06:35 - want to do is to type pass so we're not
06:37 - doing anything actually
06:40 - just to see that this is working let's
06:42 - do instead
06:44 - self.displaysurface dot fill let's say
06:47 - with a white color
06:48 - that way we can tell what's going on
06:51 - and with that all I want to do is inside
06:54 - of main.pi I want from editor import
06:59 - editor that way I have this class
07:02 - available in main.pi
07:04 - and inside of the init method I want to
07:08 - create an instance of that which means
07:10 - self.editor is going to be the editor
07:14 - and on this editor
07:17 - inside of the while loop of the game I
07:20 - want to get my editor
07:22 - and get the run method
07:25 - now if I run this
07:27 - we are getting an error that there's one
07:30 - required argument missing Delta time
07:33 - this happened because in here we have
07:36 - the data time argument fortunately this
07:38 - one is easy because we have Delta time I
07:41 - can just pass it in here and now if I
07:43 - run this we have a white background this
07:46 - white background we are getting from
07:48 - this line here which means this one is
07:50 - working good start
07:52 - there's one more thing that we do have
07:54 - to do and let me explain why once again
07:57 - here are the different states of the
07:59 - game and the problem we have is that
08:02 - both the editor and the level need their
08:05 - own event Loop
08:07 - which means for the editor we have to
08:10 - check what we are doing for the mouse
08:12 - input if there's a certain kind of
08:14 - keyboard import or if we are closing the
08:16 - game and the same we have to do for the
08:18 - level
08:19 - as a matter of fact we actually have a
08:21 - third event loop as well the one from
08:24 - Main
08:25 - and all of this combined really isn't
08:28 - good because if you have too many event
08:29 - Loops things can get quite complicated
08:32 - as a consequence we are going to make
08:36 - some changes and that is that main does
08:39 - not have an event Loop by itself instead
08:42 - we only have an event Loop inside of the
08:45 - editor and inside of level
08:48 - and those event Loops are not going to
08:50 - run at the same time and that is because
08:52 - we either have the editor or the level
08:54 - open they are never open at the same
08:55 - time
08:56 - and this is what we have to implement
08:59 - which means back in the code I want to
09:02 - take all of this here and add it to my
09:07 - class inside of a method let's call it
09:10 - event Loop this one itself and nothing
09:14 - else
09:14 - and in here I want to have the event
09:18 - Loop and for now the only thing that we
09:21 - need is close the game
09:25 - that is going to be your exercise what I
09:28 - want you guys to do is to copy all of
09:30 - this paste it in here and then run the
09:33 - event Loop when the editor is open
09:35 - should be fairly straightforward so
09:38 - pause the video now and try to figure
09:39 - this one out yourself
09:44 - alrighty first of all
09:46 - I want to cut out a couple of things
09:48 - this while true Loop here has to stay
09:50 - same for this Delta time
09:53 - however this event Loop here I do want
09:56 - to cut out like this
09:58 - and now inside of editor I want to paste
10:02 - it I do have to fix the indentation
10:06 - but now this is more or less all I had
10:10 - to do
10:11 - all I need now is to actually call this
10:13 - event Loop so self dot event Loop
10:18 - and now if I run all of this again I
10:21 - should be able to close the game and I
10:23 - am although now I'm getting an error
10:24 - that name sis is not defined
10:27 - that is happening because now we are
10:29 - calling sys.exit inside of editor which
10:32 - doesn't have the sys module that we can
10:34 - fix quite easily by importing sys as
10:36 - well
10:37 - along those lines we don't need CIS and
10:40 - may not Pi anymore
10:41 - if I run this now
10:43 - once again we're getting a white
10:44 - background now we can close it and
10:46 - everything works as intended cool
10:49 - let me minimize the event Loop and also
10:52 - the init method because the editor class
10:55 - is going to become really long
10:58 - but that is what we are going to start
11:00 - building
11:01 - although for now I think this is a
11:03 - pretty good start so let's work on the
11:05 - next part in this section we are going
11:09 - to create the editor and the main Grid
11:11 - or at least we are going to display it
11:13 - and let me explain what that actually
11:15 - means
11:16 - for the editor we have an origin this
11:19 - origin is a vector and literally every
11:21 - single element is going to be relative
11:23 - to it this is literally just one
11:26 - position or more specifically this is a
11:29 - vector with an X and a y coordinate
11:32 - and this point we can move around later
11:35 - on this is actually what we are going to
11:37 - do in this section and every single
11:39 - element we are going to create for
11:41 - example let's say if we are creating a
11:44 - single tile these tiles are always going
11:46 - to be relative to the origin
11:49 - which means if we're moving the origin
11:51 - to the top right we are also moving all
11:54 - of the other elements in the same
11:56 - direction
11:58 - that way when we want to pan around the
12:00 - editor we only have to move one point
12:02 - and everything else is going to follow
12:05 - so let's implement it
12:07 - once again we are inside of the code I
12:10 - want to work inside of the editor more
12:12 - specifically inside of the init method
12:16 - in here I want to add another section
12:18 - let me call it navigation
12:21 - the really important part in here is
12:23 - self Dodge origin this one is going to
12:26 - be a simple Vector now for the editor
12:29 - we're going to use vectors quite a bit
12:31 - and as a consequence I want to save me
12:34 - some writing so I'm going to create a
12:36 - shorthand which means from pygame dot
12:39 - math I want to import a vector 2 and I
12:42 - want to rename this to vector that
12:45 - allows me to not write
12:48 - pygame.math.vector2 every single time
12:49 - instead all I have to do is type vector
12:52 - and I have a vector now we have
12:55 - ourself.origin
12:57 - and just to illustrate what is going on
12:59 - let me actually draw it which I do with
13:03 - pygame DOT draw dot Circle
13:07 - in here I need self dot display surface
13:11 - so the surface we want to draw on then I
13:14 - need to color let's go with red for now
13:16 - then I need a center and the center is
13:19 - going to be self.origin finally we need
13:22 - a radius let's go with 10 so we can see
13:25 - it quite easily
13:27 - if I run main.pi now
13:30 - you can see in the top left we have a
13:32 - red dot and this point we are going to
13:35 - move around
13:37 - and to move it around
13:39 - I want to add another method let me do
13:43 - it below the event Loop and let's call
13:45 - it pan input
13:48 - in here we need self and we need the
13:51 - current event this is what we're getting
13:53 - from the event Loop
13:55 - and since the editor is going to have a
13:58 - ton of methods I want to add quite a few
14:00 - different comments here to make it
14:02 - easier to follow
14:04 - which means this entire section here is
14:06 - always going to be the input and there
14:09 - are going to be a few more methods
14:10 - coming but for now let's not worry too
14:13 - much about it now pen dot input we are
14:16 - going to always call inside of the event
14:19 - Loop so pen input and I want to pass the
14:23 - event in here
14:25 - inside of this I have to figure out a
14:28 - couple of different things first of all
14:30 - I want to check if the middle Mouse
14:32 - button was pressed or released let me
14:34 - add this with a comment so middle Mouse
14:37 - button pressed or
14:40 - released
14:41 - which means if I am holding down the
14:44 - middle Mouse button I want to pan around
14:46 - the editor and if I'm releasing the
14:48 - middle Mouse button I want to stop
14:50 - panning although right now this is only
14:52 - the input besides that I need an actual
14:55 - let's call it panning update
14:58 - and how we are going to connect the two
15:00 - is by creating one attribute inside of
15:03 - the init method that I call Self dot pan
15:07 - active
15:09 - by default this one is going to be false
15:14 - in here I first have to check now if the
15:18 - event DOT type that is the event I'm
15:21 - getting from the event Loop although let
15:23 - me minimize it for now so we only focus
15:25 - on one thing
15:27 - if this is equal to pygame dot mouse
15:30 - button down
15:32 - that's not how you spell that like that
15:35 - if that is the case
15:38 - I want to set self dot pan active to
15:41 - true
15:43 - although we do have a problem here right
15:46 - now we are checking for any Mouse button
15:48 - down so any click of the mouse this
15:51 - could be a left click a right click or a
15:53 - middle click but I only want to check
15:55 - for the middle Mouse Button as a
15:58 - consequence I have to add another
16:00 - condition
16:01 - and this one we get with pygame dot
16:04 - mouse dot get underscore pressed this
16:08 - one is going to give us the different
16:09 - Mouse buttons that have been pressed
16:11 - although this I am also going to use a
16:13 - couple of times and it's quite
16:15 - cumbersome to write so let me cut it all
16:18 - out
16:19 - and instead from
16:21 - pygame dot mouse I want to import get
16:25 - underscore pressed and rename it to
16:29 - Mouse
16:30 - buttons that I think is much easier to
16:33 - understand
16:35 - and this I can now use S Mouse buttons
16:38 - and this is going to give me a tuple
16:40 - with the left right and middle Mouse
16:42 - button
16:43 - in my case I only care about the middle
16:46 - Mouse button this is the one with the
16:48 - index 1.
16:50 - I guess while we are here I can just
16:52 - print
16:54 - middle Mouse button and see if this is
16:57 - working
16:58 - which means in main.pi
17:01 - I am getting an error that name pan
17:02 - input is not defined the reason for that
17:05 - I think is that this should be called
17:08 - self.pan input
17:11 - if I run this again now and press the
17:13 - middle Mouse button we get middle Mouse
17:15 - button pressed or just middle Mouse
17:16 - button although if I press left and
17:18 - right nothing is happening
17:21 - which means this is a really good start
17:24 - and these two lines here work
17:28 - while we're at it we can also check if
17:30 - the button has been released that we are
17:33 - getting with if Mouse buttons don't
17:36 - forget to call it
17:38 - and one if that is not the case
17:44 - then I want to set self dot pan active
17:47 - back to false
17:49 - once we have all of that inside of
17:52 - panning update I can check if self dot
17:55 - pan active and if that is the case I
17:58 - want to set self dot origin
18:02 - to my mouse position
18:05 - in this we will get with pygame dot
18:07 - mouse dot get underscore pause although
18:10 - just like we have seen with getpressed
18:14 - this is going to be kind of annoying to
18:16 - write as a consequence I'm going to
18:19 - duplicate this line and replace get
18:22 - pause with the mouse position
18:28 - which means now the origin is just going
18:31 - to be
18:32 - Mouse position and now I can now if I
18:36 - hold the middle Mouse button move the
18:38 - origin around and this is working really
18:41 - well although now we do have a problem
18:43 - we have the origin right here that one
18:47 - is really obvious
18:48 - but every time we are pressing the
18:50 - middle Mouse button this point is moved
18:52 - to the mouse position
18:54 - which means if our Mouse position is
18:57 - somewhere down here we are jumping the
19:00 - origin Point all the way this distance
19:03 - which is not what's supposed to be
19:05 - happening
19:06 - and if we had more elements in the game
19:08 - this would be really confusing
19:11 - instead what I want to do is
19:14 - this point here if we press the middle
19:17 - Mouse button is going to stay in the
19:19 - same position and then if we are moving
19:21 - the mouse let's say in this position I
19:24 - also want to move the origin in the same
19:27 - position
19:28 - which means we are only getting the
19:30 - mouse movement we're not getting the
19:31 - actual Mouse position
19:34 - and to achieve that all we have to do is
19:37 - whenever we are pressing the middle
19:38 - Mouse button we are getting the offset
19:41 - between these two points which is going
19:44 - to be another Vector that looks like
19:46 - this
19:47 - and I think this is going to make much
19:49 - more sense when I actually implement it
19:52 - which means
19:53 - whenever I am pressing the middle Mouse
19:56 - button I want to get some kind of offset
19:59 - this offset I actually want to create
20:02 - inside of the initi method let's call it
20:05 - self pan offset this is also going to be
20:09 - a vector but by default it is going to
20:11 - be 0 and 0.
20:12 - and let me minimize the event Loop and
20:16 - now inside of this line here
20:19 - I want to get myself dot pan offset and
20:24 - now I have to figure out the size of
20:26 - this vector
20:28 - which honestly isn't that difficult all
20:31 - I need is my current Mouse position
20:33 - don't forget to call it and from that I
20:37 - want to subtract myself dot origin
20:39 - although for this to work in this most
20:42 - position needs to be a vector itself so
20:45 - vector
20:47 - and let me explain what's Happening Here
20:50 - this one is going to be the entire
20:53 - window and for Simplicity let's use
20:55 - examples the origin is going to be a
20:59 - point up here and the mouse position is
21:02 - going to be a point down here
21:04 - what we are getting with this entire
21:07 - operation is the distance between the
21:10 - two
21:11 - how I am going to use that is when I'm
21:13 - setting the origin when pan active is
21:16 - true I don't want to set the origin to
21:18 - the mouse position
21:19 - instead I want to turn the mouse
21:22 - position again into a vector and from
21:26 - that I want to subtract self dot pan
21:29 - offset
21:31 - and now let me run all of this again
21:35 - now if I only hold the middle Mouse
21:37 - button and don't move my mouse nothing
21:39 - is happening however now if I move the
21:42 - mouse we are moving the origin Point
21:44 - without moving the origin point to the
21:47 - mouse we are only getting the movement
21:49 - of the mouse but nothing else I hope
21:52 - that makes sense
21:54 - that way when we're moving the origin
21:55 - Point around it doesn't look too
21:57 - confusing
21:58 - and all we are really doing here let me
22:01 - minimize all of this so I have a bit of
22:04 - space to write on
22:07 - like so basically all we are doing
22:10 - whenever we are pressing the middle
22:11 - Mouse button we are getting the distance
22:13 - between the two this line here
22:16 - when we are moving the mouse in this
22:18 - direction we are setting this origin
22:21 - point to the same position so this point
22:24 - here however we are giving it an offset
22:27 - and the offset is again the same blue
22:30 - Vector we created here that way we are
22:34 - always getting the same kind of movement
22:37 - without putting the origin on the mouse
22:40 - position
22:41 - we are essentially panning the origin
22:43 - point
22:46 - all right that I hope wasn't too
22:48 - difficult although there's one more
22:50 - thing that I do want to add and that is
22:52 - a mouse wheel
22:55 - all we need for that is if event DOT
22:58 - type is equal to pygame dot mouse wheel
23:03 - and what that is doing let me print it
23:05 - actually I want to get event dot y
23:10 - event.y might be a bit confusing here
23:12 - the way you want to think about it is
23:14 - that when you have your mouse button
23:16 - something like this
23:19 - you can for most mice move it up or down
23:22 - some mice also allow you to move it left
23:25 - and right although the mouse I have
23:27 - doesn't do it and it's not very many
23:29 - mice that do it
23:31 - so I am not going to use it although you
23:33 - could and event.y is this up and down
23:37 - movement here event.x would be the left
23:41 - and the right movement which means if I
23:43 - run main.pi and I scroll up or down we
23:47 - get either one or a negative one
23:50 - depending if I go forwards or backwards
23:53 - or up or down depending on how you want
23:54 - to call it all we have to figure out now
23:57 - is how to use this to influence the
23:59 - origin position and this could be a
24:02 - really good exercise for you try to
24:04 - implement the mouse wheel yourself and
24:06 - see how you can use it to change the
24:08 - position of the origin
24:10 - this could either only be the X position
24:12 - but if you want to challenge yourself
24:13 - you could also add another mouse input
24:16 - and also do it for the Y position see
24:18 - how far you get
24:22 - all we have to do is get self dot origin
24:26 - and I want to move the X part of this
24:28 - vector
24:29 - and this I want to
24:32 - minus equal event dot Y and right now
24:37 - event.y is either one or a negative one
24:41 - which is going to be quite small which
24:43 - means I want to multiply it by 50. if I
24:47 - run this now
24:48 - I can scroll down and go in this
24:52 - direction and scroll up and go in the
24:53 - other direction
24:56 - which looks pretty good let me move it a
24:58 - bit more to the middle if I scroll down
25:00 - we're going in this direction if I
25:02 - scroll up we're going in this direction
25:08 - you might be wondering now why I'm using
25:11 - negative equal instead of plus equal and
25:14 - let me print event dot y again
25:19 - if I run all of this now let me move the
25:21 - Red Dot into the middle if I scroll away
25:24 - from me so four words I guess I'm
25:27 - getting a 1 and if I scroll towards me
25:29 - I'm getting a negative one
25:31 - and I found this to be most natural if I
25:34 - go forwards
25:35 - like this the entire level is going to
25:38 - move a tiny bit more to the right
25:41 - it's kind of hard to see right now but
25:43 - later on this is going to make much more
25:45 - sense just imagine this is the entire
25:47 - origin point for the game and if this
25:49 - thing is moving in this Direction the
25:52 - entire level is moving in this direction
25:54 - as well which is what I want to happen
25:56 - if I'm scrolling forward like this
25:59 - and then if I go in the other way it
26:01 - goes in the other way once we have some
26:03 - elements this is going to make much more
26:05 - sense for now just stick with me
26:08 - I suppose while we are here we can also
26:11 - make this a tiny bit more fancy I can
26:14 - check if pygame dot key
26:18 - dot get underscore pressed
26:22 - so right now I'm checking if I'm
26:24 - pressing any button on the keyboard
26:26 - although I only care about one specific
26:28 - one and that is pi game
26:30 - dot k underscore L control that is the
26:35 - left control button on Windows and I
26:37 - think on the Mac it's the command button
26:40 - and if I'm holding that one I want to
26:43 - copy this line here indented
26:46 - and now move the Y position
26:48 - with the X position being in the else
26:50 - statement
26:52 - this makes sure if I'm pressing left
26:54 - control and scroll of the mouse we're
26:56 - going up and down and if you're not
26:57 - holding this button we're going left or
26:59 - right
27:01 - let's try it
27:03 - and let me move the dot into the middle
27:05 - if I don't hold left control and use the
27:08 - mouse wheel I can go left and right if I
27:11 - hold left control I'm going up and down
27:14 - that way we have a pretty good scroll
27:16 - Behavior
27:18 - and that is going to be the pan input
27:21 - later on we will have to add a tiny bit
27:23 - more but for now this is fine there is
27:26 - one more thing that I want to add for
27:28 - this section although it is getting
27:30 - quite a long one let me add another
27:32 - section that I called Drawing
27:35 - in here I want to draw tile lines
27:40 - maybe not the best name but well it is
27:43 - what it is what this means is
27:46 - if this one here is the entire editor
27:51 - window or the entire game window I want
27:54 - to have individual lines that tell me
27:58 - where in the grid I am which is going to
28:01 - make it much easier to navigate through
28:02 - the entire thing and this is supposed to
28:05 - be infinite and also relative to the
28:07 - origin Point Let's Start and let me
28:10 - explain how the logic is going to work
28:13 - first of all I need to know how many
28:15 - columns and how many rows I will have
28:19 - and this I get with the window with or
28:23 - the columns and divide it by the tile
28:26 - size both of these are inside of
28:29 - settings I have the window width and the
28:31 - tile size
28:33 - both of these are static numbers so they
28:35 - are never going to change
28:37 - also I haven't mentioned but the entire
28:40 - game is going to be independent of the
28:42 - resolution of the game so if you have a
28:44 - very small or very large monitor you
28:46 - could change these numbers as you want
28:48 - although tile size because of the
28:50 - graphics has to stay at 64.
28:52 - and the same thing
28:55 - I want to do for the rows except this
28:58 - one is going to be window height
29:02 - once I have all of that I can run
29:05 - something like for call in range cults
29:11 - which means if I have 10 columns I want
29:14 - to draw 10 lines one for each column in
29:17 - here literally all I want to do is
29:19 - pygame dot draw dot line we first of all
29:22 - need a surface which for now is going to
29:25 - be self dot display surface
29:28 - after that we need a color and the color
29:30 - we have in the settings line color
29:33 - although just black is also fine but let
29:36 - me copy line color and line color in
29:39 - here
29:40 - finally I need a start and an end point
29:44 - both of which are going to be
29:47 - an X and A Y position
29:50 - let me add X and Y in here so this is
29:54 - easier to read
29:55 - border columns the Y position is going
29:58 - to be really easy let me draw it
30:00 - actually once again we have an entire
30:03 - window
30:04 - and right now I want to draw the column
30:06 - lines something like this all of these
30:09 - columns always start at the position 0
30:12 - so the top of the window and end at the
30:15 - height of the window
30:16 - which means for the Y position this is
30:19 - either going to be zero for the start
30:20 - position and window height for the end
30:24 - position that's literally all we do
30:27 - the X position is getting a tiny bit
30:30 - more complicated so let me create a
30:32 - separate variable
30:34 - although that being said both X for the
30:37 - start and for the end position are going
30:39 - to be identical because each line is a
30:42 - straight line I probably should have
30:43 - drawn this a bit better something like
30:45 - this okay you get the idea the important
30:48 - thing here is that the X position for
30:50 - this and the X position for this is the
30:53 - same that's the really important bit
30:54 - here and what I want is self dot origin
30:58 - dot X Plus call multiplied by the tile
31:05 - size
31:06 - what that means let's say our origin
31:09 - point is at position 0 and 0 right now
31:12 - this is the point we're getting here and
31:14 - X is zero so let me write X is equal to
31:19 - zero
31:20 - and from this point I want to add column
31:23 - multiplied by the tile size column right
31:26 - now is going to be 0 and tile size is
31:28 - always going to be 64.
31:31 - which means for the first one we get
31:34 - zero and this is then going to be this
31:37 - line here
31:39 - however now if we add this to a 1 or the
31:42 - second cycle in this for Loop and
31:44 - multiply it with 64. we are getting 64.
31:48 - and this is then bringing us to this
31:50 - point here
31:52 - and this we keep on doing until we reach
31:54 - the end of the columns
31:57 - so now all we have to do is call this
32:00 - method and we should be seeing something
32:02 - although there are quite a few problems
32:04 - let me do it before we are drawing the
32:08 - origin and let me add another comment
32:10 - here to call this drawing so this is a
32:13 - bit easier to follow
32:16 - filling display surface should also be
32:18 - in there actually
32:19 - in here I want self Dodge draw tile
32:22 - lines
32:24 - and now if I run out of this there you
32:27 - can see the lines and if I move the
32:29 - origin point you can also see that they
32:31 - are moving along with the origin Point
32:33 - although I guess you can see the problem
32:36 - we are very easily running out of points
32:39 - and nothing is here anymore
32:42 - also what I can do is if I move the
32:45 - origin Point too far to the left we're
32:47 - also running out of points here
32:49 - all of which is not ideal I want to be
32:52 - able to scroll infinitely and just keep
32:55 - on going which means I have to make some
32:58 - adjustments but they aren't that big
33:01 - let me minimize the run method and in
33:05 - here now I want to make sure that the
33:08 - lines are always on the display we are
33:11 - never running out of lines
33:13 - and if you want to challenge yourself
33:15 - this could be a fun exercise although
33:18 - this one is getting quite a bit more
33:19 - advanced but see if we can figure this
33:22 - one with yourself you don't have to add
33:23 - that much more if you want a reference I
33:26 - fixed this entire problem with one
33:29 - additional line of code
33:33 - all right let's do together now and
33:36 - first of all let me talk about the logic
33:39 - that we need here right now we have the
33:43 - entire window and we have an origin
33:46 - Point somewhere on here let's say right
33:48 - now it is somewhere here and this point
33:50 - is going to be the origin for all of the
33:53 - other columns meaning we are always
33:54 - drawing them in this line here you can
33:57 - already tell the first problem is to the
33:59 - left we have nothing
34:01 - on top of that if we are moving the
34:04 - origin too far to the left we also have
34:07 - nothing on the right side both of which
34:10 - are problems we do have to account for
34:13 - so let me clean this up a tiny bit and
34:15 - instead what I want to do
34:19 - is let me move the origin point a bit
34:22 - further to the left let's say it is here
34:24 - and the X position is 100.
34:29 - the logic you have to understand that is
34:32 - probably going to take you some time to
34:34 - follow is we always want to draw some
34:37 - columns here is column zero then we have
34:39 - column one at 64 pixels then the next
34:43 - one would be somewhere here at 128 and
34:47 - we keep on going and always go by one
34:49 - Higher in our tile size
34:51 - however now when I'm drawing all of this
34:54 - I do not want to set this origin Point
34:57 - here as the origin because then we end
34:59 - up with the problem that we have the
35:01 - columns that always go to the right and
35:03 - we end up without points instead I want
35:06 - to create another vector
35:08 - and this Vector is always going to be in
35:12 - this first area here somewhere like this
35:17 - which means the vector can only be here
35:19 - or here or here it could also be higher
35:22 - up or lower up that doesn't matter but
35:25 - it could never be here or here those
35:28 - points are not possible we Are Always
35:30 - Somewhere in here now the Y position we
35:33 - are going to completely ignore the X
35:35 - position however is going to be really
35:37 - important and this one we are getting
35:40 - from this distance here it's kind of
35:44 - hard to see basically what I want to
35:46 - know is what is 100 this number here
35:49 - minus
35:51 - 64 which is this number here
35:55 - if I'm doing the math here this one
35:58 - would be 36.
36:00 - and this 46 is going to be the distance
36:03 - from the origin so we are moving a point
36:06 - here it has the same y position as the
36:08 - origin but the X position is going to be
36:11 - the distance between the next column and
36:14 - the actual point
36:15 - I hope that makes sense once we have
36:18 - this point here
36:20 - all I really want to do is to start
36:22 - drawing columns from this point so we
36:25 - are creating columns here columns here
36:27 - columns here and that way we can move
36:30 - the origin wherever we want it is always
36:32 - going to be somewhere in this position
36:34 - and that way the columns can never go
36:36 - outside of the window I hope that makes
36:39 - sense
36:40 - again this isn't the easiest logic to
36:42 - follow
36:43 - but let me actually implement it and
36:46 - let's see how far we get
36:48 - first of all I want to create let me
36:50 - call it an offset vector
36:52 - this is also going to be a vector and in
36:55 - here we have an X and A Y position and
36:58 - I'm going to put both of them on
37:00 - separate lines to make it a bit easier
37:01 - to see although if you have a large
37:04 - enough monitor you probably don't need
37:05 - to
37:06 - in both cases
37:08 - I want to first of all get self.origin
37:11 - and this is either going to be X or it's
37:14 - going to be y
37:16 - I now want to get distance between my
37:18 - current point so self.origen.x currently
37:21 - is 100. and from that I want to know the
37:25 - distance this blue line here between the
37:30 - next column which is going to be 100
37:32 - minus 64. the 100 I already have I now
37:37 - have to get the 64.
37:40 - although I do have to be careful here my
37:42 - origin Point could also be let's say
37:45 - here or here or here so this 64 always
37:49 - has to be the next column this we are
37:51 - getting with self Dot
37:54 - origin dot X
37:56 - and I want to divide this by the tile
38:00 - size
38:02 - and this I want to turn into an integer
38:08 - once again if I use actual numbers self
38:11 - dot origin.x would be 100 and the tile
38:13 - size would always be 64. which means
38:18 - this combined would be something like
38:19 - one point let's say 1.4 and if we get
38:23 - the integer we are removing anything
38:26 - after the dot so this would be a one
38:28 - which means we are on the first column
38:33 - although again this one would just be a
38:36 - one it needs to be a 64. as a
38:39 - consequence I want to multiply all of
38:41 - this with the tile size once again
38:45 - that way this entire number is going to
38:48 - become a 64. the 64 we actually need
38:53 - and with that we have the actual origin
38:57 - for the X position the one we actually
38:59 - want
39:01 - and this I can just copy for the Y
39:03 - position just to have something in here
39:07 - so this is going to be origin.y and the
39:10 - rest can stay the same
39:12 - and now when I'm drawing The Columns I
39:16 - don't want to have
39:17 - self.origen.x instead I want to have the
39:20 - offset vector
39:23 - actually let me call this
39:25 - the origin
39:28 - offset that I think makes more sense
39:31 - the rest however can stay exactly as it
39:34 - is so now let's try all of this again
39:37 - now you can see once again
39:40 - we have
39:42 - the origin point we can move around but
39:44 - all of the columns are going to scroll
39:46 - indefinitely
39:48 - although there's one problem if I move
39:51 - the origin Point too far to the left
39:55 - you can see here all the way on the
39:57 - right we are missing one column
40:00 - but the rest looks pretty good so I am
40:05 - very happy with that
40:07 - the one change we do have to make is
40:10 - that when we're using this for loop I
40:13 - want to have colds plus one
40:15 - and now if I run this again now this is
40:19 - looking really good
40:23 - cool this is looking amazing now the
40:26 - main reason why this is working is
40:28 - because it only looks like the origin
40:30 - point is the origin of the columns
40:32 - however the actual origin is this point
40:35 - here which is the origin Point
40:38 - subtracted with the offset we have
40:41 - created and only from this point we are
40:44 - drawing all of these columns
40:47 - that way it looks like we have an
40:49 - infinite amount but we're always only
40:51 - drawing The Columns you can see on the
40:53 - window
40:56 - cool now all we have to do is do the
40:59 - same thing for the Y position so for Row
41:02 - in range rows plus one
41:07 - I want to create a y position and that
41:10 - is going to be the origin of set dot y
41:14 - plus the row multiplied by the tile size
41:20 - and once I have that let me duplicate
41:23 - the pygame dot draw line line
41:26 - and now I have to change the X and the Y
41:29 - position
41:31 - X is either going to be zero or it is
41:34 - going to be the window
41:36 - with
41:38 - and Y is going to be well the Y position
41:43 - once again if I draw the entire thing
41:46 - each row is going to look something like
41:49 - this
41:51 - for the X position we always starting on
41:54 - the left side of the window and we're
41:55 - ending on the size of the window width
41:58 - meaning this is ever going to be zero or
42:00 - the window width
42:02 - and Y is just going to be the distance
42:05 - from the top both on the left and on the
42:08 - right
42:09 - and now we have all we need I can run
42:12 - this again and now
42:14 - we have an infinite grid that we can
42:18 - scroll around in this is looking really
42:20 - good
42:22 - cool although there's one more thing I
42:25 - do want to do and that is that right now
42:27 - this black color is a bit too strong
42:30 - especially later on if we have the
42:32 - actual level this isn't going to look
42:34 - very good
42:35 - meaning I want to give all of this some
42:38 - transparency for that I'm going to draw
42:41 - all of this on a separate surface and
42:44 - then this surface is going to get some
42:46 - transparency the reason here is when you
42:48 - are drawing something you cannot
42:50 - influence the transparency this we have
42:52 - to do on a separate surface
42:54 - and this is going to happen inside of
42:57 - the init method I want to add another
42:59 - section let me call the common support
43:02 - lines
43:04 - in here first of all I want to create
43:06 - another surface let me call it support
43:08 - line
43:10 - surface and this is just going to be
43:12 - another pygame dot surface and in here I
43:16 - want to have the window width and the
43:18 - window height we are essentially copying
43:21 - our entire display surface
43:24 - if I scroll down a tiny bit you can
43:26 - still see it
43:28 - before we start to draw everything here
43:31 - right now our problem is these lines are
43:34 - black and this background here is black
43:37 - so you can only see black which isn't
43:39 - too helpful as a consequence before we
43:42 - are drawing The Columns or the rows I
43:45 - want to get my support line surface and
43:47 - fill it
43:48 - with a green color
43:51 - we are drawing not on display surface
43:54 - but instead on the support line surface
43:58 - and all the way at the end
44:00 - I want to have self.displaysurface.blit
44:05 - I want to Blitz
44:06 - self.support line surface at a position
44:09 - 0 and 0. since the support line surface
44:13 - has the same size as the display surface
44:16 - if we put it at position 0 and 0 it is
44:18 - going to cover the entire window
44:20 - let's try and now the entire thing is
44:23 - green
44:25 - not particularly helpful it actually
44:27 - looks really weird
44:29 - but what we can do
44:31 - in the init method we can set a color
44:34 - key this we get with self Dot support
44:36 - line surface and set underscore color
44:40 - key
44:41 - and the color key here is supposed to be
44:43 - green
44:45 - this means that we're going to remove
44:47 - any color with this color key Green in
44:50 - this case which is what we're using to
44:52 - fill the entire surface the consequence
44:55 - is that the entire green color is
44:57 - removed and right now we don't really
45:01 - see much of a difference
45:03 - however what we can do now is set the
45:06 - transparency on this support line
45:09 - surface
45:10 - all we need for that is set underscore
45:12 - Alpha and then here we need a value
45:15 - between 0 and 255.
45:18 - 0 being nothing at all and 255 is the
45:22 - full color
45:23 - in my case I went with something like
45:25 - 30.
45:28 - and now
45:30 - you can see some very faint lines but
45:32 - they don't get too much in the way but
45:35 - with that we have the actual grid that
45:38 - we can move around in this is looking
45:41 - really good
45:42 - and this section has gotten really long
45:44 - so let's finish it now and let's come to
45:47 - the next part
45:48 - now for the next part we can do
45:50 - something slightly easier and that is
45:52 - changing the mouse cursor that really
45:54 - isn't going to take long and this
45:56 - section is going to be shorter and
45:57 - easier so let's jump right into it
46:01 - here we are back at Main and I want to
46:04 - work inside of the init method of the
46:06 - main class because in here we have to
46:09 - initiate the cursor and let me add a
46:11 - comment to make this easier to follow
46:14 - now for a cursor we have to do a couple
46:17 - of things first of all we have to import
46:20 - an image as a surface let me store it as
46:23 - a surface and all we really have to do
46:25 - is to import an image and that we do
46:27 - with pygame DOT image dot load however
46:31 - once again I'm going to import quite a
46:34 - few different things inside of the main
46:36 - class later on as a consequence I don't
46:39 - always want to write Pi game image and
46:41 - load I just want to write load so what I
46:44 - can do just like I have done
46:47 - with these lines here
46:48 - I can let me put it here I want from
46:53 - pygame dot image
46:56 - import load
46:59 - that way I can just type load and import
47:02 - a graphic if I open the folder we have
47:05 - audio code and Graphics right now we are
47:08 - inside of code and here is what we have
47:11 - so far
47:12 - inside of Graphics though we have
47:14 - cursors and there we have a handle and
47:16 - we have a mouse the handle we look at
47:18 - later but Mouse is the important one for
47:20 - now this is what we are going to import
47:22 - and the file path towards this is one
47:25 - folder up then graphics cursors
47:30 - and mouse.png
47:33 - on top of that don't forget to convert
47:36 - Alpha all of this
47:39 - next up we have to convert this surface
47:41 - to a cursor object this I also want to
47:43 - store in the variable let's call it
47:45 - cursor and the command here is pygame
47:48 - dot cursors dot cursor in here we need
47:53 - two bits of information we need the
47:55 - let's call it the click
47:57 - yeah Bell area and we need a surface the
48:02 - surface we already have this surface
48:04 - here is totally fine the clickable area
48:06 - is let me actually open the graphic
48:10 - here we go and if I open this and scroll
48:13 - in a tiny bit
48:15 - what the clickable area essentially
48:17 - tells you is which part of this mouse is
48:21 - actually going to be the point we are
48:22 - controlling which right now in this case
48:24 - is going to be this point here so when I
48:27 - click the mouse button I want this area
48:29 - to interact and be my actual Mouse
48:31 - position with the entirety of this just
48:35 - being an attached graphic that doesn't
48:37 - really do that much this point here is
48:40 - what actually matters I hope that makes
48:43 - sense basically we are looking for a
48:45 - clickable area
48:47 - in my case the position here is quite
48:49 - simple I want the Tuple and this one
48:51 - needs X and Y and in my case both of
48:55 - them are zero
48:57 - that means we are having the top left of
48:59 - this surface as the clickable area
49:02 - there's one more thing that we have to
49:03 - do and that is we have to get pygame dot
49:07 - mouse dot set underscore cursor and then
49:10 - here I want to have the cursor if I run
49:13 - the code now
49:15 - we are getting an error because I have a
49:18 - typo in here this should be cursors
49:21 - now if I run this and you can see my
49:23 - mouse here we have a mouse cursor that
49:26 - looks much more appropriate everything
49:28 - else still works just as usual we have
49:30 - just changed the graphics of the mouse
49:33 - for the next part we're going to create
49:34 - a menu and let me start by talking about
49:37 - how this system is actually going to
49:39 - work
49:40 - inside of the editor we are going to
49:42 - create what is called a selection index
49:45 - and this is a variable with values
49:47 - between 2 and 18. and each number
49:50 - represents a certain kind of tile inside
49:52 - of the editor
49:54 - for example two would be terrain three
49:56 - would be water four would be gold coin
49:58 - and so on
50:00 - and this selection index can either be
50:02 - changed by clicking on the menu or via
50:04 - hotkeys and just to explain how we got
50:07 - the numbers 2 to 18 let me open the code
50:09 - right away
50:11 - here we are back in the project and
50:13 - inside of settings
50:15 - we have editor data which is a
50:18 - dictionary that contains other
50:19 - dictionaries and the key is always the
50:22 - index and then we have the dictionary
50:23 - with lots of information
50:25 - in here we have 0 and 1 those two are
50:29 - going to be ignored because 0 is the
50:30 - player and one is the handle for the sky
50:33 - those two are always going to be inside
50:35 - of the editor so we don't have to create
50:37 - them
50:38 - however from 2 to 18 we have objects
50:42 - that the player can actually create
50:44 - for example two would be terrain you can
50:46 - see it here then we have water then we
50:49 - have different kinds of coin for example
50:51 - we have a gold coin a silver coin and a
50:53 - diamond
50:55 - then we have a bunch of enemies a bunch
50:58 - of foreground palm trees and a bunch of
51:00 - background palm trees all of these
51:02 - things we have to account for so let's
51:05 - get started inside of the editor and let
51:07 - me minimize everything so it's a bit
51:09 - easier to follow
51:10 - right now I want to work inside of the
51:13 - init method and in here I want to add
51:15 - another section let me add a comment
51:18 - that I call selection
51:20 - for now all I want is self.selection
51:23 - index by default this one is going to be
51:26 - let's say 2 for terrain now that we have
51:29 - that we have to create the menu and the
51:32 - hotkeys to change this selection index
51:34 - the hotkeys are going to be easier so
51:37 - let's do it right away and this is going
51:38 - to be another method in the input
51:40 - section in here I want to have let's
51:43 - call it selection or keys
51:47 - we need itself and besides that we also
51:50 - need the event all we really have to
51:53 - check in here is if the event DOT type
51:56 - is equal to pygame dot k down this means
52:00 - we are checking for any kind of keyboard
52:02 - input in here I want to check if the
52:05 - event dot key is equal to pygame dot k
52:09 - underscore right so we are pressing to
52:11 - the right and if that is the case I want
52:14 - to set self dot selection index and
52:17 - increase it by one
52:19 - then I can do the same thing for the
52:21 - left key so if event dot key is equal to
52:25 - pygame dot k underscore left
52:28 - and if that is the case let me duplicate
52:30 - the line
52:31 - this should be minus equal one
52:34 - since the event type only checks if we
52:36 - are pressing a button and not if we're
52:38 - holding down a button we also don't need
52:39 - a timer in here which makes all of this
52:41 - quite a bit easier to work with although
52:44 - there's going to be one issue let me
52:46 - print what we get at the end of this so
52:48 - print self dot selection index and also
52:53 - don't forget to call this thing I want
52:55 - self.selection
52:58 - not index but hot keys and we have to
53:01 - pass the event in here
53:03 - if I run all of this now we're not
53:05 - getting an error and you can see two in
53:07 - the bottom left if I now press to the
53:09 - right we get higher numbers and if I go
53:12 - down we get lower numbers so this is
53:14 - working really well however I can go
53:16 - below zero and I can also go above 18.
53:21 - like so and if we try to use those keys
53:24 - inside of the dictionary we would be
53:25 - getting an error which means I want to
53:29 - limit the numbers we can get from this
53:32 - one here
53:33 - so that the lowest number is a two and
53:36 - the highest number is an 18. and that
53:38 - could be a really good exercise for you
53:40 - so pause the video and limit the numbers
53:43 - to a range of 2 to 18. it should be
53:46 - doable on a single line of code
53:50 - I first of all want to Target myself dot
53:53 - selectionindex after I have done all of
53:56 - this let's get started with the smallest
53:58 - number and this we get with the Min
54:00 - function this one takes two arguments
54:02 - and it always selects the lower one in
54:05 - my case this would be self dot selection
54:07 - not hot keys but
54:10 - index and 18.
54:14 - with this line already selection index
54:16 - can never exceed 18. let's try actually
54:19 - by printing
54:20 - self.selection index and run out of this
54:23 - again and now if I go further and
54:25 - further to the right I can never exceed
54:28 - 18.
54:29 - so this one is working now we just have
54:32 - to cover the minimum so that we can
54:34 - never go below 2. and for that I want to
54:37 - put this function inside of a Max
54:41 - function this one also takes two
54:43 - arguments and it always selects the
54:45 - larger one which means if I have my
54:48 - minimum and I add a 2 in here
54:51 - if this Min now goes below 2 we're
54:54 - always selecting the larger number which
54:56 - is the two as a consequence we can never
54:59 - go below 2. which means if I run out of
55:02 - this again I can go to the left
55:04 - and the number doesn't go below 2 and if
55:06 - I go to the right the number increases
55:08 - but only up to 18. so this is working
55:12 - really well cool
55:14 - with that we have some basic hotkeys
55:17 - let me get rid of the print statement we
55:20 - don't need it anymore
55:21 - and we can minimize all of this as well
55:25 - next up we have to work on the menu and
55:28 - this is going to be a larger part so I
55:31 - want to put all of this in a separate
55:32 - file
55:33 - let me create a new file
55:35 - I will save this one as menu dot pi in
55:39 - here I want to import Pi game
55:42 - and just as before let me copy it
55:44 - actually I need all of the stuff from
55:47 - the settings
55:48 - once I have that I want to create a new
55:51 - class called menu no need for
55:53 - inheritance but we do need it under a
55:56 - niche method and here we need self and
55:58 - nothing else now first of all we need to
56:02 - be able to draw on the display surface
56:04 - so we need to display surface which we
56:06 - get with self.display surface or name it
56:09 - whatever you want and here we need
56:12 - pygam.display.get underscore surface
56:15 - once we have that I want to create two
56:19 - more methods the first one let's call it
56:21 - create buttons
56:23 - itself and nothing else and for now this
56:26 - is just going to be a pass besides that
56:28 - I also want to create a method that I
56:32 - called display
56:34 - in here once again we need self and
56:36 - nothing else at least for now
56:39 - and this display is what we're going to
56:41 - call
56:42 - to run the actual menu
56:45 - let's do it right away actually so
56:47 - inside of the editor I want to from menu
56:50 - import menu
56:52 - next up I have to create an instance of
56:55 - this object
56:56 - don't forget to comment things properly
56:58 - and let's call it menu is going to be
57:01 - menu
57:03 - finally to actually show the menu inside
57:06 - of the run method all the way at the
57:09 - bottom I want self dot menu dot display
57:13 - right now if I run all of this we cannot
57:16 - see anything because the menu doesn't
57:18 - print anything but at the very least
57:21 - we're not crashing so that's a good
57:22 - start now we can start working inside of
57:25 - the menu class and actually do something
57:28 - the first thing I want to do is to
57:30 - create a general area for the menu
57:33 - let's say this here is the entire
57:35 - display surface and what I want is in
57:38 - the bottom right a square that contains
57:41 - smaller Square this red square is the
57:44 - entire menu inside of it we have a
57:46 - couple of smaller squares and those are
57:49 - the things the player actually clicks on
57:51 - and the red thing is what we're going to
57:53 - create right now
57:55 - let me add a comment here as well and
57:57 - let's call it menu area General
58:01 - first of all I want to create two
58:03 - variables the first one is the size of
58:06 - the menu in general and that I have set
58:08 - to 180 pixels and then I want to have
58:11 - margin and this I've set to 6 pixels
58:14 - I suppose both of those numbers are
58:16 - fairly self-explanatory once I have them
58:19 - I want to create self.rect
58:22 - and this is going to be the area of the
58:24 - entire menu this is just going to be a
58:27 - normal python rectangle enter here we
58:30 - need a left a top a width and a height
58:33 - the width and the height are both fairly
58:36 - easy because they are just going to be
58:37 - the size
58:38 - for the left side let me explain how
58:41 - this is going to work actually once
58:43 - again we have the entire display surface
58:47 - and inside of that we have the menu
58:51 - the size of the menu so this Dimension
58:53 - here and this Dimension here is going to
58:56 - be the size and this is what we have
58:58 - done already
58:59 - next up I want to have a margin and the
59:03 - margin is going to be this distance here
59:05 - and this distance here and this
59:08 - shouldn't be too difficult of a thing to
59:10 - implement so I think this could also be
59:12 - a pretty good exercise try to figure
59:14 - this amount yourself and see how far you
59:16 - get you have to set the left and the top
59:19 - meaning this point here to get this kind
59:22 - of margin on the right and on the bottom
59:25 - try to figure this one out and see how
59:27 - far you get
59:29 - let me get rid of the drawing and
59:32 - basically all we have to do first of all
59:34 - I need the window with from that I want
59:37 - to subtract the size and from that I
59:41 - also want to subtract the margin
59:43 - if I draw on all of this again basically
59:46 - what we have done
59:47 - let me scroll down a tiny bit so now you
59:49 - can see it better
59:51 - when the width is this point here then
59:54 - the size is going to be this area here
59:57 - and the margin is going to be this bit
60:00 - here meaning if we subtract the two from
60:03 - the other we are getting to this point
60:06 - here this bit which is exactly what we
60:09 - need for the left side of this rectangle
60:11 - once we have that the top shouldn't be
60:14 - too difficult all we have to do is copy
60:17 - all of this and for the top I want to
60:21 - have not the window width but the window
60:22 - height and this is going to be really
60:26 - hard to read so let me put it in
60:28 - separate variables for the top left I
60:31 - want to have all of this
60:34 - and I can just paste it in here
60:37 - since this is now a tuple we need a
60:40 - position Tuple and a size Tuple meaning
60:43 - the size has to be inside of another
60:44 - Tuple otherwise pygame gets confused
60:48 - you'll either need two tuples for the
60:50 - position and the size or you need four
60:52 - numbers for the left the top the width
60:54 - and the height both are okay but well
60:56 - you can't mix them
60:58 - if I now run this we're not getting an
61:01 - error so that's a good sign
61:03 - to actually see something now I can run
61:06 - pygame dot draw dot rect now we need a
61:10 - surface so self dot display surface
61:14 - then we need to color that one doesn't
61:16 - matter let's go with red and finally we
61:19 - need the rectangle self.rect
61:21 - finally before we can start we have to
61:24 - call create buttons which we do with
61:26 - self dot create buttons
61:28 - and now if I run this you can see in the
61:31 - bottom right we have a menu and this one
61:33 - stays on top of the level so it doesn't
61:35 - move around which is exactly what I want
61:39 - now that we have that we have to create
61:42 - the button areas
61:45 - and let me get rid of the general it's
61:47 - not needed
61:49 - and it kind of annoyed me I want to
61:52 - create four rectangles that go inside of
61:54 - the menu
61:56 - meaning if this one here is the menu I
62:00 - want to have four smaller rectangles
62:02 - inside of this larger box on top of that
62:06 - between the buttons there should be some
62:08 - margins so we do have to be careful with
62:11 - the numbers here the easiest way I found
62:14 - to work with this is to first of all
62:16 - create a generic button rectangle since
62:21 - all of the buttons have the same size we
62:23 - can just create this rectangle once and
62:25 - then copy it and move it in different
62:27 - positions
62:28 - meaning once again I want to create a
62:30 - pygame rectangle in here we need a
62:34 - position and a size the position is
62:38 - actually quite simple because all I want
62:40 - to do is
62:41 - self.rect.top left
62:43 - which means if I am drawing again
62:48 - the position we are looking at right now
62:49 - is this point here and the first
62:52 - rectangle we are creating is right on
62:55 - this point
62:56 - next up we have to make sure that we
62:59 - have a rectangle that is one quarter of
63:02 - the size of this entire box we're going
63:04 - to shrink that in just a second for now
63:06 - I want to keep the number simple so for
63:09 - the size
63:11 - I want to have a tuple with self.direct
63:14 - DOT with divided by two and besides that
63:19 - self.direct dot height
63:21 - divided by two
63:23 - with that we have a generic button
63:26 - rectangle or we almost have one that
63:28 - works let me turn it into an attribute
63:31 - so now we can draw it that makes the
63:33 - entire thing easier to see self dot
63:36 - generic button rectangle and this
63:38 - shouldn't be red let's go with green
63:43 - if I run this now we can now see we have
63:45 - a green rectangle inside of the larger
63:47 - rectangle that's a pretty good start but
63:50 - not ideal
63:53 - the problem we have right now is that
63:55 - this rectangle is a tiny bit too large
63:57 - if we had four of these rectangles they
64:00 - would fill out the entire menu rectangle
64:02 - perfectly since I do want to have
64:04 - margins this is not ideal
64:06 - as a consequence
64:09 - let me create another variable let's
64:12 - call it button margin
64:15 - and this in my case I've set to 5. also
64:18 - this generic button rectangle shouldn't
64:21 - be an attribute and this I also want to
64:24 - comment out at least for now
64:26 - we now have a generic button rectangle
64:28 - and we have a button margin with those
64:31 - two things we can actually create the
64:33 - first rectangle and this one is going to
64:35 - be an attribute
64:37 - and now I have to create four different
64:39 - areas for the specific kinds of buttons
64:42 - the first button area I want to create
64:44 - is the tile button let's call it rect
64:48 - all I want to do here is get the generic
64:50 - button rectangle and create a copy of it
64:54 - and just to see what is going on let me
64:56 - copy the entire thing and paste in
65:00 - the tile button rectangle if around all
65:02 - of this you cannot see any difference
65:04 - because we have copied a rectangle so
65:07 - nothing has changed yet
65:09 - however what we can do now
65:11 - is to run the inflate method on this
65:13 - rectangle in here we need an X and A Y
65:16 - position by how much we want to increase
65:18 - or decrease the size of the rectangle in
65:21 - my case I want to shrink this rectangle
65:23 - by the negative button
65:26 - margin both for the X and for the Y
65:30 - if I now run this again
65:33 - there is a tiny gap on the top left
65:37 - so we can see this is working the
65:39 - rectangle has shrunk in all four
65:40 - directions
65:42 - the reason why this is really useful is
65:44 - because the original rectangle was
65:46 - something like this and we were right up
65:49 - in the top left
65:51 - and this rectangle we have now shrunk in
65:53 - all four different directions by keeping
65:56 - it centered on this position here
65:58 - that makes it really easy to place this
66:01 - area and not have to worry about the map
66:03 - of positioning to get exactly the right
66:06 - area here and the right area here I hope
66:09 - that makes sense
66:10 - you're going to see in a second how this
66:12 - is really helpful
66:14 - so with that we have the first button or
66:17 - button area next up I want to create
66:20 - this one I called the coin button
66:25 - wrecked
66:27 - and here once again
66:28 - I want to get the generic button
66:30 - rectangle and create a copy of it
66:34 - although for this one I want to move it
66:38 - in here we have to give X and Y values
66:41 - to tell Pi game by how much we want to
66:43 - move this rectangle
66:45 - since the coins are going to be right
66:47 - next to the tiles we're not going to
66:49 - move the X position at all
66:51 - however what I do want once again if
66:55 - this is the entire menu and right now
66:59 - we have this array here already covered
67:01 - that is the tile button rectangle
67:04 - what I want to do next is for this coin
67:08 - button rectangle to move it right here
67:12 - which means since we right now have a
67:14 - copy of this original rectangle we want
67:16 - to move this point here to this point
67:19 - here which is exactly in the midpoint of
67:23 - this self.rectangle
67:25 - which means all we have to do
67:28 - is move this rectangle by itself dot
67:32 - rect dot with divided by two once I have
67:36 - that I can copy the drawing logic here
67:39 - and now I want to draw self dot coin
67:43 - button rectangle with a different color
67:45 - let's go with blue
67:47 - if I now run this you can see that I
67:50 - made a mistake because I confused the X
67:53 - and the Y position
67:55 - since the coins are supposed to be on
67:57 - the right side of the tiles I want to
67:59 - move
68:00 - only the X and not the Y let me cut it
68:04 - out and paste 0 in here and this one
68:07 - should be self.rect dot height divided
68:10 - by 2 and 0. now if I run this again this
68:12 - is looking much better
68:15 - all I have to do now is to call the
68:17 - inflate method let me actually copy it
68:19 - from here
68:21 - and paste it in there and now we should
68:24 - be good to go and there we go this is
68:26 - looking really good
68:28 - and I hope now you can see by using the
68:31 - inflate method here is really useful it
68:34 - allows us to create a rectangle that is
68:36 - exactly one quarter of the original
68:38 - rectangle size and then once we have the
68:41 - better position we can shrink it to have
68:44 - a tiny bit of margin
68:46 - all we have to do now is to copy this
68:48 - thing two more times
68:50 - we have an enemy button rectangle and we
68:54 - have a palm button rectangle
68:56 - The Palms I have in the bottom left and
69:00 - this is the area we have already seen
69:02 - I can just
69:04 - add a 0 for x and for y I want to have
69:08 - self.rect dot with divided by two and
69:12 - let me draw all of them so it's a bit
69:14 - easier to follow right now I have the
69:16 - pump button rectangle if I run this now
69:19 - you can see another area in the bottom
69:21 - left
69:22 - I guess I should change the color let's
69:25 - go with yellow
69:27 - you can see we have another rectangle
69:30 - and finally
69:32 - we need the enemy button rectangle this
69:35 - one is in the bottom right which means
69:37 - we need self.directed height divided by
69:39 - two and on top of that we also need
69:41 - self.rect.wiff divided by two as well so
69:44 - let me copy it and paste it in here
69:47 - and now the last thing I have to do is
69:50 - to draw the final thing as well or enemy
69:53 - button rectangle for the color here a
69:56 - color we haven't used yet let's go with
69:58 - brown
69:59 - and finally we have all four rectangles
70:02 - and this is looking really nice
70:05 - it looks even better if you don't draw
70:07 - the original rectangle let me comment it
70:10 - out
70:11 - and there we go now we have different
70:13 - areas for the buttons that we want to
70:15 - create so this is working very well
70:19 - now that we have all of that we need to
70:23 - actually fill these areas with an actual
70:25 - button and for that I'm going to create
70:28 - a whole separate class that I called
70:30 - button
70:33 - and this is going to be a Sprite Which
70:35 - means this one has to inherit from
70:37 - pygame dot Sprite dot Sprite
70:40 - and inside of that we need it done there
70:43 - in it method and then here we need a
70:45 - couple of different things besides rect
70:47 - we need the rectangle so the area we
70:50 - want to use then we need a group so what
70:53 - group this button Sprite should be part
70:55 - of
70:56 - and finally we need items and besides
70:59 - that I also want items alternative
71:02 - although items alternative by default is
71:05 - going to be none
71:07 - the reason here is when we have the palm
71:10 - trees we have the foreground and the
71:12 - background ones the foreground ones are
71:14 - going to be the items while the
71:16 - background ones are going to be the
71:17 - alternative ones and if you middle click
71:19 - on the Sprite it is going to switch
71:21 - between the two that felt like a good
71:23 - system to handle all of this but no
71:25 - other button is going to have
71:27 - alternative items unless you want to add
71:29 - some yourself but that's something
71:30 - Beyond this tutorial
71:32 - now once we have all of that the first
71:34 - thing we have to do is to create a super
71:37 - thunder in Niche method and pass in the
71:40 - group in here
71:42 - next up we have to create self.image and
71:46 - this is going to be a plain pie game dot
71:49 - surface with the size of the rectangle
71:53 - the rectangle that we have created up
71:55 - here for each individual button besides
71:58 - that we also need self.rect for each
72:00 - individual Sprite and this is just going
72:03 - to be the rectangle besides that we have
72:06 - to capture all of the items
72:08 - and this is going to be a dictionary
72:11 - that I called self.items in here we have
72:14 - the main ones and this is going to be
72:16 - items ideally spelled correctly and then
72:19 - we have the alternative ones and this is
72:22 - going to be items alternative besides
72:25 - that I also want to have self.index
72:28 - which by default is going to be 0 and
72:30 - self dot main underscore active which by
72:34 - default is going to be true
72:36 - main.active is going to decide if we are
72:39 - in the main ones or in the alternative
72:41 - ones
72:42 - and index is just going to tell us which
72:45 - item we are on you're going to see in a
72:47 - second how that is going to work however
72:49 - first of all we do have a problem we
72:52 - have to import a bunch of items and
72:54 - alternative items and that is going to
72:57 - be a bit more extensive and for that I'm
73:00 - going to create a separate method that I
73:03 - called create data itself and nothing
73:07 - else in here and all of this is going to
73:10 - be stored inside of self dot menu
73:13 - surfaces but now it's going to be an
73:16 - empty dictionary
73:18 - and let's have a look what we are
73:19 - actually going to import
73:21 - inside of settings we have this editor
73:24 - data dictionary with a ton of different
73:27 - things
73:28 - and let's have a look at the terrain for
73:30 - now in here we have a style we have a
73:33 - type we have a menu and then we have a
73:37 - menu surface the menu surface is really
73:40 - important and this we have for a lot of
73:43 - different elements
73:44 - all of them besides the player and the
73:47 - sky because those are not supposed to be
73:49 - in the menu also note here this is just
73:52 - going to be a path it is not a surface
73:55 - which means we have to use this path to
73:57 - create an actual surface
73:59 - and that is what we are going to do now
74:02 - for that first of all I want for key and
74:07 - value in editor data Dot
74:11 - items
74:13 - don't forget to call it
74:15 - and let me just print what we get so we
74:17 - have a key and we have a Vel U
74:22 - don't forget to call it and really
74:24 - important here
74:25 - self.create data needs to be called
74:28 - before created buttons because we need a
74:31 - data to create the buttons properly in
74:33 - just a bit
74:33 - but now if I run all of this
74:36 - and extend this one here
74:40 - where you can see we have a ton of
74:42 - different things we have the index and
74:45 - we have a dictionary with the stuff we
74:47 - have seen earlier so for example for the
74:49 - player we have seen this one here
74:52 - and the first thing we have to do in
74:54 - here is to check if
74:57 - each particular item even has a menu
75:00 - surface if it doesn't have one we just
75:02 - want to ignore it
75:04 - which is quite easily done all we need
75:06 - to do if I get rid of the print
75:08 - statement I want to check if value
75:12 - and menu exists in the first place that
75:16 - is this one here
75:18 - you could also check for the menu
75:19 - surface both would be fine
75:22 - and here you can see that the player
75:24 - doesn't have a menu and the sky also
75:27 - doesn't have a menu
75:28 - once I have checked that
75:32 - essentially what I want to create is a
75:35 - key value pair that is going to be
75:37 - inside of this dictionary the key is
75:40 - always going to be the menu entry here
75:43 - for example for these two elements here
75:45 - I want to have one key that's called
75:48 - terrain and attached to this key are two
75:51 - surfaces the surfaces from this one here
75:54 - and the surface from this one here
75:56 - it is always going to be one individual
75:58 - surface
76:00 - which means what I want to do is
76:03 - if not
76:06 - value
76:07 - and menu
76:11 - in self dot menu serves
76:15 - and if that is the case I want to create
76:18 - a new entry inside of this dictionary so
76:20 - self dot menu serves
76:23 - and then I want to get my value
76:27 - menu
76:29 - and for now let me just add an empty
76:31 - dictionary
76:32 - and this is probably confusing so let me
76:35 - print what we actually get self dot menu
76:37 - surfaces
76:39 - if I run all of this now
76:43 - we are getting a couple of keys with an
76:46 - empty Tuple as the value we have terrain
76:49 - oin enemy Palm foreground and palm
76:52 - background if I look at settings
76:55 - you can see we have terrain we have the
76:58 - coin we have the enemy and then we have
77:02 - Palm foreground and palm background
77:05 - and essentially what I now want to do is
77:08 - for example for the terrain I want to
77:10 - have this graphic here and this graphic
77:12 - here as a tuple associated with this
77:15 - terrain key and this is what I am going
77:17 - to pass into each of the buttons
77:20 - these buttons here as the items
77:25 - which means first of all I want to
77:27 - create a list inside of a tuple because
77:29 - I want to add more elements inside of
77:32 - this I want to run pygame dot image.load
77:35 - however we have already seen this inside
77:37 - of main.pi typing
77:40 - pygame.image.load is kind of cumbersome
77:43 - so I'm going to copy this from Main and
77:45 - paste it in here so now I only have to
77:48 - type load
77:49 - makes my life a bit easier
77:52 - and what I want to load is the current
77:54 - value we have and then the menu surface
77:58 - that is going to be this file here
78:02 - although now this Surface by itself
78:04 - isn't going to be enough but I guess for
78:07 - now let me run the entire thing and see
78:09 - if it works
78:10 - there we go
78:11 - at least it didn't crash so it has to
78:13 - start now for terrain we have one entry
78:17 - as a matter of fact for all of these we
78:19 - always have one entry which isn't ideal
78:21 - because in settings for example for
78:23 - terrain we have two entries and right
78:27 - now we are checking if Terrain is not
78:30 - inside of this surface and if it is not
78:33 - in there so this if statement here then
78:36 - we are creating a new entry
78:38 - the problem with that is once we come to
78:40 - the next entry that has the same menu
78:43 - then we are just going to ignore it and
78:46 - this we have to account for
78:48 - meaning I want to add an else statement
78:50 - if we already have this entry and if
78:53 - that is the case I can actually just
78:55 - copy this entire thing
78:58 - I want to append something to the list
79:01 - we already have this list we created
79:03 - just now and what I want to append
79:07 - is the same thing
79:09 - and now if I run this again
79:13 - we get for example for terrain two
79:15 - surfaces one surface for the terrain and
79:18 - one surface for the water
79:20 - although we do need one more thing right
79:23 - now we only have the graphic but we need
79:26 - a bit more information we have to know
79:28 - for each graphic the associated key for
79:32 - example for terrain we need to know the
79:34 - two because this is how we identify each
79:37 - individual graphic
79:38 - that is quite easy all you have to do is
79:41 - turn this surface into a tuple that
79:43 - right now contains only a surface but I
79:46 - also want to add the key here this I
79:48 - also want to do in the else statement
79:51 - when I append the value and now I want
79:55 - the key in here
79:56 - and now if I run this again
80:00 - we for example get for Terrain we have a
80:03 - tuple with two and the terrain surface
80:06 - and then we have three and the water
80:08 - surface for coin we have another list
80:13 - with a tuple and this one is a four and
80:15 - then we have a surface with the gold
80:16 - coin
80:17 - and that is actually all we needed so I
80:20 - can get rid of the print statement and
80:23 - minimize the entire method
80:25 - and now inside of create buttons I can
80:29 - actually create the
80:32 - buttons
80:34 - although first of all for that we need a
80:37 - group for the Sprites this one is really
80:39 - easily created all we need
80:42 - let me actually do it inside of the
80:43 - buttons that makes a bit more sense in
80:45 - here I want to have self dot buttons and
80:49 - this is just going to be
80:49 - pygame.sprite.group
80:52 - and now I can create individual buttons
80:55 - for example the first button
80:58 - just button is going to have a couple of
81:01 - arguments these four here
81:04 - or the rectangle first of all we need
81:06 - self
81:08 - tile button rectangle the group is going
81:12 - to be self dot buttons the items is
81:15 - going to be self dot menu surfaces and
81:19 - in here I want to have the terrain key
81:22 - finally for the alternative items I can
81:24 - just ignore the entire thing and this is
81:28 - going to be the first button now I can
81:30 - copy the entire thing and I think this
81:33 - is going to be a really good exercise
81:34 - for you to see if you can still follow
81:36 - along because the Imports I think did
81:40 - get a tiny bit confusing so definitely
81:43 - work with this and well try to create
81:46 - the other three buttons so we have all
81:48 - four buttons and see if we can figure
81:50 - this one out yourself
81:54 - let me actually copy it two more times
81:56 - and first of all besides the tile we
81:59 - also need the coin button rectangle this
82:02 - one is in the same group although for
82:04 - the surfaces we don't need terrain we
82:06 - need coin let's work on the enemy button
82:09 - rectangle this one again same group but
82:12 - for the surfaces we need this one I
82:16 - called enemy
82:18 - inside of settings you can see here we
82:21 - have the enemy finally we need the Palm
82:23 - button rectangle and this one is going
82:26 - to have items and the alternative items
82:28 - for the items this one is called Palm FG
82:32 - and this I have gotten from here and
82:35 - besides that we have Pawn BG and this is
82:37 - the alternative item here so I can just
82:40 - copy the entire thing and this one
82:42 - should be Palm
82:44 - BG
82:45 - and with that we can minimize create
82:47 - buttons because we don't need it anymore
82:49 - although let me run the entire thing and
82:52 - nothing is crashing that's usually a
82:55 - good sign
82:56 - right now we can work inside of the
82:59 - button in here first of all we need some
83:03 - kind of update or display method this
83:05 - one actually displays what we have
83:07 - inside of the Sprite first of all in
83:10 - here I want to have self dot image dot
83:13 - fill
83:14 - and for the fill now we need a color
83:16 - that color we're getting from settings
83:19 - and in here we have button BG color and
83:22 - button line color
83:24 - right now I want button BG color and
83:27 - this I want to pass in here next up we
83:31 - have to create a surface and a rectangle
83:34 - from the items or the alternative items
83:37 - and this information we are then going
83:39 - to use for
83:41 - self.image.blit and we are going to
83:43 - Blitz the surface and the rectangle the
83:47 - best way to think about it is that the
83:48 - actual Sprite with the image and the
83:50 - rectangle this is just going to be the
83:53 - background which means we are just
83:55 - filling it with a simple color but on
83:58 - top of this Sprite we're going to Blitz
84:00 - another surface and this surface is
84:02 - going to come from the items or the
84:04 - alternative items
84:05 - which means
84:07 - for now this is just going to be self
84:09 - dot items and then here for Simplicity
84:13 - I'm just going to work with the main
84:14 - ones for now these ones here actually
84:16 - just to make this a bit simpler
84:19 - let me print what the surface is going
84:21 - to be so print
84:23 - surface
84:24 - and now I can copy out all of this
84:30 - and instead I can run self dot buttons
84:35 - dot update
84:37 - and self dot buttons dot draw and in
84:41 - here we need self.d display surface
84:45 - if you have forgotten
84:46 - the buttons are just going to be a
84:48 - Sprite group and this has the methods
84:52 - for update and draw so we don't have to
84:54 - worry about it
84:56 - if I run this now you can see four
84:59 - different squares and besides that we
85:01 - can see a very long list and this is
85:04 - always going to be a list
85:06 - and inside of the list we have a tuple
85:09 - with the relevant surfaces this is what
85:12 - we actually want to draw on top of the
85:14 - Sprite Which means
85:16 - in here I first of all want to get the
85:19 - self Dot
85:20 - index
85:22 - the one we have created up here and by
85:24 - default this one is always going to be
85:25 - zero with that we are returning a tuple
85:28 - with the index of the graphic so if I go
85:32 - up a tiny bit
85:34 - this one here and then we have the
85:35 - actual graphic the one we imported here
85:37 - for example
85:38 - since we only want the graphic I want to
85:41 - use indexing again with a 1 so we're
85:43 - only picking the graphic with that we
85:45 - have a surface
85:47 - now that we have a surface
85:50 - I also want to create a rectangle a
85:52 - rectangle is quite simple I just want to
85:54 - get the surface and get underscore rect
85:57 - for this one I want to place this Center
86:00 - although for the center here you might
86:02 - be tempted to run something like
86:04 - self.rect.center
86:06 - that would not work and let me explain
86:09 - why it's really important to understand
86:11 - the rectangles here if this is the
86:14 - entire display surface and the menu is
86:17 - somewhere down here with one item inside
86:20 - of the menu being here
86:23 - what we want to do is to draw one
86:26 - surface inside of the center of this
86:29 - individual button which means we want to
86:32 - go
86:33 - half the width of this button and have
86:36 - the height of this button so that we end
86:38 - right in the center of this button the
86:42 - problem is if we used
86:44 - self.rect.center we will get the global
86:47 - position of this rectangle which would
86:50 - be a problem here because the origin or
86:52 - the local origin is this point here and
86:54 - if we use self.direct.center we would
86:57 - move this point here by this distance
87:00 - and this distance which would be way too
87:04 - much instead what we need we need a
87:07 - tuple
87:09 - with
87:11 - self.rect.wiff divided by two and
87:14 - self.rec Dot height divided by two and
87:18 - now if I run this this is looking really
87:22 - really nice
87:23 - so what you really have to understand
87:24 - here why all of this works is you have
87:27 - to imagine that this is the origin point
87:28 - for the surface we are currently drawing
87:30 - on and we only want to go a tiny bit to
87:33 - the right and a tiny bit downwards to
87:35 - get the center of this point
87:38 - if we used self-directed Center we would
87:41 - get the distance
87:43 - all of this distance here
87:47 - which would be way too much
87:49 - understanding the global and the local
87:51 - area for rectangles is really important
87:53 - this is definitely something you want to
87:55 - practice if you want to get really good
87:56 - at Pi game
87:58 - all right with that we can see what we
88:00 - are doing what we now have to figure out
88:03 - is how to actually change the item or
88:06 - more specifically self.index this is
88:09 - going to happen inside of menu in here I
88:12 - want to create another method that I
88:15 - called click this one needs self we need
88:18 - position and we need a button
88:22 - how this click is going to work for now
88:25 - just so that something is working I want
88:28 - to print
88:29 - menu
88:31 - click
88:33 - this click method here is going to be
88:36 - called from inside of the editor
88:39 - which means inside of input I want to
88:42 - create another method
88:44 - this one I called menu underscore click
88:48 - for this one we need itself and we need
88:51 - the event once more what I want to check
88:53 - in here is if event DOT type is equal to
88:57 - pygame dot mouse button down and self
89:02 - dot menu dot rect dot Collide point
89:08 - with my mouse position essentially in
89:11 - here I am checking if I'm pressing the
89:13 - mouse button and if I'm pressing on the
89:16 - menu
89:16 - if that is the case I want self.menu dot
89:21 - click
89:22 - and for this one
89:24 - we need two arguments the position of
89:26 - the mouse and the button that we have
89:28 - pressed with the mouse which we can get
89:31 - very easily we need the mouse position
89:34 - and we need the mouse buttons the naming
89:38 - here might be a tiny bit confusing when
89:40 - I talk about buttons here I mean the
89:42 - mouse button let me actually change it a
89:44 - tiny bit Mouse button and I guess Mouse
89:48 - position you could also Import
89:51 - pygame.mouse in here and get the
89:53 - information from there but I think doing
89:55 - it like this is a bit cleaner
89:57 - now that we have that what I want to do
90:00 - first of all I want to check if we're
90:03 - actually clicking on any of the buttons
90:05 - so for sprite and self dot buttons
90:10 - if Sprite dot direct dot Collide point
90:14 - with the mouse position
90:16 - then I know print let's say button
90:20 - pressed
90:22 - let's try and now I can click on any of
90:25 - the buttons and nothing is happening and
90:28 - the reason why nothing is happening
90:29 - because I'm not calling Mouse click this
90:32 - once again happens inside of the event
90:34 - Loop in here self Dot menu click don't
90:39 - forget to pass in the event and now
90:41 - let's try this again if I now click on
90:43 - any of the buttons with any Mouse button
90:45 - we get button pressed
90:47 - which means all of this is already
90:49 - working at least to an extent
90:51 - in here now I have to check for the
90:54 - different Mouse buttons so if Mouse
90:57 - button and one
91:00 - this would be the middle Mouse click
91:04 - besides that we have if Mouse button two
91:09 - then this would be a right
91:11 - click however I do not want to have if
91:15 - Mouse button 0. the reason for that is
91:19 - if I click on the button with any of my
91:22 - mouse buttons so left right or middle
91:24 - Mouse button I always immediately want
91:27 - to select the current item imagine my
91:29 - terrain button in there I have terrain
91:31 - and water if I left click on it to
91:34 - switch to water I want to immediately
91:36 - select water as a consequence even if I
91:39 - right click on the button I want to
91:40 - select the new item as a consequence
91:43 - there's not going to be if Mouse button
91:45 - 0 instead I want to return
91:49 - a Sprite and then get ID this one
91:53 - doesn't exist yet but but we're going to
91:56 - create it in just a second first of all
91:58 - though
91:59 - inside of menu click
92:03 - I want to save
92:04 - self.selection index and storing it
92:08 - whatever we get from menu click and from
92:11 - when you click we're getting the current
92:13 - Sprite ID which is going to be
92:16 - any of these numbers here for example if
92:19 - we're clicking on land we are getting a
92:21 - number two the logic here does get a
92:24 - tiny bit more complicated I hope it
92:25 - still makes sense
92:27 - let's start by implementing get ID this
92:30 - one should be fairly simple inside of
92:32 - the button
92:33 - I want to create another method get
92:35 - underscore ID in here we need self
92:38 - and all I want to do is I want to return
92:42 - self dot items and now I first of all
92:46 - have to know if I am in main or in Alt
92:50 - this is quite easy to do I am in main if
92:53 - self dot mainactive else
92:57 - alternative
93:00 - this main is going to toggle if we are
93:02 - in main or alternative and this is what
93:05 - I'm checking with here
93:06 - which means self.items is the entire
93:09 - dictionary and with this line here we
93:13 - are either selecting items or items
93:15 - alternative
93:16 - which means we have a new list and from
93:19 - this list I want to get self.index which
93:22 - is once again going to give me a tuple
93:24 - with a key and a surface
93:27 - from this one I want to get the index 0.
93:30 - this is very similar compared to what we
93:32 - have done down here except now we don't
93:34 - get a Surface we get a key
93:37 - while we are here I can also copy all of
93:40 - this
93:41 - and paste it in here it is the exact
93:44 - same logic and with that inside of the
93:49 - editor I can look at my run method and
93:52 - let me print
93:53 - self.selection index
93:56 - if I run main.pi again
93:58 - we're getting an error that we have
94:01 - expected into the block after an if
94:02 - statement on line 46. that happens
94:05 - inside of menu and the problem is I
94:07 - should have added a pass in here Pass
94:10 - and Pass and now let's try this again
94:13 - right now our index is 2 if I click on
94:16 - the coins we have 4 11 and 7.
94:19 - so this is already working not all too
94:23 - badly we are definitely making progress
94:26 - what we now need is the middle Mouse
94:28 - button and the right click the middle
94:30 - Mouse button is the easier actually
94:32 - because all I have to do in here is
94:34 - Sprite dot main active
94:37 - is going to be
94:39 - not Sprite dot main active that way
94:43 - we're just toggling this on and off
94:46 - however this is only the behavior if the
94:49 - Sprite has alternative Sprites which is
94:52 - only the case right now where are the
94:54 - buttons
94:55 - inside of the buttons Only The Palms
94:58 - have alternative items the other three
95:00 - buttons don't
95:02 - and the code right now
95:04 - would crash here because we would have
95:07 - an empty list for the alternative items
95:10 - which we can fix quite easily I only
95:12 - want to have this behavior is Sprite dot
95:14 - items and ALT exists in the first place
95:18 - and if that is not the case this one
95:20 - should be true
95:23 - which means
95:24 - if the Sprite has alternative items then
95:28 - I am switching and toggling them on or
95:30 - off however if the Sprite does not have
95:33 - alternative items this is always going
95:35 - to be true I suppose what you could be
95:37 - doing to make this a tiny bit easier to
95:39 - read
95:40 - you could add the if statement here
95:42 - and
95:44 - then all of this and put else at the
95:48 - bottom
95:49 - and this should be Sprite dot mainactive
95:52 - is going to be true or rather since main
95:55 - active is by default true and we can't
95:58 - change it if there's no alternative item
96:00 - we can just leave it like this let's try
96:03 - this one actually
96:04 - so now if I middle click on the palm
96:07 - trees you can see this one is changing
96:10 - although if I click on anything else
96:12 - nothing is happening besides the
96:14 - selection index changing so this one is
96:17 - working quite well now for the right
96:20 - click I want to get my Sprite and run a
96:24 - switch method
96:26 - that's which method doesn't exist right
96:28 - now so let's create it all we need in
96:31 - here is self and basically what I want
96:34 - to do is self.index is plus equal one
96:37 - which should already work to an extent
96:40 - now if I right click on any of these
96:43 - buttons we get something else although
96:46 - if I keep on clicking for example on the
96:48 - terrain
96:49 - we're getting an error list index out of
96:52 - range for example for the terrain
96:54 - buttons we only have two items so if
96:58 - index gets greater than that we are
97:00 - getting the error that we have an index
97:02 - error to fix that once again we have to
97:05 - limit the index
97:07 - so sell for index is going to be zero if
97:11 - self dot index is greater or equal than
97:14 - the length
97:16 - and now we need to know if we are in the
97:20 - main items or the alternative items
97:22 - which is what we have done a couple of
97:24 - times already so I can just copy it this
97:26 - one here and paste it in there
97:29 - however if that is not the case so else
97:32 - I just want to get myself dot Index this
97:35 - entire line means I want to set
97:37 - self.index to zero if self.index is
97:41 - greater than the length either of the
97:43 - main items or the alternative items
97:45 - however if it is not greater or equal
97:48 - than the length I just want to keep self
97:50 - index as sub index and not make any
97:53 - changes that is all that we are doing in
97:55 - here although I just realized this
97:57 - should be self dot items and then we're
98:00 - indexing on it
98:01 - but now if I run out of this and I right
98:05 - click on any of the buttons
98:08 - we are cycling through
98:10 - the different things that we can do and
98:13 - now for the palm trees if I'm going to
98:15 - click on it and right click we're
98:17 - getting different kinds of palm trees
98:20 - so this is looking really good also if
98:22 - you look in the bottom left we get the
98:24 - different selection indexes
98:26 - I am very happy with that
98:28 - with that I can minimize the buttons and
98:32 - get rid of all of these comments here
98:35 - and the last thing we need I can also
98:37 - minimize the click the last thing we
98:39 - need is
98:41 - a highlight
98:43 - in the cater
98:45 - this one itself and besides that I also
98:49 - want to have an index this method makes
98:51 - sure that it highlights the currently
98:53 - selected button so we have an idea of
98:55 - what we're actually doing
98:57 - in here first of all we have to know
99:00 - what the currently selected rectangle is
99:03 - the easiest way for that I found was to
99:06 - get the editor data again
99:08 - check the index we are currently working
99:10 - on
99:11 - and then I want to check one specific
99:13 - item in here for example I could check
99:16 - if the menu is terrain or coin or enemy
99:19 - and that I think was the best way to
99:22 - approach it I guess you could also go
99:24 - with style but that we're going to use
99:26 - in a bit but now I want to check the
99:29 - menu and if the menu is equal to terrain
99:33 - then I want to draw pygame dot draw Dot
99:38 - rect and here I want to draw on
99:40 - self.display Surface the color we are
99:43 - getting from settings and in here we
99:46 - have the button line color
99:48 - yes I want to pass it here and finally
99:50 - we need a rectangle
99:52 - for the terrain this is going to be the
99:56 - tile button rectangle
99:59 - it's called tile button rectangle by the
100:01 - way because both the water and the
100:03 - terrain are both going to be tiles and
100:05 - they're kind of unique in that respect
100:08 - you'll see later on what that means
100:11 - but now all I have to do is call
100:14 - self.highlight indicator and in here I
100:18 - need the current index
100:20 - which I don't have right now so inside
100:22 - of display I want to have another
100:24 - parameter called index
100:26 - and now inside of the editor I can get
100:29 - rid of this print statement and when I
100:32 - display the menu I want to pass
100:34 - self.selection index into it and now if
100:38 - on all of this you can see that we have
100:41 - highlighted out the terrain so if I
100:43 - click on it you can't see anything
100:45 - but at the very least we know it's
100:47 - working
100:48 - the problem here is that we have to
100:50 - specify a border with with ifset to five
100:53 - besides that there's also border
100:55 - rounding which I have set to four and
100:58 - now if I try this again this is looking
101:00 - at least a little bit better another
101:02 - thing that you can do here is to inflate
101:05 - this rectangle
101:07 - which I do with the inflate method in
101:10 - here again I need X and Y values which
101:13 - I've both set to 4.
101:15 - if I now run this again this is looking
101:17 - much better it's kind of hard to see
101:19 - right now because the background is
101:21 - white but it definitely works
101:24 - I guess inside of the editor I can
101:27 - change the background color to something
101:28 - like Gray
101:30 - and now you can see much better what's
101:32 - going on you can definitely tell the
101:34 - terrain is currently selected same with
101:36 - the water it works the same way
101:39 - all we have to do now is do the same
101:41 - thing for the other three items
101:45 - let me copy the entire thing
101:47 - paste it in here and now I want to check
101:50 - if we're not on terrain but on coin
101:53 - and if that is the case I want to draw a
101:56 - rectangle around the coin button
101:57 - rectangle besides that I can paste this
102:00 - one more time now we have the enemy
102:04 - at least I think that's what it was
102:05 - called
102:06 - if I look at the menu here we have enemy
102:10 - if that is the case I want to have the
102:13 - enemy button rectangle and finally we
102:16 - have to do this one more time and now
102:18 - I want to check if menu
102:21 - is not equal to but inside of a list
102:25 - because the menu here we have to check
102:28 - all of these different items it could
102:30 - either be Palm FG or Pawn BG
102:33 - which means I want to check if the value
102:36 - we currently have selected is either a
102:38 - pawn BG
102:40 - or
102:43 - Pawn FG
102:45 - and with that
102:48 - let's try all of this
102:49 - and now
102:51 - if I select any of them they work except
102:54 - for the pawn tree the problem here I
102:57 - think is that this final rectangle
102:59 - should have been Pawn button rectangle
103:00 - so now if I run this again I can select
103:03 - the different buttons also change the
103:06 - item and this is looking really good
103:12 - cool I'm really happy with that
103:15 - and with that we have finished the
103:18 - entire menu this was once again a larger
103:21 - section but we have made a ton of
103:24 - progress
103:26 - I can actually close the entire menu
103:28 - because we don't need it I think ever
103:30 - again
103:32 - so let me minimize everything and this
103:35 - was one major chunk of the game done now
103:37 - that we can select things I want to
103:39 - start working on creating the tiles that
103:42 - basically means if the player clicks
103:44 - anywhere on the editor we're going to
103:46 - start a position and what the selection
103:48 - index is later on this will be used to
103:51 - draw the entire editor although for now
103:54 - we just work on the input and storing
103:55 - the information let's go over what we
103:58 - have to do number one whenever the
104:01 - player clicks on the editor we have to
104:03 - get the mouse position and convert it to
104:05 - a cell and this cell has to be relative
104:08 - to the origin point
104:10 - think of it like this
104:11 - this one here is the origin point and
104:15 - this one here for example could be the
104:18 - entire map
104:19 - if I for example click here I want to
104:23 - know the distance on the X from the
104:25 - origin and on the Y from the origin if
104:29 - for example this position is inside the
104:33 - First Column with the First Column being
104:35 - 64 pixels and the origin point being at
104:38 - point zero this should be in column 0.
104:41 - you could do the same thing for the
104:42 - y-axis or for the rows if we are
104:45 - somewhere in here then this position
104:47 - should be 0 and 0.
104:50 - however if we are clicking somewhere
104:53 - let's say here
104:55 - then this should be I don't know let's
104:57 - say this is zero this is one this could
105:01 - be two
105:02 - and if I draw another one down here
105:07 - then this would be zero this would be
105:09 - one this would be two which means this
105:13 - cell here
105:16 - would be the cell two and one and that
105:19 - is the information I want to store or
105:21 - that I first have to get on top of that
105:24 - which is really important is that this
105:26 - system has to work with negative numbers
105:28 - because we could get into this direction
105:31 - here and get Negative cells
105:35 - stuff up here for example we could have
105:37 - a cell I don't know what this is but
105:39 - let's say negative 4 and negative 1.
105:42 - these cells we also need to get what is
105:45 - really important about this system is
105:47 - that this origin Point can be moved
105:49 - wherever we want it could be positive or
105:52 - negative infinity and we have to account
105:54 - for that so this is a system we have to
105:57 - implement
105:58 - once we have that
106:00 - what we are going to do is we are going
106:02 - to be creating a dictionary with a key
106:05 - and a value pair like any dictionary the
106:07 - key in this case is going to be the cell
106:09 - position
106:11 - the associated value will be an object
106:13 - that tracks all of the IDS we have used
106:15 - on the cell for example this is again
106:18 - two for terrain free for water four for
106:20 - gold coin
106:22 - and the objects we are using for storage
106:24 - could contain any number of them
106:27 - for example if a cell has water and a
106:30 - gold coin we'll be storing three and
106:32 - four inside of this object
106:34 - and that is what we have to do so let's
106:37 - Jump Right In once again here we have
106:39 - everything and I want to work inside of
106:42 - the editor and let me minimize
106:43 - everything so it's easier to see first
106:46 - of all I need to figure out whenever I
106:48 - click where my mouse position is let's
106:51 - put this in another method that I called
106:54 - get current
106:57 - cell
106:58 - for now we don't need any parameters
107:00 - besides self
107:02 - and for now all I want to do is to print
107:05 - my mouse position
107:08 - don't forget to call it and also we have
107:11 - to figure out when to call this method
107:14 - here for that I need another kind of
107:16 - input which is going to happen inside of
107:19 - the inputs section
107:21 - in here I want to add let's call this
107:24 - one canvas add
107:26 - this is going to be triggered whenever
107:28 - we are clicking on the canvas this one
107:31 - only in itself and nothing else and in
107:33 - here I want if Mouse buttons and zero so
107:39 - we are left clicking on the canvas and
107:42 - not self dot menu Dot rect and Collide
107:47 - point with the mouse position with this
107:51 - we're checking if we're left clicking
107:53 - and we are not clicking on the menu if
107:55 - that is the case I want to run self and
107:58 - get current cell
108:00 - finally all we have to do is to run this
108:03 - canvas ad this again is going to happen
108:06 - inside of the event Loop and here I want
108:09 - to call self.canvas AD and for this one
108:11 - we don't need the event
108:13 - which means if I run this now and I
108:16 - click I get the mouse position however
108:19 - if I click on the menu nothing is going
108:21 - to happen
108:22 - cool so this one is working
108:24 - I can minimize the event loop again and
108:27 - now we can work on getting our current
108:30 - cell
108:31 - and the first thing we have to do let me
108:34 - actually do this in the editor
108:37 - and let me show my mouse there we go
108:40 - right now you can see my mouse moving
108:43 - across the entire editor and if I for
108:45 - example click on this cell here this
108:47 - should be 0 and 0. the actual position
108:51 - if I move this to the side a bit
108:54 - where I have clicked was 24 and 24.
108:59 - this I have to convert to 0 and 0.
109:04 - however we do have a problem because if
109:07 - I show a mouse again and I am doing the
109:10 - same thing again after moving the origin
109:13 - point if I now click again in the top
109:15 - left I am getting roughly the same
109:17 - position but now this number needs to be
109:19 - negative for the simple reason that I
109:22 - clicked on this cell all the way up here
109:24 - which is really far negative from the
109:28 - origin point
109:29 - basically what we are going to do when
109:31 - we are checking for the cells we are
109:33 - checking how far each cell is away from
109:37 - the origin point this is what really
109:39 - matters I guess the confusing thing here
109:41 - is that for the display surface when
109:43 - we're getting the mouse input the origin
109:45 - point is here but we want to have the
109:48 - origin point to be this point here and
109:50 - this is what we have to change
109:54 - I want to get distance to origin and
109:59 - this I think could be a really
110:01 - interesting exercise for you try to
110:04 - figure out the distance to the origin so
110:06 - what is the distance and X and Y from a
110:09 - mouse position to the origin
110:14 - alrighty basically what we want to do
110:17 - here I want to get my mouse position and
110:20 - from that I want to subtract self dot
110:23 - origin
110:25 - there is one adjustment that we are
110:27 - going to need because this mouse
110:28 - position right now is a tubo but we need
110:31 - a vector to do proper Vector math like
110:34 - so and this is all we needed let me
110:38 - print distance to origin so we see
110:40 - what's going on
110:41 - if I run all of this again and I click
110:44 - let me show my mouse if I click here we
110:47 - get 29 and 22. this is now the distance
110:50 - from the origin so this distance here if
110:53 - I click somewhere else we get a larger
110:55 - number which is working as intended
110:58 - so far there's no difference however now
111:01 - if I move the origin Point somewhere
111:03 - here and now I click again in this top
111:06 - left corner we now get a really large
111:08 - negative number
111:10 - only if I click again next to the origin
111:13 - point we get the small numbers that get
111:15 - us to zero and zero and this is working
111:18 - everywhere on this map or editor it
111:21 - works pretty well so this system is
111:23 - already working
111:26 - although we have to make one more
111:28 - adjustment let's have a look at the
111:29 - numbers we got here
111:32 - right now they're all pixel positions
111:35 - let's find a good number let's go with
111:40 - this one here 146 and 91. this right now
111:44 - is simply a pixel position how far we
111:47 - are away from the origin point
111:49 - this I have to convert
111:53 - because I want to have the cells away
111:55 - from the origin not an actual pixel
111:58 - position
111:59 - what this is supposed to be is that we
112:02 - are in cell I think this is going to be
112:03 - three and two
112:06 - these numbers we are getting by dividing
112:08 - this number by the tile size
112:12 - and then getting the integer of that for
112:14 - example this three here would be a 146
112:18 - divided by 64 and then we're turning all
112:22 - of this into an integer
112:26 - I'm looking at this like this this is
112:29 - probably a 2 and this is going to be a
112:31 - one but you get the idea
112:33 - let me make this a bit smaller and back
112:36 - in the editor I now have to know
112:40 - a column and I have to know a row and
112:44 - this is going to tell me exactly what
112:46 - cell I am on
112:48 - all we need to do is the integer of
112:50 - distance to origin and since this is a
112:53 - vector I can get X and Y quite easily
112:56 - and this I want to divide by the tile
112:58 - size
113:00 - the same thing I want to do for the row
113:02 - in here I can just copy the entire thing
113:05 - and this should be a y and now I can
113:09 - print a tuple with the column and the
113:12 - row
113:12 - and let's run all of this again if I now
113:15 - click let me show my mouse again next to
113:18 - the origin point we get 0 and 0. if I
113:21 - click to the right we get one and zero
113:22 - and we get one and one two and two three
113:25 - and two and so on this is working very
113:28 - well
113:31 - also if I move the origin point we can
113:34 - still click and get the right cell
113:36 - position
113:38 - however if I now click on this cell here
113:41 - we're getting a problem this is 0 and 0
113:44 - and this is zero and zero
113:48 - which is a minor problem with omf let's
113:51 - talk about it
113:52 - let me draw a couple of columns that
113:56 - makes it much easier to explain
113:58 - we have a bunch of columns here and I'm
114:00 - really bad at drawing straight lines
114:02 - and the origin point is going to be this
114:05 - point here the issue we have right now
114:07 - if we have a point here that is some
114:10 - small number let's say on the x-axis we
114:14 - have 20 pixels and on the y-axis we have
114:18 - 15 pixels
114:20 - if we divide
114:23 - 20 by 64.
114:26 - we are getting 0 if we're taking the
114:29 - integer and if we are getting 15 over 64
114:33 - we are also getting 0. which means that
114:36 - this x here has a coordinate of 0 and 0
114:40 - in the coordinate system we have created
114:42 - so far so good
114:45 - however if I clean all of this up
114:48 - and now if I go the other way and I go
114:52 - in this direction here and this
114:54 - direction here and I end up in this
114:56 - point which is let's say negative 40 and
115:01 - negative 50.
115:04 - if I divide negative 40 by 64 or
115:09 - negative 50 by 64. we are also going to
115:15 - get 0 and 0.
115:17 - which in our logic is going to be a
115:19 - problem because 2 pi game this cell here
115:22 - and this cell here have the same
115:25 - position which would break the entire
115:28 - game and would be a massive headache to
115:30 - work with so we have to account for it
115:32 - what I want to do let me do this over
115:35 - multiple lines although you could do all
115:37 - of this on one line but it's easier to
115:39 - read over multiple lines I first want to
115:42 - add an if statement if distance to
115:44 - origin dot X is greater than zero if
115:49 - that is the case
115:51 - I want to have this column the one we
115:53 - have already seen however if that is not
115:56 - the case so else I can copy the entire
115:59 - thing
116:00 - and just subtract one from it
116:02 - that fixes the entire issue it really
116:05 - isn't that difficult
116:06 - the same thing we have to do
116:09 - or let me actually copy it
116:13 - if distance to origin dot Y is greater
116:16 - than zero then we want to get this row
116:18 - however if that is not the case so else
116:22 - then I want to get the same thing
116:27 - -1
116:27 - and that is it if I run this again now
116:31 - and show my mouse
116:33 - I can again click here and we get 0 1
116:36 - this looks pretty good however now if I
116:40 - click on the top left of the origin
116:41 - point I get negative 1 and negative 1
116:44 - negative two and one and so on this is
116:46 - also working very good now
116:49 - cool so with that we have fixed the
116:51 - entire issue
116:52 - all we have to do now is I want to
116:56 - return
116:58 - column and row at the end of this method
117:02 - and with that I can minimize it and not
117:04 - worry about it anymore
117:06 - now we can continue working in the
117:09 - canvas ad method
117:10 - in here first of all I want to get my
117:14 - current cell that is the one we are
117:17 - getting from the method we just created
117:20 - although now I need some way to store
117:23 - the information we are going to create
117:25 - in here this I want to create inside of
117:28 - the init method
117:31 - and in here in the main setup I want to
117:34 - create self dot canvas data right now
117:39 - this is an empty dictionary
117:41 - that's all I need for now although I
117:43 - also want to add this section here I
117:46 - want to call support
117:48 - it's going to be a bit more methods
117:51 - later on in there but let me
117:54 - all of this a bit more properly
117:58 - because we are going to add a ton more
118:00 - methods in here but all right
118:02 - now we can actually work in here if the
118:06 - player is clicking on the editor this is
118:08 - what we already have this is this line
118:09 - here then I want to check if the current
118:12 - position we have is inside of canvas
118:15 - data if that is the case we want to add
118:18 - something if it is not the case we want
118:19 - to create a new key value pair
118:22 - which means I first of all want to check
118:24 - if the current cell is in self dot
118:28 - canvas data
118:30 - if that is the case we don't really know
118:32 - what to do right now so let's just write
118:34 - pass in here however if that is not the
118:37 - case else
118:39 - I want to get self dot can this data and
118:44 - then I'm going to get my current cell as
118:46 - a key
118:48 - and for now let's say I want to add cell
118:51 - in here and after every time we are
118:54 - clicking I want to print self dot canvas
118:57 - data if I now run this and show my mouse
119:01 - you can see that I can add more and more
119:04 - cells
119:05 - and we always have the position of the
119:07 - cell and then cell this cell here is
119:11 - going to become much more complicated
119:12 - but the position is what we really care
119:15 - about for now this is working really
119:16 - well
119:17 - whether there's one more thing that I do
119:20 - want to do later on when we are going to
119:23 - run this we are going to run quite some
119:25 - code that is going to be a bit more
119:27 - processor intensive as a consequence
119:30 - I only want to run this if we are
119:33 - changing the cell
119:34 - which means if the current cell
119:38 - is different from self dot let's call it
119:41 - last selected
119:43 - cell
119:44 - only if that is the case which means we
119:47 - have changed the cell so we went to a
119:48 - different one then I want to run all of
119:50 - this
119:51 - and at the end of it I want to run self
119:55 - dot last
119:57 - selected cell is going to be the current
120:00 - cell
120:01 - all we have to do now is to create this
120:04 - as a proper attribute inside of the init
120:07 - method
120:08 - let's do it below selection
120:10 - and by default this can just be none
120:14 - all this one does is it safeguards us
120:17 - against wasting some resources
120:19 - but if I run this again
120:21 - we can't really see any difference
120:23 - what we now have to figure out is how to
120:26 - create a data structure that can capture
120:28 - all of the data
120:30 - what this basically means is we need
120:32 - some kind of object that can store
120:34 - hypothetically all of these numbers
120:37 - and since that is going to be a tiny bit
120:38 - more complex I want to create a whole
120:41 - new class for it
120:43 - so all the way at the end of this
120:44 - document
120:45 - I want to create a new class
120:48 - this one I called canvas tile there's no
120:52 - inheritance but we do need as always a
120:55 - Dunder init method
120:58 - in here we need self and tile ID this
121:03 - one is going to store quite a bit of
121:04 - information so let me add comments to
121:06 - explain what is happening
121:07 - first of all it is going to check self
121:10 - dot has Terrain
121:12 - this could ever be true or false by
121:14 - default it's going to be false besides
121:17 - that I also want self dot terrain
121:20 - Neighbors
121:22 - and this for now is going to be an empty
121:24 - list
121:25 - imagine we have a Terrain tile here just
121:29 - some empty land
121:30 - what kind of graphic we need for this
121:32 - terrain tile depends on what surrounds
121:35 - it for example if there's a tile here
121:37 - this one would need to be some kind of
121:39 - bottom tile if we had a tile below we
121:44 - would need a top tile something like
121:46 - this which means whenever we have a
121:48 - Terrain we also need to know what
121:50 - neighbors this terrain has and all of
121:52 - this is going to be stored in here
121:54 - next up we need the water and then here
121:57 - the logic is going to be fairly similar
121:59 - first of all we want to check has water
122:01 - and this by default is going to be false
122:05 - besides that I also want to know if self
122:08 - dot water on top this by default is also
122:12 - going to be false
122:14 - the important thing here I can actually
122:15 - show this in the folder
122:18 - here's the game folder I want to look at
122:21 - Graphics terrain and then there we have
122:24 - water
122:24 - and in the animation this is what's
122:27 - supposed to be on top of the water
122:29 - however this is only on the top layer of
122:32 - the water if water is below that we want
122:34 - to have this graphic here
122:36 - if we have two water tiles this one and
122:40 - this one only the top one needs to have
122:43 - the water animation the bottom one can
122:46 - just be a full tile that doesn't need
122:48 - animations
122:51 - next up we need to know what coin we
122:54 - have this one is very simple all we need
122:56 - here is self.coin and by default this is
122:59 - going to be none
123:00 - the system I want to have is that each
123:02 - tire can only have one kind of coin so
123:05 - we couldn't have a gold and a silver
123:07 - coin on the same tile which means this
123:10 - attribute here could either be four five
123:13 - or six and if we're changing it we're
123:15 - getting rid of any other coin
123:18 - besides that we have the enemy and
123:21 - that's the same logic as the coin we
123:23 - have self dot enemy and this is going to
123:25 - be none we can only ever have one enemy
123:27 - per tile
123:29 - finally something we are going to work
123:31 - on much later we are going to need the
123:34 - objects and this is self.objects and for
123:37 - now this is an empty list the logic for
123:40 - the objects like the palm trees and the
123:42 - player are going to be much more
123:44 - complicated for now I am not going to
123:46 - worry about it
123:48 - however what we do need is a method that
123:52 - I called self dot add ID
123:56 - this one itself and a tile ID
124:01 - that is the one we're actually getting
124:03 - from up here and this inside of the
124:06 - editor is going to be the selection
124:08 - index so basically later on when we are
124:12 - creating this object I can actually do
124:13 - it right now
124:14 - we're going to create a canvas tile and
124:18 - pass in self.selection index
124:21 - for example if in settings our selection
124:25 - index is 2 right now we are adding a
124:27 - Terrain tile
124:29 - which means this number here would be a
124:31 - 2 for example
124:33 - and then this is going to be a 2 in here
124:36 - and this two will be passed in here
124:39 - and now
124:40 - we have to create add IB with self and
124:48 - tile ID
124:51 - what we now have to figure out is
124:53 - if this tile ID here is 2 we want to add
124:58 - in self dot terrain that this is
125:02 - supposed to be true and then we need to
125:03 - find the neighbors the neighbors is
125:06 - going to be topic on its own but we want
125:08 - to change this one here and the same
125:11 - would also be the case for water for the
125:12 - enemies for the coins and so on first of
125:15 - all I need to know what options are
125:18 - available
125:19 - this I know from the settings again I
125:21 - need this editor data
125:23 - if again my current selection index or
125:27 - the tile ID is two I want to know the
125:30 - style of this current dictionary
125:33 - and this is going to be a dictionary
125:35 - comprehension which means I want curly
125:38 - brackets and I want key and value for
125:43 - key and value in editor data dot items
125:48 - this right now would duplicate the
125:51 - entire dictionary so we haven't really
125:53 - achieved very much
125:55 - but all I really care about is the style
125:59 - part of the dictionary
126:02 - that we are getting let me actually
126:04 - print what we get that should make all
126:06 - of this much easier to see
126:08 - if I run this now I hope it doesn't
126:11 - crash and it does crash
126:14 - because this self ID here shouldn't
126:16 - itself it just needs tile ID
126:19 - now if I run this there we go this is
126:21 - working and we are getting now in the
126:25 - canvas data 0 and 0 and then an object
126:29 - and this is
126:32 - not what we're doing here but instead
126:34 - this happens because of this line so
126:36 - let's get rid of it
126:38 - and that should make all of this much
126:40 - easier to see there we go now we can see
126:42 - what's going on
126:44 - if I click anywhere on the editor we're
126:46 - getting a dictionary that is the
126:48 - dictionary I have created here the
126:51 - options dictionary
126:53 - we have 0 and player one and Sky to
126:56 - enter rain 3 and water we basically have
126:59 - this key and then only this value here
127:03 - how I want to use that is with a match
127:06 - case statement I want to check match
127:09 - options
127:10 - with my tile ID
127:13 - remember here using match needs python
127:16 - 3.10 if you have an earlier version this
127:19 - is not going to work but you can make
127:21 - the same thing work with an if statement
127:22 - as well although update your python
127:25 - version
127:26 - the first case is going to be
127:29 - Terrain
127:31 - and if that is the case I want to set
127:33 - self dot has terrain to true
127:38 - if the case is water
127:42 - I want self dots as water
127:46 - to be true
127:47 - if the case is coin
127:50 - then I want self.coin and in here I want
127:55 - to have the tile ID for the coin
127:58 - the same thing I can just duplicate it
127:59 - actually for the enemy
128:03 - then self-taught enemy is going to be
128:07 - the tile ID now what does all of this
128:09 - mean and let me try to get all of this
128:11 - on one image
128:14 - let's do some examples to illustrate how
128:16 - this is working
128:17 - the case we have already seen is that
128:19 - tile ID is 2.
128:21 - from the dictionary we have created here
128:24 - we always have key value pairs for
128:26 - example 2 is going to be Terrain
128:31 - and if we're getting indexing like this
128:33 - we know that this 2 is going to be this
128:36 - case which means we want to set self dot
128:39 - has terrain to True which is going to
128:41 - set this terrain all the way up here to
128:44 - true
128:45 - on the same line if this for example let
128:48 - me get rid of all of this if this tile
128:50 - ID was a four a four bought a coin this
128:54 - one here if that was the case
128:56 - we would get this case statement here
128:59 - and we will set self.coin to the tile ID
129:02 - which means this self.coin here would be
129:06 - F4 which would tell us on this tile we
129:09 - want to have a gold coin
129:11 - and later on when we are clicking on
129:13 - this again with for example the number
129:15 - five then we're going to overwrite this
129:18 - and change this 4 to a 5. that way we're
129:22 - getting rid of the gold coin and replace
129:24 - it with a silver coin the same logic is
129:26 - going to happen with the enemies as well
129:28 - I hope all of that makes sense it is a
129:30 - lot of data management later on we have
129:33 - to add a tiny bit more in here to
129:35 - account for the objects but for now I am
129:37 - not too concerned
129:39 - all we have to do now is figure out if
129:42 - this system actually works let me
129:43 - minimize it for now and now we can work
129:47 - inside of this canvas ad again and
129:49 - instead of printing the entire thing I
129:52 - now want for key and value in
129:57 - self.canvas data
130:00 - I want to print
130:01 - an F string with the key which is going
130:05 - to be the position
130:06 - for the value here let's just print the
130:09 - value itself
130:11 - also let me add a bit of white space
130:13 - here so all of this is easier to see if
130:16 - I now run all of this and click on it
130:19 - we are getting
130:21 - something weird
130:23 - and I think the issue here is that this
130:25 - should be canvas dot items or canvas
130:27 - data.items now if I run this
130:30 - this is much better now we're getting a
130:33 - canvas tile object at a certain position
130:36 - which doesn't help us too much but I
130:39 - could now for example check as the rain
130:44 - and if I now click on it we're getting
130:47 - true and we're getting false okay this
130:49 - is very hard to see but trust me it is
130:52 - definitely working
130:54 - illustrating how it works is very hard
130:56 - to do
130:57 - once we get to drawing things all of
130:59 - this is going to make much more sense
131:00 - but first of all the last thing for this
131:02 - section is inside of this
131:06 - when we are clicking on a cell that
131:07 - already has a canvas tile I want to add
131:10 - to this tile and this I get with self
131:13 - dot canvas data and current cell so now
131:17 - instead of creating a new key value pair
131:20 - I am targeting an existing one
131:22 - and this is going to return a canvas
131:24 - tile and on this canvas tile I want to
131:26 - run add ID with myself.selection index
131:31 - this is going to work because inside of
131:33 - this canvas tile
131:34 - we can run this add ID multiple times it
131:37 - is going to work every single time which
131:39 - is all we need here
131:42 - and with that we can add stuff to our
131:45 - editor although we can't really see
131:47 - anything but I guess that is going to
131:50 - come in the next part or rather I'm
131:51 - going to cover this over multiple
131:53 - sections the logic here is a bit more
131:55 - extensive
131:56 - let's get started on drawing the level
131:59 - in here we already know what to draw and
132:03 - where to draw it all of that is coming
132:06 - from the last section where we have
132:07 - created a canvas data dictionary with a
132:10 - position and then a canvas tile that
132:12 - tells us what we want to draw
132:14 - basically all we have to do is to cycle
132:16 - through this camera started dictionary
132:18 - and draw the things associated with it
132:21 - which sounds much easier in theory but
132:24 - it certainly is doable let's Jump Right
132:26 - In and let's have a look at it
132:28 - once again we are in main.pi and I want
132:32 - to keep on working in the editor more
132:34 - specifically I want to add to the
132:37 - drawing section in here I want to have
132:39 - another method let's call it draw
132:42 - level
132:43 - this should be an underscore and then
132:45 - here we need itself and nothing else
132:48 - the main thing we have to do in here is
132:51 - for let's call it cell position and the
132:55 - tile in self dot canvasdata dot items
133:00 - first of all we have to convert this
133:02 - cell position into an actual pixel
133:04 - position
133:06 - so that for example something like 1 and
133:09 - 2
133:11 - would rather be a
133:13 - 64 and 128.
133:16 - on top of that we have to make sure that
133:19 - this is the position from the origin
133:22 - Point not from the top left of the
133:24 - window this is really important to take
133:26 - care of
133:27 - I'm going to store all of this in a
133:29 - separate variable position seems like a
133:31 - good name and in here I first of all
133:33 - always want to start from the origin
133:36 - once again this is a vector
133:39 - and to this I want to add the cell
133:43 - position
133:44 - and this cell position I want to
133:46 - multiply with the tile size there's one
133:49 - problem this cell position right now is
133:52 - a tuple
133:53 - which we cannot multiply with a number
133:55 - but I can do that if I convert it to a
133:58 - vector there we go this is all we needed
134:01 - now comes the kind of tedious part we
134:05 - have to check all of the different
134:06 - possibilities the one that is most
134:09 - common I think is going to be if tile
134:11 - dot has not water but rain
134:15 - if that is the case I want to Blitz a
134:18 - certain thing let's say self dot display
134:21 - surface and then I want to Blitz
134:23 - something
134:24 - in here we need a surface and we need a
134:27 - position
134:28 - the position we already have that is
134:30 - coming from here the surface is going to
134:32 - become a bit more complicated
134:35 - for now just to have something in here I
134:38 - want to create a let's call it a test
134:41 - surface
134:43 - and this is going to be Pi game dot
134:46 - surface
134:48 - and for the size I want to have the tile
134:50 - size and the tile size again
134:54 - on top of that I want to fill this test
134:56 - surface
134:57 - with a brown color so it's easier to see
134:59 - what's going on once we have that inside
135:02 - of the run method
135:04 - before we are drawing the lines I want
135:06 - self Dodge draw level
135:11 - if I run this now and click
135:14 - we're getting an error the type object
135:16 - is not subscriptable
135:18 - the issue happened on this line here and
135:21 - I realized this shouldn't be square
135:23 - brackets this should be normal brackets
135:26 - like so
135:28 - now they're on this
135:31 - we're getting another error that
135:34 - this should be test surface
135:37 - and now there we go we can draw on this
135:41 - thing and we have a nice logic that
135:44 - works really well
135:46 - also now if I Pan the entire thing all
135:49 - of this is still going to work I should
135:52 - actually show my mouse that I think is
135:54 - going to make all of this easier to see
135:55 - so all of this is working really well we
135:59 - are definitely making some progress and
136:01 - this is looking really nice
136:05 - while we are here there are going to be
136:08 - three more things that we need to add
136:11 - we have to add the water
136:14 - we have to add the coins and we have to
136:18 - add the enemies
136:20 - all of those are going to look kind of
136:22 - like this and they all need the
136:24 - individual if statements and this could
136:26 - be a really good exercise copy this and
136:29 - create the same thing for water coins
136:31 - and enemies
136:32 - and make sure to properly check what
136:35 - kind of tile you are going to have in
136:37 - this position
136:41 - in my case I am going to copy all of
136:44 - this
136:44 - and now for the water I want to check if
136:48 - as
136:49 - water
136:51 - if that is the case I want to create
136:53 - another surface like so and this one I
136:56 - want to have not water this should be
136:59 - blue
137:01 - I can copy The Thing One More Time
137:04 - although for this one I just want to
137:06 - check if tile dot point
137:10 - because of type conversion here if coin
137:13 - is none which is the case by default
137:15 - coin is none this if statement is not
137:19 - going to trigger however once this coin
137:22 - has a 4 a 5 or 6 this if statement is
137:26 - going to trigger so this is still going
137:27 - to work
137:29 - the color here I want to have yellow and
137:32 - we need one more if statement for the
137:35 - enemies like so
137:37 - and just one if tile dot enemy exists
137:40 - and for this one I want to have a red
137:42 - color
137:44 - and with this
137:46 - let's try main.pi
137:48 - let me show my mouse again and now if I
137:51 - draw a Terrain tile we're getting the
137:54 - brown color but if I click or right
137:56 - click on the water and draw again we are
137:59 - now getting blue tiles
138:03 - also if I click on the brown tile
138:06 - you can't really see the result because
138:08 - the terrain is on top of the water but
138:11 - it definitely works I guess if I draw
138:13 - terrain on the water we get brown on top
138:17 - I can also do this for the coins and I
138:20 - can do this for the enemies
138:22 - we are definitely starting to have a
138:25 - start of the game
138:27 - all we really need now is to import a
138:29 - bunch of different Graphics to make this
138:31 - look actually decent
138:33 - let's do that in the next part it is
138:35 - going to be a bit of a larger topic
138:38 - I suppose the most important part of the
138:40 - level editor is drawing the terrain
138:42 - let's work on this one in here we first
138:46 - of all need to import a lot of data and
138:50 - when I say a lot of data I really mean a
138:52 - lot of data let me show it actually
138:56 - here is the project folder there we have
138:59 - Graphics inside of there is terrain and
139:01 - inside of the app we have the land and
139:04 - in there we have a few hundred different
139:07 - graphics
139:09 - these are all the possible Graphics that
139:11 - we could potentially have
139:13 - how the naming scheme here works you are
139:15 - going to see it is a very strange file
139:17 - if you don't know what's going on just
139:19 - be aware we have to import all of this
139:24 - once we have that whenever we are
139:27 - placing a Terrain tile we need to know
139:29 - what's going on with the neighbors
139:31 - and only once we have all of that we can
139:34 - draw the right terrain tile
139:36 - and that is giving us a list we can work
139:38 - through so let's jump into the code and
139:40 - let's figure all of this out
139:42 - here we are back in the code editor and
139:44 - now we have to figure out where to
139:46 - import all of the land tiles
139:49 - and here we do have to be careful
139:51 - because these land tiles need to be
139:53 - available in the editor and later on in
139:55 - the level as well and since there are a
139:57 - ton of Graphics I only want to do this
139:59 - once which means I want to import all of
140:02 - this inside of Main
140:04 - and then pass it into the editor I guess
140:07 - what we can do in here is create another
140:10 - method let's call it Imports need self
140:13 - and nothing else and then here we can
140:16 - import a bunch of different things the
140:18 - one we care about for now is self.land
140:21 - tiles
140:23 - for this one I want to create a function
140:26 - that I called something like import
140:29 - folder as a dictionary this one doesn't
140:33 - exist right now but it's going to exist
140:35 - in just a second
140:37 - and here we need a path to a folder for
140:39 - that we need to go up one folder then to
140:42 - graphics and in there we have terrain
140:45 - and inside of the app we have land if I
140:48 - show defolder again
140:50 - in here you can see we have Graphics
140:52 - terrain and land this is the file path
140:55 - we are following
140:56 - which means what we have to do now is to
140:59 - create this function and since we are
141:01 - going to use it quite a bit I am going
141:03 - to Outsource all of this to a separate
141:05 - file which means I want to create a new
141:08 - Pi file and save it as let's call it
141:11 - support dot pi
141:14 - in here as always we have to import Pi
141:17 - game
141:19 - besides that we need to have access to
141:22 - the file system and this we get with the
141:25 - walk module which we have to import from
141:27 - OS import walk and using this I want to
141:31 - create two functions the first one is
141:34 - import folder
141:36 - and this one needs a path and does a
141:39 - certain thing and besides that I want to
141:42 - have another function that is import
141:44 - folder as a dictionary and here we also
141:48 - need a path
141:49 - those two are going to be fairly similar
141:52 - so let's create them both at the same
141:54 - time the easier one is going to be the
141:57 - import folder let's start working on
141:59 - this one and just to illustrate what's
142:00 - going on let's use this one
142:03 - for now so I'm just importing a folder
142:05 - and I am going to get a ton of surfaces
142:08 - but I don't know the file name of each
142:10 - surface which in some cases I don't
142:13 - really care about it I guess why we're
142:15 - here I also want to run the import this
142:18 - is going to happen right at the top self
142:20 - dot Imports
142:22 - just to make sure that this is working
142:24 - inside of support I want to print the
142:28 - path
142:29 - also I want to add a pattern here so
142:31 - we're not getting an error if I run this
142:33 - now
142:34 - we are getting name input folder is not
142:37 - defined the reason for that is I have to
142:40 - import it so from support import
142:43 - everything
142:44 - now if I run this
142:47 - we can see Graphics terrain land and
142:49 - that is what we're getting from here so
142:51 - this one is working good start
142:54 - what I now want to do in here I want to
142:56 - ultimately create a surface list
142:59 - and this for now is going to be an empty
143:02 - list
143:02 - I want to cycle through whatever files
143:05 - we have inside of this path and then any
143:08 - kind of picture is going to be imported
143:10 - as a surface and placed inside of this
143:13 - list
143:14 - for that we have two for data in Walk
143:19 - and Walk needs a path so this path in
143:22 - here
143:24 - and just to see what we're getting let
143:26 - me print the data it's going to look
143:27 - slightly different if you see this for
143:29 - the first time
143:31 - if I now run off this we are getting a
143:34 - very very long list
143:37 - this list is going to contain three
143:39 - elements although it looks like there's
143:40 - much more the first element we get here
143:43 - this is the name of the folder this is
143:46 - not something we care about at all
143:47 - besides that we get another list and
143:50 - this one will contain all of the
143:52 - subfolders also not something we care
143:54 - about
143:55 - finally we have all of the actual files
143:58 - inside of this folder this is what we
144:01 - actually care about and this is what I
144:03 - want to import
144:04 - which means inside of this I can split
144:07 - this data up into three bits we get the
144:10 - folder name
144:12 - we get sub folders
144:15 - and then we get the image files
144:19 - the image files is all I really care
144:22 - about as a consequence let me just print
144:25 - the image files and let's see what we
144:28 - get we are getting a ton of different
144:31 - image files or not really image files
144:34 - rather it is names of image files
144:38 - a.png is just a string right now we have
144:42 - to convert it to a full path and then
144:44 - use this path to import the image as a
144:47 - surface
144:48 - although first of all I have to cycle
144:50 - through this list which means for image
144:53 - name in image files
144:56 - I want to do a couple of things first of
144:59 - all I have to get a full path and this
145:03 - full path is going to be the folder plus
145:06 - the file name
145:09 - once I have to fold path I can create an
145:12 - image surface
145:14 - and then I want to let me add this as a
145:17 - comment I want to add
145:19 - the image surface to the surface list
145:25 - first of all we need the folder path in
145:28 - here and the folder path we are getting
145:30 - from this path remember in main.pi we
145:34 - are passing in
145:35 - this folder path in here and this is
145:38 - what leads us to the folder
145:40 - which means the folder path is just
145:43 - going to be the path
145:45 - to that I want to first of all add slash
145:49 - and then I want to have the image name
145:54 - and just to see what we get let me print
145:56 - the full path and comment this one out
146:00 - and if I run main.pi
146:03 - we're getting a whole bunch of file
146:06 - names
146:07 - but in here the important bit is we
146:09 - always start with Graphics terrain and
146:11 - land then we're adding a slash and then
146:13 - we're getting the file name and this
146:15 - happens hundreds of times
146:18 - once I have that
146:20 - I can use this image path to import an
146:23 - image surface
146:24 - and this is going to be pygame dot image
146:27 - dot load and that should be an equal
146:30 - sign
146:32 - and I want to use my full path
146:35 - this is going to give me the actual
146:37 - surface and this surface I want to add
146:40 - to this surface list which means I want
146:43 - to have the surface list append a
146:46 - surface and the surface I want to append
146:48 - is the image surface
146:50 - and that is all we need all I have to do
146:54 - now is to return this surface list
146:58 - and that way all of the land tiles are
147:01 - going to be surfaces from this folder
147:03 - which means I can print self.land tiles
147:07 - run all of this again and we are getting
147:11 - a huge amount of surfaces all the stuff
147:14 - we have just imported
147:16 - although for the land tiles I need to
147:19 - know the file name and this one is not
147:21 - going to give me that
147:23 - as a consequence I have this import
147:25 - folder as a dictionary
147:27 - the key here is going to be the name of
147:29 - the file and the value is going to be
147:32 - the actual surface
147:33 - and this I think could be a really good
147:35 - exercise try to convert this function
147:38 - here so that we are creating a
147:40 - dictionary with key value pairs the key
147:43 - being the file name and the value being
147:44 - the surface pause the video now and try
147:47 - to figure this one out
147:51 - I think the easiest way to start is to
147:54 - copy all of this and now we don't have a
147:56 - surface list we have a surface
147:58 - dictionary
148:00 - which means curly brackets
148:02 - these two lines can stay exactly as they
148:05 - are as can full path the image surface
148:08 - is also fine let me remove the white
148:11 - space here this one isn't really
148:13 - necessary
148:15 - and finally the only real change that we
148:18 - have to make is now we have a surface
148:21 - dictionary and for this one
148:25 - I want to have the file name
148:29 - and for the value here I want to have
148:31 - the image surface so I can delete this
148:34 - one here as well one more change that we
148:36 - do have to make
148:37 - this shouldn't be file name this should
148:40 - be the image name the image name right
148:42 - now would be something like a DOT PNG
148:45 - and this dot PNG is going to be kind of
148:48 - annoying so I want to get rid of it
148:50 - which I can do with the split method I
148:54 - want to split this string wherever we
148:57 - have a DOT this is then going to return
148:59 - a list with the file name and the file
149:01 - ending in this case I only care about
149:04 - the one with the index 0 which is always
149:06 - going to be the file name without the
149:09 - file ending
149:10 - after I have that I can return the
149:12 - surface dictionary and we should be done
149:16 - if I now use import for that dictionary
149:19 - and run the entire thing
149:21 - I now get
149:23 - a really large dictionary that always
149:25 - has a key with the name of the file and
149:28 - then an Associated value which is the
149:30 - surface
149:31 - which seems to be working just fine cool
149:34 - with that I can close the support file
149:37 - because we don't have to change it
149:40 - anymore with that we can import a bunch
149:42 - of things quite easily
149:45 - and now when I'm creating the editor I
149:48 - want to pass in self.land tiles
149:51 - which means inside of the editor we need
149:54 - another parameter which is going to be
149:57 - land
149:58 - tiles
150:00 - on top of that let me add another
150:02 - section here that I call Imports I want
150:05 - to store my land tiles as an attribute
150:08 - inside of the class and tiles
150:12 - so now we have a bunch of Graphics that
150:15 - we can be using and we could already
150:17 - implement this to an extent at least
150:19 - when I'm drawing the level
150:21 - I only care about terrain right now let
150:24 - me minimize everything else
150:27 - in here for the test surface we could
150:29 - actually use
150:31 - self.land tiles and a generic one in
150:35 - here is the one with x
150:38 - I could just use that and don't fill it
150:40 - with a color
150:41 - and now if I run this and I let me show
150:45 - my mouse
150:45 - and I draw a Terrain you can already see
150:48 - a graphic which is not looking bad at
150:51 - all the problem is you can see it quite
150:53 - easily all of those look identical
150:56 - but that is not something I want for
150:59 - example for this title here I want this
151:01 - to have something like this where we
151:04 - have a connection to this tile and to
151:06 - this tile and also to this tile here
151:09 - we have to always find the neighbors for
151:11 - each of these terrain tile and then get
151:14 - the appropriate graphic
151:16 - which is going to be a fun little topic
151:18 - to work on
151:20 - let's have a look
151:22 - basically what we have to do inside of
151:24 - canvas tile we have to fill this terrain
151:27 - Neighbors
151:29 - and for that we need a bunch of logic
151:32 - which I have stored in a separate method
151:35 - inside of the support section I created
151:38 - a method called check
151:40 - Neighbors
151:43 - there is one parameter we need in here
151:45 - and this is going to be a cell
151:49 - position
151:50 - the most important thing we have to do
151:52 - in here as the name of the method
151:54 - applies we have to check the neighbors
151:56 - obviously but there is going to be a
151:59 - problem and let me draw the issue
152:02 - actually let me add pass in here and run
152:04 - this entire thing again and I'm going to
152:06 - draw a whole bunch of terrain tiles
152:10 - all of that
152:14 - something like this
152:16 - now we have a ton of different terrain
152:19 - tiles
152:20 - and now I want to add a new tile in here
152:24 - and this tile needs to check what its
152:27 - neighbors are doing
152:28 - which in this case would be I want to
152:31 - check these three tiles here and then
152:34 - change this tile here the problem is I
152:37 - want to make sure that I am only
152:40 - changing this grid here
152:43 - the cells that are surrounding the
152:46 - current tile I am working on
152:49 - what I do not want to do is check every
152:52 - single terrain tile that we have because
152:55 - we could have thousands of terrain tiles
152:57 - I do not want to check all of them
153:00 - and as a consequence I want to create
153:02 - what I called a local cluster and those
153:05 - are the terrain tiles that surround the
153:08 - current tile we have just placed sounds
153:10 - a bit complicated it's not that
153:11 - difficult to implement
153:14 - but first of all I wanted another
153:16 - comment and I want to create
153:20 - create a local cluster
153:24 - and then here first of all I want to
153:26 - create a cluster size
153:29 - which I have set to free
153:31 - and from that I want to create my local
153:34 - luster
153:37 - and this is going to be a list
153:38 - comprehension what I want in here if
153:42 - this is the current cell I'm working on
153:44 - this would be my cell position I want to
153:47 - know
153:48 - this style here
153:49 - this tile here
153:51 - is tied here here here here here here
153:54 - and here
153:56 - so by the end of it we have eight tiles
153:59 - that we are going to look at I guess
154:01 - nine theoretically because this one is
154:03 - going to be included but this one
154:04 - doesn't matter so much
154:06 - also the cluster size here refers to
154:09 - this distance here and this distance
154:12 - here we have a cluster that is three by
154:15 - three columns at rows you could make
154:18 - this larger if you really wanted to but
154:20 - there isn't really a reason to
154:22 - I guess the one thing you want to be
154:24 - careful here if you're placing a new
154:26 - tile here it might change existing tiles
154:29 - for example if this tile before we place
154:33 - the yellow tile was a top tile that
154:36 - looked something like this
154:39 - after we are placed in the yellow tile
154:40 - it needs to be a bottom tile once I
154:43 - Implement all of this it's going to make
154:44 - a lot more sense
154:46 - I want to place let's say a tile which
154:51 - is just going to be a string for now but
154:53 - that is going to change
154:54 - or call in range
154:58 - cluster size this is going to give me
155:00 - the columns and then again I want for
155:03 - Row in range
155:06 - Laster size as well
155:08 - just to illustrate what is happening
155:09 - right now let me for Row in local
155:13 - cluster and print row
155:19 - now we have to figure out when to call
155:21 - this check neighbors and this is going
155:23 - to be called whenever we use canvas add
155:27 - I want to run self dot check Neighbors
155:32 - this cell I want to pass in here is the
155:35 - current cell now if I run the entire
155:37 - thing press anywhere
155:40 - we are getting a bunch of tiles okay
155:43 - it's not particularly helpful
155:46 - but if I minimize canvas add and just
155:49 - print the local cluster that might
155:52 - illustrate a bit better what's going on
155:56 - print local cluster
155:58 - and click anywhere
156:00 - we're getting a list
156:02 - with nine different tiles
156:05 - because we have three columns and three
156:07 - rows we are going to get nine items in
156:10 - total
156:12 - what we now have to figure out is the
156:14 - actual position for each of these tiles
156:16 - and this is always going to be a tuple
156:19 - with a row and a column although here we
156:24 - do have to account for quite a bit
156:25 - although let me print it right now
156:28 - if I do it like so we're always getting
156:30 - from 0 to 2 and 2. also I want to put
156:34 - this over multiple lines so it's easier
156:37 - to read
156:38 - and fits on my screen there we go I
156:43 - think this is going to be a bit easier
156:44 - for the row and by the way I think this
156:48 - could be a really interesting exercise
156:50 - what I want to do in the end is if I for
156:53 - example click on let me use a simple
156:55 - number if I click on this tile here I
156:59 - want a local cluster to be these tiles
157:02 - the top left one is going to be 0 and 0
157:06 - then we have one and zero and we have
157:09 - two and zero and so on the same thing
157:12 - this should be zero and one and zero and
157:15 - two
157:15 - and then down here we have two and two
157:18 - right now this is what we always get
157:20 - however if I now add
157:24 - a tile let's say here
157:28 - the local cluster should be this area
157:33 - with this bottom one here there should
157:35 - be negative one and negative one
157:38 - then we have negative two and negative 1
157:41 - and negative three and negative one and
157:44 - so on these numbers here always have to
157:47 - be relative to the position you just
157:49 - placed you basically want to create a
157:52 - row and a column that is always relative
157:55 - to the sub position and then circles
157:57 - around the cell position so positively
157:59 - now and see if we can figure this one
158:01 - out
158:04 - all right let's get started and I
158:07 - realized already this should be column
158:09 - and row because this one is X and this
158:13 - one is Y which is how our position also
158:16 - works
158:17 - this column right now is always going to
158:20 - be 0 1 or 2 because of this range here
158:23 - this number we want to add to the cell
158:29 - position and I want to get cell position
158:32 - and X
158:34 - the same thing I want to do for the row
158:37 - so let me copy the entire thing paste it
158:39 - in here and this should be a one if I
158:42 - now print the entire thing let's do it
158:45 - somewhere here
158:46 - we're getting
158:49 - the start position here one and one and
158:51 - then keep on going down so we are making
158:54 - progress although if I am drawing what
158:56 - we're doing right now
158:57 - if I place it here again and give me a
159:01 - bit of space this is actually working
159:04 - very good
159:05 - the first cell I get is one and one
159:07 - which is this one here
159:10 - then I'm getting 1 and 2 which is this
159:13 - one here then I'm getting one and three
159:15 - this one here
159:16 - then I go to the next row which is this
159:19 - one here and here we're getting these
159:21 - three cells
159:24 - which is 2 1 2 2 and 2 3. finally we're
159:28 - going to the third row here we have
159:30 - three one three two and three free
159:33 - which means whatever terrain we are
159:36 - placing we always get this area here
159:41 - which is a good start but not exactly
159:43 - what we want the area we actually want
159:46 - is this one here
159:49 - to fix that we have to move the entire
159:52 - local cluster up by one cell until left
159:54 - by one cell
159:56 - or more specifically and to be a bit
159:58 - more flexible
160:00 - I want to subtract it by the cluster
160:03 - size
160:04 - divided by 2 and then I want to have the
160:08 - integer
160:10 - this I want to have both for the column
160:12 - and for the row
160:14 - and now if I do this again and draw for
160:17 - example a tile here
160:20 - and move it to the side again
160:23 - the first tile I'm getting now is one at
160:26 - one which is this one and one here
160:29 - the final cell I get is free and free
160:31 - which is the one down here
160:35 - which means the entire thing now is this
160:38 - area exactly what I wanted
160:41 - so we are making some really good
160:43 - progress
160:45 - now that I have that I can actually
160:47 - check the neighbors
160:49 - with that first of all I want for cell
160:52 - in local cluster
160:55 - I want to go for all of the cells I have
160:57 - just created
161:00 - and now I want to check if cell is in
161:03 - self dot canvas data
161:06 - meaning I want to check if any of the
161:08 - cells I've just created actually exist
161:11 - and have a Terrain tile or exist in the
161:13 - first place for now
161:15 - if that is the case I can get myself dot
161:18 - canvas data
161:20 - and pass in the cell
161:23 - I am currently looking at
161:25 - and whenever we start this I want to set
161:28 - my terrain neighbors to an empty list
161:30 - that way if we are running this check
161:32 - neighbors multiple times we're not
161:34 - adding pointless data in here which can
161:36 - be very problematic
161:38 - and once we have all of that we can
161:41 - actually check the neighbors of all of
161:44 - the tiles inside of this local cluster
161:47 - if this is the tile we have currently
161:49 - placed we have to check all of its
161:52 - neighbors
161:54 - all of the eight neighbors it can
161:56 - possibly have
161:57 - on top of that for all of the neighbors
162:00 - so all of the tiles in our local cluster
162:02 - these tiles here they also need to check
162:06 - what their neighbors are meaning once
162:08 - again we have to check what their
162:11 - neighbors are doing which means for
162:15 - every cell in local cluster if it exists
162:18 - we want to check all of the neighbors
162:20 - and for that inside of settings let me
162:23 - minimize the editor data we have
162:26 - neighbor directions inside of this
162:28 - dictionary we have a key a and then a
162:31 - position
162:33 - the way you have to think about it if
162:35 - this is the cell we are currently
162:37 - checking
162:38 - a is the one on top then we have b c e e
162:43 - f
162:45 - G and H
162:48 - the keys we have here these are all the
162:51 - four possible directions and this is
162:53 - what I want to check for which means in
162:56 - here I want to check for name and site
162:59 - in neighbor
163:03 - directions dot items don't forget that
163:07 - I want to get my current neighbor cell
163:10 - just to make the math a bit easier
163:12 - and this neighbor cell is going to be a
163:16 - cell I'm currently looking at
163:18 - and in here again we need X and Y so let
163:22 - me do cell zero
163:25 - and cell one
163:29 - right now we are copying the cell but
163:31 - that's not what I want to do instead I
163:33 - want to add a side
163:35 - which here is going to be side 0 and for
163:38 - y it is going to be side 1.
163:43 - aside as a reminder is always this
163:46 - position here
163:48 - for example for a the cell right on top
163:51 - if we're going zero for the x-axis and
163:54 - negative 1 for y we are staying here for
163:57 - x and we're just going up by one cell
164:00 - if we for example use D we are going one
164:03 - to the right
164:04 - this one here and then we're going one
164:07 - down this is this one here and that way
164:09 - we're ending up in the bottom right
164:11 - which means with this line we are
164:13 - getting the current neighbor inside of
164:15 - this for loop on this neighbor cell I
164:18 - first of all want to check if it exists
164:19 - in the first place so if neighbor cell
164:22 - in self dot canvas data
164:26 - if it's not in there there's no point
164:27 - doing anything because there is no cell
164:29 - however if there is one we can check if
164:32 - self dot canvas data I want to get the
164:36 - neighbor cell
164:37 - and now I want to check if it has a
164:40 - Terrain if that is the case I want to
164:42 - get myself dot canvas data and to sell I
164:46 - am currently looking at
164:48 - I want to get the terrain neighbors and
164:51 - I want to append the name
164:54 - this name here that we are looking at
164:57 - if we have a tile here and there's one
165:01 - tile on top only this tile would mean we
165:04 - are adding the letter A to terrain
165:06 - Neighbors
165:07 - and what that means if I open the
165:10 - graphics folder again
165:12 - here we go inside of this folder we for
165:15 - example have a and if we only have the
165:18 - terrain neighbor a it means this is the
165:21 - tile we are currently looking at and
165:23 - there's one tile on top and as a
165:25 - consequence we want to have a tile that
165:28 - ends at the bottom
165:30 - and that is all we need here
165:33 - I am fully aware that this logic here
165:35 - does get quite a bit more advanced so if
165:38 - you're following this there's a pretty
165:40 - good chance you're confused definitely
165:42 - go over this a couple of times to
165:44 - understand the logic but for now this is
165:47 - all we need so I can minimize check
165:49 - Neighbors
165:50 - and now when I'm drawing
165:53 - if tile has terrain I first of all want
165:56 - to have a Terrain string
165:59 - and this terrain string is going to be
166:02 - the title I'm currently looking at and
166:04 - then terrain neighbors this right now is
166:08 - going to be a list
166:10 - this list I want to convert
166:13 - to a string which I do with an empty
166:16 - string and then the join method
166:19 - although there's one more thing that we
166:21 - have to do let's say I want to have a
166:23 - Terrain
166:25 - Style
166:27 - this is not going to be
166:29 - self.land.x instead this is going to be
166:32 - the terrain string
166:35 - but only if the terrain string is in
166:40 - self.land tiles
166:42 - if that is not the case I want to add X
166:45 - what that means is if the terrain string
166:49 - we have created doesn't exist in the
166:51 - graphics we have imported I want to have
166:53 - the generic graphic X that basically
166:55 - always works
166:57 - this is both a safeguard so if we forgot
167:00 - to import one graphic the game doesn't
167:02 - crash on top of that
167:04 - some tiles are just by themselves and I
167:07 - didn't really account for that they are
167:09 - just way too many graphics
167:11 - and this way if they're by themselves we
167:13 - always have this outcome
167:15 - and we are nearly done the last thing we
167:18 - need is now I'm using
167:21 - this terrain style as a key to get the
167:24 - surface
167:25 - so terrain style in here
167:29 - and now this should be working let's try
167:33 - and let me show my mouse if I now print
167:36 - something
167:37 - we are getting something that almost
167:40 - Works uh not great yet but
167:47 - we have to work with this a tiny bit
167:48 - more
167:50 - let's have a look on the editor I'm
167:53 - pretty sure draw level works just fine
167:55 - because we are getting something
167:57 - so let's have a look at Czech neighbors
168:00 - and I can tell the error happened in
168:03 - here in the neighbor cell because this
168:05 - side should be one not zero
168:07 - now if I try this again
168:10 - and let me show my mouse again
168:13 - if I now draw on here we have a proper
168:17 - tiling system and this one is looking
168:19 - really good also if I move around all of
168:23 - this is still working just fine
168:26 - and with that we have the terrain I am
168:29 - really happy with this and this system
168:31 - is really satisfying
168:34 - cool so this covers a really large
168:36 - section before we finish with this part
168:39 - I do want to go over the main logic and
168:42 - just quickly explain it again I think
168:44 - this is a really important part that you
168:46 - absolutely have to understand
168:49 - inside of the editor Let Me minimize
168:51 - everything
168:53 - our starting point is always the canvas
168:56 - add method in here we are adding
168:58 - something to our editor these lines here
169:01 - in particular are the most important
169:03 - ones because in here we are creating a
169:06 - new canvas tile or we are adding to this
169:08 - canvas tile depending on what id we have
169:11 - after that we are checking all of the
169:15 - current neighbors and this is really
169:17 - important especially for the terrain
169:19 - tiles because this one determines the
169:21 - graphic of the terrain tile so let's
169:23 - have a look what check neighbors
169:25 - actually does and how it works first of
169:28 - all we are creating a local cluster
169:31 - think of if this one here is the title
169:34 - we are currently looking at we need to
169:36 - know all of the neighbors
169:39 - there are eight Neighbors in total that
169:43 - we are going to care about
169:47 - these eight here
169:49 - and that information is incredibly
169:51 - important because whenever we are
169:53 - placing a Terrain tile we need to know
169:55 - what its neighbors are doing for example
169:58 - if a Terrain tile has something on top
170:00 - it needs to be a bottom-ish tile
170:03 - and if there's a tile on top and a tile
170:07 - below it should be some kind of
170:09 - connector tile something like this that
170:12 - is open both on top and on the bottom
170:14 - also really important here why we are
170:17 - creating a cluster is later on in the
170:19 - game we might have thousands of terrain
170:21 - tiles and we don't want to check all of
170:24 - them we only want to check the ones that
170:26 - are right next to the current tire and
170:28 - this is why the local cluster here is
170:30 - incredibly important
170:32 - now once we have that what we need to do
170:35 - is to go for every single of these local
170:38 - tiles that we have created that is
170:41 - important because when we are placing a
170:43 - new tile let's say we are placing this
170:45 - yellow tile here if there's a tile to
170:47 - the right of it this one here this one
170:50 - needs to change as well
170:52 - if this one for example previously was
170:55 - by itself now if there's a tile on the
170:58 - right the yellow one here then this one
171:00 - needs to be open to the right
171:03 - and as a consequence
171:04 - we have to check for every cell in the
171:08 - local cluster we have to check all of
171:11 - these tiles here that is super important
171:16 - let me clean this one up a tiny bit so
171:19 - we can see what's going on
171:21 - on the next line we are checking if the
171:24 - cell is inside of the canvas data and
171:27 - once we have that we are creating an
171:29 - empty list for the neighbors and this
171:32 - list is going to contain some letters
171:34 - that are going to be important I'll talk
171:36 - about that right now actually
171:38 - what we're doing in this bit here
171:43 - most importantly for a name site in
171:45 - neighbor the directions and the items
171:49 - how this one is essentially going to
171:51 - work for every single one of these tiles
171:54 - we're going to check all of the
171:55 - neighbors the top neighbor would be a
171:58 - the top right would be B then we have C
172:01 - then d
172:03 - then e for the one right below then we
172:05 - have f d and H
172:09 - and essentially what we're doing we're
172:11 - going clockwise for every single tile
172:14 - inside of the local cluster and we are
172:16 - checking what neighbors are there
172:19 - and depending on what neighbors are
172:20 - available we're going to add the
172:22 - relevant number to terrain Neighbors
172:25 - let's say a tile has the neighbors a c
172:28 - and d
172:31 - then the strings we are going to attach
172:33 - in here are going to be a c and d all of
172:38 - that is happening down here which means
172:41 - by the end of it the terrain neighbors
172:43 - is just a list with a couple of strings
172:46 - inside and each string is one letter
172:48 - once we have that bit of information I
172:51 - can open the graphics folder again go to
172:53 - Graphics in here we have the terrain
172:55 - then we have land and inside of there we
172:59 - have all of these files with weird names
173:01 - but I hope now they make sense for
173:04 - example if we have a tile let's choose
173:08 - one it's a bit more random let's go with
173:12 - this one here this one is called CEF
173:15 - this means if we have a tile here we
173:19 - want to check if there's a tile in
173:21 - not in a not in B but there should be
173:25 - one in C then not in D
173:29 - but then in e f but not in G or h
173:35 - this CEF is going to come from the c e f
173:40 - depending on what the neighbors are that
173:42 - is how the entire system is going to
173:44 - work and that is also why there are
173:47 - going to be a ton of different Graphics
173:48 - in here
173:50 - on top of that there are quite a few
173:52 - duplicates in here for example if you
173:54 - check these two they are identical you
173:58 - could probably optimize this entire
174:00 - system quite a bit but in my case I'm
174:02 - not too concerned so all right the last
174:05 - thing we now need is to understand the
174:08 - system when we are drawing the level
174:10 - and we have some terrain like this one
174:13 - here
174:14 - we are combining the terrain neighbor
174:16 - strings into one larger string then we
174:19 - are checking if the string is inside of
174:22 - the imported graphics
174:23 - if that is not the case the string name
174:26 - is going to be x and x is if I open this
174:29 - again all the way at the bottom we have
174:31 - this tile here this one fits basically
174:34 - everywhere
174:36 - oh well it doesn't fit everywhere but it
174:38 - looks fine by itself
174:40 - and then this is going to be the graphic
174:42 - we are blitting on the screen
174:45 - I hope all of that makes sense the logic
174:47 - here does get a bit more complicated all
174:49 - right with that we have our terrains
174:52 - next up we can start working on the
174:55 - water
174:56 - let's talk about the water now and the
174:59 - water is going to work quite a bit like
175:02 - the terrain we again have to import some
175:05 - graphics and then check the neighbors of
175:07 - every tile and then we can draw the
175:09 - water although the water is going to be
175:11 - a little bit easier all we really care
175:13 - about if we have two water tiles like so
175:18 - the top water tile should have a water
175:20 - animation whereas the bottom water bit
175:24 - should have a plain graphic this one
175:27 - doesn't need to be animated
175:29 - for this section we are going to have
175:31 - the bottom graphic and we are going to
175:33 - know if we need a top graphic animation
175:36 - but the animation itself we are going to
175:39 - cover in the next part I want to keep
175:41 - things separated and the animations are
175:43 - a larger bit by themselves but we
175:46 - already have all the major Concepts in
175:48 - place so this shouldn't be too difficult
175:50 - let's Jump Right In once again we are in
175:53 - our code and I want to work inside of
175:56 - the editor I guess you could import the
176:00 - water surfaces in here like we have done
176:02 - for the land tiles
176:03 - although there aren't that many water
176:06 - tiles so I'm going to do all of this
176:08 - inside of the editor to keep things a
176:10 - bit cleaner and more self-contained
176:12 - inside of the editor
176:14 - what I want to do in here since we are
176:16 - going to import a few more things I want
176:18 - to create another method that I called
176:20 - import
176:22 - all we need in here is self and water
176:26 - bottom
176:28 - and this is just going to be a graphic
176:30 - we want to load
176:32 - for that I want to have the load method
176:35 - that is not available right now which I
176:38 - can fix quite easily I want from pygame
176:40 - dot image import load
176:44 - only now is a file path to my water
176:47 - bottom file this one if I open the
176:49 - graphics folder and make this a tiny bit
176:52 - smaller we have to go through Graphics
176:54 - inside of there we have the terrain and
176:59 - inside of the terrain we have water and
177:01 - there we have animation and water bottom
177:03 - water bottom is what we care about right
177:05 - now
177:06 - which means we have to add a string go
177:10 - one folder up then to graphics
177:13 - then to terrain and there we have water
177:15 - and in here I care about water bottom
177:19 - dot PNG
177:21 - water top we are not going to import
177:23 - right now because later on for the
177:26 - animations we are going to have separate
177:27 - Logic for that meaning for now this is
177:30 - all we are going to need
177:32 - don't forget to call it and this I have
177:35 - done after I have imported the lamp
177:37 - tiles I guess it kind of makes sense in
177:39 - here self dot Imports
177:42 - I think this was just import yeah just
177:44 - import
177:45 - let me actually
177:48 - self.import
177:50 - and now we have to figure out a few more
177:54 - things
177:55 - most importantly we have to work inside
177:58 - Czech neighbors one more time because in
178:01 - here we are checking the neighbors right
178:03 - now all we're doing in here is we are
178:06 - checking the neighbors of the terrain
178:07 - tiles
178:08 - let me actually add a comment in here to
178:11 - rain nay
178:13 - verse besides that I also want to know
178:17 - if water top neighbor exists
178:21 - to figure out the top neighbor here we
178:23 - are going to need a couple of things
178:25 - although before I am doing this I would
178:28 - really recommend you to try this one
178:29 - yourself you kind of have to modify the
178:32 - logic here a fair bit to figure out if
178:35 - there is
178:36 - let's say water in the current tile
178:41 - and another water tile on top
178:45 - if these conditions are true you know
178:48 - the tile on top has water
178:50 - if that is the case if I look at the
178:52 - canvas tile again in there we have has
178:55 - water this one we can already cover but
178:57 - what we care about is if we have to set
179:00 - water on top to true or not this is what
179:03 - we are trying to figure out
179:05 - however if these two conditions are true
179:08 - then we can set water on top to true so
179:11 - pause the video now and see if we can
179:13 - figure this one out yourself
179:17 - I want to check if self dot canvas data
179:22 - and now I want to look at the neighbor
179:25 - cell that's the one we have created up
179:27 - here
179:28 - on this one I want to check if it has
179:32 - water on top of that I want to check if
179:36 - self dot canvas data and my current cell
179:40 - that is the cell we are checking from
179:42 - the current cluster and that's basically
179:44 - our current cell the one that we are
179:46 - working with right now if that is the
179:49 - case I know one of the neighbor cells
179:51 - has water but what I care about here in
179:54 - particular is if this cell is on top of
179:58 - the current cell and that I can check
180:01 - with another condition the condition
180:03 - being if name is equal to a
180:08 - there you can see it all this works
180:10 - because if I go to settings in here we
180:13 - have the neighbor directions and a is
180:16 - the cell right on top
180:18 - or in other words it's the top neighbor
180:20 - this is the only one we really care
180:22 - about
180:24 - if that is the case I want to get
180:26 - self.canvas data and my current cell
180:30 - on this I want to set water on top to
180:34 - true on top of that there's one more
180:37 - thing that I do want to do like we have
180:39 - done with the terrain neighbors I want
180:41 - to set self dot canvas data and sell
180:46 - water on top should be false
180:50 - meaning every time we are running this
180:53 - we first of all remove all of the
180:56 - neighbors that makes it much easier
180:59 - later on when we're deleting tiles to
181:01 - not worry about this again the reason
181:03 - why this one is important and let me
181:05 - remove the comments here if we didn't
181:08 - have these two lines later on when we
181:11 - are deleting tiles we would have a
181:13 - problem let's say you have two tiles
181:17 - of water
181:19 - and as a consequence the top tile here
181:21 - has water for the animation
181:24 - on top of that the bottom tile here this
181:27 - one would have water on top being true
181:30 - however if we delete it this top tile
181:33 - the bottom tile would still have water
181:36 - on top as true and as a consequence the
181:39 - graphic now would be wrong
181:41 - the same would happen with the terrain
181:44 - neighbors and all of this can be avoided
181:46 - with these two lines here we are
181:48 - basically resetting the entire system
181:50 - and then recreating it from scratch and
181:52 - that way later on when we delete things
181:54 - this makes everything much easier
181:57 - so with that we have the neighbors for
182:00 - the water or the one neighbor
182:03 - all we need now when we are drawing the
182:06 - level
182:07 - we have to account for that
182:09 - and this happens inside tile has water
182:13 - in here I want to check if tile water on
182:17 - top
182:18 - if that is the case I want to get myself
182:21 - dot display surface and I want to split
182:25 - something
182:26 - once again I need a surface and I need a
182:29 - position the position we already have
182:31 - that's the one we created up here the
182:33 - surface we also have that's the one we
182:36 - imported in self dot Imports this one
182:39 - here
182:39 - which means all we have to do now is
182:44 - self.water bottom I think I called it
182:47 - and that is literally all we need I
182:50 - guess one more thing that we do need is
182:53 - the rest should be inside of an else
182:54 - statement and I'm going to change the
182:57 - color to make this a bit more emphasized
182:59 - let's change this to a red color so it's
183:02 - definitely visible
183:04 - now let me run main.pi again and we are
183:07 - getting an error that we have some
183:09 - problem in self-import
183:11 - and I believe I know what the issue is
183:14 - import is a restricted name because we
183:18 - are using import here and that one
183:19 - confuses python let's change it to
183:22 - Imports and that should fix the entire
183:25 - thing
183:26 - there we go this is much better now if I
183:29 - show my mouse and I switch to water
183:32 - we are getting a key error
183:35 - let's have a look I think I already know
183:37 - where the issue is
183:39 - it is definitely going to happen
183:40 - somewhere in here and while we are here
183:43 - I realized on this self canvas data and
183:46 - cell we want to check if this one has
183:49 - water the main problem we have right now
183:51 - is when we're using the neighbor cell on
183:54 - canvas data this tile does not exist
183:58 - that wasn't a problem for the terrain
184:00 - neighbors because they have we are
184:02 - checking if the neighbor cell was in the
184:04 - canvas data this if statement we want to
184:07 - do for the water as well
184:09 - like so and this one has to be indented
184:12 - and now this should be working we are
184:15 - only doing this operation if the
184:17 - neighbor cell actually exists
184:20 - now let's try this again
184:23 - and let me show my mouse again right now
184:25 - I have the terrain and this one works
184:28 - just fine if I now change to water we're
184:31 - getting a red cell but now we're getting
184:33 - a water tile and the water tile we are
184:36 - only getting if we have water on top if
184:39 - we don't
184:39 - we don't get that and this one also
184:42 - updates perfectly fine so this is a
184:46 - pretty good start for the water
184:48 - definitely a good start and sorry about
184:50 - the errors it's kind of hard to keep
184:52 - this much code organized and explain it
184:54 - at the same time but with that we have
184:57 - the water or at least parts of the water
184:59 - what we know to figure out is a bunch of
185:02 - animations and that's gonna be its own
185:04 - section for the next part we are going
185:07 - to create the animated tiles
185:10 - in the game there are lots of tiles that
185:13 - can be animated like the top water the
185:16 - coins and the enemies those are the main
185:18 - ones there is also going to be the
185:20 - player and the palm trees but those are
185:23 - going to be objects not tiles
185:25 - welcome to those later in this tutorial
185:27 - now for the animations to work we first
185:30 - of all have to import a ton of different
185:32 - graphics
185:34 - after that we have to figure out how to
185:36 - animate all of these separate objects
185:38 - and for this one we are not going to use
185:41 - Sprites
185:42 - you might actually Wonder so far for
185:45 - each tile why am I not using a Sprite
185:48 - for example each terrain tile could be a
185:51 - Sprite
185:52 - the answer here is that Sprites are
185:54 - generally fine but in the editor we
185:57 - could potentially have thousands of
185:59 - items on the screen at the same time and
186:01 - for that Sprites would be very slow and
186:05 - avoiding them improved game performance
186:07 - significantly when I tested all of this
186:09 - if I remember correctly when I use
186:11 - Sprites you could only place about two
186:14 - to three hundred terrain tiles and then
186:16 - the game would slow down drastically if
186:18 - we don't use Sprites we can place up to
186:20 - a thousand and not really have
186:22 - performance issues although later on we
186:25 - are going to use them to an extent but
186:27 - alright with that covered we can start
186:29 - working in the code once more we have
186:32 - main.pi again and once again I want to
186:34 - work inside of the editor Let Me
186:37 - minimize everything and I want to add a
186:41 - bit of white space Here and Now work in
186:43 - Imports again what I have to do in here
186:46 - I have to import animations let's just
186:49 - call it animations because we already
186:51 - importing in here anyway essentially
186:54 - what I want to have I want to have a
186:56 - dictionary that I called animations for
186:59 - now it's just going to be an empty
187:00 - dictionary inside of it I want to have
187:03 - something like this I want to have first
187:05 - of all a key let's go if I look at
187:09 - settings
187:10 - we can look for example at the water and
187:13 - the water would have an index of three
187:15 - this three I want to keep here and then
187:18 - the associated value is going to be
187:20 - another dictionary with three items
187:23 - we have a frame index
187:26 - and this one is always going to start at
187:28 - zero then I want to have the frames and
187:32 - those are going to be let's say it's
187:35 - going to be a list and this list is
187:37 - going to contain surfaces
187:39 - the surfaces we're going to Loop through
187:41 - for the animation
187:43 - finally the last thing I want
187:46 - is going to be the length of the
187:50 - animation and this could be an integer
187:52 - let's say four or rather for the water
187:54 - we have three animation frames
187:57 - once we have all of this we can create
188:00 - animations fairly easily first of all I
188:04 - need for key and value in editor data
188:09 - dot items meaning we are looping through
188:12 - this entire thing here
188:14 - inside of that I want to check if the
188:17 - value has an entry for graphics
188:21 - and only if that is the case I guess
188:23 - let's talk about Graphics first if I
188:25 - look at settings
188:26 - for example for water and I scrolled to
188:30 - the right quite a bit
188:32 - all the way at the end we have a
188:33 - graphics key and the associated value is
188:36 - a folder
188:38 - for the water it would be the animation
188:40 - for the top this is what we care about
188:41 - here for example for the gold coin
188:44 - that's this one here
188:45 - we have a folder for the gold coin and
188:50 - all of these contain animations and this
188:52 - is what I want to import
188:54 - which means first of all I want to
188:56 - create a graphics variable and now I
188:58 - want to import a folder like we have
189:02 - done in main.pi
189:04 - let me copy from support import
189:06 - everything and this I want to do in here
189:09 - as well and let me add a bit of white
189:11 - space all of this is a bit easier to
189:14 - understand
189:15 - the file path we are getting from value
189:18 - graphics
189:20 - there we go and with that we have
189:22 - Graphics imported
189:24 - next up we need to actually create an
189:28 - entry inside of this dictionary for that
189:31 - I want to have self.animations
189:34 - and now I need a key the key I am
189:38 - already getting from this one so I can
189:40 - just pass in key in here the value I am
189:43 - going to give it is going to be another
189:45 - dictionary the dictionary we have
189:47 - created here or we are going to create
189:50 - we always start with a frame index and
189:53 - this one is always going to be zero
189:56 - after that we want some frames and the
189:59 - frames are going to be the graphics
190:01 - finally I want to have the length of the
190:04 - animation
190:06 - and this is just going to be the length
190:08 - of my frames which is going to be the
190:11 - length of the graphics folder that is
190:13 - all we need I can now delete the example
190:16 - and print what we actually get print
190:19 - self dot animations
190:22 - if I now run all of this
190:26 - you can see if I for example look at the
190:29 - first bit we have zero and this one has
190:33 - a bunch of different things this is all
190:35 - the stuff for the player that's not what
190:37 - we care about right now I guess this one
190:39 - here is better we have three that's the
190:41 - one for the water we have a frame index
190:43 - of zero then we have frames and this is
190:46 - a list with three items
190:49 - these free bits here and finally we have
190:52 - a length this one is telling us when we
190:54 - have to stop the animation and start
190:56 - again that looks really good with that I
190:59 - can minimize let me first get rid of the
191:02 - print statement now I can minimize the
191:04 - Imports method what we are now able to
191:07 - do inside of draw level we can start
191:10 - using these imported Graphics let's
191:13 - start with water
191:15 - first of all in here I want to have the
191:18 - frames more isolated and those I get
191:20 - with self dot animations
191:23 - and I know the water is always going to
191:26 - have the index three so I can just pass
191:28 - it in here and from that I want to get
191:30 - the frames
191:32 - this is going to give me the water
191:34 - animation frames
191:35 - besides that I need to have some kind of
191:38 - index because this here is a list and we
191:43 - have to pick one item from it
191:45 - for that we have self dot animations
191:49 - the same entry again for the water and
191:52 - in here we want to have the frame Index
191:56 - this one we're going to increase over
191:59 - time and if this for example gets to one
192:02 - or two we're going to pick a different
192:04 - item by default it's going to be zero
192:07 - although since this value could
192:10 - potentially become a floating Point
192:11 - number I always want to convert this to
192:14 - an integer finally let me get rid of
192:16 - these two items here and instead I want
192:19 - to create another surface and this is
192:21 - going to be frames and index
192:24 - finally all I have to do is get rid of
192:26 - this test so we're using this surface
192:29 - here
192:30 - and now let's try if this is working
192:34 - I can still draw terrain just fine and
192:37 - now if I print water we are getting at
192:41 - least a proper graphic so this is
192:43 - already definitely some progress
192:46 - although not entirely what we needed but
192:49 - at the very least this one is working
192:51 - all we have to figure out now is how to
192:54 - increase this index over time for that
192:57 - I'm going to minimize draw level and
193:00 - inside of support I need another method
193:04 - this one I called animation update and
193:09 - then here we need self and we need Delta
193:11 - time all I really want to do in here I
193:14 - want to go through my self.animations
193:18 - dictionary although for this one I only
193:20 - really care about the values which means
193:23 - or
193:24 - value in
193:28 - self dot animations dot well use
193:33 - in here for each value I want to get the
193:38 - frame index
193:40 - and this I want to increase by what is
193:43 - called the animation speed
193:46 - this is a constant that I have defined
193:49 - inside of settings it's always going to
193:52 - be eight although you could change the
193:53 - number if you feel the animations are
193:55 - too fast or too slow
193:57 - and this value I want to multiply with
194:00 - Delta time that way its frame rate
194:02 - independent if your game slows down or
194:04 - runs really fast the animation speed is
194:06 - going to be the same finally we have one
194:09 - more problem and that is if
194:12 - value and frame index
194:16 - is greater or equal than value and the
194:20 - length of the animation
194:23 - think of it like this the frame index
194:26 - always starts at zero and we are
194:29 - increasing this number by a small amount
194:32 - on every single frame let's say by 0.2
194:38 - which means on the first frame we have
194:40 - zero then we have 0.2 and we have 0.4
194:47 - let me separate this properly and so on
194:50 - this is fine for quite some time at
194:52 - least a couple of frames however quite
194:55 - fast we are going to get a number that
194:58 - is let me put it on the next line we are
195:01 - going to get a number that is let's say
195:03 - a 7.2 completely random number
195:07 - the issue with this 7.2 is that we only
195:11 - have for the water we have three
195:14 - animation frames
195:16 - and since we are indexing later on this
195:19 - 7.3 is going to cause an error
195:23 - because we are trying to get a larger
195:25 - index that exists inside of a list
195:28 - which is going to be an issue that we
195:29 - have to account for
195:31 - accounting for it is very easy though I
195:34 - just want to get my value frame index
195:36 - again and set it to zero
195:40 - which means every time the frame index
195:43 - gets created in the length of the list
195:45 - so we are exceeding the animation we
195:47 - want to restart the animation with that
195:49 - we have the animation update all we have
195:52 - to figure out now is when to call it
195:55 - for that let me minimize it inside of
195:58 - the run method
195:59 - we only have a drawing part right now I
196:03 - want to add
196:05 - I'm going to call it updating as a
196:09 - section in here I want
196:12 - self.animation update don't forget to
196:15 - pass Delta time in here and now we
196:18 - should be done actually if I now run
196:21 - this again
196:22 - show my mouse
196:24 - the terrain tiles work just as before
196:26 - and now for the water we have animations
196:29 - the bottom ones still work just fine and
196:33 - I can add things and have all of this
196:36 - work perfectly fine
196:40 - and the reason why this is working if I
196:42 - look inside of draw level again we still
196:45 - have the same logic here the only
196:47 - difference now is that this number keeps
196:50 - on increasing at the start it is always
196:53 - going to be zero but because of
196:55 - Animation update this number gets larger
196:57 - and larger although at some point if
197:00 - we're exceeding the length of the
197:01 - animation it goes back to zero but that
197:04 - is literally all that this one is doing
197:06 - with that I can minimize hairspot it has
197:10 - terrain because those two are done and
197:12 - now what we have to do is cover the coin
197:14 - and the enemy
197:15 - and those two I think would be a really
197:18 - interesting exercise for you
197:20 - inside of the dictionary there are coin
197:23 - animations and they are enemy animations
197:25 - try to draw them with the animation and
197:28 - see if you can figure this one out
197:33 - let's start with the tile coin in here
197:37 - once again we need to get some frames
197:41 - and the frames I want to get in here is
197:43 - once again self dot animations
197:46 - the same thing we have done for the
197:48 - water up here although now for the coins
197:51 - we are not entirely sure what kind of
197:54 - index we have because title coin could
197:58 - be either 4 5 or 6. the number here
198:00 - depends if we have a gold or silver coin
198:03 - or a diamond
198:04 - fortunately that's not really something
198:05 - we have to worry about because we can
198:08 - just pass in tile.coin in here because
198:11 - this one stores the number four five or
198:13 - six depending on what coin we have and
198:16 - on that I want to get the frames
198:19 - with that I have the graphics
198:22 - next up I need the index
198:25 - for that I can just copy the line we
198:28 - have created up here and change the
198:30 - three to tile
198:32 - and coin I can get rid of this test
198:35 - surface and replace it with frames and
198:39 - my index
198:41 - I also don't want to fill anything
198:43 - anymore instead I want to get the
198:46 - surface and get the position
198:48 - and then we should be almost done
198:51 - there's one more thing we have to do but
198:52 - we should at the very least have an
198:54 - animation
198:55 - if I run this again
198:57 - and select a coin I can place some coins
199:01 - also now if I select the silver coin
199:04 - I can't draw them and if I draw them
199:07 - over gold coin the gold coin disappears
199:09 - this also works with the diamonds so
199:12 - this is working really nicely
199:15 - on top of that if I pan around this also
199:18 - works with the panning around
199:22 - however let me actually run this again
199:24 - if I only create one coin the problem
199:27 - you can see right now is that this coin
199:30 - is always in the top right corner
199:32 - instead it should be right in the center
199:37 - which means we have to make a few more
199:39 - adjustments
199:41 - the way I approach this I have created a
199:44 - rectangle and for this one I want to get
199:46 - the surface we just created and then get
199:49 - underscore wrecked
199:51 - I want to place this center for the
199:54 - center we need an X and A Y position
199:58 - although we already have that to an
200:00 - extent we have position 0 that's the X
200:03 - bit and we have position
200:06 - one that's the way but this is what we
200:08 - have created up here the problem is
200:10 - these two numbers are too far to the top
200:13 - left let me draw a tile that looks like
200:16 - this these two positions are this top
200:19 - bit up here and since the surface
200:21 - doesn't cover this entire area we are
200:24 - placing the surface here which is why
200:27 - the coin is in the top left of each tile
200:30 - to account for that I want to move the
200:32 - center of the coin so this Center here
200:35 - to the middle of the current tile
200:39 - for that I have to get the top left move
200:42 - it to the center or increase it by half
200:46 - of this entire width the same thing I
200:50 - have to do for the height this is going
200:52 - to be one half
200:54 - of the entire thing
200:56 - if I do that this top Point here is
200:59 - right in the center and this is exactly
201:02 - the point I'm looking for
201:04 - which means all I have to do is to add
201:07 - tile size and divide it by two
201:12 - the same thing I have to do for the Y
201:15 - position and now what I'm placing all of
201:19 - this with blit I don't want to have a
201:21 - position I want to have a rectangle
201:24 - let's try it now
201:25 - and now if I place the coins this is
201:29 - looking much better also works with the
201:31 - other coins and with the diamonds
201:33 - and big nozzle pan around all of this
201:36 - looks pretty good I can also still place
201:39 - the terrain and I can place the water
201:42 - oh this is looking really good
201:45 - finally I can minimize the tile coin and
201:49 - we have to work on the enemies
201:51 - although truth be told this is going to
201:53 - be quite some luck compared to the coins
201:55 - so let me copy a bit of code here
201:58 - although I guess you could make this a
202:01 - tiny bit more efficient but in my case
202:03 - I'm not too concerned
202:05 - fourth childhood enemy we want to have
202:07 - tile and enemy and then the frames for
202:12 - the index we also want to have the enemy
202:14 - index surface can remain identical
202:17 - though
202:18 - and the center we probably have to
202:21 - change in just a bit but for now let's
202:23 - see what this one is actually doing
202:25 - if I now select one of the enemies
202:28 - this is the bottom right bit here I can
202:31 - now Place some spikes this one's looking
202:33 - good I can place this little guy here he
202:36 - animates and we can place the shells
202:39 - also the shot can go left or right
202:43 - most of this is looking pretty good
202:45 - although we do have a bit of a problem
202:47 - and that is
202:50 - this area down here right now all of the
202:54 - shells are floating and there's a tiny
202:57 - Gap below the enemy this I do have to
203:01 - account for which I'm doing inside of
203:04 - this line here
203:06 - what I want to do now I want to place
203:08 - the mid bottom if you imagine that this
203:12 - is the cell and this is the top left
203:14 - part of the cell this used to be our
203:16 - origin point now what I want to do is
203:19 - this mid bottom is going to be this
203:21 - point and this is what I want to have
203:23 - for the origin Point as a consequence
203:26 - kinda similar compared to what we have
203:28 - done with the coins we have to go
203:30 - halfway
203:33 - one half to the right except now we have
203:36 - to go the entire height down so just one
203:40 - the entire height of the tile
203:42 - and then we're ending on this point here
203:46 - which means for X we don't have to make
203:48 - any kind of change only for y we have to
203:51 - get rid of the divide by two and that
203:55 - should be all if I now run this again
203:58 - I can select some spikes they still work
204:00 - just fine but if I now place an enemy he
204:03 - is right on the bottom and most
204:06 - importantly the shells are also on the
204:08 - bottom
204:11 - and that is looking really good cool
204:14 - so with that we have the animations
204:17 - there's one more really important thing
204:20 - that we have to cover and that is
204:22 - deleting tiles for now we are only able
204:25 - to add more tiles but well we couldn't
204:27 - get rid of them let's work on that and
204:30 - that's not going to be too difficult so
204:32 - we can jump right in once again we are
204:35 - in main.pi and I want to work inside of
204:39 - the editor in here inside of the input
204:43 - section I already have canvas add I now
204:46 - want to add canvas remove
204:49 - neat self and nothing else
204:52 - and the first thing we have to check in
204:54 - here is if we are right clicking on the
204:57 - canvas and if we are not clicking on the
204:59 - menu
205:00 - this means I want to check if Mouse
205:04 - buttons don't forget to call it and two
205:07 - this is going to be the right click and
205:10 - not self dot menu Dot rect and Collide
205:15 - point
205:16 - with my mouse position
205:19 - and it should be fairly obvious I only
205:21 - want to delete tiles if I am right
205:24 - clicking and if I'm not clicking on the
205:25 - menu if that is the case
205:28 - I first of all want to check if self dot
205:31 - canvas has any kind of Entry if it
205:35 - doesn't there isn't any point in
205:36 - deleting anything if that is the case
205:38 - however I want to get my current cell
205:42 - that I get from self and get current
205:46 - sell once I have that I want to check if
205:49 - the current cell is in
205:52 - self.canvas data now I know that I have
205:56 - right clicked somewhere on the canvas
205:57 - there's something inside of the canvas
206:00 - and I know the position of where I have
206:02 - clicked if where I have clicked actually
206:05 - targets an existing tile I want to get
206:08 - this tile so self dot canvas data and
206:13 - the current cell
206:14 - and on this I want to remove ID with
206:19 - self.selection Index this remove ID is
206:23 - going to work kind of similar compared
206:25 - to ad ID if I scroll down a tiny bit and
206:28 - minimize the init method we have ADD ID
206:32 - remove ID is going to be another method
206:37 - that has the same parameters
206:39 - and is kind of going to do the opposite
206:43 - once again I want to get my options I
206:46 - can just copy them and besides that I
206:49 - can actually copy the entire thing
206:50 - because we are going to check for every
206:53 - single kind of option we have here I
206:56 - should probably explain for the tile
206:59 - delete Logic the way deleting is going
207:01 - to work is we can only delete the
207:04 - currently selected tile index for
207:07 - example I only want to be able to delete
207:09 - terrain if I have terrain currently
207:11 - selected same for water same for the
207:14 - coins and so on that way I have some
207:17 - control over what I am going to delete
207:20 - all I have to do in here now is when I'm
207:22 - removing something I'm going to set
207:24 - terrain and has terrain to false
207:27 - the same thing I want to do for the
207:29 - water this one should be false
207:31 - self.coin should be none and self dot
207:34 - enemy should also be none there's one
207:37 - more thing that I do want to check this
207:40 - I have called is going to be another
207:41 - method self dot check
207:45 - content
207:46 - let me create it right here again
207:49 - what this one is going to do is if all
207:54 - of these cases are false meaning on this
207:57 - current tile there simply is no data I
208:00 - want to delete this entire tile
208:03 - the problem is
208:05 - I cannot do this from inside of the tile
208:08 - because all of this is stored inside of
208:11 - self.canvas data the dictionary
208:14 - which means for now inside of this check
208:17 - content I want to have an attribute that
208:19 - is called self dot is empty
208:23 - if there's nothing left inside of this
208:26 - tile meaning all of these cases are
208:27 - false or none this one should be set to
208:30 - true that being said by default inside
208:33 - of the init method let me do it all the
208:35 - way at the end self dot is empty is
208:39 - going to be false
208:41 - all I have to do now is to figure out
208:43 - when this is going to be empty
208:46 - and that is basically just a bunch of if
208:49 - statements so if not self dot has
208:52 - not water but Terrain
208:55 - and not
208:57 - self.s now we have water
209:00 - and not self.coin and node self Dot and
209:05 - me if all of these are wrong I know this
209:08 - one is going to be empty
209:10 - once I know that it is going to be empty
209:13 - inside of canvas remove
209:16 - I can now check after I added a bit of
209:19 - white space if self dot canvas data
209:23 - and my current cell if this one is empty
209:29 - then I want to delete this current cell
209:32 - or the entire key value pair like so and
209:36 - then I am done
209:37 - let's try this actually so inside of the
209:40 - event Loop besides cell dot canvas Edge
209:42 - I also want to have self.canvas remove
209:46 - and I guess I could add a bit of white
209:48 - space here to make all of this a bit
209:50 - more spacious cool so now inside of
209:54 - main.pi I am getting an error
209:57 - that I made a typo this one should be
210:00 - delete not Define
210:02 - never on this again this is looking good
210:05 - and I can place some terrain tiles and
210:09 - now if I right click
210:11 - we are getting an error
210:15 - this remove ID we have a problem
210:19 - the reason here is this should be remove
210:21 - ID
210:23 - now if I play some terrain tiles
210:26 - I can right click and it disappears
210:29 - although you can see a problem we have
210:31 - to call check neighbors again to update
210:33 - this entire thing otherwise it would
210:36 - look a bit weird
210:37 - but that we can do quite easily if I
210:40 - minimize canvas tile
210:43 - after I have run all of this
210:48 - I want to run
210:49 - self.check Neighbors
210:52 - in here don't forget I have to pass in
210:54 - my current cell
210:56 - although I messed up the annotations
210:57 - here a tiny bit those two
211:00 - should only be run if we are
211:04 - or if the current cell is in the canvas
211:06 - data otherwise this line here might
211:08 - cause an error because
211:10 - this tile might not exist
211:14 - but with that
211:17 - let's try all of this one more time I
211:19 - can place some terrain tiles and now if
211:22 - I right click they disappear and this is
211:25 - feeling really good
211:27 - I can keep on adding and removing also
211:31 - now if I add some water
211:34 - I can also remove this and it updates
211:36 - perfectly fine
211:38 - and now to understand the system if I
211:41 - place a gold coin
211:42 - like so and if I right click now on the
211:45 - water the water isn't being affected but
211:48 - if I go over the coins the coins are
211:50 - affected that way I have quite a bit of
211:53 - control over what I am going to delete
211:54 - which I quite think is useful
212:02 - well with that
212:04 - we have been making quite a bit of
212:06 - progress this is definitely a very
212:09 - satisfying system
212:11 - or the next part we can start working on
212:14 - the objects and let me explain what that
212:16 - is going to mean
212:18 - so far we only worked with tiles those
212:22 - are always going to be placed in a grid
212:24 - however some objects in the game are
212:27 - supposed to be working differently and
212:29 - those are going to be called objects
212:30 - these can be moved flexibly anywhere on
212:33 - the screen the best example here is the
212:36 - player this one needs to be moved
212:37 - anywhere wherever we want and I think
212:41 - the best way to think about it is to
212:43 - actually illustrate it so let me run the
212:45 - finished game
212:48 - this one here and here you can already
212:51 - see we have the tiles just as before and
212:54 - I can also Place water tiles all of this
212:57 - is what we already have however now we
213:00 - can move the player around wherever we
213:02 - want there is no limitation in terms of
213:05 - tiles the same thing is also going to
213:07 - work with the sky so the sky we can move
213:09 - up and down as we want there's no
213:12 - limitation in terms of tiles
213:15 - furthermore we have the palm trees and
213:18 - those can also be moved around freely
213:20 - because for those let me place a few
213:23 - more
213:25 - those just don't really fit exactly on a
213:28 - tile grid I want it to be more flexible
213:30 - here and all of this is what we are
213:33 - going to implement via objects so this
213:36 - is what we have to work on
213:38 - all of this though is going to require
213:40 - quite a bit of additional logic so let's
213:43 - Jump Right In and let's cover all of it
213:46 - here we are back in the project and once
213:48 - again I want to work inside of the
213:50 - editor in here we need some kind of
213:53 - object that can actually work as well an
213:57 - object and in my case I have used
213:59 - Sprites for that so fundamentally we
214:02 - have two different things to draw the
214:03 - level we have all of the tiles those are
214:07 - the canvas tiles and besides that I want
214:10 - to create another class this one I have
214:13 - called canvas object and importantly
214:16 - here this one is going to be a Sprite so
214:19 - we have to inherit from pygame.sprite
214:21 - dot Sprite
214:23 - as a consequence the first thing we have
214:25 - to do is declare an init method and here
214:29 - we need itself besides that we're going
214:31 - to need a position we are going to need
214:34 - some frames as well because the objects
214:36 - are also going to be animated
214:38 - besides that each object is also going
214:41 - to have a tile ID that way we can
214:44 - identify it this for example means
214:46 - inside of settings
214:49 - all of the palm trees are going to be
214:51 - objects
214:52 - and I want to store the 11 12 13 and so
214:56 - on for each of them that way I know
214:58 - exactly what kind of object I am working
215:00 - with besides that I also want to have an
215:03 - origin point this one I'm going to
215:06 - explain more in just a bit but this one
215:08 - is really important to figure out where
215:11 - this canvas object is placed inside of
215:13 - the grid finally we need a group because
215:15 - we have a Sprite and we need to place
215:18 - the Sprite inside of a group
215:19 - with all of that covered we have to call
215:22 - this super init method and pass in the
215:26 - group in here just to get started for
215:29 - now I want to create a basic self.image
215:32 - and this is just going to be pygame Dot
215:36 - surface in here we can create a surface
215:40 - with the size of 100 times 200.
215:43 - this I want to fill with a color so we
215:45 - can see it more easily let's go with red
215:48 - and finally we are going to need a
215:51 - rectangle so self.rect and this is going
215:54 - to be self.mage.get underscore rect
215:59 - this should also be spelled correctly in
216:02 - here I want to place the center
216:04 - wherever the position is and I am
216:07 - getting much worse at typing there we go
216:09 - with all of this at the very least we
216:11 - have some kind of sprite that we are
216:14 - able to see we just have to figure out
216:16 - how to place it
216:18 - for that we have multiple angles
216:21 - if I look at settings we have all of
216:24 - these different palm trees here we have
216:26 - the foreground palm trees and the
216:28 - background palm trees those I want to be
216:31 - able to select from the menu and then
216:32 - place anywhere on the screen
216:34 - however besides that I also have the
216:37 - player and I have the sky
216:40 - those are going to be on the level when
216:43 - we are starting the level meaning those
216:45 - cannot be placed they are always there
216:47 - as a consequence both of those have to
216:50 - be created inside of the init method so
216:52 - we already have them
216:53 - and that makes it quite easy to fix
216:55 - things as they come along so let's get
216:57 - started by placing the player this one
216:59 - is just going to be another canvas
217:01 - object all of this is going to happen
217:04 - inside of the init method in here let's
217:07 - do it all the way at the bottom
217:09 - I want to place the objects
217:12 - for that first of all I have to create a
217:15 - group this let's call it canvas objects
217:19 - this is just going to be pygame.sprite
217:22 - dot group
217:24 - once we have that I want to create one
217:26 - canvas object and that is going to be
217:29 - the player
217:30 - I suppose I could add a comment here
217:33 - that is going to be the player
217:36 - we don't actually have to store this
217:37 - canvas object inside of an attribute you
217:40 - could but there's simply no reason for
217:42 - it
217:43 - in here we now need all of the
217:46 - parameters that we have created in here
217:48 - let me copy them
217:50 - and fill them with some kind of argument
217:53 - for the position we can go Fairly random
217:56 - in my case I went 200 pixels from the
217:59 - left and then I place the player in the
218:01 - center of the window in the y-axis which
218:03 - means window height divided by 2.
218:07 - after that we are going to need the
218:09 - frames those we are getting from
218:11 - settings as well because in settings if
218:14 - I scroll down the player does have some
218:16 - graphics we can just use those we
218:19 - already have them imported those we have
218:21 - inside of imports and inside of the
218:24 - animations
218:26 - which means I want to get
218:28 - self.animations
218:30 - the index I'm looking for here is zero
218:32 - that is the player and on this I want to
218:35 - get the frames
218:38 - I hope you can remember this is what we
218:39 - have imported here
218:41 - next up we have the tile ID for the
218:43 - player this one is going to be zero and
218:46 - the origin is going to be the origin of
218:50 - the actual editor which means it is this
218:54 - origin here
218:56 - meaning I can just place self.orgion in
218:59 - here and I'm good to go inside of the
219:01 - class later on we are going to work with
219:03 - this quite a bit for now don't worry too
219:05 - much about it
219:06 - finally we need to group and this is
219:08 - self dot canvas objects
219:12 - with all of that going over multiple
219:13 - lines let me use named arguments so it's
219:18 - a bit easier to read
219:19 - we have the position we have the frames
219:24 - then we have the tile ID next up is the
219:29 - origin
219:31 - and finally we have the group
219:34 - much easier to read
219:36 - if I run this now
219:38 - we can't say any difference the reason
219:40 - is
219:41 - we are not drawing any of these objects
219:44 - that we can do quite easily inside of
219:47 - raw level
219:49 - after we have done all of this here
219:52 - I want to get my self dot canvas objects
219:56 - and draw them on the display surface
220:01 - and now if I run this we can see we have
220:04 - an object this is going to be the player
220:07 - we can't really see it right now but at
220:09 - the very least something is going to
220:11 - happen
220:12 - although the issue is if I pan around
220:17 - you can see the player doesn't update or
220:19 - doesn't pan around with the rest of the
220:21 - level which is something we do have to
220:23 - work on
220:25 - all of that is going to happen inside of
220:27 - the canvas object or at least most of it
220:29 - is
220:30 - I am going to add a movement section
220:33 - here like so
220:35 - and this one is going to first of all
220:38 - need
220:39 - self and distance to origin this is a
220:43 - really important thing we have to know
220:45 - and this needs to be a vector with the
220:48 - distance of my current object let me
220:51 - draw this actually
220:52 - I want to know when I am placing or
220:55 - creating the Sprite we have the entire
220:57 - window and somewhere in here we have the
221:01 - Sprite besides that we have the origin
221:03 - somewhere here what I want to know in
221:06 - distance to origin is going to be this
221:09 - distance here
221:11 - we have done this earlier so it
221:13 - shouldn't be too difficult the math here
221:15 - really isn't too challenging
221:18 - all we need is a vector of self.rect and
221:21 - top left
221:23 - and from that I'm going to subtract the
221:25 - origin this is the origin we're getting
221:28 - from the parameters
221:29 - which is the origin we are passing in
221:33 - here which is the actual origin up here
221:36 - of the level or the editor
221:40 - once I have that bit of information I
221:43 - can create another method let's call it
221:46 - pan position in here we need self and we
221:49 - need to know where the origin point is
221:51 - which means I want to pass in An Origin
221:54 - in here
221:55 - and now we are going to do basically
221:57 - what we have done way earlier in this
221:59 - tutorial
222:00 - which is when we are panning around
222:03 - meaning we have the origin point and we
222:06 - are moving the origin point in this
222:08 - direction
222:09 - if we now have a Sprite we want this
222:13 - Sprite with this origin point we want
222:16 - this Sprite to move in the same
222:19 - direction
222:20 - those two errors here are supposed to be
222:22 - identical I'm just bad at drawing
222:25 - to achieve that what we are going to do
222:28 - we are going to place the top left on
222:31 - the position of this new origin and then
222:35 - we already know the distance to the
222:38 - origin when we have placed it that is
222:40 - going to be this distance here
222:43 - once we have this distance we can simply
222:47 - move this thing around and then we have
222:51 - this new Vector that is going to be
222:53 - identical to the original
222:56 - I hope all of that makes sense the logic
222:58 - here well you definitely want to play
223:00 - around with this a bit but all I really
223:02 - want to do is I want to get
223:04 - self.direct.top left
223:06 - and I want to place this wherever the
223:09 - origin is and to that I want to add self
223:12 - dot distance to origin
223:14 - which means now if I do all of this
223:17 - again
223:18 - we are starting with the blue part this
223:21 - is the blue part I have drawn in here
223:23 - we are setting the top left of our
223:25 - Sprite to the position of the origin
223:27 - this however isn't enough because we
223:30 - need to get this distance to origin here
223:33 - to account for a distance and that way
223:35 - we go from this point to this point here
223:39 - all we have to do now when we are
223:41 - panning the entire editor this one here
223:48 - I want to in the panning update
223:52 - besides updating the origin I also want
223:55 - to update every single Sprite
223:58 - this is going to be for sprite in self
224:01 - dot canvas objects
224:04 - all I have to do in here is Sprite dot
224:07 - pen
224:08 - position and pass in self dot origin
224:14 - now if I run all of this
224:16 - and Pan the entire thing
224:18 - we are always accounting for the origin
224:22 - and that way everything works as
224:24 - intended
224:25 - very happy with this this is looking
224:27 - good
224:30 - now we can minimize the pan input and we
224:32 - never have to worry about this one again
224:35 - which means we can Flash out the canvas
224:38 - object quite a bit more
224:40 - the first thing I want to work on is the
224:44 - animation
224:47 - because I don't want to have a plain red
224:49 - rectangle for all of the images I want
224:52 - to have an animation
224:55 - for that animation
224:56 - we need frames first of all
224:59 - and those are the frames we are already
225:00 - getting we don't do anything with them
225:02 - right now I am for now just going to
225:05 - store them inside of an attribute
225:07 - besides that we are going to need
225:09 - self.frame index
225:12 - this we have already done some
225:14 - animations is the number we are going to
225:15 - increase
225:17 - and now instead of drawing a plain red
225:21 - rectangle I want to get myself dot
225:24 - frames
225:26 - and on that I want to get myself dot
225:29 - frame index
225:31 - just as a reminder self.frames right now
225:34 - is just a list with surfaces and we are
225:38 - picking one of those
225:41 - with that we don't have to fill the
225:43 - entire surface anymore and this should
225:45 - already give us something that looks
225:47 - much better meaning if I run minute pipe
225:49 - we can see the pirate and the pirate can
225:52 - also be panned around this is definitely
225:55 - making some progress
225:57 - all we have to do now is to create an
226:00 - animate method this one itself and Delta
226:03 - time
226:04 - inside of this one if you want to
226:06 - challenge yourself you should be able to
226:08 - create an animate method quite easily at
226:11 - this point
226:12 - so positively now and see if you can
226:14 - figure this one out
226:18 - first of all I want to increase self dot
226:21 - frame index with plus equal and then I
226:25 - want to get the animation speed and
226:28 - multiply it by Delta time
226:30 - once I have that I want to update myself
226:32 - dot image and this is going to be self
226:36 - dot frames
226:38 - in here we want to get self dot frame
226:41 - index
226:42 - there are going to be a couple of major
226:44 - problems first of all this self.frame
226:47 - index is probably going to be a floating
226:49 - Point number because Delta time is a
226:52 - very small number and if you multiply it
226:54 - with animation speed which I believe is
226:57 - eight
227:00 - we are going to end up with a
227:02 - multiplication of 8 by 0.01 or something
227:05 - like that
227:06 - since we cannot do indexing with a
227:08 - floating Point number
227:10 - I want to convert this Frame index into
227:12 - an integer
227:14 - the next problem we have is that inside
227:16 - of self.frames we probably have
227:18 - something like five to six surfaces
227:21 - and we're always getting them by
227:23 - indexing however this self.frame index
227:26 - is going to be larger than the length of
227:29 - this cell.frames very quickly and this
227:31 - we have to account for
227:33 - what we have to do in here is self dot
227:35 - frame index is going to be zero if
227:39 - itself dot frame index is greater or
227:44 - equal than the length of self dot frames
227:49 - if that is not the case meaning else I
227:52 - just want to keep self frame index as
227:54 - the frame index
227:56 - and that is all we need all we have to
227:59 - do now is to actually call the animate
228:02 - method inside of an update method in
228:05 - here we need itself and Delta time just
228:07 - as before
228:09 - and call Self dot animate
228:13 - with Delta time
228:15 - we are nearly done with the animations
228:17 - we just have to call this update method
228:20 - inside of the run method inside of
228:23 - updating since all of the canvas objects
228:26 - are going to be inside of the canvas
228:29 - objects group I can call it update on
228:32 - this one
228:33 - and now if I run main.pi we are getting
228:37 - an error the canvas object update needs
228:40 - Delta time
228:42 - which we can just pass in here and now
228:45 - if I run this we have the animation for
228:47 - the player this is quite nice
228:51 - although there's one more thing that I
228:53 - would like to add in here and that is
228:56 - for each animation I also want to update
228:59 - the rectangle
229:01 - that way if the surface changes too much
229:03 - we're not moving this thing around and
229:06 - this is just going to be
229:08 - self.mage.getwrecked again and in here I
229:12 - want to place them at bottom with the
229:15 - position being where the mid bottom of
229:18 - the rectangle was in the last frame
229:20 - this way the rectangle or this entire
229:22 - Sprite is always going to stay in the
229:24 - same position which definitely makes a
229:26 - small difference
229:28 - but that is all we need for animate now
229:30 - we can minimize it and never worry about
229:31 - it again
229:33 - next up we have another problem if I run
229:36 - main.pi again I guess I can show my
229:38 - mouse
229:39 - if I click on the player nothing is
229:42 - going to happen there's no way to
229:44 - interact with it at all right now
229:46 - and this I want to change the first
229:49 - thing I want to do is that we can drag
229:52 - this object around in the editor
229:55 - for that we need two more attributes I'm
229:58 - going to put them inside of movement
230:00 - first one is self dot selected this by
230:03 - default is going to be false this is
230:05 - just going to be an attribute that tells
230:07 - us if we currently have this spread
230:08 - selected or not
230:10 - besides that I want to have self and
230:13 - this one I called Mouse
230:15 - offset by default it's going to be a
230:19 - vector with 0 and 0.
230:22 - and let me explain why we are going to
230:24 - need this
230:25 - we want to move a Sprite that could look
230:28 - something like this on the Sprite we are
230:31 - always going to be constrained to moving
230:33 - one point say we could move this point
230:35 - here or at this point here or at this
230:37 - point here and these are all of the
230:39 - predefined points inside of a rectangle
230:41 - so we have top left top right center and
230:44 - so on
230:45 - in my case I am always going to move the
230:48 - top left
230:50 - let me get rid of the other points and
230:53 - this is the point we are actually going
230:54 - to move for the Sprite this however is a
230:58 - problem because when the player is
231:00 - clicking on a Sprite
231:02 - we might get a click here or here or
231:06 - here or here
231:08 - and the player expects that we don't
231:10 - instantly jump the top left position to
231:12 - let's say this point here
231:15 - and to account for that we have this
231:18 - mouse offset
231:20 - this is always going to be the distance
231:22 - between the top left and the pointer
231:23 - player clicked on
231:25 - this point we have to get every time the
231:28 - player is clicking on this object let me
231:31 - put all of this inside of a separate
231:33 - method
231:34 - let's call it start drag
231:37 - this one itself and nothing else in here
231:41 - we first of all have to make sure that
231:43 - self dot selected
231:46 - is going to be true
231:49 - besides that I want to have self dot
231:51 - mouse offset
231:53 - as a reminder this point is going to be
231:56 - the distance between the top left and
231:58 - the position the player actually clicked
231:59 - on just to make sure that you can still
232:01 - follow along try to figure this one out
232:03 - yourself this should be a very simple
232:06 - Vector operation don't overthink this
232:11 - we first of all need to get the mouse
232:14 - position don't forget to call it this
232:17 - mouse position is going to be one of
232:19 - these blue axes
232:21 - from this I want to subtract self.rect
232:24 - dot top left
232:26 - which is going to be the top left
232:28 - position this one here
232:31 - the problem we have right now is that
232:33 - both of these are two builds which we
232:35 - couldn't really work with but that is an
232:37 - easy thing to fix all we have to do is
232:39 - to convert both of them to a vector with
232:43 - that we know when we are dragging and we
232:46 - also have an offset to the mouse
232:49 - which means now I can minimize the
232:50 - method
232:51 - and the next thing that I want to do
232:54 - let's actually put this inside another
232:57 - method to keep things a bit more
232:58 - organized
233:00 - and this one I called drag in here we
233:03 - need self and nothing else
233:05 - if self dot selected is true
233:09 - I want to place self.rect dot top left
233:13 - to the position of my mouse
233:17 - although remember this is what I just
233:19 - talked about right now we are just
233:22 - placing the mouse position which is
233:24 - going to be this top left here
233:26 - this point we have to adjust a tiny bit
233:29 - because we need this offset here
233:33 - to get to this point
233:37 - which we can get very easily because
233:39 - this is what we have done inside of
233:41 - start drag
233:42 - meaning I want to subtract self dot
233:45 - mouse offset
233:47 - with that I can drag things around all I
233:50 - have to do is call Self dot drag
233:53 - I suppose we could test this one if I
233:58 - set
233:59 - selected to true if I now Run the game
234:04 - and show my mouse you can see the player
234:06 - is always going to be following the
234:08 - mouse this one is working really well
234:11 - although the problem right now is I can
234:13 - never get rid of the player anymore
234:14 - which is a tiny bit annoying
234:16 - which means we have to add a bit more
234:19 - code that we can control if a Sprite is
234:22 - selected or not let me set it to false
234:24 - again
234:25 - for that I'm going to minimize the
234:27 - canvas object and the run method
234:31 - inside of the input I want to have
234:34 - another method
234:36 - which I called
234:38 - object rack
234:41 - in here we need itself and we need an
234:43 - event for this one I want to check if
234:46 - the event DOT type is equal to pygame
234:50 - dot mouse button down
234:54 - meaning right now I know if I am
234:56 - clicking anywhere on the editor besides
234:59 - that I also want to know if Mouse
235:01 - buttons
235:03 - and zero that means I am left clicking
235:06 - somewhere on the editor if that is the
235:08 - case I want to look at all of my Sprites
235:10 - which I'm doing with a for Loop for
235:12 - sprite in self dot canvas objects inside
235:17 - of this I want to check if I'm actually
235:19 - clicking on a Sprite so sprite.rect dot
235:22 - Collide point and I want to check we can
235:26 - go either with the event position or
235:29 - with mouse position
235:31 - both is fine it's going to give you the
235:33 - same result
235:34 - I guess since we're using events let me
235:36 - use the event position if this if
235:39 - condition returns a true I want to set
235:41 - Sprite and start drag this is the method
235:45 - we have created just a few minutes ago
235:48 - this start drag here which means if I
235:52 - inside of the event Loop add self dot
235:56 - object drag with an event we should be
236:01 - getting something
236:03 - and let me show my mouse I can now click
236:06 - on the player and move the player around
236:08 - although there are quite a few different
236:10 - problems the first one is even after I
236:13 - release my mouse the player keeps on
236:14 - following me however if I keep on
236:16 - clicking I am also drawing while
236:19 - dragging the player meaning this is
236:21 - something we do have to work on this is
236:23 - a very strange Behavior
236:26 - I'm going to start by not drawing a tile
236:28 - if I have an object selected for that
236:31 - inside of the init method
236:33 - I want to create self dot object
236:38 - drag and I'm going to call this active
236:42 - by default this one is going to be false
236:44 - but anytime we have any kind of drag for
236:49 - any object active this one is going to
236:51 - be true
236:52 - which means
236:55 - inside of this object drag if this if
236:58 - statement is true I also want to set
237:00 - self dot object drag active to true
237:05 - this I can now use inside of canvas ad
237:10 - this is where we are drawing all of the
237:13 - tiles right now and we are checking if
237:16 - we are pressing the left Mouse button
237:17 - and if we're not colliding with the menu
237:20 - I want to add another if statement in
237:22 - here and that is going to be and not
237:24 - self object drag active
237:28 - which means I only want to draw a
237:30 - Terrain tile for example if we are left
237:33 - clicking if we're not clicking on the
237:34 - menu and if we don't have an object
237:37 - currently selected
237:39 - there is one more change we do have to
237:41 - make and you might be able to spot it if
237:44 - I run main.pi and I click on the player
237:48 - if I click for the first time we are
237:50 - placing a Terrain tile but if I click
237:52 - again nothing is going to happen
237:55 - the reason for that is inside of the
237:58 - event Loop
237:59 - we are calling canvas add before the
238:03 - object drag as a consequence we are
238:06 - drawing something and then we make it
238:08 - impossible to draw
238:09 - as a consequence we are drawing one
238:12 - terrain tile this we can fix quite
238:14 - easily by just placing the object drag
238:16 - before canvas add
238:19 - now I can select my player let me show
238:21 - my mouse again move them around and
238:24 - everything works just fine I am not
238:26 - drawing anything on the editor the
238:28 - problem now is I can't get rid of my
238:30 - player
238:31 - that's going to be the next bit
238:33 - this is also going to happen inside of
238:35 - object drag inside of here I want to
238:39 - check another if statement
238:42 - I first of all need to create another if
238:44 - statement where we are checking if we
238:46 - are releasing the mouse button which
238:49 - means if event DOT type is equal to
238:53 - Mouse button up
238:57 - however this we only want to check and
239:00 - this should be pygame dot mouse button
239:02 - up this we only want to check if we
239:05 - currently have something selected which
239:07 - means and self object drag active
239:12 - if these two conditions are true I know
239:15 - we currently have something selected and
239:17 - we are releasing the mouse button which
239:19 - tells me I want to unselect whatever
239:21 - Sprite I currently have selected and for
239:24 - that I need for sprite in self dot
239:27 - canvas objects once more
239:30 - and if Sprite is selected
239:35 - then I want to
239:37 - let's put all of this in another method
239:39 - that I called and drag
239:42 - in here once again we need the origin
239:44 - you will see in a second why
239:46 - although besides that I also want to set
239:49 - self dot object drag active back to
239:53 - false
239:54 - that is all we need inside of this one I
239:57 - can minimize it and now inside of my
239:59 - canvas object
240:01 - I can Define drag end
240:06 - in here we need self and don't forget
240:08 - the parameter for the origin
240:11 - the most important thing now is self dot
240:13 - selected is going to be false
240:18 - and now
240:20 - I think this drag and I called something
240:24 - else inside of the object drag
240:28 - ah I called it
240:29 - and drag this should be drag
240:32 - end
240:34 - we have drag end and we have drag end
240:37 - this one's looking good
240:39 - now inside of main.pi I can run this let
240:42 - me show my mouse again I can now click
240:44 - on My Player move the player around and
240:46 - release the player and now we are
240:49 - getting an error
240:51 - that error is happening inside of here
240:53 - because this needs to be self dot origin
240:57 - now let me try this again
241:00 - I can click on the player I can release
241:01 - the player and this one seems fine
241:04 - although now you can see it if I pan
241:06 - around let me do it again let me move
241:08 - the player somewhere here and if I now
241:10 - pan
241:11 - the player is teleporting around the
241:14 - reason for that is
241:17 - inside of the player or the canvas
241:21 - object
241:22 - after drag end we have a problem because
241:27 - this distance to the origin which we
241:29 - needed for the panning has changed so
241:31 - once we start to pan the player is going
241:34 - to be teleported around depending on
241:36 - where this position is
241:38 - to account for that I can just duplicate
241:40 - this line and paste it in here and now
241:42 - we get a new distance to origin and that
241:46 - way we can pan around properly again
241:48 - meaning if I try this now
241:50 - I can move the player around I can also
241:53 - pan and everything is working perfectly
241:56 - fine
241:58 - I am very happy with this this is
242:00 - looking really good
242:03 - there's actually only one more thing
242:05 - that we absolutely have to do inside of
242:07 - this canvas object and that is we have
242:10 - to store the tile ID this one is
242:12 - honestly super simple all we need is
242:14 - self.tile ID is going to be the tile ID
242:19 - this part is going to become really
242:21 - important later on but for now we don't
242:23 - really need it
242:25 - but I can't minimize the canvas objects
242:29 - and now we need one more thing before we
242:33 - can place objects from the menu and that
242:35 - is
242:37 - inside of the init method
242:43 - we have two objects we have to create
242:45 - when the editor is starting we have the
242:48 - player and besides that we also need the
242:51 - sky
242:53 - this is going to be a simple object that
242:55 - is not animated and it's basically the
242:57 - thing that determines the height of the
242:59 - sky
243:00 - this is also something we have to store
243:02 - inside of another attribute
243:05 - let me call it Sky handle
243:08 - this one is going to be a canvas object
243:12 - and we need a couple of different things
243:15 - in here
243:16 - the most important one is for the frames
243:19 - we are only going to have a single
243:22 - surface and this one we have to import
243:25 - which is going to happen inside of
243:27 - imports besides water Bottom I want let
243:31 - me call this the sky handle surface
243:35 - I just have to load it and then here we
243:38 - need a string with one fold up then
243:41 - Graphics inside of there we have the
243:44 - cursors and inside of there we have
243:47 - handle dot PNG
243:50 - inside of the folder I want to look at
243:53 - Graphics inside of there we have cursors
243:56 - and there we have the handle this is
243:59 - what we are going to import
244:01 - on top of that I forgot for both of
244:04 - those they need to be convert Alpha that
244:08 - way the game is going to run a tiny bit
244:10 - faster
244:11 - and as I'm saying this I realized if I
244:14 - open
244:16 - support again when we are loading this
244:19 - image surface here and this image
244:21 - surface here we're not converting them
244:23 - which is going to be really bad for
244:25 - performance which means I want to
244:27 - convert Alpha both
244:30 - that is going to help massively for the
244:32 - performance of the game
244:33 - with that covered we can create a sky
244:37 - handle and that I want to be an exercise
244:39 - the position should be in the middle of
244:44 - the window
244:46 - the graphic we already have and the
244:48 - index you can also figure out so all you
244:50 - really need is
244:52 - the position
244:53 - which means you have to create a canvas
244:56 - object that is right in the middle with
244:58 - this graphic here and the index you can
245:01 - get from the editor data you're looking
245:03 - for the sky
245:04 - and pause the video now and see if you
245:07 - can figure this one out
245:11 - we have to start with the position and
245:13 - this is going to be a tuple with X and Y
245:16 - since I want to Sky handle to be right
245:19 - in the middle of the window this is
245:21 - going to be window width divided by 2
245:24 - and window height divided by two
245:27 - next up we have to work on the frames
245:31 - and in here you do have to be a tiny bit
245:34 - careful obviously we need self.sky
245:39 - handle surface
245:43 - the one we have imported down here
245:45 - however
245:47 - inside of the canvas object class we are
245:50 - cycling for a list for the animation so
245:53 - for the frames we don't need one surface
245:56 - we need a list with surfaces as a
245:58 - consequence this one needs to be a list
246:01 - with this one surface
246:03 - you could make this a tiny bit more
246:06 - fancy to only animate this canvas object
246:09 - if there's more or if there's a list
246:12 - of surfaces but in my case this isn't
246:14 - going to be too much of an issue
246:16 - next up we need the tile ID this one we
246:21 - are getting from the editor data and sky
246:23 - is one
246:25 - which means tile ID is one as well the
246:29 - origin is going to be self dot origin
246:32 - and finally group is going to be quite
246:37 - simple because we only have one group
246:38 - self dot canvas objects
246:42 - with that I can get rid of this position
246:45 - here and finally let me show my mouse
246:49 - I can click on the sky handle and move
246:52 - this one around I can release it and it
246:54 - doesn't move anymore and now I can move
246:56 - the player
246:58 - and I can also pan around all of this is
247:00 - working really well
247:02 - obviously I can combine this with
247:04 - terrain tiles as well and all of this is
247:07 - working super well
247:09 - there is some definite progress being
247:12 - made
247:15 - I can now minimize
247:18 - the init method
247:20 - and the last thing we are going to need
247:22 - for this section it is getting quite
247:24 - long but I want to have all of the main
247:27 - part of the object inside of one section
247:30 - when I am adding something to the canvas
247:32 - this canvas here I am always adding a
247:36 - tile but this isn't necessarily the case
247:39 - because sometimes I'm going to place an
247:41 - object
247:42 - which means inside of here I have to
247:45 - check if I am placing a tile or if I'm
247:48 - placing an object
247:50 - this I can do with another if statement
247:52 - I want to check if my editor data in
247:56 - here I want to look at myself Dot
247:59 - selectionindex
248:01 - and on this I have a type if I look at
248:04 - settings we have type this is either
248:06 - object or it can be tile
248:10 - for the tiles we have placed so far
248:11 - there's coin there's enemy
248:15 - and there's the terrain and water these
248:18 - are all tiles
248:19 - however for the poems we have object and
248:23 - this we can check
248:24 - specifically we're checking this in here
248:28 - meaning we want to do all of this only
248:32 - if this one is a tile
248:36 - I want to have all of this indented and
248:39 - if that is not the case so else
248:43 - then I want to place an object
248:46 - which means all I have to do is create
248:49 - another canvas object
248:51 - this one is going to need the mouse
248:53 - position
248:55 - I guess let me use named arguments I
248:58 - want to have the position where my mouse
249:00 - is
249:01 - next up I'm going to need some frames
249:05 - this I get with self dot animations in
249:09 - here we have
249:10 - self.selection index
249:13 - and this once again is what we're
249:14 - getting from import
249:16 - on this I want to get the frames
249:19 - next up we need a tile ID
249:23 - that in this case is just going to be
249:25 - self dot selection index
249:28 - and the same is going to be with the
249:32 - origin in here we need self dot origin
249:35 - finally the last thing we need is the
249:37 - group once again we only have one group
249:40 - we need self dot canvas objects
249:44 - and with that every time I am clicking
249:47 - on the editor with an object selected we
249:50 - should be placing an object although
249:52 - before testing this I realized there's
249:54 - one error this should be a comparison
249:56 - operator not an assignment operator
249:59 - and now if I run out of this and let me
250:03 - show my mouse once again I can now click
250:05 - on the palm tree and place it somewhere
250:07 - here and we have a new object I can also
250:10 - move this around and this one I can do
250:13 - multiple times this one is working
250:15 - really well
250:16 - we do have a problem though and that is
250:19 - if I hope I Mouse down and drag it
250:22 - around
250:23 - I can place a whole bunch of palm trees
250:32 - a substantial amount actually
250:36 - and well you can probably tell this
250:39 - isn't exactly ideal for performance so
250:42 - we do have to account here for quite a
250:44 - few different things but at the very
250:46 - least for now we can place different
250:48 - things I guess while we are here I can
250:50 - try to place another tile or palm tree
250:55 - there and I can also place the
250:57 - background ones
250:59 - it's kind of hard to see because there's
251:01 - no preview but all of this we are going
251:03 - to work on more at the very least now
251:05 - you can see something is working and we
251:07 - can definitely Place different things
251:09 - all of this is coming together just fine
251:13 - now that we have the basics of objects
251:16 - we can refine some things for this part
251:18 - I want to keep things a bit more simple
251:20 - I want to do two things number one there
251:23 - should be a timer when we are placing
251:25 - objects that way I couldn't drag around
251:28 - and create tens of thousands of palm
251:30 - trees
251:31 - besides that the player should also be
251:33 - able to delete objects
251:35 - both of these things are fairly easy to
251:38 - implement so let's Jump Right In Here we
251:40 - are back in our code and I want to keep
251:42 - on working inside of the editor
251:45 - to start with the timer inside of the
251:48 - init method when I'm creating all of the
251:51 - objects
251:52 - I want to create one more attribute and
251:55 - this I called self.object timer
251:59 - this is going to be a timer a class I'm
252:02 - going to create in just a second and
252:04 - when I'm creating this class I want to
252:06 - specify how long the timer is
252:09 - which in this case is going to be 400
252:11 - milliseconds and this time of class I'm
252:14 - going to create in a separate python
252:15 - file
252:17 - and save it as timer dot pi
252:21 - inside of this one I as always have to
252:25 - import pygame but I don't need anything
252:27 - else I want to create a timer class
252:31 - inside of this I want to have an init
252:34 - method
252:35 - we need itself and we need a duration
252:39 - iteration
252:42 - should be an attribute
252:44 - and besides that I also want to know if
252:46 - this timer is active or not meaning we
252:49 - need another attribute by default it is
252:51 - going to be false
252:53 - there's one more thing that we do need
252:55 - and that is the start time
252:58 - which by default is going to be zero but
253:01 - we are going to overwrite this anyway
253:04 - now inside of this
253:06 - I want to have an activate method and I
253:10 - want to have it the activate method
253:15 - when we are activating the timer I want
253:17 - to set self.active to true and self dot
253:22 - start time is going to be the current
253:25 - time in the game which is going to be Pi
253:26 - game dot time dot get underscore ticks
253:30 - deactivate is going to be basically the
253:33 - opposite we are setting self DOT active
253:36 - to false and self dot start time is
253:40 - going to be zero with that we have a
253:43 - couple of basic attributes that we can
253:44 - use to actually create a timer this one
253:47 - I am doing inside of an update method in
253:51 - here we need self and nothing else and
253:54 - now to explain how the timer is going to
253:56 - work
253:57 - let's say this one here is a timeline of
254:01 - the entire game with this point being 0
254:04 - or the start of the game
254:07 - when we're calling
254:09 - pygametime.getix we're getting some
254:11 - number in here it really doesn't matter
254:14 - what it is
254:16 - to create a timer I now need three bits
254:19 - of information the first bit is the
254:21 - start time this one we create up here
254:24 - and we are setting when we are calling
254:27 - the activate method let's say for
254:29 - Simplicity the start time could be
254:31 - somewhere here
254:32 - at 500 milliseconds so we are running
254:36 - this method half a second after the
254:38 - start of the game
254:39 - that is the first bit of information the
254:42 - second bit of information is the
254:43 - duration
254:45 - that is what we are getting up here this
254:49 - one is telling us how long this timer is
254:51 - going to last
254:52 - let me draw a random error and the timer
254:55 - I want to create is supposed to run for
254:57 - 400 milliseconds or a bit less than half
254:59 - a second
255:01 - with that I know how long the timer is
255:03 - going to last all I have to do now is to
255:06 - constantly check my timer and this I
255:08 - want to do inside of the update method
255:10 - down here what this method is going to
255:14 - do it is going to check the time
255:16 - constantly
255:18 - all the time
255:19 - and we are at some point going to end up
255:22 - with this point here
255:25 - which is greater than the start point
255:29 - plus the duration as a consequence we
255:32 - know this timer has run out
255:34 - that is the entire logic I want in here
255:37 - so let me clean this one up a tiny bit I
255:40 - guess I can keep the main drawing up
255:42 - there that's quite helpful
255:44 - inside of the update method
255:46 - actually this could be a really good
255:47 - exercise from the drawing try to create
255:50 - your own timer logic and see if you can
255:52 - figure this one out
255:57 - first of all I have to get the current
256:00 - time
256:01 - this I get once again with pygame DOT
256:04 - time dot get underscore ticks
256:08 - this is what I've talked about earlier
256:11 - this one checks the time constantly if
256:13 - you are here here here here here here
256:16 - or here and if you are wondering the
256:20 - difference between these two get ticks
256:22 - is the method itself does the same thing
256:25 - the difference is that disk ethics is
256:28 - being called constantly while this get
256:32 - ticks is only called once whenever we
256:34 - are starting this timer as a consequence
256:36 - those two do slightly different things
256:39 - once we have that I want to check if my
256:43 - current time minus my self dot start
256:46 - time is greater or equal than self dot
256:51 - duration and if that is the case I want
256:54 - to run
256:55 - self.d activate
256:57 - and the logic here I hope is quite
256:59 - straightforward we are checking the
257:02 - current time this one could be here for
257:05 - example right now and we are checking if
257:07 - this number minus self dot start time
257:09 - that is this number here is greater than
257:13 - self dot duration which is this distance
257:17 - here
257:18 - and if that's the case we can deactivate
257:21 - the timer
257:22 - now we have a timer class that we can
257:24 - use inside of the editor although we
257:26 - first of all have to import it which
257:28 - means from timer import timer
257:33 - let me run my notepad to make sure
257:34 - everything is working we're not crashing
257:36 - that's generally a good sign
257:39 - with that covered when I am running
257:42 - canvas ad
257:44 - and I am placing an object I only want
257:46 - to place the object if the timer is not
257:49 - active which means if not self dot
257:53 - object
257:54 - timer
257:56 - DOT active
257:58 - only if this timer is not active I want
258:00 - to be able to place an object
258:03 - and once we have place an object I want
258:05 - to activate this timer which means self
258:08 - dot object timer dot activate
258:12 - the one thing we need now is to actually
258:15 - update this timer because inside of
258:17 - update we have this update method and
258:20 - this one isn't being called right now
258:22 - this I am going to do inside of the run
258:25 - method in here we have an updating part
258:27 - and inside of that I want to call
258:31 - self.objecttimer Dot update
258:34 - and this should be all we need if I now
258:37 - run main.pi again
258:39 - and select a palm tree I can now only
258:42 - place them every so often I cannot drag
258:45 - them like crazy anymore
258:48 - I can still place a huge amount of them
258:51 - and if I draw too many performance is
258:53 - going to suffer
258:55 - although it is going to be much less bad
258:57 - than it used to be so I'm kind of okay
259:00 - with that
259:01 - what we have to work on now is to give
259:03 - the player the ability to delete objects
259:05 - and for that we already have a method
259:09 - called canvas remove
259:12 - although in here we are only checking if
259:15 - we want to remove a tile or not
259:18 - meaning we have to make this thing a
259:20 - tiny bit more flexible
259:22 - let me put all of this stuff here under
259:26 - tiles or rather delete
259:29 - tiles besides that I also want to have
259:32 - delete
259:34 - object
259:35 - to delete an object we first have to
259:38 - know if there is an object selected so
259:41 - we know that we have an object that we
259:42 - currently are targeting this object I
259:45 - want to store in a separate variable
259:47 - let's call it selected
259:49 - object
259:50 - this one we can't get particularly
259:53 - easily right now as a consequence I'm
259:55 - going to create another method this I
259:58 - called Mouse on object
260:02 - this I'm going to create inside of the
260:05 - support part
260:09 - Mouse on object
260:12 - we need self and nothing else and all we
260:15 - are really going to do in here
260:18 - is we're going to check all of the
260:20 - Sprites or Sprite in self dot canvas
260:23 - objects and I want to know if my mouse
260:26 - is currently on any of these Sprites
260:29 - which I get with Sprite dot rect dot
260:33 - Collide point
260:34 - and my mouse position
260:36 - if that is the case I want to return
260:41 - the Sprite
260:43 - that is all I need in here
260:45 - and now if this is the case if we have a
260:50 - selected object
260:53 - then we can do something
260:55 - and the thing we want to do is get this
260:58 - selected object and destroy it with the
261:00 - kill method
261:02 - I can run main.pi and if I now left
261:04 - click on the player the player
261:06 - disappears same with the sky handle and
261:08 - I think you can already tell where the
261:10 - problem here is
261:12 - the player should not be able to delete
261:14 - the player or rather the pirate
261:17 - for that I want to add another if
261:19 - statement and that if statement
261:22 - is going to be could be a good exercise
261:25 - actually make sure that the player is
261:28 - only able to delete the palm trees all
261:31 - of these here the player should not be
261:33 - able to lead ever the player or the sky
261:36 - and when I say player here I mean the
261:38 - pirate I hope that makes sense try to
261:41 - figure this one out it should be doable
261:42 - inside of this one line of code that the
261:45 - player cannot get rid of the pirate or
261:47 - of the sky pause the video now and see
261:50 - if we can figure this one out
261:54 - I want to check if inside of the editor
261:57 - data
261:58 - I have a selected object dot tile ID
262:05 - remember tile ID is inside of settings
262:08 - and I can close the timer we don't need
262:10 - it anymore inside of settings we have
262:12 - all of these keys and this is telling us
262:14 - what kind of object we have
262:16 - inside of each of the associated
262:19 - dictionaries we get a certain kind of
262:22 - style this is what we want to check for
262:25 - meaning I want to check the style
262:28 - and only if this is not in
262:32 - the player
262:35 - or in the sky
262:39 - only if that is the case I want to
262:41 - delete the object
262:44 - which means now if I run main.pi
262:47 - and I left click on the player nothing
262:50 - is happening anymore although I can
262:51 - still drag the pirate around however now
262:54 - if I place a palm tree and right click
262:57 - on it it disappears this I can do
263:00 - multiple times let me place a couple of
263:03 - palm trees they all disappear if I right
263:05 - click on them
263:06 - and with that we have made a ton of
263:10 - progress this is all we need inside of
263:12 - this method
263:13 - for the next part we are going to create
263:16 - a preview and this basically means right
263:19 - now it is really hard to tell what is
263:22 - currently being placed
263:24 - as a consequence there should be a
263:26 - preview so the player knows what kind of
263:28 - tile or object is going to be placed
263:31 - however there's one caveat and that is
263:35 - if the player hovers over an object
263:37 - there should be an indicator that this
263:39 - object can be dragged
263:41 - in my case what I went with if we have
263:44 - an object here I want to draw some
263:47 - indicators around it these pinkish
263:50 - things are going to be the indicator
263:52 - this is what we are going to do all of
263:54 - this is going to happen inside of one
263:56 - method inside of the editor so we can
263:58 - all cover it in one part
264:00 - so let's get right to it once again we
264:04 - have main.pi but I only care about the
264:06 - editor inside of here I want to first of
264:10 - all add a bit of white space and then
264:13 - inside of drawing I want to create a
264:16 - preview method that doesn't need any
264:19 - custom parameters
264:21 - and this preview method is going to do
264:23 - two major things it is going to give us
264:25 - a preview of the tile or
264:29 - object that we want to place
264:32 - and it draws lines around objects when
264:37 - hovered over
264:40 - that way we know what we are going to
264:43 - place
264:44 - or if we have something selected
264:46 - although first of all we have to figure
264:49 - out which of these two we currently are
264:52 - doing so is the play hovering over an
264:54 - object or is the player placing a new
264:57 - element so we need an if statement to
264:59 - separate these two cases
265:01 - and for that we already have a really
265:04 - useful method
265:06 - that is the one I created earlier Mouse
265:08 - on object this one telling us if the
265:11 - player is hovering over an object or not
265:13 - this I want to use to get the current
265:17 - let's call it selected object and this
265:20 - we get with self.mouse on object
265:24 - remember this mouse an object is going
265:27 - to return the object we are currently
265:29 - hovering over meaning we are getting a
265:31 - Sprite
265:32 - once we have that we can check if
265:35 - selected object exists
265:39 - and if that is the case I want to draw
265:41 - lines around this object
265:43 - and if that is not the case so else I
265:45 - want to show a preview
265:47 - although there's one more thing we do
265:49 - have to do and that is all of this
265:51 - should only happen if the mouse is not
265:54 - over the menu
265:55 - meaning I want to indent all of this and
265:58 - add another if statement that if not
266:01 - self dot menu.rect dot Collide point
266:05 - with the mouse position
266:08 - that part should be fairly
266:09 - self-explanatory we don't want to show
266:11 - any preview if the player hovers over
266:13 - the menu that'd be kind of weird
266:15 - and with that we can start working on
266:18 - let's start with the first if statement
266:20 - and let me add a pass in the other so
266:23 - we're not getting an error
266:25 - if we have a selected object I want to
266:28 - draw lines around it
266:30 - first of all for that I need a few bits
266:33 - of information the most important one is
266:35 - I need some kind of rectangle and this
266:38 - rectangle I'm getting from the selected
266:40 - object
266:42 - since this one is a Sprite I can Target
266:44 - the rectangle and let's just leave it at
266:47 - that although I do want to copy it
266:49 - once we have that just to make sure we
266:52 - can see something I can for example do
266:54 - pygame dot draw dot rect in here we need
266:58 - a surface we need a color and we need a
267:01 - rectangle
267:02 - the rectangle is the easiest part this
267:04 - we already have the color we are going
267:07 - to change anyway so for now let's use
267:09 - red so it's something we can see quite
267:11 - easily finally we need a surface and
267:14 - this in my case is going to be the
267:16 - display surface
267:17 - and with that we should already be able
267:20 - to see if we are hovering over an object
267:22 - the last thing we have to do is to call
267:25 - this method that happens inside of the
267:28 - run method in here inside of the drawing
267:31 - section I want to draw the preview
267:34 - this I have done before we are drawing
267:37 - the menu I want the menu always to be on
267:39 - top so and here self.preview let's call
267:42 - it and this should be all we need if I
267:46 - now run the entire thing and show my
267:47 - mouse I can hover over the pirate we get
267:50 - a rectangle and also if I hover over the
267:52 - sky handle this also works on top of
267:55 - that even if I move around the pirate
267:58 - the red rectangle stays around which is
268:01 - a really good start
268:02 - even if I add a new palm tree you can
268:05 - see if I have over it it shows that it's
268:08 - being selected
268:09 - so this is working really well
268:13 - although just showing let me minimize
268:16 - this just showing a red rectangle really
268:18 - isn't ideal so we have to refine this
268:21 - and I want to get rid of this drawing
268:23 - method here
268:24 - instead let me explain what I want to do
268:27 - the rectangle we have right now looks
268:30 - something like this and what I want to
268:33 - do is to draw the lines around it
268:36 - something like this
268:38 - every single line in here is going to be
268:41 - drawn with pygame.draw.lines this one
268:43 - allows us to draw a line although we
268:46 - first of all need to figure out how to
268:48 - expand this rectangle so these
268:50 - indicators are a bit further outside
268:53 - this we fortunately can do quite easily
268:55 - instead of copying the rectangle I want
268:58 - to inflate the rectangle
269:01 - I'm going to inflate it by 10 and 10
269:04 - pixels which means we're inflating it in
269:07 - this and this direction by 10 pixels or
269:11 - rather 5 pixels on the bottom and 5
269:14 - pixels on top
269:15 - the same thing is going to happen for
269:17 - right and left
269:19 - they are both going to expand by 5
269:21 - pixels that way we're getting a bit of a
269:24 - distance between the actual Sprite and
269:26 - the indicators
269:27 - all of this is going to happen inside of
269:29 - this rectangle
269:31 - once we have that I want to figure out
269:33 - how to actually get these lines here
269:36 - and for that I want to declare a couple
269:39 - more variables
269:41 - the first one is a color that's why I
269:44 - don't have to write the same color over
269:46 - and over again but this one I want to go
269:48 - with black
269:50 - next up I need a width the width is the
269:53 - line width I set this one to three and
269:56 - finally I want to have a size this I
270:00 - have set to 15.
270:02 - what this size means if I show this one
270:04 - again
270:06 - this size here for example could refer
270:08 - to this distance here or to this
270:11 - distance here
270:14 - once we have all of that we can actually
270:16 - start with the drawing and what we need
270:19 - in here is pygame dot draw dot lines
270:24 - inside of that we need a couple of
270:26 - different arguments we need a surface to
270:28 - draw on we need a color
270:31 - we need to tell Pi game if the line is
270:34 - closed or not
270:36 - then we need the actual points we want
270:38 - to use and finally we need the line
270:41 - width
270:43 - most of these are really easy for
270:45 - example the color we already have with
270:48 - the color here the line width is also
270:50 - very easy that is the width here
270:53 - let me change the line with just a width
270:56 - and we are good to go the surface is
270:59 - also quite easy I want self.d display
271:01 - surface
271:03 - closed means if we have a couple of
271:06 - points let's say I have a point here a
271:09 - point here and a point here and Pi game
271:11 - is going to connect them like so
271:14 - if closed is activated it is going to
271:17 - draw another line from the last to the
271:19 - first point
271:20 - which in my case I do not want
271:23 - which means I'm going to add a false in
271:25 - here
271:27 - the only really complicated bit inside
271:29 - of here is points
271:31 - because for this one we need a list
271:35 - and this list has to contain three
271:37 - points
271:39 - each of them is going to be X and Y so
271:42 - let me add X and Y in here and then I
271:46 - can talk about this in detail
271:48 - what I want to happen in here if this is
271:53 - the original Sprite that we have
271:55 - selected that we are getting from up
271:57 - here the selected object
271:58 - around that we have created a larger
272:01 - rectangle this rectangle here this one
272:03 - looks something like this
272:09 - the larger size we are getting from
272:11 - inflate
272:12 - what I want to do now is to draw for
272:15 - example in the top left
272:16 - to do that I need to figure out three
272:19 - points I need this point here I need
272:23 - this point here and finally I need this
272:26 - point here these are the points I'm
272:28 - going to figure out down here down here
272:30 - and down here
272:33 - and I think this could be a really good
272:36 - exercise for you try to figure out these
272:38 - three points and see if you can draw
272:41 - this line
272:42 - so pause the view now and try this one
272:47 - all right let's do together now the
272:50 - easiest point we can get is the top left
272:52 - point because this one is literally just
272:55 - the top left
272:57 - and I can clean this one up a tiny bit
272:59 - we also don't need the inner rectangle
273:01 - anymore
273:03 - this second Point here that is the red
273:05 - one we just need the top left of the
273:07 - rectangle which we get with rect DOT top
273:10 - left
273:11 - with that we already have the first
273:13 - point covered next up I'm going to work
273:16 - on this point here
273:17 - for this point we know we are on the
273:20 - left side of the rectangle
273:22 - which means X is quite easy to get all
273:25 - we need is rect dot left
273:28 - why we can get quite easily as well
273:30 - because we know we are all the way at
273:34 - the top and we want to go down by a
273:36 - certain amount the amount being this
273:38 - size here in our case we want to go down
273:41 - 15 pixels
273:43 - as a consequence for why I want to get
273:46 - rect.top minus
273:49 - the size
273:52 - there's only one more point that we need
273:54 - and that is this point here or the
273:57 - yellow point
273:58 - this one is going to work in kind of a
274:00 - similar way we know for this one we are
274:03 - all the way on the top of this rectangle
274:05 - which makes y quite easy all we need is
274:08 - rect dot top
274:11 - for X we know that we are all the way on
274:15 - the left side and we want to go 15
274:17 - pixels to the right
274:19 - the same 15 we have gotten here
274:22 - as a consequence for X I want to get
274:25 - rect.left plus this size
274:29 - and with that
274:32 - I can clean all of this one up and now
274:35 - let's try to run this and see if it
274:37 - works
274:39 - if I now hover over my player I can see
274:42 - this is almost working
274:44 - I just messed up the blue point but this
274:48 - we can fix quite easily
274:50 - the problem here is this line this
274:54 - should be less instead of minus
274:57 - if I run this again now
274:59 - now this is working just fine cool
275:03 - the problem with this one was that the
275:05 - origin point is in the top left and if
275:07 - you want to go down we have to increase
275:09 - y instead of decreasing and this is what
275:11 - I got wrong here
275:13 - but well all we have to do now is to
275:16 - this three more times meaning I can
275:18 - duplicate it
275:21 - and well
275:23 - we already have the top left
275:25 - besides that I want to have the top
275:28 - right
275:30 - then I want to have the bottom right
275:34 - and finally I need the bottom left
275:38 - all of these points are going to be
275:41 - fairly simple geometry so let's go for
275:44 - them one by one this one here is the top
275:46 - right
275:48 - if I make all of this visible
275:50 - and we have a rectangle like so
275:54 - the one we already covered is this one
275:57 - here so we don't have to worry about it
276:00 - the one I'm going to work on next is
276:01 - going to be the top right this one here
276:04 - well that once again I want to have one
276:07 - rectangle a second rectangle and then a
276:10 - third rectangle
276:12 - once again the red one is the easiest
276:14 - one because
276:16 - this one here inside of the top left we
276:19 - want to have the top right
276:21 - for the blue rectangle we know we are on
276:24 - the top of the rectangle and we want to
276:27 - go 15 pixels to the left
276:29 - that I can do in here for X I want to
276:33 - have rect not left but right
276:36 - and from that I want to subtract the
276:39 - size
276:41 - for why I am happy just with the top
276:44 - that is giving us the blue and the red
276:47 - rectangle finally we have to work on the
276:49 - yellow one
276:50 - for this one for X we just want to stay
276:53 - on the not the left side but the right
276:56 - side and from the top we want to go down
276:59 - so plus 15 pixels
277:03 - and with that we should have the top
277:05 - right
277:07 - let's try
277:09 - if I now hover over the player this is
277:12 - looking really good
277:14 - cool
277:17 - next up and I guess I can do this one
277:19 - without drawing we have the bottom left
277:22 - bottom right actually is this one and we
277:25 - have the bottom left
277:26 - or the bottom right I want to have as
277:29 - the Middle Point the bottom right
277:33 - and the first point we want in here is
277:36 - rect dot right and from that I want to
277:39 - subtract the size
277:42 - with the Y part
277:46 - we can just use the bottom one or the
277:48 - final point for X we want rect dot right
277:54 - this one doesn't need the size and then
277:57 - I want to have rect dot bottom
278:00 - and from that I want to subtract the
278:03 - size
278:04 - with that we should have the bottom
278:06 - right let's try this one
278:08 - and this is also looking pretty good
278:13 - and if you are struggling just draw
278:15 - these points yourself it's not that hard
278:17 - to follow along if you play around with
278:19 - this a tiny bit
278:21 - finally we need the bottom left meaning
278:25 - the Middle Point again is very easy
278:28 - then for the starting point I want to
278:30 - have rect.left this one I can leave as
278:32 - it is but now I want rect dot bottom
278:36 - minus the size
278:39 - besides that we need a point that goes
278:41 - horizontally that is going to be this
278:42 - one here
278:44 - meaning I can leave this one as it is
278:47 - but this one should be rect dot bottom
278:51 - and this is all we need
278:54 - at least as long as I didn't make a
278:56 - mistake so let's try and this is looking
278:59 - really good this works with any kind of
279:01 - object even for place of objects like a
279:04 - palm tree
279:06 - they can all be selected and we can move
279:08 - them around so I'm really happy with
279:10 - this
279:11 - let's try another palm tree like so
279:14 - or this one or this one and they all
279:17 - look really good
279:20 - so with that we have
279:23 - the overlay if we have something
279:25 - selected covered
279:27 - so next up we can work on the else
279:29 - statement that we want to actually
279:31 - preview something if we are placing a
279:35 - new element
279:37 - for this one we first of all have to
279:39 - know are we placing a tile or are we
279:43 - placing an object because those two need
279:46 - different logic
279:47 - to separate the two I want to create a
279:50 - type dictionary
279:51 - this one we are going to create with
279:54 - dictionary comprehension meaning in here
279:56 - I want a key and a value or key and
280:00 - value in editor data dot items
280:07 - with this line here once again we are
280:10 - copying this entire dictionary which we
280:13 - don't need all I want in here is the
280:16 - type do I have an object or do I have a
280:19 - tile that's all I care about so instead
280:22 - of getting the entire value all I want
280:24 - is the type of the value we are
280:27 - currently looking at
280:28 - once I have that I want to get a Surface
280:33 - now for that I need a bunch of surfaces
280:37 - which I don't have right now
280:40 - however if you look at settings inside
280:43 - of this dictionary we have a menu
280:46 - surface and we have a preview these I
280:49 - want to import
280:52 - this is going to happen inside of the
280:56 - Imports method and here all the way at
280:59 - the bottom
281:00 - I can add another comment for preview
281:05 - and now we have to import all of these
281:07 - surfaces
281:08 - and I want to store them as preview
281:11 - surfaces
281:12 - and what I want to get out of here is
281:15 - another dictionary that has key value
281:17 - pairs the key is always going to be the
281:20 - ID for the object for example if we have
281:23 - a number two in here if I look at this
281:26 - dictionary again
281:28 - I want to have this 2 and Associated as
281:31 - a value here should be this previous
281:35 - surface which is going to be for the
281:37 - land tiles
281:38 - the same for water although this one
281:40 - should have a key of three
281:43 - which means for this dictionary for
281:45 - example I want to have 2 and a rain
281:48 - surface
281:49 - and all of that we can get with
281:52 - dictionary comprehension once again
281:54 - in here I want to have a key
281:57 - and on this key I have a value and let's
282:01 - do the same thing again for key and
282:03 - value in editor
282:06 - data dot items right now once again we
282:10 - are just going to copy this entire
282:12 - dictionary so wouldn't be helpful
282:15 - however what I can do now I know on this
282:18 - value which is another dictionary and
282:20 - this dictionary has one key called
282:22 - preview
282:23 - and the associated value for that
282:26 - is going to be a path to one surface and
282:29 - this I want to import
282:31 - which means here I can use the load
282:35 - method to actually import a surface
282:39 - and with this you would get the
282:40 - different surfaces however there's one
282:43 - issue if I look at settings again the
282:45 - player and the sky do not have a
282:48 - previous surface
282:50 - which means if we were to run this we
282:52 - would be getting an error but this we
282:54 - can fix quite easily I only want to run
282:57 - any of this if value
283:01 - and preview actually exists if it
283:05 - doesn't we just want to skip it
283:07 - and that is all we need here now we have
283:10 - our previous surfaces and I can use them
283:13 - inside of here
283:15 - so I want to get myself dot preview
283:17 - surfaces
283:19 - and since we once again have key value
283:22 - pairs I can get the surface here quite
283:25 - easily
283:26 - although for that I need indexing and I
283:29 - want to have myself dot selection index
283:32 - on this one I want to copy the surface
283:36 - that we have
283:37 - the reason for that is for the surface
283:39 - we have currently selected I want to
283:41 - change the alpha value to something like
283:43 - 200. that way it is going to be a little
283:46 - bit transparent which is quite important
283:49 - for a preview I don't want this to be
283:51 - too obvious
283:52 - once we have to surface we just have to
283:54 - find the position and for that we have
283:57 - to separate between tile and object
283:59 - and now all we have to do is if the type
284:03 - dictionary and self dot selection index
284:08 - is actually a tile
284:12 - that is working because this dictionary
284:14 - here has a key for the ID and the value
284:17 - is the type and the type is either
284:19 - object or tile
284:21 - which enables this if statement here
284:25 - if that is the case I need to find some
284:28 - kind of position and for the position I
284:31 - need to currently select itself meaning
284:33 - I want to have a current cell and this I
284:35 - get with self dot get current cell this
284:39 - is a method we created all the way in
284:41 - the beginning
284:42 - this get current cell here
284:46 - and now that we have a current cell I
284:49 - want to create a rectangle
284:51 - this rectangle is going to be the
284:53 - surface we have just imported and on
284:55 - that I want to get wrecked
284:57 - here I want to place the top left
284:59 - position
285:00 - and on this
285:02 - I always want to start from self.origin
285:06 - to that I want to get the current cell
285:09 - although I want to multiply this one by
285:12 - the tile size
285:13 - since the current cell is a tuple I have
285:16 - to convert this to a vector
285:19 - but that is actually all I need now all
285:22 - the way at the end of this method or
285:25 - rather of the if statement
285:27 - I want to self dot display
285:30 - surface.blit and since I now have a
285:33 - surface and a rectangle I can just pass
285:36 - the surface and the rectangle in here
285:38 - and I should be good to go at least on a
285:41 - very basic level
285:43 - and now if I run this and let me show my
285:46 - mouse I can see the preview of the lamp
285:49 - tiles this also works with water this
285:52 - also works with the coins
285:54 - and this is also going to work with the
285:56 - spikes and with the enemies
286:00 - so I am very happy with that the only
286:03 - problem we have right now is the palm
286:05 - trees are not going to work and we are
286:08 - getting an error the reason for that is
286:10 - we are not doing anything with the
286:12 - objects so we are getting an error
286:14 - fortunately that one is really easy to
286:17 - fix we need to first of all an else
286:19 - statement
286:20 - so besides the tile we are working on an
286:23 - object
286:24 - and for this one now we have to create a
286:27 - rectangle and this part is going to be
286:30 - your exercise try to get the rectangle
286:33 - for the object and see what you are
286:35 - going to need
286:36 - if you want a tip check out the canvas
286:39 - ad to see how the object is going to be
286:42 - placed that is going to be really
286:43 - important but pause the video now and
286:46 - see if you can figure this one out
286:51 - the answer here is going to be I want to
286:54 - get the surface I already have and on
286:56 - that I want to call Get Wrecked
287:00 - and now the point I want to place is the
287:02 - center
287:03 - and the center needs to be wherever my
287:07 - mouse position is
287:10 - if I run this now
287:11 - and let me show my mouse again I can
287:14 - select the palm tree
287:16 - and you can see it follows my mouse
287:18 - perfectly and if I place it this is
287:20 - looking pretty good
287:21 - now I can move it around and place
287:23 - another element all of this is working
287:26 - very well
287:28 - the question now is how do I know that I
287:32 - have to place the center and for that if
287:35 - I minimize preview and go to Canvas add
287:39 - inside of here when I'm placing the
287:41 - canvas object the position is always
287:44 - going to be the mouse position and now
287:47 - if I look at this canvas object
287:50 - the rectangle here is going to be the
287:52 - center position so anytime I'm clicking
287:55 - with an object selected I want to place
287:58 - the object or the center of the object
287:59 - where my mouse position is as a
288:02 - consequence
288:03 - inside of my preview when I'm running a
288:07 - preview of the surface this one here I
288:11 - have to show the object in the same
288:12 - position that is really important
288:15 - but well with that I can remove a bunch
288:19 - of comments here
288:21 - and now we are done at least with the
288:24 - preview
288:25 - for the final part of the editor at
288:28 - least purely for the editor we have to
288:30 - work on the sky
288:32 - now for this guy we need a couple of
288:34 - different methods to make all of this
288:36 - work and I think all of this is best
288:39 - explained by actually doing it so let's
288:42 - jump right into the code and let's have
288:44 - a look once more we have main.pi which I
288:47 - don't care about I want to look at my
288:49 - editor and first of all in here inside
288:53 - of the drawing section I want to create
288:56 - a new method that I call display
289:00 - this one is going to need self and Delta
289:03 - time for the cloud movement although
289:05 - we're not going to use that for a bit
289:08 - on top of that before I start working on
289:10 - this let me call it right away inside of
289:12 - the run method and now really important
289:15 - this display sky has to be called before
289:18 - we are drawing anything else so display
289:23 - sky in here with Delta time and this
289:26 - always has to be in the background so it
289:29 - needs to be before the level the level
289:30 - lines the preview and so on
289:33 - and I guess while we are here I can also
289:36 - comment out the origin point because
289:38 - this one we don't need anymore
289:40 - ready now I can start working on
289:44 - displaying the sky there are going to be
289:46 - two major parts to all of this
289:49 - let me draw the entire window something
289:52 - like this and first of all I want to
289:55 - create a horizon something like this
289:57 - then we have the actual sky up here and
290:00 - we have some water at the bottom meaning
290:03 - we have to draw three different things
290:06 - and those are always going to cover the
290:08 - entire background and even more
290:10 - important this middle line here has to
290:13 - be controlled by the sky handle we
290:16 - created earlier
290:17 - let me actually run the game by adding
290:19 - pairs in here and running main.pi this
290:23 - handle here is going to determine the
290:26 - vertical position of the sky
290:28 - which more specifically means from this
290:31 - point I want to draw a horizontal line
290:38 - and that means first of all I need to
290:41 - get a y position
290:45 - that I get with self and I call this one
290:47 - this guy handle in here we need rect and
290:51 - we need the center y with that we know
290:56 - where the Horizon is going to be
290:58 - although there's one thing we can do
291:00 - first of all and that is self dot
291:03 - display surface dot fill and in here
291:06 - inside of settings if I scroll down a
291:08 - tiny bit to the colors we have a sky
291:11 - color
291:12 - which I can copy and paste in here and I
291:15 - guess this one we could do right at the
291:17 - start if I run this now you can see some
291:20 - kind of Sky color by itself it looks
291:22 - kind of weird but it definitely works
291:25 - so with that we have a starting point
291:27 - although not a very good one but
291:29 - definitely something we can work with
291:32 - now with that inside of the editor we
291:35 - now have a y point so we can use that
291:39 - for now I want to use it to draw some
291:42 - Horizon Lines
291:44 - we actually have multiple you're going
291:46 - to see in a second what I mean
291:48 - bodies let me create a horizon
291:51 - rectangle and this rectangle is going to
291:54 - be pygame Dot rect and then here we need
291:57 - a left a top a width and a height left
292:01 - and width are really easy because I want
292:04 - this rectangle always to start on the
292:07 - left side of the window and cover the
292:09 - entire window so window width the top
292:12 - for this one is going to be
292:15 - let's just go with Y for now and let's
292:18 - give it a height of 10. and now with
292:21 - that I can pie game Dodge draw Dot rect
292:27 - and once again I need a surface so I
292:29 - display Surface body color
292:32 - inside of settings I have a horizon top
292:35 - color this I want to copy paste it in
292:38 - here and the last thing we need is the
292:40 - actual Horizon rectangle
292:43 - now if I run this let's see what we get
292:46 - you can see we have a rectangle that now
292:50 - works as a horizon line
292:52 - and this one only cares about the wine
292:54 - part so it always covers the entire
292:57 - width of the window which is really nice
292:59 - because now if I move
293:02 - the entire editor this one
293:05 - well the Horizon is always going to work
293:07 - so this is exactly what I wanted here
293:14 - although the one part that I don't
293:16 - really like is that I think this Horizon
293:18 - is a tiny bit too low but that is fairly
293:21 - subjective if I run this now and you
293:23 - look very closely The Horizon is a tiny
293:25 - bit higher but it really doesn't make
293:27 - much of a difference
293:30 - what I can do is this shouldn't be the
293:34 - Horizon rectangle this should be Horizon
293:36 - rectangle one because I want to have
293:39 - two and three and those are going to be
293:42 - other rectangles on top of this original
293:45 - one that way basically what I want to
293:48 - have this one here is going to be the
293:50 - entire display surface
293:52 - and the first rectangle we created is
293:54 - something like this
293:58 - on top of that I want to have a smaller
294:01 - line
294:02 - just imagine I can draw straight lines
294:04 - that would definitely help and on top of
294:06 - that I want to have an even smaller line
294:10 - okay this is very hard to see but once I
294:12 - actually implement it you can definitely
294:14 - tell what's going on now first of all
294:16 - when we're drawing this there should be
294:18 - Horizon rectangle one
294:20 - for a horizon rectangle two I want this
294:22 - to be a tiny bit higher and for the
294:25 - height I want this to be four
294:29 - if I draw this one and run the entire
294:32 - thing again you can now see we have a
294:35 - bigger line on top of a smaller line
294:38 - this I want to do one more time with
294:41 - Horizon rectangle three this one should
294:43 - be 20 pixels from the center and should
294:45 - have a height of 2.
294:47 - if I draw this one now and run main.pi
294:51 - again we now have a third line in here
294:53 - and all three of these lines work with
294:56 - the sky handle so this is working really
294:58 - good
295:00 - although there's one minor thing we can
295:02 - do here to optimize all of this
295:04 - and that is I want to draw all of this
295:08 - only if a certain if condition is true
295:10 - and that if condition being that Y is
295:14 - greater than zero
295:17 - if the sky handle is really far up
295:20 - there's no point drawing any of this let
295:23 - me visualize this actually
295:25 - right now this guy handle is right in
295:27 - the middle of the window and if I move
295:29 - further up and up at some point the sky
295:32 - handle is going to be well on top of the
295:35 - editor and if that is the case we are
295:38 - only supposed to see water as a
295:40 - consequence there's no reason in drawing
295:41 - anything of the horizon
295:45 - and with that here we're not drawing
295:47 - them if we only want to show water this
295:49 - isn't going to make much of a difference
295:51 - in practice but every tiny bit helps
295:55 - now besides that
295:56 - I want to draw the C
296:00 - for that I want to create a c rectangle
296:03 - and this once again is going to be
296:05 - pygame Dot rect
296:07 - and in here once again we need left top
296:10 - width and height
296:12 - the left once again is really easy we
296:15 - just need zero the top is going to be y
296:18 - that one is also easy the width is going
296:20 - to be the window width
296:24 - and for the height here we could be
296:26 - fancy but well we can also just add
296:29 - window I that makes things a bit easier
296:31 - and I guess I should draw all of this
296:34 - again
296:35 - we once again have a display surface and
296:37 - we have the horizon line somewhere here
296:40 - this C rectangle is now going to be this
296:44 - rectangle here
296:47 - although I was a bit lazy with the
296:49 - window height Because the actual
296:50 - rectangle I am going to create is
296:52 - probably somewhere in size like this
296:57 - which in practice doesn't make much of a
296:59 - difference so it's not too much of an
297:01 - issue this rectangle I now want to draw
297:04 - which I do with pygame DOT draw dot rect
297:07 - in here once again we need a surface to
297:10 - draw on the display surface or the color
297:12 - inside of settings we have C color
297:17 - this I want to use in here
297:19 - and then I want to draw the CU rectangle
297:22 - and if I run this again now this is
297:25 - starting to come together we now have
297:28 - a prophecy that is starting to look much
297:31 - better and it also works along with the
297:33 - sky handle
297:35 - also if I go down you can now see an
297:37 - issue that the C at some point stops and
297:41 - this I have to work on
297:43 - the idea here once again is going to be
297:46 - this should be an if statement if the
297:49 - Horizon is on the screen
297:53 - I want to do all of this
297:56 - however if that is not the case so else
297:59 - I want to fill the entire surface with
298:03 - water I'm pretty sure you can already
298:06 - see where this is going this is going to
298:08 - be your exercise
298:10 - so try to figure out the if statements
298:12 - here it is going to look somewhat
298:14 - similar compared to what we have done
298:15 - here with the Horizon Lines possibly now
298:18 - and try to think about this
298:23 - to figure out if the Horizon is on the
298:25 - window I want to check if Y is smaller
298:29 - than the window height only if that is
298:32 - the case I want to do all of this
298:34 - once again we have the display surface
298:37 - and here is y that is our Horizon and
298:43 - what I'm doing with this if condition
298:45 - here is I'm checking if this y currently
298:48 - is somewhere on top of this thing here
298:50 - imagine if this y was moved further down
298:54 - there wouldn't be any point in drawing
298:56 - water because the water wouldn't be
298:57 - visible for example if the player wants
299:00 - to have a level without any water this
299:02 - one should also be possible so let me
299:04 - clean this one up a tiny bit that is
299:07 - looking better now this is one part and
299:10 - there's no point running Pi game right
299:12 - now because you wouldn't be able to see
299:13 - the difference
299:15 - there's one more thing I do want to do
299:17 - and that is
299:18 - zero is smaller than y is smaller than
299:21 - window height this means I am only
299:23 - drawing water if this y here is inside
299:27 - of this range we already covered the
299:31 - case if the water is below we only want
299:33 - to show Sky if the water is on top I
299:36 - want to do something else I want to fill
299:38 - the entire window with water and that I
299:41 - want to do instead of drawing a
299:43 - rectangle and let me actually implement
299:45 - this right away with this we know that
299:48 - the Horizon is somewhere on the editor
299:50 - but now I can add another if statement
299:53 - that if
299:55 - Y is smaller than zero if that is the
299:59 - case I know I only want to have water to
300:02 - fill the entire surface
300:05 - which I get with self dot displaysurface
300:07 - dot fill and in here we have the C color
300:11 - which I have already used here so I can
300:13 - just copy it and paste it in there and
300:16 - now you should be able to see what's
300:18 - going on
300:19 - if I move this thing up and down nothing
300:22 - is going to happen but now if I move a
300:24 - bit further down you can only see water
300:27 - forever and that is because
300:30 - if this Sky handle here is somewhere up
300:34 - here or smaller than zero then we are
300:38 - filling the entire display surface with
300:40 - the watercolor which means if I do that
300:45 - we are filling the entire display
300:46 - service with the blue color so it looks
300:49 - like we only have water
300:51 - but if I move it the other way so I go
300:54 - up now we are only drawing the sky and
300:57 - if the Horizon is anywhere in between we
301:00 - are drawing all the other stuff
301:02 - I hope that makes sense if you play
301:04 - around with numbers I think this should
301:06 - be fairly straightforward
301:08 - let me get rid of the comment here and
301:12 - here and this is starting to come
301:14 - together there's one more thing that I
301:16 - do want to do and this is going to be
301:18 - all the way at the end I want to draw
301:20 - one more line for the Horizon and this I
301:22 - get with
301:23 - pygame.draw.line in here I want the
301:26 - display surface
301:28 - for this one we have another color The
301:30 - Horizon color
301:32 - this one I can paste in here and now for
301:35 - the points I need X and Y for the start
301:37 - and I need X and Y for the end
301:40 - X is either going to be 0 or the window
301:44 - width remember here we always want to
301:46 - cover the entire width of the window
301:49 - and Y is going to be well y this is the
301:52 - point we are getting up here
301:54 - finally we need a width and this one
301:56 - I've set to 3.
301:58 - and for this one if I draw this now you
302:02 - can see we have another horizon line
302:04 - that if it makes the entire thing look a
302:06 - bit nicer
302:07 - cool so with that we are displaying the
302:11 - sky the problem right now is that we are
302:14 - going to need some clouds
302:16 - also I should mention that you could
302:18 - optimize this one here a tiny bit more
302:21 - that this horizon line only really needs
302:23 - to be drawn if we have this condition
302:26 - here so technically I could move it in
302:29 - here and indent it properly run this
302:32 - again and we have the same outcome but
302:35 - now we're not drawing this line if it's
302:37 - not on the window
302:38 - but more importantly we now are going to
302:41 - need some clouds that is going to make
302:43 - out of this look much better and really
302:46 - important here those clouds need to be
302:49 - running inside of this display Sky
302:51 - because the clouds are supposed to be
302:53 - behind the water but on top of the
302:56 - Horizon Lines this is why I separated
302:58 - these two parts
302:59 - in between the two I want to run
303:01 - something like self dot display clouds
303:06 - since the clouds are going to move this
303:08 - one needs Delta time
303:10 - and this I can create right here we need
303:15 - a method called display louds
303:19 - and don't forget a parameter for Delta
303:21 - time
303:21 - first of all in here we need to know the
303:24 - position of the Horizon that is the same
303:27 - thing we have done in here so I could
303:29 - just copy it
303:31 - although to be a bit more elegant here I
303:33 - can also pass this y inside of this
303:37 - method
303:38 - that way we get Delta time and Y on top
303:42 - of that inside of the clouds there's one
303:45 - more change that we can make before we
303:46 - actually write any code inside of this
303:48 - method and that is I only want to
303:51 - display clouds if Y is greater than zero
303:56 - if the Horizon is above the entire
303:59 - editor and we only want to show water
304:00 - there's no point in displaying clouds
304:03 - and this if statement we already have up
304:06 - here which means I can put display
304:08 - clouds in there
304:10 - and then I can skip this if statement
304:14 - and now I can actually work on
304:16 - displaying the clouds
304:18 - essentially what I want to do in here I
304:20 - want to create some kind of let me call
304:23 - it self dot current louds these are the
304:27 - clouds that currently exist they don't
304:29 - right now but we are going to create
304:31 - them in just a second and I want to look
304:33 - at every single Cloud inside of here so
304:36 - for cloud in the current clouds
304:40 - current clouds is just going to be a
304:44 - list inside of that every single Cloud
304:46 - will be represented by a dictionary and
304:50 - this dictionary has a surface of the
304:52 - cloud we have a position and we have
304:54 - speed
304:56 - I want to get my cloud and in here I
304:59 - want to get the position
305:01 - this is going to give me a tuple with X
305:04 - and Y and for now I want to move all of
305:07 - the clouds to the left so it looks like
305:09 - they're moving
305:11 - put that in here I want to get 0 that is
305:13 - X and move it by the cloud and the speed
305:19 - of that cloud and this I want to
305:22 - multiply with Delta time
305:23 - once I have that I want to self.display
305:27 - surface and lit the cloud
305:30 - and in here we have the cloud surface
305:34 - although one thing we do need is a
305:36 - position and this position is going to
305:38 - be X and Y this one I want to create on
305:42 - separate lines to make it a bit easier
305:44 - to understand X is going to be the
305:46 - easier bit in here we have cloud
305:49 - we have a position and once again this
305:53 - is a tuple with X and Y I care about X
305:56 - Y is going to be a bit different
306:00 - although I can copy this bit in its
306:04 - entirety and change the 0 to a one
306:07 - this is a good start but what we have to
306:10 - be careful about is that all of this has
306:12 - to be relative to this y that way if
306:16 - this one here is the Horizon and we have
306:19 - some clouds here and let's say another
306:23 - Cloud here those are horrible clouds but
306:27 - the basic idea is if the player is
306:30 - moving the Horizon up all of the clouds
306:32 - should move up as well
306:36 - by the same logic if the player is
306:37 - moving the Horizon down the clouds
306:39 - should move down as well and this
306:42 - Behavior we get with Y minus the cloud
306:45 - position
306:46 - that way the clouds are always relative
306:49 - to The Horizon the one issue here is we
306:52 - have y twice which is going to be a bit
306:55 - confusing so I'm going to rename this y
306:58 - to Horizon y
307:01 - and with that we can work with our
307:05 - clouds the problem we have right now is
307:07 - that current clouds doesn't exist also
307:10 - even if it did exist it wouldn't have
307:12 - any content so there are two things we
307:15 - have to work on let me start by creating
307:17 - another method that I called create
307:20 - louds in here we need itself and we are
307:23 - going to need an event
307:26 - this is important for the timer I'll
307:28 - explain that in just a second but for
307:31 - now let me add pass in here and I can
307:35 - minimize the display Sky method and I
307:39 - can all the way in the init method
307:42 - let me do it right after the Imports I
307:45 - want to create clouds
307:47 - in here first of all we need the current
307:50 - clouds that is going to be an empty list
307:54 - and to for loop I have written down here
307:57 - is for the current clouds in just a bit
308:00 - we're going to populate this list with
308:03 - dictionaries but there are some things
308:05 - we have to cover first
308:07 - the most important one for now is we
308:10 - actually need some surfaces that we can
308:12 - use and those I am storing in a cloud
308:15 - surface and this is also going to be a
308:17 - list in here I'm going to use my import
308:21 - folder function
308:23 - and there's one path we want to import
308:25 - from this path is one folder up then we
308:29 - have graphics and then we have clouds
308:31 - that is horrible spelling like so
308:35 - if I look inside of the project folder
308:37 - we have Graphics inside of there we have
308:41 - clouds and then here we have three
308:44 - different clouds
308:45 - those I want to import next up we have
308:48 - to create a timer the basic idea is
308:51 - every time a timer ticks we want to
308:54 - create a new cloud and to create that we
308:57 - need Cloud timer
308:59 - and since this one is a repeating timer
309:02 - that is quite simple pygam has something
309:04 - inbuilt here this we get with pygame DOT
309:07 - user event and now we need plus one to
309:11 - not confuse the events in pi game once
309:14 - we have that we have a custom event and
309:17 - on this event we have to create a timer
309:19 - which we do with pygam.time and set
309:22 - timer
309:23 - for this one I want to set the self
309:25 - Cloud timer and now in milliseconds we
309:29 - need the duration of this timer in my
309:31 - case I want a new Cloud every two
309:33 - seconds or every 2 000 milliseconds once
309:36 - we have that I can minimize the init
309:40 - method and inside of my event loop I can
309:44 - call Self dot create clouds and
309:48 - important here I need the event
309:51 - with that I can minimize the event Loop
309:53 - and look at my create clouds
309:57 - the first thing I want to check in here
309:59 - is if event DOT type is equal to self
310:03 - dot Cloud timer
310:05 - I only want to run whatever is going to
310:08 - come next if this event is true so if
310:10 - the timer triggers
310:12 - and ultimately what I want to do I want
310:15 - to create a dictionary for each cloud
310:17 - with a surface a position and a speed
310:20 - which means I want to get myself dot
310:23 - current clouds and on this I want to
310:26 - append
310:27 - a dictionary
310:29 - that has his surface
310:32 - that has a position and finally that has
310:36 - e speed
310:38 - so let me add the colons here and we
310:42 - have to figure out these three bits of
310:44 - information and since there's going to
310:46 - be quite a bit of Randomness I want to
310:48 - have the random module or at least parts
310:50 - of it
310:51 - I want from random import choice and
310:55 - rent int
310:58 - for this surface we already have a list
311:02 - of surfaces that we can use the list of
311:05 - surfaces is self.cloud surfaces and this
311:10 - is right now a list with three different
311:12 - surfaces I want to have one of those at
311:14 - random for that I need choice
311:17 - and this surface I want to store
311:20 - in a separate variable
311:22 - now you could place the surface straight
311:24 - away in here but to add a bit more
311:27 - Randomness I want to do one more thing
311:29 - and that is surface is going to be
311:32 - pygame dot transform dot scale to X
311:37 - with this surface
311:39 - this method would scale the Surface by a
311:42 - factor of two and this I only want to do
311:45 - some of the time
311:46 - which I get with if Rand int between 0
311:50 - and 4 is smaller than 2.
311:53 - only if that is the case I want to
311:56 - double the size of this surface
311:58 - I suppose we could make this a tiny bit
312:00 - more elegant by copying this if
312:03 - statement here and pasting it all the
312:05 - way at the end and then else
312:08 - we keep the same surface
312:11 - that way we only
312:14 - use one line here like so besides that
312:18 - we need a position and we need this
312:22 - speed this speed is the really easy bit
312:24 - I just want to have a random integer
312:26 - between 20 and 50.
312:29 - that is going to be the speed since it
312:32 - is so simple I could just do Straight
312:34 - inside of the dictionary here that makes
312:36 - the code a bit more readable
312:38 - the only slightly more complicated bit
312:41 - is the position this one is going to be
312:44 - a list with X and Y and really important
312:48 - this has to be a list it cannot be a
312:51 - tuple because inside of this for loop
312:55 - we're going to update the position and
312:57 - with a tuple we couldn't do that
312:59 - for X I want to have my window width and
313:03 - to that I want to add a random number so
313:06 - rent in between 50 and 100.
313:10 - let me draw this actually
313:13 - we have our entire display surface here
313:15 - and the window width is going to be this
313:19 - line here to this I want to add a random
313:23 - number which I'm getting from here this
313:26 - is going to be the start position for my
313:27 - clouds they are always going to be
313:29 - slightly to the right of the window
313:31 - for the white part I also want to use
313:34 - Rand end and here I just want to use 0
313:38 - and the window height this means if I
313:43 - reopen the drawing
313:45 - all of the clouds can be somewhere
313:47 - inside of this range here
313:51 - and this might be confusing because you
313:53 - might be wondering aren't we going to
313:55 - have some clouds down here for example
313:57 - but that is not going to happen because
314:00 - of this line here we are always going to
314:02 - subtract this lowest point here from The
314:05 - Horizon which means effectively for most
314:08 - of the games we're going to move up the
314:10 - clouds to wherever the Horizon is
314:13 - and that is all we need let's try it
314:15 - actually if I run main.pi we are getting
314:18 - an error that we
314:21 - are missing something and that's
314:24 - something is I forgot to add the
314:25 - position in here
314:27 - now if we run this again
314:30 - if I'm waiting for a bit
314:34 - they can see a cloud all the way in the
314:37 - top right
314:38 - and those clouds if I move the editor
314:40 - around are only affected by the Y
314:42 - position not by X and this is
314:45 - intentional because if the player is
314:46 - moving too far left and right
314:49 - this would get confusing but this by
314:52 - itself is looking pretty good
314:57 - yep I'm definitely happy with this the
315:00 - issue is you can already tell when we
315:03 - are starting the editor we have to wait
315:04 - for the clouds
315:06 - which isn't ideal
315:10 - as a consequence I want to create
315:12 - another method here and this I called
315:14 - start up
315:16 - louds
315:19 - doesn't need any custom parameters and
315:22 - in this one I want to create a couple of
315:24 - clouds let's say for I in range I want
315:28 - to have 20 clouds when the game is
315:30 - starting and at the end of this for Loop
315:34 - what I basically want to have is a
315:35 - duplication of this line here again I
315:39 - want to create a dictionary for every
315:41 - single cloud and put them somewhere
315:43 - where the sky is and this is going to be
315:46 - the exercise here I want you guys to
315:48 - create a surface a position and a speed
315:52 - the position here is the most important
315:55 - bit when we are starting the game the
315:57 - clouds should be randomly covering the
316:00 - entire width of the sky so there
316:03 - shouldn't be to the right there should
316:04 - be in the middle somewhere try to figure
316:06 - this one out and definitely run the game
316:08 - a couple of times to see what looks good
316:10 - but possibly now and see if you can
316:12 - figure this one out
316:16 - the speed is the easiest one because
316:18 - this one we already have we can just get
316:21 - rid of it
316:22 - wasn't even necessary
316:24 - the surface is also quite easy because
316:27 - we basically have to do the same thing
316:29 - we have done here
316:30 - although to be a bit more fancy we can
316:33 - now optimize this to have it all on one
316:35 - line I want to have this surface
316:38 - and this one is going to be I can copy
316:41 - this entire line here except now for the
316:45 - surface I want to have
316:47 - this Choice function here
316:50 - but this I only want to do if
316:53 - the random condition is true
316:57 - and if that is not the case so else I
317:00 - just want to choose a random surface
317:02 - like so
317:05 - that way if your monitor is a bit larger
317:08 - you have all of this on one line and
317:10 - this Fields quite a bit more elegant
317:13 - besides that we need a position
317:16 - once again this has to be a list with X
317:18 - and Y
317:20 - and this one now is going to be really
317:22 - easy because I just want to have Rand
317:24 - int from 0 to the window width this is
317:28 - for x and for y I want to do the same
317:31 - thing I want to go from 0 to the window
317:34 - height
317:35 - we are placing the clouds somewhere in
317:38 - the middle of the window and that is all
317:41 - we need all I have to do now is actually
317:43 - call this startup clouds method this I
317:46 - do inside of the init method self dot
317:48 - start up clouds
317:51 - and now let's run main.pi and they can
317:55 - already see we have a bunch of clouds
317:56 - and this is looking much better
317:59 - I can also go up and down left and right
318:02 - all of this is working really well I
318:04 - guess the one limitation here is if you
318:06 - go too far up the clouds at some point
318:09 - disappear but I wouldn't imagine this to
318:12 - become too much of an issue
318:15 - although I guess if it is an issue for
318:17 - you you can definitely play around with
318:19 - this and make this more flexible but I
318:21 - am fine the way it is right now
318:24 - that being said there's one more thing
318:26 - that we do have to change
318:28 - and that is inside of create clouds the
318:32 - problem essentially is
318:34 - we keep on creating more and more clouds
318:36 - so we have more and more objects which
318:39 - at some point in the game is going to
318:41 - slow down performance because we keep on
318:43 - creating objects we never get rid of
318:45 - them for example once again we have the
318:49 - entire surface clouds keep on going
318:52 - further to the right and we keep on
318:54 - amassing more and more clouds on the
318:57 - left of the window if the game runs for
318:59 - an hour We're going to have hundreds
319:01 - maybe even thousands of clouds in here
319:04 - which we honestly don't need and this is
319:07 - going to be a drag on performance
319:09 - as a consequence every time we are
319:12 - creating a new Cloud we are also going
319:14 - to remove layouts
319:16 - and this is going to be self dot current
319:19 - clouds is going to be a list
319:21 - comprehension and I want to have Cloud
319:23 - for cloud in self dot current clouds
319:27 - right now we are literally just copying
319:30 - the current cloud list
319:33 - but I only want to have the elements
319:35 - inside of the list if cloud
319:39 - and position
319:41 - with zero is greater than let's say
319:45 - negative 400.
319:47 - this means I only want to have the
319:50 - clouds inside of the list if they are
319:52 - somewhere here so they are greater than
319:56 - negative 400.
320:00 - if they are further to the left I want
320:02 - to get rid of them which specifically
320:04 - here means I am not going to copy them
320:06 - over into my new list so they're just
320:09 - going to disappear
320:10 - this is not going to be visible in the
320:12 - game but I can run it make sure nothing
320:15 - breaks
320:17 - and now we can also see some new clouds
320:21 - and this is looking pretty good
320:24 - I guess the one limitation here is you
320:26 - are going to have a bit of a gap
320:28 - somewhere here
320:33 - but
320:35 - nothing too major so I'm quite happy
320:37 - with this
320:38 - and this covers the entire editor so
320:41 - with that we now have to figure out how
320:43 - to export all of this and create the
320:45 - actual level from it now that we have
320:48 - the editor we have to export the level
320:50 - data or at least we have to be able to
320:52 - and for that we need a couple of things
320:54 - most importantly we have to export the
320:58 - entire thing into some kind of grid this
321:00 - grid is going to make it much easier
321:02 - later on to build the level
321:04 - we already have a good start for this
321:06 - because the canvas tile here is really
321:09 - useful
321:10 - this one is going to become really
321:12 - important later on to build the actual
321:13 - level although there's one more thing
321:16 - that we do have to do and that is the
321:18 - objects right now are not in the system
321:21 - at all remember here all of the objects
321:23 - are just individual Sprites they are not
321:26 - part of the canvas tile system at all
321:29 - which means we somehow have to get them
321:32 - in there that's going to be a really
321:33 - important part for now and that is also
321:36 - what we are going to start with but
321:38 - let's start off this trading code and
321:40 - let's see how far we get once again we
321:43 - have the code and I want to keep on
321:45 - working inside of the editor the very
321:47 - first thing that we are going to need is
321:49 - going to happen inside of the event Loop
321:52 - inside of here I want to check if event
321:56 - DOT type is equal to pygame dot key down
322:01 - and the event key we are getting at that
322:04 - moment is going to be pygame.k
322:07 - underscore return those two statements
322:10 - combined check if the player is pressing
322:12 - the enter button if that is the case I
322:14 - want to export the map and create an
322:16 - actual level although in our case there
322:19 - are quite a few more steps before we get
322:21 - to that stage
322:23 - now in here all I want to do for now I
322:26 - want to print let's call this one self
322:28 - dot create grid on this grid method here
322:32 - is going to actually export the level
322:35 - this one doesn't exist right now so
322:37 - let's create it
322:39 - create grid and then here we don't need
322:43 - any custom parameters
322:45 - inside of this method first of all we
322:48 - have to add the objects to the tiles
322:52 - and once we have that I want to create a
322:55 - grid
322:57 - where each cell is going to be one cell
322:59 - inside of the actual level let's go for
323:02 - this step by step and first of all I
323:04 - want to add the objects to the tiles for
323:07 - that since I do have access to all of
323:09 - the objects we have four let's say obj
323:12 - in self dot canvas objects
323:15 - in here for example I can print obj dot
323:21 - top left
323:23 - oh and this should be
323:25 - object.rect dot top left
323:28 - and now if I run this and press enter we
323:31 - are getting
323:32 - the top left positions of both of the
323:34 - objects we currently have in the game
323:36 - which means in here we do have some
323:39 - starting positions although we don't
323:41 - really care about the top left instead
323:43 - we care about the current tile let me
323:46 - explain what that means right now the
323:48 - player has a border that's something
323:51 - like this and the top left of the player
323:54 - is this bit here as a consequence the
323:58 - player is going to be inside of this
324:00 - tile or rather this is the tile that I
324:03 - want to add the player to same for the
324:06 - sky handle the top left of the sky
324:08 - handle is this bit here and this I want
324:11 - to add to this tile
324:14 - and that way we're getting the object
324:16 - into the grid system
324:20 - I hope that makes sense basically what
324:22 - we are going to do we're getting the top
324:24 - left of any kind of object and we are
324:26 - adding it to the canvas tile in this
324:29 - particular cell
324:30 - for that first of all we need to get the
324:34 - current cell of this canvas object now
324:38 - we already have a method that kind of
324:41 - works here we have self and get current
324:43 - cell
324:44 - although so far we always use this with
324:47 - the most position but I want to expand
324:49 - this method a tiny bit so that it can
324:52 - also deal with basically any kind of
324:54 - object
324:56 - which means we have to work inside of
324:58 - get current cell
325:00 - first of all in here
325:02 - we have to create another parameter
325:05 - let's call it obj and by default this is
325:07 - none that way we don't have to change
325:10 - any of the other method calls that we so
325:12 - far have used
325:13 - we only want to get this line here if
325:17 - obj is none or if it exists at all so if
325:21 - not obj that way once again we don't
325:24 - have to change anything else however if
325:27 - that is not the case so else meaning we
325:30 - have some kind of object
325:31 - what I didn't want to return is the
325:34 - vector
325:35 - and the vector is going to be obj and
325:38 - distance to origin
325:40 - from this I want to subtract self dot
325:43 - origin
325:44 - this might sound a tiny bit confusing
325:46 - but this logic here is basically the
325:49 - same thing we have done here for the
325:51 - mouse except now for the position we are
325:54 - not using the mouse position we are
325:56 - using the distance to the origin and
325:59 - that way we can leave all of this
326:01 - exactly as it is and we are good to go
326:04 - let's try this actually
326:06 - instead of printing the top left of the
326:09 - current object I want to get the current
326:11 - cell
326:12 - meaning now if I run all of this and
326:15 - place the player in the top left
326:17 - if I print enter now we get 0 and 0 down
326:20 - here and 9 and 5 for this guy handle
326:23 - let's say if I move this thing one cell
326:26 - further to the left press enter again
326:28 - and now we get 0 and 0 for the player
326:30 - and eight and five this seems to be
326:32 - working just fine let's try it one cell
326:35 - up
326:36 - and we get eight and four so I'm quite
326:39 - happy with this this seems to be working
326:41 - just fine
326:44 - with that we know the current cell of
326:47 - whatever object we are looking at
326:49 - although there's one more thing that we
326:51 - do need and that is the offset what this
326:54 - one means is if this one here is one
326:58 - individual cell inside of the game let
327:00 - me add a couple of supporting lines
327:02 - something like this
327:05 - this could be one cell inside of the
327:07 - editor inside of here we could for
327:09 - example have a player that covers an
327:12 - area like this
327:14 - the offset is going to be this offset
327:18 - here I want to know how far is the top
327:20 - left of the object from the origin point
327:22 - of the cell this is going to become
327:25 - important later on to place the Sprite
327:26 - exactly in the right position
327:28 - because remember right now the cell is
327:31 - always fairly static we only really have
327:33 - the top left
327:35 - but the objects are going to be a bit
327:37 - more flexible and this we have to
327:39 - account for and the offset here could
327:41 - actually be a really interesting
327:42 - exercise for you so try to get the
327:46 - distance between the top left of the
327:48 - cell and the top left of the object
327:51 - and see how far you get
327:55 - first of all we need the distance from
327:58 - the object to the origin point this we
328:01 - get with obj DOT distance to origin this
328:04 - is the same thing we have done up here
328:07 - in get current cell
328:08 - I guess I should mention here we can't
328:11 - use the top left because this always has
328:14 - to be relative to the origin
328:16 - but essentially this one here is the top
328:18 - left in our more flexible system
328:21 - and if I draw all of this if we have
328:24 - once again here the entire level and let
328:27 - me draw a couple of cells we have one
328:30 - cell here one cell or rather a column
328:33 - and a couple of rows
328:36 - with the origin point being here and the
328:40 - distance to the origin could be let's
328:42 - say we are here meaning this distance is
328:46 - what we are getting right now but in my
328:48 - case I don't want to get the entire
328:50 - distance what I want is the distance
328:52 - from this point here to this point for
328:57 - that we need to get the current
329:00 - tile
329:01 - which means we have to know the column
329:03 - and the row
329:05 - this we already have because we know the
329:08 - current cell that we are in
329:10 - which means from this point I want to
329:13 - subtract the current cell although this
329:16 - I want to multiply by the tile size
329:18 - remember here the current cell is a
329:21 - position like 1 2 and 3 but we need
329:24 - actual pixel positions which we're
329:26 - getting by multiplying this by the tile
329:28 - size
329:29 - although once again distance to origin
329:31 - and current cell both are tuples which
329:35 - means I want to convert both to a vector
329:38 - that way we can multiply the current
329:40 - cell with the tile size and not get an
329:42 - error and let me put this into brackets
329:44 - so it's a bit easier to see
329:46 - and I want to do the same thing for
329:48 - distance to origin so this is going to
329:51 - be a vector for sure and that way we are
329:54 - getting the offset I suppose let me
329:56 - print it to see what's going on
329:59 - if I now run the entire thing and press
330:01 - enter we're getting some random numbers
330:03 - they don't tell you that much right now
330:06 - but if you look at the player and I can
330:10 - place the player roughly in the top left
330:13 - if I press this now the player moves
330:15 - closer to the top left the player here
330:17 - is a tiny bit confusing because the
330:20 - actual area the play occupies is
330:22 - something like this
330:24 - the player is much larger than the
330:25 - graphic here
330:28 - I guess you could be seeing it a bit
330:30 - easier with the sky handle
330:32 - if I move it here
330:35 - now you can see we're getting much
330:37 - closer to the top left than we were in
330:39 - the last time we called this method
330:43 - at the very least it works definitely
330:45 - play around with this yourself and see
330:47 - how it works
330:49 - with that we know where the object is
330:53 - and what the offset is going to be both
330:56 - of these are going to give us the exact
330:57 - position where the Sprite needs to be
330:59 - now we need to figure out how to get
331:02 - this one into a canvas tile and for that
331:05 - first of all I need to check if this
331:07 - current cell actually exists inside of
331:10 - our canvas data meaning if in the
331:12 - current cell we actually have something
331:14 - already
331:15 - which means if the current cell is in
331:19 - self.canvas data this means
331:23 - a tile exists already
331:27 - and let me add a pass in here and
331:30 - besides that we have else
331:33 - which means that no tile exists yet
331:38 - but now I am only going to worry about
331:40 - this case here that we already have a
331:42 - tile if that is the case I want to get
331:45 - this tire which means self dot canvas
331:48 - data and the current cell
331:52 - and I want to call add ID
331:55 - although now I want to have object dot
331:59 - tile ID and I want to have the offset
332:04 - I should probably explain object.tile ID
332:06 - is going to tell us what kind of object
332:09 - we have if I go all the way down inside
332:12 - of the canvas object we have the tile ID
332:14 - once again this is one of these IDs here
332:19 - and we want to know which one we are
332:20 - currently dealing with
332:22 - besides that I also need to know the
332:25 - offset so the distance from the top left
332:28 - this is really important to place the
332:29 - object properly although this offset we
332:33 - can't really account for yet
332:35 - as a consequence we have to expand this
332:38 - add ID method
332:40 - which I am going to do all the way down
332:44 - here we have ADD ID
332:46 - for this one once again we need another
332:48 - parameter let's call this one offset as
332:51 - well and in here since we are using this
332:54 - add ID already I want to have a default
332:56 - argument by default this offset is going
332:59 - to be an empty Vector that way we don't
333:01 - have to make any changes to the ad ID we
333:03 - already used multiple times inside of
333:06 - this
333:08 - I want to have another case
333:10 - in this case is going to be an
333:13 - underscore which means if none of these
333:15 - cases are true we are going to do this
333:17 - one here and this is then going to tell
333:20 - us that we are working with objects
333:23 - inside of the canvas Tire I think way
333:25 - earlier I created objects which is just
333:28 - going to be an empty list this we want
333:30 - to fill and what I want to fill it with
333:34 - let me get self.objects
333:36 - I want to append a tuple with the tile
333:41 - ID and with the offset
333:44 - and you could leave this as it is but I
333:47 - added one more if statement and that if
333:49 - statement is if the tile ID and the
333:53 - offset is not in self dot objects
333:58 - only if that is the case I want to
334:00 - append this the idea here is that it
334:04 - shouldn't be possible to have the same
334:05 - object in exactly the same position so
334:08 - for example we couldn't have a palm tree
334:09 - exactly in the same spot that would be
334:12 - kind of weird
334:13 - but other than that we are good to go
334:17 - although well not really because we are
334:21 - only accounting for one case we need to
334:23 - account for the other case
334:24 - if there is no tile yet I have to create
334:28 - a new one which means self and canvas
334:31 - data once again I want to get the
334:34 - current cell and now I have to create a
334:37 - canvas tile remember again if I minimize
334:42 - everything and look at the canvas tile
334:43 - right now we only have the tile ID this
334:47 - we definitely need
334:48 - I need the tile ID however now we also
334:52 - need the offset
334:54 - otherwise we couldn't place the object
334:55 - properly so we have to change the init
334:59 - method of the canvas tile to account for
335:02 - the offset and this is going to be an
335:04 - exercise for you update the canvas tile
335:07 - so that by the end of it
335:10 - we get the object in there even if
335:13 - there's nothing else in there so
335:15 - positively now and try to figure this
335:17 - one out there aren't too many changes
335:19 - you have to make
335:22 - first of all we need another parameter
335:25 - let's call it offset once again that one
335:27 - seems to make the most sense
335:29 - also once again you do want to have a
335:31 - default value in my case Vector 2. that
335:34 - way we don't have to make any changes to
335:36 - the existing canvas tiles we have used
335:37 - if you didn't add this one you would
335:40 - have to change every single canvas tile
335:42 - you have created so far would be kind of
335:44 - a pain
335:45 - and besides that when we are calling add
335:47 - ID
335:49 - for the offset
335:51 - I want to use the offset that way if we
335:55 - have a value here we are going to pass
335:57 - it through
335:58 - and this is all you have to change
336:02 - wasn't actually so bad although I do
336:03 - want to get rid of the comment here
336:05 - that's going to be annoying otherwise
336:08 - cool so with that we are adding the
336:12 - objects to the canvas tile system which
336:16 - is all we really needed
336:19 - however there's one more change that I
336:21 - do want to make and that is if we kept
336:24 - the system like this we are only ever
336:26 - adding more objects to the canvas tiles
336:28 - but we're never cleaning things up so
336:31 - let's say I place the player in one
336:33 - position start the level then go back to
336:35 - the editor place the player in another
336:36 - position and then start the level again
336:38 - we're not getting rid of the original
336:40 - player which we do have to account for
336:44 - and this is quite easy all we need is
336:47 - for tile in self dot canvas dot uh not
336:53 - objects but data
336:55 - dot values inside of here I want to
336:59 - empty all of the objects
337:01 - and with that we have a proper system to
337:04 - account for all of the objects
337:07 - so now we can actually create the grid
337:10 - however for that we are going to need a
337:13 - couple of things so let me go through
337:15 - this one by one first of all we need a
337:19 - red offset
337:21 - once again we have the entire window and
337:25 - inside of this we have a couple of
337:28 - columns and a bunch of rows
337:31 - something like this I am getting better
337:34 - at drawing straight lines
337:36 - the issue we have right now is that we
337:38 - have a huge amount of data that we don't
337:42 - really need because it's completely
337:43 - empty so for example if we exported the
337:46 - game without placing anything we would
337:48 - have the player let's say here
337:51 - and we would have to Sky handle in this
337:54 - cell here
337:55 - everything else we could basically
337:57 - disregard
337:58 - which means we have to figure out a
338:00 - system to only get the cells that we
338:02 - actually want
338:03 - specifically in this case I want to have
338:06 - only these two cells here this is what
338:09 - actually is going to build the level
338:11 - everything else is just going to be
338:13 - empty data that I'm going to ignore now
338:16 - later on obviously we are going to fill
338:18 - this with terrain tiles palm trees
338:20 - enemies but in the most basic sense we
338:22 - only really want to create two tiles
338:25 - and for that the first thing we need is
338:28 - the top left of all of the tiles that
338:31 - actually exist in this case right now it
338:34 - would be the player but it could be any
338:36 - kind of tile
338:37 - so more specifically what I want to get
338:39 - is the top left tile that is actually
338:42 - filled
338:43 - and this one I have separated I want to
338:46 - have the left side or the left tile
338:49 - position that is actually filled and the
338:51 - top one how we are going to do this
338:53 - first of all I need self.canvas data and
338:58 - then here I only really care about the
339:00 - keys because the keys are the position
339:03 - and this I want to have inside of a
339:06 - sorted function
339:08 - which means for this I also need a key
339:11 - the key here is going to be a Lambda
339:14 - function
339:15 - and let me call the parameter here a
339:18 - tile
339:19 - and I want to sort all of this by tile
339:23 - and zero canvas data.keys is going to
339:27 - give us a position
339:28 - for example this could be 64 and 128
339:34 - for X and Y positions here this we are
339:37 - going to pass into the tile parameter
339:39 - and on this we are only getting tile
339:42 - zero which is going to be the X bit this
339:46 - is the one we actually care about from
339:48 - this one here
339:49 - and once we have that this sorted method
339:52 - is going to sort all of this from the
339:55 - lowest to the highest number
339:57 - and since we only care about the
339:59 - leftmost tile we want to know the tile
340:02 - here with the lowest x value which means
340:05 - from this list I only want to get the
340:08 - first item that is going to be the very
340:11 - lowest x value or the leftmost position
340:14 - of all of our canvas data positions and
340:18 - this is going to return an X and A Y
340:20 - value I only care about the X1 so I want
340:23 - to get another indexing of 0.
340:25 - the same thing we have to do for the top
340:27 - position and this is going to be your
340:30 - exercise to see if you can follow along
340:32 - try to get the top left position of all
340:35 - of the filled canvas tiles
340:37 - should be fairly similar to this one you
340:39 - do have to make some minor changes
340:40 - though
340:44 - I am going to copy the entire thing like
340:48 - so
340:49 - and now first of all
340:52 - of this here can stay identical because
340:55 - we once again care about the positions
340:57 - but now for the key I don't want to sort
341:00 - the items by the x value but rather by
341:03 - the Y value
341:04 - with this one now I'm going to get a
341:07 - sorted list from the lowest to the
341:09 - highest y position of all of the
341:11 - existing canvas tiles from this once
341:14 - again I want to get the first item but
341:16 - now I want to get the Y position of this
341:19 - first item instead of the X position and
341:21 - with that I have the leftmost at the
341:23 - topmost position of all of our filled
341:26 - canvas tiles let me print this one
341:28 - actually to see what we get I want to
341:30 - print the left and I want to print the
341:32 - top
341:33 - if I now run main.pi and press enter we
341:37 - are getting an error
341:38 - and the error we get here on tile ID
341:41 - because this one should be object.tile
341:43 - ID
341:45 - if I run all of this like so we get 2
341:48 - and 5 which I think is the top left
341:50 - position of the player but if I move
341:52 - this object here to let's say somewhere
341:55 - here we get 1 and 3. so we now have a
341:59 - different top left position this seems
342:01 - to be working just fine
342:03 - once we have that
342:06 - I want to create
342:08 - an empty grid
342:11 - what this actually means is now we can
342:13 - start working on the actual data
342:16 - structure we need for the level
342:18 - for this one I want to have various
342:19 - layers which is going to be another
342:21 - dictionary and in here let me copy paste
342:25 - a couple of things
342:27 - I want to have these items
342:30 - these are going to be all of the
342:33 - different layers we are going to have
342:35 - inside of the actual level the order
342:38 - here also is important because later on
342:40 - for the level I'm going to cycle through
342:42 - and for example I want to have the water
342:44 - all the way in the back then I want to
342:46 - have to back on palm trees then the
342:48 - terrain and so on but all we are really
342:51 - going to do for each of these
342:53 - dictionaries I want to have an X and A Y
342:55 - position and then I want to have some
342:58 - kind of value for example for terrain
343:00 - this could be what kind of terrain we
343:02 - are going to need
343:04 - which means we want to fill the grid
343:09 - and this we do with or tile position
343:15 - and the actual tile in self dot canvas
343:18 - data and items
343:22 - with this we're getting the tiled
343:23 - position and the tile and this we can
343:26 - use to actually fill all of this here
343:29 - although first of all we need to get an
343:32 - X position and we need to get a y
343:34 - position
343:35 - unfortunately this isn't as easy as
343:38 - getting something like tile position and
343:42 - zero because we have to normalize this
343:44 - position to the top left the values we
343:47 - get up here
343:48 - let me actually move this one down a
343:50 - tiny bit so this is easier to see
343:53 - like so
343:57 - and let me explain what this actually
343:59 - means
344:01 - once again we have a couple of columns
344:04 - and rows inside of the editor and when
344:08 - we are exporting everything
344:11 - and once we start to exporting things
344:13 - the player could be in this cell here
344:16 - for Simplicity let's say this cell is 2
344:19 - and 3 for X and Y
344:21 - also this is going to be the top left
344:24 - cell of all of the filled canvas tiles
344:27 - inside of the actual level this has to
344:29 - become the top left cell which means
344:32 - instead of 2 and 3 this needs to be 0
344:35 - and 0 because it is the top left cell so
344:39 - this is the one we are starting with
344:42 - now to get that
344:45 - I first of all want to get the row and
344:49 - the column and those are going to be
344:51 - adjusted for so let me rename it
344:54 - actually
344:55 - row and column adjusted
344:58 - for this one now we are going to need
345:00 - for the column we have tile position 0
345:03 - and for the row is going to be one so we
345:06 - have X and Y
345:08 - from this for the row I want to subtract
345:11 - the top
345:13 - and for the column I want to subtract
345:15 - the left
345:18 - remember here the left and the top are
345:20 - giving us a cell position so this could
345:23 - be one two or three depending on what
345:25 - cell we are in and this number we are
345:27 - subtracting from the cell we have and
345:30 - that way the top cell if I draw this
345:33 - again
345:34 - with this cell being the top left cell
345:37 - left would be two and top would be three
345:40 - and these are the numbers we're
345:42 - subtracting from the cell and that way
345:44 - we're getting to zero and zero if we had
345:46 - another cell let's say here
345:49 - that had three and four we would be
345:52 - doing the same thing and that way the
345:54 - number would become a one and two
345:58 - which will be the distance that we now
346:00 - need here
346:02 - although all of this is still going to
346:04 - be in Grid positions but I want actual X
346:07 - and Y positions to make this easier to
346:09 - place later on and this is quite easy
346:12 - for X I want to have the call adjusted
346:15 - multiplied by the tile size and for y
346:18 - this is going to be row adjusted
346:21 - multiplied by the tile size
346:23 - this is giving us actual pixel positions
346:26 - we can place right away we don't have to
346:28 - multiply with anything
346:29 - and once we have that this is now going
346:33 - to involve a couple of if statements for
346:36 - example if a tile has water
346:38 - I want to get
346:40 - my layers
346:41 - in here I want to get the water and I
346:44 - want to create a new key and this key is
346:47 - going to be the X and Y position
346:50 - although now for this water position we
346:54 - have to know if we have a top water cell
346:56 - or a bottom water cell
346:59 - and this logic I want to keep inside of
347:02 - the tile which means I'm going to create
347:04 - a method that is going to be called get
347:07 - water
347:09 - let's create it right away inside of
347:11 - canvas tile I want to have another
347:14 - method get water
347:17 - all I really want to do in here is
347:19 - return
347:20 - bottom
347:22 - if self and water on top if that is not
347:27 - the case so else this is going to return
347:29 - top
347:31 - with that
347:34 - for every water cell we know exactly
347:37 - what kind of water cell we need to place
347:40 - next up
347:43 - I want to check
347:46 - if the tile
347:48 - has to rain
347:50 - if that is the case once again I want to
347:53 - get my layers and then here I want to
347:55 - Target terrain so we just work with
347:58 - water now I'm working with Terrain
348:01 - once again I want to get an X and Y key
348:05 - here
348:06 - and the value for this is going to be
348:08 - something like tile and get the rain
348:12 - this one once again we have to create
348:15 - which means all the way in the bottom
348:19 - Define get Terrain
348:23 - what I want to return here
348:25 - is going to be a string
348:28 - that is going to contain with the join
348:31 - method self dot terrain Neighbors
348:35 - essentially if I look at the init method
348:38 - all I really care about for the terrain
348:40 - is the actual terrain Neighbors
348:43 - because this one is going to tell me
348:44 - what kind of graphic I need for each
348:46 - individual terrain tile
348:49 - so we can just leave it at that
348:52 - which means we don't need anything else
348:54 - I can move up although in here we are
348:57 - going to need one more thing
349:00 - and that is if we don't have a Terrain
349:03 - or is specifically named Terrain in here
349:06 - I want to get the X1
349:08 - which means I want to get this terrain
349:11 - but only if tile and get the rain don't
349:15 - forget to call it is in self dot land
349:19 - tiles we only want to get this graphic
349:21 - if the graphic actually exists inside of
349:23 - here if that is not the case so else I
349:27 - want to have the X graphic the one that
349:29 - works as a default tile
349:31 - besides that if tile and coin
349:36 - that I want to look at my layers for the
349:40 - coin that is going to be this one here
349:43 - and once again I want to get X and Y
349:47 - and this one is going to be easier
349:49 - because all I want is tile.coin this one
349:52 - doesn't need any method however there's
349:54 - one thing that we do need this one here
349:57 - is always going to be the top left
349:59 - position
350:00 - but the problem we have seen here is
350:03 - that if this is one tile a coin is going
350:07 - to be stuck here in the top left which
350:09 - is going to look weird as a consequence
350:12 - I need to adjust these X Y values to
350:15 - place the coin right in the center of
350:18 - the tile
350:19 - that is something we can do quite easily
350:21 - all we have to do is plus the tile size
350:24 - divided by two
350:27 - we are getting closer to the Finish Line
350:29 - next up I want to check if tile dot
350:32 - enemy exists
350:34 - if that is the case I want to get my
350:36 - layers once more I want to look at the
350:38 - enemy this is enemies actually
350:42 - so in here we have enemies this one can
350:45 - just be X and Y
350:48 - and in here I want to get tile dot enemy
350:51 - this one is very similar compared to the
350:54 - coin
350:55 - finally for the last one we need if tile
350:59 - dot objects which means if inside of
351:02 - this tile we have an object
351:05 - I want to look at for obj
351:08 - and offset in tile dot objects
351:14 - remember here inside of tile objects we
351:17 - always have a tuple and the Tuple is
351:20 - going to contain the object and the
351:22 - offset from the top left
351:24 - which is what we're getting here inside
351:26 - of the for Loop
351:28 - but now the important thing that we do
351:30 - have to figure out is inside of this
351:33 - layers dictionary we have background
351:35 - palm trees and we have foreground Pawn
351:38 - trees both of these are going to be
351:40 - objects
351:41 - while ground objects also has the player
351:43 - so this is why it's not called palm
351:45 - trees
351:46 - but this separation we have to create
351:49 - ourselves
351:50 - which means inside of this for loop I
351:53 - want to have an if statement if we have
351:55 - VG palm trees and if that is not the
351:58 - case so else
352:00 - I want to have all of the foreground
352:04 - objects
352:05 - what we need in here I want to check if
352:09 - the object we currently have
352:11 - is inside a certain list remember here
352:14 - object refers to a number so this could
352:16 - be one two three or more likely it's
352:19 - going to be somewhere between 11 and 18.
352:22 - although it could also be zero for the
352:25 - player but this is what I have to check
352:27 - for
352:28 - and more specifically what I want to
352:30 - check for is the key for key and value
352:35 - in editor data dot items
352:39 - meaning this right now is going to give
352:41 - us all of the keys of this dictionary
352:44 - here but we only care about the keys if
352:48 - the value
352:50 - of that particular key more specifically
352:53 - the style is equal to Palm
352:58 - BG this basically means we are only
353:01 - getting the keys from this dictionary if
353:04 - the value has
353:07 - style and pawn BG which means this
353:11 - comprehension here would return the
353:14 - numbers 15 to 18. and if the object is
353:17 - inside of that we know it's a background
353:19 - palm tree
353:20 - meaning inside of here I can get my
353:23 - layers I can get BG Palms that is the
353:27 - layer we have created here
353:29 - and on this once again I need to get an
353:32 - X and A Y position
353:34 - with the value being the object now for
353:37 - the X and Y position here we have to
353:39 - account for the offset
353:41 - which means for X I want to have plus
353:44 - offset dot X and for y I want to have
353:48 - the offset dot y
353:50 - and while I was testing this sometimes
353:54 - because the offsite is going to be a
353:56 - vector we had some problems so I want to
353:59 - convert all of those to integers
354:01 - but once we have that we are good to go
354:05 - the last thing we need I can just
354:06 - duplicate the entire thing here and now
354:09 - instead of the background palm trees I
354:11 - want to have the foreground objects
354:14 - the rest can remain identical though
354:18 - finally the very last thing we have to
354:20 - do this for Loop here is done so I can
354:23 - minimize it and now all I want to do is
354:26 - to return this
354:29 - layers grid
354:32 - and with that we should be done with
354:34 - exporting the entire editor map let's
354:38 - try it actually if I run this now and
354:40 - press enter
354:42 - and let me see what we get we get
354:44 - nothing for water palm trees terrain and
354:46 - so on but for the foreground objects we
354:49 - have the player here and we have the sky
354:51 - handle which means something is
354:54 - definitely working
354:56 - if I try this again and place some
354:58 - elements let's say some terrain some
355:01 - water palm tree enemy and a coin and run
355:07 - this again
355:08 - we are getting an error
355:10 - let's have a look this happens inside of
355:13 - the for Loop
355:14 - when we are adding the coin and I think
355:16 - the problem here is the layers called
355:19 - coins not coin
355:21 - like so and now let's try this again
355:25 - I want to have a couple of things of all
355:28 - of the different elements like so if I
355:30 - run this now
355:31 - we didn't get an error but now I forgot
355:34 - the water
355:35 - and we don't have background trees but
355:37 - we do have terrain tiles with the name
355:40 - of the terrain and the position quite a
355:42 - few of those then we have an enemy we
355:45 - have coins and we have foreground
355:47 - objects
355:49 - this seems to be working really well
355:51 - although just to make sure I also want
355:54 - to place
355:56 - a background palm tree and I want to
355:58 - place some water just to make sure this
356:00 - is working
356:01 - if I run this now
356:04 - we have some water
356:06 - and if I find it really quick we have
356:09 - background palm trees that seems to be
356:12 - working quite well
356:16 - and with that I can minimize the entire
356:19 - create grid method
356:21 - and this covers another major part for
356:23 - the game
356:24 - before we are going to continue I
356:26 - realized I forgot one important thing
356:28 - and that is a quick drawing fix in the
356:31 - editor to properly display everything
356:34 - let me actually show what the problem is
356:36 - right now
356:37 - back inside of the editor if I run the
356:39 - entire thing I can place some background
356:41 - tiles I can place a foreground palm tree
356:44 - and a background palm tree but now if I
356:46 - move the player the player is behind the
356:49 - background palm trees which is kind of
356:52 - weird because they are supposed to be in
356:54 - the background this also looks a bit
356:57 - weird because they can just be in front
356:59 - of the terrain which I really don't like
357:03 - the fix for that though is quite simple
357:05 - inside of the editor in the init method
357:08 - when I am creating all of the objects
357:11 - right now we only have a single group
357:14 - for all of the objects I want to create
357:17 - two more we have self and foreground and
357:22 - self and background both of those are
357:25 - going to be a Sprite group I guess I can
357:27 - copy this one
357:29 - and paste it in here now we have a few
357:32 - more groups
357:34 - and this we can use when we are adding
357:39 - where did I put it canvas at
357:43 - down here we are adding all of the
357:45 - objects
357:47 - when I'm placing the groups I want to be
357:49 - a bit more careful let me put all of
357:51 - this in a separate variable
357:53 - the groups should be self canvas objects
357:58 - and self background but only if we have
358:03 - the editor data again
358:05 - and in here I want to check myself and
358:08 - selection Index this is going to give me
358:11 - one of these items here
358:13 - on this I want to check this style
358:16 - and only if the style is Palm
358:20 - and this one is called Palm BG the one
358:23 - we are creating all the way at the
358:25 - bottom here
358:26 - if that is the case I want to have these
358:28 - two groups however if that is not the
358:30 - case so else the groups should be still
358:34 - self and
358:36 - this one I called canvas objects but now
358:40 - I want self and foreground
358:42 - once again if you have a bigger monitor
358:45 - this is going to be much better to see
358:47 - now that I have that I can replace this
358:50 - canvas objects with the groups
358:54 - by itself this isn't going to change
358:55 - anything but when I am drawing the level
358:59 - in here
359:01 - currently I am always drawing all of the
359:03 - objects on top of all of the tiles
359:06 - which is not necessarily what I want
359:10 - I can actually minimize the entire cell
359:13 - drawing logic so all of this and instead
359:16 - what I want now I want to have self dot
359:19 - background and this I want to draw on
359:22 - self dot display surface
359:25 - that way all of these background objects
359:28 - are going to be behind all of the tiles
359:31 - and in the foreground so self dot
359:34 - foreground I want to draw all of the
359:36 - other objects
359:37 - and now if I run this again we can't see
359:40 - anything however you could already see
359:42 - it if I hover over with the mouse over
359:44 - this area the player does exist we just
359:47 - can't see it same with the sky handle it
359:50 - is somewhere here
359:51 - it still exists we just can't see it the
359:54 - reason is never the player nor the sky
359:56 - handle are inside of either the
359:58 - foreground or the background group
359:59 - however if I place a palm tree or a
360:03 - background palm tree those still work
360:05 - and more importantly now if I'm placing
360:08 - a Terrain tile
360:10 - those are going to be in front of the
360:12 - background palm trees which makes the
360:14 - entire thing look much nicer but the
360:16 - other palm trees are always going to be
360:18 - in front of it
360:19 - the last specific thing now is that the
360:21 - player is not visible at all and this we
360:24 - have to change which is going to be your
360:26 - exercise change the code so that the
360:29 - player and the sky handle are going to
360:31 - be visible again pause the video now and
360:34 - see if we can figure this one out
360:38 - or this one I can minimize the drawer
360:40 - level method and go all the way to the
360:44 - init method when I'm placing the player
360:47 - and the sky handle
360:49 - the problem we have right now is that
360:51 - for the group we only have the canvas
360:53 - objects
360:55 - but we're only drawing the foreground or
360:57 - the background groups
360:59 - which means we have to change this one
361:01 - and this one into a group
361:05 - the player I want to be in the
361:07 - foreground so self dot for ground
361:11 - while the sky handle I want to be in
361:15 - self dot background and now this should
361:17 - be visible again that is looking much
361:19 - better now I can move them around
361:21 - everything still works just fine
361:22 - although now if I have terrain I can
361:25 - move the sky handle behind it you can
361:28 - still use it but I think this one looks
361:30 - a tiny bit better
361:31 - it's a matter of preference here there's
361:33 - no clear answer
361:34 - but now everything else works really
361:37 - well and this entire thing is coming
361:39 - together
361:41 - very nicely
361:43 - cool I am really happy with this
361:46 - finally we can start working on the
361:48 - actual level and first of all we need
361:51 - some kind of transition basically there
361:54 - should be a transition from the editor
361:56 - to the level if we switch them right
361:58 - away it would feel a bit too abrupt
362:00 - but for this transition to work we need
362:03 - to have at the very least a very basic
362:06 - level for now this level is not going to
362:08 - do anything it is just going to be a red
362:10 - background but at the very least we are
362:13 - going to be able to see something
362:15 - once again we are in the code and for
362:19 - once I don't want to work in the editor
362:20 - I want to create a new file
362:23 - this one I want to save as level dot pi
362:28 - in here we are going to need a couple of
362:30 - things let me copy them from the editor
362:32 - at the very least I want to have
362:34 - highgame and sys and the vector
362:38 - besides that I also want to have these
362:41 - two Imports here
362:43 - and the rest we don't need for now once
362:47 - I have all of that I want to create a
362:49 - class called level there's no need for
362:52 - inheritance and in here I want to have
362:54 - an init method and this one as always
362:58 - needs self
362:59 - and for now this is all that we are
363:02 - going to use inside of the method I want
363:04 - to get self dot display surface and this
363:09 - one I get as always with
363:11 - pygame.display.get underscore surface
363:15 - once I have that this level class is
363:18 - going to have an update method with self
363:21 - and Delta time
363:23 - although inside of this one for now all
363:26 - I want is self.display surface dot bill
363:29 - and just so that we can see something I
363:32 - want to have a red color
363:34 - although there's one more thing that we
363:36 - need in here and that is the event
363:40 - Loop
363:41 - this we absolutely need because remember
363:43 - inside of main.pi we don't really have
363:46 - an event Loop
363:48 - we are just running the game the event
363:50 - Loop either runs inside of the editor or
363:53 - inside of the level
363:54 - which means in here I need for event in
363:58 - pygame dot event dot get don't forget to
364:01 - call it and here I want to check if
364:03 - event DOT type is equal to pygame dot
364:07 - quit
364:09 - which means we are closing the game
364:11 - which means I want to quit Pi game and
364:14 - says.exit
364:16 - also don't forget to call self.eventloop
364:20 - so we are actually able to run it
364:23 - with that in place inside of main.pi I
364:26 - can from Level import level
364:30 - with this inside of the init method of
364:33 - the main I can create self dot level
364:37 - which is going to be level
364:39 - there are no arguments needed right now
364:41 - and once I have that I can run self dot
364:45 - level dot run
364:48 - and comment out the editor also I think
364:51 - I just realized inside of level I called
364:53 - this update let's call it run to keep
364:55 - more consistent
364:56 - also don't forget the other time and now
364:59 - if I run this we can see a plain red
365:01 - window
365:02 - which isn't what we want but at the very
365:04 - least this is working
365:07 - which means we now have level and we
365:09 - have an editor we just have to figure
365:11 - out how to switch between the two back
365:13 - and forth
365:15 - also I want to have an animation between
365:16 - the two
365:18 - so let's get started most of this is
365:20 - going to happen inside of main.pi inside
365:23 - here first of all I want to have another
365:26 - attribute that I called editor active
365:30 - by default this one is going to be true
365:34 - the reason here should be obvious that
365:36 - by default the editor should be open
365:38 - that is the first thing the player
365:40 - should see
365:41 - and with that in mind inside of the run
365:44 - method of the main class I can run if
365:47 - self dot editor active only if that is
365:52 - the case I want to actually run the
365:54 - editor and if that is not the case so
365:57 - else I want to run the level
366:00 - next up we are going to need another
366:03 - method that I called toggle
366:06 - in here we need itself and nothing else
366:08 - and all that is going to happen inside
366:11 - of this method is self dot editor active
366:14 - is going to be not self dot editor
366:17 - active
366:18 - meaning whenever we are calling this
366:20 - method we are switching editor active
366:22 - either to true or to false
366:25 - on this one now you might be tempted to
366:28 - just pass this toggle method into the
366:31 - player and into the level which would be
366:34 - possible but not ideal because I want to
366:37 - have a transition
366:39 - I think it's best to actually show the
366:41 - finished thing that's going to explain
366:42 - this the best
366:44 - here we have the final level and I
366:47 - already have a couple of terrain tiles
366:49 - if I now press enter
366:52 - we have this nice little animation
366:55 - that moves us from one to the other this
366:58 - is what I want to have as well in here
367:00 - to create this one I want to have a
367:03 - transition object to create this effect
367:05 - I want to have self dot transition this
367:09 - is going to be a whole separate object
367:10 - let's call it transition and only this
367:14 - one is going to call Self dot toggle
367:17 - meaning I want to pass it in here but
367:19 - make sure not to call it because I want
367:22 - to call this method from inside of
367:24 - transition
367:26 - this transition object I want to create
367:29 - right in here so class transition this
367:34 - is just going to be an animation it
367:36 - doesn't need inheritance though but we
367:38 - do need an init method
367:41 - this one itself and toggle
367:44 - first of all we need as always the
367:46 - display surface and this we get with
367:48 - pygame dot display dot get undescore
367:52 - surface
367:54 - we also have to store
367:56 - ourself.toggle which is going to be the
367:59 - toggle
368:00 - and finally I want to know if this thing
368:03 - is active or Not by default it is not
368:06 - with that I can start talking about the
368:09 - actual animation we are going to do
368:12 - how it's going to work is we have the
368:15 - display surface again and I'm going to
368:17 - draw a circle around like so
368:21 - by default this circle has a border
368:23 - width of zero meaning this width here is
368:28 - zero but once the animation is starting
368:30 - this border width is going to get bigger
368:33 - and bigger because of that it is going
368:37 - to cover more and more of the display
368:38 - surface in a circular manner so we're
368:41 - getting smaller and smaller circles and
368:43 - at some point we can't see anything of
368:45 - the actual editor anymore
368:48 - however once we are reaching this Middle
368:51 - Point here I want to reverse the
368:53 - animation so we are going this way again
368:56 - and that way it looks like the thing is
368:58 - opening
368:59 - also importantly here only when we have
369:02 - reached this blue point then I want to
369:05 - call the toggle method that way you
369:07 - can't see the switch between the editor
369:09 - and the level
369:11 - that way we don't get a sudden switch
369:13 - between the two makes the entire thing
369:15 - look much better
369:17 - for all of this I need a few more
369:19 - attributes the first one I want is self
369:22 - dot border with by default this one is
369:26 - going to be zero
369:27 - then I want to have a Direction so self
369:30 - dot Direction by default this is going
369:33 - to be 1 then I need self Dot Center
369:38 - and this is literally just going to be
369:40 - the window with
369:42 - divided by 2 and the window height
369:45 - divided by 2. next up I am going to need
369:49 - self dot radius
369:52 - this is going to be if I draw all of
369:54 - this again let me use a different color
369:57 - the radius the red color here is going
370:00 - to be the size from the center to where
370:04 - I want my actual Circle to be and the
370:07 - best size here I found is from the
370:09 - center all the way to one of the corners
370:12 - of the window they all have the same
370:13 - distance so it doesn't really matter
370:15 - which one and this is going to be the
370:17 - radius for the circle so I'm going to
370:19 - draw the circle roughly here you get the
370:23 - idea I hope
370:24 - for this one you could do some math but
370:26 - we don't really need it because we
370:29 - already have the center and this I want
370:31 - to convert to a vector so self Dot
370:33 - Center in here and since I know that
370:36 - this is going to be the center of the
370:38 - window I can just get the magnitude on
370:42 - this one and call it a day
370:44 - that being said I don't think the vector
370:47 - exists in here right now it does not so
370:51 - from the editor I want to import
370:54 - vector let's put it all the way at the
370:57 - top now this is going to work the last
371:00 - thing that I want to do is create a
371:02 - threshold
371:04 - and this is going to be self dot radius
371:07 - Plus 100.
371:10 - what this one is going to do is it gives
371:13 - us a threshold when we want to stop the
371:15 - entire thing you're going to see in a
371:17 - second how this is going to work but now
371:19 - that we have all of those
371:21 - I want to create let's call it a display
371:24 - method in here we need self and Delta
371:27 - time
371:28 - I want to check if self DOT active is
371:32 - true meaning I want to play the
371:33 - animation then I want to get myself dot
371:36 - border with
371:37 - and increase it by some number let's say
371:40 - 1000 is what iPhone look best multiplied
371:44 - by the Delta time and multiplied by the
371:47 - direction that way we are increasing the
371:50 - Border width by 1000 but since we're
371:52 - multiplying this with data time this
371:54 - becomes a much smaller number and
371:56 - Direction means we are increasing this
371:58 - in the positive direction so the thing
372:00 - is growing I'm not actually sure what
372:02 - happens in a negative direction if the
372:04 - starting point is zero but that doesn't
372:06 - really matter right now
372:08 - but with this we should already be
372:11 - seeing something although we need to
372:13 - draw the entire thing which means I want
372:15 - pygame dot draw dot Circle in here we
372:20 - need self dot display underscore surface
372:23 - for the color I'm just going with black
372:25 - then we need the center of the circle
372:27 - this is going to be the center of the
372:29 - entire thing then we need the radius and
372:32 - we do have a radius that is the radius
372:35 - finally we need a border width this we
372:38 - also have itself and Border width
372:40 - although this I want to convert to an
372:43 - integer because
372:45 - due to this operation we are almost
372:48 - certainly going to get floating Point
372:49 - numbers and this one here expects
372:51 - integers
372:52 - but now that we have that inside of the
372:56 - run method after we are checking if the
372:59 - editor or the level is running I want to
373:01 - run
373:03 - self.transition dot display I believe I
373:07 - called it and pass in Delta time we are
373:10 - calling this method here
373:13 - if I run the entire thing nothing is
373:15 - going to happen
373:16 - for the simple reason that active right
373:19 - now is false if I set it to true though
373:22 - and run the entire thing again
373:24 - we are getting an error I already see
373:26 - why this should be self dot Direction
373:28 - next attempt and there we go this is
373:31 - looking much better
373:33 - now we have this circle closing but we
373:37 - never know once it's opening again so
373:39 - this we have to work on
373:41 - and for that I have if self water width
373:45 - is greater or equal than self dot
373:48 - threshold
373:50 - if that is the case I want to set self
373:52 - dot direction
373:54 - to negative one
373:57 - if I run this now again
373:59 - we are getting a nice animation
374:02 - basically the way this one is working
374:04 - and this is what threshold is doing let
374:07 - me explain it properly now if this one
374:09 - here again is the entire window
374:13 - we have the radios looking something
374:16 - like this that is this radius here
374:19 - for Simplicity let's say this one could
374:21 - be 500 and this 500 is going to be
374:25 - important for the animation however once
374:28 - we are in the center I want the center
374:31 - to be closed for a tiny bit so we can
374:33 - only see a black window for a while
374:36 - the way I achieve that is with this
374:38 - threshold because this threshold is this
374:41 - 500 plus this 100. which means even
374:45 - after we are reaching the center we are
374:48 - increasing the border with a tiny bit
374:50 - more and that way the entire window
374:52 - stays black but only once we are
374:54 - exceeding this threshold we are
374:57 - reversing the entire animation
374:59 - I hope that makes sense if you play
375:01 - around with this for a tiny bit I think
375:03 - the logic is going to become obvious
375:04 - also what we can do in here is called
375:07 - self dot toggle I want to call this
375:11 - toggle when the entire thing is going to
375:13 - be black so the player cannot see the
375:15 - transition
375:16 - finally the last thing we didn't hear is
375:18 - if self and border with is smaller than
375:22 - zero
375:23 - if that is the case I want to set
375:26 - self.active back to false
375:29 - the border with should be zero
375:32 - and finally self dot direction should be
375:36 - one again that way when we restart the
375:38 - animation later on this works all
375:40 - properly
375:42 - meaning now if I run the entire thing
375:46 - this is working really good
375:48 - almost better than I expected actually
375:50 - you could see we started with the editor
375:52 - and then moved to the level so all of
375:54 - this is working
375:56 - which means now I can minimize it and I
375:58 - just have to figure out actually by
376:00 - default this active here should be false
376:04 - what I have to figure out now is how to
376:06 - call this transition from inside of the
376:09 - editor and from inside of the level for
376:12 - that I have created another method this
376:15 - one I called switch in here we need self
376:19 - and we need a grid although by default
376:22 - the grid is none
376:24 - the grid here is what we created inside
376:26 - of the editor
376:28 - inside of create grid what I'm expecting
376:31 - inside of this method is this return
376:34 - statement here the layers if we are
376:37 - running this first of all I want to set
376:39 - self.transition DOT active to true that
376:43 - way we are starting the animation
376:46 - and now if there is a grid we know we
376:50 - are going from the editor to the level
376:53 - which means I want to create a new level
376:56 - so self the level is going to be the
376:58 - level
376:59 - right now there are no arguments so we
377:01 - can just ignore it although I guess
377:03 - while we are here we can pass the Grid
377:05 - in here and inside of the level we can
377:08 - store the grid
377:10 - we are not going to use it for this
377:12 - section but later on this is going to
377:14 - become useful
377:15 - although what is also important in order
377:18 - to go back from the level to the editor
377:20 - this level object needs to know or needs
377:24 - to have access to the switch method
377:26 - which means in here I want to pass in
377:29 - self dot switch
377:31 - for this we have to create a parameter
377:33 - in here I want to create switch
377:36 - and that I want to store inside
377:39 - self.switch is going to be switch
377:42 - and to make all of this work inside of
377:46 - the event Loop if the event and type is
377:51 - equal to Pi game and K down and the
377:56 - event dot key is equal to pygame dot k
378:00 - underscore Escape
378:02 - this means we are pressing escape inside
378:04 - of the level if that is the case I want
378:07 - to call self.switch without any
378:09 - arguments
378:10 - what this means inside of this switch
378:13 - method we are only calling the
378:15 - transition we are not creating a new
378:17 - level as a consequence we can just see
378:20 - the editor speaking of the editor this
378:23 - editor when we are creating it up here
378:26 - we also need self dot switch
378:31 - this self.switch inside of the editor I
378:34 - want to minimize everything again and
378:36 - only work on the init method we need
378:39 - switch in here as well
378:42 - in this switch I want to turn into an
378:44 - attribute self.switch is going to be
378:47 - switch
378:48 - and now we just need to figure out when
378:51 - to call it and this we already have to a
378:54 - pretty good extent this happens inside
378:57 - of the event Loop in here right now we
379:01 - are just printing self.grid but instead
379:03 - of printing self.grid I want to self dot
379:06 - switch and pass the Grid in there
379:09 - meaning now when I call self.switch from
379:12 - inside of the editor this one here is
379:15 - going to be true
379:16 - meaning we are going to create a new
379:19 - level from the data we're getting from
379:21 - inside of the editor and that is the
379:24 - reason why inside of the editor we can
379:26 - have self.switch with an argument and
379:28 - inside of level.pi we can have switch
379:30 - without an argument and we have the same
379:33 - method except the method does a
379:34 - different thing depending on which way
379:36 - we are going also I realized this should
379:39 - be a double equation sign
379:41 - once we have all of that we don't
379:44 - actually have to create level inside of
379:47 - the init method
379:49 - because by default the level shouldn't
379:51 - exist we only want a level to exist once
379:54 - we're switching from the editor to a
379:56 - level
379:57 - and now with all of that let's try I can
380:00 - press enter
380:01 - we're getting to the level I can press
380:03 - escape and we're going back to the
380:05 - editor and in here we can keep on
380:07 - working all of this is working really
380:09 - well let's try it again
380:11 - obviously we cannot see the editor but
380:13 - at the very least all of this seems to
380:15 - be working just fine
380:17 - cool so with that we have covered
380:20 - another major section
380:22 - so next up we can actually flesh out the
380:24 - level
380:25 - so for the next part we can place the
380:28 - terrain on top of that I am also going
380:30 - to place the basic version of a player
380:32 - that isn't going to have any animations
380:34 - yet I just want to have something for
380:36 - the player so let's Jump Right In and
380:39 - let's see what we have to do
380:41 - once again we have main.pi and we have
380:44 - level.pi the editor we are not going to
380:47 - use for quite some time
380:49 - inside of the level we also have the
380:51 - grid available this one is going to
380:53 - contain all of the information we need
380:55 - to build everything which means I want
380:58 - to work inside of the init method and
381:00 - then here I first of all need a few more
381:03 - things
381:04 - since we are going to use Sprites for
381:06 - most of this I want to have self dot all
381:09 - Sprites this one is going to be at least
381:12 - for now pygame dot Sprite dot group a
381:16 - basic Sprite group we use to place
381:18 - everything in
381:19 - once I have that I want to create one
381:21 - method that I called build level
381:24 - and in here I want to pass in the grid
381:28 - and I also want to create something else
381:31 - that I called the asset dictionary
381:34 - this as a dictionary I am going to get
381:37 - from the init method when we are
381:40 - creating the level and basically what
381:43 - this one means anytime we are creating
381:45 - the level we are going to need a ton of
381:47 - different graphics
381:49 - and those I really don't want to import
381:51 - every time we are creating a level
381:53 - because we're going to create a level
381:55 - multiple times anytime we are switching
381:59 - we are creating a new instance of the
382:01 - level as a consequence importing more
382:03 - Graphics every single time is going to
382:05 - be a nightmare and really bad for
382:07 - performance
382:08 - to account for that I am also going to
382:10 - pass in a dictionary and this dictionary
382:13 - is going to be quite long so I'm going
382:15 - to put it over multiple lines in here
382:18 - one entry the one entry we are actually
382:20 - going to use is called land and this is
382:23 - going to be self.land tiles this is what
382:27 - we got way earlier inside of imports
382:30 - when we use this for the editor this we
382:33 - can reuse and just place it in here
382:35 - later on we are going to add a lot more
382:38 - in here but for now I just want to have
382:40 - the land this I can now use in here and
382:43 - I have to build the build level method I
382:46 - want to create build level in here we
382:50 - need a grid and we need the assets
382:53 - I guess let me call it asset dictionary
382:56 - to be a bit more consistent also this
382:58 - needs self
383:00 - we need to first of all get all of the
383:02 - different layers for reference inside of
383:05 - the editor what we are getting if I
383:08 - create grid we have to cycle through all
383:11 - of the layers of this dictionary which
383:13 - means I want to have for layer name and
383:18 - layer in Grid dot items
383:23 - inside of each layer we have more
383:25 - information we have the position and we
383:28 - have the data in layer dot items as well
383:33 - which means this first for Loop goes for
383:36 - the entire dictionary and the second for
383:38 - Loop is looking at every individual
383:40 - dictionary for every layer
383:43 - once I have that I can look for the
383:45 - layer name for example if the layer name
383:48 - is terrain the one we have specified
383:51 - here then I want to place some terrain
383:55 - tiles for that though I'm going to need
383:57 - some kind of vehicle to contain the
383:59 - graphics in my case I'm going to use a
384:02 - Sprite
384:03 - for that I'm going to create a new
384:05 - python file and save it as sprites.pi
384:10 - in here once again I want to import by
384:13 - game and besides that I also want to use
384:16 - vectors as always so let me add it right
384:19 - away
384:20 - in here for now all we need is pi game
384:23 - the first thing I want to do is I want
384:25 - to create a class called generic
384:28 - this one is going to be pygame dot
384:31 - Sprite dot Sprite to create an actual
384:33 - Sprite and inside of here we need an
384:36 - init method for the parameters here
384:39 - obviously we need self besides that we
384:42 - need a position we need a surface and we
384:44 - need the groups
384:46 - once we have all of that we have to do
384:48 - the basic setup the one that we always
384:50 - need for any kind of group I want to
384:52 - call Super init for the group then I
384:55 - have to create self.image this is going
384:58 - to be the surface and then self.rect is
385:00 - going to be
385:01 - self.mage.get underscore rect and I want
385:04 - to place the top left wherever the
385:07 - position is
385:08 - which means this group goes in there
385:11 - this surface goes in there and the
385:15 - position goes in there we are using all
385:18 - of our parameters
385:20 - once we have that I can return to
385:22 - level.pi and in here I have to import
385:25 - from Sprite import generic
385:30 - although I call this one Sprites
385:35 - this I can now use
385:37 - in here I want to create a generic
385:39 - Sprite and let me copy over the
385:42 - parameters we need we have position
385:44 - surface and group those three
385:47 - number one we need a position this
385:50 - position we already have that is the key
385:53 - for the layer items dictionary
385:56 - meaning this one is quite simple
385:58 - the next thing we need is the group or
386:00 - the next easy thing we need is the group
386:02 - because we only have one group here and
386:04 - this is all Sprites
386:06 - finally we need a surface and this is
386:10 - going to be your exercise figure out
386:13 - where you can get this surface from and
386:16 - well it shouldn't be too difficult
386:18 - just look at what parameters we have
386:20 - available and what you have in here
386:23 - all the information you need is
386:24 - available in there so pause the video
386:26 - now and see if we can figure this one
386:28 - out
386:31 - the surface is going to be inside of the
386:35 - asset dictionary meaning I want to use
386:37 - the asset dictionary and in here I want
386:41 - to look at land
386:43 - the reason I want to look at land is
386:45 - because inside of main.pi this is where
386:48 - we are storing the land tiles
386:50 - this by itself is going to be a
386:53 - dictionary as well and the name of this
386:55 - dictionary is going to be the name of
386:57 - the graphic we need
386:58 - which means in here we can pass in data
387:02 - this one here you get the proper tile
387:04 - that we need
387:06 - remember here inside of the inside of
387:09 - editor for terrain here what is inside
387:12 - of this dictionary is going to be first
387:15 - of all the position for the key let's
387:17 - say 128 and 64.
387:20 - this is going to be a tuple for the key
387:23 - and the associated value is going to be
387:25 - a string with the file name that we need
387:28 - this could for example be ABC
387:31 - this ABC we can then use to pick one of
387:34 - the graphics
387:35 - from
387:37 - this land tiles here
387:40 - that is basically all that's going to
387:42 - happen inside of this one
387:44 - which means once I have all of that
387:47 - I can get self dot all Sprites inside of
387:50 - the run method
387:52 - and draw the entire thing on
387:55 - self.display Surface
387:59 - and let's see if this is working
388:02 - the game is still starting and now let
388:05 - me draw a couple of tiles
388:07 - and now if I go to the other part you
388:10 - can see in the top left we have our
388:12 - terrain this is looking really good also
388:15 - I can return back to the editor make
388:17 - some more changes
388:20 - go back to the level and this is looking
388:22 - really good I'm very happy with this
388:25 - also while we are here the red
388:27 - background isn't needed anymore this one
388:30 - we can replace with the color from
388:33 - settings
388:34 - in here we have the sky color
388:37 - that is going to make the entire thing
388:38 - look much nicer next up we can start
388:41 - working on the player and for the player
388:44 - we have to look at the objects which
388:46 - means inside of the editor I want to
388:48 - look at the foreground objects
388:51 - I want to inside of this for Loop here
388:56 - use a match case statement and what I
389:01 - want to match is data
389:04 - for example inside of this one case
389:06 - could be zero and this would be the
389:09 - player
389:10 - in another case we could cover here
389:12 - let's say case one
389:15 - this one would be the sky
389:17 - and besides that we could also have for
389:20 - example case four
389:23 - and this would be a gold coin
389:27 - we're going to expand on this quite a
389:28 - bit but for now I only want to work on
389:31 - the player
389:33 - the main thing you have to understand
389:34 - here is that data most of the time
389:36 - refers to the ID of the object we are
389:39 - working with
389:41 - only the terrain and the water are a bit
389:43 - different here but everything else we
389:45 - can cover on the data so with that I
389:48 - want to create a player object and this
389:51 - I also want to store as an attribute
389:53 - meaning self.player is going to be layer
389:57 - this one doesn't exist right now which
390:00 - means inside of Sprites I want to create
390:02 - it
390:03 - I want to have a class for the player
390:06 - and this player has to inherit from
390:08 - generic that way we already cover all of
390:11 - these basic attributes saves me a bit of
390:14 - writing
390:15 - but this one inside of the init method I
390:18 - want to have self I won't have the
390:20 - position and for now all that I need
390:23 - besides that is the group
390:25 - inside of here I can call the super init
390:29 - method and now I have to cover these
390:33 - three parameters here position is super
390:36 - easy because we're getting that from the
390:38 - parameter same is going to happen for
390:40 - the group this one we can just ignore
390:43 - the only thing we have to work with is
390:45 - the surface and this one we don't have
390:48 - right now and for this entire section I
390:50 - am not going to import the player assets
390:52 - as a consequence this is going to be a
390:55 - plain pie game dot surface
390:58 - with a size of let's say 32 by 64 pixels
391:03 - finally after this one to have a
391:05 - slightly different color I want to get
391:07 - self.image and fill this one with a red
391:10 - color
391:12 - now with that
391:14 - back inside of my level besides generic
391:17 - I want to import the player
391:20 - and for this player now I need a
391:22 - position the position I already have and
391:24 - for the group I want to have self dot
391:26 - all Sprites
391:28 - if I run this now and let me draw a
391:30 - Terrain around the player and if I run
391:33 - the entire thing
391:34 - you can see we have the terrain and we
391:36 - have a red rectangle inside of it this
391:38 - is going to become the player later on
391:41 - that is looking really good so now we
391:44 - can add a tiny bit of input for the
391:45 - player to be able to move around
391:48 - all of that is going to happen inside of
391:50 - an input method and here we need self
391:52 - and nothing else
391:54 - we first of all have to get all of the
391:56 - keys that could be pressed this we get
391:58 - with
391:59 - pygame.key.get underscore pressed once
392:02 - we have that I can check if keys and
392:05 - pygame dot k underscore right
392:10 - and let me spell this one properly
392:13 - then I want to do something the same is
392:16 - going to be the case for left and this
392:18 - needs to be an L if statement and
392:21 - finally I want to have an else statement
392:24 - now we can check if the player is
392:26 - pressing right left or neither of the
392:29 - two
392:30 - I do however need some kind of logic to
392:32 - store the movement of the player for
392:35 - that inside of the init method I want to
392:37 - create a section
392:39 - that I called movement
392:42 - in here first of all we need the
392:45 - direction of the player and this I want
392:47 - to be a vector that by default is going
392:50 - to be zero now the shorthand for this
392:52 - Vector we have to import once again
392:54 - which I can do from the editor I want to
392:57 - have this one here
392:59 - we are essentially going to create a
393:02 - vector 2 and I just shortened all of
393:04 - this to Vector to save me some writing
393:06 - this is all that happens in here
393:08 - next up to store the position of the
393:10 - player I want to have a position this
393:13 - one is also going to be a vector
393:15 - although by default this Vector position
393:18 - is going to be self.rect dot top left
393:21 - the last thing we need is a speed and
393:24 - this one I've set to 300 but play around
393:27 - with it it's a fairly subjective value
393:30 - inside of the input when the player is
393:33 - pressing right I want to get self dot
393:35 - Direction
393:36 - [Music]
393:37 - I only care for this one about X and
393:39 - this one I want to set to 1. if the
393:43 - player is pressing left there should be
393:44 - negative one and if the player is
393:47 - pressing neither of the two it should be
393:49 - zero
393:50 - the logic here should be fairly obvious
393:52 - if the player is pressing right the
393:54 - direction should be positive all we need
393:56 - now is some way to implement this
393:59 - direction into actual movement for that
394:01 - we are going to need an update method
394:03 - this one is going to need self and Delta
394:06 - time
394:07 - first of all and here I want to check
394:09 - for the input
394:11 - besides that I want to have self dot
394:14 - move this one is going to actually
394:17 - implement the movement and this one
394:18 - needs Delta time
394:19 - this doesn't exist right now so let me
394:22 - create move with self and Delta time and
394:25 - for now what we did in here is self dot
394:28 - pause plus equal self dot Direction
394:32 - multiplied by self dot speed multiplied
394:36 - by Delta time
394:37 - this position here by the way is needed
394:40 - because while self.speed is an integer
394:43 - Direction and Delta time are not going
394:45 - to be integers as a consequence the
394:48 - value we are getting here is going to be
394:49 - some kind of floating Point number and
394:52 - by default pygame is only going to store
394:54 - integers for rectangles
394:57 - which is going to cause some
394:58 - inconsistent movement but if you store
395:00 - that position inside of a separate
395:02 - variable like a vector then you can
395:04 - store floating Point numbers and once
395:07 - you have that you can set self.rect dot
395:10 - top left
395:12 - to the rounded version of self.post.x
395:17 - and the rounded version of
395:20 - self.post.y okay with that we can go
395:23 - back to the level and in here besides
395:27 - drawing all of this I also want self.ul
395:30 - Sprites dot update
395:32 - and in here we have to pass in Delta
395:35 - time and now if I run this and create
395:38 - some terrain tiles like so
395:41 - I can run the entire thing and now the
395:43 - player can go right and left
395:46 - we can't go up and down but for this I
395:49 - want to have proper jumping logic this
395:51 - is going to come later
395:54 - cool but so far this is working really
395:56 - well with that we have another section
395:59 - covered so for the next part we can
396:01 - flesh out the level a tiny bit more
396:03 - for the next part we can work on the
396:06 - animated tiles this means we're going to
396:08 - create the water and the coins inside of
396:11 - the level both of which are not going to
396:13 - be terribly complicated if you can
396:15 - animate a Sprite so let's Jump Right In
396:18 - and let's have a look
396:19 - once again we are inside of main.pi and
396:23 - first of all I want to work inside of
396:26 - the level
396:27 - in here inside of build level besides
396:31 - the layer name
396:32 - right now we only have terrain I want to
396:34 - do a bit more
396:36 - because the other layer name that we
396:39 - have in here is going to be water
396:43 - so inside of the editor if I check
396:45 - create grid we have water as a reminder
396:48 - here
396:49 - this dictionary is going to consist of a
396:51 - position for the key 128 and 64 as an
396:55 - example and the value Associated is
396:58 - either I think I call this water top or
397:01 - water bottom this is what we are going
397:04 - to look for inside of level I want to
397:07 - check if data is equal to and I just
397:11 - realized this one I called top if that
397:14 - is the case I want to create an animated
397:17 - Sprite
397:19 - however besides that so else we also
397:23 - have the plain water or the water bottom
397:25 - this one is not animated as a
397:28 - consequence I can turn this into a
397:30 - generic Sprite
397:32 - and here once again inside of Sprites I
397:36 - can copy the parameters
397:37 - and we have a position a surface and the
397:40 - groups position is really easy this one
397:43 - we are already getting from here
397:45 - a group is also easy we only have a
397:48 - single group I want to have all Sprites
397:49 - however now we are going to need a
397:52 - surface and this one we don't have right
397:55 - now this one I want to import inside of
397:58 - this inputs here and then pass it inside
398:02 - of this dictionary in the level
398:05 - when we are creating level
398:07 - which means in here we need to import a
398:11 - water tile
398:13 - and then inside of this one we need
398:16 - water with something something with a
398:19 - water surface and to be a bit more
398:21 - specific this one should be water bottom
398:23 - and this could be a really good exercise
398:25 - for you try to figure this one out
398:27 - import the bottom water tile place it
398:30 - inside of this dictionary here and then
398:33 - try to use it to create a generic bottom
398:36 - water tile and see how far you get
398:40 - first of all we have to import the
398:43 - bottom water tile this I want to store
398:45 - in an attribute water bottom in here I
398:50 - just want to load one individual surface
398:53 - for this I can use load although I'm not
398:56 - sure if I have it available I do I'm
398:57 - using it here so we can use just load
399:00 - instead of pygame.image.load
399:02 - for the folder pattern here I want to go
399:05 - up on folder then to Graphics then to
399:08 - Terrain in there we have water and there
399:13 - we have water bottom dot PNG
399:16 - like so and this should be spelled like
399:19 - this
399:20 - also important here I want to convert
399:24 - Alpha all of this to improve performance
399:28 - now that we have that
399:30 - inside of the dictionary that we pass
399:32 - into the level I can create a water
399:35 - bottom key and the value Associated is
399:39 - going to be water bottom
399:41 - this I can now use inside of the level
399:43 - inside of asset dictionary we have the
399:46 - entire dictionary available
399:47 - this I want to use for the surface which
399:50 - means acid dictionary
399:52 - in here I want to get water
399:58 - like so and now I can add pass in here
400:01 - for the top part of the water
400:04 - and run main.pi and we are getting a
400:08 - syntax error
400:10 - because you've probably seen it I forgot
400:14 - a comma
400:16 - now if I run this again this is looking
400:18 - pretty good let me Place some terrain
400:20 - tiles and now some water tiles remember
400:23 - for now we are only going to be able to
400:25 - see the bottom water tiles
400:27 - or at least I hope we will and this is
400:30 - looking really good we have bottom water
400:32 - tiles
400:34 - that is going to cover one easy bit
400:36 - so now we can start working on the
400:38 - actually animated tiles
400:40 - and for that first of all we are going
400:42 - to need a list of water surfaces
400:45 - this I can do right away let's call this
400:48 - one the water top
400:51 - animation
400:53 - this I can just import SE
400:57 - holder and in here the folder path is
401:00 - going to be one folder up then we have
401:03 - Graphics then we have terrain and in
401:06 - here we have water and animation
401:09 - this once again I want to place inside
401:12 - of the dictionary and this one I called
401:14 - water top
401:17 - this is going to be self dot water top
401:19 - animation and this should be all we need
401:22 - for this part now inside of level
401:25 - in here I want to create an animated
401:28 - Sprite
401:30 - this one is going to need some assets
401:34 - I want to have a position I want to have
401:36 - a group
401:37 - these are the things we are going to
401:39 - need and I guess while we're here we can
401:41 - pass in the proper arguments right away
401:43 - the position we already have this is
401:46 - what we're getting from here the group
401:48 - is also easy we still only have a single
401:50 - group
401:51 - assets you should be familiar with this
401:54 - at this point we need the asset
401:56 - dictionary and in here I want to have
401:59 - water top
402:00 - that is what I imported just a second
402:03 - ago this bit here
402:05 - finally after generic I want to have an
402:08 - animated Sprite
402:11 - this I can now create below generic I
402:15 - want to have class animated
402:18 - this one also has to inherit from
402:20 - generic
402:22 - 4D init method we are going to need self
402:25 - as always then we need assets then we
402:29 - need a position and then we need a group
402:32 - and for the animation in here we need
402:34 - first of all the animation frames which
402:37 - I want to have as an attribute this is
402:40 - just going to be the assets
402:42 - besides that I want to have self dot
402:44 - frame
402:45 - index which by default is going to be
402:48 - zero and essentially what's going to
402:50 - happen is that we are using this Frame
402:52 - index to pick one surface from this list
402:56 - although first of all we have to call
402:58 - this super thunder in it method and in
403:02 - here we need to have the arguments for
403:04 - the generic class
403:07 - although it's quite simple position we
403:10 - already have this is what we're getting
403:11 - from here and the group we are also
403:13 - getting from there all we have to do is
403:15 - to convert this animation frames and
403:19 - pick one surface from there to get
403:21 - started
403:23 - and this could be a good exercise for
403:25 - you to see if you understand what is
403:27 - going to happen here
403:28 - use the frame index to pick one surface
403:32 - from the animation frames and pass them
403:34 - into the parent class and see if we can
403:36 - figure this one out
403:40 - this one honestly should be really
403:42 - simple we need self.animation frames and
403:45 - this is a list with surfaces which means
403:48 - in here we can get self dot frame index
403:52 - and this right now would pick the first
403:54 - surface from this list that is going to
403:58 - give us one Sprite Which means now
404:00 - inside of the level this one here sorry
404:03 - this one here should actually work let
404:06 - me get rid of the comment
404:08 - and let's actually try
404:10 - if I run the entire thing I can create
404:12 - some terrain again for reference and now
404:15 - I can place some water
404:18 - like so and let me run the entire thing
404:21 - and we're getting an error
404:24 - that error happens inside of here that
404:26 - we have list index out of range which is
404:30 - a very common error what it basically
404:32 - means is that inside of this animation
404:35 - frames we don't have any items
404:37 - let me actually demonstrate if I print
404:40 - self.animation frames
404:42 - and I run main.pi again and I am drawing
404:46 - some water tiles
404:49 - you can see that what we've imported is
404:51 - an empty list the reason for that
404:54 - most likely is that I messed up the
404:57 - folder path here and I can already see
404:59 - that Graphics is misspelled
405:03 - the rest looks pretty good though if I
405:06 - run the entire thing with this fix and
405:08 - play some tiles again and now I can play
405:10 - some water
405:12 - you can now see we have the water on top
405:15 - of that you can see now we have a list
405:18 - with all of the surfaces one for each
405:20 - Sprite that we are going to create
405:22 - although I don't actually want to do
405:24 - that
405:25 - although you can probably already tell
405:27 - this thing is not animated for that I
405:30 - want to have an animate method in here
405:32 - we need self and Delta time this I also
405:36 - want to call inside of an update method
405:38 - in here we also need self and Delta time
405:41 - and I want to call Self dot animate with
405:45 - Delta time
405:46 - all we have to do in here is we have to
405:48 - get self.frame index and add the
405:52 - animation speed this is what we're
405:55 - getting from the settings all the way at
405:57 - the top here we have animation speed
405:59 - this is what I'm going to use in here
406:02 - this I have to multiply with Delta time
406:04 - to be frame rate independent
406:06 - and this I want to now use with
406:08 - self.image and I want to get self Dodge
406:12 - animation frames
406:14 - and I want to have self dot frame index
406:19 - essentially what we're doing here
406:21 - self.frame index is going to become a
406:23 - larger and larger number and this larger
406:25 - larger number we're using in here to
406:28 - pick other animation frames for the
406:30 - water tiles although there are going to
406:33 - be two problems problem number one is
406:37 - that self dot frame index is a loading
406:42 - point number
406:43 - and we cannot use 30 point numbers for
406:46 - indexing so this we have to fix
406:48 - besides that self Dot
406:51 - frame index is going to be two large
406:56 - very fast
406:58 - the way you have to think about it for
407:00 - the water frames we have three surfaces
407:04 - as a consequence we could only use very
407:06 - small numbers for the indexing 0 1 or 2.
407:10 - if we have a number larger than that
407:12 - we're going to get an error the problem
407:14 - is frame index is going to be quite fast
407:17 - much larger than that so this is what we
407:20 - have to account for and this is going to
407:23 - be your exercise see if you can figure
407:26 - this one out and again if you know
407:28 - animations this shouldn't be too
407:29 - difficult
407:33 - first of all this part here is really
407:36 - easy all we have to do is this
407:38 - self.frame index we need to convert to
407:41 - an integer that way we can always use it
407:44 - for proper indexing
407:46 - besides that let me get rid of this
407:49 - first part we have to make sure
407:51 - self.frame index is never getting too
407:54 - large
407:56 - this I want to do on a separate line of
407:57 - code in here I want to get self.frame
408:00 - index
408:01 - is going to be zero but only if self dot
408:06 - frame index is greater or equal than the
408:10 - length of self dot animation
408:13 - frames
408:15 - which means if this cell.frame index
408:17 - becomes a number so large that we will
408:19 - get an error here for the indexing we
408:22 - are setting this number back to zero
408:24 - however if that is not the case so else
408:26 - I just want to keep self.frame index s
408:29 - cell dot frame index so no change
408:32 - and with that we have the second part of
408:34 - the exercise
408:36 - since we already call update inside of
408:39 - the level on all of these Sprites
408:41 - there's not much else we have to do
408:43 - which means I can now call main.pi and
408:46 - draw some terrain tiles once again and
408:49 - now some water tiles
408:51 - and let me run the entire thing and we
408:54 - are crashing because animation speed is
408:56 - not defined
408:58 - this happens because inside of here
409:01 - we're not importing settings which means
409:04 - from settings import everything
409:08 - let's try this again now some terrain
409:10 - and some water
409:12 - enough around this this is looking much
409:15 - better and you can see all the way in
409:16 - the top we have some water animations
409:20 - I guess I could make this a bit more
409:22 - visible if I add the water down here and
409:27 - here you can make this look very silly
409:30 - if you really wanted to
409:32 - like so and well there we have animated
409:35 - water
409:38 - now that we have that we can use this
409:41 - animated class for the coins as well
409:43 - it's not actually that much of a change
409:46 - for that though I have to import some
409:49 - more Graphics this is going to happen
409:51 - inside of main inside of imports once
409:53 - again
409:54 - let me actually add some comments here
409:57 - to make this a bit clearer this one is
409:58 - going to be the coins and this one is
410:01 - going to be the terrain
410:04 - for the coins I want to have self.gold
410:08 - self.silver
410:10 - self dot diamond
410:13 - all three of those are going to be
410:16 - import folder and the folder path for
410:19 - all three of them is going to be fairly
410:20 - similar we have to go one fold up then
410:23 - we have Graphics inside of there we have
410:25 - items
410:26 - and then here we have gold
410:29 - we have silver and we have a diamond
410:33 - I suppose I should probably show all of
410:35 - this a bit more visually
410:38 - here is the folder that I can make it
410:40 - tiny bit smaller
410:43 - we have Graphics inside of there we have
410:47 - the items inside of there we have
410:50 - diamond gold and particle I'll talk
410:53 - about this one in a second but the
410:55 - folder path here is what we need so
410:57 - Graphics items and then diamond gold or
411:00 - silver for now
411:01 - this we now have to get into the level
411:04 - which happens inside of this or rather
411:07 - this dictionary here which means in here
411:10 - I want to have gold
411:12 - this is going to be self dot gold
411:16 - like so
411:18 - I can copy this two times I want to have
411:21 - silver and I want to have a diamond
411:25 - and this is looking pretty good
411:28 - with that inside of the level I have to
411:32 - figure out when I have any of these
411:35 - coins this is going to happen inside of
411:37 - this match data because in here I know
411:41 - case 4 is going to be gold
411:44 - case 5 is going to be
411:47 - silver and case 6 is going to be a
411:52 - diamond
411:53 - I know this from settings we have 4 5
411:56 - and 6 for Gold Silver and diamond
412:00 - all three of those though are going to
412:02 - get the same class
412:04 - I want to have a coin glass
412:07 - in here like for the animated class I
412:10 - want to have assets I want to have a
412:12 - position and I want to have groups
412:15 - spelled properly
412:17 - now once again we know the groups
412:19 - already we want self.all Sprites this
412:22 - one doesn't change
412:23 - besides that for the assets we know this
412:26 - one already we have the asset dictionary
412:28 - and in here we either want gold
412:33 - we want to have silver or we want to
412:36 - have a diamond
412:38 - there is one more thing I do want to add
412:41 - in here all the way at the beginning I
412:43 - want to have something like a coin type
412:45 - this could be gold this would be silver
412:49 - this would be a diamond that way later
412:53 - on I can identify what kind of coin the
412:55 - player collided with
412:57 - although for this tutorial I'm not going
412:59 - to use it it's just if you want to
413:01 - expand it yourself
413:02 - now we have to actually create a coin
413:06 - and let me import it right away so
413:08 - inside of Sprites below animated I want
413:11 - to have glass coin
413:14 - this one since we do want to have an
413:16 - animated Sprite it has to inherit from
413:18 - animated
413:20 - which means inside of the init method
413:23 - we first of all have to use all of the
413:27 - arguments we used here
413:29 - let me copy them actually we first of
413:31 - all want to have some kind of coin type
413:35 - then we need
413:36 - assets the position can stay as it is
413:39 - and finally we have a group
413:42 - all of this now we have to pass into the
413:46 - parent class with super init on the
413:49 - parent class we have assets position and
413:52 - group these I want to pass in here
413:54 - and I think you can tell this is going
413:56 - to be quite easy because these
413:59 - parameters are identical so we don't
414:01 - have to do anything
414:02 - the one thing that we do have to do
414:04 - though is store this coin type here as
414:07 - an attribute which means sales.coin type
414:10 - is going to be coin type
414:12 - however there is going to be one issue
414:15 - although you're going to see in a second
414:17 - what I mean for now though this is
414:20 - looking pretty good
414:21 - which means I can run main.pi again let
414:24 - me play some terrain and now I want to
414:27 - place one of each type of coin and if I
414:30 - now run this we are getting an error
414:33 - that coin.net takes four position
414:35 - arguments but five were given
414:39 - which means I forgot the self in here
414:43 - now if I run this again do the same
414:45 - thing let's Place one of each coin and
414:49 - let's try this now and there we go we
414:52 - have the animations for each coin
414:54 - although I hope you can see the problem
414:56 - in there because all of the coins are a
415:00 - bit off center if this one here is the
415:03 - grid
415:04 - you can see this looks weird there
415:06 - should ideally all be on one straight
415:08 - line and they all look a bit weird right
415:10 - now
415:13 - the reason for that is once again
415:17 - if I have a bit more space here
415:20 - in our game we have 64 by 64 tiles so 64
415:25 - by 64. and all of the coins are smaller
415:28 - than that as a consequence Pi game is
415:31 - going to place them in the top left and
415:33 - we're going to have some weird
415:34 - positioning
415:36 - this we can fix quite easily though all
415:38 - I want is self.rect
415:40 - is going to be self dot image and get
415:43 - underscore rect and now this Center
415:47 - should be the position
415:49 - this is working because when we exported
415:52 - the position for the coins inside of the
415:55 - editor I hope I find it
415:57 - for the coins we added half of the tile
416:00 - size for x and half of the tile size for
416:03 - y that way we're placing the coin in the
416:05 - middle of this tile
416:07 - and this we can use in here
416:10 - earlier on inside of generic for all of
416:13 - the other Sprites so far we always place
416:15 - the top left which is not what I want to
416:17 - do for the coins
416:19 - but this should now fix the entire thing
416:22 - let me Place stuff again let's do a few
416:25 - more coins actually
416:27 - and if I run the entire thing this is
416:29 - looking much better
416:34 - cool so with that we have some coins
416:37 - now all of this is a good start but we
416:40 - can't actually do anything with the
416:41 - coins so let's work on that it's not
416:44 - that complicated
416:46 - inside of the level
416:48 - I want to create another group this one
416:52 - I called self.coin
416:54 - Sprites
416:55 - this one once again is just going to be
416:58 - another group
416:59 - I can just copy this one and minimize
417:01 - the edit method
417:03 - and now every time I am creating a coin
417:06 - I want to have all of the coins inside
417:09 - of both old Sprites
417:12 - and inside of self.coin Sprites
417:16 - that way I can Target them easily
417:19 - and this I can use inside of another
417:21 - method let's call it get points
417:25 - in human itself and nothing else and all
417:29 - I really have to do in here
417:31 - I have to get the collided
417:34 - points and this I get with pygame DOT
417:37 - Sprite dot Sprite or light
417:41 - I forgot the assignment operator and
417:45 - then here once again we need a Sprite we
417:47 - need a group and we need new kill the
417:51 - Sprite is going to be self dot layer the
417:54 - group is going to be coin Sprites
417:57 - and do kill I want to set to true
418:00 - because I do want to get rid of the coin
418:03 - and with that inside of the event Loop
418:06 - let me clean this one up a tiny bit more
418:09 - we essentially have an update part and
418:13 - we have a drawing part inside of the
418:16 - update part I want to call self and get
418:19 - coins
418:20 - if I run this now
418:22 - and I do have to be careful here because
418:25 - the player can only move left and right
418:28 - so I'm going to place the coins to the
418:31 - right if I run this now and the player
418:33 - moves to the right the coins disappear
418:36 - that's a good start
418:38 - although
418:40 - it's not exactly an exciting thing here
418:44 - for that I want to create a particle
418:46 - effect every time the player collects a
418:48 - coin
418:49 - which means after running all of this
418:52 - I want to or Sprite in collided coins
418:57 - I want to create a particle effect
419:01 - and this particle effect is going to be
419:03 - kind of like the animated Sprites except
419:05 - it's only going to play one animation
419:07 - and then destroy itself although and
419:10 - here once again we need assets we need a
419:12 - position and we need a group
419:16 - also this one we do have to import so
419:19 - besides animated I also want to have a
419:22 - particle
419:24 - or this one let's cover a couple of the
419:27 - arguments first position is the easiest
419:30 - one because in here I want to have
419:32 - Sprite Dot rect.center
419:36 - I'm going to place this particle in the
419:38 - same Center where we add the coins we
419:41 - just collided with
419:43 - for the group I want to have
419:44 - self.allsprites that is all we are going
419:46 - to need
419:47 - next up we are going to need the assets
419:51 - this I first of all want to import
419:52 - inside of main.pi
419:56 - inside of the coin section in here I
419:59 - have self dot particle
420:01 - this is what you have seen just a second
420:04 - ago inside of the items folder I also
420:07 - have particle
420:10 - let me open this one once again we have
420:13 - particle and inside of that we have a
420:15 - simple particle effect it's nothing
420:17 - particularly fancy
420:19 - this I now have to get into the level
420:22 - which I do with the asset dictionary in
420:25 - here I want to have particle and this I
420:29 - get with self Dodge particle
420:31 - now with that inside of the level we
420:35 - have something available although the
420:37 - problem is this get coins doesn't have
420:40 - access to this as a dictionary
420:43 - we have to figure out something else in
420:46 - my case I added another section
420:50 - that I called
420:53 - additional stuff
420:57 - not the greatest name but it gets the
421:00 - job done and yeah I want to have
421:01 - particle surfaces and this I get with
421:05 - the asset dictionary and what I want in
421:08 - here is the partic hilts I think I
421:10 - called it
421:11 - I actually just called it particle so
421:14 - self dot particle and with that I have
421:17 - some particle surfaces that I can pass
421:20 - in here for the assets
421:22 - now what we actually have to do is to
421:25 - create this particle class this once
421:28 - again is going to happen inside of the
421:30 - Sprites
421:31 - let's do it on top of the coins I want
421:34 - to have class particle
421:37 - this one I also want to inherit from
421:39 - animated
421:40 - and for the init method we know we need
421:45 - self we need the assets we need a
421:47 - position and we need a group
421:50 - and the first thing I want to do in here
421:52 - is called the super Thunder init method
421:55 - and pass in the assets the position and
421:58 - the group once again this and this thing
422:01 - is identical so we essentially are just
422:03 - creating an animated class
422:06 - although once again we have to account
422:08 - for the position which I can copy from
422:11 - here and we are good to go
422:13 - if we didn't add this line here the
422:16 - position of the particle would be
422:17 - slightly offset from the coin which I'm
422:20 - trying to avoid
422:21 - besides that we have to overwrite the
422:24 - animate method although we also need
422:27 - self and delta type the problem here is
422:29 - inside of animated
422:32 - this animate is designed to run forever
422:36 - but for the particle I only want to play
422:38 - the animation once and then destroy the
422:40 - object so we have to create a different
422:43 - kind of animate method this one could
422:45 - actually be a really interesting
422:47 - exercise for you
422:49 - write to write an animate method that
422:51 - only animates over all of the surfaces
422:54 - once and if we are beyond that we are
422:56 - going to destroy the entire object so
423:00 - pause the view now and try to figure
423:02 - this one out
423:06 - once again I want to have self.frame
423:09 - index plus equal animation speed
423:11 - multiplied by Delta time this part
423:14 - doesn't change but now I want to add an
423:17 - if statement that if self dot frame
423:20 - index
423:21 - is smaller than the length of self dot
423:24 - animation frames
423:26 - only if that is the case I want to
423:28 - update self.image with self dot
423:32 - animation frames and now in here I need
423:35 - the integer of self dot frame index
423:39 - so far we have kind of covered the first
423:42 - two lines of the first animation
423:43 - although this animation would simply
423:45 - stop once we reach the end of the
423:47 - animation which in our case means I want
423:50 - to have an else statement and I want to
423:53 - destroy with the kill method the entire
423:56 - object
423:57 - and with that I am good to go if I now
424:01 - run main.pi and I can place a gold coin
424:04 - and run the entire thing
424:09 - and if I now get over the coin you can
424:12 - see an animation this one worked really
424:14 - well
424:15 - which means we have a working particle
424:19 - on top of that what you could be doing
424:22 - in here is if
424:24 - Sprite dot coin type is equal to for
424:29 - example gold
424:31 - then we could I know I could print gold
424:34 - in this case and let me run the entire
424:36 - thing again place a couple of gold coins
424:39 - run it
424:41 - and now I'm getting gold and this
424:44 - information you can use to do well
424:45 - whatever you want in my case though I
424:48 - don't really care about it and I want to
424:50 - keep the entire thing a bit more
424:52 - streamlined this video is already
424:54 - getting really long
424:55 - so with that we have the coin logic
424:59 - and I can minimize a bunch of things and
425:02 - this is covering another major section
425:06 - for the next part now that we have some
425:08 - basic system to place things we can
425:10 - place all of the remaining objects
425:13 - and well let's Jump Right In most of
425:16 - this is not going to be too difficult we
425:18 - just have to create a few more classes
425:21 - once more we are inside of main.pi and I
425:24 - want to keep on working inside of the
425:26 - level specifically inside of build level
425:30 - because in here I want to have a few
425:33 - more cases
425:34 - quite a few of those are going to be
425:36 - fairly simple for example for case 11
425:40 - I want to have another animated Sprite
425:44 - and this one is going to be for the
425:47 - small foreground palm tree
425:49 - let me type it in here small Palm
425:52 - foreground
425:54 - although this is just going to be an
425:56 - animation it doesn't do anything else
425:59 - so the class we already have we can just
426:01 - reuse and in here we need assets we need
426:05 - a position and we need a group once
426:07 - again the group is going to be self dot
426:10 - or Sprites the position we also have
426:13 - this is the one we have used up here and
426:16 - this we don't have to change
426:18 - the only problem we have is we are going
426:21 - to need some assets
426:23 - and this once again is going to happen
426:25 - inside of magnet Pi inside of imports
426:29 - in here I want to have another section
426:31 - that I called Palm Breeze
426:35 - in here we do have a bit of a problem
426:38 - now let me illustrate what I want to
426:41 - avoid
426:43 - here's the project folder I can go to
426:45 - graphics and inside of there we have
426:48 - terrain and we have palm trees in here
426:52 - we have a bunch of different folders and
426:54 - all of them contain some animation for
426:56 - palm tree
426:58 - my issue is I don't want to type the
427:01 - import for every single one of these
427:03 - folders which would be kind of annoying
427:06 - to do
427:06 - as a consequence I am going to store all
427:09 - of them inside of self dot Pawns
427:13 - and now we are going to use dictionary
427:16 - comprehension to import all of them what
427:19 - this is going to mean I want to have a
427:21 - folder as the key and inside of the
427:24 - folder I want to have import folder the
427:28 - function we already created
427:30 - and inside of the app we need a path and
427:33 - this path is going to be to all of the
427:36 - folders which is inside of Graphics
427:38 - inside of terrain inside of palm and
427:42 - then I want to look at the folder
427:44 - although this one has to be a variable
427:47 - and I should spell this properly as well
427:50 - this I want to do for folder in all of
427:54 - the folders my problem now is how do I
427:58 - get all of the folders
428:00 - I hope the rest of the logic here makes
428:03 - sense though
428:04 - all we're really doing we are importing
428:07 - a folder and for that folder we need a
428:10 - specific kind of path this we are
428:12 - getting from here the path to the main
428:14 - folder is always going to be the same
428:16 - but inside of that folder I want to look
428:19 - at every folder that exists inside of
428:22 - that folder
428:23 - which means here is the graphic folder
428:27 - and we are going inside of terrain and
428:29 - inside of palm every single folder is
428:32 - going to be the name of one of these
428:34 - folders this is what I want to get
428:36 - or rather this is what I'm trying to get
428:39 - here
428:40 - and that is information I am getting
428:43 - from walk although right now I don't
428:46 - have work available
428:48 - but that I can change quite easily I
428:50 - want from OS import walk
428:53 - if you remember from way earlier when we
428:56 - did all of the import folder this one
428:59 - here import folder addict and import
429:01 - folder we have used walk there as well
429:03 - so it shouldn't be entirely new
429:06 - inside of work I need a file path
429:09 - that is going to be the same file path I
429:12 - have used here
429:13 - let me copy it and paste it in here and
429:16 - this is going to give me way too much
429:19 - information
429:21 - also by default I can only use this in
429:23 - the for Loop so I have to convert this
429:25 - to a list
429:27 - and this is probably going to be really
429:30 - confusing so I'm going to cut all of
429:32 - this out comment out the entire line and
429:35 - just print what we're getting from this
429:38 - if I run this
429:39 - you can see we have a long list with
429:42 - information
429:44 - all I really care about is the first
429:46 - item in here that is this bit
429:50 - because what this one is telling me as a
429:52 - reminder when we are using work we are
429:55 - getting three bits of information and
429:58 - that is the name of the folder then we
430:01 - get all of the subfolders and then we
430:03 - get all of the actual files besides
430:05 - folders inside of this folder all I
430:09 - really care about is this list here
430:11 - everything else I can get rid of
430:14 - entirely
430:16 - so how can I get this bit then and this
430:20 - is actually quite easy I only care here
430:22 - about the first element so if I run this
430:25 - again
430:25 - and close the game now I'm only getting
430:28 - the first item returned and on this I
430:31 - can run indexing again I only care about
430:34 - item number one
430:35 - which means indexing here again with one
430:39 - I now get a list with all of the folder
430:43 - names
430:45 - and this is what I want to use inside of
430:48 - my dictionary comprehension
430:51 - I can uncomment this and paste what we
430:53 - have just created in here and now we are
430:58 - good to go once again if you have a
431:01 - large enough monitor this is going to be
431:03 - much easier to work with
431:05 - once we have this I'm going to print
431:07 - self dot this should be homes I am
431:12 - definitely getting worse at typing like
431:15 - so if I run this now
431:17 - we didn't get an arrow and this is
431:19 - looking pretty good for example now we
431:21 - get large background and this is a list
431:24 - of a bunch of surfaces and this we can
431:27 - use
431:28 - I hope this line here makes sense
431:30 - honestly it's not that complicated
431:32 - although you do have to look at it for a
431:34 - couple of seconds but then it should be
431:36 - fairly straightforward
431:37 - all right this I now want to get into my
431:40 - level which means inside of switch
431:43 - I want to have
431:45 - all of the poems and this is going to be
431:49 - self dot ohms
431:52 - now this I can use inside of the level
431:54 - to get the assets here
431:57 - I want to have the asset dictionary and
432:00 - inside of there
432:02 - we have the Palms which is going to give
432:05 - us another dictionary on this dictionary
432:08 - I want to use indexing again for example
432:11 - this pointer here number 11 is going to
432:14 - be
432:16 - the small foreground and this one needs
432:21 - to be a string
432:22 - once I have that we should be good to go
432:24 - let me try it actually if I now place a
432:27 - small palm tree run the entire thing we
432:30 - are getting a key error
432:31 - this happens inside of the level and I
432:35 - think the problem here is this key is
432:37 - Palms while I used Pawn
432:40 - now if I run this and place a palm tree
432:42 - and go to the level you can see we have
432:46 - one palm tree
432:48 - this is looking pretty good
432:51 - what we have to do now I can get rid of
432:53 - this comment and duplicate this thing a
432:57 - few more times because now we have 12 13
433:00 - 14 15 16 17 and 18. those are
433:07 - respectively we have the large
433:09 - foreground
433:11 - we have left foreground we have right
433:14 - foreground and then we basically have
433:17 - the same thing except for the background
433:19 - so we have small background we have
433:22 - large background then we have left
433:27 - background
433:28 - and finally we have right background all
433:31 - of those are just going to be animated
433:34 - Sprites that don't do anything else
433:36 - meaning now I can try all of this and
433:39 - place a bunch of palm trees to make sure
433:43 - I can work with all of them
433:46 - so I want to try the alternative ones
433:48 - like so and now let's try this
433:52 - and there we go we have all of the palm
433:54 - trees this looks really good
433:57 - later on we are going to add a few more
433:59 - things in here but for the basics this
434:02 - is literally all we need
434:04 - and I suppose I could add a couple of
434:07 - comments here this is going to be the
434:09 - palm trees
434:11 - and this part is going to be the coins
434:17 - the one thing we have to do now is to
434:19 - get the enemies
434:21 - the enemies are going to be a larger
434:23 - topic so I am just going to place some
434:26 - basic Sprites here that show us that we
434:28 - have an enemy
434:29 - but for those we have case seven
434:33 - we have the spikes
434:36 - then we have case eight this is going to
434:39 - be tooth that's the name of the enemy
434:41 - that's the walking one and this should
434:43 - be an eight and then we have case nine
434:47 - this is going to be the shell
434:51 - pointing left and this I can duplicate
434:54 - because now we have the shell pointing
434:56 - right
434:57 - these are the four cases we now have to
435:00 - account for the easiest one in here is
435:02 - spikes because this one is well not that
435:05 - complicated at all although I still want
435:07 - to place it in a separate Sprite class
435:09 - so I can work with it and the rest I can
435:12 - comment out so we're not going to get an
435:14 - error now for the spikes in here we
435:19 - don't need very much we need once again
435:21 - some assets we need a position and we
435:25 - need the groups
435:27 - position once again it's a really easy
435:29 - bit we don't have to worry about it
435:31 - for the groups I want to have two groups
435:34 - here I want to have self dot all Sprites
435:36 - and besides that I want to have another
435:39 - group that I called damage Sprites
435:42 - these are all of the Sprites that if the
435:45 - player collides with them the player is
435:46 - going to get damaged this doesn't exist
435:49 - right now
435:50 - but that we can change quite easily
435:52 - inside of the init method I want to have
435:55 - self.damaged Sprites and this is going
435:57 - to be pygam.spright dot group
436:01 - and now we have the same issue again we
436:04 - need to get the assets for the spikes
436:06 - this is going to happen inside of
436:08 - main.pi in here in the import I want to
436:12 - have the enemies
436:14 - the spikes here are going to be really
436:16 - simple because we have self.spikes and
436:19 - this is literally going to be a single
436:21 - surface so we can just use load and the
436:23 - file path is going to be one folder up
436:25 - then Graphics then we have enemies then
436:29 - we have spikes and inside of there we
436:31 - have spikes.png
436:33 - although don't forget I want to convert
436:37 - Alpha all of this
436:39 - so just to be thorough here we have all
436:42 - of the graphics I want to look at the
436:44 - enemies inside of there we have the
436:46 - spikes and there we have the spikes
436:47 - literally just one surface
436:50 - this I now have to get into the level in
436:53 - here I want to have spikes and this is
436:55 - going to be self dot spikes
436:58 - so with that inside of the level I can
437:00 - get the asset dictionary and I just care
437:04 - about this spikes
437:07 - cool all we have to do now is to
437:09 - actually create the spikes
437:11 - bikes like so and now inside of sprite I
437:16 - am going to add
437:18 - let me put it here I want to have all of
437:20 - the enemies this could actually be a
437:22 - comment enemies
437:24 - and this could be
437:27 - simple animated objects
437:30 - that way we keep the entire code a bit
437:32 - more organized
437:34 - in an actual example you might even want
437:36 - to think about separating all of this
437:38 - into multiple files for example the
437:40 - player could be its own file the enemies
437:42 - could be their own file and so on but in
437:44 - my case I think this is still fine
437:47 - I want to now create the spikes this one
437:51 - since there's no animation this can just
437:53 - inherit from generic and we don't have
437:57 - to do very much I want to create an init
438:00 - method in here we have self
438:02 - we have a surface we have a position and
438:05 - we have a group this is what we have
438:08 - done here we have a surface position and
438:12 - the groups
438:13 - those we now have to pass into the
438:16 - parent class with super and init
438:20 - and the generic class has position
438:23 - surface and group
438:26 - I can just pass them in here and we are
438:28 - good to go at least for now spikes is
438:31 - just going to be a copy of generic but
438:34 - later on we're going to add a tiny bit
438:36 - more to make this class better for the
438:38 - Collision I am basically going to add a
438:40 - mask but that's a fairly simple thing to
438:42 - add
438:43 - although now inside of level I am
438:46 - already importing the spikes so this
438:48 - should be working
438:50 - now inside of main let me add some
438:53 - terrain and some spikes I can place them
438:56 - anywhere I want actually let's do it
438:58 - like this
438:59 - if I run this now this is looking like
439:01 - we have some enemies
439:03 - very happy with that so that's one part
439:05 - covered
439:07 - next up we can work on tooth
439:10 - this once again is going to be another
439:13 - class
439:14 - and in here we need the assets again
439:18 - that we don't have yet then I want to
439:21 - have a position and then I'm going to
439:24 - need some groups
439:27 - position we have seen multiple times by
439:29 - now although for the groups I want to
439:31 - have the same groups I had for the
439:34 - spikes
439:35 - like so
439:37 - which means if the player is touching
439:40 - tooth the player should get hurt
439:43 - the last thing we have to figure out now
439:44 - is the assets and the same pattern we
439:49 - have already seen is going to follow
439:50 - here I want to have the asset dictionary
439:52 - and then here I have two although this
439:55 - one is going to be a bit more
439:57 - comprehensive than the spikes let me
440:00 - demonstrate actually here we have the
440:01 - folder with all of the graphics inside
440:03 - of there we have tooth and tooth has
440:05 - three different animations we have idle
440:08 - this one's quite long then we have run
440:10 - left and we have run right
440:13 - all of this we have to import
440:16 - this is going to be kind of similar
440:18 - compared to the palm trees
440:20 - which means in here
440:22 - self dot tooth
440:25 - is going to be something that looks
440:27 - somewhat comparable to this line here
440:31 - and to see if you understood that line
440:33 - this could actually be a really fun
440:34 - exercise import all the
440:38 - surfaces
440:40 - images
440:41 - from the file path that you need here is
440:45 - going to be let me copy it really quick
440:48 - this is the folder path you are going to
440:50 - need one folder up Graphics enemies and
440:54 - two
440:54 - and specifically what I want you guys to
440:56 - do is to create a dictionary for
440:59 - self.tooth and every subfolder inside of
441:02 - this folder is going to be the key and
441:05 - then the value is going to be all of the
441:07 - images inside of that subfolder so pause
441:10 - the video now and try to figure this one
441:12 - out should look very similar compared to
441:14 - this
441:18 - since all of this is going to be kind of
441:20 - similar I can just copy the entire bit
441:23 - and paste it in here
441:26 - and well mostly what we have to do is
441:29 - change some names in here
441:32 - most importantly I want to go to
441:34 - Graphics then enemies and inside of
441:36 - there I have two
441:38 - this I have to do for both of the
441:41 - folders so we have one here and we have
441:43 - one here
441:45 - the rest however can remain basically
441:48 - identical which means if I now print
441:52 - self.tooth not toggle move let's see
441:56 - what we get
441:58 - this is looking pretty good we get one
442:01 - key with idle this one has a bunch of
442:04 - surfaces then we have run left and we
442:07 - have run right I'm pretty happy with
442:09 - this
442:10 - and once again this we have to add to
442:12 - the level via the dictionary this is
442:15 - going to be tooth and then here self dot
442:18 - Doof
442:20 - which means now this one should be
442:21 - working so all we have to do is to
442:24 - create this class here
442:27 - and while we add it I want to import it
442:29 - as well so tooth in here
442:31 - and now inside of Sprites we can create
442:33 - tooth
442:35 - class two
442:38 - and just like the player TUF is going to
442:40 - inherit from generic
442:43 - in here as always we need a Dunder init
442:46 - method that needs self the assets the
442:49 - position and the group
442:52 - this is what we have done in here we
442:55 - have assets position and group
442:58 - should be fairly straightforward at this
443:00 - point
443:01 - and at some point in here we have to
443:03 - call Super init
443:05 - and the arguments we need here are for
443:08 - generic we need a position surface and
443:11 - group
443:12 - and in here we already have the position
443:14 - and we have the groups so once again all
443:17 - we need is going to be the surface
443:20 - for that this is going to be kind of
443:22 - similar compared to animated
443:24 - I want to have self dots animation
443:27 - frames
443:29 - this is going to be the assets we get
443:31 - and I want to have self dot frame index
443:34 - by default this one is going to be zero
443:36 - this is going to be identical to what we
443:38 - have done in here unfortunately though
443:41 - we couldn't just inherit from animate it
443:44 - because we have to make a few more
443:45 - changes the major issue is that this
443:48 - animation frames is not a list it's a
443:52 - dictionary
443:52 - what we have in here essentially is we
443:55 - have for example idle
443:58 - and inside of there we have the surfaces
444:01 - besides that we had walk left and this
444:05 - one also has a list of surfaces
444:09 - the issue is we have to first identify
444:11 - what our current state is and then we
444:14 - can use indexing to get the surface
444:16 - which means we have to get one more
444:18 - thing
444:19 - which in my case I get with self dot
444:22 - orientation and by default I want to to
444:26 - go in the right direction
444:28 - this I can now use to create a surface
444:31 - this surface is going to be self Dodge
444:33 - animation frames
444:36 - and in here I now want to create an F
444:40 - string that says run underscore and then
444:43 - the orientation
444:46 - remember here the frames could ever be
444:49 - run left or run right
444:51 - idle is essentially only for the editor
444:53 - inside of the actual game tooth is
444:55 - always going to run which means all we
444:58 - really have to change is the orientation
444:59 - to left or right and then tooth is going
445:02 - to run and phase in that direction
445:04 - with this we are getting an actual list
445:06 - and on this list we are getting self dot
445:10 - frame index and now we are good to go
445:13 - this surface we can pass in here which
445:16 - we already have and we should have a
445:18 - basic start let me get rid of this
445:21 - dictionary here and let's try this
445:23 - now I can play stuff as usual and now if
445:27 - I place tooth and some spikes let's see
445:30 - what happens
445:31 - we are getting an error
445:34 - and I can already tell where this is
445:36 - going this should be self dot
445:38 - orientation
445:39 - next attempt let's Place some spikes and
445:45 - proof and now let's try this
445:47 - and there we go we can see tooth doesn't
445:50 - do anything right now but at the very
445:52 - least we have something
445:54 - finally we need case 9 and 10 and both
445:58 - of those are going to be shells so I'm
446:00 - going to cover both of them at the same
446:02 - time
446:03 - which is quite simple because they are
446:05 - both made by the same class the only
446:07 - difference between the two is that one
446:11 - is going to face left so we're going to
446:13 - pass left and here's an argument and the
446:15 - other is going to face right
446:17 - besides that we have the normal
446:19 - arguments we have the assets
446:22 - we have the position and then we'll get
446:24 - a bunch of groups
446:26 - at least for now I only want self dot or
446:29 - Sprites the reason being the player
446:32 - should be able to stand on the shell
446:34 - without being heard as a consequence the
446:36 - shell is not going to be inside of the
446:39 - damaged Sprites
446:40 - which means all we have left is the
446:43 - assets and this we can work on inside of
446:47 - the Imports once again and then here I
446:50 - want to have self and shell like so
446:54 - and for this once again
446:56 - I want to have something that looks like
446:59 - this
447:01 - let me copy it and now we have to work
447:04 - with this import statement here
447:08 - inside of Graphics we have enemies and
447:11 - there we have shell we actually have
447:13 - left gel and we have right shell
447:17 - in our case fortunately we only need one
447:20 - and I'm gonna go with shell left let me
447:23 - show the folder actually
447:25 - here are all of the graphics we have
447:27 - enemies and there we have shell left and
447:29 - shell right if I got shell left we have
447:31 - idle looks like this and we have a tag
447:34 - looks like this
447:36 - and then we have the same thing for
447:38 - right
447:39 - something like this
447:40 - what we can do for the shell is import
447:43 - only shell left and then flip the entire
447:47 - Sprite if we have a right shell that way
447:50 - we don't have to import so much
447:52 - which means now all I have to do is copy
447:55 - all of this here and paste it inside of
447:59 - this one
448:00 - and we should be good to go
448:02 - let me print what we get self.shell just
448:06 - to make sure if I run this
448:08 - we now get attack and we get idle this
448:12 - is all we need
448:13 - so we have to get this into the level
448:16 - once again this happens with shell
448:19 - enter here self dot shell
448:23 - so now inside of the level I can get the
448:26 - asset dictionary once again and this is
448:29 - going to be shell
448:31 - which means now we just have to create
448:33 - the class for this one which is going to
448:36 - be shell
448:37 - and inside of Sprites we have to make
448:40 - the actual class so class shell
448:45 - this one as before is going to inherit
448:47 - from generic and in here we need it init
448:53 - method we need itself we need
448:55 - orientation
448:58 - we need the assets we need a position
449:00 - and we need a group
449:02 - orientation I do want to store as an
449:05 - attribute so self.orientation is going
449:07 - to be orientation
449:10 - besides that I want to have self dot
449:13 - frame animation frames and this is going
449:16 - to be the assets we just passed into
449:20 - although here's one thing that I
449:22 - realized while testing the game once it
449:25 - was finished this you want to copy
449:27 - because we are going to flip all of
449:30 - these assets if the shell is pointing to
449:32 - the right side
449:33 - and if we didn't add copy we would flip
449:36 - all of the assets even for other classes
449:38 - so this copy here is really important
449:42 - otherwise all of your shells are going
449:43 - to point in the direction of the last
449:45 - shell you have used
449:47 - although speaking of I can now check if
449:50 - the orientation is equal to right
449:55 - then we want to flip all of the frames
449:58 - inside of this frames
450:00 - and this could be an exercise for you I
450:03 - want you guys to flip all surfaces
450:05 - inside the animation frames keep in mind
450:09 - here animation frames is a dictionary
450:12 - with key value Pairs and only the values
450:14 - are actual surfaces and those you want
450:16 - to flip
450:18 - so pause the video now and see if we can
450:20 - figure this one out
450:24 - I want to start with four key and value
450:28 - in self dot animation frames and items
450:32 - and here I want to get once again my
450:35 - animation frames and I want to overwrite
450:38 - the current key or the key value pair
450:41 - and the item I want to add is going to
450:43 - be another list
450:45 - I can start by just copying what is in
450:47 - there and this is going to be surf for
450:49 - surf in value
450:52 - like so
450:53 - we're getting the value here and we are
450:56 - copying all of the surfaces but this is
451:00 - not exactly what I want to do instead
451:01 - what I want to do I want to manipulate
451:03 - this surface and this I get with pygame
451:06 - DOT Brands form dot lip and now we need
451:11 - to surface
451:12 - and we need information if you want to
451:14 - flip this in X and in y and those are
451:18 - going to be true fault statement I do
451:20 - want to flip this thing in X but I do
451:22 - not want to flip it in y
451:24 - and with that we are flipping all of the
451:28 - surfaces if the shell is pointing to the
451:31 - right
451:31 - so I can minimize this one
451:33 - and work on the rest of it
451:36 - what we need now is self dot frame Index
451:39 - this one once again is going to be zero
451:41 - and then I want to have self dot status
451:44 - by default this one is going to be idle
451:47 - and once I have that I can call this
451:50 - super in Niche method
451:52 - and once again we have the generic
451:55 - parameters that we need to cover I can
451:58 - just copy them
451:59 - and paste them in here
452:02 - the position we are getting from up here
452:05 - so this one is very simple the groups
452:08 - we're also getting from up here so
452:10 - nothing to worry about
452:11 - surface is what we do have to think
452:13 - about and this is going to be quite
452:16 - similar compared to two because
452:19 - animation frames is a dictionary we
452:21 - first have to get the status and then we
452:23 - can use indexing for this one I'm not
452:26 - going to create a separate variable
452:27 - because we don't really need it I can
452:29 - just self dot animation frames inside of
452:33 - there I can get self dot status and then
452:36 - I can use indexing with self dot frame
452:39 - index
452:40 - and for start this is all we are going
452:43 - to need let me run main.pi again without
452:46 - cutting an error I can play stuff as
452:48 - usual and now let me play some spikes
452:50 - the enemy
452:52 - and two shells and now if I run this we
452:55 - are getting an error that name assets is
452:57 - not defined
453:00 - this is happening inside of here because
453:03 - I forgot to pass in the proper
453:07 - value for this assets here
453:10 - this is literally the same information
453:11 - because we are flipping all of this data
453:14 - inside of the class
453:15 - now next attempt let's run out of this
453:18 - again let's Place some enemies like so
453:22 - nothing's crashing and there we go we
453:25 - have all of the enemies although you can
453:27 - see they all have a bit of an offset
453:30 - from the floor this area here looks a
453:33 - bit weird
453:34 - yes we can fix right now and then we are
453:38 - nearly done
453:39 - and once again the problem here is that
453:42 - we have a tile size of 64 by 64 and the
453:47 - shell for example is only covering this
453:51 - size which is why we're getting the Gap
453:53 - below that is a very easy thing to fix
453:56 - now we have self.rect and I want to
454:00 - update the bottom of this rectangle
454:04 - and the bottom here I get with
454:06 - self.rect.top plus the tile size
454:11 - which means
454:12 - I am getting the top of the rectangle
454:15 - this line here and I am adding the tile
454:18 - size so 64. and this is why I'm placing
454:22 - the bottom which means now we are
454:24 - getting the bottom information here
454:27 - the same thing I am going to tooth and
454:31 - make sure you're calling this after the
454:33 - Super method otherwise you are going to
454:35 - get an error but now I can run this
454:37 - again and let's try all of this one more
454:41 - time
454:43 - like so and now I can run this
454:45 - and this is looking much better
454:49 - cool so with that we have literally all
454:52 - of the objects inside of the game we
454:55 - just have to make them work a little bit
454:57 - better but at the very least we have a
454:59 - really good start in this section once
455:01 - again is getting quite long so let's
455:03 - finish this one up now that we have the
455:06 - level we can start working on the player
455:08 - movement and for that we are going to
455:09 - need a couple of things first of all the
455:12 - player already can move left and right
455:14 - that's a good start but I also want the
455:17 - player to be able to fall and jump
455:19 - however for that we are going to need
455:22 - collisions with the level otherwise
455:24 - falling and jumping is going to be kind
455:26 - of annoying which means we are going to
455:28 - start by creating collisions with the
455:31 - level let's have a look how that's going
455:33 - to work and let's do all of this trading
455:36 - code once again here we are in the code
455:39 - editor and I want to have a look at my
455:42 - level file
455:43 - in here there's one important thing that
455:45 - I have to figure out and that is when
455:48 - I'm building a level I also want to when
455:51 - placing all of these Sprites I have to
455:53 - figure out what kind of object I want to
455:55 - place that the player can collide with
455:57 - and here we do have to be quite careful
456:01 - for example for it to rain those are
456:04 - going to be fairly simple if we have for
456:07 - example a block or a Terrain block that
456:09 - looks like this I want all of those to
456:12 - be collidable
456:14 - where this becomes a bit more
456:15 - complicated is if we look at all of the
456:18 - palm trees these ones here
456:20 - because for all of those a palm tree
456:23 - could for example look like this
456:27 - with a long stem
456:31 - and what I want is that the player can
456:33 - only collide with this top part here
456:36 - which means for those we have to create
456:39 - some custom way to create collisions
456:41 - which we couldn't do with the animated
456:44 - class so we have to figure out something
456:46 - else
456:47 - and here's what I'm going to do I'm
456:49 - going to create a whole separate class
456:51 - for that inside of Sprites I am going to
456:55 - create a whole another class and this is
456:58 - going to be a very simple one so let me
457:01 - minimize everything else that way we can
457:07 - focus on things a bit easier there we go
457:09 - the class I'm going to create is going
457:12 - to be called class I call this one just
457:15 - block once again this one can inherit
457:18 - from generic because we are just going
457:21 - to create a very simple Sprite or the
457:24 - init method here I want to know I need a
457:27 - self I need a position now I need a size
457:30 - and now I need a group importantly here
457:34 - we do not have a surface
457:37 - the reason for that is imagine once
457:40 - again I have a palm tree that looks in a
457:42 - simplified way something like this what
457:46 - I want to do for this block is to spawn
457:48 - the block on top of the palm tree in
457:51 - this position with this size and this
457:54 - block is going to be collidable while
457:57 - the yellow part is not going to be
457:59 - collidable as a consequence the pink
458:01 - rectangle will not be visible so we
458:04 - don't need a fancy surface I am just
458:06 - going to create a surface from the size
458:08 - and since it's going to be invisible
458:10 - that's really all we need as always we
458:14 - need some kind of super Thunder image
458:16 - method and for this one we have to
458:19 - figure out these parameters here
458:22 - position surface and group
458:25 - position
458:26 - and group are going to be easy those we
458:29 - already have what we have to figure out
458:32 - is how to convert the size to a surface
458:35 - which means in here we need a surface
458:38 - this surface we get with pi game and
458:42 - surface and for this surface we always
458:45 - need a tuple with a size and that is the
458:48 - size we are actually getting so whenever
458:50 - I'm creating this kind of block the size
458:53 - here is going to be a tuple with X and Y
458:56 - once I have that surface I can pass it
458:59 - in here and I am good to go this is
459:01 - literally all I need
459:03 - with that I can minimize this class and
459:06 - back in level I first of all have to
459:09 - import it let me do it right next to
459:11 - generic I want to have a block
459:13 - now we just have to figure out how to
459:16 - use it
459:17 - for that inside of the init method when
459:20 - I'm creating my groups I want to create
459:22 - one more group
459:23 - in this one I'm going to call
459:24 - self.collision
459:27 - Sprites
459:28 - once again this is just going to be
459:31 - pygame.sprite.group and that's all we
459:33 - need in here so I can minimize this and
459:36 - now any kind of object that we are
459:38 - creating inside build level that is
459:41 - going to be inside of the group is going
459:42 - to be collidable with the player for
459:45 - example when I'm creating a Terrain this
459:47 - part here
459:48 - I want this to be in all Sprites and in
459:52 - self.collision Sprites
459:54 - just with that I can make this generic
459:57 - collidable with the player while this
459:59 - one here the water bottom tile is not
460:01 - going to be collidable because it's not
460:03 - inside of the group
460:05 - so with that we already have the terrain
460:07 - covered next up we have to figure out
460:10 - this slightly more complicated bit and
460:12 - that is all of these animated trees and
460:15 - also the shell needs to be collidable
460:17 - the shell is the easier bit because this
460:20 - one we can treat like the terrain
460:23 - I want this to be in all Sprites and
460:26 - self.collision Sprites
460:29 - that way the player later on can collide
460:31 - with them now a slightly more
460:33 - complicated part is going to be these
460:35 - palm trees here because those I couldn't
460:38 - just put into two groups and well that
460:41 - wouldn't work
460:42 - because we will be ending up with the
460:44 - entirety of the palm tree being
460:45 - collidable which I don't want let me
460:48 - first of all separate them into
460:50 - foreground palm trees and background
460:52 - palm trees the background ones we can
460:54 - just ignore because those are not going
460:56 - to be collidable at all those can just
460:59 - remain an animated Sprite and we don't
461:01 - have to worry about them
461:02 - what we have to worry about is the
461:05 - foreground palm trees and then here let
461:07 - me do one example
461:09 - besides the animated palm tree I also
461:12 - want to create a block for this one I'm
461:15 - going to need a position a size and a
461:18 - group
461:19 - for the group for now I'm going to place
461:22 - them in self dot all Sprites and
461:25 - self.collision Sprites although later on
461:28 - I'm going to remove all Sprites that way
461:31 - this block is not going to be drawn but
461:33 - the Collision is still going to work
461:35 - besides that we need position and size
461:37 - position once again is easy we already
461:40 - have that and we used it multiple times
461:43 - what we have to figure out is the size
461:46 - and for what this one well I could
461:49 - measure this in Photoshop it depends on
461:51 - the graphic but for this palm tree I
461:53 - want a width of 70 and a height of 50.
461:56 - also let me move this block
461:59 - that way we can see this a bit easier
462:01 - which makes bug fixing a bit more visual
462:04 - let me actually try this if I switch to
462:07 - main.pi and I play some small Pawn trees
462:11 - and run the entire thing
462:13 - there you can see we now have a black
462:16 - rectangle on top of the palm trees this
462:19 - later on is going to be the collision
462:20 - and I did notice here this I could
462:22 - probably make a tiny bit wider just to
462:25 - be a bit more accurate
462:26 - let's say 76 and let's try this again
462:30 - how to place palm trees again
462:34 - and this is definitely looking better
462:36 - you can play around with this as much as
462:38 - you want there's basically no end to it
462:42 - this we now have to do for the other
462:44 - palm trees as well
462:46 - next up we have the large foreground
462:48 - palm tree this one fortunately has the
462:51 - same top size as the small one so we can
462:54 - just copy this bit and call it a day
462:56 - besides that we have the left palm tree
462:58 - and the right palm tree those have a
463:00 - palm trees that look like this and then
463:04 - we have the top part here which means
463:06 - this is the entire bounding rectangle
463:09 - for the surface and we have to move the
463:12 - Collision One somewhere here
463:14 - that would be the case for the right one
463:17 - but for the left one we can keep it
463:19 - somewhere here
463:21 - because let me use a different color
463:22 - because the left one is going to look
463:25 - like this that is the one we are going
463:27 - to work on in here
463:30 - once again I want to copy the block and
463:32 - since we're always placing this position
463:34 - in the top left I can also leave this
463:35 - one as it is
463:37 - which means I can copy this one more
463:39 - time and now we have to figure out the
463:42 - right foreground Pawn Tree in my case
463:44 - all I really did was I added a vector
463:48 - with 40 and 0 to this and that's
463:53 - basically all I needed that way this
463:55 - block is going to be a bit further to
463:57 - the right which is perfect to capture
463:58 - this top part
464:00 - and let's try all of this
464:02 - if I now Place different palm trees like
464:05 - so and so and run the entire thing you
464:09 - can see that this is working reasonably
464:12 - well although this part here could do
464:16 - some more work
464:18 - let's move it a tiny bit further let's
464:20 - say I want to move it by 46 pixels
464:27 - and place all of them again
464:31 - and that is could still do a tiny bit
464:34 - more let's say I want to move this by 50
464:38 - pixels
464:40 - and this is the only one I want to place
464:43 - and there we go this is looking really
464:45 - good
464:46 - with that we have a collidable object
464:49 - for all of the foreground palm trees
464:51 - body shells and for the terrain this is
464:55 - literally all we need obviously for the
464:57 - terrain and for the shell we can't
464:59 - really see them right now because we are
465:01 - using the object itself as a collision
465:03 - object but that is something we can work
465:06 - on later
465:07 - for now what I want to do is to remove
465:10 - these self.all Sprites
465:13 - from all of the palm tree Collision
465:16 - objects that way they're not going to be
465:18 - visible anymore but once we work on the
465:21 - player they are definitely going to be
465:23 - felt
465:25 - like so and this is all I need for this
465:30 - stuff here there's one more thing that I
465:32 - do need and that is when I'm creating
465:35 - the player all the way up here this
465:37 - player needs to know the position of all
465:40 - of the collidable Sprites I can just
465:42 - Place self
465:43 - dot Collision Sprites and here and that
465:48 - way the player is going to have access
465:49 - to them
465:50 - and really important here for the player
465:53 - I am assigning the player Sprite to the
465:56 - group all Sprites and I'm giving the
465:58 - player a reference to the Collision
466:00 - Sprites but the player itself is not
466:04 - inside of the group or is not going to
466:07 - be inside of the group this is different
466:09 - for example to the terrain the generic
466:11 - type we create up here we are placing
466:13 - this generic inside of all Sprites and
466:16 - collision Sprites
466:18 - understanding the difference here is
466:20 - really important the player only has a
466:23 - reference to Collision Sprites but is
466:25 - not itself in it because it couldn't
466:26 - collide with itself that would be weird
466:29 - but now the player has access to all of
466:32 - the collisions which means inside of
466:34 - sprite I can look at my player one more
466:37 - time and first of all we need another
466:39 - parameter this one is going to be the
466:42 - Collision Sprites
466:44 - this I want to capture inside of a
466:47 - variable let me add another section here
466:49 - that I called Collision
466:51 - I want
466:52 - self.collision Sprites it's going to be
466:55 - Collision Sprites and while we are here
466:58 - there's one more thing that I do want to
467:00 - do and that is that the player should
467:02 - have a hitbox and this is supposed to be
467:06 - a rectangle as well the size of it I
467:09 - think is best explained by looking at
467:10 - the graphics here is the folder for all
467:13 - of the graphics I want to look at the
467:15 - player and let's say I want to look at
467:17 - run left
467:18 - if I open a random one
467:22 - inside of this the entire surface is
467:25 - going to have a size something like this
467:29 - but not all of this is supposed to be
467:31 - collidable what I want to have is that
467:34 - the player can only collide with this
467:36 - rectangle here more or less
467:39 - which means I have to shrink the
467:41 - original rectangle quite a bit and for
467:45 - that I want to get self Dot rect and
467:48 - this I want to inflate and now I need to
467:51 - inflate it by an X and A Y amount Y is
467:54 - going to be zero because I'm happy with
467:56 - the height
467:57 - X however I want to shrink by 50 pixels
468:00 - and with inflate we are keeping the
468:03 - Center Constant which means if this one
468:05 - here is the original rectangle we are
468:08 - creating one that looks something like
468:11 - this
468:13 - that we are shrinking by 25 and 25
468:17 - pixels on each side
468:19 - that looked best when I tested the
468:21 - entire game
468:22 - now we have to incorporate this hitbox
468:25 - into the player movement as well
468:28 - that is going to happen down here inside
468:30 - of the move method
468:32 - and this one for the collisions we have
468:35 - to change quite a bit anyway the most
468:38 - important thing that we have to do here
468:39 - for now is we have to split this into
468:42 - horizontal and vertical movement why
468:46 - that is you're going to see later but it
468:48 - is going to be really important for the
468:50 - collisions
468:52 - to fix this one first of all I still
468:54 - want to get myself.poss but now I want
468:56 - to get the X part of it
468:58 - to this I want to add self dot Direction
469:02 - dot X multiplied with self dot speed and
469:07 - multiply this by Delta time
469:09 - this I now want to use to move the
469:11 - hitbox so self Dot hitbox and remember
469:14 - the hitbox is just going to be a
469:17 - rectangle
469:18 - but you couldn't use the left for this
469:20 - one because this would make the math
469:23 - kind of awkward if I show the drawing
469:25 - again
469:26 - I want to start by moving this Collision
469:28 - rectangle and then later on make this
469:32 - actual rectangle that shows the position
469:34 - of the player follow in the same
469:37 - position and then placing this Collision
469:39 - rectangle in the top left is going to be
469:41 - kind of awkward because we couldn't
469:43 - translate this easily to the original
469:45 - top left
469:47 - which means in my case I'm going to
469:49 - place the center of the hitbox
469:52 - that way I can use this Center also for
469:55 - the positioning of the larger rectangle
469:57 - that shows the player that is going to
469:59 - make my math quite a bit easier
470:02 - so for this one I want to place this
470:04 - Center
470:05 - and this I'm getting with round self dot
470:09 - post dot X
470:11 - and once I have that I can place
470:13 - self.rect.center X
470:15 - it's going to be self dot hitbox dot
470:18 - Center X and I noticed this one should
470:21 - be Center X not Center because we only
470:23 - care about X or the horizontal movement
470:25 - for now
470:26 - the same thing we now have to do 40
470:29 - horizontal movement which means I can
470:32 - copy all of this paste it in here and
470:34 - this bit I can get rid of
470:37 - and essentially now I just have to
470:40 - replace all of the X's with y's and then
470:43 - I should be good to go
470:46 - sort of the X should be a y and now we
470:49 - basically have the same outcome with one
470:51 - intermediate step we can see the hitbox
470:54 - however when we are creating the
470:56 - position when I'm creating this Vector I
470:59 - don't want to have the top left I want
471:01 - to have the center just to keep things
471:02 - consistent
471:04 - and with that let's try all of this
471:06 - actually so let me draw some terrain
471:08 - tiles run the entire thing
471:10 - and the player can still move left and
471:12 - right
471:13 - so that's a good start
471:16 - we make this even more visual let me
471:18 - minimize the build level and inside of
471:21 - run
471:21 - right now we are drawing all of the
471:24 - Sprites on top of that I also want to
471:27 - pygame dot draw Dot rect
471:31 - on self dot display surface with let's
471:34 - say a yellow color
471:36 - I want to draw
471:38 - self.player Dot hitbox
471:41 - if I run all of this again I can run the
471:44 - level straight away we can't see
471:46 - anything the reason for that is that
471:49 - right now the player has a width of 32
471:52 - pixels and if we shrink this by 50
471:55 - pixels we can't see anything
471:57 - but if I change this let's say to 80
472:01 - now if I run the entire thing let me
472:03 - draw some terrain tiles and run this
472:05 - this is looking much better the yellow
472:07 - bit is now what is actually going to
472:09 - collide with the level
472:12 - so with that back and Sprites I can
472:15 - actually start working on the Collision
472:17 - logic
472:19 - this I'm going to cover in another
472:20 - method let's call it Collision in here
472:23 - we need self and we need the direction
472:27 - first of all here we have to look at all
472:29 - of the Collision objects which we get
472:31 - with four Sprite in self dot Collision
472:34 - Sprites remember all of the collidable
472:37 - Sprites we put inside of this group
472:40 - once we have that I want to check if
472:43 - Sprite dot rect dot collide rect with
472:50 - self Dot hitbox
472:52 - now I'm checking after I have all of my
472:55 - Sprites I want to check if the player
472:57 - hitbox collided with any of these
473:00 - Sprites
473:01 - inside of that if statement I want to
473:04 - add another if statement because now I
473:07 - want to check the direction is the
473:09 - direction equal to
473:11 - horizontal that I want to do horizontal
473:15 - collisions for now I'm going to add a
473:17 - pass if that is not the case so else I
473:20 - want to check vertical collisions
473:22 - for now I'm just going to add a pass in
473:24 - here in here now we just have to figure
473:26 - out some basic things let's say for
473:29 - example we have the player here and the
473:32 - player is moving to the right this
473:34 - direction we can get from up here the
473:36 - direction of the player that one is
473:38 - quite easy to get so we always know if
473:41 - the player is moving right or left
473:43 - and if the player for example is moving
473:46 - to the right and he just overlapped with
473:49 - an object like so
473:51 - all I really have to do is put the right
473:55 - side of the player so this part here
473:59 - on the left side of the obstacle
474:02 - and once I have that I basically have
474:04 - collisions
474:06 - which means inside of Direction I first
474:08 - of all want to check if
474:11 - self.direction.x is greater than zero
474:13 - this means we are moving right
474:16 - if that is the case we are moving right
474:19 - and we have a collision that means the
474:21 - players colliding with an object on the
474:23 - right side and this I can use to set
474:26 - self dot hitbox dot right equal to
474:30 - Sprite Dot rect.left
474:34 - if I draw all of this again
474:37 - the right side of the player is going to
474:40 - be this bit here
474:42 - and the left side of the obstacle is
474:46 - going to be this side here
474:48 - that way as soon as there's any kind of
474:50 - overlap we are putting the right side of
474:52 - the player on the left side of the
474:53 - obstacle and we have a collision
474:56 - the same thing we now have to do with if
475:00 - self.direction.x is smaller than zero if
475:03 - that is the case we are moving left
475:07 - and in here we can check
475:09 - self.hitbox.left is going to be
475:11 - sprite.rect dot right
475:14 - once we have done all of that I have to
475:17 - do two more things first of all we have
475:19 - to update the rectangle this is the one
475:21 - that the player is actually going to see
475:23 - for this one I also want to update the
475:25 - center X and I want to set this to self
475:28 - dot hitbox dot Center X
475:32 - what this means is imagine we have the
475:35 - player moving to the right but then
475:38 - because of a collision we moved this
475:40 - rectangle a bit further to the left
475:43 - as a consequence the center of this
475:45 - rectangle moved from here to let's say
475:48 - somewhere here all of that just means
475:51 - that the Collision has changed but it
475:53 - doesn't tell Pi game without this line
475:56 - here that we want to draw the player in
475:58 - a different position as well but once we
476:01 - have this line we know that we also want
476:04 - to draw the rectangle so what the player
476:06 - actually sees around this new center
476:09 - that way the player can actually see the
476:11 - Collision
476:12 - finally the actual position that we have
476:15 - so self.post.x I also want to update
476:18 - this is going to be
476:20 - self.hitbox.center X and that is all we
476:23 - are going to need for horizontal
476:25 - collisions I can call this method now
476:28 - self.collision don't forget to pass in
476:31 - horizontal in here
476:33 - and now if I run main.pi again and draw
476:37 - some terrain tiles next to the player
476:41 - and run the entire thing if I now move
476:43 - too far to the right I can't go any
476:45 - further same as the left side this is
476:48 - looking really good
476:50 - the same thing if I return to the editor
476:53 - I can also do with a palm tree let's
476:55 - place it here
476:57 - run the entire bit again and the same
476:59 - thing is also going to work with a palm
477:01 - tree so I'm very happy with this
477:03 - which means all we have to do now is
477:06 - copy all of this for the vertical
477:09 - collisions and this is going to be your
477:12 - exercise
477:14 - let me add a bit more space I want you
477:16 - guys to copy the logic here and apply it
477:19 - to the vertical axis so pause the view
477:21 - now and try to figure this one out
477:27 - this one is going to look basically
477:29 - identical compared to this one although
477:31 - we can make all of this a bit more space
477:33 - efficient but I also want to be able to
477:36 - test out of this for that first of all
477:38 - let me copy these lines here
477:41 - and
477:42 - now I want to check if the player is
477:45 - moving down or up
477:50 - and if that is the case I want to move y
477:53 - for all of these
477:55 - with that I have to add a pass in here
477:59 - again let me test this and Run the game
478:01 - and switch to the level now I can move
478:04 - the player around as I want obviously
478:07 - this is not going to be the logic for a
478:09 - side scroller but that we're going to
478:10 - implement in just a bit this is good
478:13 - enough to test things
478:14 - now in here
478:16 - I now want to copy this logic but make
478:20 - it a tiny bit more space efficient
478:21 - because there isn't that much happening
478:24 - here and writing six lines of code is
478:27 - kind of Overkill we can set self dot
478:30 - hitbox.top so this is what I'm doing
478:33 - here basically except for top and bottom
478:36 - I want to set this to sprite.rect dot
478:40 - bottom
478:42 - this means if the player is moving up
478:47 - and overlaps with a wall on the top if
478:51 - that is the case I want to move this top
478:53 - side here to this position the bottom of
478:56 - the wall but I only want to do this
478:59 - if self dot Direction dot Y is smaller
479:04 - than zero meaning the player is moving
479:07 - up
479:08 - if that is not the case so else I want
479:11 - to keep
479:12 - self.hitbox.top as it is the same thing
479:15 - I can do for the bottom so now I want to
479:18 - place the bottom of the player to the
479:20 - top of the rectangle which means now the
479:24 - player is moving down like so and
479:27 - overlaps with a wall on the bottom I
479:30 - want to get this bottom part of the
479:32 - player and move it on top of the wall
479:34 - this is what I'm getting here and this I
479:37 - only want to do if the player is moving
479:40 - down so Y is positive or direction that
479:43 - Y is positive to be a bit more specific
479:45 - if that is not the case I want to keep
479:48 - bottom as it is
479:50 - this Alliance basically do the same
479:53 - logic as these four lines here except in
479:56 - well much less space
479:58 - all we have to do now is copy these two
480:01 - lines here I want to set self dot
480:04 - rect.center Y and I want to set self dot
480:08 - pause dot y
480:10 - both of these are going to be self Dot
480:14 - hitbox
480:15 - Dot Center y all I have to do is copy
480:19 - this one and I am good to go with that
480:22 - we have covered the same logic that we
480:25 - have here for the vertical side in half
480:28 - the amount of lines
480:30 - which I think is also a bit more
480:32 - readable but it's a bit subjective let's
480:34 - try it actually
480:36 - now let me place a couple of terrain
480:38 - tiles all over so it's easy to test like
480:42 - so if I run all of this I can move
480:44 - around this Collision works pretty well
480:46 - and in here
480:49 - there is a bit of a problem
480:52 - the other collisions seem pretty good
480:54 - though oh this one is also not great so
480:57 - we have to look around here a bit so the
480:59 - vertical collisions definitely not ideal
481:01 - yet let's have a look
481:04 - I think I actually realized what the
481:06 - problem is I am not actually calling
481:08 - inside of the move method self dot
481:12 - collision with vertical
481:15 - now let's try this again if I now run
481:17 - main.pi let me draw a few things again
481:21 - like so
481:24 - now the collisions are working much
481:27 - better
481:28 - and this is
481:30 - pretty good I'm quite happy with that
481:33 - part
481:36 - okay this seems to be working just fine
481:38 - so I can leave this one as it is I can't
481:41 - see any kind of problem here while we're
481:44 - here I also want to make all of this as
481:47 - space efficient as this bit down here I
481:50 - guess I can also explain the logic a bit
481:51 - better I want to place self dot hitbox
481:54 - dot write to
481:57 - sprite.direct.left but only if this
482:00 - condition here is true
482:02 - if it is not true I want to keep
482:05 - self.hitbox.right where it was before
482:09 - this is going to cover this part here
482:12 - so I can take it out
482:14 - and duplicate this line and to duplicate
482:17 - this one here
482:18 - I want to place the left side of the
482:20 - hitbox to the right side of the wall but
482:24 - only if the direction is smaller than
482:26 - zero
482:27 - that way we're moving left and now I can
482:30 - get rid of this bit here
482:33 - finally
482:34 - I want to assign
482:36 - self.rec.centerx and self.post.x where
482:40 - the hitbox is like so and with that
482:45 - all of this is much more easily readable
482:48 - yes one thing I forgot and here at the
482:51 - end this should be hitbox left
482:54 - but with that we should be good to go
482:57 - let's try this
482:58 - if I now place a few more elements
483:02 - and try all of this
483:05 - still looks pretty good
483:08 - so yeah this is working just fine cool
483:12 - very happy with this
483:15 - with that we have Collision logic and
483:18 - the entire Collision logic here really
483:20 - isn't that complex this is still fairly
483:23 - simple
483:24 - it's like a minimize for now and now we
483:27 - have to work on the actual player side
483:29 - scroller movement logic which means that
483:31 - the player actually moves like a 2d
483:34 - platformer for that we first of all want
483:38 - to get rid of this one here because well
483:41 - the player shouldn't be able to just
483:42 - move up and down we should only be able
483:44 - to jump and fall inside of the init
483:47 - method I want to create a few more
483:50 - attributes
483:51 - the first one is going to be self dot
483:54 - gravity this one I have set to 4.
483:58 - besides that there's one more attribute
484:00 - that I want and this I called self and
484:02 - on lore
484:05 - this by default is going to be false
484:08 - later on the player is only supposed to
484:11 - be jumping if he is on the floor if it
484:14 - is not the player shouldn't be able to
484:15 - jump that way the player couldn't keep
484:17 - on jumping in the air
484:19 - now we have to implement all of this and
484:22 - for this let me minimize a couple of
484:24 - methods here
484:25 - besides move I want to have a method I
484:29 - called apply gravity
484:32 - this one needs self and since we have
484:35 - movement this is also Delta time and
484:37 - that is some horrible spelling
484:40 - all I really want here is
484:43 - self.direction.y plus equal self dot
484:47 - gravity multiplied by Delta time
484:52 - as always gravity just means we are
484:54 - falling down so y gets larger and larger
484:58 - and this number I now want to add to
485:01 - self.rect.y plus equal self.direction.y
485:07 - note here what is really important I am
485:09 - using plus equal twice which means that
485:12 - we have an exponential false speed this
485:15 - Direction gets larger and larger every
485:18 - single time and this number we're always
485:19 - adding towards the position
485:22 - but that is all we need I can minimize
485:24 - this one before I'm running move I want
485:27 - to self dot apply gravity with Delta
485:30 - time
485:31 - if I run this again now and let me just
485:34 - go to the level and the player is indeed
485:36 - falling that is a good sign
485:39 - now let me try the same thing again with
485:41 - some terrain and we have a platform
485:44 - and there we go now we have some basic
485:47 - movement although if I wait for a bit
485:49 - this should eventually break
485:53 - I just have to wait for a bit
485:56 - maybe it doesn't
485:57 - but basically now if I fall down the
485:59 - player moves down really really fast the
486:02 - reason here is
486:03 - when the player was still standing here
486:06 - we kept on increasing self.direction.y
486:10 - which means every millisecond the player
486:13 - stood on this platform the gravity that
486:16 - he would be subjected to was larger and
486:19 - larger in practice pygame would put the
486:22 - player down to let's say this position
486:25 - here realizes it's on top of a Terrain
486:29 - and place the bottom of the player back
486:31 - to this position here
486:32 - if this was running for long enough
486:34 - though we would eventually get to an
486:36 - arrow that is somewhere here and then
486:39 - pygen would assume that the player just
486:40 - jumped over the entire platform
486:43 - another problem that we have seen is if
486:46 - we wait on the platform here for a while
486:48 - and then fall down all of a sudden the
486:50 - player falls down at a really fast speed
486:53 - so we have to account for a couple of
486:55 - things here
486:56 - this is actually going to happen inside
486:58 - of collision
487:00 - what I want to do if the player is
487:02 - colliding with something vertical I want
487:05 - to reset the gravity which means I want
487:07 - to set self dot Direction dot y back to
487:11 - zero which effectively cancels out all
487:15 - of the Gravity we have applied inside of
487:17 - this method here and this is really
487:20 - important that way the player doesn't
487:22 - accumulate gravity while standing on the
487:24 - platform which would become a massive
487:26 - issue when we're trying to jump or
487:28 - falling down from a platform
487:30 - kind of hard to test but this is
487:32 - basically all we need in here
487:34 - okay and now that we have that I also
487:37 - want to cover the jump mechanic this one
487:40 - we are going to start inside of input
487:42 - and what I want to check in here is if
487:45 - he's
487:47 - is pygame dot k underscore space
487:51 - meaning the player is pressing the space
487:53 - button and self dot on floor is true
487:59 - if that is the case basically all I want
488:01 - to do is move the player upwards so
488:05 - self.direction.y is going to be -2
488:08 - and just to test this let me set self
488:11 - dot on floor this we get up here to true
488:14 - if I run all of this now and let me add
488:17 - a platform here so we can see what we're
488:19 - doing
488:20 - we are getting an error that I have made
488:24 - a typo this one here now let's try this
488:27 - again and I create another platform
488:30 - and now if I press space the player goes
488:33 - up and comes down again
488:37 - this is looking really good I'm quite
488:40 - happy with this
488:42 - all we have to figure out now is how to
488:45 - check if the player is actually standing
488:46 - on the floor
488:48 - since we don't have that right now let
488:50 - me actually show what problem we have
488:52 - and let me add a couple of terrain tiles
488:54 - here
488:55 - so this is a bit easier to show
488:58 - if I am in the air the player can keep
489:01 - on jumping
489:03 - which
489:05 - um well I hope you can see the problem
489:06 - with this
489:08 - is is not his side scroller we rather
489:10 - have some kind of Flappy Bird kind of
489:12 - thing
489:14 - this we have to account for which means
489:17 - by default I want to set on floor back
489:20 - to false
489:22 - the input we don't need anymore and we
489:24 - also don't need the init method
489:27 - instead I want to have another method
489:30 - that I called check on floor
489:34 - no custom parameter needed here and
489:37 - essentially what I am going to do
489:40 - if this one here is the player I'm going
489:43 - to create a rectangle below the player
489:45 - like so and if this rectangle here is
489:49 - colliding with some kind of collidable
489:52 - object we know the player is going to be
489:54 - on some kind of floor
489:56 - for that first of all I want to create a
489:59 - floor rectangle this one is going to be
490:02 - pygame Dot rect and now we need the left
490:05 - the top the width and the height
490:07 - the height is going to be fairly
490:09 - subjective I've set this one to a 2. two
490:12 - pixels for this one is perfectly fine
490:14 - but we also have to figure out the width
490:17 - the top and the left side and this I
490:19 - think could be a really good exercise
490:20 - for you try to figure out all of these
490:23 - values and see what you can come up with
490:25 - so pause the video now and try this one
490:28 - yourself
490:32 - the width is very easy I want to get
490:35 - self.hitbox.wiff
490:38 - that part should make quite a bit of
490:40 - sense if this one here is the hitbox of
490:42 - the player and this one is the entire
490:45 - player drawing
490:47 - what I want is this area here
490:51 - this one right now is two pixats high
490:53 - that's what we are getting here and the
490:55 - width is going to be this area which is
490:58 - the same width as the hitbox which is
491:00 - what we are getting here
491:02 - while we have that let me draw this
491:05 - again we have the player hitbox and we
491:08 - have the floor rectangle now we have to
491:10 - figure out the top left
491:13 - and this one is going to be quite simple
491:15 - because all this is going to be is the
491:17 - bottom left of the hitbox
491:19 - let me turn the width and the height
491:22 - into a tuple that way we can turn the
491:24 - positioning also into Tuple and here I
491:27 - want
491:28 - self.hitbox.bottom left
491:30 - just to check if this one is working I
491:33 - want to turn this self.floor into an
491:36 - attribute
491:37 - now after we're moving I want to run
491:39 - self.check on floor
491:42 - and inside of the level after we are
491:45 - doing the update that's really important
491:47 - so after this line here I want to draw
491:51 - all of this I guess I can copy this
491:54 - rectangle Here and Now
491:57 - self.player.floor rectangle and I'm
491:59 - going to use a different color let's go
492:02 - with pink
492:04 - if I now run off this again draw
492:06 - something here it doesn't really matter
492:08 - what it is
492:09 - and now we have a very small pink
492:12 - rectangle on the bottom of the player
492:14 - it's quite difficult to see but if you
492:17 - squint you can definitely see it
492:19 - so this is working I guess just to make
492:22 - it a bit more visible let me change this
492:23 - to a 20. and try out of this again
492:27 - there you go now it's much more visible
492:31 - but this one should only be two
492:33 - otherwise we get weird results
492:35 - this rectangle we want to check if
492:37 - there's any kind of collision with the
492:39 - floor or rather with the Collision
492:41 - Sprites
492:43 - for this one I'm going to create another
492:45 - variable let me call it floor Sprites
492:48 - and in here I want to get all of the
492:51 - Sprites that this self.flor.rect is
492:54 - colliding with and this I get with
492:56 - Sprite
492:57 - or Sprite in self dot Collision Sprites
493:02 - now I'm copying all of the existing
493:05 - Sprites but I only want so if Sprite dot
493:10 - rect dot collide rect
493:13 - with the floor rectangle and this self
493:17 - we don't need anymore
493:19 - what this
493:21 - list comprehension here means is we are
493:24 - copying all of the Sprites from the
493:25 - Collision Sprites but only if a Sprite
493:28 - is colliding with the floor rectangle
493:31 - this we can now use to check
493:33 - that self on floor is going to be true
493:38 - if there's anything inside of this list
493:41 - meaning if we have floor Sprites if that
493:44 - is not the case so else it is going to
493:46 - be false
493:48 - that is all we need in here now inside
493:50 - of level I want to get rid of this line
493:53 - here because this one would throw an
493:55 - error but now inside of main.pi let me
493:58 - draw once again a couple of platforms
494:01 - and run this again
494:03 - now I can jump but I can only jump if I
494:06 - am on a platform
494:08 - this is quite nice I can also jump to
494:10 - another platform and this is looking
494:12 - much more like a side scroller except I
494:16 - can't play it well so with that we have
494:19 - the player movement another major step
494:22 - for the next part we can actually show
494:24 - the player that is going to make the
494:26 - game much more visually appealing
494:29 - with the player movement coverage we can
494:31 - work on the player graphics and this one
494:33 - isn't going to be terribly difficult
494:35 - first of all we have to import a couple
494:38 - of different things all to play
494:39 - animations
494:40 - then we have to figure out what the
494:42 - status of the player is so is the player
494:44 - falling jumping running we also have to
494:47 - know what direction the player is facing
494:49 - so left or right but once we have all of
494:53 - that we just need a simple animation and
494:56 - we are good to go
494:58 - which means once again let's jump into
495:00 - the code editor and let's have a look at
495:02 - all of this back in main.pi I need the
495:06 - first step I have to import some player
495:08 - Graphics which I want to do in here
495:09 - because the player has a ton of
495:12 - different Graphics I am going to place
495:14 - this all the way at the end here I have
495:17 - the player and all of this is going to
495:19 - be inside of one attribute let's call it
495:21 - player graphics
495:23 - once again if I open the folder
495:26 - we have the project here there we have
495:29 - Graphics there we have the player and
495:31 - here are all the different possible
495:33 - states that the player can have for
495:35 - example we have idle right we have four
495:38 - left lots of different things that we
495:40 - could import and what I want is a
495:43 - dictionary and the key is always the
495:46 - name of the folder and the value is
495:49 - going to be all of these surfaces
495:51 - imported
495:52 - this we have done a couple of times
495:54 - already which means I can just copy this
495:57 - one here for example and paste it in
496:01 - there
496:01 - the only difference being that when I
496:04 - look at the folder there should be
496:06 - graphics and layer
496:09 - and the same we're going to do for the
496:11 - other folder this should be graphics and
496:14 - layer
496:16 - there we go
496:17 - and now let me print
496:20 - self.player graphics just to make sure
496:22 - this is working
496:24 - and there we go this is looking pretty
496:26 - good now we have four left we have fall
496:29 - right and we have lots of other states I
496:32 - am quite happy with that
496:34 - now we have to get this into the level
496:37 - this once again is going to happen
496:39 - inside of the switch method in here I
496:42 - want to have another entry for the
496:45 - player this is going to be self dot
496:47 - player graphics
496:50 - that is all we need to import the
496:53 - graphics next up we can work inside of
496:55 - the level
496:56 - in here the important thing is that we
496:59 - are getting all of these Graphics into
497:01 - the player class
497:03 - so in here let me do it all the way at
497:05 - the top I want to have the asset
497:08 - dictionary and I want to have the player
497:10 - Graphics this I now have to store inside
497:14 - of Sprites inside of the player Sprite
497:17 - with another parameter
497:21 - so in here I want to have the assets
497:25 - this I now want to turn into some
497:28 - animation logic
497:30 - and here first of all we want to have
497:33 - animation frames
497:35 - and those we're getting from the assets
497:37 - next up we need self.frame Index this
497:41 - one is going to be 0 and now we need
497:44 - self dot status this one by default is
497:47 - going to be idle
497:48 - finally we're going to need self dot
497:51 - orientation by default this one is going
497:54 - to be right
497:55 - these two lines here are already the
497:57 - second step of what we have to cover now
498:00 - we have the graphics with this part here
498:02 - the next step is figuring out the
498:04 - player's status so what is the player
498:06 - doing and which way is the player facing
498:09 - once we have that though we can create a
498:12 - surface
498:14 - and for the surface we have a dictionary
498:17 - with all of the different states as a
498:20 - key and then Associated we have a list
498:23 - of values right now I want to combine
498:26 - these two here to pick one key from this
498:30 - dictionary to get one value or one list
498:34 - of surfaces and from that I want to get
498:37 - the first Index this could be a good
498:39 - exercise for you to see if you can
498:41 - follow along try to get the surfaces
498:43 - that are either right and pick the frame
498:46 - index 0 from that and set this as the
498:49 - surface and then you can pass this
498:52 - surface in here like so
498:57 - okay first of all we want to get all of
499:01 - the animation frames
499:04 - in here I want to get some kind of
499:09 - string that is going to be idle right
499:13 - so I'm combining this one with this one
499:15 - with an underscore separating the two
499:17 - and this I want to be more flexible so
499:19 - I'm going to use an F string replace the
499:22 - first one with self dot status
499:25 - like so
499:28 - and right should be self dot orientation
499:33 - this is going to give me the full status
499:35 - of the player and this entire thing here
499:38 - is going to return a list of services
499:41 - on this list of surfaces I now want to
499:44 - perform indexing with my frame index
499:48 - and that is the entire line that we need
499:51 - so if I now run may not Pi let me play
499:54 - something and go to the level
499:56 - we can't see anything the reason here is
500:00 - we are drawing over the entire surface
500:03 - this I don't want to do anymore I also
500:07 - don't want to draw this happen inside of
500:09 - level in the run method I don't want to
500:12 - draw the hitbox anymore
500:14 - like so and now let's try this if I now
500:18 - switch to the level we can now see the
500:20 - player it doesn't actually update but
500:22 - well that is something we can work on
500:25 - next the rest is still working just fine
500:28 - let me minimize the init method and now
500:31 - what we are going to need is two more
500:34 - methods
500:36 - the first one is going to be get status
500:39 - and here we need itself and nothing else
500:43 - let me add pass in here and besides that
500:46 - I want to have an animate method this
500:49 - one needs self and Delta time in here as
500:52 - well I also want to have pass
500:54 - let's work on animate first that one is
500:57 - going to be the easier one and this is
500:59 - the kind of method we have already seen
501:01 - a couple of times so if you want to do
501:04 - an exercise here right to write the
501:06 - animate method it's going to be quite
501:08 - similar compared to the one we have
501:10 - created in here I could actually just
501:13 - copy the entire thing at least for now
501:16 - and pass it in here
501:19 - all of these are actually I think the
501:21 - naming are kept fairly consistent so all
501:24 - of this should still work just fine we
501:26 - just have to call it
501:28 - so inside of update
501:31 - all the way at the end I want to have
501:33 - self Dot and made with Delta time
501:38 - oh although I did realize there's going
501:40 - to be one error in here and that is
501:43 - these animation frames by default are
501:46 - not going to work
501:47 - because as you have seen here
501:51 - we need something quite extensive to get
501:54 - the actual animation frames
501:56 - I think the best way to approach this is
501:58 - copy all of this and create a current
502:01 - animation
502:03 - and this is going to be what we get in
502:05 - here but we're not indexing from it
502:08 - I hope I didn't go too fast just now but
502:10 - once again we're getting the animation
502:12 - frames and then we are getting one list
502:16 - of surfaces by using the full status
502:19 - once we have that I can replace these
502:23 - animation frames with the current
502:24 - animation and those ones as well that
502:28 - way later on inside of get status all we
502:30 - have to do is change this status and
502:33 - this orientation and we always get the
502:36 - proper current animation
502:38 - but this one should already work let's
502:40 - try this one and if I now run the entire
502:43 - thing you can see we have an animation
502:47 - doesn't change but at the very least the
502:49 - player is animated
502:51 - very good so now we have to get get
502:54 - status
502:55 - in here I want to check if
502:59 - self.direction.y is smaller than zero if
503:03 - that is the case self dot status is
503:06 - going to be
503:07 - jump after that I want to have an L if
503:11 - statement and the condition is going to
503:13 - be
503:13 - self.direction.y is greater than zero
503:17 - now we are falling so self dot status is
503:21 - going to be all
503:23 - if neither of those two are the case I
503:25 - want to have an else statement and this
503:27 - else statement is only going to trigger
503:29 - if direction.y is zero and this means
503:32 - the player is standing somewhere on the
503:35 - platform
503:36 - all I really have to check is if
503:38 - self.direction.x is different from zero
503:42 - if that is the case the status of the
503:45 - player is going to be run
503:47 - however if Direction dot X so else if
503:51 - this one is zero then self dot status
503:54 - should be idle
503:57 - and I don't really like that we're using
503:58 - four lines of code for something so
504:00 - simple which means I can rewrite this a
504:03 - tiny bit I want to have self.status
504:06 - being run only if this condition here is
504:10 - true if it is not so else then I want to
504:14 - have
504:16 - self.status being idle this one down
504:19 - here and with that we have the entire
504:21 - thing much more concise
504:24 - this get status we now have to call let
504:27 - me do it right before animate self dot
504:29 - get status
504:31 - what is really important here is that
504:33 - you're calling this get status always
504:36 - after applying gravity and move
504:39 - especially move here is important
504:40 - because in there if the player is on a
504:43 - platform we are changing
504:46 - self.direction.y to zero and that way we
504:49 - know if the player is falling or jumping
504:51 - or standing on a platform
504:53 - and now let's try this one
504:57 - and
504:59 - you can already see something is working
505:02 - although the player is always
505:05 - falling that is not ideal also the
505:07 - player doesn't face in the right
505:08 - direction so there are a couple of
505:10 - things we have to work on
505:11 - first of all let's start with left and
505:14 - right that's actually the easier one
505:15 - because in here inside of input if the
505:19 - player is pressing right I want to set
505:22 - self dot orientation
505:25 - to write
505:27 - and if the player is pressing left the
505:30 - orientation should be left
505:32 - let's try this one now and let me Place
505:35 - once again a few more terrain tiles I
505:39 - guess while we're here I can also place
505:40 - a couple of palm trees
505:42 - like so
505:45 - and we are definitely making progress so
505:49 - I can move left and right I can see the
505:51 - player jumping and this is definitely
505:53 - looking better the problem now is if I
505:56 - am on the floor the player is always
505:58 - falling so this is not ideal
506:02 - or this one I can minimize the input
506:04 - method and the easiest way I found to
506:07 - fix this is when we are checking get
506:12 - status
506:14 - here
506:15 - right now I am checking if the
506:17 - direction.y is greater than zero but I
506:19 - want to set this to 1. if I try this now
506:22 - and create a few more platforms once
506:25 - again
506:27 - now this is going to work
506:30 - the reason here is
506:33 - highgame basically moves the player down
506:35 - a tiny bit on every single frame and
506:38 - then checks if we are colliding with
506:39 - something if that is the case Pi game
506:41 - moves to the bottom of the player here
506:43 - but because of this Collision check we
506:46 - always have a very low y direction and
506:51 - this one
506:52 - we know that this is so small it is
506:55 - never going to exceed one so if we have
506:58 - a one here this is fairly safe
507:01 - and with that I can clean all of this up
507:04 - a tiny bit and now we have the
507:07 - animations for the player so let me
507:10 - place a few more platforms to make sure
507:12 - this is working and I can place I guess
507:15 - a few more palm trees in here
507:18 - like so and let me also place a couple
507:21 - of background ones so we know that those
507:23 - don't cause a problem
507:25 - this is looking pretty good and the
507:28 - player can move around just fine and the
507:31 - animations also look really good
507:35 - so I am very happy with this
507:41 - the game is definitely taking shape so
507:45 - yeah we are absolutely making progress
507:48 - for the next part I want to create the
507:50 - camera there are basically two major
507:53 - things that we need here number one the
507:55 - camera should always follow the player
507:57 - meaning the player is essentially always
507:59 - in the middle of the window and
508:01 - everything else gets drawn around the
508:03 - player besides that I also want to sort
508:06 - all of the objects in the level by depth
508:08 - this one is going to ensure that we for
508:11 - example always have the background palm
508:13 - trees in the actual background
508:16 - right now Sprites are going to be sorted
508:18 - by the way they are being created so if
508:21 - one Sprite is being created after
508:23 - another Sprite the Sprite that is
508:25 - created later is going to be on top
508:27 - which isn't terribly reliable to well
508:30 - create any kind of graphic system
508:32 - so let's work on those two things this
508:35 - shouldn't be too difficult
508:37 - inside of the code I want to work inside
508:40 - of a level and the way the camera is
508:42 - going to work is
508:45 - we are drawing everything inside of all
508:47 - Sprites this I want to change a bit or
508:51 - well I want to instead create a camera
508:54 - group
508:55 - this is still going to be a spread group
508:57 - but a special one that is going to draw
508:59 - everything in relation to the player
509:02 - this I want to create in the same file
509:05 - so let me create another class here that
509:09 - I called camera group this one has to
509:12 - inherit from pygame.spright.group
509:16 - this one as always is going to need a
509:19 - niche but there's no need for any kind
509:21 - of custom parameter
509:22 - however we do need to call Super thunder
509:26 - in knit
509:27 - once we have that though we have
509:30 - basically created a perfect replica of a
509:33 - normal pygam Sprite Group which means if
509:36 - I run the entire thing now let me draw a
509:38 - couple of terrain tiles and let's test a
509:40 - few more just to make sure everything is
509:42 - still working
509:44 - is looking pretty good so we are now
509:47 - drawing everything via a custom group
509:50 - but so far this custom group is a
509:53 - perfect copy of its bright group this we
509:56 - want to change though
509:58 - and first of all I need a few more
510:00 - attributes the first one is the display
510:02 - surface this one I'm getting with pygame
510:05 - DOT is Lay
510:08 - dot get underscore surface
510:11 - and besides that I want to have an off
510:14 - set
510:16 - this one by default is going to be a
510:19 - vector
510:20 - what we are now going to need let me
510:22 - call it a custom raw method
510:27 - this one in itself and we also need to
510:30 - know where the player is
510:32 - in here though first of all we need to
510:35 - draw something in general and what
510:38 - pygame does internally it does for a
510:41 - Sprite in self
510:43 - works because we always attach all of
510:46 - the Sprites to this group
510:48 - and now all we need is pi game
510:52 - and now we can use this for blitting so
510:54 - I want to get
510:55 - self.displaysurface dot lit
510:58 - and then here I want to have Sprite dot
511:01 - image and Sprite Dot rect
511:04 - this I can now use inside of the run
511:06 - method instead of running all
511:09 - sprites.draw let me comment this one out
511:11 - I want to get self dot all Sprites dot
511:15 - custom draw
511:16 - and in here I don't need to display
511:18 - surface because this group always has
511:21 - the display surface instead what I need
511:23 - is the player this I get with
511:25 - self.player
511:27 - well now this doesn't do anything but
511:30 - later on we are going to draw everything
511:32 - in relation to this player but let me
511:35 - first of all try this if I draw and run
511:38 - the level
511:39 - so far we haven't made any kind of
511:41 - change
511:42 - and let me get rid of the comment here
511:45 - we don't need that one
511:46 - what I can do in here
511:50 - when I'm drawing or blitting all of the
511:52 - Sprites I am always putting them in the
511:54 - same position where the rectangle is but
511:57 - I don't necessarily have to do that
511:59 - instead I could for example get an
512:02 - offset rectangle and this offside
512:05 - rectangle is going to be Sprite dot
512:07 - right let's copy it and this offside
512:10 - rectangle I now want to offset this I
512:13 - can do with offset rect and let's move
512:16 - the center minus equal by self dot
512:19 - offset which means now instead of
512:23 - drawing this sprited rectangle I want to
512:26 - draw a surface wherever the offset
512:29 - rectangle is this one we have created
512:32 - here
512:33 - since the offsite right now is 0 and 0
512:36 - this isn't going to do anything
512:39 - meaning if I run out of this once again
512:43 - there is no change whatsoever we always
512:45 - starting in the top left however what I
512:48 - can do now if I change this Vector to
512:51 - let's say something like
512:53 - 250 if I run this now and let me add a
512:57 - few more things in here
513:00 - now everything is drawn
513:03 - 200 pixels in this direction and 50
513:06 - pixels up
513:09 - this I can use
513:13 - by default though this Vector here
513:15 - should be 0 and 0.
513:18 - the way I want to use this offset this
513:20 - should always be relative to the player
513:22 - and in here I need
513:24 - self.offset.x and self dot offset dot y
513:28 - I want to get player.rect Dot Center
513:31 - either X or Y depending on what axis we
513:35 - are looking at and from that I want to
513:37 - subtract the window over to window with
513:40 - like so or the window height
513:44 - like so and both of these I want to
513:47 - divide by two
513:49 - what this basically means is imagine
513:51 - that this one here is the player and I
513:55 - want to draw everything else in the
513:57 - level so all of the tiles
513:59 - everything relative to the position of
514:03 - that player this means I want to look at
514:06 - the center of the player this is what
514:08 - I'm getting here and then the top left
514:11 - of the current part of the window should
514:14 - be half of the window width to the left
514:16 - that's what we are getting here
514:18 - and half the window size up this is what
514:21 - we are getting here
514:22 - the resulting point is going to be the
514:24 - top left of the window
514:26 - if I try this one now and let me draw
514:29 - lots of terrain tiles like so
514:33 - go to the level and now you can see we
514:36 - have a camera following the player
514:39 - and with that we have some basic camera
514:42 - logic
514:44 - so this one here is kind of all we need
514:46 - for the camera although there's one
514:49 - problem that I do want to account for if
514:52 - I run the level editor again and let me
514:54 - draw some terrain tiles and place lots
514:57 - of palm trees floating in the air
515:01 - that should make it a bit easy to
515:02 - illustrate what I'm talking about
515:05 - also a couple of background ones
515:09 - like so
515:12 - and run the entire now inside of the
515:15 - level
515:16 - the player this one actually worked
515:17 - really good I want the player to be on
515:20 - top of the background palm trees and
515:22 - behind the foregone palm trees at least
515:24 - for the stem bit
515:27 - I place them a tiny bit too high but the
515:30 - problem here right now is that the depth
515:32 - of all of these tiles is decided when we
515:35 - are creating them so the later Sprite is
515:38 - going to be created
515:40 - the more on top it is going to be which
515:43 - sometimes could mean that the player is
515:45 - behind a palm tree which I really want
515:49 - to avoid
515:52 - and for that inside of Sprites let me
515:55 - minimize the player
515:57 - I am
515:59 - going inside of generic going to add one
516:03 - more parameter
516:04 - that parameter I called that
516:07 - and that by default
516:09 - is going to be I have different settings
516:11 - actually down here
516:13 - we have the different layers of the
516:15 - level all the way in the back we have
516:17 - the clouds then we have the ocean then
516:19 - we have the background water and Main
516:21 - most things are going to be in Main
516:25 - which means the default argument let me
516:27 - copy level layers in here
516:31 - is going to be inside of main that way
516:34 - once again we don't have to make any
516:37 - change to the existing Sprites
516:40 - which would be a pain to do this I now
516:43 - want to turn into an attribute so
516:45 - self.zet is going to be Z for the block
516:48 - we can ignore this system entirely
516:50 - because the block doesn't really care
516:51 - about where it's drawn oh well it's not
516:53 - even drawn at all so this one doesn't
516:55 - matter at all next one for animated this
516:58 - one doesn't need that
517:00 - although here once again I want to have
517:03 - a default argument that I can just pass
517:05 - in there
517:07 - so we don't have to make any change to
517:08 - the existing parts and this is that I
517:11 - want to pass into the parent class like
517:14 - so
517:15 - and this is the only change we really
517:17 - have to make here inside of level let me
517:21 - minimize the camera group and the init
517:24 - method and I want to look at my build
517:26 - level
517:27 - in here when I'm creating these palm
517:30 - trees and these palm trees this is the
517:33 - only time where I really care about the
517:35 - depth because those always need to be in
517:37 - the background and this I can achieve by
517:40 - adding one more argument all the way in
517:42 - the back and this is level layers
517:46 - this is what we're getting from settings
517:48 - and in here we have the key BG so inside
517:52 - of settings we have BG
517:54 - that way all of these palm trees are
517:57 - going to be drawn in the background in
517:59 - particular behind Main the other place
518:02 - where I really have to care about this
518:04 - for now is when I'm creating the water
518:06 - this one here
518:08 - this one also is going to need another
518:11 - argument for the level layers and this
518:14 - one here I called water
518:17 - so in here we have water this one I want
518:20 - to be on top of the background but
518:22 - behind Main
518:24 - and with that we have the basic
518:26 - information for all of the layers if we
518:29 - don't specify this one here these
518:32 - Sprites are always going to be on the
518:33 - main layer
518:35 - and for all of those I'm pretty happy
518:37 - with them we only really care about
518:39 - these and the water tiles those need to
518:41 - be in the background
518:43 - all we have to do now is to actually
518:45 - implement the logic for this drawing
518:47 - which means when we are doing our custom
518:50 - draw we know that every single Sprite
518:53 - has a z parameter
518:55 - and this set parameter can be really
518:57 - useful to draw the level inside of a
519:00 - layered manner all I really want to do
519:02 - is for a layer in level layers dot
519:06 - values
519:08 - this is going to give me the numbers
519:09 - between 1 2 3 4 and 5. and this I can
519:14 - now check if I indent this information
519:18 - I only want to draw a certain layer if
519:20 - Sprite dot Z is equal to the layer and
519:25 - only if that is the case I want to draw
519:27 - all of this
519:30 - and with that we have different layers
519:32 - let me run the entire thing now and let
519:34 - me Place lots of palm trees I hope some
519:38 - of them are going to be visible
519:41 - well this is a slightly more difficult
519:43 - thing to test
519:44 - let's try this one
519:46 - and well at the very least this one is
519:49 - working and this one is more deliberate
519:52 - later on when we have the clouds you're
519:54 - going to see the system a bit more
519:56 - but this one by itself is a pretty good
519:58 - start
520:02 - so all right with that we have another
520:04 - major part
520:06 - now that we have the player we can work
520:08 - on the enemies the first enemy I want to
520:11 - work on is the shell for this one
520:14 - it doesn't damage the player on contact
520:17 - that way the player can stand on top of
520:19 - it I think that should already work
520:22 - however the shell does shoot a pearl and
520:24 - this one damages the player so what we
520:28 - basically have to figure out is if this
520:32 - one here is the shell we want to shoot a
520:35 - pearl whenever the player is in a
520:37 - certain distance let's say in this
520:39 - radius here
520:42 - let's have a look at that once again I'm
520:44 - on the code editor and I want to work
520:46 - inside of the level more specifically
520:49 - inside of build level where we are
520:52 - creating this shell that happens here
520:55 - bodies we have to do a couple of things
520:58 - number one is they need a
521:03 - I called this one a pearl image this is
521:06 - what they are going to shoot
521:08 - next up number two they need to know
521:13 - where the player is this one should be
521:18 - quite obvious I want them to shoot if
521:20 - the player is in a certain distance and
521:23 - once the player is I want them to start
521:25 - shooting this Pearl image
521:27 - once we have those two we can work
521:30 - inside of the shell and add the stuff
521:32 - that we need but let's get started with
521:35 - the Pearl image this one as before is
521:38 - going to be imported inside of imports I
521:42 - will do this right below the shell
521:44 - I want to call this self dot Pearl and
521:47 - this is literally just a single surface
521:49 - so I can use load again and the file
521:52 - path here is going to be one fold up
521:55 - graphics and there we have enemies
521:59 - and in there we have Pearl and pearl dot
522:02 - PNG also don't forget to convert Alpha
522:06 - all of this
522:08 - just to double check this
522:10 - here we are in the folder I want to go
522:12 - to graphics and there we have enemies
522:14 - there is Pearl and inside there we have
522:17 - this simple image that's called Pearl
522:19 - this is what we are going to import
522:21 - and this we now have to get into the
522:23 - level
522:26 - that is once again happening inside of
522:28 - the dictionary here and I want to have
522:31 - Pearl
522:33 - with self dot Perl
522:36 - all right now we have this available in
522:38 - here and for both of the shells let me
522:41 - put them on separate lines that's going
522:43 - to be a bit easier to read
522:45 - actually this is probably best if I use
522:49 - named arguments we have orientation then
522:54 - we have assets
522:57 - and we have position
523:01 - and then we have groups and then I can
523:04 - put all of this over multiple lines
523:08 - that is going to make everything so much
523:10 - easier to read
523:13 - like so much more visible
523:17 - and in here I want to add one more entry
523:21 - this is going to be let's call it the
523:24 - Pearl
523:25 - surface
523:28 - this we also get from the asset
523:30 - dictionary although in here this one I
523:33 - called Pearl that's the one we just
523:35 - imported this one here or this one here
523:39 - with that we have covered the first part
523:42 - we have a pearl image
523:44 - the next part is going to be a bit
523:47 - different because now we have to know
523:49 - where the player is
523:51 - unfortunately now we do have a problem
523:54 - because we couldn't just add the player
523:57 - in here as another argument the reason
523:59 - is we are only creating the player here
524:02 - and there's a reasonable chance that
524:04 - this player will be created after these
524:07 - shells
524:08 - which means if we try to pass the player
524:10 - in here the player might not exist yet
524:12 - which is well not ideal
524:16 - the easiest way I found around that is I
524:19 - created another Sprite group let me call
524:22 - itself and shell
524:25 - brights this group we do have to create
524:27 - so inside of a knit
524:30 - I want to create
524:32 - self.shell Sprites once again this is
524:36 - going to be pygame dot Sprite dot group
524:39 - and that way I can Target all of my
524:42 - shells quite easily
524:45 - this I can then use all the way at the
524:48 - end of this
524:50 - entire statement here
524:53 - all the way at the end of this I want to
524:56 - Loop through all of my shells
524:58 - which means for sprite in Self Storage
525:01 - shell Sprites
525:03 - I want to add Sprite dot player is going
525:06 - to be self dot layer and let me minimize
525:10 - the match data for Loop
525:13 - because this one here I want to have on
525:16 - the same notation level as this original
525:18 - for Loop but this is literally all we
525:21 - need here
525:22 - and with that I believe we are done with
525:25 - the second part
525:27 - let me get rid of it and now inside of
525:30 - Sprites I have to account for all of
525:33 - these parameters although I already see
525:35 - I made a typo this is group and this I
525:38 - called groups so let me fix this one the
525:41 - rest is looking pretty good though
525:44 - although we do need one more parameter
525:46 - and that is the Pearl surface
525:50 - this I also want to store let me add
525:53 - another section here that I called I
525:55 - guess Pearl works first of all I need
525:58 - the Pearl surface as an attribute so per
526:00 - surface is Pearl's surface
526:02 - besides that though I do want to have a
526:05 - few more attributes here the first one
526:07 - is has shot by default this one is going
526:11 - to be false
526:13 - next up I want to have an attack cool
526:16 - down and this one is going to be a timer
526:20 - fortunately we already created a time up
526:23 - way earlier
526:25 - if I open my files in here we have timer
526:28 - and I can reuse one of these timers
526:32 - so inside of Sprites I want to from
526:35 - timer import timer
526:39 - now we have to create a duration I went
526:42 - with two seconds or 2 000 milliseconds
526:44 - there's one more thing that I forgot to
526:46 - add and that is self dot damage group
526:50 - what this one means inside of the level
526:54 - again if the player touches spikes for
526:56 - example the player is supposed to later
526:59 - on get damaged because these spikes are
527:01 - inside of damaged Sprites
527:03 - any kind of sprite inside of this is
527:06 - going to damage the player if the player
527:07 - is in contact with it and I want the
527:10 - Pearl surface to be inside of this
527:13 - damage Sprites as well as a consequence
527:15 - since we are creating this pulse surface
527:18 - inside of the shell I want shell to have
527:21 - access to the damaged Sprites but not be
527:24 - in it itself
527:25 - which means I want to have another
527:28 - argument in here and let's call this the
527:31 - damage Sprites is going to be self dot
527:35 - damage Sprites
527:36 - this is kind of similar compared to the
527:38 - player this Sprite has access to the
527:40 - group but is not in the group itself
527:44 - but now inside of my Sprites again
527:48 - I can add I think I called this damage
527:50 - Sprites yep and those
527:54 - let me name this properly damaged
527:56 - Sprites is going to be damage Sprites
527:59 - right with that we have all of the
528:02 - parameters we are going to need for the
528:03 - Pearl
528:04 - which means now we can start to animate
528:07 - it adding here I want to have animate
528:09 - with self and Delta time as always and I
528:13 - want to have an update method that also
528:15 - gets self and Delta time and this one is
528:18 - going to call
528:20 - self.nmate with Delta time
528:23 - this we have seen a couple of times
528:24 - already and in here once again we have
528:28 - to get the actual animation so let me
528:30 - start off this in a separate variable
528:32 - that I get with self dot animation
528:34 - frames and self dot status this one so
528:38 - far is quite simple we only really have
528:40 - two statuses we have idle or attack so
528:44 - not much can go wrong here then I want
528:46 - to get self dot frame index plus equal
528:49 - the animation speed multiplied by Delta
528:52 - time this one should also be fairly
528:54 - straightforward but now we do have to
528:57 - make a change and that is if self dot
529:00 - frame index is greater or equal than the
529:03 - length of the anime not animation
529:06 - animation I think earlier I call this
529:09 - the current animation that probably
529:11 - makes a bit more sense like so I want to
529:13 - have a proper if statement and this is
529:16 - different compared to for example
529:17 - animated where I put everything on a
529:20 - single line the reason is inside of this
529:24 - line here when we are checking if the
529:26 - animation is ending I want to do a few
529:28 - more things
529:30 - although for now I want to set self dot
529:32 - frame index back to zero and at the end
529:35 - of all of this I want to set self dot
529:38 - image back to the S is the current
529:42 - animation with integer and self dot
529:46 - frame Index this animation here is
529:49 - basically the same thing that we have
529:51 - done up here except a bit less concise
529:55 - but the function is basically identical
529:57 - but let's try this one actually I
529:59 - haven't run the code in a while so let's
530:02 - check if everything is still working
530:04 - I want to create two shells let's run
530:07 - this entire thing it doesn't crash and
530:09 - that's looking pretty good and the
530:10 - player can also stand on the shelves so
530:12 - we are definitely making some progress
530:15 - although right now you can see
530:17 - that the shells don't do anything but at
530:20 - the very least nothing is crashing
530:22 - that's usually a good sign right now
530:24 - they are animated but they're not doing
530:26 - anything because they are idling and the
530:28 - idle animation is a single image so it
530:31 - looks like a static image for that we
530:34 - have to add a bit more logic and I guess
530:36 - I can put out of this inside of a get
530:39 - status method
530:41 - or this one we need self and nothing
530:43 - else all I really want to check in here
530:46 - is if player is close enough that could
530:51 - be a random number then I want to set
530:53 - self dot status
530:56 - to attack
530:58 - and if that is not the case so I want to
531:00 - have an else statement then self.status
531:04 - should be idle remember here we do have
531:08 - access to self.player because of this
531:11 - line here all the way at the bottom
531:13 - which is all you really need to figure
531:15 - out the distance between the player and
531:18 - the shell and if you want a specific
531:20 - number let's say if the player has less
531:23 - than 500 pixels between himself and the
531:25 - shell I want the shell to attack and
531:28 - this could be a good exercise for you
531:29 - try to use some math to figure out the
531:32 - distance between the player and the
531:33 - shell and if the player is closer than
531:35 - 500 the shell should have the status of
531:38 - attack pause the video now and try to
531:40 - figure this one out
531:44 - obviously this is going to be an if
531:46 - statement and first of all I need a
531:48 - position of my player and this I get
531:50 - with self dot
531:52 - player.rect dot Center this I want to
531:56 - turn into a vector
531:58 - with Vector because this allows me to
532:01 - use one specific method that is called
532:03 - distance
532:05 - 2 which is giving me the distance to
532:08 - another vector and the other Vector I
532:10 - want to look at is
532:12 - self.rect.center or at the center of the
532:15 - shell
532:16 - and if the resulting number is smaller
532:19 - than 500
532:21 - then the status should be attack however
532:24 - if that is not the case so else I want
532:27 - the status to be idle like so and I can
532:31 - get rid of this comment here
532:33 - and this is going to cover most of it so
532:36 - now before we animate we also call
532:38 - self.getstatus
532:41 - and let's try this one
532:43 - and let me add a longer level with a bit
532:46 - more stuff
532:48 - and I can play shells all throughout
532:51 - here
532:53 - let's try this
532:55 - and they can see the shells in the
532:57 - bottom are attacking so this one and
533:00 - this one is attacking but this one is
533:02 - just chilling
533:04 - however if I go closer
533:07 - at some point it starts attacking and
533:09 - they can see it perfectly this distance
533:11 - seems to working just fine
533:13 - cool
533:15 - also let me close the timer we don't
533:17 - need this one anymore now that we have
533:19 - that we can start to think about how to
533:22 - actually shoot a pearl and for that we
533:25 - need to work quite a bit more inside of
533:27 - this animate method
533:29 - but essentially all I really want to do
533:31 - in here is
533:32 - if a certain condition is true and there
533:35 - are quite a few in here let me go
533:37 - through them actually the first one is
533:39 - if in self dot frame index is equal to
533:43 - two
533:45 - this by itself is going to be kind of
533:47 - confusing I'm checking if we are on the
533:50 - third frame inside of the animation
533:51 - remember here we are starting at zero
533:54 - the reason why I'm choosing this Frame
533:56 - let me open the folder actually
533:59 - here we have it and we have Graphics
534:01 - enemies shell left and attack
534:05 - the frame we are looking at right now is
534:07 - this one here and I have chosen this one
534:09 - because this is the best frame to
534:10 - actually start creating the Pearl you
534:13 - can see here the shell is charging and
534:16 - here it's basically recovering so on
534:18 - this one I actually want to shoot it
534:20 - just imagine if it were on this Frame
534:22 - here and we would have one Pearl here it
534:25 - would look kind of silly because we have
534:27 - the Pearl in there and we're also
534:29 - shooting one that I want to avoid so I
534:31 - only want to create the Pearl if we are
534:33 - on this Frame that is this if statement
534:36 - here besides that obviously I also want
534:39 - to check if self dot status
534:42 - is equal to a tag this should be a
534:45 - comparison operator there we go and
534:47 - there's one more condition that we need
534:49 - and that is and not self
534:51 - dot has shot this one should be obvious
534:55 - once we have shot I want to run a timer
534:59 - that the shell can only shoot every two
535:02 - seconds
535:03 - that we are going to control up here
535:04 - with the timer
535:05 - and inside of here I need to do a couple
535:09 - of things I first of all need to get a
535:12 - pearl Direction so is the Pearl going
535:15 - left or right and this one is quite easy
535:18 - I want to have a vector with negative
535:20 - one and zero this one is going left if
535:23 - self dot orientation is equal to left
535:28 - this is the orientation we created
535:30 - earlier all the way at the top and this
535:33 - one is telling us what way the shell is
535:34 - facing if that is not the case so else I
535:37 - want to have a vector that goes 1 and 0.
535:41 - this one is going right
535:43 - once we have that I want to create a
535:46 - pearl for this one we are going to need
535:49 - another class I'm going to do that in a
535:51 - second but for now I just want to print
535:54 - Pearl was shot
535:57 - this we're going to replace in just a
535:59 - bit and after I have done that I also
536:02 - want to set self.hashot to true
536:06 - that way we're not going to trigger this
536:08 - multiple times what we now have to
536:10 - figure out is how to reset this
536:12 - self.hash shot and for that we have the
536:15 - timer up here and basically what I want
536:18 - to do after we set the self.frame index
536:21 - back to zero I want to check if self dot
536:24 - has shot is true which is going to be
536:27 - the case after we have short
536:29 - or after we have run this if statement
536:31 - here if that is the case I want to
536:34 - activate my attack cooldown which I do
536:37 - with activate
536:39 - and besides that I also want to set self
536:42 - dot has shot back to false with these
536:46 - two lines I can look at this get status
536:50 - again because I only want the status to
536:53 - be attack if the player is close enough
536:56 - and self dot attack cooldown
537:00 - is not active which means I want to have
537:04 - a not in here
537:06 - that way after we have activated this
537:08 - timer here the shell cannot attack which
537:11 - means this entire statement here would
537:13 - not be run the last thing we have to do
537:16 - is to update the timer so self dot it
537:20 - tag cooldown I called it dot update and
537:23 - with that we should be good to go and I
537:27 - just realized this one should be an end
537:29 - instead of an if
537:31 - this is looking much better so now let's
537:34 - try this
537:35 - and let me just create one shell then we
537:40 - can test this a bit better
537:42 - so right now it doesn't do anything
537:44 - because the player is too far but if we
537:46 - get close enough we get probably shot
537:48 - and there again after about two seconds
537:51 - and this keeps on going so this is
537:54 - looking pretty good
537:56 - and for this one it might be kind of
537:59 - hard to follow the logic I would
538:00 - definitely go over this a couple of
538:02 - times
538:03 - you want to understand how this part
538:05 - this part and this part here interact
538:08 - with each other but in my case I am
538:10 - going to continue and I'm going to
538:12 - create another class
538:15 - that is going to be the Pearl
538:18 - this one as always is going to inherit
538:20 - from generic and in here I want to have
538:23 - an init method
538:25 - for this one we need itself we need a
538:27 - position we need a direction we need a
538:31 - surface and we need a group and first
538:34 - thing that we are going to do in here is
538:36 - a super init method
538:39 - this one is going to come from generic
538:42 - so we need positions surface and group
538:44 - that's the stuff we are getting all the
538:47 - way to top here position surface and
538:49 - group that we can just ignore
538:53 - we now need a few more things first of
538:56 - all since this Pearl is going to be
538:57 - moving we need some movement attributes
538:59 - we want self.position and this is going
539:03 - to be a vector and a position here is
539:06 - self.rect dot top left
539:09 - besides that I want to have
539:10 - self.direction and this is the direction
539:13 - we are getting from the parameters
539:16 - this direction here we're just going to
539:18 - pass in here finally this one needs self
539:20 - Dot
539:22 - speed and I've set this one to 150.
539:25 - finally I want to have a self-destruct
539:29 - mechanism because this Pearl if we
539:32 - didn't destroy it would keep on going
539:34 - forever and at some point we would have
539:35 - too many of them
539:37 - for that I'm going to create self.timer
539:40 - and this is going to be the time up we
539:42 - have already seen
539:43 - and I want to have a duration here of 6
539:46 - seconds and after these six seconds are
539:49 - over I want to destroy this entire
539:51 - object
539:52 - which means right when I create this
539:55 - Pearl I want to activate the timer
539:59 - like so activate
540:02 - with that covered I can create an update
540:06 - method and here we need self and data
540:08 - time
540:09 - and now we have to figure out the
540:11 - movement and the timer for this class
540:13 - and I think this could be a good
540:16 - exercise for you
540:17 - move this Perl here in the direction by
540:21 - a certain speed this is either going to
540:23 - be left or right for the direction and
540:26 - then after the time has over destroy the
540:28 - entire class
540:30 - and if you want to go further you can
540:32 - also create the Pearl right in here as
540:35 - well and see if this one is going to
540:36 - work so possibly now and try to figure
540:39 - all of this out
540:43 - I want to have
540:45 - self.post.x plus equal self dot
540:48 - Direction dot X
540:50 - multiplied by self dot speech multiplied
540:54 - by Delta time
540:56 - this is going to give me new position
540:58 - and this position I'm going to use to
541:01 - update the rectangle which I'm doing
541:03 - with round self dot pause dot X
541:06 - and that is all we need for the movement
541:08 - next up for a timer I first of all want
541:11 - to self dot timer dot update so the
541:14 - thing actually runs
541:15 - and now I can check if self.timer is
541:19 - active
541:20 - but I only really care if this is not
541:24 - active and if that is the case I want to
541:27 - destroy the Sprite with the kill method
541:30 - and with that we have the Pearl I am
541:33 - going to copy the parameters and
541:35 - minimize this thing and now inside of
541:38 - these two lines here I can create a
541:41 - pearl with these arguments the direction
541:44 - we already have this is the Purl
541:46 - Direction surface we also have this is
541:50 - self dot Pearl surface
541:52 - bought a group
541:54 - we are going to need two important
541:56 - groups in here the first one is self dot
541:59 - damage Sprites this one should be
542:01 - obvious this is what we're getting from
542:03 - here
542:04 - however there's one more group that we
542:06 - need and that is all Sprites and this we
542:09 - absolutely need because this one is the
542:11 - only group that draws anything
542:13 - unfortunately we don't have all Sprites
542:16 - easily available but we do know when we
542:20 - are creating the shell
542:22 - we are assigning self.uspirites as the
542:26 - first group inside of this list and this
542:28 - we can use because this list is always
542:31 - ordered and we can access it so inside
542:34 - of Sprites when I am creating the Pearl
542:37 - besides the damaged Sprites I also want
542:40 - to get self Dot
542:43 - groups don't forget to call this and
542:46 - this is going to return a list with all
542:48 - of the groups that this shell Sprite is
542:50 - in and I want to get the first one this
542:53 - is going to be all Sprites Auto make
542:55 - sure here that you have the same order
542:56 - if this all Sprites for somewhere else
542:58 - you would need a different index
543:00 - but with that we have a pearl let's try
543:05 - so I can run the entire thing let me
543:07 - create a longer level and let me create
543:11 - two shells
543:14 - and now we're getting an error the
543:16 - reason is that this position has not
543:19 - been defined but that we can do quite
543:20 - easily I want to create this Pearl
543:24 - wherever
543:26 - self.rect.center is
543:28 - now let's try this again
543:31 - and I want to create a few more terrain
543:35 - tiles and let's put a shell here
543:38 - right now nothing happens but if I get
543:40 - close enough we are getting one shell
543:43 - two shells this is not looking bad at
543:46 - all the issue is
543:48 - right now the shell is a bit offset and
543:51 - this makes the entire thing look a bit
543:53 - weird so when we are creating the
543:55 - position of the shell I mean the Pearl
543:57 - we need to get an offset
544:00 - inside of this if statement here
544:03 - I want to have an offset and for this
544:07 - one I first of all need to get my Purl
544:10 - Direction and multiply this by 50. but
544:14 - this I only want to do if self dot
544:17 - orientation is equal to left
544:20 - if that is not the case else I want to
544:24 - get an offset and the number I found for
544:27 - this one is 20. the different sites here
544:30 - look a bit different so these numbers
544:32 - are necessarily equal
544:34 - but once we have that remember Pearl
544:37 - direction is a vector so we can just add
544:39 - this to the position and now this should
544:42 - be looking a bit better and let me try
544:45 - to add two shells here like so and so
544:51 - and now this is already looking much
544:55 - better
544:57 - the only problem now is that all of
544:59 - these pearls are a bit too low which I
545:02 - also don't really like so if you look at
545:03 - them they don't really align with the
545:05 - mouth of the shell or the opening or
545:07 - whatever it's called
545:09 - which means I want to have a bit more to
545:11 - this offset or both if statements I want
545:15 - to add plus vector and this is going to
545:18 - be 0 for x and 10 for y this should
545:22 - actually be negative 10 because we are
545:24 - going upwards and now let's try this
545:26 - again I want to create
545:29 - two more shells
545:35 - and now
545:37 - this is looking much better so I'm quite
545:40 - happy with this
545:42 - with that we are concluding the shell
545:45 - now obviously the player is not going to
545:47 - be heard by the Pearl but that I want to
545:49 - have in a separate chapter there we are
545:51 - going to add the interaction between the
545:53 - player and all of the enemies but next
545:55 - up let's work on tooth that's the other
545:57 - major enemy so let's start working on
546:00 - tooth and tooth is ultimately not that
546:03 - difficult he basically runs around and
546:06 - reverses Direction every time he
546:08 - collides with an obstacle or a cliff
546:10 - importantly here he doesn't actually
546:13 - have gravity he just moves left and
546:15 - right that is much easier to calculate
546:17 - that's kind of all we need so let's Jump
546:21 - Right In and let's have a look once
546:23 - again we are in the code editor and in
546:26 - here we first of all need the tooth
546:28 - Graphics those fortunately we already
546:31 - have we imported them way earlier
546:34 - so this I don't have to worry about
546:36 - which means inside of level
546:39 - we are creating two in this line here
546:45 - and most of this is perfectly fine that
546:48 - being said there's one thing that I do
546:51 - want to add and let me add tooth on the
546:53 - next line
546:55 - since tooth needs to reverse if there's
546:57 - some kind of collision tooth has to know
547:00 - where all of the Collision objects are
547:02 - as a consequence I'm going to add one
547:05 - more argument in here and that is
547:07 - self.collision Sprites
547:10 - with that kind of like the player tooth
547:14 - is inside of all of these groups but
547:16 - also has access to the Collision Sprites
547:18 - although he himself is not in it but
547:21 - once we have that I can work inside of
547:24 - the Sprites and I want to flesh out
547:25 - tooth right now he's quite simple and he
547:29 - needs Collision Sprites
547:32 - I want to start by creating a movement
547:35 - section and let me add in section here
547:39 - let's call it the general setup
547:42 - like for the Pearl we need
547:44 - self.direction first of all and this by
547:47 - default is going to be a vector that
547:49 - points at 1 and 0. although actually
547:52 - while we are here we could randomize
547:54 - this a tiny bit and for that I want to
547:57 - have
547:59 - from random import choice
548:03 - and this choice I want to use with
548:05 - Choice and then here I can pass in
548:08 - if one or a negative one that way the
548:12 - start direction is ever going to be left
548:13 - or right
548:15 - next up we need to position this we get
548:18 - once again as a vector and then here
548:21 - self.rect dot top left this should look
548:25 - like this
548:27 - finally I need a speed so self dot speed
548:30 - is going to be a hundred and twenty
548:33 - and I did forget we do need to turn the
548:36 - Collision Sprites into an actual
548:38 - attribute so Collision Sprites here and
548:40 - then we are good to go
548:42 - however there's one more thing that I do
548:44 - want to do and that is to destroy tooth
548:49 - at the beginning
548:51 - [Music]
548:52 - like so if e is not on a lore
548:58 - the reason here is tooth is going to
549:00 - move left and right and it's going to
549:02 - switch Direction every time he faces a
549:04 - cliff and there's no gravity for him
549:07 - whatsoever the problem with that is if
549:09 - we place them in the air it would look
549:11 - really weird so I want to add the logic
549:14 - that if tooth is just placed somewhere
549:17 - in the air without a floor tile I just
549:20 - want to destroy him right away and that
549:22 - could be a really good exercise for you
549:24 - try to figure out at the beginning when
549:27 - we are creating the Sprite if tooth is
549:29 - standing on the floor or not and if not
549:31 - destroy the Sprite immediately
549:36 - to figure out if tooth is standing on
549:39 - the floor I want to use list
549:41 - comprehension in here I want Sprite for
549:43 - sprite in Collision Sprites that's why I
549:49 - am checking all of the Collision Sprites
549:51 - but I only want to get a Sprite if
549:54 - sprite.racked dot Collide point
549:58 - and this point is going to be
550:00 - self.direct dot mid bottom and plus a
550:05 - vector of 0 and 10. that's why I'm
550:09 - checking if there's a point below the
550:12 - player and I'm going to check all of my
550:14 - Sprites in Collision Sprites if they are
550:16 - colliding with that
550:18 - this is then going to return a list and
550:22 - if this list is empty I know there's
550:25 - nothing below the player which means I
550:27 - want to destroy the Sprite this we can
550:31 - actually test right away let me run
550:32 - main.pi again and let's create a few
550:36 - terrain tiles and let's place two here
550:39 - here
550:40 - and then let's say here and here and
550:43 - let's see what happens
550:45 - and they can see all the ones in the air
550:47 - just disappeared so this is looking
550:50 - pretty good
550:51 - that's a very nice Safeguard and once we
550:55 - have that we can work on the other bits
550:58 - in here first of all I want to have an
551:00 - animate method as always with self and
551:03 - Delta time
551:04 - and this one is actually going to be
551:06 - quite simple
551:07 - so current animation
551:10 - [Music]
551:11 - is going to be self dot frames
551:15 - and for this one I want to have an F
551:18 - string and we always want to have run
551:20 - and the other thing we need is self dot
551:23 - orientation remember this is also what
551:26 - we got earlier up here
551:28 - although once I have this bit the rest
551:31 - is going to be very simple I want to
551:32 - increase self.frame index by the
551:35 - animation speed multiplied by Delta time
551:38 - and besides that I want to set self dot
551:42 - frame index to zero if self dot frame
551:47 - index is greater or equal than the
551:50 - length of the current animation
551:52 - and else I want to keep self dot frame
551:56 - index
551:57 - and finally I want to set self dot image
552:00 - to the current animation with self.frame
552:04 - index with cell frame index being an
552:07 - integer
552:09 - this we have already done a couple of
552:12 - times and well shouldn't be too
552:14 - difficult at this point
552:16 - once we have that I can call the update
552:19 - method with self and Delta time and
552:22 - actually call
552:23 - self.animate with Delta time and let's
552:26 - try
552:27 - if I run this again and select tooth
552:33 - we are getting an error that we have no
552:36 - frames because this frames here I called
552:39 - animation frames
552:42 - next attempt let's try this
552:46 - so
552:48 - and there we go now we have an animation
552:51 - looks pretty good we just have to move
552:54 - him now
552:55 - for that I'm going to create another
552:57 - method self dot move this one also needs
553:00 - Delta time
553:01 - in here move and solve with Delta time
553:06 - in the most basic sense all I want here
553:08 - is self.post.x plus equal self dot
553:12 - Direction dot X multiplied by self dot
553:16 - speed multiplied by Delta time we have
553:19 - seen this plenty of times already and
553:20 - once I have that self.rect dot X is
553:24 - going to be round self dot pause dot X
553:28 - with this I can run this one more time
553:31 - and let me place a few things here
553:36 - I can place two in many different places
553:41 - run the entire thing and there you can
553:43 - see they are moving except we have no
553:46 - bottom Collision so not ideal yet but at
553:49 - least something is happening
553:51 - now we have to figure out how to limit
553:54 - this movement only to a platform
553:57 - and for that what I have done
554:00 - this one here is tooth and I'm going to
554:03 - create a gap rectangle here and here and
554:09 - I'm also going to create a wall
554:10 - rectangle here and here
554:13 - the red ones here are checking for a
554:15 - cliff and the green ones are going to
554:17 - check for a wall and if there's any
554:20 - collision with any of them I'm going to
554:22 - change the direction so for example if
554:25 - tooth is moving to the right and there's
554:27 - a collision either with the green
554:28 - rectangle or there's no collision with
554:31 - this rectangle I want to reverse the
554:34 - direction
554:35 - to the left
554:37 - for that first of all I have to create a
554:40 - couple of things
554:41 - I want to have a right Gap I want to
554:45 - have a right
554:46 - lock
554:48 - then I want to have a left Gap and I
554:51 - want to have a left lock
554:54 - all of these unfortunately are going to
554:56 - have different positions for the right
554:58 - Gap or the right Cliff or whatever you
555:00 - want to call it I want to have
555:03 - self.rect.bot right and then here I want
555:06 - to add a vector that is one and one
555:10 - this means if this one here is tooth I
555:14 - am getting this bottom position and I am
555:17 - moving one and one pixel to the right
555:20 - and down next up for the right block I
555:23 - want to have self.rect dot mid right
555:26 - that is horrible spelling midrite and
555:28 - then here a vector that is one and zero
555:32 - for the left block this one is going to
555:35 - be self.rect dot bottom left
555:39 - plus a vector of negative one and one
555:44 - for this one we're going one to the left
555:46 - and one down finally the left block is
555:49 - self.direct dot mid left plus a vector
555:54 - of negative one and zero with that we
555:57 - have all of the different blocks we want
555:59 - to check now we just have to use them
556:01 - and then here first of all I want to
556:03 - check my Direction so self dot Direction
556:06 - dot X is greater than zero this means we
556:11 - are moving right
556:14 - we now have to check two conditions
556:16 - number one is going to be
556:20 - no floor Collision
556:23 - and number two is going to be a wall
556:26 - Collision
556:28 - the idea here is if this bottom right
556:31 - point doesn't have contact with the
556:33 - floor we know that tooth is facing a
556:35 - cliff and tooth should return this is
556:37 - going to be this part here
556:39 - the second part is going to be the wall
556:41 - collision and this we're checking with
556:43 - this point
556:45 - and all I'm really checking here is if
556:47 - there's any kind of collision with the
556:50 - wall and if that is the case I want two
556:52 - to return as well all of this by the way
556:54 - is going to look kinda similar compared
556:56 - to what we have done up here
556:58 - which means this could be an interesting
557:01 - exercise
557:02 - try to check those two conditions to see
557:04 - if tooth is either facing a cliff or a
557:08 - wall if that is the case I want to
557:10 - change direction.x and multiply it
557:15 - with negative one and self dot
557:18 - orientation is going to be left
557:22 - that is all you need for the movement so
557:24 - you have to figure out this if statement
557:26 - here try to see if you can do it
557:31 - I am going to put all of this over
557:33 - multiple lines that is going to make it
557:34 - much easier to read
557:36 - and let me call it floor Sprites for
557:40 - this one once again I want to have list
557:42 - comprehension and in here I want Sprite
557:44 - for sprite in self dot Collision Sprites
557:49 - this is going to copy all of the Sprites
557:51 - but I want to add an if condition that I
557:54 - only want a Sprite if sprite.racked dot
557:57 - Collide point with my right Gap
558:02 - this way I know if there's going to be a
558:05 - collision between the bottom point of my
558:08 - player this one here and the floor and
558:11 - if this list here is empty I know there
558:13 - is a cliff this I guess I can now copy
558:16 - and call it wall Sprites for this one I
558:21 - want to check the point right lock
558:25 - like so
558:26 - but the rest can stay basically
558:28 - identical
558:29 - once I have those two conditions I can
558:33 - I guess let me put the comments here a
558:35 - bit more proper once I have those two I
558:38 - can check if
558:39 - we have Wall Sprites or not lore
558:45 - rights then I want to do all of this
558:49 - the idea here is if there's anything
558:51 - inside of the wall Sprites or if lowest
558:54 - price is empty if either of those two is
558:57 - true then I know the players facing a
558:59 - wall or a cliff and should reverse
559:01 - Direction this we can test right away
559:03 - let me add a few platforms because I
559:06 - can't control the starting direction of
559:09 - tooth so let me just create a bunch of
559:12 - them and at least one of them should
559:14 - work out
559:16 - there we go and now on the right side
559:18 - you can see they are reversing
559:21 - this is looking pretty good and also if
559:24 - I add a wall in here let me do it for
559:26 - this one
559:27 - and run the entire thing you can see
559:30 - this is also working
559:32 - cool so this is definitely working now
559:36 - we just have to cover the other side and
559:38 - that part is going to be your exercise
559:41 - so possibly now and see if you can
559:44 - figure this one out
559:48 - first of all I want to check if
559:51 - self.direction.x is smaller than zero
559:54 - that means we are moving left
559:56 - and after I have that I guess I can copy
559:59 - all of this
560:01 - although now I want to check the left
560:04 - Gap and the left block
560:08 - and if that is the case these two are
560:10 - still working out as is this one but now
560:13 - the orientation should be right
560:16 - and by the way in actual code what you
560:19 - would probably do is not declare
560:21 - separate variables but instead
560:24 - you could do list comprehension right
560:27 - away inside of the if statement
560:29 - and if you add a line break this isn't
560:33 - even that hard to read like so and then
560:35 - I can get rid of these statements here
560:39 - although I did realize here I flipped
560:42 - the thingies so this should be like this
560:46 - we want to reverse direction if there's
560:48 - a collision with the wall or if there is
560:51 - not a collision with the floor
560:55 - so now let's try this
560:57 - everything is still working let me
560:59 - create a couple of terrain tiles and
561:03 - place tooth in here
561:06 - and now this is almost working
561:14 - so this is quite good the only problem
561:17 - is if I'm starting all of this again
561:20 - when we are starting
561:23 - at the beginning we have a random
561:25 - Direction this is what we are getting I
561:28 - can minimize move and animate
561:32 - when we're getting this random Direction
561:34 - here we are not updating the orientation
561:37 - that way it could happen that tooth is
561:39 - moving to the left while having the
561:42 - right orientation
561:43 - to fix that all we have to do is
561:45 - self.orientation
561:48 - is going to be left
561:52 - if
561:54 - self dot Direction dot X is smaller than
561:57 - 0 and else it is going to be right
562:02 - now we can try this again and let me add
562:05 - lots of platforms here
562:08 - it's not this one
562:10 - and now we can actually play around with
562:12 - this quite a bit because we have a fair
562:15 - bit of elements available oh and by the
562:18 - way since a shell is also considered a
562:21 - obstacle this one should also work as a
562:24 - limiter and this is looking pretty good
562:31 - so and complain about this one
562:36 - very happy with it
562:39 - obviously once again the player can't be
562:41 - hurt by tooth but that is going to be
562:44 - the next section actually
562:46 - but for this one we have once again made
562:48 - a ton of progress
562:51 - now that we have all of the enemies we
562:53 - can work on the player damage and this
562:56 - one basically means the player gets
562:58 - damaged when there is contact with the
563:00 - spikes the pearls or tooth and direction
563:02 - of the player is going to be a jump and
563:04 - a white Flash
563:06 - I didn't Implement a proper Health
563:08 - mechanic because I think this is already
563:11 - our 10 of this tutorial
563:13 - and well I do want to keep things at
563:16 - least somewhat focused but you could
563:19 - very easily implement this yourself
563:21 - finally we're going to need a mask for
563:24 - every object so the player despite the
563:26 - pearls and two that way we have much
563:29 - more precise collisions it's going to be
563:32 - really important for a platformer that
563:34 - is all we need so let's Jump Right In
563:36 - and let's have a look we are back in the
563:38 - code editor and the first thing that we
563:40 - have to do is to give all important
563:43 - objects a proper mask that way we have
563:47 - more specific collisions let's start
563:49 - with the spikes because that's the
563:51 - easiest one in here we are basically
563:54 - copying the generic Sprite on top of
563:56 - that I want to give this one a mask that
563:59 - we get with pygame DOT mask Dot from
564:02 - underscore surface added here I want to
564:05 - pass in self.image that way these Spikes
564:09 - have a mask which is much better for
564:11 - collisions this I do want to copy
564:13 - because we're going to use it a couple
564:15 - of times for tooth
564:18 - after we are doing all of this I also
564:21 - want to assign a mask however for all of
564:24 - these animated enemies after we are
564:26 - doing animation we also have to assign a
564:28 - new mask because in here the surface has
564:31 - changed not by very much but it's still
564:33 - good practice but that is all we need
564:36 - for the shell we don't need to do
564:39 - anything but for the Pearl we do need to
564:41 - add a mask this we can do right here and
564:44 - since this one doesn't animate we can
564:46 - just leave it here
564:47 - finally for the player
564:50 - all the way at the top I want to have a
564:52 - mask and now after every animation I
564:56 - want to have another mask or I want to
564:58 - update the mask and with that all of the
565:01 - important objects have a mask and this I
565:04 - can now use inside of level four
565:06 - collisions
565:07 - I am going to add another method below
565:10 - get coins because this one I want to
565:13 - call get damage there's no need for
565:16 - custom parameters in here and I want to
565:19 - get my Collision Sprites this I get with
565:22 - pygame DOT Sprite dot Sprite Collide and
565:27 - here first of all I need a Sprite that
565:29 - is myself dot player then I need a group
565:32 - for this one I have self dot damage
565:35 - Sprites
565:36 - then I want to kill so do I want to kill
565:39 - the Sprite my players colliding with in
565:41 - my case this is false finally we have to
565:44 - tell this method that we want to use a
565:46 - mask for the collisions that we get with
565:48 - pygam.spright DOT Collide underscore
565:51 - mask
565:53 - and once we have that I can simply check
565:55 - if there's any kind of Sprite in there
565:57 - so if Collision Sprites then self dot
566:02 - player and here I want to run a damage
566:05 - method this is going to happen inside of
566:08 - the player so in here let me do it all
566:11 - the way at the top Define damage funnel
566:15 - self and nothing else and I want to
566:17 - print
566:18 - ouch
566:20 - let's try this one and I want to have a
566:23 - couple of different elements here I want
566:25 - to have spikes I want to have two and I
566:28 - want to have this shell
566:31 - and I guess also a palm tree so the
566:34 - player isn't always a danger
566:37 - so if I collide with the spikes nothing
566:40 - is happening in fact nothing is
566:42 - happening at all and I can already tell
566:44 - why because I am not calling this get
566:47 - damage this happens inside of the run
566:49 - method in here self dot get not coins
566:53 - but damage
566:55 - next attempt let's try this again just
566:59 - with the spikes
567:02 - and we are getting an error
567:05 - because in here I have a typo
567:09 - next attempt let's see if this is
567:11 - working now
567:14 - that seems good and I get ouch this is
567:17 - definitely working
567:19 - so once I have that I can also place two
567:22 - and the shell and now let's try this
567:25 - again
567:26 - oh this one is still working and if I
567:28 - get hit by a shell we also get some
567:30 - updates this seems to be working pretty
567:33 - good we can't see too much yet but at
567:35 - the very least it's something
567:38 - okay so with that I can flesh out the
567:42 - player damage and what is going to
567:44 - happen
567:45 - first of all in here I want to have a
567:47 - timer this I call Self dot
567:50 - invulnerability timer
567:53 - and this is going to be timer with a
567:54 - duration of 200 which means after the
567:57 - player was damaged I want the player to
567:59 - be invulnerable for 200 milliseconds
568:03 - and I only want to be able to damage the
568:05 - player if this timer is not active so if
568:08 - not self dot inverldtimer dot active
568:13 - and we are calling this method then I
568:15 - want to start the involved timer with
568:18 - the activate method and then I want to
568:21 - make the player jump so self dot
568:23 - Direction dot y
568:25 - minus equal 1.5 I think was a good
568:28 - number
568:29 - we do have to make sure though that we
568:32 - are updating the timer all the way at
568:34 - the bottom actually let's do it right
568:36 - here
568:38 - self.inveltimer dot update and I think
568:41 - there are a bit too many methods open
568:43 - this is going to be confusing
568:46 - we don't need any of this or this or
568:49 - this
568:50 - the gravity can also go so this is
568:53 - basically all we need for now like so
568:57 - what we're doing is we are updating the
568:59 - timer constantly and we are only
569:01 - allowing damage if this timer is not
569:04 - active and by default it is not
569:06 - so let's try this and I'm just going to
569:09 - use some spikes and let's see if this
569:11 - has been working and there we go the
569:13 - player is jumping
569:17 - and this is at least something once
569:20 - again you could flesh this one out quite
569:22 - a bit more but well for this part it's
569:24 - pretty good I think
569:26 - finally what I also want to do this is
569:29 - going to happen inside of animate
569:32 - if the player is being damaged which
569:35 - means if self dot involt timer is active
569:39 - if that is the case
569:42 - I want to make the entire player flash
569:44 - white and for that I need a new Surface
569:47 - and this surface is going to be self dot
569:52 - mask
569:54 - and this I want to turn to a surface
569:58 - in this surface I want to set as the
570:01 - image so self load image is going to be
570:03 - this surface
570:05 - with that let me actually show what we
570:07 - get
570:09 - with some spikes
570:11 - and now we are getting something the
570:15 - problem here is this looks weird because
570:16 - we have the black background but other
570:19 - than that we are basically using the
570:21 - mask to create a new Surface and this
570:23 - turns the entire surface into a black
570:27 - and white silhouette kind of thing
570:29 - to make it look actually good we have to
570:31 - get rid of the black part and this we
570:33 - get with surface and set underscore
570:35 - color key and the color key I want to
570:38 - get rid of is going to be black this
570:40 - color key gets rid of one particular
570:43 - color inside of a surface which in my
570:45 - case is black that way we only have the
570:49 - white color left and now let me add a
570:52 - shell
570:53 - and let me shoot it and there we go we
570:56 - have some interaction
571:00 - so with that
571:02 - we have the interactions between the
571:04 - player and the enemies I guess I should
571:06 - try this one more time with tooth to
571:09 - make sure this one is working as well
571:11 - and there we go
571:13 - we also have collisions obviously we
571:15 - couldn't hurt tooth but well that could
571:18 - be your own project
571:21 - but with that we have the interactions
571:24 - between the player and the enemies
571:26 - another major step
571:29 - we are nearly finished the last major
571:32 - part is to create the sky this one is
571:36 - going to be like in the editor we have
571:38 - to create clouds continuously besides
571:41 - that we also have to create the Horizon
571:42 - and at this point if you still follow
571:45 - along this shouldn't be too difficult
571:47 - given that we have done this before I
571:50 - want to work inside of a level once
571:52 - again and in here I have to do a couple
571:55 - of things
571:56 - most importantly I guess we can start
571:59 - with the Horizon this we get when I'm
572:01 - building the level we also have case one
572:04 - this one is the sky and this I want to
572:07 - use in two ways first of all I want to
572:10 - create self dot Horizon this is the
572:13 - information I'm getting from position
572:15 - one if you remember ages ago when we
572:19 - created the editor
572:20 - this guy handle is what we are looking
572:23 - for right now and the sky handle is
572:25 - going to be inside of the canvas groups
572:31 - this one here actually and on this
572:33 - object we really just care about the Y
572:35 - position this is going to be our Horizon
572:37 - this we need to have available inside of
572:40 - our level and also inside of all Sprites
572:43 - so self dot all Sprites dot Horizon Y is
572:48 - going to be pause one we need it in both
572:51 - because we're going to create the clouds
572:53 - inside of the level so in here and we're
572:55 - going to draw all of them inside of all
572:58 - Sprites so both need this but this is
573:01 - all we need here so besides that inside
573:05 - of the camera group I want to add one
573:09 - more method and that is going to be raw
573:13 - or ryzen for this one and itself and
573:17 - nothing else
573:18 - in here first of all we need a y
573:21 - position and this I stored in a separate
573:23 - variable let me call it Horizon
573:27 - position
573:29 - for this one we need
573:32 - self.orizon.y this is what we already
573:34 - have but from this I want to subtract
573:37 - the self.offset dot y that way this one
573:41 - scales along with the player and now I
573:44 - can check if the Horizon position is
573:49 - smaller than the window height
573:52 - if that is the case once again I can
573:55 - create a rectangle and this is going to
573:57 - be pygame Dot rect and now we need left
573:59 - top width and height left is going to be
574:03 - zero top is going to be the Horizon
574:07 - position width is going to be the window
574:11 - width and height is going to be the
574:13 - window height
574:15 - minus the Horizon position meaning this
574:19 - one here is going to be our C this I can
574:22 - draw right away
574:24 - pygame.row.rect and self dot display
574:27 - surface
574:29 - here I have a c color I believe I called
574:32 - it this we get in settings we have C
574:35 - color this is what I want to draw
574:37 - and finally I want to draw this
574:39 - rectangle and I guess I should name it
574:41 - properly it should be the C rectangle
574:44 - all I have to do now is to call this and
574:47 - this importantly here I have to do
574:49 - before I'm drawing all of the Sprites
574:51 - self dot draw Horizon the reason should
574:54 - be obvious all of this should be in the
574:56 - background
574:57 - so let's try this one now I don't have
574:59 - to draw too much
575:01 - and we're getting an error
575:03 - the reason is I made a typo somewhere
575:07 - this should be Horizon position instead
575:10 - of horizon y I made the same mistake
575:12 - here and here
575:15 - now let's try this next attempt
575:19 - like so and there we go this is looking
575:22 - really good
575:24 - and now that we have that position we
575:26 - can draw up all of the other things
575:28 - which in my case means I want to have
575:31 - the horizon line that is the white line
575:34 - and then I want to have the three extra
575:37 - rectangles
575:40 - this if you look back at the editor Let
575:43 - Me minimize everything in here
575:46 - at some point instead of drawing the sky
575:49 - I think it was in here yeah in here I
575:52 - basically want to do this thing again
575:54 - and this could be an exercise for you
575:56 - inside of the level draw all of the
575:59 - stuff we used to see inside of the
576:00 - editor you could even copy it quite a
576:03 - bit of this is similar so pause the
576:05 - video now and try to figure this one out
576:10 - I guess the easiest way to approach this
576:12 - is to just literally copy all of them
576:14 - and paste them in here since the naming
576:17 - here I am using the same display surface
576:20 - this should actually still work although
576:22 - the one change I do have to make is this
576:24 - isn't y anymore now this is the Horizon
576:27 - position
576:28 - now if I try this and create some tiles
576:32 - and there we go
576:34 - with that we have a horizon we just need
576:37 - the line in between
576:39 - this I am getting
576:42 - with pygame DOT draw dot line and then
576:45 - here self dot display surface the color
576:49 - is going to be inside of settings I call
576:52 - this one the Horizon color I believe
576:55 - like so
576:57 - and now I need X and Y for the start
577:00 - point and I need X and Y for the end
577:04 - point the line width is going to be 3. X
577:07 - is going to be super simple because this
577:09 - is going to be 0 and the window width Y
577:13 - is also going to be quite simple because
577:15 - for this one I want to have the Horizon
577:17 - position
577:18 - and now let's try this one
577:22 - and there we go
577:24 - I am very happy with this with that we
577:27 - have some background
577:28 - all we have to do now is to figure out
577:30 - the clouds so I can minimize this method
577:33 - here although I guess what we could be
577:36 - doing is
577:38 - if the Horizon position is on top of the
577:42 - entire window
577:44 - so to draw all of this if this one here
577:46 - is the display surface and what we have
577:49 - checked here
577:50 - is if the Horizon is somewhere below the
577:55 - window height what we can also check is
577:58 - if the Horizon is somewhere up here that
578:01 - way I want to fill the entire surface
578:05 - with a blue color
578:06 - which means if the Horizon position is
578:09 - below zero
578:10 - then self dot display surface dot fill
578:14 - with the C color
578:16 - let's try this one and I am going to
578:19 - move this one really high up
578:23 - roll this thing and now
578:27 - everything is going to be blue if you
578:28 - have an underwater level this would be
578:30 - the start for it
578:32 - all right this is all we need inside of
578:34 - draw Horizon
578:36 - and let me get rid of this one white
578:38 - space here next up we have to work on
578:41 - the clouds and for that I'm going to
578:43 - create one more Sprite so inside of my
578:46 - Sprites
578:47 - I want to have let me put it all the way
578:50 - here at the top because this one is a
578:52 - fairly simple class I want to have class
578:54 - Cloud once again this one inherits from
578:57 - generic
578:58 - and in here inside of the init method I
579:03 - want to have self I need a position I
579:05 - need a surface and I need a group
579:07 - then we can call Super thunder in Niche
579:10 - and in here I have to pass in the
579:13 - surface the position the group and now
579:17 - for that this is what we usually didn't
579:19 - specify because most things are on Main
579:22 - however the clouds need to be in the
579:25 - background
579:26 - for that inside of level layers we have
579:29 - clouds here
579:31 - and this I want to pass in here with my
579:34 - clouds
579:36 - that way this is always going to be in
579:38 - the background
579:39 - the rest though is going to be for the
579:41 - movement and here I want self.position
579:44 - this is going to be a vector with
579:47 - self.rect DOT top left and besides that
579:50 - I want to have a speed and in here I
579:53 - want to have a random integer between 20
579:55 - and 30. rent and we don't have right now
579:58 - so I'm going to import it finally all we
580:02 - need in here is the update method with
580:04 - self and Delta time and literally all we
580:07 - have to do in here is self.post.x minus
580:11 - equal self dot speed multiplied by Delta
580:15 - time a direction here we don't need
580:18 - because the clouds always go to the left
580:20 - so once we have that self.rec.x is going
580:23 - to be round self dot post dot X and with
580:27 - that we have a cloud
580:30 - so next up we need graphics for this
580:32 - Cloud this we get inside of main.pi and
580:36 - when I'm importing all of this stuff I
580:38 - need one more import
580:40 - I'm gonna put all of this all the way at
580:42 - the end and here we have clouds and
580:45 - self.clouds is going to be import folder
580:49 - and in there we have graphics and we
580:53 - have clouds
580:56 - this I now want to put inside of my
580:58 - level once again the same way I have
581:01 - clouds and then here self.louds
581:06 - I believe this is the last graphic we
581:08 - are going to need in there
581:10 - so besides that inside of the level we
581:13 - can now start to create some clouds and
581:16 - this I want to put in a separate method
581:18 - Define and create loud
581:23 - and here I want self and event
581:26 - I'm going to check if the event DOT type
581:29 - is equal to self and now we need a timer
581:32 - for the clouds I'm going to call this
581:34 - one Cloud timer although it doesn't
581:37 - exist right now let's actually create it
581:39 - right away so for now print cloud and
581:42 - inside of the init method I'm going to
581:45 - put all of this under additional stuff
581:47 - in here I want to have the cloud
581:51 - timer
581:52 - and this is going to be pygame dot user
581:55 - event
581:56 - and for this one I want to go with plus
581:58 - two because we already have a user event
582:00 - that was plus one
582:02 - and now pygame dot time dot set
582:04 - underscore timer self dot Cloud timer
582:08 - and I want to create a new Cloud every
582:11 - two seconds
582:12 - this I can now use inside of my event
582:18 - Loop and what I want to do in here is if
582:22 - the event DOT type is equal to self dot
582:27 - loud timer and in here I want to create
582:32 - the clouds actually I don't need this
582:34 - create Cloud I can do all of this
582:36 - straight inside of this method here or
582:38 - the if statement rather and here I need
582:40 - a surface I need the X position I need a
582:44 - y position and once I thought of that I
582:46 - want to create my cloud This Cloud I
582:49 - have to import so all the way at the end
582:51 - I want to have a cloud
582:54 - and for this Cloud just as a reminder we
582:57 - need a position surface and group the
583:00 - surfaces we have stored actually nowhere
583:03 - right now so we need to have access to
583:06 - them
583:07 - this I can also do in here self.load
583:11 - surfaces let me call it serves is going
583:14 - to be the asset dictionary and then here
583:17 - I want to have clouds with that I always
583:19 - have access to these surfaces meaning
583:22 - this I can use in here now
583:24 - I want to pick a random item from
583:28 - self.cloud services I don't think we
583:32 - have Choice available right now we don't
583:35 - so from random import choice
583:39 - next up we need an X and A Y position
583:45 - and for now let me set them to zero and
583:49 - 500. just to make sure that something is
583:51 - working
583:52 - once I have all of that I want to create
583:54 - a cloud and as a reminder I need a
583:56 - position I need a surface and I need a
584:00 - group
584:01 - the position is going to be super easy
584:03 - this is going to be X and Y
584:07 - the surface we already have that's the
584:09 - surface we created here and for the
584:11 - groups all I want is self dot all
584:13 - Sprites oh although I did make a mistake
584:16 - this shouldn't be 500 this should be
584:18 - self taught Horizon y by default I want
584:22 - to create the clouds on top of the
584:23 - Horizon so at the very least we can see
584:26 - something and for X since I want all of
584:29 - them to move to the left let's start
584:31 - with 500 for this one
584:33 - this still isn't going to be the ideal
584:35 - position but at the very least we should
584:37 - be able to see something
584:39 - if I now run main.pi
584:43 - let me run the entire thing and we
584:45 - should be able to see a cloud there and
584:47 - the second one in a second there we go
584:50 - we have a second cloud
584:52 - they still don't look ideal but at the
584:55 - very least we have a start so with that
584:57 - we can work but first of all I want to
585:00 - draw the clouds always in the background
585:02 - and more importantly I want to draw them
585:05 - behind the horizon
585:07 - for that I have added a second for Loop
585:11 - and this is going to be quite similar so
585:13 - for sprite in self and if Sprite dot Z
585:18 - is equal to level layers and in here I
585:22 - only want to draw the clouds
585:25 - which means I can copy all of this
585:27 - and only draw the clouds and nothing
585:31 - else and then down here I want to draw
585:34 - all of the other layers except
585:37 - if Sprite dot Z
585:40 - is
585:41 - then I can copy this part here
585:45 - I hope the logic here makes sense
585:47 - basically
585:49 - we start by drawing all of the clouds
585:51 - then we are drawing The Horizon and then
585:53 - we are drawing all of the other elements
585:55 - or all the elements that are not a cloud
585:58 - that way we have the clouds behind the
586:01 - Horizon which I think looks a bit better
586:04 - with that we can minimize the camera
586:05 - group and now since the clouds are going
586:08 - to be behind the Horizon we have to give
586:11 - this one an offset
586:13 - which I want to be a random number so
586:16 - Rand inch which we don't have just yet
586:19 - besides choice I want to import rent int
586:23 - and the random integer here is going to
586:25 - be between 100 and 1000.
586:29 - if you want to create a really tall
586:31 - level you probably want to have a higher
586:33 - number or something more flexible but
586:35 - I'm fine with this one
586:37 - so let's try all of this
586:39 - run the entire thing and now
586:44 - we should be able to see something at
586:48 - some point
586:57 - but we don't I think one problem here
587:01 - could be that we just got really unlucky
587:03 - with the numbers let me change this to
587:05 - 100 to 200 so we're always going to see
587:08 - something
587:09 - let me try this again and now there I go
587:12 - there we can see a cloud and second
587:14 - cloud and the third cloud and so on
587:17 - so in the last part I just draw the
587:20 - clouds too high
587:22 - cool this is definitely looking pretty
587:25 - good
587:27 - what we now have to figure out is let me
587:30 - change this to a 500.
587:33 - next up we have to figure out this
587:36 - number here the X part
587:38 - and for this we have to figure out what
587:41 - the level limits are and since I only
587:43 - want to do this once this is going to
587:45 - happen inside of the init method before
587:48 - I'm doing all of the additional stuff I
587:50 - want to get the level limits and think
587:54 - of it like this if I have a level that
587:57 - has a couple of tiles here a couple of
587:59 - tiles here stuff here and so on I want
588:02 - to by default create some clouds inside
588:05 - of roughly this area here and later on
588:08 - when I create new clouds the clouds
588:10 - should come from this side here on top
588:13 - of that if a cloud goes too far to the
588:16 - left or rather exceeds the left side of
588:18 - the level I want to destroy that cloud
588:21 - and for all of that I have to know the
588:24 - size of my level
588:26 - for that I have put all of this inside
588:29 - of a separate dictionary that I called
588:32 - level limits in here I want to have a
588:36 - left side and I want to have a right
588:39 - side the left side is actually the
588:41 - easier part because this I always want
588:44 - to set at negative 500. the reason here
588:47 - is I know left or the left side of the
588:50 - level is always going to be at position
588:51 - 0. so I want to have this with some
588:54 - offset so the player can never see a
588:57 - cloud disappear
588:58 - the right side however is going to be a
589:01 - tiny bit more complicated the way I
589:03 - approached it is I looked at all of my
589:05 - terrain tiles and got the one with the
589:08 - highest number so the right side should
589:11 - be the right most terrain tile with an
589:16 - offset let's say plus 500 and this I
589:19 - think could be a good exercise for you
589:21 - try to figure out the width of the level
589:24 - and there are different ways to approach
589:26 - this but I think using the terrain tiles
589:28 - is the best one because be always going
589:29 - to use them
589:30 - so positively now and try to figure this
589:33 - one out
589:37 - in here I first of all want to get my
589:40 - grid and inside of there I have my
589:42 - terrain tiles
589:44 - since I only care about the position I
589:46 - only want to have the keys
589:48 - this I want to sort which means I can
589:51 - put all of this in the sorted method oh
589:53 - and I forgot I do want to turn all of
589:56 - this into a list
590:00 - and this list I want to sort
590:02 - for it sorting I am going to need a key
590:06 - or this one as always we need a function
590:08 - and let me pass in a position as the
590:11 - parameter here
590:13 - we always get a position with X and Y as
590:16 - a tuple I only care about X
590:19 - this is going to return a list with all
590:21 - of the terrain tiles sorted by the
590:23 - horizontal position I only care about
590:26 - the last one the one with the highest
590:28 - number on this one I only care about the
590:31 - X part and this is going to give me the
590:33 - rightmost tile and to this I want to add
590:36 - 500. I guess there's one limitation here
590:40 - and that is if the player doesn't place
590:43 - any terrain tiles we are going to get an
590:45 - error although I don't expect this to
590:48 - happen and this you could expand
590:49 - yourself I think at this stage the
590:51 - project is more or less done we just
590:53 - have to make some minor things but you
590:55 - can definitely expand this quite a bit
590:57 - but alright with that I have the level
590:59 - limits when I am creating all of the
591:03 - clouds
591:04 - I want to have my self dot level limits
591:10 - get the right side and to this I want to
591:14 - add a random number so my clouds look a
591:16 - bit more random
591:17 - let's go between 100 and 300. oh I can
591:21 - see the problem here
591:23 - I am adding an equal instead of a plus
591:27 - now let's try this again
591:29 - if I now draw some level
591:32 - and now the clouds should come all the
591:35 - way from the right and there we go this
591:37 - is feeling much better
591:40 - kind of hard to see but it's definitely
591:41 - working
591:42 - now there are two more things that we do
591:44 - have to do and by default the clouds I
591:48 - want to randomly scale up like we have
591:50 - done in the editor
591:52 - that we can do by writing surf is going
591:56 - to be Pi game
591:58 - dot transform dot scale to X and I want
592:03 - to scale up the surface but only if Rand
592:07 - in let's say between 0 and 5
592:10 - is greater than 3. else I want to keep
592:15 - the surface as it is if I try this one
592:18 - now draw a new floor
592:21 - and now at some point we should see a
592:24 - cloud that's twice as big and I think
592:25 - the first one there or already looks
592:28 - pretty good
592:30 - also I do want to change this to
592:33 - negative 50 to 600 for the Y position
592:37 - that way you do have a chance to have a
592:39 - cloud right behind the Horizon Lines
592:41 - which looks pretty good
592:43 - cool so with that I can minimize the
592:45 - event Loop and
592:48 - one more thing that I do want to do is
592:50 - to create some clouds by default
592:53 - this I can I think I call this start up
592:56 - louds all the way in the beginning and
592:58 - the name still works
593:00 - and for this one I want to create a
593:03 - random amount so for cloud in
593:07 - let's say range 100. and this probably
593:10 - shouldn't be Cloud we can just call this
593:12 - I because I'm not going to use this
593:14 - number anyway
593:15 - and here I'm going to do a fairly
593:17 - similar thing compared to what I have
593:19 - done here
593:20 - and you could be more elegant by putting
593:22 - all of this inside of a separate
593:24 - function
593:25 - but in my case I'm not too concerned
593:27 - although that being said we do have to
593:30 - make some changes here because all of
593:32 - these clouds are supposed to come in
593:34 - from the right whereas all of these
593:36 - clouds are supposed to be randomly
593:38 - distributed across the level
593:40 - y can stay the same but 4X I want to
593:44 - have a random number so Rand int between
593:48 - the left side and the right side of the
593:51 - level
593:52 - which means I want to have self dot
593:54 - level limits and in here I only care
593:57 - about the left side
593:59 - and then for the right side I only care
594:02 - about
594:03 - the right side here
594:06 - that is pretty much all I need so at the
594:10 - end of additional stuff I want to have
594:12 - my start up clouds and let's see if this
594:16 - is working
594:17 - if I now create some terrain again and
594:20 - now we have potentially too many clouds
594:24 - so this number here where did I put
594:27 - startup clouds there this number here
594:29 - you probably want to scale along with
594:32 - the width of the level so if I set this
594:34 - to a 40 probably looks a lot better
594:39 - yeah this is definitely better
594:41 - so in here the longer a level is the
594:44 - more clouds you want but in my case I
594:47 - think this is a pretty good start with
594:50 - that being done there's one more thing
594:52 - that we do have to do and that is in
594:56 - these clouds if a cloud goes further
594:59 - than the left side limit I want to get
595:01 - rid of the cloud
595:02 - and for that every time I'm creating a
595:05 - cloud so let me once again minimize
595:08 - everything
595:09 - I am creating a cloud either in the
595:12 - event Loop or inside of startup clouds
595:16 - both times I want to pass one more
595:18 - argument in here and that is going to be
595:21 - self.level limits and then here I only
595:23 - care about the left side
595:25 - this inside of Sprites I can now work
595:28 - with because in here I have the let's
595:31 - call it left limit
595:33 - this I want to store into an attribute
595:36 - self Dodge left
595:39 - limit is going to be left
595:42 - limit
595:43 - and this I can now use inside of update
595:46 - to destroy the cloud if it goes further
595:48 - than this which means if self.rect.x
595:53 - is smaller or equal than self dot left
595:56 - limit and if that is the case I want to
596:00 - destroy
596:02 - this object
596:04 - and with that we should be limiting the
596:06 - amount of clouds that we have it's going
596:08 - to be kind of hard to see but I'm going
596:10 - to assume that if there's no major crash
596:13 - this is probably fine
596:15 - and here you can see the limit is
596:17 - probably a bit too low
596:20 - so if I jump it you can see clouds
596:22 - disappearing
596:24 - but an important thing here is that the
596:26 - left side of the map so this area here
596:30 - is going to be 0 and 0 and this point
596:33 - here roughly would be negative 500.
596:37 - that way we have a bit more control over
596:40 - the numbers here
596:41 - but well I guess what I can set for the
596:45 - left level limit
596:47 - let's set this one to negative 1000.
596:51 - or I guess to be even better here this
596:54 - could be negative the window width
596:58 - that probably makes the most sense
597:01 - so now let's try this again let's create
597:03 - a platform
597:06 - and now the player should not be able to
597:09 - see when things are ending and this is
597:13 - looking pretty good we can just see a
597:15 - bunch of clouds and everything else
597:17 - works just fine
597:19 - okay there we go
597:21 - with that we have finished up the clouds
597:24 - and with that we have finished up all of
597:26 - the visual parts of the game for the
597:28 - last section all we really have to do is
597:30 - to add the sound and then we are good to
597:32 - go this isn't going to be a major
597:34 - section so let's Jump Right In we are in
597:37 - the code editor and I want to start with
597:39 - the editor because this one is going to
597:41 - need some background music
597:44 - this I want to do inside of the init
597:46 - method and in here all the way at the
597:49 - bottom
597:50 - I want to have some music this I get
597:54 - with self dot editor music
597:58 - and this we get with pygame.mixer DOT
598:01 - sound
598:03 - with proper spelling here and the file
598:06 - path now is one folder up then audio and
598:09 - inside of there we have a file called
598:11 - explorer.ogg
598:14 - and this I want to play right away so
598:16 - self dot editor music dot play
598:20 - importantly here you want to set Loops
598:22 - to negative one so it plays forever
598:25 - on top of that before we are playing it
598:27 - I want to set the volume
598:29 - this I get with set volume and I set
598:33 - this one to 0.4
598:36 - [Music]
598:40 - now you can hear some music so this one
598:43 - is working already
598:45 - the problem is now when I am switching
598:47 - to the level I want to switch off the
598:50 - music for the editor and play some music
598:52 - for the level
598:53 - the logic for that I can actually keep
598:56 - inside of the editor if I minimize the
599:00 - init method and look at my event Loop
599:03 - for this one whenever I'm calling this
599:06 - if statement here I also want to stop
599:08 - playing the music so self dot editor
599:10 - music dot stop like so and that way we
599:14 - are stopping the music once we go to a
599:16 - level
599:17 - let's try this one
599:21 - and there we go no more background music
599:24 - although now if I return
599:27 - we also don't have music playing again
599:29 - because we don't restart it
599:32 - this we can Now cover inside of main
599:35 - because in here inside of toggle
599:40 - I can check if self dot editor active
599:45 - and if that is the case self dot editor
599:48 - like so and editor
599:51 - underscore music and this I now want to
599:54 - play
599:55 - let's try it up on
599:57 - [Music]
600:00 - way back in the level there's no music
600:01 - and now if I return
600:04 - [Music]
600:07 - we got some music so this one is working
600:09 - now and this is all the music I'm going
600:12 - to add for the editor
600:14 - that's basically all we need
600:16 - with that I can close the editor we
600:19 - don't need it anymore
600:20 - next up for the level I want to have a
600:23 - couple of music files and those once
600:25 - again I'm going to import in main.pi so
600:27 - I'm only doing it once this is also
600:30 - going to happen inside of imports
600:33 - and in here I want to add some sounds
600:38 - all of this is going to be inside of one
600:40 - dictionary let me call it sounds let's
600:43 - call it level sounds
600:45 - and here we have a couple of different
600:47 - files the first one is going to be coin
600:49 - let me indent this and this I get with
600:52 - pygame DOT mixer dot sound and here once
600:56 - again one fold up then we have audio and
600:59 - then we have
601:00 - oin dot wav
601:04 - this I want to do three more times
601:07 - we now have hit besides that there is
601:11 - jump and finally there is the music
601:16 - these files are called Hit
601:19 - then we have jump and finally we have a
601:23 - file that is called super hero file
601:26 - ending being Ogg
601:29 - with that we have all of the level
601:31 - sounds these we now have to get into the
601:33 - level and this once again happens with
601:35 - all of this thing here
601:38 - I actually don't want to use the
601:39 - dictionary instead I want to have
601:42 - another entry and that is going to be
601:44 - self taught level sounds
601:48 - it's going to be kind of hard to read so
601:50 - let me put every entry here on a
601:52 - separate line with some proper
601:54 - indentation like so and this bracket
601:57 - here can go like this
602:00 - now this means for the level besides the
602:04 - asset dictionary we also need music
602:08 - all of those I do have to store in their
602:10 - separate variables so I'm going to add
602:13 - another entry sound and we have self dot
602:16 - BG music this one is going to be music
602:20 - actually I don't think music is good
602:23 - here let's call it audio
602:25 - and
602:27 - audio in here this I called music
602:32 - but this one like for the editor I want
602:34 - to add self.pg music
602:37 - dot set underscore volume once again
602:40 - this should be 0.4 and finally I can
602:43 - play the entire thing with loops being
602:47 - set to negative one
602:51 - that way this one's going to play
602:52 - Forever
602:54 - let's try all of this
602:58 - [Music]
603:07 - thank you
603:10 - and at the very least we do have music
603:12 - but now we have to make sure that this
603:15 - sound here also stops once we leave the
603:18 - level that we can also do quite easily
603:20 - inside of the event Loop when we are
603:22 - switching back to the level inside of
603:24 - here
603:25 - I want self.pg music to stop and since
603:30 - we are creating a new instance of the
603:33 - level this one is always going to start
603:35 - playing once we start the level
603:37 - and it's going to stop once we end the
603:39 - level so this is all we need for the
603:41 - background music
603:43 - next up we have to work on the coins and
603:46 - this part is quite easy because in here
603:48 - we do have access to the coins
603:51 - which means after I have the sounds I
603:53 - also want self.coin sound
603:56 - and this I get with audio and this entry
604:01 - I called coin so in here coin
604:05 - and now for every Sprite or every coin
604:09 - the players colliding with I want
604:12 - self.coin sound dot play this is
604:16 - supposed to only happen once though
604:18 - and just to test this let me not play
604:21 - the background music inside of the level
604:23 - that makes it a bit more noticeable
604:27 - [Music]
604:35 - there we go we have some coins and now
604:37 - if the pet touches them
604:41 - we get sound this one is working really
604:43 - well possibly a bit loud but that we can
604:47 - change simply by setting self dot
604:50 - coinsound dot set underscore volume to
604:55 - 0.3 it's something fairly subjective
604:58 - just play around with this that covers
605:00 - the next part so next up we have hit and
605:03 - we have jump it is going to be the
605:05 - easier one because we have a get damage
605:08 - method here and we can basically do the
605:11 - same thing we have done for the coin
605:12 - sound
605:13 - which means in here self dot hit sound
605:16 - is going to be audio and this one I
605:19 - called Hit
605:21 - and while we're here
605:23 - it's sound set volume with 0.3 and now
605:27 - every time the player is hit
605:30 - I want to play self dot hit sound dot
605:33 - play and we should be good to go
605:36 - let's try this one
605:38 - [Music]
605:42 - and I've only placed a single Spike
605:44 - and we get some sound
605:49 - that's working pretty good
605:52 - now I can minimize those two methods and
605:54 - this is all I need here the last bit we
605:57 - need is the jump sound for the player
606:01 - and this we can only do inside of build
606:05 - level because in here we are creating
606:07 - the player which means I want to pass in
606:10 - audio and this one I called jump
606:15 - so on here I want to pass in the jump
606:18 - sound
606:18 - this I guess I can now minimize the init
606:21 - method and for build level we need one
606:24 - more parameter and that is the jump
606:26 - sound
606:27 - this I also want to pass into the player
606:30 - all the way at the end we have the jump
606:33 - sound
606:35 - and now inside of Sprites when I am
606:38 - creating the player all the way here
606:41 - I have a jump sound
606:45 - this I can store all the way at the end
606:48 - with sound
606:50 - and self.jump
606:53 - sound
606:54 - is going to be the jump sound
606:57 - this I now just have to call and this I
607:00 - get inside of input because in here the
607:04 - player is pressing jump if that is the
607:06 - case I want self.jump sound dot play
607:11 - with that covered let's try
607:14 - [Music]
607:18 - and we have a very annoying jump sound
607:21 - this is definitely too loud right now
607:25 - which means inside of the Sprites once
607:27 - again I want to set self Dodge jump
607:30 - sound
607:31 - and set the volume to 0.2 possibly
607:40 - [Music]
607:42 - that is definitely a major Improvement
607:46 - but once again this is something you can
607:48 - play around with a lot
607:50 - and that is going to cover all of the
607:52 - sound that we are going to need I guess
607:55 - I can close level Sprites and settings
607:58 - and with that we have the entire game
608:00 - although I just realized
608:02 - if I reopen level I do want to play that
608:06 - background music now we are basically
608:09 - done with the entire project
608:12 - with all of that in place we can finish
608:14 - up the game and there isn't that much to
608:16 - do we only have to fix a couple of bucks
608:19 - and then we are done
608:21 - I think the best way to illustrate this
608:23 - is let me actually run the game
608:25 - and then here we have all the stuff we
608:27 - created so far and most of this is
608:30 - working just fine but if I play some
608:33 - tiles and some palm trees
608:36 - and now use the mouse wheel
608:38 - you can see that the mouse wheel doesn't
608:41 - work either horizontally or vertically
608:43 - so this we have to fix
608:45 - on top of that if I show my mouse
608:47 - clicking on the menu works just fine
608:50 - however if I click between the menu
608:53 - buttons like so the entire game crashes
608:57 - and we get a key error those are the two
609:00 - bugs I want to work on and both have
609:02 - them inside of the editor
609:05 - for this one I want to minimize
609:06 - everything and in here we have to work
609:10 - on menu click and Pen input and if you
609:13 - want to challenge yourself you should be
609:15 - able to fix both of them yourself quite
609:17 - easily the problems really aren't that
609:20 - big
609:20 - let's start with the menu because this
609:22 - one is game breaking the issue
609:25 - essentially is let me draw this actually
609:28 - we have our main menu rectangle and this
609:31 - is what we're getting from the menu
609:32 - inside of there we have a couple of
609:35 - boxes like so
609:40 - and they all return a number so for
609:43 - example for terrain and water this was
609:45 - two or three for the items I think it
609:48 - was four five or six and so on
609:52 - this is the value we are storing in
609:54 - self.selection index and this is then
609:56 - what we use to select an item to draw in
609:58 - the editor Works reasonably fine the
610:01 - issue is when the player clicks between
610:04 - the buttons this area here the return
610:07 - value is going to be none
610:10 - and none you cannot use for indexing
610:13 - which is why we're getting an error here
610:16 - which obviously isn't very good
610:19 - this is a very easy thing to fix though
610:21 - in my case I'm going to store the value
610:25 - we are getting from menu click this one
610:28 - here inside of a new variable that I
610:31 - called new index
610:33 - and this value I'm going to assign to
610:36 - the selection index but only if new
610:38 - index actually exists so if we have a
610:41 - value different from none
610:43 - if that is not the case I want to keep
610:46 - myself.selectionindex and with that I
610:48 - should be good to go let's try
610:51 - the game still runs I can still select
610:54 - everything inside of the menu and now if
610:58 - I click between the buttons nothing
611:01 - happens
611:04 - either left clicking or right clicking
611:06 - it all works just fine cool
611:09 - so we have fixed the first bug so now we
611:11 - can minimize the method and not worry
611:13 - about it again next up we have pan input
611:17 - in here the mouse wheel is covered in
611:20 - these lines of code
611:22 - the issue we have right here is we are
611:24 - updating the origin but we don't tell
611:27 - all of the Sprites to update as well you
611:29 - can see the issue down here we covered
611:31 - this a couple of hours ago
611:33 - when pen is active I want to change the
611:35 - origin and also update all of the
611:37 - Sprites this part here is what is
611:40 - missing inside of the mouse wheel and
611:42 - all I really have to do after we are
611:44 - covering all of this I want to add a for
611:47 - Loop so for sprite in self dot canvas
611:50 - objects
611:51 - the same thing we have done down here as
611:54 - a matter of fact I want to copy all of
611:56 - this and paste it in here
611:58 - that should be all we need let's try
612:02 - I can place some elements doesn't really
612:05 - matter what it is but let's try a few
612:07 - different ones just to be sure
612:10 - there we go and now if I use the mouse
612:11 - wheel this works in both axes
612:16 - so with that we have fixed another bug
612:21 - and with that I think the entire game is
612:24 - basically ready to go so I hope you
612:27 - enjoyed this video and I'll see you
612:28 - around

Cleaned transcript:

hello in this video you are going to learn how to create a Mario Maker Style game in Python using pi game you will be able to build huge levels with lots of monsters and decorations and then you can play them too while making this game you are going to learn how to manage a pretty large project with lots of data attached you will learn how to create an auto tiling system for the terrain and I will also cover the logic for a 2d platformer with a camera and basic enemy Behavior along with lots of other topics there's a reason this video is 10 hours long I do have to mention though that this is not a beginner's project I expect that you already know the basics of Pi game if you don't check out my ultimate introduction to pie game on YouTube or my paid udemy course the latter one teaches you pie game by making four advanced games and by purchasing it you also help me make more free stuff the last thing before I start the entire project is organized by a free folders one for the code one for the graphics and one for the audio the code folder contains the actual logic of the game you can download all of this from GitHub a quick note on that though inside of the GitHub project there are multiple code folders each of those corresponds to one chapter inside of the video that should make it quite a bit easier to follow along with all of that out of the way we can work on the intro and the editor of this project let's Jump Right In and let's have a look here is the code I already have there are two python files we have main.pi and settings.pi settings.pi let me minimize everything is quite an extensive file the most important one in here is edited data and in there we have a very chunky dictionary although for now just don't worry about it all we need for now are these bits up here more specifically the window width and the window height the rest you can ignore at least for now what is much more important inside main.pi in here if I run everything we can see a black window that right now doesn't do anything let's go over it really quick all the way at the bottom down here we are first checking if we are in the main file we are going to have quite a few different files so this one is important next up we are creating an instance of the class Main and this class we are creating up here I'll talk about it in just a second finally on this object we are calling main.run which is this run method here inside of that we are running the actual game meaning this here is going to become quite a bit more extensive and that would be a basic overview now inside of the main class we have an init method and we have the run method the init method initializes Pi game this happens here then we are creating a display surface and we are creating a clock I guess the important bit here is that when the width and window height come from the settings this is what we have created here and this is why this is important right now besides that nothing really happens inside of the initi method so I can minimize it at least for now inside of the run method all we're really doing is we are creating a while loop this one here and inside of that we're getting Delta time we are getting the events and finally we are drawing a frame this is a really simple setup for pi game let's talk about what we have to do right now we have a main object and later on for the game we are going to need two different states we have the editor State and we have the level State I assume the names here are quite selfevident editor is for editing the game and level is for actually playing the game the important thing we have to figure out for this is how we can switch between these two different states meaning how do we get from the editor to the level and how do we get from the level back to the editor and this is not going to happen straight between the two instead what is going to happen is that main is going to organize everything meaning that if we want to go to a level we go to the main file and then to level and the other way around if we want to go back from the level we go back to main and then to the editor although for quite some time we are only going to talk about editor because this one is the more extensive part so let's start working on that one at least for the basic setup here we are back in the code editor and I want to create a new file this one I'm going to save as editor dot pi in here as always we have to import Pi game besides that let me copy it from main.pi actually I also want from settings to import everything which means we have all of this here available inside of the editor as well once we have that I want to create a class called editor there's no inheritance and in here I want to first of all create a Dunder init method this one itself and nothing else at least for now and finally in here let me add a comment this is going to be the main setup for now all I want is self dot display underscore surface this we get with pygame.display.get underscore surface that allows us to draw on the display surface so what the player sees right away we don't have to go over main.pi and besides that I want to create a run method this one needs self and we also need Delta time Delta time we are getting from DT here and this one is really important to keep our game frame rate independent if you have no idea what that means check out this tutorial it explains all of that although for now inside of run all I want to do is to type pass so we're not doing anything actually just to see that this is working let's do instead self.displaysurface dot fill let's say with a white color that way we can tell what's going on and with that all I want to do is inside of main.pi I want from editor import editor that way I have this class available in main.pi and inside of the init method I want to create an instance of that which means self.editor is going to be the editor and on this editor inside of the while loop of the game I want to get my editor and get the run method now if I run this we are getting an error that there's one required argument missing Delta time this happened because in here we have the data time argument fortunately this one is easy because we have Delta time I can just pass it in here and now if I run this we have a white background this white background we are getting from this line here which means this one is working good start there's one more thing that we do have to do and let me explain why once again here are the different states of the game and the problem we have is that both the editor and the level need their own event Loop which means for the editor we have to check what we are doing for the mouse input if there's a certain kind of keyboard import or if we are closing the game and the same we have to do for the level as a matter of fact we actually have a third event loop as well the one from Main and all of this combined really isn't good because if you have too many event Loops things can get quite complicated as a consequence we are going to make some changes and that is that main does not have an event Loop by itself instead we only have an event Loop inside of the editor and inside of level and those event Loops are not going to run at the same time and that is because we either have the editor or the level open they are never open at the same time and this is what we have to implement which means back in the code I want to take all of this here and add it to my class inside of a method let's call it event Loop this one itself and nothing else and in here I want to have the event Loop and for now the only thing that we need is close the game that is going to be your exercise what I want you guys to do is to copy all of this paste it in here and then run the event Loop when the editor is open should be fairly straightforward so pause the video now and try to figure this one out yourself alrighty first of all I want to cut out a couple of things this while true Loop here has to stay same for this Delta time however this event Loop here I do want to cut out like this and now inside of editor I want to paste it I do have to fix the indentation but now this is more or less all I had to do all I need now is to actually call this event Loop so self dot event Loop and now if I run all of this again I should be able to close the game and I am although now I'm getting an error that name sis is not defined that is happening because now we are calling sys.exit inside of editor which doesn't have the sys module that we can fix quite easily by importing sys as well along those lines we don't need CIS and may not Pi anymore if I run this now once again we're getting a white background now we can close it and everything works as intended cool let me minimize the event Loop and also the init method because the editor class is going to become really long but that is what we are going to start building although for now I think this is a pretty good start so let's work on the next part in this section we are going to create the editor and the main Grid or at least we are going to display it and let me explain what that actually means for the editor we have an origin this origin is a vector and literally every single element is going to be relative to it this is literally just one position or more specifically this is a vector with an X and a y coordinate and this point we can move around later on this is actually what we are going to do in this section and every single element we are going to create for example let's say if we are creating a single tile these tiles are always going to be relative to the origin which means if we're moving the origin to the top right we are also moving all of the other elements in the same direction that way when we want to pan around the editor we only have to move one point and everything else is going to follow so let's implement it once again we are inside of the code I want to work inside of the editor more specifically inside of the init method in here I want to add another section let me call it navigation the really important part in here is self Dodge origin this one is going to be a simple Vector now for the editor we're going to use vectors quite a bit and as a consequence I want to save me some writing so I'm going to create a shorthand which means from pygame dot math I want to import a vector 2 and I want to rename this to vector that allows me to not write pygame.math.vector2 every single time instead all I have to do is type vector and I have a vector now we have ourself.origin and just to illustrate what is going on let me actually draw it which I do with pygame DOT draw dot Circle in here I need self dot display surface so the surface we want to draw on then I need to color let's go with red for now then I need a center and the center is going to be self.origin finally we need a radius let's go with 10 so we can see it quite easily if I run main.pi now you can see in the top left we have a red dot and this point we are going to move around and to move it around I want to add another method let me do it below the event Loop and let's call it pan input in here we need self and we need the current event this is what we're getting from the event Loop and since the editor is going to have a ton of methods I want to add quite a few different comments here to make it easier to follow which means this entire section here is always going to be the input and there are going to be a few more methods coming but for now let's not worry too much about it now pen dot input we are going to always call inside of the event Loop so pen input and I want to pass the event in here inside of this I have to figure out a couple of different things first of all I want to check if the middle Mouse button was pressed or released let me add this with a comment so middle Mouse button pressed or released which means if I am holding down the middle Mouse button I want to pan around the editor and if I'm releasing the middle Mouse button I want to stop panning although right now this is only the input besides that I need an actual let's call it panning update and how we are going to connect the two is by creating one attribute inside of the init method that I call Self dot pan active by default this one is going to be false in here I first have to check now if the event DOT type that is the event I'm getting from the event Loop although let me minimize it for now so we only focus on one thing if this is equal to pygame dot mouse button down that's not how you spell that like that if that is the case I want to set self dot pan active to true although we do have a problem here right now we are checking for any Mouse button down so any click of the mouse this could be a left click a right click or a middle click but I only want to check for the middle Mouse Button as a consequence I have to add another condition and this one we get with pygame dot mouse dot get underscore pressed this one is going to give us the different Mouse buttons that have been pressed although this I am also going to use a couple of times and it's quite cumbersome to write so let me cut it all out and instead from pygame dot mouse I want to import get underscore pressed and rename it to Mouse buttons that I think is much easier to understand and this I can now use S Mouse buttons and this is going to give me a tuple with the left right and middle Mouse button in my case I only care about the middle Mouse button this is the one with the index 1. I guess while we are here I can just print middle Mouse button and see if this is working which means in main.pi I am getting an error that name pan input is not defined the reason for that I think is that this should be called self.pan input if I run this again now and press the middle Mouse button we get middle Mouse button pressed or just middle Mouse button although if I press left and right nothing is happening which means this is a really good start and these two lines here work while we're at it we can also check if the button has been released that we are getting with if Mouse buttons don't forget to call it and one if that is not the case then I want to set self dot pan active back to false once we have all of that inside of panning update I can check if self dot pan active and if that is the case I want to set self dot origin to my mouse position in this we will get with pygame dot mouse dot get underscore pause although just like we have seen with getpressed this is going to be kind of annoying to write as a consequence I'm going to duplicate this line and replace get pause with the mouse position which means now the origin is just going to be Mouse position and now I can now if I hold the middle Mouse button move the origin around and this is working really well although now we do have a problem we have the origin right here that one is really obvious but every time we are pressing the middle Mouse button this point is moved to the mouse position which means if our Mouse position is somewhere down here we are jumping the origin Point all the way this distance which is not what's supposed to be happening and if we had more elements in the game this would be really confusing instead what I want to do is this point here if we press the middle Mouse button is going to stay in the same position and then if we are moving the mouse let's say in this position I also want to move the origin in the same position which means we are only getting the mouse movement we're not getting the actual Mouse position and to achieve that all we have to do is whenever we are pressing the middle Mouse button we are getting the offset between these two points which is going to be another Vector that looks like this and I think this is going to make much more sense when I actually implement it which means whenever I am pressing the middle Mouse button I want to get some kind of offset this offset I actually want to create inside of the initi method let's call it self pan offset this is also going to be a vector but by default it is going to be 0 and 0. and let me minimize the event Loop and now inside of this line here I want to get myself dot pan offset and now I have to figure out the size of this vector which honestly isn't that difficult all I need is my current Mouse position don't forget to call it and from that I want to subtract myself dot origin although for this to work in this most position needs to be a vector itself so vector and let me explain what's Happening Here this one is going to be the entire window and for Simplicity let's use examples the origin is going to be a point up here and the mouse position is going to be a point down here what we are getting with this entire operation is the distance between the two how I am going to use that is when I'm setting the origin when pan active is true I don't want to set the origin to the mouse position instead I want to turn the mouse position again into a vector and from that I want to subtract self dot pan offset and now let me run all of this again now if I only hold the middle Mouse button and don't move my mouse nothing is happening however now if I move the mouse we are moving the origin Point without moving the origin point to the mouse we are only getting the movement of the mouse but nothing else I hope that makes sense that way when we're moving the origin Point around it doesn't look too confusing and all we are really doing here let me minimize all of this so I have a bit of space to write on like so basically all we are doing whenever we are pressing the middle Mouse button we are getting the distance between the two this line here when we are moving the mouse in this direction we are setting this origin point to the same position so this point here however we are giving it an offset and the offset is again the same blue Vector we created here that way we are always getting the same kind of movement without putting the origin on the mouse position we are essentially panning the origin point all right that I hope wasn't too difficult although there's one more thing that I do want to add and that is a mouse wheel all we need for that is if event DOT type is equal to pygame dot mouse wheel and what that is doing let me print it actually I want to get event dot y event.y might be a bit confusing here the way you want to think about it is that when you have your mouse button something like this you can for most mice move it up or down some mice also allow you to move it left and right although the mouse I have doesn't do it and it's not very many mice that do it so I am not going to use it although you could and event.y is this up and down movement here event.x would be the left and the right movement which means if I run main.pi and I scroll up or down we get either one or a negative one depending if I go forwards or backwards or up or down depending on how you want to call it all we have to figure out now is how to use this to influence the origin position and this could be a really good exercise for you try to implement the mouse wheel yourself and see how you can use it to change the position of the origin this could either only be the X position but if you want to challenge yourself you could also add another mouse input and also do it for the Y position see how far you get all we have to do is get self dot origin and I want to move the X part of this vector and this I want to minus equal event dot Y and right now event.y is either one or a negative one which is going to be quite small which means I want to multiply it by 50. if I run this now I can scroll down and go in this direction and scroll up and go in the other direction which looks pretty good let me move it a bit more to the middle if I scroll down we're going in this direction if I scroll up we're going in this direction you might be wondering now why I'm using negative equal instead of plus equal and let me print event dot y again if I run all of this now let me move the Red Dot into the middle if I scroll away from me so four words I guess I'm getting a 1 and if I scroll towards me I'm getting a negative one and I found this to be most natural if I go forwards like this the entire level is going to move a tiny bit more to the right it's kind of hard to see right now but later on this is going to make much more sense just imagine this is the entire origin point for the game and if this thing is moving in this Direction the entire level is moving in this direction as well which is what I want to happen if I'm scrolling forward like this and then if I go in the other way it goes in the other way once we have some elements this is going to make much more sense for now just stick with me I suppose while we are here we can also make this a tiny bit more fancy I can check if pygame dot key dot get underscore pressed so right now I'm checking if I'm pressing any button on the keyboard although I only care about one specific one and that is pi game dot k underscore L control that is the left control button on Windows and I think on the Mac it's the command button and if I'm holding that one I want to copy this line here indented and now move the Y position with the X position being in the else statement this makes sure if I'm pressing left control and scroll of the mouse we're going up and down and if you're not holding this button we're going left or right let's try it and let me move the dot into the middle if I don't hold left control and use the mouse wheel I can go left and right if I hold left control I'm going up and down that way we have a pretty good scroll Behavior and that is going to be the pan input later on we will have to add a tiny bit more but for now this is fine there is one more thing that I want to add for this section although it is getting quite a long one let me add another section that I called Drawing in here I want to draw tile lines maybe not the best name but well it is what it is what this means is if this one here is the entire editor window or the entire game window I want to have individual lines that tell me where in the grid I am which is going to make it much easier to navigate through the entire thing and this is supposed to be infinite and also relative to the origin Point Let's Start and let me explain how the logic is going to work first of all I need to know how many columns and how many rows I will have and this I get with the window with or the columns and divide it by the tile size both of these are inside of settings I have the window width and the tile size both of these are static numbers so they are never going to change also I haven't mentioned but the entire game is going to be independent of the resolution of the game so if you have a very small or very large monitor you could change these numbers as you want although tile size because of the graphics has to stay at 64. and the same thing I want to do for the rows except this one is going to be window height once I have all of that I can run something like for call in range cults which means if I have 10 columns I want to draw 10 lines one for each column in here literally all I want to do is pygame dot draw dot line we first of all need a surface which for now is going to be self dot display surface after that we need a color and the color we have in the settings line color although just black is also fine but let me copy line color and line color in here finally I need a start and an end point both of which are going to be an X and A Y position let me add X and Y in here so this is easier to read border columns the Y position is going to be really easy let me draw it actually once again we have an entire window and right now I want to draw the column lines something like this all of these columns always start at the position 0 so the top of the window and end at the height of the window which means for the Y position this is either going to be zero for the start position and window height for the end position that's literally all we do the X position is getting a tiny bit more complicated so let me create a separate variable although that being said both X for the start and for the end position are going to be identical because each line is a straight line I probably should have drawn this a bit better something like this okay you get the idea the important thing here is that the X position for this and the X position for this is the same that's the really important bit here and what I want is self dot origin dot X Plus call multiplied by the tile size what that means let's say our origin point is at position 0 and 0 right now this is the point we're getting here and X is zero so let me write X is equal to zero and from this point I want to add column multiplied by the tile size column right now is going to be 0 and tile size is always going to be 64. which means for the first one we get zero and this is then going to be this line here however now if we add this to a 1 or the second cycle in this for Loop and multiply it with 64. we are getting 64. and this is then bringing us to this point here and this we keep on doing until we reach the end of the columns so now all we have to do is call this method and we should be seeing something although there are quite a few problems let me do it before we are drawing the origin and let me add another comment here to call this drawing so this is a bit easier to follow filling display surface should also be in there actually in here I want self Dodge draw tile lines and now if I run out of this there you can see the lines and if I move the origin point you can also see that they are moving along with the origin Point although I guess you can see the problem we are very easily running out of points and nothing is here anymore also what I can do is if I move the origin Point too far to the left we're also running out of points here all of which is not ideal I want to be able to scroll infinitely and just keep on going which means I have to make some adjustments but they aren't that big let me minimize the run method and in here now I want to make sure that the lines are always on the display we are never running out of lines and if you want to challenge yourself this could be a fun exercise although this one is getting quite a bit more advanced but see if we can figure this one with yourself you don't have to add that much more if you want a reference I fixed this entire problem with one additional line of code all right let's do together now and first of all let me talk about the logic that we need here right now we have the entire window and we have an origin Point somewhere on here let's say right now it is somewhere here and this point is going to be the origin for all of the other columns meaning we are always drawing them in this line here you can already tell the first problem is to the left we have nothing on top of that if we are moving the origin too far to the left we also have nothing on the right side both of which are problems we do have to account for so let me clean this up a tiny bit and instead what I want to do is let me move the origin point a bit further to the left let's say it is here and the X position is 100. the logic you have to understand that is probably going to take you some time to follow is we always want to draw some columns here is column zero then we have column one at 64 pixels then the next one would be somewhere here at 128 and we keep on going and always go by one Higher in our tile size however now when I'm drawing all of this I do not want to set this origin Point here as the origin because then we end up with the problem that we have the columns that always go to the right and we end up without points instead I want to create another vector and this Vector is always going to be in this first area here somewhere like this which means the vector can only be here or here or here it could also be higher up or lower up that doesn't matter but it could never be here or here those points are not possible we Are Always Somewhere in here now the Y position we are going to completely ignore the X position however is going to be really important and this one we are getting from this distance here it's kind of hard to see basically what I want to know is what is 100 this number here minus 64 which is this number here if I'm doing the math here this one would be 36. and this 46 is going to be the distance from the origin so we are moving a point here it has the same y position as the origin but the X position is going to be the distance between the next column and the actual point I hope that makes sense once we have this point here all I really want to do is to start drawing columns from this point so we are creating columns here columns here columns here and that way we can move the origin wherever we want it is always going to be somewhere in this position and that way the columns can never go outside of the window I hope that makes sense again this isn't the easiest logic to follow but let me actually implement it and let's see how far we get first of all I want to create let me call it an offset vector this is also going to be a vector and in here we have an X and A Y position and I'm going to put both of them on separate lines to make it a bit easier to see although if you have a large enough monitor you probably don't need to in both cases I want to first of all get self.origin and this is either going to be X or it's going to be y I now want to get distance between my current point so self.origen.x currently is 100. and from that I want to know the distance this blue line here between the next column which is going to be 100 minus 64. the 100 I already have I now have to get the 64. although I do have to be careful here my origin Point could also be let's say here or here or here so this 64 always has to be the next column this we are getting with self Dot origin dot X and I want to divide this by the tile size and this I want to turn into an integer once again if I use actual numbers self dot origin.x would be 100 and the tile size would always be 64. which means this combined would be something like one point let's say 1.4 and if we get the integer we are removing anything after the dot so this would be a one which means we are on the first column although again this one would just be a one it needs to be a 64. as a consequence I want to multiply all of this with the tile size once again that way this entire number is going to become a 64. the 64 we actually need and with that we have the actual origin for the X position the one we actually want and this I can just copy for the Y position just to have something in here so this is going to be origin.y and the rest can stay the same and now when I'm drawing The Columns I don't want to have self.origen.x instead I want to have the offset vector actually let me call this the origin offset that I think makes more sense the rest however can stay exactly as it is so now let's try all of this again now you can see once again we have the origin point we can move around but all of the columns are going to scroll indefinitely although there's one problem if I move the origin Point too far to the left you can see here all the way on the right we are missing one column but the rest looks pretty good so I am very happy with that the one change we do have to make is that when we're using this for loop I want to have colds plus one and now if I run this again now this is looking really good cool this is looking amazing now the main reason why this is working is because it only looks like the origin point is the origin of the columns however the actual origin is this point here which is the origin Point subtracted with the offset we have created and only from this point we are drawing all of these columns that way it looks like we have an infinite amount but we're always only drawing The Columns you can see on the window cool now all we have to do is do the same thing for the Y position so for Row in range rows plus one I want to create a y position and that is going to be the origin of set dot y plus the row multiplied by the tile size and once I have that let me duplicate the pygame dot draw line line and now I have to change the X and the Y position X is either going to be zero or it is going to be the window with and Y is going to be well the Y position once again if I draw the entire thing each row is going to look something like this for the X position we always starting on the left side of the window and we're ending on the size of the window width meaning this is ever going to be zero or the window width and Y is just going to be the distance from the top both on the left and on the right and now we have all we need I can run this again and now we have an infinite grid that we can scroll around in this is looking really good cool although there's one more thing I do want to do and that is that right now this black color is a bit too strong especially later on if we have the actual level this isn't going to look very good meaning I want to give all of this some transparency for that I'm going to draw all of this on a separate surface and then this surface is going to get some transparency the reason here is when you are drawing something you cannot influence the transparency this we have to do on a separate surface and this is going to happen inside of the init method I want to add another section let me call the common support lines in here first of all I want to create another surface let me call it support line surface and this is just going to be another pygame dot surface and in here I want to have the window width and the window height we are essentially copying our entire display surface if I scroll down a tiny bit you can still see it before we start to draw everything here right now our problem is these lines are black and this background here is black so you can only see black which isn't too helpful as a consequence before we are drawing The Columns or the rows I want to get my support line surface and fill it with a green color we are drawing not on display surface but instead on the support line surface and all the way at the end I want to have self.displaysurface.blit I want to Blitz self.support line surface at a position 0 and 0. since the support line surface has the same size as the display surface if we put it at position 0 and 0 it is going to cover the entire window let's try and now the entire thing is green not particularly helpful it actually looks really weird but what we can do in the init method we can set a color key this we get with self Dot support line surface and set underscore color key and the color key here is supposed to be green this means that we're going to remove any color with this color key Green in this case which is what we're using to fill the entire surface the consequence is that the entire green color is removed and right now we don't really see much of a difference however what we can do now is set the transparency on this support line surface all we need for that is set underscore Alpha and then here we need a value between 0 and 255. 0 being nothing at all and 255 is the full color in my case I went with something like 30. and now you can see some very faint lines but they don't get too much in the way but with that we have the actual grid that we can move around in this is looking really good and this section has gotten really long so let's finish it now and let's come to the next part now for the next part we can do something slightly easier and that is changing the mouse cursor that really isn't going to take long and this section is going to be shorter and easier so let's jump right into it here we are back at Main and I want to work inside of the init method of the main class because in here we have to initiate the cursor and let me add a comment to make this easier to follow now for a cursor we have to do a couple of things first of all we have to import an image as a surface let me store it as a surface and all we really have to do is to import an image and that we do with pygame DOT image dot load however once again I'm going to import quite a few different things inside of the main class later on as a consequence I don't always want to write Pi game image and load I just want to write load so what I can do just like I have done with these lines here I can let me put it here I want from pygame dot image import load that way I can just type load and import a graphic if I open the folder we have audio code and Graphics right now we are inside of code and here is what we have so far inside of Graphics though we have cursors and there we have a handle and we have a mouse the handle we look at later but Mouse is the important one for now this is what we are going to import and the file path towards this is one folder up then graphics cursors and mouse.png on top of that don't forget to convert Alpha all of this next up we have to convert this surface to a cursor object this I also want to store in the variable let's call it cursor and the command here is pygame dot cursors dot cursor in here we need two bits of information we need the let's call it the click yeah Bell area and we need a surface the surface we already have this surface here is totally fine the clickable area is let me actually open the graphic here we go and if I open this and scroll in a tiny bit what the clickable area essentially tells you is which part of this mouse is actually going to be the point we are controlling which right now in this case is going to be this point here so when I click the mouse button I want this area to interact and be my actual Mouse position with the entirety of this just being an attached graphic that doesn't really do that much this point here is what actually matters I hope that makes sense basically we are looking for a clickable area in my case the position here is quite simple I want the Tuple and this one needs X and Y and in my case both of them are zero that means we are having the top left of this surface as the clickable area there's one more thing that we have to do and that is we have to get pygame dot mouse dot set underscore cursor and then here I want to have the cursor if I run the code now we are getting an error because I have a typo in here this should be cursors now if I run this and you can see my mouse here we have a mouse cursor that looks much more appropriate everything else still works just as usual we have just changed the graphics of the mouse for the next part we're going to create a menu and let me start by talking about how this system is actually going to work inside of the editor we are going to create what is called a selection index and this is a variable with values between 2 and 18. and each number represents a certain kind of tile inside of the editor for example two would be terrain three would be water four would be gold coin and so on and this selection index can either be changed by clicking on the menu or via hotkeys and just to explain how we got the numbers 2 to 18 let me open the code right away here we are back in the project and inside of settings we have editor data which is a dictionary that contains other dictionaries and the key is always the index and then we have the dictionary with lots of information in here we have 0 and 1 those two are going to be ignored because 0 is the player and one is the handle for the sky those two are always going to be inside of the editor so we don't have to create them however from 2 to 18 we have objects that the player can actually create for example two would be terrain you can see it here then we have water then we have different kinds of coin for example we have a gold coin a silver coin and a diamond then we have a bunch of enemies a bunch of foreground palm trees and a bunch of background palm trees all of these things we have to account for so let's get started inside of the editor and let me minimize everything so it's a bit easier to follow right now I want to work inside of the init method and in here I want to add another section let me add a comment that I call selection for now all I want is self.selection index by default this one is going to be let's say 2 for terrain now that we have that we have to create the menu and the hotkeys to change this selection index the hotkeys are going to be easier so let's do it right away and this is going to be another method in the input section in here I want to have let's call it selection or keys we need itself and besides that we also need the event all we really have to check in here is if the event DOT type is equal to pygame dot k down this means we are checking for any kind of keyboard input in here I want to check if the event dot key is equal to pygame dot k underscore right so we are pressing to the right and if that is the case I want to set self dot selection index and increase it by one then I can do the same thing for the left key so if event dot key is equal to pygame dot k underscore left and if that is the case let me duplicate the line this should be minus equal one since the event type only checks if we are pressing a button and not if we're holding down a button we also don't need a timer in here which makes all of this quite a bit easier to work with although there's going to be one issue let me print what we get at the end of this so print self dot selection index and also don't forget to call this thing I want self.selection not index but hot keys and we have to pass the event in here if I run all of this now we're not getting an error and you can see two in the bottom left if I now press to the right we get higher numbers and if I go down we get lower numbers so this is working really well however I can go below zero and I can also go above 18. like so and if we try to use those keys inside of the dictionary we would be getting an error which means I want to limit the numbers we can get from this one here so that the lowest number is a two and the highest number is an 18. and that could be a really good exercise for you so pause the video and limit the numbers to a range of 2 to 18. it should be doable on a single line of code I first of all want to Target myself dot selectionindex after I have done all of this let's get started with the smallest number and this we get with the Min function this one takes two arguments and it always selects the lower one in my case this would be self dot selection not hot keys but index and 18. with this line already selection index can never exceed 18. let's try actually by printing self.selection index and run out of this again and now if I go further and further to the right I can never exceed 18. so this one is working now we just have to cover the minimum so that we can never go below 2. and for that I want to put this function inside of a Max function this one also takes two arguments and it always selects the larger one which means if I have my minimum and I add a 2 in here if this Min now goes below 2 we're always selecting the larger number which is the two as a consequence we can never go below 2. which means if I run out of this again I can go to the left and the number doesn't go below 2 and if I go to the right the number increases but only up to 18. so this is working really well cool with that we have some basic hotkeys let me get rid of the print statement we don't need it anymore and we can minimize all of this as well next up we have to work on the menu and this is going to be a larger part so I want to put all of this in a separate file let me create a new file I will save this one as menu dot pi in here I want to import Pi game and just as before let me copy it actually I need all of the stuff from the settings once I have that I want to create a new class called menu no need for inheritance but we do need it under a niche method and here we need self and nothing else now first of all we need to be able to draw on the display surface so we need to display surface which we get with self.display surface or name it whatever you want and here we need pygam.display.get underscore surface once we have that I want to create two more methods the first one let's call it create buttons itself and nothing else and for now this is just going to be a pass besides that I also want to create a method that I called display in here once again we need self and nothing else at least for now and this display is what we're going to call to run the actual menu let's do it right away actually so inside of the editor I want to from menu import menu next up I have to create an instance of this object don't forget to comment things properly and let's call it menu is going to be menu finally to actually show the menu inside of the run method all the way at the bottom I want self dot menu dot display right now if I run all of this we cannot see anything because the menu doesn't print anything but at the very least we're not crashing so that's a good start now we can start working inside of the menu class and actually do something the first thing I want to do is to create a general area for the menu let's say this here is the entire display surface and what I want is in the bottom right a square that contains smaller Square this red square is the entire menu inside of it we have a couple of smaller squares and those are the things the player actually clicks on and the red thing is what we're going to create right now let me add a comment here as well and let's call it menu area General first of all I want to create two variables the first one is the size of the menu in general and that I have set to 180 pixels and then I want to have margin and this I've set to 6 pixels I suppose both of those numbers are fairly selfexplanatory once I have them I want to create self.rect and this is going to be the area of the entire menu this is just going to be a normal python rectangle enter here we need a left a top a width and a height the width and the height are both fairly easy because they are just going to be the size for the left side let me explain how this is going to work actually once again we have the entire display surface and inside of that we have the menu the size of the menu so this Dimension here and this Dimension here is going to be the size and this is what we have done already next up I want to have a margin and the margin is going to be this distance here and this distance here and this shouldn't be too difficult of a thing to implement so I think this could also be a pretty good exercise try to figure this amount yourself and see how far you get you have to set the left and the top meaning this point here to get this kind of margin on the right and on the bottom try to figure this one out and see how far you get let me get rid of the drawing and basically all we have to do first of all I need the window with from that I want to subtract the size and from that I also want to subtract the margin if I draw on all of this again basically what we have done let me scroll down a tiny bit so now you can see it better when the width is this point here then the size is going to be this area here and the margin is going to be this bit here meaning if we subtract the two from the other we are getting to this point here this bit which is exactly what we need for the left side of this rectangle once we have that the top shouldn't be too difficult all we have to do is copy all of this and for the top I want to have not the window width but the window height and this is going to be really hard to read so let me put it in separate variables for the top left I want to have all of this and I can just paste it in here since this is now a tuple we need a position Tuple and a size Tuple meaning the size has to be inside of another Tuple otherwise pygame gets confused you'll either need two tuples for the position and the size or you need four numbers for the left the top the width and the height both are okay but well you can't mix them if I now run this we're not getting an error so that's a good sign to actually see something now I can run pygame dot draw dot rect now we need a surface so self dot display surface then we need to color that one doesn't matter let's go with red and finally we need the rectangle self.rect finally before we can start we have to call create buttons which we do with self dot create buttons and now if I run this you can see in the bottom right we have a menu and this one stays on top of the level so it doesn't move around which is exactly what I want now that we have that we have to create the button areas and let me get rid of the general it's not needed and it kind of annoyed me I want to create four rectangles that go inside of the menu meaning if this one here is the menu I want to have four smaller rectangles inside of this larger box on top of that between the buttons there should be some margins so we do have to be careful with the numbers here the easiest way I found to work with this is to first of all create a generic button rectangle since all of the buttons have the same size we can just create this rectangle once and then copy it and move it in different positions meaning once again I want to create a pygame rectangle in here we need a position and a size the position is actually quite simple because all I want to do is self.rect.top left which means if I am drawing again the position we are looking at right now is this point here and the first rectangle we are creating is right on this point next up we have to make sure that we have a rectangle that is one quarter of the size of this entire box we're going to shrink that in just a second for now I want to keep the number simple so for the size I want to have a tuple with self.direct DOT with divided by two and besides that self.direct dot height divided by two with that we have a generic button rectangle or we almost have one that works let me turn it into an attribute so now we can draw it that makes the entire thing easier to see self dot generic button rectangle and this shouldn't be red let's go with green if I run this now we can now see we have a green rectangle inside of the larger rectangle that's a pretty good start but not ideal the problem we have right now is that this rectangle is a tiny bit too large if we had four of these rectangles they would fill out the entire menu rectangle perfectly since I do want to have margins this is not ideal as a consequence let me create another variable let's call it button margin and this in my case I've set to 5. also this generic button rectangle shouldn't be an attribute and this I also want to comment out at least for now we now have a generic button rectangle and we have a button margin with those two things we can actually create the first rectangle and this one is going to be an attribute and now I have to create four different areas for the specific kinds of buttons the first button area I want to create is the tile button let's call it rect all I want to do here is get the generic button rectangle and create a copy of it and just to see what is going on let me copy the entire thing and paste in the tile button rectangle if around all of this you cannot see any difference because we have copied a rectangle so nothing has changed yet however what we can do now is to run the inflate method on this rectangle in here we need an X and A Y position by how much we want to increase or decrease the size of the rectangle in my case I want to shrink this rectangle by the negative button margin both for the X and for the Y if I now run this again there is a tiny gap on the top left so we can see this is working the rectangle has shrunk in all four directions the reason why this is really useful is because the original rectangle was something like this and we were right up in the top left and this rectangle we have now shrunk in all four different directions by keeping it centered on this position here that makes it really easy to place this area and not have to worry about the map of positioning to get exactly the right area here and the right area here I hope that makes sense you're going to see in a second how this is really helpful so with that we have the first button or button area next up I want to create this one I called the coin button wrecked and here once again I want to get the generic button rectangle and create a copy of it although for this one I want to move it in here we have to give X and Y values to tell Pi game by how much we want to move this rectangle since the coins are going to be right next to the tiles we're not going to move the X position at all however what I do want once again if this is the entire menu and right now we have this array here already covered that is the tile button rectangle what I want to do next is for this coin button rectangle to move it right here which means since we right now have a copy of this original rectangle we want to move this point here to this point here which is exactly in the midpoint of this self.rectangle which means all we have to do is move this rectangle by itself dot rect dot with divided by two once I have that I can copy the drawing logic here and now I want to draw self dot coin button rectangle with a different color let's go with blue if I now run this you can see that I made a mistake because I confused the X and the Y position since the coins are supposed to be on the right side of the tiles I want to move only the X and not the Y let me cut it out and paste 0 in here and this one should be self.rect dot height divided by 2 and 0. now if I run this again this is looking much better all I have to do now is to call the inflate method let me actually copy it from here and paste it in there and now we should be good to go and there we go this is looking really good and I hope now you can see by using the inflate method here is really useful it allows us to create a rectangle that is exactly one quarter of the original rectangle size and then once we have the better position we can shrink it to have a tiny bit of margin all we have to do now is to copy this thing two more times we have an enemy button rectangle and we have a palm button rectangle The Palms I have in the bottom left and this is the area we have already seen I can just add a 0 for x and for y I want to have self.rect dot with divided by two and let me draw all of them so it's a bit easier to follow right now I have the pump button rectangle if I run this now you can see another area in the bottom left I guess I should change the color let's go with yellow you can see we have another rectangle and finally we need the enemy button rectangle this one is in the bottom right which means we need self.directed height divided by two and on top of that we also need self.rect.wiff divided by two as well so let me copy it and paste it in here and now the last thing I have to do is to draw the final thing as well or enemy button rectangle for the color here a color we haven't used yet let's go with brown and finally we have all four rectangles and this is looking really nice it looks even better if you don't draw the original rectangle let me comment it out and there we go now we have different areas for the buttons that we want to create so this is working very well now that we have all of that we need to actually fill these areas with an actual button and for that I'm going to create a whole separate class that I called button and this is going to be a Sprite Which means this one has to inherit from pygame dot Sprite dot Sprite and inside of that we need it done there in it method and then here we need a couple of different things besides rect we need the rectangle so the area we want to use then we need a group so what group this button Sprite should be part of and finally we need items and besides that I also want items alternative although items alternative by default is going to be none the reason here is when we have the palm trees we have the foreground and the background ones the foreground ones are going to be the items while the background ones are going to be the alternative ones and if you middle click on the Sprite it is going to switch between the two that felt like a good system to handle all of this but no other button is going to have alternative items unless you want to add some yourself but that's something Beyond this tutorial now once we have all of that the first thing we have to do is to create a super thunder in Niche method and pass in the group in here next up we have to create self.image and this is going to be a plain pie game dot surface with the size of the rectangle the rectangle that we have created up here for each individual button besides that we also need self.rect for each individual Sprite and this is just going to be the rectangle besides that we have to capture all of the items and this is going to be a dictionary that I called self.items in here we have the main ones and this is going to be items ideally spelled correctly and then we have the alternative ones and this is going to be items alternative besides that I also want to have self.index which by default is going to be 0 and self dot main underscore active which by default is going to be true main.active is going to decide if we are in the main ones or in the alternative ones and index is just going to tell us which item we are on you're going to see in a second how that is going to work however first of all we do have a problem we have to import a bunch of items and alternative items and that is going to be a bit more extensive and for that I'm going to create a separate method that I called create data itself and nothing else in here and all of this is going to be stored inside of self dot menu surfaces but now it's going to be an empty dictionary and let's have a look what we are actually going to import inside of settings we have this editor data dictionary with a ton of different things and let's have a look at the terrain for now in here we have a style we have a type we have a menu and then we have a menu surface the menu surface is really important and this we have for a lot of different elements all of them besides the player and the sky because those are not supposed to be in the menu also note here this is just going to be a path it is not a surface which means we have to use this path to create an actual surface and that is what we are going to do now for that first of all I want for key and value in editor data Dot items don't forget to call it and let me just print what we get so we have a key and we have a Vel U don't forget to call it and really important here self.create data needs to be called before created buttons because we need a data to create the buttons properly in just a bit but now if I run all of this and extend this one here where you can see we have a ton of different things we have the index and we have a dictionary with the stuff we have seen earlier so for example for the player we have seen this one here and the first thing we have to do in here is to check if each particular item even has a menu surface if it doesn't have one we just want to ignore it which is quite easily done all we need to do if I get rid of the print statement I want to check if value and menu exists in the first place that is this one here you could also check for the menu surface both would be fine and here you can see that the player doesn't have a menu and the sky also doesn't have a menu once I have checked that essentially what I want to create is a key value pair that is going to be inside of this dictionary the key is always going to be the menu entry here for example for these two elements here I want to have one key that's called terrain and attached to this key are two surfaces the surfaces from this one here and the surface from this one here it is always going to be one individual surface which means what I want to do is if not value and menu in self dot menu serves and if that is the case I want to create a new entry inside of this dictionary so self dot menu serves and then I want to get my value menu and for now let me just add an empty dictionary and this is probably confusing so let me print what we actually get self dot menu surfaces if I run all of this now we are getting a couple of keys with an empty Tuple as the value we have terrain oin enemy Palm foreground and palm background if I look at settings you can see we have terrain we have the coin we have the enemy and then we have Palm foreground and palm background and essentially what I now want to do is for example for the terrain I want to have this graphic here and this graphic here as a tuple associated with this terrain key and this is what I am going to pass into each of the buttons these buttons here as the items which means first of all I want to create a list inside of a tuple because I want to add more elements inside of this I want to run pygame dot image.load however we have already seen this inside of main.pi typing pygame.image.load is kind of cumbersome so I'm going to copy this from Main and paste it in here so now I only have to type load makes my life a bit easier and what I want to load is the current value we have and then the menu surface that is going to be this file here although now this Surface by itself isn't going to be enough but I guess for now let me run the entire thing and see if it works there we go at least it didn't crash so it has to start now for terrain we have one entry as a matter of fact for all of these we always have one entry which isn't ideal because in settings for example for terrain we have two entries and right now we are checking if Terrain is not inside of this surface and if it is not in there so this if statement here then we are creating a new entry the problem with that is once we come to the next entry that has the same menu then we are just going to ignore it and this we have to account for meaning I want to add an else statement if we already have this entry and if that is the case I can actually just copy this entire thing I want to append something to the list we already have this list we created just now and what I want to append is the same thing and now if I run this again we get for example for terrain two surfaces one surface for the terrain and one surface for the water although we do need one more thing right now we only have the graphic but we need a bit more information we have to know for each graphic the associated key for example for terrain we need to know the two because this is how we identify each individual graphic that is quite easy all you have to do is turn this surface into a tuple that right now contains only a surface but I also want to add the key here this I also want to do in the else statement when I append the value and now I want the key in here and now if I run this again we for example get for Terrain we have a tuple with two and the terrain surface and then we have three and the water surface for coin we have another list with a tuple and this one is a four and then we have a surface with the gold coin and that is actually all we needed so I can get rid of the print statement and minimize the entire method and now inside of create buttons I can actually create the buttons although first of all for that we need a group for the Sprites this one is really easily created all we need let me actually do it inside of the buttons that makes a bit more sense in here I want to have self dot buttons and this is just going to be pygame.sprite.group and now I can create individual buttons for example the first button just button is going to have a couple of arguments these four here or the rectangle first of all we need self tile button rectangle the group is going to be self dot buttons the items is going to be self dot menu surfaces and in here I want to have the terrain key finally for the alternative items I can just ignore the entire thing and this is going to be the first button now I can copy the entire thing and I think this is going to be a really good exercise for you to see if you can still follow along because the Imports I think did get a tiny bit confusing so definitely work with this and well try to create the other three buttons so we have all four buttons and see if we can figure this one out yourself let me actually copy it two more times and first of all besides the tile we also need the coin button rectangle this one is in the same group although for the surfaces we don't need terrain we need coin let's work on the enemy button rectangle this one again same group but for the surfaces we need this one I called enemy inside of settings you can see here we have the enemy finally we need the Palm button rectangle and this one is going to have items and the alternative items for the items this one is called Palm FG and this I have gotten from here and besides that we have Pawn BG and this is the alternative item here so I can just copy the entire thing and this one should be Palm BG and with that we can minimize create buttons because we don't need it anymore although let me run the entire thing and nothing is crashing that's usually a good sign right now we can work inside of the button in here first of all we need some kind of update or display method this one actually displays what we have inside of the Sprite first of all in here I want to have self dot image dot fill and for the fill now we need a color that color we're getting from settings and in here we have button BG color and button line color right now I want button BG color and this I want to pass in here next up we have to create a surface and a rectangle from the items or the alternative items and this information we are then going to use for self.image.blit and we are going to Blitz the surface and the rectangle the best way to think about it is that the actual Sprite with the image and the rectangle this is just going to be the background which means we are just filling it with a simple color but on top of this Sprite we're going to Blitz another surface and this surface is going to come from the items or the alternative items which means for now this is just going to be self dot items and then here for Simplicity I'm just going to work with the main ones for now these ones here actually just to make this a bit simpler let me print what the surface is going to be so print surface and now I can copy out all of this and instead I can run self dot buttons dot update and self dot buttons dot draw and in here we need self.d display surface if you have forgotten the buttons are just going to be a Sprite group and this has the methods for update and draw so we don't have to worry about it if I run this now you can see four different squares and besides that we can see a very long list and this is always going to be a list and inside of the list we have a tuple with the relevant surfaces this is what we actually want to draw on top of the Sprite Which means in here I first of all want to get the self Dot index the one we have created up here and by default this one is always going to be zero with that we are returning a tuple with the index of the graphic so if I go up a tiny bit this one here and then we have the actual graphic the one we imported here for example since we only want the graphic I want to use indexing again with a 1 so we're only picking the graphic with that we have a surface now that we have a surface I also want to create a rectangle a rectangle is quite simple I just want to get the surface and get underscore rect for this one I want to place this Center although for the center here you might be tempted to run something like self.rect.center that would not work and let me explain why it's really important to understand the rectangles here if this is the entire display surface and the menu is somewhere down here with one item inside of the menu being here what we want to do is to draw one surface inside of the center of this individual button which means we want to go half the width of this button and have the height of this button so that we end right in the center of this button the problem is if we used self.rect.center we will get the global position of this rectangle which would be a problem here because the origin or the local origin is this point here and if we use self.direct.center we would move this point here by this distance and this distance which would be way too much instead what we need we need a tuple with self.rect.wiff divided by two and self.rec Dot height divided by two and now if I run this this is looking really really nice so what you really have to understand here why all of this works is you have to imagine that this is the origin point for the surface we are currently drawing on and we only want to go a tiny bit to the right and a tiny bit downwards to get the center of this point if we used selfdirected Center we would get the distance all of this distance here which would be way too much understanding the global and the local area for rectangles is really important this is definitely something you want to practice if you want to get really good at Pi game all right with that we can see what we are doing what we now have to figure out is how to actually change the item or more specifically self.index this is going to happen inside of menu in here I want to create another method that I called click this one needs self we need position and we need a button how this click is going to work for now just so that something is working I want to print menu click this click method here is going to be called from inside of the editor which means inside of input I want to create another method this one I called menu underscore click for this one we need itself and we need the event once more what I want to check in here is if event DOT type is equal to pygame dot mouse button down and self dot menu dot rect dot Collide point with my mouse position essentially in here I am checking if I'm pressing the mouse button and if I'm pressing on the menu if that is the case I want self.menu dot click and for this one we need two arguments the position of the mouse and the button that we have pressed with the mouse which we can get very easily we need the mouse position and we need the mouse buttons the naming here might be a tiny bit confusing when I talk about buttons here I mean the mouse button let me actually change it a tiny bit Mouse button and I guess Mouse position you could also Import pygame.mouse in here and get the information from there but I think doing it like this is a bit cleaner now that we have that what I want to do first of all I want to check if we're actually clicking on any of the buttons so for sprite and self dot buttons if Sprite dot direct dot Collide point with the mouse position then I know print let's say button pressed let's try and now I can click on any of the buttons and nothing is happening and the reason why nothing is happening because I'm not calling Mouse click this once again happens inside of the event Loop in here self Dot menu click don't forget to pass in the event and now let's try this again if I now click on any of the buttons with any Mouse button we get button pressed which means all of this is already working at least to an extent in here now I have to check for the different Mouse buttons so if Mouse button and one this would be the middle Mouse click besides that we have if Mouse button two then this would be a right click however I do not want to have if Mouse button 0. the reason for that is if I click on the button with any of my mouse buttons so left right or middle Mouse button I always immediately want to select the current item imagine my terrain button in there I have terrain and water if I left click on it to switch to water I want to immediately select water as a consequence even if I right click on the button I want to select the new item as a consequence there's not going to be if Mouse button 0 instead I want to return a Sprite and then get ID this one doesn't exist yet but but we're going to create it in just a second first of all though inside of menu click I want to save self.selection index and storing it whatever we get from menu click and from when you click we're getting the current Sprite ID which is going to be any of these numbers here for example if we're clicking on land we are getting a number two the logic here does get a tiny bit more complicated I hope it still makes sense let's start by implementing get ID this one should be fairly simple inside of the button I want to create another method get underscore ID in here we need self and all I want to do is I want to return self dot items and now I first of all have to know if I am in main or in Alt this is quite easy to do I am in main if self dot mainactive else alternative this main is going to toggle if we are in main or alternative and this is what I'm checking with here which means self.items is the entire dictionary and with this line here we are either selecting items or items alternative which means we have a new list and from this list I want to get self.index which is once again going to give me a tuple with a key and a surface from this one I want to get the index 0. this is very similar compared to what we have done down here except now we don't get a Surface we get a key while we are here I can also copy all of this and paste it in here it is the exact same logic and with that inside of the editor I can look at my run method and let me print self.selection index if I run main.pi again we're getting an error that we have expected into the block after an if statement on line 46. that happens inside of menu and the problem is I should have added a pass in here Pass and Pass and now let's try this again right now our index is 2 if I click on the coins we have 4 11 and 7. so this is already working not all too badly we are definitely making progress what we now need is the middle Mouse button and the right click the middle Mouse button is the easier actually because all I have to do in here is Sprite dot main active is going to be not Sprite dot main active that way we're just toggling this on and off however this is only the behavior if the Sprite has alternative Sprites which is only the case right now where are the buttons inside of the buttons Only The Palms have alternative items the other three buttons don't and the code right now would crash here because we would have an empty list for the alternative items which we can fix quite easily I only want to have this behavior is Sprite dot items and ALT exists in the first place and if that is not the case this one should be true which means if the Sprite has alternative items then I am switching and toggling them on or off however if the Sprite does not have alternative items this is always going to be true I suppose what you could be doing to make this a tiny bit easier to read you could add the if statement here and then all of this and put else at the bottom and this should be Sprite dot mainactive is going to be true or rather since main active is by default true and we can't change it if there's no alternative item we can just leave it like this let's try this one actually so now if I middle click on the palm trees you can see this one is changing although if I click on anything else nothing is happening besides the selection index changing so this one is working quite well now for the right click I want to get my Sprite and run a switch method that's which method doesn't exist right now so let's create it all we need in here is self and basically what I want to do is self.index is plus equal one which should already work to an extent now if I right click on any of these buttons we get something else although if I keep on clicking for example on the terrain we're getting an error list index out of range for example for the terrain buttons we only have two items so if index gets greater than that we are getting the error that we have an index error to fix that once again we have to limit the index so sell for index is going to be zero if self dot index is greater or equal than the length and now we need to know if we are in the main items or the alternative items which is what we have done a couple of times already so I can just copy it this one here and paste it in there however if that is not the case so else I just want to get myself dot Index this entire line means I want to set self.index to zero if self.index is greater than the length either of the main items or the alternative items however if it is not greater or equal than the length I just want to keep self index as sub index and not make any changes that is all that we are doing in here although I just realized this should be self dot items and then we're indexing on it but now if I run out of this and I right click on any of the buttons we are cycling through the different things that we can do and now for the palm trees if I'm going to click on it and right click we're getting different kinds of palm trees so this is looking really good also if you look in the bottom left we get the different selection indexes I am very happy with that with that I can minimize the buttons and get rid of all of these comments here and the last thing we need I can also minimize the click the last thing we need is a highlight in the cater this one itself and besides that I also want to have an index this method makes sure that it highlights the currently selected button so we have an idea of what we're actually doing in here first of all we have to know what the currently selected rectangle is the easiest way for that I found was to get the editor data again check the index we are currently working on and then I want to check one specific item in here for example I could check if the menu is terrain or coin or enemy and that I think was the best way to approach it I guess you could also go with style but that we're going to use in a bit but now I want to check the menu and if the menu is equal to terrain then I want to draw pygame dot draw Dot rect and here I want to draw on self.display Surface the color we are getting from settings and in here we have the button line color yes I want to pass it here and finally we need a rectangle for the terrain this is going to be the tile button rectangle it's called tile button rectangle by the way because both the water and the terrain are both going to be tiles and they're kind of unique in that respect you'll see later on what that means but now all I have to do is call self.highlight indicator and in here I need the current index which I don't have right now so inside of display I want to have another parameter called index and now inside of the editor I can get rid of this print statement and when I display the menu I want to pass self.selection index into it and now if on all of this you can see that we have highlighted out the terrain so if I click on it you can't see anything but at the very least we know it's working the problem here is that we have to specify a border with with ifset to five besides that there's also border rounding which I have set to four and now if I try this again this is looking at least a little bit better another thing that you can do here is to inflate this rectangle which I do with the inflate method in here again I need X and Y values which I've both set to 4. if I now run this again this is looking much better it's kind of hard to see right now because the background is white but it definitely works I guess inside of the editor I can change the background color to something like Gray and now you can see much better what's going on you can definitely tell the terrain is currently selected same with the water it works the same way all we have to do now is do the same thing for the other three items let me copy the entire thing paste it in here and now I want to check if we're not on terrain but on coin and if that is the case I want to draw a rectangle around the coin button rectangle besides that I can paste this one more time now we have the enemy at least I think that's what it was called if I look at the menu here we have enemy if that is the case I want to have the enemy button rectangle and finally we have to do this one more time and now I want to check if menu is not equal to but inside of a list because the menu here we have to check all of these different items it could either be Palm FG or Pawn BG which means I want to check if the value we currently have selected is either a pawn BG or Pawn FG and with that let's try all of this and now if I select any of them they work except for the pawn tree the problem here I think is that this final rectangle should have been Pawn button rectangle so now if I run this again I can select the different buttons also change the item and this is looking really good cool I'm really happy with that and with that we have finished the entire menu this was once again a larger section but we have made a ton of progress I can actually close the entire menu because we don't need it I think ever again so let me minimize everything and this was one major chunk of the game done now that we can select things I want to start working on creating the tiles that basically means if the player clicks anywhere on the editor we're going to start a position and what the selection index is later on this will be used to draw the entire editor although for now we just work on the input and storing the information let's go over what we have to do number one whenever the player clicks on the editor we have to get the mouse position and convert it to a cell and this cell has to be relative to the origin point think of it like this this one here is the origin point and this one here for example could be the entire map if I for example click here I want to know the distance on the X from the origin and on the Y from the origin if for example this position is inside the First Column with the First Column being 64 pixels and the origin point being at point zero this should be in column 0. you could do the same thing for the yaxis or for the rows if we are somewhere in here then this position should be 0 and 0. however if we are clicking somewhere let's say here then this should be I don't know let's say this is zero this is one this could be two and if I draw another one down here then this would be zero this would be one this would be two which means this cell here would be the cell two and one and that is the information I want to store or that I first have to get on top of that which is really important is that this system has to work with negative numbers because we could get into this direction here and get Negative cells stuff up here for example we could have a cell I don't know what this is but let's say negative 4 and negative 1. these cells we also need to get what is really important about this system is that this origin Point can be moved wherever we want it could be positive or negative infinity and we have to account for that so this is a system we have to implement once we have that what we are going to do is we are going to be creating a dictionary with a key and a value pair like any dictionary the key in this case is going to be the cell position the associated value will be an object that tracks all of the IDS we have used on the cell for example this is again two for terrain free for water four for gold coin and the objects we are using for storage could contain any number of them for example if a cell has water and a gold coin we'll be storing three and four inside of this object and that is what we have to do so let's Jump Right In once again here we have everything and I want to work inside of the editor and let me minimize everything so it's easier to see first of all I need to figure out whenever I click where my mouse position is let's put this in another method that I called get current cell for now we don't need any parameters besides self and for now all I want to do is to print my mouse position don't forget to call it and also we have to figure out when to call this method here for that I need another kind of input which is going to happen inside of the inputs section in here I want to add let's call this one canvas add this is going to be triggered whenever we are clicking on the canvas this one only in itself and nothing else and in here I want if Mouse buttons and zero so we are left clicking on the canvas and not self dot menu Dot rect and Collide point with the mouse position with this we're checking if we're left clicking and we are not clicking on the menu if that is the case I want to run self and get current cell finally all we have to do is to run this canvas ad this again is going to happen inside of the event Loop and here I want to call self.canvas AD and for this one we don't need the event which means if I run this now and I click I get the mouse position however if I click on the menu nothing is going to happen cool so this one is working I can minimize the event loop again and now we can work on getting our current cell and the first thing we have to do let me actually do this in the editor and let me show my mouse there we go right now you can see my mouse moving across the entire editor and if I for example click on this cell here this should be 0 and 0. the actual position if I move this to the side a bit where I have clicked was 24 and 24. this I have to convert to 0 and 0. however we do have a problem because if I show a mouse again and I am doing the same thing again after moving the origin point if I now click again in the top left I am getting roughly the same position but now this number needs to be negative for the simple reason that I clicked on this cell all the way up here which is really far negative from the origin point basically what we are going to do when we are checking for the cells we are checking how far each cell is away from the origin point this is what really matters I guess the confusing thing here is that for the display surface when we're getting the mouse input the origin point is here but we want to have the origin point to be this point here and this is what we have to change I want to get distance to origin and this I think could be a really interesting exercise for you try to figure out the distance to the origin so what is the distance and X and Y from a mouse position to the origin alrighty basically what we want to do here I want to get my mouse position and from that I want to subtract self dot origin there is one adjustment that we are going to need because this mouse position right now is a tubo but we need a vector to do proper Vector math like so and this is all we needed let me print distance to origin so we see what's going on if I run all of this again and I click let me show my mouse if I click here we get 29 and 22. this is now the distance from the origin so this distance here if I click somewhere else we get a larger number which is working as intended so far there's no difference however now if I move the origin Point somewhere here and now I click again in this top left corner we now get a really large negative number only if I click again next to the origin point we get the small numbers that get us to zero and zero and this is working everywhere on this map or editor it works pretty well so this system is already working although we have to make one more adjustment let's have a look at the numbers we got here right now they're all pixel positions let's find a good number let's go with this one here 146 and 91. this right now is simply a pixel position how far we are away from the origin point this I have to convert because I want to have the cells away from the origin not an actual pixel position what this is supposed to be is that we are in cell I think this is going to be three and two these numbers we are getting by dividing this number by the tile size and then getting the integer of that for example this three here would be a 146 divided by 64 and then we're turning all of this into an integer I'm looking at this like this this is probably a 2 and this is going to be a one but you get the idea let me make this a bit smaller and back in the editor I now have to know a column and I have to know a row and this is going to tell me exactly what cell I am on all we need to do is the integer of distance to origin and since this is a vector I can get X and Y quite easily and this I want to divide by the tile size the same thing I want to do for the row in here I can just copy the entire thing and this should be a y and now I can print a tuple with the column and the row and let's run all of this again if I now click let me show my mouse again next to the origin point we get 0 and 0. if I click to the right we get one and zero and we get one and one two and two three and two and so on this is working very well also if I move the origin point we can still click and get the right cell position however if I now click on this cell here we're getting a problem this is 0 and 0 and this is zero and zero which is a minor problem with omf let's talk about it let me draw a couple of columns that makes it much easier to explain we have a bunch of columns here and I'm really bad at drawing straight lines and the origin point is going to be this point here the issue we have right now if we have a point here that is some small number let's say on the xaxis we have 20 pixels and on the yaxis we have 15 pixels if we divide 20 by 64. we are getting 0 if we're taking the integer and if we are getting 15 over 64 we are also getting 0. which means that this x here has a coordinate of 0 and 0 in the coordinate system we have created so far so good however if I clean all of this up and now if I go the other way and I go in this direction here and this direction here and I end up in this point which is let's say negative 40 and negative 50. if I divide negative 40 by 64 or negative 50 by 64. we are also going to get 0 and 0. which in our logic is going to be a problem because 2 pi game this cell here and this cell here have the same position which would break the entire game and would be a massive headache to work with so we have to account for it what I want to do let me do this over multiple lines although you could do all of this on one line but it's easier to read over multiple lines I first want to add an if statement if distance to origin dot X is greater than zero if that is the case I want to have this column the one we have already seen however if that is not the case so else I can copy the entire thing and just subtract one from it that fixes the entire issue it really isn't that difficult the same thing we have to do or let me actually copy it if distance to origin dot Y is greater than zero then we want to get this row however if that is not the case so else then I want to get the same thing 1 and that is it if I run this again now and show my mouse I can again click here and we get 0 1 this looks pretty good however now if I click on the top left of the origin point I get negative 1 and negative 1 negative two and one and so on this is also working very good now cool so with that we have fixed the entire issue all we have to do now is I want to return column and row at the end of this method and with that I can minimize it and not worry about it anymore now we can continue working in the canvas ad method in here first of all I want to get my current cell that is the one we are getting from the method we just created although now I need some way to store the information we are going to create in here this I want to create inside of the init method and in here in the main setup I want to create self dot canvas data right now this is an empty dictionary that's all I need for now although I also want to add this section here I want to call support it's going to be a bit more methods later on in there but let me all of this a bit more properly because we are going to add a ton more methods in here but all right now we can actually work in here if the player is clicking on the editor this is what we already have this is this line here then I want to check if the current position we have is inside of canvas data if that is the case we want to add something if it is not the case we want to create a new key value pair which means I first of all want to check if the current cell is in self dot canvas data if that is the case we don't really know what to do right now so let's just write pass in here however if that is not the case else I want to get self dot can this data and then I'm going to get my current cell as a key and for now let's say I want to add cell in here and after every time we are clicking I want to print self dot canvas data if I now run this and show my mouse you can see that I can add more and more cells and we always have the position of the cell and then cell this cell here is going to become much more complicated but the position is what we really care about for now this is working really well whether there's one more thing that I do want to do later on when we are going to run this we are going to run quite some code that is going to be a bit more processor intensive as a consequence I only want to run this if we are changing the cell which means if the current cell is different from self dot let's call it last selected cell only if that is the case which means we have changed the cell so we went to a different one then I want to run all of this and at the end of it I want to run self dot last selected cell is going to be the current cell all we have to do now is to create this as a proper attribute inside of the init method let's do it below selection and by default this can just be none all this one does is it safeguards us against wasting some resources but if I run this again we can't really see any difference what we now have to figure out is how to create a data structure that can capture all of the data what this basically means is we need some kind of object that can store hypothetically all of these numbers and since that is going to be a tiny bit more complex I want to create a whole new class for it so all the way at the end of this document I want to create a new class this one I called canvas tile there's no inheritance but we do need as always a Dunder init method in here we need self and tile ID this one is going to store quite a bit of information so let me add comments to explain what is happening first of all it is going to check self dot has Terrain this could ever be true or false by default it's going to be false besides that I also want self dot terrain Neighbors and this for now is going to be an empty list imagine we have a Terrain tile here just some empty land what kind of graphic we need for this terrain tile depends on what surrounds it for example if there's a tile here this one would need to be some kind of bottom tile if we had a tile below we would need a top tile something like this which means whenever we have a Terrain we also need to know what neighbors this terrain has and all of this is going to be stored in here next up we need the water and then here the logic is going to be fairly similar first of all we want to check has water and this by default is going to be false besides that I also want to know if self dot water on top this by default is also going to be false the important thing here I can actually show this in the folder here's the game folder I want to look at Graphics terrain and then there we have water and in the animation this is what's supposed to be on top of the water however this is only on the top layer of the water if water is below that we want to have this graphic here if we have two water tiles this one and this one only the top one needs to have the water animation the bottom one can just be a full tile that doesn't need animations next up we need to know what coin we have this one is very simple all we need here is self.coin and by default this is going to be none the system I want to have is that each tire can only have one kind of coin so we couldn't have a gold and a silver coin on the same tile which means this attribute here could either be four five or six and if we're changing it we're getting rid of any other coin besides that we have the enemy and that's the same logic as the coin we have self dot enemy and this is going to be none we can only ever have one enemy per tile finally something we are going to work on much later we are going to need the objects and this is self.objects and for now this is an empty list the logic for the objects like the palm trees and the player are going to be much more complicated for now I am not going to worry about it however what we do need is a method that I called self dot add ID this one itself and a tile ID that is the one we're actually getting from up here and this inside of the editor is going to be the selection index so basically later on when we are creating this object I can actually do it right now we're going to create a canvas tile and pass in self.selection index for example if in settings our selection index is 2 right now we are adding a Terrain tile which means this number here would be a 2 for example and then this is going to be a 2 in here and this two will be passed in here and now we have to create add IB with self and tile ID what we now have to figure out is if this tile ID here is 2 we want to add in self dot terrain that this is supposed to be true and then we need to find the neighbors the neighbors is going to be topic on its own but we want to change this one here and the same would also be the case for water for the enemies for the coins and so on first of all I need to know what options are available this I know from the settings again I need this editor data if again my current selection index or the tile ID is two I want to know the style of this current dictionary and this is going to be a dictionary comprehension which means I want curly brackets and I want key and value for key and value in editor data dot items this right now would duplicate the entire dictionary so we haven't really achieved very much but all I really care about is the style part of the dictionary that we are getting let me actually print what we get that should make all of this much easier to see if I run this now I hope it doesn't crash and it does crash because this self ID here shouldn't itself it just needs tile ID now if I run this there we go this is working and we are getting now in the canvas data 0 and 0 and then an object and this is not what we're doing here but instead this happens because of this line so let's get rid of it and that should make all of this much easier to see there we go now we can see what's going on if I click anywhere on the editor we're getting a dictionary that is the dictionary I have created here the options dictionary we have 0 and player one and Sky to enter rain 3 and water we basically have this key and then only this value here how I want to use that is with a match case statement I want to check match options with my tile ID remember here using match needs python 3.10 if you have an earlier version this is not going to work but you can make the same thing work with an if statement as well although update your python version the first case is going to be Terrain and if that is the case I want to set self dot has terrain to true if the case is water I want self dots as water to be true if the case is coin then I want self.coin and in here I want to have the tile ID for the coin the same thing I can just duplicate it actually for the enemy then selftaught enemy is going to be the tile ID now what does all of this mean and let me try to get all of this on one image let's do some examples to illustrate how this is working the case we have already seen is that tile ID is 2. from the dictionary we have created here we always have key value pairs for example 2 is going to be Terrain and if we're getting indexing like this we know that this 2 is going to be this case which means we want to set self dot has terrain to True which is going to set this terrain all the way up here to true on the same line if this for example let me get rid of all of this if this tile ID was a four a four bought a coin this one here if that was the case we would get this case statement here and we will set self.coin to the tile ID which means this self.coin here would be F4 which would tell us on this tile we want to have a gold coin and later on when we are clicking on this again with for example the number five then we're going to overwrite this and change this 4 to a 5. that way we're getting rid of the gold coin and replace it with a silver coin the same logic is going to happen with the enemies as well I hope all of that makes sense it is a lot of data management later on we have to add a tiny bit more in here to account for the objects but for now I am not too concerned all we have to do now is figure out if this system actually works let me minimize it for now and now we can work inside of this canvas ad again and instead of printing the entire thing I now want for key and value in self.canvas data I want to print an F string with the key which is going to be the position for the value here let's just print the value itself also let me add a bit of white space here so all of this is easier to see if I now run all of this and click on it we are getting something weird and I think the issue here is that this should be canvas dot items or canvas data.items now if I run this this is much better now we're getting a canvas tile object at a certain position which doesn't help us too much but I could now for example check as the rain and if I now click on it we're getting true and we're getting false okay this is very hard to see but trust me it is definitely working illustrating how it works is very hard to do once we get to drawing things all of this is going to make much more sense but first of all the last thing for this section is inside of this when we are clicking on a cell that already has a canvas tile I want to add to this tile and this I get with self dot canvas data and current cell so now instead of creating a new key value pair I am targeting an existing one and this is going to return a canvas tile and on this canvas tile I want to run add ID with myself.selection index this is going to work because inside of this canvas tile we can run this add ID multiple times it is going to work every single time which is all we need here and with that we can add stuff to our editor although we can't really see anything but I guess that is going to come in the next part or rather I'm going to cover this over multiple sections the logic here is a bit more extensive let's get started on drawing the level in here we already know what to draw and where to draw it all of that is coming from the last section where we have created a canvas data dictionary with a position and then a canvas tile that tells us what we want to draw basically all we have to do is to cycle through this camera started dictionary and draw the things associated with it which sounds much easier in theory but it certainly is doable let's Jump Right In and let's have a look at it once again we are in main.pi and I want to keep on working in the editor more specifically I want to add to the drawing section in here I want to have another method let's call it draw level this should be an underscore and then here we need itself and nothing else the main thing we have to do in here is for let's call it cell position and the tile in self dot canvasdata dot items first of all we have to convert this cell position into an actual pixel position so that for example something like 1 and 2 would rather be a 64 and 128. on top of that we have to make sure that this is the position from the origin Point not from the top left of the window this is really important to take care of I'm going to store all of this in a separate variable position seems like a good name and in here I first of all always want to start from the origin once again this is a vector and to this I want to add the cell position and this cell position I want to multiply with the tile size there's one problem this cell position right now is a tuple which we cannot multiply with a number but I can do that if I convert it to a vector there we go this is all we needed now comes the kind of tedious part we have to check all of the different possibilities the one that is most common I think is going to be if tile dot has not water but rain if that is the case I want to Blitz a certain thing let's say self dot display surface and then I want to Blitz something in here we need a surface and we need a position the position we already have that is coming from here the surface is going to become a bit more complicated for now just to have something in here I want to create a let's call it a test surface and this is going to be Pi game dot surface and for the size I want to have the tile size and the tile size again on top of that I want to fill this test surface with a brown color so it's easier to see what's going on once we have that inside of the run method before we are drawing the lines I want self Dodge draw level if I run this now and click we're getting an error the type object is not subscriptable the issue happened on this line here and I realized this shouldn't be square brackets this should be normal brackets like so now they're on this we're getting another error that this should be test surface and now there we go we can draw on this thing and we have a nice logic that works really well also now if I Pan the entire thing all of this is still going to work I should actually show my mouse that I think is going to make all of this easier to see so all of this is working really well we are definitely making some progress and this is looking really nice while we are here there are going to be three more things that we need to add we have to add the water we have to add the coins and we have to add the enemies all of those are going to look kind of like this and they all need the individual if statements and this could be a really good exercise copy this and create the same thing for water coins and enemies and make sure to properly check what kind of tile you are going to have in this position in my case I am going to copy all of this and now for the water I want to check if as water if that is the case I want to create another surface like so and this one I want to have not water this should be blue I can copy The Thing One More Time although for this one I just want to check if tile dot point because of type conversion here if coin is none which is the case by default coin is none this if statement is not going to trigger however once this coin has a 4 a 5 or 6 this if statement is going to trigger so this is still going to work the color here I want to have yellow and we need one more if statement for the enemies like so and just one if tile dot enemy exists and for this one I want to have a red color and with this let's try main.pi let me show my mouse again and now if I draw a Terrain tile we're getting the brown color but if I click or right click on the water and draw again we are now getting blue tiles also if I click on the brown tile you can't really see the result because the terrain is on top of the water but it definitely works I guess if I draw terrain on the water we get brown on top I can also do this for the coins and I can do this for the enemies we are definitely starting to have a start of the game all we really need now is to import a bunch of different Graphics to make this look actually decent let's do that in the next part it is going to be a bit of a larger topic I suppose the most important part of the level editor is drawing the terrain let's work on this one in here we first of all need to import a lot of data and when I say a lot of data I really mean a lot of data let me show it actually here is the project folder there we have Graphics inside of there is terrain and inside of the app we have the land and in there we have a few hundred different graphics these are all the possible Graphics that we could potentially have how the naming scheme here works you are going to see it is a very strange file if you don't know what's going on just be aware we have to import all of this once we have that whenever we are placing a Terrain tile we need to know what's going on with the neighbors and only once we have all of that we can draw the right terrain tile and that is giving us a list we can work through so let's jump into the code and let's figure all of this out here we are back in the code editor and now we have to figure out where to import all of the land tiles and here we do have to be careful because these land tiles need to be available in the editor and later on in the level as well and since there are a ton of Graphics I only want to do this once which means I want to import all of this inside of Main and then pass it into the editor I guess what we can do in here is create another method let's call it Imports need self and nothing else and then here we can import a bunch of different things the one we care about for now is self.land tiles for this one I want to create a function that I called something like import folder as a dictionary this one doesn't exist right now but it's going to exist in just a second and here we need a path to a folder for that we need to go up one folder then to graphics and in there we have terrain and inside of the app we have land if I show defolder again in here you can see we have Graphics terrain and land this is the file path we are following which means what we have to do now is to create this function and since we are going to use it quite a bit I am going to Outsource all of this to a separate file which means I want to create a new Pi file and save it as let's call it support dot pi in here as always we have to import Pi game besides that we need to have access to the file system and this we get with the walk module which we have to import from OS import walk and using this I want to create two functions the first one is import folder and this one needs a path and does a certain thing and besides that I want to have another function that is import folder as a dictionary and here we also need a path those two are going to be fairly similar so let's create them both at the same time the easier one is going to be the import folder let's start working on this one and just to illustrate what's going on let's use this one for now so I'm just importing a folder and I am going to get a ton of surfaces but I don't know the file name of each surface which in some cases I don't really care about it I guess why we're here I also want to run the import this is going to happen right at the top self dot Imports just to make sure that this is working inside of support I want to print the path also I want to add a pattern here so we're not getting an error if I run this now we are getting name input folder is not defined the reason for that is I have to import it so from support import everything now if I run this we can see Graphics terrain land and that is what we're getting from here so this one is working good start what I now want to do in here I want to ultimately create a surface list and this for now is going to be an empty list I want to cycle through whatever files we have inside of this path and then any kind of picture is going to be imported as a surface and placed inside of this list for that we have two for data in Walk and Walk needs a path so this path in here and just to see what we're getting let me print the data it's going to look slightly different if you see this for the first time if I now run off this we are getting a very very long list this list is going to contain three elements although it looks like there's much more the first element we get here this is the name of the folder this is not something we care about at all besides that we get another list and this one will contain all of the subfolders also not something we care about finally we have all of the actual files inside of this folder this is what we actually care about and this is what I want to import which means inside of this I can split this data up into three bits we get the folder name we get sub folders and then we get the image files the image files is all I really care about as a consequence let me just print the image files and let's see what we get we are getting a ton of different image files or not really image files rather it is names of image files a.png is just a string right now we have to convert it to a full path and then use this path to import the image as a surface although first of all I have to cycle through this list which means for image name in image files I want to do a couple of things first of all I have to get a full path and this full path is going to be the folder plus the file name once I have to fold path I can create an image surface and then I want to let me add this as a comment I want to add the image surface to the surface list first of all we need the folder path in here and the folder path we are getting from this path remember in main.pi we are passing in this folder path in here and this is what leads us to the folder which means the folder path is just going to be the path to that I want to first of all add slash and then I want to have the image name and just to see what we get let me print the full path and comment this one out and if I run main.pi we're getting a whole bunch of file names but in here the important bit is we always start with Graphics terrain and land then we're adding a slash and then we're getting the file name and this happens hundreds of times once I have that I can use this image path to import an image surface and this is going to be pygame dot image dot load and that should be an equal sign and I want to use my full path this is going to give me the actual surface and this surface I want to add to this surface list which means I want to have the surface list append a surface and the surface I want to append is the image surface and that is all we need all I have to do now is to return this surface list and that way all of the land tiles are going to be surfaces from this folder which means I can print self.land tiles run all of this again and we are getting a huge amount of surfaces all the stuff we have just imported although for the land tiles I need to know the file name and this one is not going to give me that as a consequence I have this import folder as a dictionary the key here is going to be the name of the file and the value is going to be the actual surface and this I think could be a really good exercise try to convert this function here so that we are creating a dictionary with key value pairs the key being the file name and the value being the surface pause the video now and try to figure this one out I think the easiest way to start is to copy all of this and now we don't have a surface list we have a surface dictionary which means curly brackets these two lines can stay exactly as they are as can full path the image surface is also fine let me remove the white space here this one isn't really necessary and finally the only real change that we have to make is now we have a surface dictionary and for this one I want to have the file name and for the value here I want to have the image surface so I can delete this one here as well one more change that we do have to make this shouldn't be file name this should be the image name the image name right now would be something like a DOT PNG and this dot PNG is going to be kind of annoying so I want to get rid of it which I can do with the split method I want to split this string wherever we have a DOT this is then going to return a list with the file name and the file ending in this case I only care about the one with the index 0 which is always going to be the file name without the file ending after I have that I can return the surface dictionary and we should be done if I now use import for that dictionary and run the entire thing I now get a really large dictionary that always has a key with the name of the file and then an Associated value which is the surface which seems to be working just fine cool with that I can close the support file because we don't have to change it anymore with that we can import a bunch of things quite easily and now when I'm creating the editor I want to pass in self.land tiles which means inside of the editor we need another parameter which is going to be land tiles on top of that let me add another section here that I call Imports I want to store my land tiles as an attribute inside of the class and tiles so now we have a bunch of Graphics that we can be using and we could already implement this to an extent at least when I'm drawing the level I only care about terrain right now let me minimize everything else in here for the test surface we could actually use self.land tiles and a generic one in here is the one with x I could just use that and don't fill it with a color and now if I run this and I let me show my mouse and I draw a Terrain you can already see a graphic which is not looking bad at all the problem is you can see it quite easily all of those look identical but that is not something I want for example for this title here I want this to have something like this where we have a connection to this tile and to this tile and also to this tile here we have to always find the neighbors for each of these terrain tile and then get the appropriate graphic which is going to be a fun little topic to work on let's have a look basically what we have to do inside of canvas tile we have to fill this terrain Neighbors and for that we need a bunch of logic which I have stored in a separate method inside of the support section I created a method called check Neighbors there is one parameter we need in here and this is going to be a cell position the most important thing we have to do in here as the name of the method applies we have to check the neighbors obviously but there is going to be a problem and let me draw the issue actually let me add pass in here and run this entire thing again and I'm going to draw a whole bunch of terrain tiles all of that something like this now we have a ton of different terrain tiles and now I want to add a new tile in here and this tile needs to check what its neighbors are doing which in this case would be I want to check these three tiles here and then change this tile here the problem is I want to make sure that I am only changing this grid here the cells that are surrounding the current tile I am working on what I do not want to do is check every single terrain tile that we have because we could have thousands of terrain tiles I do not want to check all of them and as a consequence I want to create what I called a local cluster and those are the terrain tiles that surround the current tile we have just placed sounds a bit complicated it's not that difficult to implement but first of all I wanted another comment and I want to create create a local cluster and then here first of all I want to create a cluster size which I have set to free and from that I want to create my local luster and this is going to be a list comprehension what I want in here if this is the current cell I'm working on this would be my cell position I want to know this style here this tile here is tied here here here here here here and here so by the end of it we have eight tiles that we are going to look at I guess nine theoretically because this one is going to be included but this one doesn't matter so much also the cluster size here refers to this distance here and this distance here we have a cluster that is three by three columns at rows you could make this larger if you really wanted to but there isn't really a reason to I guess the one thing you want to be careful here if you're placing a new tile here it might change existing tiles for example if this tile before we place the yellow tile was a top tile that looked something like this after we are placed in the yellow tile it needs to be a bottom tile once I Implement all of this it's going to make a lot more sense I want to place let's say a tile which is just going to be a string for now but that is going to change or call in range cluster size this is going to give me the columns and then again I want for Row in range Laster size as well just to illustrate what is happening right now let me for Row in local cluster and print row now we have to figure out when to call this check neighbors and this is going to be called whenever we use canvas add I want to run self dot check Neighbors this cell I want to pass in here is the current cell now if I run the entire thing press anywhere we are getting a bunch of tiles okay it's not particularly helpful but if I minimize canvas add and just print the local cluster that might illustrate a bit better what's going on print local cluster and click anywhere we're getting a list with nine different tiles because we have three columns and three rows we are going to get nine items in total what we now have to figure out is the actual position for each of these tiles and this is always going to be a tuple with a row and a column although here we do have to account for quite a bit although let me print it right now if I do it like so we're always getting from 0 to 2 and 2. also I want to put this over multiple lines so it's easier to read and fits on my screen there we go I think this is going to be a bit easier for the row and by the way I think this could be a really interesting exercise what I want to do in the end is if I for example click on let me use a simple number if I click on this tile here I want a local cluster to be these tiles the top left one is going to be 0 and 0 then we have one and zero and we have two and zero and so on the same thing this should be zero and one and zero and two and then down here we have two and two right now this is what we always get however if I now add a tile let's say here the local cluster should be this area with this bottom one here there should be negative one and negative one then we have negative two and negative 1 and negative three and negative one and so on these numbers here always have to be relative to the position you just placed you basically want to create a row and a column that is always relative to the sub position and then circles around the cell position so positively now and see if we can figure this one out all right let's get started and I realized already this should be column and row because this one is X and this one is Y which is how our position also works this column right now is always going to be 0 1 or 2 because of this range here this number we want to add to the cell position and I want to get cell position and X the same thing I want to do for the row so let me copy the entire thing paste it in here and this should be a one if I now print the entire thing let's do it somewhere here we're getting the start position here one and one and then keep on going down so we are making progress although if I am drawing what we're doing right now if I place it here again and give me a bit of space this is actually working very good the first cell I get is one and one which is this one here then I'm getting 1 and 2 which is this one here then I'm getting one and three this one here then I go to the next row which is this one here and here we're getting these three cells which is 2 1 2 2 and 2 3. finally we're going to the third row here we have three one three two and three free which means whatever terrain we are placing we always get this area here which is a good start but not exactly what we want the area we actually want is this one here to fix that we have to move the entire local cluster up by one cell until left by one cell or more specifically and to be a bit more flexible I want to subtract it by the cluster size divided by 2 and then I want to have the integer this I want to have both for the column and for the row and now if I do this again and draw for example a tile here and move it to the side again the first tile I'm getting now is one at one which is this one and one here the final cell I get is free and free which is the one down here which means the entire thing now is this area exactly what I wanted so we are making some really good progress now that I have that I can actually check the neighbors with that first of all I want for cell in local cluster I want to go for all of the cells I have just created and now I want to check if cell is in self dot canvas data meaning I want to check if any of the cells I've just created actually exist and have a Terrain tile or exist in the first place for now if that is the case I can get myself dot canvas data and pass in the cell I am currently looking at and whenever we start this I want to set my terrain neighbors to an empty list that way if we are running this check neighbors multiple times we're not adding pointless data in here which can be very problematic and once we have all of that we can actually check the neighbors of all of the tiles inside of this local cluster if this is the tile we have currently placed we have to check all of its neighbors all of the eight neighbors it can possibly have on top of that for all of the neighbors so all of the tiles in our local cluster these tiles here they also need to check what their neighbors are meaning once again we have to check what their neighbors are doing which means for every cell in local cluster if it exists we want to check all of the neighbors and for that inside of settings let me minimize the editor data we have neighbor directions inside of this dictionary we have a key a and then a position the way you have to think about it if this is the cell we are currently checking a is the one on top then we have b c e e f G and H the keys we have here these are all the four possible directions and this is what I want to check for which means in here I want to check for name and site in neighbor directions dot items don't forget that I want to get my current neighbor cell just to make the math a bit easier and this neighbor cell is going to be a cell I'm currently looking at and in here again we need X and Y so let me do cell zero and cell one right now we are copying the cell but that's not what I want to do instead I want to add a side which here is going to be side 0 and for y it is going to be side 1. aside as a reminder is always this position here for example for a the cell right on top if we're going zero for the xaxis and negative 1 for y we are staying here for x and we're just going up by one cell if we for example use D we are going one to the right this one here and then we're going one down this is this one here and that way we're ending up in the bottom right which means with this line we are getting the current neighbor inside of this for loop on this neighbor cell I first of all want to check if it exists in the first place so if neighbor cell in self dot canvas data if it's not in there there's no point doing anything because there is no cell however if there is one we can check if self dot canvas data I want to get the neighbor cell and now I want to check if it has a Terrain if that is the case I want to get myself dot canvas data and to sell I am currently looking at I want to get the terrain neighbors and I want to append the name this name here that we are looking at if we have a tile here and there's one tile on top only this tile would mean we are adding the letter A to terrain Neighbors and what that means if I open the graphics folder again here we go inside of this folder we for example have a and if we only have the terrain neighbor a it means this is the tile we are currently looking at and there's one tile on top and as a consequence we want to have a tile that ends at the bottom and that is all we need here I am fully aware that this logic here does get quite a bit more advanced so if you're following this there's a pretty good chance you're confused definitely go over this a couple of times to understand the logic but for now this is all we need so I can minimize check Neighbors and now when I'm drawing if tile has terrain I first of all want to have a Terrain string and this terrain string is going to be the title I'm currently looking at and then terrain neighbors this right now is going to be a list this list I want to convert to a string which I do with an empty string and then the join method although there's one more thing that we have to do let's say I want to have a Terrain Style this is not going to be self.land.x instead this is going to be the terrain string but only if the terrain string is in self.land tiles if that is not the case I want to add X what that means is if the terrain string we have created doesn't exist in the graphics we have imported I want to have the generic graphic X that basically always works this is both a safeguard so if we forgot to import one graphic the game doesn't crash on top of that some tiles are just by themselves and I didn't really account for that they are just way too many graphics and this way if they're by themselves we always have this outcome and we are nearly done the last thing we need is now I'm using this terrain style as a key to get the surface so terrain style in here and now this should be working let's try and let me show my mouse if I now print something we are getting something that almost Works uh not great yet but we have to work with this a tiny bit more let's have a look on the editor I'm pretty sure draw level works just fine because we are getting something so let's have a look at Czech neighbors and I can tell the error happened in here in the neighbor cell because this side should be one not zero now if I try this again and let me show my mouse again if I now draw on here we have a proper tiling system and this one is looking really good also if I move around all of this is still working just fine and with that we have the terrain I am really happy with this and this system is really satisfying cool so this covers a really large section before we finish with this part I do want to go over the main logic and just quickly explain it again I think this is a really important part that you absolutely have to understand inside of the editor Let Me minimize everything our starting point is always the canvas add method in here we are adding something to our editor these lines here in particular are the most important ones because in here we are creating a new canvas tile or we are adding to this canvas tile depending on what id we have after that we are checking all of the current neighbors and this is really important especially for the terrain tiles because this one determines the graphic of the terrain tile so let's have a look what check neighbors actually does and how it works first of all we are creating a local cluster think of if this one here is the title we are currently looking at we need to know all of the neighbors there are eight Neighbors in total that we are going to care about these eight here and that information is incredibly important because whenever we are placing a Terrain tile we need to know what its neighbors are doing for example if a Terrain tile has something on top it needs to be a bottomish tile and if there's a tile on top and a tile below it should be some kind of connector tile something like this that is open both on top and on the bottom also really important here why we are creating a cluster is later on in the game we might have thousands of terrain tiles and we don't want to check all of them we only want to check the ones that are right next to the current tire and this is why the local cluster here is incredibly important now once we have that what we need to do is to go for every single of these local tiles that we have created that is important because when we are placing a new tile let's say we are placing this yellow tile here if there's a tile to the right of it this one here this one needs to change as well if this one for example previously was by itself now if there's a tile on the right the yellow one here then this one needs to be open to the right and as a consequence we have to check for every cell in the local cluster we have to check all of these tiles here that is super important let me clean this one up a tiny bit so we can see what's going on on the next line we are checking if the cell is inside of the canvas data and once we have that we are creating an empty list for the neighbors and this list is going to contain some letters that are going to be important I'll talk about that right now actually what we're doing in this bit here most importantly for a name site in neighbor the directions and the items how this one is essentially going to work for every single one of these tiles we're going to check all of the neighbors the top neighbor would be a the top right would be B then we have C then d then e for the one right below then we have f d and H and essentially what we're doing we're going clockwise for every single tile inside of the local cluster and we are checking what neighbors are there and depending on what neighbors are available we're going to add the relevant number to terrain Neighbors let's say a tile has the neighbors a c and d then the strings we are going to attach in here are going to be a c and d all of that is happening down here which means by the end of it the terrain neighbors is just a list with a couple of strings inside and each string is one letter once we have that bit of information I can open the graphics folder again go to Graphics in here we have the terrain then we have land and inside of there we have all of these files with weird names but I hope now they make sense for example if we have a tile let's choose one it's a bit more random let's go with this one here this one is called CEF this means if we have a tile here we want to check if there's a tile in not in a not in B but there should be one in C then not in D but then in e f but not in G or h this CEF is going to come from the c e f depending on what the neighbors are that is how the entire system is going to work and that is also why there are going to be a ton of different Graphics in here on top of that there are quite a few duplicates in here for example if you check these two they are identical you could probably optimize this entire system quite a bit but in my case I'm not too concerned so all right the last thing we now need is to understand the system when we are drawing the level and we have some terrain like this one here we are combining the terrain neighbor strings into one larger string then we are checking if the string is inside of the imported graphics if that is not the case the string name is going to be x and x is if I open this again all the way at the bottom we have this tile here this one fits basically everywhere oh well it doesn't fit everywhere but it looks fine by itself and then this is going to be the graphic we are blitting on the screen I hope all of that makes sense the logic here does get a bit more complicated all right with that we have our terrains next up we can start working on the water let's talk about the water now and the water is going to work quite a bit like the terrain we again have to import some graphics and then check the neighbors of every tile and then we can draw the water although the water is going to be a little bit easier all we really care about if we have two water tiles like so the top water tile should have a water animation whereas the bottom water bit should have a plain graphic this one doesn't need to be animated for this section we are going to have the bottom graphic and we are going to know if we need a top graphic animation but the animation itself we are going to cover in the next part I want to keep things separated and the animations are a larger bit by themselves but we already have all the major Concepts in place so this shouldn't be too difficult let's Jump Right In once again we are in our code and I want to work inside of the editor I guess you could import the water surfaces in here like we have done for the land tiles although there aren't that many water tiles so I'm going to do all of this inside of the editor to keep things a bit cleaner and more selfcontained inside of the editor what I want to do in here since we are going to import a few more things I want to create another method that I called import all we need in here is self and water bottom and this is just going to be a graphic we want to load for that I want to have the load method that is not available right now which I can fix quite easily I want from pygame dot image import load only now is a file path to my water bottom file this one if I open the graphics folder and make this a tiny bit smaller we have to go through Graphics inside of there we have the terrain and inside of the terrain we have water and there we have animation and water bottom water bottom is what we care about right now which means we have to add a string go one folder up then to graphics then to terrain and there we have water and in here I care about water bottom dot PNG water top we are not going to import right now because later on for the animations we are going to have separate Logic for that meaning for now this is all we are going to need don't forget to call it and this I have done after I have imported the lamp tiles I guess it kind of makes sense in here self dot Imports I think this was just import yeah just import let me actually self.import and now we have to figure out a few more things most importantly we have to work inside Czech neighbors one more time because in here we are checking the neighbors right now all we're doing in here is we are checking the neighbors of the terrain tiles let me actually add a comment in here to rain nay verse besides that I also want to know if water top neighbor exists to figure out the top neighbor here we are going to need a couple of things although before I am doing this I would really recommend you to try this one yourself you kind of have to modify the logic here a fair bit to figure out if there is let's say water in the current tile and another water tile on top if these conditions are true you know the tile on top has water if that is the case if I look at the canvas tile again in there we have has water this one we can already cover but what we care about is if we have to set water on top to true or not this is what we are trying to figure out however if these two conditions are true then we can set water on top to true so pause the video now and see if we can figure this one out yourself I want to check if self dot canvas data and now I want to look at the neighbor cell that's the one we have created up here on this one I want to check if it has water on top of that I want to check if self dot canvas data and my current cell that is the cell we are checking from the current cluster and that's basically our current cell the one that we are working with right now if that is the case I know one of the neighbor cells has water but what I care about here in particular is if this cell is on top of the current cell and that I can check with another condition the condition being if name is equal to a there you can see it all this works because if I go to settings in here we have the neighbor directions and a is the cell right on top or in other words it's the top neighbor this is the only one we really care about if that is the case I want to get self.canvas data and my current cell on this I want to set water on top to true on top of that there's one more thing that I do want to do like we have done with the terrain neighbors I want to set self dot canvas data and sell water on top should be false meaning every time we are running this we first of all remove all of the neighbors that makes it much easier later on when we're deleting tiles to not worry about this again the reason why this one is important and let me remove the comments here if we didn't have these two lines later on when we are deleting tiles we would have a problem let's say you have two tiles of water and as a consequence the top tile here has water for the animation on top of that the bottom tile here this one would have water on top being true however if we delete it this top tile the bottom tile would still have water on top as true and as a consequence the graphic now would be wrong the same would happen with the terrain neighbors and all of this can be avoided with these two lines here we are basically resetting the entire system and then recreating it from scratch and that way later on when we delete things this makes everything much easier so with that we have the neighbors for the water or the one neighbor all we need now when we are drawing the level we have to account for that and this happens inside tile has water in here I want to check if tile water on top if that is the case I want to get myself dot display surface and I want to split something once again I need a surface and I need a position the position we already have that's the one we created up here the surface we also have that's the one we imported in self dot Imports this one here which means all we have to do now is self.water bottom I think I called it and that is literally all we need I guess one more thing that we do need is the rest should be inside of an else statement and I'm going to change the color to make this a bit more emphasized let's change this to a red color so it's definitely visible now let me run main.pi again and we are getting an error that we have some problem in selfimport and I believe I know what the issue is import is a restricted name because we are using import here and that one confuses python let's change it to Imports and that should fix the entire thing there we go this is much better now if I show my mouse and I switch to water we are getting a key error let's have a look I think I already know where the issue is it is definitely going to happen somewhere in here and while we are here I realized on this self canvas data and cell we want to check if this one has water the main problem we have right now is when we're using the neighbor cell on canvas data this tile does not exist that wasn't a problem for the terrain neighbors because they have we are checking if the neighbor cell was in the canvas data this if statement we want to do for the water as well like so and this one has to be indented and now this should be working we are only doing this operation if the neighbor cell actually exists now let's try this again and let me show my mouse again right now I have the terrain and this one works just fine if I now change to water we're getting a red cell but now we're getting a water tile and the water tile we are only getting if we have water on top if we don't we don't get that and this one also updates perfectly fine so this is a pretty good start for the water definitely a good start and sorry about the errors it's kind of hard to keep this much code organized and explain it at the same time but with that we have the water or at least parts of the water what we know to figure out is a bunch of animations and that's gonna be its own section for the next part we are going to create the animated tiles in the game there are lots of tiles that can be animated like the top water the coins and the enemies those are the main ones there is also going to be the player and the palm trees but those are going to be objects not tiles welcome to those later in this tutorial now for the animations to work we first of all have to import a ton of different graphics after that we have to figure out how to animate all of these separate objects and for this one we are not going to use Sprites you might actually Wonder so far for each tile why am I not using a Sprite for example each terrain tile could be a Sprite the answer here is that Sprites are generally fine but in the editor we could potentially have thousands of items on the screen at the same time and for that Sprites would be very slow and avoiding them improved game performance significantly when I tested all of this if I remember correctly when I use Sprites you could only place about two to three hundred terrain tiles and then the game would slow down drastically if we don't use Sprites we can place up to a thousand and not really have performance issues although later on we are going to use them to an extent but alright with that covered we can start working in the code once more we have main.pi again and once again I want to work inside of the editor Let Me minimize everything and I want to add a bit of white space Here and Now work in Imports again what I have to do in here I have to import animations let's just call it animations because we already importing in here anyway essentially what I want to have I want to have a dictionary that I called animations for now it's just going to be an empty dictionary inside of it I want to have something like this I want to have first of all a key let's go if I look at settings we can look for example at the water and the water would have an index of three this three I want to keep here and then the associated value is going to be another dictionary with three items we have a frame index and this one is always going to start at zero then I want to have the frames and those are going to be let's say it's going to be a list and this list is going to contain surfaces the surfaces we're going to Loop through for the animation finally the last thing I want is going to be the length of the animation and this could be an integer let's say four or rather for the water we have three animation frames once we have all of this we can create animations fairly easily first of all I need for key and value in editor data dot items meaning we are looping through this entire thing here inside of that I want to check if the value has an entry for graphics and only if that is the case I guess let's talk about Graphics first if I look at settings for example for water and I scrolled to the right quite a bit all the way at the end we have a graphics key and the associated value is a folder for the water it would be the animation for the top this is what we care about here for example for the gold coin that's this one here we have a folder for the gold coin and all of these contain animations and this is what I want to import which means first of all I want to create a graphics variable and now I want to import a folder like we have done in main.pi let me copy from support import everything and this I want to do in here as well and let me add a bit of white space all of this is a bit easier to understand the file path we are getting from value graphics there we go and with that we have Graphics imported next up we need to actually create an entry inside of this dictionary for that I want to have self.animations and now I need a key the key I am already getting from this one so I can just pass in key in here the value I am going to give it is going to be another dictionary the dictionary we have created here or we are going to create we always start with a frame index and this one is always going to be zero after that we want some frames and the frames are going to be the graphics finally I want to have the length of the animation and this is just going to be the length of my frames which is going to be the length of the graphics folder that is all we need I can now delete the example and print what we actually get print self dot animations if I now run all of this you can see if I for example look at the first bit we have zero and this one has a bunch of different things this is all the stuff for the player that's not what we care about right now I guess this one here is better we have three that's the one for the water we have a frame index of zero then we have frames and this is a list with three items these free bits here and finally we have a length this one is telling us when we have to stop the animation and start again that looks really good with that I can minimize let me first get rid of the print statement now I can minimize the Imports method what we are now able to do inside of draw level we can start using these imported Graphics let's start with water first of all in here I want to have the frames more isolated and those I get with self dot animations and I know the water is always going to have the index three so I can just pass it in here and from that I want to get the frames this is going to give me the water animation frames besides that I need to have some kind of index because this here is a list and we have to pick one item from it for that we have self dot animations the same entry again for the water and in here we want to have the frame Index this one we're going to increase over time and if this for example gets to one or two we're going to pick a different item by default it's going to be zero although since this value could potentially become a floating Point number I always want to convert this to an integer finally let me get rid of these two items here and instead I want to create another surface and this is going to be frames and index finally all I have to do is get rid of this test so we're using this surface here and now let's try if this is working I can still draw terrain just fine and now if I print water we are getting at least a proper graphic so this is already definitely some progress although not entirely what we needed but at the very least this one is working all we have to figure out now is how to increase this index over time for that I'm going to minimize draw level and inside of support I need another method this one I called animation update and then here we need self and we need Delta time all I really want to do in here I want to go through my self.animations dictionary although for this one I only really care about the values which means or value in self dot animations dot well use in here for each value I want to get the frame index and this I want to increase by what is called the animation speed this is a constant that I have defined inside of settings it's always going to be eight although you could change the number if you feel the animations are too fast or too slow and this value I want to multiply with Delta time that way its frame rate independent if your game slows down or runs really fast the animation speed is going to be the same finally we have one more problem and that is if value and frame index is greater or equal than value and the length of the animation think of it like this the frame index always starts at zero and we are increasing this number by a small amount on every single frame let's say by 0.2 which means on the first frame we have zero then we have 0.2 and we have 0.4 let me separate this properly and so on this is fine for quite some time at least a couple of frames however quite fast we are going to get a number that is let me put it on the next line we are going to get a number that is let's say a 7.2 completely random number the issue with this 7.2 is that we only have for the water we have three animation frames and since we are indexing later on this 7.3 is going to cause an error because we are trying to get a larger index that exists inside of a list which is going to be an issue that we have to account for accounting for it is very easy though I just want to get my value frame index again and set it to zero which means every time the frame index gets created in the length of the list so we are exceeding the animation we want to restart the animation with that we have the animation update all we have to figure out now is when to call it for that let me minimize it inside of the run method we only have a drawing part right now I want to add I'm going to call it updating as a section in here I want self.animation update don't forget to pass Delta time in here and now we should be done actually if I now run this again show my mouse the terrain tiles work just as before and now for the water we have animations the bottom ones still work just fine and I can add things and have all of this work perfectly fine and the reason why this is working if I look inside of draw level again we still have the same logic here the only difference now is that this number keeps on increasing at the start it is always going to be zero but because of Animation update this number gets larger and larger although at some point if we're exceeding the length of the animation it goes back to zero but that is literally all that this one is doing with that I can minimize hairspot it has terrain because those two are done and now what we have to do is cover the coin and the enemy and those two I think would be a really interesting exercise for you inside of the dictionary there are coin animations and they are enemy animations try to draw them with the animation and see if you can figure this one out let's start with the tile coin in here once again we need to get some frames and the frames I want to get in here is once again self dot animations the same thing we have done for the water up here although now for the coins we are not entirely sure what kind of index we have because title coin could be either 4 5 or 6. the number here depends if we have a gold or silver coin or a diamond fortunately that's not really something we have to worry about because we can just pass in tile.coin in here because this one stores the number four five or six depending on what coin we have and on that I want to get the frames with that I have the graphics next up I need the index for that I can just copy the line we have created up here and change the three to tile and coin I can get rid of this test surface and replace it with frames and my index I also don't want to fill anything anymore instead I want to get the surface and get the position and then we should be almost done there's one more thing we have to do but we should at the very least have an animation if I run this again and select a coin I can place some coins also now if I select the silver coin I can't draw them and if I draw them over gold coin the gold coin disappears this also works with the diamonds so this is working really nicely on top of that if I pan around this also works with the panning around however let me actually run this again if I only create one coin the problem you can see right now is that this coin is always in the top right corner instead it should be right in the center which means we have to make a few more adjustments the way I approach this I have created a rectangle and for this one I want to get the surface we just created and then get underscore wrecked I want to place this center for the center we need an X and A Y position although we already have that to an extent we have position 0 that's the X bit and we have position one that's the way but this is what we have created up here the problem is these two numbers are too far to the top left let me draw a tile that looks like this these two positions are this top bit up here and since the surface doesn't cover this entire area we are placing the surface here which is why the coin is in the top left of each tile to account for that I want to move the center of the coin so this Center here to the middle of the current tile for that I have to get the top left move it to the center or increase it by half of this entire width the same thing I have to do for the height this is going to be one half of the entire thing if I do that this top Point here is right in the center and this is exactly the point I'm looking for which means all I have to do is to add tile size and divide it by two the same thing I have to do for the Y position and now what I'm placing all of this with blit I don't want to have a position I want to have a rectangle let's try it now and now if I place the coins this is looking much better also works with the other coins and with the diamonds and big nozzle pan around all of this looks pretty good I can also still place the terrain and I can place the water oh this is looking really good finally I can minimize the tile coin and we have to work on the enemies although truth be told this is going to be quite some luck compared to the coins so let me copy a bit of code here although I guess you could make this a tiny bit more efficient but in my case I'm not too concerned fourth childhood enemy we want to have tile and enemy and then the frames for the index we also want to have the enemy index surface can remain identical though and the center we probably have to change in just a bit but for now let's see what this one is actually doing if I now select one of the enemies this is the bottom right bit here I can now Place some spikes this one's looking good I can place this little guy here he animates and we can place the shells also the shot can go left or right most of this is looking pretty good although we do have a bit of a problem and that is this area down here right now all of the shells are floating and there's a tiny Gap below the enemy this I do have to account for which I'm doing inside of this line here what I want to do now I want to place the mid bottom if you imagine that this is the cell and this is the top left part of the cell this used to be our origin point now what I want to do is this mid bottom is going to be this point and this is what I want to have for the origin Point as a consequence kinda similar compared to what we have done with the coins we have to go halfway one half to the right except now we have to go the entire height down so just one the entire height of the tile and then we're ending on this point here which means for X we don't have to make any kind of change only for y we have to get rid of the divide by two and that should be all if I now run this again I can select some spikes they still work just fine but if I now place an enemy he is right on the bottom and most importantly the shells are also on the bottom and that is looking really good cool so with that we have the animations there's one more really important thing that we have to cover and that is deleting tiles for now we are only able to add more tiles but well we couldn't get rid of them let's work on that and that's not going to be too difficult so we can jump right in once again we are in main.pi and I want to work inside of the editor in here inside of the input section I already have canvas add I now want to add canvas remove neat self and nothing else and the first thing we have to check in here is if we are right clicking on the canvas and if we are not clicking on the menu this means I want to check if Mouse buttons don't forget to call it and two this is going to be the right click and not self dot menu Dot rect and Collide point with my mouse position and it should be fairly obvious I only want to delete tiles if I am right clicking and if I'm not clicking on the menu if that is the case I first of all want to check if self dot canvas has any kind of Entry if it doesn't there isn't any point in deleting anything if that is the case however I want to get my current cell that I get from self and get current sell once I have that I want to check if the current cell is in self.canvas data now I know that I have right clicked somewhere on the canvas there's something inside of the canvas and I know the position of where I have clicked if where I have clicked actually targets an existing tile I want to get this tile so self dot canvas data and the current cell and on this I want to remove ID with self.selection Index this remove ID is going to work kind of similar compared to ad ID if I scroll down a tiny bit and minimize the init method we have ADD ID remove ID is going to be another method that has the same parameters and is kind of going to do the opposite once again I want to get my options I can just copy them and besides that I can actually copy the entire thing because we are going to check for every single kind of option we have here I should probably explain for the tile delete Logic the way deleting is going to work is we can only delete the currently selected tile index for example I only want to be able to delete terrain if I have terrain currently selected same for water same for the coins and so on that way I have some control over what I am going to delete all I have to do in here now is when I'm removing something I'm going to set terrain and has terrain to false the same thing I want to do for the water this one should be false self.coin should be none and self dot enemy should also be none there's one more thing that I do want to check this I have called is going to be another method self dot check content let me create it right here again what this one is going to do is if all of these cases are false meaning on this current tile there simply is no data I want to delete this entire tile the problem is I cannot do this from inside of the tile because all of this is stored inside of self.canvas data the dictionary which means for now inside of this check content I want to have an attribute that is called self dot is empty if there's nothing left inside of this tile meaning all of these cases are false or none this one should be set to true that being said by default inside of the init method let me do it all the way at the end self dot is empty is going to be false all I have to do now is to figure out when this is going to be empty and that is basically just a bunch of if statements so if not self dot has not water but Terrain and not self.s now we have water and not self.coin and node self Dot and me if all of these are wrong I know this one is going to be empty once I know that it is going to be empty inside of canvas remove I can now check after I added a bit of white space if self dot canvas data and my current cell if this one is empty then I want to delete this current cell or the entire key value pair like so and then I am done let's try this actually so inside of the event Loop besides cell dot canvas Edge I also want to have self.canvas remove and I guess I could add a bit of white space here to make all of this a bit more spacious cool so now inside of main.pi I am getting an error that I made a typo this one should be delete not Define never on this again this is looking good and I can place some terrain tiles and now if I right click we are getting an error this remove ID we have a problem the reason here is this should be remove ID now if I play some terrain tiles I can right click and it disappears although you can see a problem we have to call check neighbors again to update this entire thing otherwise it would look a bit weird but that we can do quite easily if I minimize canvas tile after I have run all of this I want to run self.check Neighbors in here don't forget I have to pass in my current cell although I messed up the annotations here a tiny bit those two should only be run if we are or if the current cell is in the canvas data otherwise this line here might cause an error because this tile might not exist but with that let's try all of this one more time I can place some terrain tiles and now if I right click they disappear and this is feeling really good I can keep on adding and removing also now if I add some water I can also remove this and it updates perfectly fine and now to understand the system if I place a gold coin like so and if I right click now on the water the water isn't being affected but if I go over the coins the coins are affected that way I have quite a bit of control over what I am going to delete which I quite think is useful well with that we have been making quite a bit of progress this is definitely a very satisfying system or the next part we can start working on the objects and let me explain what that is going to mean so far we only worked with tiles those are always going to be placed in a grid however some objects in the game are supposed to be working differently and those are going to be called objects these can be moved flexibly anywhere on the screen the best example here is the player this one needs to be moved anywhere wherever we want and I think the best way to think about it is to actually illustrate it so let me run the finished game this one here and here you can already see we have the tiles just as before and I can also Place water tiles all of this is what we already have however now we can move the player around wherever we want there is no limitation in terms of tiles the same thing is also going to work with the sky so the sky we can move up and down as we want there's no limitation in terms of tiles furthermore we have the palm trees and those can also be moved around freely because for those let me place a few more those just don't really fit exactly on a tile grid I want it to be more flexible here and all of this is what we are going to implement via objects so this is what we have to work on all of this though is going to require quite a bit of additional logic so let's Jump Right In and let's cover all of it here we are back in the project and once again I want to work inside of the editor in here we need some kind of object that can actually work as well an object and in my case I have used Sprites for that so fundamentally we have two different things to draw the level we have all of the tiles those are the canvas tiles and besides that I want to create another class this one I have called canvas object and importantly here this one is going to be a Sprite so we have to inherit from pygame.sprite dot Sprite as a consequence the first thing we have to do is declare an init method and here we need itself besides that we're going to need a position we are going to need some frames as well because the objects are also going to be animated besides that each object is also going to have a tile ID that way we can identify it this for example means inside of settings all of the palm trees are going to be objects and I want to store the 11 12 13 and so on for each of them that way I know exactly what kind of object I am working with besides that I also want to have an origin point this one I'm going to explain more in just a bit but this one is really important to figure out where this canvas object is placed inside of the grid finally we need a group because we have a Sprite and we need to place the Sprite inside of a group with all of that covered we have to call this super init method and pass in the group in here just to get started for now I want to create a basic self.image and this is just going to be pygame Dot surface in here we can create a surface with the size of 100 times 200. this I want to fill with a color so we can see it more easily let's go with red and finally we are going to need a rectangle so self.rect and this is going to be self.mage.get underscore rect this should also be spelled correctly in here I want to place the center wherever the position is and I am getting much worse at typing there we go with all of this at the very least we have some kind of sprite that we are able to see we just have to figure out how to place it for that we have multiple angles if I look at settings we have all of these different palm trees here we have the foreground palm trees and the background palm trees those I want to be able to select from the menu and then place anywhere on the screen however besides that I also have the player and I have the sky those are going to be on the level when we are starting the level meaning those cannot be placed they are always there as a consequence both of those have to be created inside of the init method so we already have them and that makes it quite easy to fix things as they come along so let's get started by placing the player this one is just going to be another canvas object all of this is going to happen inside of the init method in here let's do it all the way at the bottom I want to place the objects for that first of all I have to create a group this let's call it canvas objects this is just going to be pygame.sprite dot group once we have that I want to create one canvas object and that is going to be the player I suppose I could add a comment here that is going to be the player we don't actually have to store this canvas object inside of an attribute you could but there's simply no reason for it in here we now need all of the parameters that we have created in here let me copy them and fill them with some kind of argument for the position we can go Fairly random in my case I went 200 pixels from the left and then I place the player in the center of the window in the yaxis which means window height divided by 2. after that we are going to need the frames those we are getting from settings as well because in settings if I scroll down the player does have some graphics we can just use those we already have them imported those we have inside of imports and inside of the animations which means I want to get self.animations the index I'm looking for here is zero that is the player and on this I want to get the frames I hope you can remember this is what we have imported here next up we have the tile ID for the player this one is going to be zero and the origin is going to be the origin of the actual editor which means it is this origin here meaning I can just place self.orgion in here and I'm good to go inside of the class later on we are going to work with this quite a bit for now don't worry too much about it finally we need to group and this is self dot canvas objects with all of that going over multiple lines let me use named arguments so it's a bit easier to read we have the position we have the frames then we have the tile ID next up is the origin and finally we have the group much easier to read if I run this now we can't say any difference the reason is we are not drawing any of these objects that we can do quite easily inside of raw level after we have done all of this here I want to get my self dot canvas objects and draw them on the display surface and now if I run this we can see we have an object this is going to be the player we can't really see it right now but at the very least something is going to happen although the issue is if I pan around you can see the player doesn't update or doesn't pan around with the rest of the level which is something we do have to work on all of that is going to happen inside of the canvas object or at least most of it is I am going to add a movement section here like so and this one is going to first of all need self and distance to origin this is a really important thing we have to know and this needs to be a vector with the distance of my current object let me draw this actually I want to know when I am placing or creating the Sprite we have the entire window and somewhere in here we have the Sprite besides that we have the origin somewhere here what I want to know in distance to origin is going to be this distance here we have done this earlier so it shouldn't be too difficult the math here really isn't too challenging all we need is a vector of self.rect and top left and from that I'm going to subtract the origin this is the origin we're getting from the parameters which is the origin we are passing in here which is the actual origin up here of the level or the editor once I have that bit of information I can create another method let's call it pan position in here we need self and we need to know where the origin point is which means I want to pass in An Origin in here and now we are going to do basically what we have done way earlier in this tutorial which is when we are panning around meaning we have the origin point and we are moving the origin point in this direction if we now have a Sprite we want this Sprite with this origin point we want this Sprite to move in the same direction those two errors here are supposed to be identical I'm just bad at drawing to achieve that what we are going to do we are going to place the top left on the position of this new origin and then we already know the distance to the origin when we have placed it that is going to be this distance here once we have this distance we can simply move this thing around and then we have this new Vector that is going to be identical to the original I hope all of that makes sense the logic here well you definitely want to play around with this a bit but all I really want to do is I want to get self.direct.top left and I want to place this wherever the origin is and to that I want to add self dot distance to origin which means now if I do all of this again we are starting with the blue part this is the blue part I have drawn in here we are setting the top left of our Sprite to the position of the origin this however isn't enough because we need to get this distance to origin here to account for a distance and that way we go from this point to this point here all we have to do now when we are panning the entire editor this one here I want to in the panning update besides updating the origin I also want to update every single Sprite this is going to be for sprite in self dot canvas objects all I have to do in here is Sprite dot pen position and pass in self dot origin now if I run all of this and Pan the entire thing we are always accounting for the origin and that way everything works as intended very happy with this this is looking good now we can minimize the pan input and we never have to worry about this one again which means we can Flash out the canvas object quite a bit more the first thing I want to work on is the animation because I don't want to have a plain red rectangle for all of the images I want to have an animation for that animation we need frames first of all and those are the frames we are already getting we don't do anything with them right now I am for now just going to store them inside of an attribute besides that we are going to need self.frame index this we have already done some animations is the number we are going to increase and now instead of drawing a plain red rectangle I want to get myself dot frames and on that I want to get myself dot frame index just as a reminder self.frames right now is just a list with surfaces and we are picking one of those with that we don't have to fill the entire surface anymore and this should already give us something that looks much better meaning if I run minute pipe we can see the pirate and the pirate can also be panned around this is definitely making some progress all we have to do now is to create an animate method this one itself and Delta time inside of this one if you want to challenge yourself you should be able to create an animate method quite easily at this point so positively now and see if you can figure this one out first of all I want to increase self dot frame index with plus equal and then I want to get the animation speed and multiply it by Delta time once I have that I want to update myself dot image and this is going to be self dot frames in here we want to get self dot frame index there are going to be a couple of major problems first of all this self.frame index is probably going to be a floating Point number because Delta time is a very small number and if you multiply it with animation speed which I believe is eight we are going to end up with a multiplication of 8 by 0.01 or something like that since we cannot do indexing with a floating Point number I want to convert this Frame index into an integer the next problem we have is that inside of self.frames we probably have something like five to six surfaces and we're always getting them by indexing however this self.frame index is going to be larger than the length of this cell.frames very quickly and this we have to account for what we have to do in here is self dot frame index is going to be zero if itself dot frame index is greater or equal than the length of self dot frames if that is not the case meaning else I just want to keep self frame index as the frame index and that is all we need all we have to do now is to actually call the animate method inside of an update method in here we need itself and Delta time just as before and call Self dot animate with Delta time we are nearly done with the animations we just have to call this update method inside of the run method inside of updating since all of the canvas objects are going to be inside of the canvas objects group I can call it update on this one and now if I run main.pi we are getting an error the canvas object update needs Delta time which we can just pass in here and now if I run this we have the animation for the player this is quite nice although there's one more thing that I would like to add in here and that is for each animation I also want to update the rectangle that way if the surface changes too much we're not moving this thing around and this is just going to be self.mage.getwrecked again and in here I want to place them at bottom with the position being where the mid bottom of the rectangle was in the last frame this way the rectangle or this entire Sprite is always going to stay in the same position which definitely makes a small difference but that is all we need for animate now we can minimize it and never worry about it again next up we have another problem if I run main.pi again I guess I can show my mouse if I click on the player nothing is going to happen there's no way to interact with it at all right now and this I want to change the first thing I want to do is that we can drag this object around in the editor for that we need two more attributes I'm going to put them inside of movement first one is self dot selected this by default is going to be false this is just going to be an attribute that tells us if we currently have this spread selected or not besides that I want to have self and this one I called Mouse offset by default it's going to be a vector with 0 and 0. and let me explain why we are going to need this we want to move a Sprite that could look something like this on the Sprite we are always going to be constrained to moving one point say we could move this point here or at this point here or at this point here and these are all of the predefined points inside of a rectangle so we have top left top right center and so on in my case I am always going to move the top left let me get rid of the other points and this is the point we are actually going to move for the Sprite this however is a problem because when the player is clicking on a Sprite we might get a click here or here or here or here and the player expects that we don't instantly jump the top left position to let's say this point here and to account for that we have this mouse offset this is always going to be the distance between the top left and the pointer player clicked on this point we have to get every time the player is clicking on this object let me put all of this inside of a separate method let's call it start drag this one itself and nothing else in here we first of all have to make sure that self dot selected is going to be true besides that I want to have self dot mouse offset as a reminder this point is going to be the distance between the top left and the position the player actually clicked on just to make sure that you can still follow along try to figure this one out yourself this should be a very simple Vector operation don't overthink this we first of all need to get the mouse position don't forget to call it this mouse position is going to be one of these blue axes from this I want to subtract self.rect dot top left which is going to be the top left position this one here the problem we have right now is that both of these are two builds which we couldn't really work with but that is an easy thing to fix all we have to do is to convert both of them to a vector with that we know when we are dragging and we also have an offset to the mouse which means now I can minimize the method and the next thing that I want to do let's actually put this inside another method to keep things a bit more organized and this one I called drag in here we need self and nothing else if self dot selected is true I want to place self.rect dot top left to the position of my mouse although remember this is what I just talked about right now we are just placing the mouse position which is going to be this top left here this point we have to adjust a tiny bit because we need this offset here to get to this point which we can get very easily because this is what we have done inside of start drag meaning I want to subtract self dot mouse offset with that I can drag things around all I have to do is call Self dot drag I suppose we could test this one if I set selected to true if I now Run the game and show my mouse you can see the player is always going to be following the mouse this one is working really well although the problem right now is I can never get rid of the player anymore which is a tiny bit annoying which means we have to add a bit more code that we can control if a Sprite is selected or not let me set it to false again for that I'm going to minimize the canvas object and the run method inside of the input I want to have another method which I called object rack in here we need itself and we need an event for this one I want to check if the event DOT type is equal to pygame dot mouse button down meaning right now I know if I am clicking anywhere on the editor besides that I also want to know if Mouse buttons and zero that means I am left clicking somewhere on the editor if that is the case I want to look at all of my Sprites which I'm doing with a for Loop for sprite in self dot canvas objects inside of this I want to check if I'm actually clicking on a Sprite so sprite.rect dot Collide point and I want to check we can go either with the event position or with mouse position both is fine it's going to give you the same result I guess since we're using events let me use the event position if this if condition returns a true I want to set Sprite and start drag this is the method we have created just a few minutes ago this start drag here which means if I inside of the event Loop add self dot object drag with an event we should be getting something and let me show my mouse I can now click on the player and move the player around although there are quite a few different problems the first one is even after I release my mouse the player keeps on following me however if I keep on clicking I am also drawing while dragging the player meaning this is something we do have to work on this is a very strange Behavior I'm going to start by not drawing a tile if I have an object selected for that inside of the init method I want to create self dot object drag and I'm going to call this active by default this one is going to be false but anytime we have any kind of drag for any object active this one is going to be true which means inside of this object drag if this if statement is true I also want to set self dot object drag active to true this I can now use inside of canvas ad this is where we are drawing all of the tiles right now and we are checking if we are pressing the left Mouse button and if we're not colliding with the menu I want to add another if statement in here and that is going to be and not self object drag active which means I only want to draw a Terrain tile for example if we are left clicking if we're not clicking on the menu and if we don't have an object currently selected there is one more change we do have to make and you might be able to spot it if I run main.pi and I click on the player if I click for the first time we are placing a Terrain tile but if I click again nothing is going to happen the reason for that is inside of the event Loop we are calling canvas add before the object drag as a consequence we are drawing something and then we make it impossible to draw as a consequence we are drawing one terrain tile this we can fix quite easily by just placing the object drag before canvas add now I can select my player let me show my mouse again move them around and everything works just fine I am not drawing anything on the editor the problem now is I can't get rid of my player that's going to be the next bit this is also going to happen inside of object drag inside of here I want to check another if statement I first of all need to create another if statement where we are checking if we are releasing the mouse button which means if event DOT type is equal to Mouse button up however this we only want to check and this should be pygame dot mouse button up this we only want to check if we currently have something selected which means and self object drag active if these two conditions are true I know we currently have something selected and we are releasing the mouse button which tells me I want to unselect whatever Sprite I currently have selected and for that I need for sprite in self dot canvas objects once more and if Sprite is selected then I want to let's put all of this in another method that I called and drag in here once again we need the origin you will see in a second why although besides that I also want to set self dot object drag active back to false that is all we need inside of this one I can minimize it and now inside of my canvas object I can Define drag end in here we need self and don't forget the parameter for the origin the most important thing now is self dot selected is going to be false and now I think this drag and I called something else inside of the object drag ah I called it and drag this should be drag end we have drag end and we have drag end this one's looking good now inside of main.pi I can run this let me show my mouse again I can now click on My Player move the player around and release the player and now we are getting an error that error is happening inside of here because this needs to be self dot origin now let me try this again I can click on the player I can release the player and this one seems fine although now you can see it if I pan around let me do it again let me move the player somewhere here and if I now pan the player is teleporting around the reason for that is inside of the player or the canvas object after drag end we have a problem because this distance to the origin which we needed for the panning has changed so once we start to pan the player is going to be teleported around depending on where this position is to account for that I can just duplicate this line and paste it in here and now we get a new distance to origin and that way we can pan around properly again meaning if I try this now I can move the player around I can also pan and everything is working perfectly fine I am very happy with this this is looking really good there's actually only one more thing that we absolutely have to do inside of this canvas object and that is we have to store the tile ID this one is honestly super simple all we need is self.tile ID is going to be the tile ID this part is going to become really important later on but for now we don't really need it but I can't minimize the canvas objects and now we need one more thing before we can place objects from the menu and that is inside of the init method we have two objects we have to create when the editor is starting we have the player and besides that we also need the sky this is going to be a simple object that is not animated and it's basically the thing that determines the height of the sky this is also something we have to store inside of another attribute let me call it Sky handle this one is going to be a canvas object and we need a couple of different things in here the most important one is for the frames we are only going to have a single surface and this one we have to import which is going to happen inside of imports besides water Bottom I want let me call this the sky handle surface I just have to load it and then here we need a string with one fold up then Graphics inside of there we have the cursors and inside of there we have handle dot PNG inside of the folder I want to look at Graphics inside of there we have cursors and there we have the handle this is what we are going to import on top of that I forgot for both of those they need to be convert Alpha that way the game is going to run a tiny bit faster and as I'm saying this I realized if I open support again when we are loading this image surface here and this image surface here we're not converting them which is going to be really bad for performance which means I want to convert Alpha both that is going to help massively for the performance of the game with that covered we can create a sky handle and that I want to be an exercise the position should be in the middle of the window the graphic we already have and the index you can also figure out so all you really need is the position which means you have to create a canvas object that is right in the middle with this graphic here and the index you can get from the editor data you're looking for the sky and pause the video now and see if you can figure this one out we have to start with the position and this is going to be a tuple with X and Y since I want to Sky handle to be right in the middle of the window this is going to be window width divided by 2 and window height divided by two next up we have to work on the frames and in here you do have to be a tiny bit careful obviously we need self.sky handle surface the one we have imported down here however inside of the canvas object class we are cycling for a list for the animation so for the frames we don't need one surface we need a list with surfaces as a consequence this one needs to be a list with this one surface you could make this a tiny bit more fancy to only animate this canvas object if there's more or if there's a list of surfaces but in my case this isn't going to be too much of an issue next up we need the tile ID this one we are getting from the editor data and sky is one which means tile ID is one as well the origin is going to be self dot origin and finally group is going to be quite simple because we only have one group self dot canvas objects with that I can get rid of this position here and finally let me show my mouse I can click on the sky handle and move this one around I can release it and it doesn't move anymore and now I can move the player and I can also pan around all of this is working really well obviously I can combine this with terrain tiles as well and all of this is working super well there is some definite progress being made I can now minimize the init method and the last thing we are going to need for this section it is getting quite long but I want to have all of the main part of the object inside of one section when I am adding something to the canvas this canvas here I am always adding a tile but this isn't necessarily the case because sometimes I'm going to place an object which means inside of here I have to check if I am placing a tile or if I'm placing an object this I can do with another if statement I want to check if my editor data in here I want to look at myself Dot selectionindex and on this I have a type if I look at settings we have type this is either object or it can be tile for the tiles we have placed so far there's coin there's enemy and there's the terrain and water these are all tiles however for the poems we have object and this we can check specifically we're checking this in here meaning we want to do all of this only if this one is a tile I want to have all of this indented and if that is not the case so else then I want to place an object which means all I have to do is create another canvas object this one is going to need the mouse position I guess let me use named arguments I want to have the position where my mouse is next up I'm going to need some frames this I get with self dot animations in here we have self.selection index and this once again is what we're getting from import on this I want to get the frames next up we need a tile ID that in this case is just going to be self dot selection index and the same is going to be with the origin in here we need self dot origin finally the last thing we need is the group once again we only have one group we need self dot canvas objects and with that every time I am clicking on the editor with an object selected we should be placing an object although before testing this I realized there's one error this should be a comparison operator not an assignment operator and now if I run out of this and let me show my mouse once again I can now click on the palm tree and place it somewhere here and we have a new object I can also move this around and this one I can do multiple times this one is working really well we do have a problem though and that is if I hope I Mouse down and drag it around I can place a whole bunch of palm trees a substantial amount actually and well you can probably tell this isn't exactly ideal for performance so we do have to account here for quite a few different things but at the very least for now we can place different things I guess while we are here I can try to place another tile or palm tree there and I can also place the background ones it's kind of hard to see because there's no preview but all of this we are going to work on more at the very least now you can see something is working and we can definitely Place different things all of this is coming together just fine now that we have the basics of objects we can refine some things for this part I want to keep things a bit more simple I want to do two things number one there should be a timer when we are placing objects that way I couldn't drag around and create tens of thousands of palm trees besides that the player should also be able to delete objects both of these things are fairly easy to implement so let's Jump Right In Here we are back in our code and I want to keep on working inside of the editor to start with the timer inside of the init method when I'm creating all of the objects I want to create one more attribute and this I called self.object timer this is going to be a timer a class I'm going to create in just a second and when I'm creating this class I want to specify how long the timer is which in this case is going to be 400 milliseconds and this time of class I'm going to create in a separate python file and save it as timer dot pi inside of this one I as always have to import pygame but I don't need anything else I want to create a timer class inside of this I want to have an init method we need itself and we need a duration iteration should be an attribute and besides that I also want to know if this timer is active or not meaning we need another attribute by default it is going to be false there's one more thing that we do need and that is the start time which by default is going to be zero but we are going to overwrite this anyway now inside of this I want to have an activate method and I want to have it the activate method when we are activating the timer I want to set self.active to true and self dot start time is going to be the current time in the game which is going to be Pi game dot time dot get underscore ticks deactivate is going to be basically the opposite we are setting self DOT active to false and self dot start time is going to be zero with that we have a couple of basic attributes that we can use to actually create a timer this one I am doing inside of an update method in here we need self and nothing else and now to explain how the timer is going to work let's say this one here is a timeline of the entire game with this point being 0 or the start of the game when we're calling pygametime.getix we're getting some number in here it really doesn't matter what it is to create a timer I now need three bits of information the first bit is the start time this one we create up here and we are setting when we are calling the activate method let's say for Simplicity the start time could be somewhere here at 500 milliseconds so we are running this method half a second after the start of the game that is the first bit of information the second bit of information is the duration that is what we are getting up here this one is telling us how long this timer is going to last let me draw a random error and the timer I want to create is supposed to run for 400 milliseconds or a bit less than half a second with that I know how long the timer is going to last all I have to do now is to constantly check my timer and this I want to do inside of the update method down here what this method is going to do it is going to check the time constantly all the time and we are at some point going to end up with this point here which is greater than the start point plus the duration as a consequence we know this timer has run out that is the entire logic I want in here so let me clean this one up a tiny bit I guess I can keep the main drawing up there that's quite helpful inside of the update method actually this could be a really good exercise from the drawing try to create your own timer logic and see if you can figure this one out first of all I have to get the current time this I get once again with pygame DOT time dot get underscore ticks this is what I've talked about earlier this one checks the time constantly if you are here here here here here here or here and if you are wondering the difference between these two get ticks is the method itself does the same thing the difference is that disk ethics is being called constantly while this get ticks is only called once whenever we are starting this timer as a consequence those two do slightly different things once we have that I want to check if my current time minus my self dot start time is greater or equal than self dot duration and if that is the case I want to run self.d activate and the logic here I hope is quite straightforward we are checking the current time this one could be here for example right now and we are checking if this number minus self dot start time that is this number here is greater than self dot duration which is this distance here and if that's the case we can deactivate the timer now we have a timer class that we can use inside of the editor although we first of all have to import it which means from timer import timer let me run my notepad to make sure everything is working we're not crashing that's generally a good sign with that covered when I am running canvas ad and I am placing an object I only want to place the object if the timer is not active which means if not self dot object timer DOT active only if this timer is not active I want to be able to place an object and once we have place an object I want to activate this timer which means self dot object timer dot activate the one thing we need now is to actually update this timer because inside of update we have this update method and this one isn't being called right now this I am going to do inside of the run method in here we have an updating part and inside of that I want to call self.objecttimer Dot update and this should be all we need if I now run main.pi again and select a palm tree I can now only place them every so often I cannot drag them like crazy anymore I can still place a huge amount of them and if I draw too many performance is going to suffer although it is going to be much less bad than it used to be so I'm kind of okay with that what we have to work on now is to give the player the ability to delete objects and for that we already have a method called canvas remove although in here we are only checking if we want to remove a tile or not meaning we have to make this thing a tiny bit more flexible let me put all of this stuff here under tiles or rather delete tiles besides that I also want to have delete object to delete an object we first have to know if there is an object selected so we know that we have an object that we currently are targeting this object I want to store in a separate variable let's call it selected object this one we can't get particularly easily right now as a consequence I'm going to create another method this I called Mouse on object this I'm going to create inside of the support part Mouse on object we need self and nothing else and all we are really going to do in here is we're going to check all of the Sprites or Sprite in self dot canvas objects and I want to know if my mouse is currently on any of these Sprites which I get with Sprite dot rect dot Collide point and my mouse position if that is the case I want to return the Sprite that is all I need in here and now if this is the case if we have a selected object then we can do something and the thing we want to do is get this selected object and destroy it with the kill method I can run main.pi and if I now left click on the player the player disappears same with the sky handle and I think you can already tell where the problem here is the player should not be able to delete the player or rather the pirate for that I want to add another if statement and that if statement is going to be could be a good exercise actually make sure that the player is only able to delete the palm trees all of these here the player should not be able to lead ever the player or the sky and when I say player here I mean the pirate I hope that makes sense try to figure this one out it should be doable inside of this one line of code that the player cannot get rid of the pirate or of the sky pause the video now and see if we can figure this one out I want to check if inside of the editor data I have a selected object dot tile ID remember tile ID is inside of settings and I can close the timer we don't need it anymore inside of settings we have all of these keys and this is telling us what kind of object we have inside of each of the associated dictionaries we get a certain kind of style this is what we want to check for meaning I want to check the style and only if this is not in the player or in the sky only if that is the case I want to delete the object which means now if I run main.pi and I left click on the player nothing is happening anymore although I can still drag the pirate around however now if I place a palm tree and right click on it it disappears this I can do multiple times let me place a couple of palm trees they all disappear if I right click on them and with that we have made a ton of progress this is all we need inside of this method for the next part we are going to create a preview and this basically means right now it is really hard to tell what is currently being placed as a consequence there should be a preview so the player knows what kind of tile or object is going to be placed however there's one caveat and that is if the player hovers over an object there should be an indicator that this object can be dragged in my case what I went with if we have an object here I want to draw some indicators around it these pinkish things are going to be the indicator this is what we are going to do all of this is going to happen inside of one method inside of the editor so we can all cover it in one part so let's get right to it once again we have main.pi but I only care about the editor inside of here I want to first of all add a bit of white space and then inside of drawing I want to create a preview method that doesn't need any custom parameters and this preview method is going to do two major things it is going to give us a preview of the tile or object that we want to place and it draws lines around objects when hovered over that way we know what we are going to place or if we have something selected although first of all we have to figure out which of these two we currently are doing so is the play hovering over an object or is the player placing a new element so we need an if statement to separate these two cases and for that we already have a really useful method that is the one I created earlier Mouse on object this one telling us if the player is hovering over an object or not this I want to use to get the current let's call it selected object and this we get with self.mouse on object remember this mouse an object is going to return the object we are currently hovering over meaning we are getting a Sprite once we have that we can check if selected object exists and if that is the case I want to draw lines around this object and if that is not the case so else I want to show a preview although there's one more thing we do have to do and that is all of this should only happen if the mouse is not over the menu meaning I want to indent all of this and add another if statement that if not self dot menu.rect dot Collide point with the mouse position that part should be fairly selfexplanatory we don't want to show any preview if the player hovers over the menu that'd be kind of weird and with that we can start working on let's start with the first if statement and let me add a pass in the other so we're not getting an error if we have a selected object I want to draw lines around it first of all for that I need a few bits of information the most important one is I need some kind of rectangle and this rectangle I'm getting from the selected object since this one is a Sprite I can Target the rectangle and let's just leave it at that although I do want to copy it once we have that just to make sure we can see something I can for example do pygame dot draw dot rect in here we need a surface we need a color and we need a rectangle the rectangle is the easiest part this we already have the color we are going to change anyway so for now let's use red so it's something we can see quite easily finally we need a surface and this in my case is going to be the display surface and with that we should already be able to see if we are hovering over an object the last thing we have to do is to call this method that happens inside of the run method in here inside of the drawing section I want to draw the preview this I have done before we are drawing the menu I want the menu always to be on top so and here self.preview let's call it and this should be all we need if I now run the entire thing and show my mouse I can hover over the pirate we get a rectangle and also if I hover over the sky handle this also works on top of that even if I move around the pirate the red rectangle stays around which is a really good start even if I add a new palm tree you can see if I have over it it shows that it's being selected so this is working really well although just showing let me minimize this just showing a red rectangle really isn't ideal so we have to refine this and I want to get rid of this drawing method here instead let me explain what I want to do the rectangle we have right now looks something like this and what I want to do is to draw the lines around it something like this every single line in here is going to be drawn with pygame.draw.lines this one allows us to draw a line although we first of all need to figure out how to expand this rectangle so these indicators are a bit further outside this we fortunately can do quite easily instead of copying the rectangle I want to inflate the rectangle I'm going to inflate it by 10 and 10 pixels which means we're inflating it in this and this direction by 10 pixels or rather 5 pixels on the bottom and 5 pixels on top the same thing is going to happen for right and left they are both going to expand by 5 pixels that way we're getting a bit of a distance between the actual Sprite and the indicators all of this is going to happen inside of this rectangle once we have that I want to figure out how to actually get these lines here and for that I want to declare a couple more variables the first one is a color that's why I don't have to write the same color over and over again but this one I want to go with black next up I need a width the width is the line width I set this one to three and finally I want to have a size this I have set to 15. what this size means if I show this one again this size here for example could refer to this distance here or to this distance here once we have all of that we can actually start with the drawing and what we need in here is pygame dot draw dot lines inside of that we need a couple of different arguments we need a surface to draw on we need a color we need to tell Pi game if the line is closed or not then we need the actual points we want to use and finally we need the line width most of these are really easy for example the color we already have with the color here the line width is also very easy that is the width here let me change the line with just a width and we are good to go the surface is also quite easy I want self.d display surface closed means if we have a couple of points let's say I have a point here a point here and a point here and Pi game is going to connect them like so if closed is activated it is going to draw another line from the last to the first point which in my case I do not want which means I'm going to add a false in here the only really complicated bit inside of here is points because for this one we need a list and this list has to contain three points each of them is going to be X and Y so let me add X and Y in here and then I can talk about this in detail what I want to happen in here if this is the original Sprite that we have selected that we are getting from up here the selected object around that we have created a larger rectangle this rectangle here this one looks something like this the larger size we are getting from inflate what I want to do now is to draw for example in the top left to do that I need to figure out three points I need this point here I need this point here and finally I need this point here these are the points I'm going to figure out down here down here and down here and I think this could be a really good exercise for you try to figure out these three points and see if you can draw this line so pause the view now and try this one all right let's do together now the easiest point we can get is the top left point because this one is literally just the top left and I can clean this one up a tiny bit we also don't need the inner rectangle anymore this second Point here that is the red one we just need the top left of the rectangle which we get with rect DOT top left with that we already have the first point covered next up I'm going to work on this point here for this point we know we are on the left side of the rectangle which means X is quite easy to get all we need is rect dot left why we can get quite easily as well because we know we are all the way at the top and we want to go down by a certain amount the amount being this size here in our case we want to go down 15 pixels as a consequence for why I want to get rect.top minus the size there's only one more point that we need and that is this point here or the yellow point this one is going to work in kind of a similar way we know for this one we are all the way on the top of this rectangle which makes y quite easy all we need is rect dot top for X we know that we are all the way on the left side and we want to go 15 pixels to the right the same 15 we have gotten here as a consequence for X I want to get rect.left plus this size and with that I can clean all of this one up and now let's try to run this and see if it works if I now hover over my player I can see this is almost working I just messed up the blue point but this we can fix quite easily the problem here is this line this should be less instead of minus if I run this again now now this is working just fine cool the problem with this one was that the origin point is in the top left and if you want to go down we have to increase y instead of decreasing and this is what I got wrong here but well all we have to do now is to this three more times meaning I can duplicate it and well we already have the top left besides that I want to have the top right then I want to have the bottom right and finally I need the bottom left all of these points are going to be fairly simple geometry so let's go for them one by one this one here is the top right if I make all of this visible and we have a rectangle like so the one we already covered is this one here so we don't have to worry about it the one I'm going to work on next is going to be the top right this one here well that once again I want to have one rectangle a second rectangle and then a third rectangle once again the red one is the easiest one because this one here inside of the top left we want to have the top right for the blue rectangle we know we are on the top of the rectangle and we want to go 15 pixels to the left that I can do in here for X I want to have rect not left but right and from that I want to subtract the size for why I am happy just with the top that is giving us the blue and the red rectangle finally we have to work on the yellow one for this one for X we just want to stay on the not the left side but the right side and from the top we want to go down so plus 15 pixels and with that we should have the top right let's try if I now hover over the player this is looking really good cool next up and I guess I can do this one without drawing we have the bottom left bottom right actually is this one and we have the bottom left or the bottom right I want to have as the Middle Point the bottom right and the first point we want in here is rect dot right and from that I want to subtract the size with the Y part we can just use the bottom one or the final point for X we want rect dot right this one doesn't need the size and then I want to have rect dot bottom and from that I want to subtract the size with that we should have the bottom right let's try this one and this is also looking pretty good and if you are struggling just draw these points yourself it's not that hard to follow along if you play around with this a tiny bit finally we need the bottom left meaning the Middle Point again is very easy then for the starting point I want to have rect.left this one I can leave as it is but now I want rect dot bottom minus the size besides that we need a point that goes horizontally that is going to be this one here meaning I can leave this one as it is but this one should be rect dot bottom and this is all we need at least as long as I didn't make a mistake so let's try and this is looking really good this works with any kind of object even for place of objects like a palm tree they can all be selected and we can move them around so I'm really happy with this let's try another palm tree like so or this one or this one and they all look really good so with that we have the overlay if we have something selected covered so next up we can work on the else statement that we want to actually preview something if we are placing a new element for this one we first of all have to know are we placing a tile or are we placing an object because those two need different logic to separate the two I want to create a type dictionary this one we are going to create with dictionary comprehension meaning in here I want a key and a value or key and value in editor data dot items with this line here once again we are copying this entire dictionary which we don't need all I want in here is the type do I have an object or do I have a tile that's all I care about so instead of getting the entire value all I want is the type of the value we are currently looking at once I have that I want to get a Surface now for that I need a bunch of surfaces which I don't have right now however if you look at settings inside of this dictionary we have a menu surface and we have a preview these I want to import this is going to happen inside of the Imports method and here all the way at the bottom I can add another comment for preview and now we have to import all of these surfaces and I want to store them as preview surfaces and what I want to get out of here is another dictionary that has key value pairs the key is always going to be the ID for the object for example if we have a number two in here if I look at this dictionary again I want to have this 2 and Associated as a value here should be this previous surface which is going to be for the land tiles the same for water although this one should have a key of three which means for this dictionary for example I want to have 2 and a rain surface and all of that we can get with dictionary comprehension once again in here I want to have a key and on this key I have a value and let's do the same thing again for key and value in editor data dot items right now once again we are just going to copy this entire dictionary so wouldn't be helpful however what I can do now I know on this value which is another dictionary and this dictionary has one key called preview and the associated value for that is going to be a path to one surface and this I want to import which means here I can use the load method to actually import a surface and with this you would get the different surfaces however there's one issue if I look at settings again the player and the sky do not have a previous surface which means if we were to run this we would be getting an error but this we can fix quite easily I only want to run any of this if value and preview actually exists if it doesn't we just want to skip it and that is all we need here now we have our previous surfaces and I can use them inside of here so I want to get myself dot preview surfaces and since we once again have key value pairs I can get the surface here quite easily although for that I need indexing and I want to have myself dot selection index on this one I want to copy the surface that we have the reason for that is for the surface we have currently selected I want to change the alpha value to something like 200. that way it is going to be a little bit transparent which is quite important for a preview I don't want this to be too obvious once we have to surface we just have to find the position and for that we have to separate between tile and object and now all we have to do is if the type dictionary and self dot selection index is actually a tile that is working because this dictionary here has a key for the ID and the value is the type and the type is either object or tile which enables this if statement here if that is the case I need to find some kind of position and for the position I need to currently select itself meaning I want to have a current cell and this I get with self dot get current cell this is a method we created all the way in the beginning this get current cell here and now that we have a current cell I want to create a rectangle this rectangle is going to be the surface we have just imported and on that I want to get wrecked here I want to place the top left position and on this I always want to start from self.origin to that I want to get the current cell although I want to multiply this one by the tile size since the current cell is a tuple I have to convert this to a vector but that is actually all I need now all the way at the end of this method or rather of the if statement I want to self dot display surface.blit and since I now have a surface and a rectangle I can just pass the surface and the rectangle in here and I should be good to go at least on a very basic level and now if I run this and let me show my mouse I can see the preview of the lamp tiles this also works with water this also works with the coins and this is also going to work with the spikes and with the enemies so I am very happy with that the only problem we have right now is the palm trees are not going to work and we are getting an error the reason for that is we are not doing anything with the objects so we are getting an error fortunately that one is really easy to fix we need to first of all an else statement so besides the tile we are working on an object and for this one now we have to create a rectangle and this part is going to be your exercise try to get the rectangle for the object and see what you are going to need if you want a tip check out the canvas ad to see how the object is going to be placed that is going to be really important but pause the video now and see if you can figure this one out the answer here is going to be I want to get the surface I already have and on that I want to call Get Wrecked and now the point I want to place is the center and the center needs to be wherever my mouse position is if I run this now and let me show my mouse again I can select the palm tree and you can see it follows my mouse perfectly and if I place it this is looking pretty good now I can move it around and place another element all of this is working very well the question now is how do I know that I have to place the center and for that if I minimize preview and go to Canvas add inside of here when I'm placing the canvas object the position is always going to be the mouse position and now if I look at this canvas object the rectangle here is going to be the center position so anytime I'm clicking with an object selected I want to place the object or the center of the object where my mouse position is as a consequence inside of my preview when I'm running a preview of the surface this one here I have to show the object in the same position that is really important but well with that I can remove a bunch of comments here and now we are done at least with the preview for the final part of the editor at least purely for the editor we have to work on the sky now for this guy we need a couple of different methods to make all of this work and I think all of this is best explained by actually doing it so let's jump right into the code and let's have a look once more we have main.pi which I don't care about I want to look at my editor and first of all in here inside of the drawing section I want to create a new method that I call display this one is going to need self and Delta time for the cloud movement although we're not going to use that for a bit on top of that before I start working on this let me call it right away inside of the run method and now really important this display sky has to be called before we are drawing anything else so display sky in here with Delta time and this always has to be in the background so it needs to be before the level the level lines the preview and so on and I guess while we are here I can also comment out the origin point because this one we don't need anymore ready now I can start working on displaying the sky there are going to be two major parts to all of this let me draw the entire window something like this and first of all I want to create a horizon something like this then we have the actual sky up here and we have some water at the bottom meaning we have to draw three different things and those are always going to cover the entire background and even more important this middle line here has to be controlled by the sky handle we created earlier let me actually run the game by adding pairs in here and running main.pi this handle here is going to determine the vertical position of the sky which more specifically means from this point I want to draw a horizontal line and that means first of all I need to get a y position that I get with self and I call this one this guy handle in here we need rect and we need the center y with that we know where the Horizon is going to be although there's one thing we can do first of all and that is self dot display surface dot fill and in here inside of settings if I scroll down a tiny bit to the colors we have a sky color which I can copy and paste in here and I guess this one we could do right at the start if I run this now you can see some kind of Sky color by itself it looks kind of weird but it definitely works so with that we have a starting point although not a very good one but definitely something we can work with now with that inside of the editor we now have a y point so we can use that for now I want to use it to draw some Horizon Lines we actually have multiple you're going to see in a second what I mean bodies let me create a horizon rectangle and this rectangle is going to be pygame Dot rect and then here we need a left a top a width and a height left and width are really easy because I want this rectangle always to start on the left side of the window and cover the entire window so window width the top for this one is going to be let's just go with Y for now and let's give it a height of 10. and now with that I can pie game Dodge draw Dot rect and once again I need a surface so I display Surface body color inside of settings I have a horizon top color this I want to copy paste it in here and the last thing we need is the actual Horizon rectangle now if I run this let's see what we get you can see we have a rectangle that now works as a horizon line and this one only cares about the wine part so it always covers the entire width of the window which is really nice because now if I move the entire editor this one well the Horizon is always going to work so this is exactly what I wanted here although the one part that I don't really like is that I think this Horizon is a tiny bit too low but that is fairly subjective if I run this now and you look very closely The Horizon is a tiny bit higher but it really doesn't make much of a difference what I can do is this shouldn't be the Horizon rectangle this should be Horizon rectangle one because I want to have two and three and those are going to be other rectangles on top of this original one that way basically what I want to have this one here is going to be the entire display surface and the first rectangle we created is something like this on top of that I want to have a smaller line just imagine I can draw straight lines that would definitely help and on top of that I want to have an even smaller line okay this is very hard to see but once I actually implement it you can definitely tell what's going on now first of all when we're drawing this there should be Horizon rectangle one for a horizon rectangle two I want this to be a tiny bit higher and for the height I want this to be four if I draw this one and run the entire thing again you can now see we have a bigger line on top of a smaller line this I want to do one more time with Horizon rectangle three this one should be 20 pixels from the center and should have a height of 2. if I draw this one now and run main.pi again we now have a third line in here and all three of these lines work with the sky handle so this is working really good although there's one minor thing we can do here to optimize all of this and that is I want to draw all of this only if a certain if condition is true and that if condition being that Y is greater than zero if the sky handle is really far up there's no point drawing any of this let me visualize this actually right now this guy handle is right in the middle of the window and if I move further up and up at some point the sky handle is going to be well on top of the editor and if that is the case we are only supposed to see water as a consequence there's no reason in drawing anything of the horizon and with that here we're not drawing them if we only want to show water this isn't going to make much of a difference in practice but every tiny bit helps now besides that I want to draw the C for that I want to create a c rectangle and this once again is going to be pygame Dot rect and in here once again we need left top width and height the left once again is really easy we just need zero the top is going to be y that one is also easy the width is going to be the window width and for the height here we could be fancy but well we can also just add window I that makes things a bit easier and I guess I should draw all of this again we once again have a display surface and we have the horizon line somewhere here this C rectangle is now going to be this rectangle here although I was a bit lazy with the window height Because the actual rectangle I am going to create is probably somewhere in size like this which in practice doesn't make much of a difference so it's not too much of an issue this rectangle I now want to draw which I do with pygame DOT draw dot rect in here once again we need a surface to draw on the display surface or the color inside of settings we have C color this I want to use in here and then I want to draw the CU rectangle and if I run this again now this is starting to come together we now have a prophecy that is starting to look much better and it also works along with the sky handle also if I go down you can now see an issue that the C at some point stops and this I have to work on the idea here once again is going to be this should be an if statement if the Horizon is on the screen I want to do all of this however if that is not the case so else I want to fill the entire surface with water I'm pretty sure you can already see where this is going this is going to be your exercise so try to figure out the if statements here it is going to look somewhat similar compared to what we have done here with the Horizon Lines possibly now and try to think about this to figure out if the Horizon is on the window I want to check if Y is smaller than the window height only if that is the case I want to do all of this once again we have the display surface and here is y that is our Horizon and what I'm doing with this if condition here is I'm checking if this y currently is somewhere on top of this thing here imagine if this y was moved further down there wouldn't be any point in drawing water because the water wouldn't be visible for example if the player wants to have a level without any water this one should also be possible so let me clean this one up a tiny bit that is looking better now this is one part and there's no point running Pi game right now because you wouldn't be able to see the difference there's one more thing I do want to do and that is zero is smaller than y is smaller than window height this means I am only drawing water if this y here is inside of this range we already covered the case if the water is below we only want to show Sky if the water is on top I want to do something else I want to fill the entire window with water and that I want to do instead of drawing a rectangle and let me actually implement this right away with this we know that the Horizon is somewhere on the editor but now I can add another if statement that if Y is smaller than zero if that is the case I know I only want to have water to fill the entire surface which I get with self dot displaysurface dot fill and in here we have the C color which I have already used here so I can just copy it and paste it in there and now you should be able to see what's going on if I move this thing up and down nothing is going to happen but now if I move a bit further down you can only see water forever and that is because if this Sky handle here is somewhere up here or smaller than zero then we are filling the entire display surface with the watercolor which means if I do that we are filling the entire display service with the blue color so it looks like we only have water but if I move it the other way so I go up now we are only drawing the sky and if the Horizon is anywhere in between we are drawing all the other stuff I hope that makes sense if you play around with numbers I think this should be fairly straightforward let me get rid of the comment here and here and this is starting to come together there's one more thing that I do want to do and this is going to be all the way at the end I want to draw one more line for the Horizon and this I get with pygame.draw.line in here I want the display surface for this one we have another color The Horizon color this one I can paste in here and now for the points I need X and Y for the start and I need X and Y for the end X is either going to be 0 or the window width remember here we always want to cover the entire width of the window and Y is going to be well y this is the point we are getting up here finally we need a width and this one I've set to 3. and for this one if I draw this now you can see we have another horizon line that if it makes the entire thing look a bit nicer cool so with that we are displaying the sky the problem right now is that we are going to need some clouds also I should mention that you could optimize this one here a tiny bit more that this horizon line only really needs to be drawn if we have this condition here so technically I could move it in here and indent it properly run this again and we have the same outcome but now we're not drawing this line if it's not on the window but more importantly we now are going to need some clouds that is going to make out of this look much better and really important here those clouds need to be running inside of this display Sky because the clouds are supposed to be behind the water but on top of the Horizon Lines this is why I separated these two parts in between the two I want to run something like self dot display clouds since the clouds are going to move this one needs Delta time and this I can create right here we need a method called display louds and don't forget a parameter for Delta time first of all in here we need to know the position of the Horizon that is the same thing we have done in here so I could just copy it although to be a bit more elegant here I can also pass this y inside of this method that way we get Delta time and Y on top of that inside of the clouds there's one more change that we can make before we actually write any code inside of this method and that is I only want to display clouds if Y is greater than zero if the Horizon is above the entire editor and we only want to show water there's no point in displaying clouds and this if statement we already have up here which means I can put display clouds in there and then I can skip this if statement and now I can actually work on displaying the clouds essentially what I want to do in here I want to create some kind of let me call it self dot current louds these are the clouds that currently exist they don't right now but we are going to create them in just a second and I want to look at every single Cloud inside of here so for cloud in the current clouds current clouds is just going to be a list inside of that every single Cloud will be represented by a dictionary and this dictionary has a surface of the cloud we have a position and we have speed I want to get my cloud and in here I want to get the position this is going to give me a tuple with X and Y and for now I want to move all of the clouds to the left so it looks like they're moving put that in here I want to get 0 that is X and move it by the cloud and the speed of that cloud and this I want to multiply with Delta time once I have that I want to self.display surface and lit the cloud and in here we have the cloud surface although one thing we do need is a position and this position is going to be X and Y this one I want to create on separate lines to make it a bit easier to understand X is going to be the easier bit in here we have cloud we have a position and once again this is a tuple with X and Y I care about X Y is going to be a bit different although I can copy this bit in its entirety and change the 0 to a one this is a good start but what we have to be careful about is that all of this has to be relative to this y that way if this one here is the Horizon and we have some clouds here and let's say another Cloud here those are horrible clouds but the basic idea is if the player is moving the Horizon up all of the clouds should move up as well by the same logic if the player is moving the Horizon down the clouds should move down as well and this Behavior we get with Y minus the cloud position that way the clouds are always relative to The Horizon the one issue here is we have y twice which is going to be a bit confusing so I'm going to rename this y to Horizon y and with that we can work with our clouds the problem we have right now is that current clouds doesn't exist also even if it did exist it wouldn't have any content so there are two things we have to work on let me start by creating another method that I called create louds in here we need itself and we are going to need an event this is important for the timer I'll explain that in just a second but for now let me add pass in here and I can minimize the display Sky method and I can all the way in the init method let me do it right after the Imports I want to create clouds in here first of all we need the current clouds that is going to be an empty list and to for loop I have written down here is for the current clouds in just a bit we're going to populate this list with dictionaries but there are some things we have to cover first the most important one for now is we actually need some surfaces that we can use and those I am storing in a cloud surface and this is also going to be a list in here I'm going to use my import folder function and there's one path we want to import from this path is one folder up then we have graphics and then we have clouds that is horrible spelling like so if I look inside of the project folder we have Graphics inside of there we have clouds and then here we have three different clouds those I want to import next up we have to create a timer the basic idea is every time a timer ticks we want to create a new cloud and to create that we need Cloud timer and since this one is a repeating timer that is quite simple pygam has something inbuilt here this we get with pygame DOT user event and now we need plus one to not confuse the events in pi game once we have that we have a custom event and on this event we have to create a timer which we do with pygam.time and set timer for this one I want to set the self Cloud timer and now in milliseconds we need the duration of this timer in my case I want a new Cloud every two seconds or every 2 000 milliseconds once we have that I can minimize the init method and inside of my event loop I can call Self dot create clouds and important here I need the event with that I can minimize the event Loop and look at my create clouds the first thing I want to check in here is if event DOT type is equal to self dot Cloud timer I only want to run whatever is going to come next if this event is true so if the timer triggers and ultimately what I want to do I want to create a dictionary for each cloud with a surface a position and a speed which means I want to get myself dot current clouds and on this I want to append a dictionary that has his surface that has a position and finally that has e speed so let me add the colons here and we have to figure out these three bits of information and since there's going to be quite a bit of Randomness I want to have the random module or at least parts of it I want from random import choice and rent int for this surface we already have a list of surfaces that we can use the list of surfaces is self.cloud surfaces and this is right now a list with three different surfaces I want to have one of those at random for that I need choice and this surface I want to store in a separate variable now you could place the surface straight away in here but to add a bit more Randomness I want to do one more thing and that is surface is going to be pygame dot transform dot scale to X with this surface this method would scale the Surface by a factor of two and this I only want to do some of the time which I get with if Rand int between 0 and 4 is smaller than 2. only if that is the case I want to double the size of this surface I suppose we could make this a tiny bit more elegant by copying this if statement here and pasting it all the way at the end and then else we keep the same surface that way we only use one line here like so besides that we need a position and we need this speed this speed is the really easy bit I just want to have a random integer between 20 and 50. that is going to be the speed since it is so simple I could just do Straight inside of the dictionary here that makes the code a bit more readable the only slightly more complicated bit is the position this one is going to be a list with X and Y and really important this has to be a list it cannot be a tuple because inside of this for loop we're going to update the position and with a tuple we couldn't do that for X I want to have my window width and to that I want to add a random number so rent in between 50 and 100. let me draw this actually we have our entire display surface here and the window width is going to be this line here to this I want to add a random number which I'm getting from here this is going to be the start position for my clouds they are always going to be slightly to the right of the window for the white part I also want to use Rand end and here I just want to use 0 and the window height this means if I reopen the drawing all of the clouds can be somewhere inside of this range here and this might be confusing because you might be wondering aren't we going to have some clouds down here for example but that is not going to happen because of this line here we are always going to subtract this lowest point here from The Horizon which means effectively for most of the games we're going to move up the clouds to wherever the Horizon is and that is all we need let's try it actually if I run main.pi we are getting an error that we are missing something and that's something is I forgot to add the position in here now if we run this again if I'm waiting for a bit they can see a cloud all the way in the top right and those clouds if I move the editor around are only affected by the Y position not by X and this is intentional because if the player is moving too far left and right this would get confusing but this by itself is looking pretty good yep I'm definitely happy with this the issue is you can already tell when we are starting the editor we have to wait for the clouds which isn't ideal as a consequence I want to create another method here and this I called start up louds doesn't need any custom parameters and in this one I want to create a couple of clouds let's say for I in range I want to have 20 clouds when the game is starting and at the end of this for Loop what I basically want to have is a duplication of this line here again I want to create a dictionary for every single cloud and put them somewhere where the sky is and this is going to be the exercise here I want you guys to create a surface a position and a speed the position here is the most important bit when we are starting the game the clouds should be randomly covering the entire width of the sky so there shouldn't be to the right there should be in the middle somewhere try to figure this one out and definitely run the game a couple of times to see what looks good but possibly now and see if you can figure this one out the speed is the easiest one because this one we already have we can just get rid of it wasn't even necessary the surface is also quite easy because we basically have to do the same thing we have done here although to be a bit more fancy we can now optimize this to have it all on one line I want to have this surface and this one is going to be I can copy this entire line here except now for the surface I want to have this Choice function here but this I only want to do if the random condition is true and if that is not the case so else I just want to choose a random surface like so that way if your monitor is a bit larger you have all of this on one line and this Fields quite a bit more elegant besides that we need a position once again this has to be a list with X and Y and this one now is going to be really easy because I just want to have Rand int from 0 to the window width this is for x and for y I want to do the same thing I want to go from 0 to the window height we are placing the clouds somewhere in the middle of the window and that is all we need all I have to do now is actually call this startup clouds method this I do inside of the init method self dot start up clouds and now let's run main.pi and they can already see we have a bunch of clouds and this is looking much better I can also go up and down left and right all of this is working really well I guess the one limitation here is if you go too far up the clouds at some point disappear but I wouldn't imagine this to become too much of an issue although I guess if it is an issue for you you can definitely play around with this and make this more flexible but I am fine the way it is right now that being said there's one more thing that we do have to change and that is inside of create clouds the problem essentially is we keep on creating more and more clouds so we have more and more objects which at some point in the game is going to slow down performance because we keep on creating objects we never get rid of them for example once again we have the entire surface clouds keep on going further to the right and we keep on amassing more and more clouds on the left of the window if the game runs for an hour We're going to have hundreds maybe even thousands of clouds in here which we honestly don't need and this is going to be a drag on performance as a consequence every time we are creating a new Cloud we are also going to remove layouts and this is going to be self dot current clouds is going to be a list comprehension and I want to have Cloud for cloud in self dot current clouds right now we are literally just copying the current cloud list but I only want to have the elements inside of the list if cloud and position with zero is greater than let's say negative 400. this means I only want to have the clouds inside of the list if they are somewhere here so they are greater than negative 400. if they are further to the left I want to get rid of them which specifically here means I am not going to copy them over into my new list so they're just going to disappear this is not going to be visible in the game but I can run it make sure nothing breaks and now we can also see some new clouds and this is looking pretty good I guess the one limitation here is you are going to have a bit of a gap somewhere here but nothing too major so I'm quite happy with this and this covers the entire editor so with that we now have to figure out how to export all of this and create the actual level from it now that we have the editor we have to export the level data or at least we have to be able to and for that we need a couple of things most importantly we have to export the entire thing into some kind of grid this grid is going to make it much easier later on to build the level we already have a good start for this because the canvas tile here is really useful this one is going to become really important later on to build the actual level although there's one more thing that we do have to do and that is the objects right now are not in the system at all remember here all of the objects are just individual Sprites they are not part of the canvas tile system at all which means we somehow have to get them in there that's going to be a really important part for now and that is also what we are going to start with but let's start off this trading code and let's see how far we get once again we have the code and I want to keep on working inside of the editor the very first thing that we are going to need is going to happen inside of the event Loop inside of here I want to check if event DOT type is equal to pygame dot key down and the event key we are getting at that moment is going to be pygame.k underscore return those two statements combined check if the player is pressing the enter button if that is the case I want to export the map and create an actual level although in our case there are quite a few more steps before we get to that stage now in here all I want to do for now I want to print let's call this one self dot create grid on this grid method here is going to actually export the level this one doesn't exist right now so let's create it create grid and then here we don't need any custom parameters inside of this method first of all we have to add the objects to the tiles and once we have that I want to create a grid where each cell is going to be one cell inside of the actual level let's go for this step by step and first of all I want to add the objects to the tiles for that since I do have access to all of the objects we have four let's say obj in self dot canvas objects in here for example I can print obj dot top left oh and this should be object.rect dot top left and now if I run this and press enter we are getting the top left positions of both of the objects we currently have in the game which means in here we do have some starting positions although we don't really care about the top left instead we care about the current tile let me explain what that means right now the player has a border that's something like this and the top left of the player is this bit here as a consequence the player is going to be inside of this tile or rather this is the tile that I want to add the player to same for the sky handle the top left of the sky handle is this bit here and this I want to add to this tile and that way we're getting the object into the grid system I hope that makes sense basically what we are going to do we're getting the top left of any kind of object and we are adding it to the canvas tile in this particular cell for that first of all we need to get the current cell of this canvas object now we already have a method that kind of works here we have self and get current cell although so far we always use this with the most position but I want to expand this method a tiny bit so that it can also deal with basically any kind of object which means we have to work inside of get current cell first of all in here we have to create another parameter let's call it obj and by default this is none that way we don't have to change any of the other method calls that we so far have used we only want to get this line here if obj is none or if it exists at all so if not obj that way once again we don't have to change anything else however if that is not the case so else meaning we have some kind of object what I didn't want to return is the vector and the vector is going to be obj and distance to origin from this I want to subtract self dot origin this might sound a tiny bit confusing but this logic here is basically the same thing we have done here for the mouse except now for the position we are not using the mouse position we are using the distance to the origin and that way we can leave all of this exactly as it is and we are good to go let's try this actually instead of printing the top left of the current object I want to get the current cell meaning now if I run all of this and place the player in the top left if I print enter now we get 0 and 0 down here and 9 and 5 for this guy handle let's say if I move this thing one cell further to the left press enter again and now we get 0 and 0 for the player and eight and five this seems to be working just fine let's try it one cell up and we get eight and four so I'm quite happy with this this seems to be working just fine with that we know the current cell of whatever object we are looking at although there's one more thing that we do need and that is the offset what this one means is if this one here is one individual cell inside of the game let me add a couple of supporting lines something like this this could be one cell inside of the editor inside of here we could for example have a player that covers an area like this the offset is going to be this offset here I want to know how far is the top left of the object from the origin point of the cell this is going to become important later on to place the Sprite exactly in the right position because remember right now the cell is always fairly static we only really have the top left but the objects are going to be a bit more flexible and this we have to account for and the offset here could actually be a really interesting exercise for you so try to get the distance between the top left of the cell and the top left of the object and see how far you get first of all we need the distance from the object to the origin point this we get with obj DOT distance to origin this is the same thing we have done up here in get current cell I guess I should mention here we can't use the top left because this always has to be relative to the origin but essentially this one here is the top left in our more flexible system and if I draw all of this if we have once again here the entire level and let me draw a couple of cells we have one cell here one cell or rather a column and a couple of rows with the origin point being here and the distance to the origin could be let's say we are here meaning this distance is what we are getting right now but in my case I don't want to get the entire distance what I want is the distance from this point here to this point for that we need to get the current tile which means we have to know the column and the row this we already have because we know the current cell that we are in which means from this point I want to subtract the current cell although this I want to multiply by the tile size remember here the current cell is a position like 1 2 and 3 but we need actual pixel positions which we're getting by multiplying this by the tile size although once again distance to origin and current cell both are tuples which means I want to convert both to a vector that way we can multiply the current cell with the tile size and not get an error and let me put this into brackets so it's a bit easier to see and I want to do the same thing for distance to origin so this is going to be a vector for sure and that way we are getting the offset I suppose let me print it to see what's going on if I now run the entire thing and press enter we're getting some random numbers they don't tell you that much right now but if you look at the player and I can place the player roughly in the top left if I press this now the player moves closer to the top left the player here is a tiny bit confusing because the actual area the play occupies is something like this the player is much larger than the graphic here I guess you could be seeing it a bit easier with the sky handle if I move it here now you can see we're getting much closer to the top left than we were in the last time we called this method at the very least it works definitely play around with this yourself and see how it works with that we know where the object is and what the offset is going to be both of these are going to give us the exact position where the Sprite needs to be now we need to figure out how to get this one into a canvas tile and for that first of all I need to check if this current cell actually exists inside of our canvas data meaning if in the current cell we actually have something already which means if the current cell is in self.canvas data this means a tile exists already and let me add a pass in here and besides that we have else which means that no tile exists yet but now I am only going to worry about this case here that we already have a tile if that is the case I want to get this tire which means self dot canvas data and the current cell and I want to call add ID although now I want to have object dot tile ID and I want to have the offset I should probably explain object.tile ID is going to tell us what kind of object we have if I go all the way down inside of the canvas object we have the tile ID once again this is one of these IDs here and we want to know which one we are currently dealing with besides that I also need to know the offset so the distance from the top left this is really important to place the object properly although this offset we can't really account for yet as a consequence we have to expand this add ID method which I am going to do all the way down here we have ADD ID for this one once again we need another parameter let's call this one offset as well and in here since we are using this add ID already I want to have a default argument by default this offset is going to be an empty Vector that way we don't have to make any changes to the ad ID we already used multiple times inside of this I want to have another case in this case is going to be an underscore which means if none of these cases are true we are going to do this one here and this is then going to tell us that we are working with objects inside of the canvas Tire I think way earlier I created objects which is just going to be an empty list this we want to fill and what I want to fill it with let me get self.objects I want to append a tuple with the tile ID and with the offset and you could leave this as it is but I added one more if statement and that if statement is if the tile ID and the offset is not in self dot objects only if that is the case I want to append this the idea here is that it shouldn't be possible to have the same object in exactly the same position so for example we couldn't have a palm tree exactly in the same spot that would be kind of weird but other than that we are good to go although well not really because we are only accounting for one case we need to account for the other case if there is no tile yet I have to create a new one which means self and canvas data once again I want to get the current cell and now I have to create a canvas tile remember again if I minimize everything and look at the canvas tile right now we only have the tile ID this we definitely need I need the tile ID however now we also need the offset otherwise we couldn't place the object properly so we have to change the init method of the canvas tile to account for the offset and this is going to be an exercise for you update the canvas tile so that by the end of it we get the object in there even if there's nothing else in there so positively now and try to figure this one out there aren't too many changes you have to make first of all we need another parameter let's call it offset once again that one seems to make the most sense also once again you do want to have a default value in my case Vector 2. that way we don't have to make any changes to the existing canvas tiles we have used if you didn't add this one you would have to change every single canvas tile you have created so far would be kind of a pain and besides that when we are calling add ID for the offset I want to use the offset that way if we have a value here we are going to pass it through and this is all you have to change wasn't actually so bad although I do want to get rid of the comment here that's going to be annoying otherwise cool so with that we are adding the objects to the canvas tile system which is all we really needed however there's one more change that I do want to make and that is if we kept the system like this we are only ever adding more objects to the canvas tiles but we're never cleaning things up so let's say I place the player in one position start the level then go back to the editor place the player in another position and then start the level again we're not getting rid of the original player which we do have to account for and this is quite easy all we need is for tile in self dot canvas dot uh not objects but data dot values inside of here I want to empty all of the objects and with that we have a proper system to account for all of the objects so now we can actually create the grid however for that we are going to need a couple of things so let me go through this one by one first of all we need a red offset once again we have the entire window and inside of this we have a couple of columns and a bunch of rows something like this I am getting better at drawing straight lines the issue we have right now is that we have a huge amount of data that we don't really need because it's completely empty so for example if we exported the game without placing anything we would have the player let's say here and we would have to Sky handle in this cell here everything else we could basically disregard which means we have to figure out a system to only get the cells that we actually want specifically in this case I want to have only these two cells here this is what actually is going to build the level everything else is just going to be empty data that I'm going to ignore now later on obviously we are going to fill this with terrain tiles palm trees enemies but in the most basic sense we only really want to create two tiles and for that the first thing we need is the top left of all of the tiles that actually exist in this case right now it would be the player but it could be any kind of tile so more specifically what I want to get is the top left tile that is actually filled and this one I have separated I want to have the left side or the left tile position that is actually filled and the top one how we are going to do this first of all I need self.canvas data and then here I only really care about the keys because the keys are the position and this I want to have inside of a sorted function which means for this I also need a key the key here is going to be a Lambda function and let me call the parameter here a tile and I want to sort all of this by tile and zero canvas data.keys is going to give us a position for example this could be 64 and 128 for X and Y positions here this we are going to pass into the tile parameter and on this we are only getting tile zero which is going to be the X bit this is the one we actually care about from this one here and once we have that this sorted method is going to sort all of this from the lowest to the highest number and since we only care about the leftmost tile we want to know the tile here with the lowest x value which means from this list I only want to get the first item that is going to be the very lowest x value or the leftmost position of all of our canvas data positions and this is going to return an X and A Y value I only care about the X1 so I want to get another indexing of 0. the same thing we have to do for the top position and this is going to be your exercise to see if you can follow along try to get the top left position of all of the filled canvas tiles should be fairly similar to this one you do have to make some minor changes though I am going to copy the entire thing like so and now first of all of this here can stay identical because we once again care about the positions but now for the key I don't want to sort the items by the x value but rather by the Y value with this one now I'm going to get a sorted list from the lowest to the highest y position of all of the existing canvas tiles from this once again I want to get the first item but now I want to get the Y position of this first item instead of the X position and with that I have the leftmost at the topmost position of all of our filled canvas tiles let me print this one actually to see what we get I want to print the left and I want to print the top if I now run main.pi and press enter we are getting an error and the error we get here on tile ID because this one should be object.tile ID if I run all of this like so we get 2 and 5 which I think is the top left position of the player but if I move this object here to let's say somewhere here we get 1 and 3. so we now have a different top left position this seems to be working just fine once we have that I want to create an empty grid what this actually means is now we can start working on the actual data structure we need for the level for this one I want to have various layers which is going to be another dictionary and in here let me copy paste a couple of things I want to have these items these are going to be all of the different layers we are going to have inside of the actual level the order here also is important because later on for the level I'm going to cycle through and for example I want to have the water all the way in the back then I want to have to back on palm trees then the terrain and so on but all we are really going to do for each of these dictionaries I want to have an X and A Y position and then I want to have some kind of value for example for terrain this could be what kind of terrain we are going to need which means we want to fill the grid and this we do with or tile position and the actual tile in self dot canvas data and items with this we're getting the tiled position and the tile and this we can use to actually fill all of this here although first of all we need to get an X position and we need to get a y position unfortunately this isn't as easy as getting something like tile position and zero because we have to normalize this position to the top left the values we get up here let me actually move this one down a tiny bit so this is easier to see like so and let me explain what this actually means once again we have a couple of columns and rows inside of the editor and when we are exporting everything and once we start to exporting things the player could be in this cell here for Simplicity let's say this cell is 2 and 3 for X and Y also this is going to be the top left cell of all of the filled canvas tiles inside of the actual level this has to become the top left cell which means instead of 2 and 3 this needs to be 0 and 0 because it is the top left cell so this is the one we are starting with now to get that I first of all want to get the row and the column and those are going to be adjusted for so let me rename it actually row and column adjusted for this one now we are going to need for the column we have tile position 0 and for the row is going to be one so we have X and Y from this for the row I want to subtract the top and for the column I want to subtract the left remember here the left and the top are giving us a cell position so this could be one two or three depending on what cell we are in and this number we are subtracting from the cell we have and that way the top cell if I draw this again with this cell being the top left cell left would be two and top would be three and these are the numbers we're subtracting from the cell and that way we're getting to zero and zero if we had another cell let's say here that had three and four we would be doing the same thing and that way the number would become a one and two which will be the distance that we now need here although all of this is still going to be in Grid positions but I want actual X and Y positions to make this easier to place later on and this is quite easy for X I want to have the call adjusted multiplied by the tile size and for y this is going to be row adjusted multiplied by the tile size this is giving us actual pixel positions we can place right away we don't have to multiply with anything and once we have that this is now going to involve a couple of if statements for example if a tile has water I want to get my layers in here I want to get the water and I want to create a new key and this key is going to be the X and Y position although now for this water position we have to know if we have a top water cell or a bottom water cell and this logic I want to keep inside of the tile which means I'm going to create a method that is going to be called get water let's create it right away inside of canvas tile I want to have another method get water all I really want to do in here is return bottom if self and water on top if that is not the case so else this is going to return top with that for every water cell we know exactly what kind of water cell we need to place next up I want to check if the tile has to rain if that is the case once again I want to get my layers and then here I want to Target terrain so we just work with water now I'm working with Terrain once again I want to get an X and Y key here and the value for this is going to be something like tile and get the rain this one once again we have to create which means all the way in the bottom Define get Terrain what I want to return here is going to be a string that is going to contain with the join method self dot terrain Neighbors essentially if I look at the init method all I really care about for the terrain is the actual terrain Neighbors because this one is going to tell me what kind of graphic I need for each individual terrain tile so we can just leave it at that which means we don't need anything else I can move up although in here we are going to need one more thing and that is if we don't have a Terrain or is specifically named Terrain in here I want to get the X1 which means I want to get this terrain but only if tile and get the rain don't forget to call it is in self dot land tiles we only want to get this graphic if the graphic actually exists inside of here if that is not the case so else I want to have the X graphic the one that works as a default tile besides that if tile and coin that I want to look at my layers for the coin that is going to be this one here and once again I want to get X and Y and this one is going to be easier because all I want is tile.coin this one doesn't need any method however there's one thing that we do need this one here is always going to be the top left position but the problem we have seen here is that if this is one tile a coin is going to be stuck here in the top left which is going to look weird as a consequence I need to adjust these X Y values to place the coin right in the center of the tile that is something we can do quite easily all we have to do is plus the tile size divided by two we are getting closer to the Finish Line next up I want to check if tile dot enemy exists if that is the case I want to get my layers once more I want to look at the enemy this is enemies actually so in here we have enemies this one can just be X and Y and in here I want to get tile dot enemy this one is very similar compared to the coin finally for the last one we need if tile dot objects which means if inside of this tile we have an object I want to look at for obj and offset in tile dot objects remember here inside of tile objects we always have a tuple and the Tuple is going to contain the object and the offset from the top left which is what we're getting here inside of the for Loop but now the important thing that we do have to figure out is inside of this layers dictionary we have background palm trees and we have foreground Pawn trees both of these are going to be objects while ground objects also has the player so this is why it's not called palm trees but this separation we have to create ourselves which means inside of this for loop I want to have an if statement if we have VG palm trees and if that is not the case so else I want to have all of the foreground objects what we need in here I want to check if the object we currently have is inside a certain list remember here object refers to a number so this could be one two three or more likely it's going to be somewhere between 11 and 18. although it could also be zero for the player but this is what I have to check for and more specifically what I want to check for is the key for key and value in editor data dot items meaning this right now is going to give us all of the keys of this dictionary here but we only care about the keys if the value of that particular key more specifically the style is equal to Palm BG this basically means we are only getting the keys from this dictionary if the value has style and pawn BG which means this comprehension here would return the numbers 15 to 18. and if the object is inside of that we know it's a background palm tree meaning inside of here I can get my layers I can get BG Palms that is the layer we have created here and on this once again I need to get an X and A Y position with the value being the object now for the X and Y position here we have to account for the offset which means for X I want to have plus offset dot X and for y I want to have the offset dot y and while I was testing this sometimes because the offsite is going to be a vector we had some problems so I want to convert all of those to integers but once we have that we are good to go the last thing we need I can just duplicate the entire thing here and now instead of the background palm trees I want to have the foreground objects the rest can remain identical though finally the very last thing we have to do this for Loop here is done so I can minimize it and now all I want to do is to return this layers grid and with that we should be done with exporting the entire editor map let's try it actually if I run this now and press enter and let me see what we get we get nothing for water palm trees terrain and so on but for the foreground objects we have the player here and we have the sky handle which means something is definitely working if I try this again and place some elements let's say some terrain some water palm tree enemy and a coin and run this again we are getting an error let's have a look this happens inside of the for Loop when we are adding the coin and I think the problem here is the layers called coins not coin like so and now let's try this again I want to have a couple of things of all of the different elements like so if I run this now we didn't get an error but now I forgot the water and we don't have background trees but we do have terrain tiles with the name of the terrain and the position quite a few of those then we have an enemy we have coins and we have foreground objects this seems to be working really well although just to make sure I also want to place a background palm tree and I want to place some water just to make sure this is working if I run this now we have some water and if I find it really quick we have background palm trees that seems to be working quite well and with that I can minimize the entire create grid method and this covers another major part for the game before we are going to continue I realized I forgot one important thing and that is a quick drawing fix in the editor to properly display everything let me actually show what the problem is right now back inside of the editor if I run the entire thing I can place some background tiles I can place a foreground palm tree and a background palm tree but now if I move the player the player is behind the background palm trees which is kind of weird because they are supposed to be in the background this also looks a bit weird because they can just be in front of the terrain which I really don't like the fix for that though is quite simple inside of the editor in the init method when I am creating all of the objects right now we only have a single group for all of the objects I want to create two more we have self and foreground and self and background both of those are going to be a Sprite group I guess I can copy this one and paste it in here now we have a few more groups and this we can use when we are adding where did I put it canvas at down here we are adding all of the objects when I'm placing the groups I want to be a bit more careful let me put all of this in a separate variable the groups should be self canvas objects and self background but only if we have the editor data again and in here I want to check myself and selection Index this is going to give me one of these items here on this I want to check this style and only if the style is Palm and this one is called Palm BG the one we are creating all the way at the bottom here if that is the case I want to have these two groups however if that is not the case so else the groups should be still self and this one I called canvas objects but now I want self and foreground once again if you have a bigger monitor this is going to be much better to see now that I have that I can replace this canvas objects with the groups by itself this isn't going to change anything but when I am drawing the level in here currently I am always drawing all of the objects on top of all of the tiles which is not necessarily what I want I can actually minimize the entire cell drawing logic so all of this and instead what I want now I want to have self dot background and this I want to draw on self dot display surface that way all of these background objects are going to be behind all of the tiles and in the foreground so self dot foreground I want to draw all of the other objects and now if I run this again we can't see anything however you could already see it if I hover over with the mouse over this area the player does exist we just can't see it same with the sky handle it is somewhere here it still exists we just can't see it the reason is never the player nor the sky handle are inside of either the foreground or the background group however if I place a palm tree or a background palm tree those still work and more importantly now if I'm placing a Terrain tile those are going to be in front of the background palm trees which makes the entire thing look much nicer but the other palm trees are always going to be in front of it the last specific thing now is that the player is not visible at all and this we have to change which is going to be your exercise change the code so that the player and the sky handle are going to be visible again pause the video now and see if we can figure this one out or this one I can minimize the drawer level method and go all the way to the init method when I'm placing the player and the sky handle the problem we have right now is that for the group we only have the canvas objects but we're only drawing the foreground or the background groups which means we have to change this one and this one into a group the player I want to be in the foreground so self dot for ground while the sky handle I want to be in self dot background and now this should be visible again that is looking much better now I can move them around everything still works just fine although now if I have terrain I can move the sky handle behind it you can still use it but I think this one looks a tiny bit better it's a matter of preference here there's no clear answer but now everything else works really well and this entire thing is coming together very nicely cool I am really happy with this finally we can start working on the actual level and first of all we need some kind of transition basically there should be a transition from the editor to the level if we switch them right away it would feel a bit too abrupt but for this transition to work we need to have at the very least a very basic level for now this level is not going to do anything it is just going to be a red background but at the very least we are going to be able to see something once again we are in the code and for once I don't want to work in the editor I want to create a new file this one I want to save as level dot pi in here we are going to need a couple of things let me copy them from the editor at the very least I want to have highgame and sys and the vector besides that I also want to have these two Imports here and the rest we don't need for now once I have all of that I want to create a class called level there's no need for inheritance and in here I want to have an init method and this one as always needs self and for now this is all that we are going to use inside of the method I want to get self dot display surface and this one I get as always with pygame.display.get underscore surface once I have that this level class is going to have an update method with self and Delta time although inside of this one for now all I want is self.display surface dot bill and just so that we can see something I want to have a red color although there's one more thing that we need in here and that is the event Loop this we absolutely need because remember inside of main.pi we don't really have an event Loop we are just running the game the event Loop either runs inside of the editor or inside of the level which means in here I need for event in pygame dot event dot get don't forget to call it and here I want to check if event DOT type is equal to pygame dot quit which means we are closing the game which means I want to quit Pi game and says.exit also don't forget to call self.eventloop so we are actually able to run it with that in place inside of main.pi I can from Level import level with this inside of the init method of the main I can create self dot level which is going to be level there are no arguments needed right now and once I have that I can run self dot level dot run and comment out the editor also I think I just realized inside of level I called this update let's call it run to keep more consistent also don't forget the other time and now if I run this we can see a plain red window which isn't what we want but at the very least this is working which means we now have level and we have an editor we just have to figure out how to switch between the two back and forth also I want to have an animation between the two so let's get started most of this is going to happen inside of main.pi inside here first of all I want to have another attribute that I called editor active by default this one is going to be true the reason here should be obvious that by default the editor should be open that is the first thing the player should see and with that in mind inside of the run method of the main class I can run if self dot editor active only if that is the case I want to actually run the editor and if that is not the case so else I want to run the level next up we are going to need another method that I called toggle in here we need itself and nothing else and all that is going to happen inside of this method is self dot editor active is going to be not self dot editor active meaning whenever we are calling this method we are switching editor active either to true or to false on this one now you might be tempted to just pass this toggle method into the player and into the level which would be possible but not ideal because I want to have a transition I think it's best to actually show the finished thing that's going to explain this the best here we have the final level and I already have a couple of terrain tiles if I now press enter we have this nice little animation that moves us from one to the other this is what I want to have as well in here to create this one I want to have a transition object to create this effect I want to have self dot transition this is going to be a whole separate object let's call it transition and only this one is going to call Self dot toggle meaning I want to pass it in here but make sure not to call it because I want to call this method from inside of transition this transition object I want to create right in here so class transition this is just going to be an animation it doesn't need inheritance though but we do need an init method this one itself and toggle first of all we need as always the display surface and this we get with pygame dot display dot get undescore surface we also have to store ourself.toggle which is going to be the toggle and finally I want to know if this thing is active or Not by default it is not with that I can start talking about the actual animation we are going to do how it's going to work is we have the display surface again and I'm going to draw a circle around like so by default this circle has a border width of zero meaning this width here is zero but once the animation is starting this border width is going to get bigger and bigger because of that it is going to cover more and more of the display surface in a circular manner so we're getting smaller and smaller circles and at some point we can't see anything of the actual editor anymore however once we are reaching this Middle Point here I want to reverse the animation so we are going this way again and that way it looks like the thing is opening also importantly here only when we have reached this blue point then I want to call the toggle method that way you can't see the switch between the editor and the level that way we don't get a sudden switch between the two makes the entire thing look much better for all of this I need a few more attributes the first one I want is self dot border with by default this one is going to be zero then I want to have a Direction so self dot Direction by default this is going to be 1 then I need self Dot Center and this is literally just going to be the window with divided by 2 and the window height divided by 2. next up I am going to need self dot radius this is going to be if I draw all of this again let me use a different color the radius the red color here is going to be the size from the center to where I want my actual Circle to be and the best size here I found is from the center all the way to one of the corners of the window they all have the same distance so it doesn't really matter which one and this is going to be the radius for the circle so I'm going to draw the circle roughly here you get the idea I hope for this one you could do some math but we don't really need it because we already have the center and this I want to convert to a vector so self Dot Center in here and since I know that this is going to be the center of the window I can just get the magnitude on this one and call it a day that being said I don't think the vector exists in here right now it does not so from the editor I want to import vector let's put it all the way at the top now this is going to work the last thing that I want to do is create a threshold and this is going to be self dot radius Plus 100. what this one is going to do is it gives us a threshold when we want to stop the entire thing you're going to see in a second how this is going to work but now that we have all of those I want to create let's call it a display method in here we need self and Delta time I want to check if self DOT active is true meaning I want to play the animation then I want to get myself dot border with and increase it by some number let's say 1000 is what iPhone look best multiplied by the Delta time and multiplied by the direction that way we are increasing the Border width by 1000 but since we're multiplying this with data time this becomes a much smaller number and Direction means we are increasing this in the positive direction so the thing is growing I'm not actually sure what happens in a negative direction if the starting point is zero but that doesn't really matter right now but with this we should already be seeing something although we need to draw the entire thing which means I want pygame dot draw dot Circle in here we need self dot display underscore surface for the color I'm just going with black then we need the center of the circle this is going to be the center of the entire thing then we need the radius and we do have a radius that is the radius finally we need a border width this we also have itself and Border width although this I want to convert to an integer because due to this operation we are almost certainly going to get floating Point numbers and this one here expects integers but now that we have that inside of the run method after we are checking if the editor or the level is running I want to run self.transition dot display I believe I called it and pass in Delta time we are calling this method here if I run the entire thing nothing is going to happen for the simple reason that active right now is false if I set it to true though and run the entire thing again we are getting an error I already see why this should be self dot Direction next attempt and there we go this is looking much better now we have this circle closing but we never know once it's opening again so this we have to work on and for that I have if self water width is greater or equal than self dot threshold if that is the case I want to set self dot direction to negative one if I run this now again we are getting a nice animation basically the way this one is working and this is what threshold is doing let me explain it properly now if this one here again is the entire window we have the radios looking something like this that is this radius here for Simplicity let's say this one could be 500 and this 500 is going to be important for the animation however once we are in the center I want the center to be closed for a tiny bit so we can only see a black window for a while the way I achieve that is with this threshold because this threshold is this 500 plus this 100. which means even after we are reaching the center we are increasing the border with a tiny bit more and that way the entire window stays black but only once we are exceeding this threshold we are reversing the entire animation I hope that makes sense if you play around with this for a tiny bit I think the logic is going to become obvious also what we can do in here is called self dot toggle I want to call this toggle when the entire thing is going to be black so the player cannot see the transition finally the last thing we didn't hear is if self and border with is smaller than zero if that is the case I want to set self.active back to false the border with should be zero and finally self dot direction should be one again that way when we restart the animation later on this works all properly meaning now if I run the entire thing this is working really good almost better than I expected actually you could see we started with the editor and then moved to the level so all of this is working which means now I can minimize it and I just have to figure out actually by default this active here should be false what I have to figure out now is how to call this transition from inside of the editor and from inside of the level for that I have created another method this one I called switch in here we need self and we need a grid although by default the grid is none the grid here is what we created inside of the editor inside of create grid what I'm expecting inside of this method is this return statement here the layers if we are running this first of all I want to set self.transition DOT active to true that way we are starting the animation and now if there is a grid we know we are going from the editor to the level which means I want to create a new level so self the level is going to be the level right now there are no arguments so we can just ignore it although I guess while we are here we can pass the Grid in here and inside of the level we can store the grid we are not going to use it for this section but later on this is going to become useful although what is also important in order to go back from the level to the editor this level object needs to know or needs to have access to the switch method which means in here I want to pass in self dot switch for this we have to create a parameter in here I want to create switch and that I want to store inside self.switch is going to be switch and to make all of this work inside of the event Loop if the event and type is equal to Pi game and K down and the event dot key is equal to pygame dot k underscore Escape this means we are pressing escape inside of the level if that is the case I want to call self.switch without any arguments what this means inside of this switch method we are only calling the transition we are not creating a new level as a consequence we can just see the editor speaking of the editor this editor when we are creating it up here we also need self dot switch this self.switch inside of the editor I want to minimize everything again and only work on the init method we need switch in here as well in this switch I want to turn into an attribute self.switch is going to be switch and now we just need to figure out when to call it and this we already have to a pretty good extent this happens inside of the event Loop in here right now we are just printing self.grid but instead of printing self.grid I want to self dot switch and pass the Grid in there meaning now when I call self.switch from inside of the editor this one here is going to be true meaning we are going to create a new level from the data we're getting from inside of the editor and that is the reason why inside of the editor we can have self.switch with an argument and inside of level.pi we can have switch without an argument and we have the same method except the method does a different thing depending on which way we are going also I realized this should be a double equation sign once we have all of that we don't actually have to create level inside of the init method because by default the level shouldn't exist we only want a level to exist once we're switching from the editor to a level and now with all of that let's try I can press enter we're getting to the level I can press escape and we're going back to the editor and in here we can keep on working all of this is working really well let's try it again obviously we cannot see the editor but at the very least all of this seems to be working just fine cool so with that we have covered another major section so next up we can actually flesh out the level so for the next part we can place the terrain on top of that I am also going to place the basic version of a player that isn't going to have any animations yet I just want to have something for the player so let's Jump Right In and let's see what we have to do once again we have main.pi and we have level.pi the editor we are not going to use for quite some time inside of the level we also have the grid available this one is going to contain all of the information we need to build everything which means I want to work inside of the init method and then here I first of all need a few more things since we are going to use Sprites for most of this I want to have self dot all Sprites this one is going to be at least for now pygame dot Sprite dot group a basic Sprite group we use to place everything in once I have that I want to create one method that I called build level and in here I want to pass in the grid and I also want to create something else that I called the asset dictionary this as a dictionary I am going to get from the init method when we are creating the level and basically what this one means anytime we are creating the level we are going to need a ton of different graphics and those I really don't want to import every time we are creating a level because we're going to create a level multiple times anytime we are switching we are creating a new instance of the level as a consequence importing more Graphics every single time is going to be a nightmare and really bad for performance to account for that I am also going to pass in a dictionary and this dictionary is going to be quite long so I'm going to put it over multiple lines in here one entry the one entry we are actually going to use is called land and this is going to be self.land tiles this is what we got way earlier inside of imports when we use this for the editor this we can reuse and just place it in here later on we are going to add a lot more in here but for now I just want to have the land this I can now use in here and I have to build the build level method I want to create build level in here we need a grid and we need the assets I guess let me call it asset dictionary to be a bit more consistent also this needs self we need to first of all get all of the different layers for reference inside of the editor what we are getting if I create grid we have to cycle through all of the layers of this dictionary which means I want to have for layer name and layer in Grid dot items inside of each layer we have more information we have the position and we have the data in layer dot items as well which means this first for Loop goes for the entire dictionary and the second for Loop is looking at every individual dictionary for every layer once I have that I can look for the layer name for example if the layer name is terrain the one we have specified here then I want to place some terrain tiles for that though I'm going to need some kind of vehicle to contain the graphics in my case I'm going to use a Sprite for that I'm going to create a new python file and save it as sprites.pi in here once again I want to import by game and besides that I also want to use vectors as always so let me add it right away in here for now all we need is pi game the first thing I want to do is I want to create a class called generic this one is going to be pygame dot Sprite dot Sprite to create an actual Sprite and inside of here we need an init method for the parameters here obviously we need self besides that we need a position we need a surface and we need the groups once we have all of that we have to do the basic setup the one that we always need for any kind of group I want to call Super init for the group then I have to create self.image this is going to be the surface and then self.rect is going to be self.mage.get underscore rect and I want to place the top left wherever the position is which means this group goes in there this surface goes in there and the position goes in there we are using all of our parameters once we have that I can return to level.pi and in here I have to import from Sprite import generic although I call this one Sprites this I can now use in here I want to create a generic Sprite and let me copy over the parameters we need we have position surface and group those three number one we need a position this position we already have that is the key for the layer items dictionary meaning this one is quite simple the next thing we need is the group or the next easy thing we need is the group because we only have one group here and this is all Sprites finally we need a surface and this is going to be your exercise figure out where you can get this surface from and well it shouldn't be too difficult just look at what parameters we have available and what you have in here all the information you need is available in there so pause the video now and see if we can figure this one out the surface is going to be inside of the asset dictionary meaning I want to use the asset dictionary and in here I want to look at land the reason I want to look at land is because inside of main.pi this is where we are storing the land tiles this by itself is going to be a dictionary as well and the name of this dictionary is going to be the name of the graphic we need which means in here we can pass in data this one here you get the proper tile that we need remember here inside of the inside of editor for terrain here what is inside of this dictionary is going to be first of all the position for the key let's say 128 and 64. this is going to be a tuple for the key and the associated value is going to be a string with the file name that we need this could for example be ABC this ABC we can then use to pick one of the graphics from this land tiles here that is basically all that's going to happen inside of this one which means once I have all of that I can get self dot all Sprites inside of the run method and draw the entire thing on self.display Surface and let's see if this is working the game is still starting and now let me draw a couple of tiles and now if I go to the other part you can see in the top left we have our terrain this is looking really good also I can return back to the editor make some more changes go back to the level and this is looking really good I'm very happy with this also while we are here the red background isn't needed anymore this one we can replace with the color from settings in here we have the sky color that is going to make the entire thing look much nicer next up we can start working on the player and for the player we have to look at the objects which means inside of the editor I want to look at the foreground objects I want to inside of this for Loop here use a match case statement and what I want to match is data for example inside of this one case could be zero and this would be the player in another case we could cover here let's say case one this one would be the sky and besides that we could also have for example case four and this would be a gold coin we're going to expand on this quite a bit but for now I only want to work on the player the main thing you have to understand here is that data most of the time refers to the ID of the object we are working with only the terrain and the water are a bit different here but everything else we can cover on the data so with that I want to create a player object and this I also want to store as an attribute meaning self.player is going to be layer this one doesn't exist right now which means inside of Sprites I want to create it I want to have a class for the player and this player has to inherit from generic that way we already cover all of these basic attributes saves me a bit of writing but this one inside of the init method I want to have self I won't have the position and for now all that I need besides that is the group inside of here I can call the super init method and now I have to cover these three parameters here position is super easy because we're getting that from the parameter same is going to happen for the group this one we can just ignore the only thing we have to work with is the surface and this one we don't have right now and for this entire section I am not going to import the player assets as a consequence this is going to be a plain pie game dot surface with a size of let's say 32 by 64 pixels finally after this one to have a slightly different color I want to get self.image and fill this one with a red color now with that back inside of my level besides generic I want to import the player and for this player now I need a position the position I already have and for the group I want to have self dot all Sprites if I run this now and let me draw a Terrain around the player and if I run the entire thing you can see we have the terrain and we have a red rectangle inside of it this is going to become the player later on that is looking really good so now we can add a tiny bit of input for the player to be able to move around all of that is going to happen inside of an input method and here we need self and nothing else we first of all have to get all of the keys that could be pressed this we get with pygame.key.get underscore pressed once we have that I can check if keys and pygame dot k underscore right and let me spell this one properly then I want to do something the same is going to be the case for left and this needs to be an L if statement and finally I want to have an else statement now we can check if the player is pressing right left or neither of the two I do however need some kind of logic to store the movement of the player for that inside of the init method I want to create a section that I called movement in here first of all we need the direction of the player and this I want to be a vector that by default is going to be zero now the shorthand for this Vector we have to import once again which I can do from the editor I want to have this one here we are essentially going to create a vector 2 and I just shortened all of this to Vector to save me some writing this is all that happens in here next up to store the position of the player I want to have a position this one is also going to be a vector although by default this Vector position is going to be self.rect dot top left the last thing we need is a speed and this one I've set to 300 but play around with it it's a fairly subjective value inside of the input when the player is pressing right I want to get self dot Direction I only care for this one about X and this one I want to set to 1. if the player is pressing left there should be negative one and if the player is pressing neither of the two it should be zero the logic here should be fairly obvious if the player is pressing right the direction should be positive all we need now is some way to implement this direction into actual movement for that we are going to need an update method this one is going to need self and Delta time first of all and here I want to check for the input besides that I want to have self dot move this one is going to actually implement the movement and this one needs Delta time this doesn't exist right now so let me create move with self and Delta time and for now what we did in here is self dot pause plus equal self dot Direction multiplied by self dot speed multiplied by Delta time this position here by the way is needed because while self.speed is an integer Direction and Delta time are not going to be integers as a consequence the value we are getting here is going to be some kind of floating Point number and by default pygame is only going to store integers for rectangles which is going to cause some inconsistent movement but if you store that position inside of a separate variable like a vector then you can store floating Point numbers and once you have that you can set self.rect dot top left to the rounded version of self.post.x and the rounded version of self.post.y okay with that we can go back to the level and in here besides drawing all of this I also want self.ul Sprites dot update and in here we have to pass in Delta time and now if I run this and create some terrain tiles like so I can run the entire thing and now the player can go right and left we can't go up and down but for this I want to have proper jumping logic this is going to come later cool but so far this is working really well with that we have another section covered so for the next part we can flesh out the level a tiny bit more for the next part we can work on the animated tiles this means we're going to create the water and the coins inside of the level both of which are not going to be terribly complicated if you can animate a Sprite so let's Jump Right In and let's have a look once again we are inside of main.pi and first of all I want to work inside of the level in here inside of build level besides the layer name right now we only have terrain I want to do a bit more because the other layer name that we have in here is going to be water so inside of the editor if I check create grid we have water as a reminder here this dictionary is going to consist of a position for the key 128 and 64 as an example and the value Associated is either I think I call this water top or water bottom this is what we are going to look for inside of level I want to check if data is equal to and I just realized this one I called top if that is the case I want to create an animated Sprite however besides that so else we also have the plain water or the water bottom this one is not animated as a consequence I can turn this into a generic Sprite and here once again inside of Sprites I can copy the parameters and we have a position a surface and the groups position is really easy this one we are already getting from here a group is also easy we only have a single group I want to have all Sprites however now we are going to need a surface and this one we don't have right now this one I want to import inside of this inputs here and then pass it inside of this dictionary in the level when we are creating level which means in here we need to import a water tile and then inside of this one we need water with something something with a water surface and to be a bit more specific this one should be water bottom and this could be a really good exercise for you try to figure this one out import the bottom water tile place it inside of this dictionary here and then try to use it to create a generic bottom water tile and see how far you get first of all we have to import the bottom water tile this I want to store in an attribute water bottom in here I just want to load one individual surface for this I can use load although I'm not sure if I have it available I do I'm using it here so we can use just load instead of pygame.image.load for the folder pattern here I want to go up on folder then to Graphics then to Terrain in there we have water and there we have water bottom dot PNG like so and this should be spelled like this also important here I want to convert Alpha all of this to improve performance now that we have that inside of the dictionary that we pass into the level I can create a water bottom key and the value Associated is going to be water bottom this I can now use inside of the level inside of asset dictionary we have the entire dictionary available this I want to use for the surface which means acid dictionary in here I want to get water like so and now I can add pass in here for the top part of the water and run main.pi and we are getting a syntax error because you've probably seen it I forgot a comma now if I run this again this is looking pretty good let me Place some terrain tiles and now some water tiles remember for now we are only going to be able to see the bottom water tiles or at least I hope we will and this is looking really good we have bottom water tiles that is going to cover one easy bit so now we can start working on the actually animated tiles and for that first of all we are going to need a list of water surfaces this I can do right away let's call this one the water top animation this I can just import SE holder and in here the folder path is going to be one folder up then we have Graphics then we have terrain and in here we have water and animation this once again I want to place inside of the dictionary and this one I called water top this is going to be self dot water top animation and this should be all we need for this part now inside of level in here I want to create an animated Sprite this one is going to need some assets I want to have a position I want to have a group these are the things we are going to need and I guess while we're here we can pass in the proper arguments right away the position we already have this is what we're getting from here the group is also easy we still only have a single group assets you should be familiar with this at this point we need the asset dictionary and in here I want to have water top that is what I imported just a second ago this bit here finally after generic I want to have an animated Sprite this I can now create below generic I want to have class animated this one also has to inherit from generic 4D init method we are going to need self as always then we need assets then we need a position and then we need a group and for the animation in here we need first of all the animation frames which I want to have as an attribute this is just going to be the assets besides that I want to have self dot frame index which by default is going to be zero and essentially what's going to happen is that we are using this Frame index to pick one surface from this list although first of all we have to call this super thunder in it method and in here we need to have the arguments for the generic class although it's quite simple position we already have this is what we're getting from here and the group we are also getting from there all we have to do is to convert this animation frames and pick one surface from there to get started and this could be a good exercise for you to see if you understand what is going to happen here use the frame index to pick one surface from the animation frames and pass them into the parent class and see if we can figure this one out this one honestly should be really simple we need self.animation frames and this is a list with surfaces which means in here we can get self dot frame index and this right now would pick the first surface from this list that is going to give us one Sprite Which means now inside of the level this one here sorry this one here should actually work let me get rid of the comment and let's actually try if I run the entire thing I can create some terrain again for reference and now I can place some water like so and let me run the entire thing and we're getting an error that error happens inside of here that we have list index out of range which is a very common error what it basically means is that inside of this animation frames we don't have any items let me actually demonstrate if I print self.animation frames and I run main.pi again and I am drawing some water tiles you can see that what we've imported is an empty list the reason for that most likely is that I messed up the folder path here and I can already see that Graphics is misspelled the rest looks pretty good though if I run the entire thing with this fix and play some tiles again and now I can play some water you can now see we have the water on top of that you can see now we have a list with all of the surfaces one for each Sprite that we are going to create although I don't actually want to do that although you can probably already tell this thing is not animated for that I want to have an animate method in here we need self and Delta time this I also want to call inside of an update method in here we also need self and Delta time and I want to call Self dot animate with Delta time all we have to do in here is we have to get self.frame index and add the animation speed this is what we're getting from the settings all the way at the top here we have animation speed this is what I'm going to use in here this I have to multiply with Delta time to be frame rate independent and this I want to now use with self.image and I want to get self Dodge animation frames and I want to have self dot frame index essentially what we're doing here self.frame index is going to become a larger and larger number and this larger larger number we're using in here to pick other animation frames for the water tiles although there are going to be two problems problem number one is that self dot frame index is a loading point number and we cannot use 30 point numbers for indexing so this we have to fix besides that self Dot frame index is going to be two large very fast the way you have to think about it for the water frames we have three surfaces as a consequence we could only use very small numbers for the indexing 0 1 or 2. if we have a number larger than that we're going to get an error the problem is frame index is going to be quite fast much larger than that so this is what we have to account for and this is going to be your exercise see if you can figure this one out and again if you know animations this shouldn't be too difficult first of all this part here is really easy all we have to do is this self.frame index we need to convert to an integer that way we can always use it for proper indexing besides that let me get rid of this first part we have to make sure self.frame index is never getting too large this I want to do on a separate line of code in here I want to get self.frame index is going to be zero but only if self dot frame index is greater or equal than the length of self dot animation frames which means if this cell.frame index becomes a number so large that we will get an error here for the indexing we are setting this number back to zero however if that is not the case so else I just want to keep self.frame index s cell dot frame index so no change and with that we have the second part of the exercise since we already call update inside of the level on all of these Sprites there's not much else we have to do which means I can now call main.pi and draw some terrain tiles once again and now some water tiles and let me run the entire thing and we are crashing because animation speed is not defined this happens because inside of here we're not importing settings which means from settings import everything let's try this again now some terrain and some water enough around this this is looking much better and you can see all the way in the top we have some water animations I guess I could make this a bit more visible if I add the water down here and here you can make this look very silly if you really wanted to like so and well there we have animated water now that we have that we can use this animated class for the coins as well it's not actually that much of a change for that though I have to import some more Graphics this is going to happen inside of main inside of imports once again let me actually add some comments here to make this a bit clearer this one is going to be the coins and this one is going to be the terrain for the coins I want to have self.gold self.silver self dot diamond all three of those are going to be import folder and the folder path for all three of them is going to be fairly similar we have to go one fold up then we have Graphics inside of there we have items and then here we have gold we have silver and we have a diamond I suppose I should probably show all of this a bit more visually here is the folder that I can make it tiny bit smaller we have Graphics inside of there we have the items inside of there we have diamond gold and particle I'll talk about this one in a second but the folder path here is what we need so Graphics items and then diamond gold or silver for now this we now have to get into the level which happens inside of this or rather this dictionary here which means in here I want to have gold this is going to be self dot gold like so I can copy this two times I want to have silver and I want to have a diamond and this is looking pretty good with that inside of the level I have to figure out when I have any of these coins this is going to happen inside of this match data because in here I know case 4 is going to be gold case 5 is going to be silver and case 6 is going to be a diamond I know this from settings we have 4 5 and 6 for Gold Silver and diamond all three of those though are going to get the same class I want to have a coin glass in here like for the animated class I want to have assets I want to have a position and I want to have groups spelled properly now once again we know the groups already we want self.all Sprites this one doesn't change besides that for the assets we know this one already we have the asset dictionary and in here we either want gold we want to have silver or we want to have a diamond there is one more thing I do want to add in here all the way at the beginning I want to have something like a coin type this could be gold this would be silver this would be a diamond that way later on I can identify what kind of coin the player collided with although for this tutorial I'm not going to use it it's just if you want to expand it yourself now we have to actually create a coin and let me import it right away so inside of Sprites below animated I want to have glass coin this one since we do want to have an animated Sprite it has to inherit from animated which means inside of the init method we first of all have to use all of the arguments we used here let me copy them actually we first of all want to have some kind of coin type then we need assets the position can stay as it is and finally we have a group all of this now we have to pass into the parent class with super init on the parent class we have assets position and group these I want to pass in here and I think you can tell this is going to be quite easy because these parameters are identical so we don't have to do anything the one thing that we do have to do though is store this coin type here as an attribute which means sales.coin type is going to be coin type however there is going to be one issue although you're going to see in a second what I mean for now though this is looking pretty good which means I can run main.pi again let me play some terrain and now I want to place one of each type of coin and if I now run this we are getting an error that coin.net takes four position arguments but five were given which means I forgot the self in here now if I run this again do the same thing let's Place one of each coin and let's try this now and there we go we have the animations for each coin although I hope you can see the problem in there because all of the coins are a bit off center if this one here is the grid you can see this looks weird there should ideally all be on one straight line and they all look a bit weird right now the reason for that is once again if I have a bit more space here in our game we have 64 by 64 tiles so 64 by 64. and all of the coins are smaller than that as a consequence Pi game is going to place them in the top left and we're going to have some weird positioning this we can fix quite easily though all I want is self.rect is going to be self dot image and get underscore rect and now this Center should be the position this is working because when we exported the position for the coins inside of the editor I hope I find it for the coins we added half of the tile size for x and half of the tile size for y that way we're placing the coin in the middle of this tile and this we can use in here earlier on inside of generic for all of the other Sprites so far we always place the top left which is not what I want to do for the coins but this should now fix the entire thing let me Place stuff again let's do a few more coins actually and if I run the entire thing this is looking much better cool so with that we have some coins now all of this is a good start but we can't actually do anything with the coins so let's work on that it's not that complicated inside of the level I want to create another group this one I called self.coin Sprites this one once again is just going to be another group I can just copy this one and minimize the edit method and now every time I am creating a coin I want to have all of the coins inside of both old Sprites and inside of self.coin Sprites that way I can Target them easily and this I can use inside of another method let's call it get points in human itself and nothing else and all I really have to do in here I have to get the collided points and this I get with pygame DOT Sprite dot Sprite or light I forgot the assignment operator and then here once again we need a Sprite we need a group and we need new kill the Sprite is going to be self dot layer the group is going to be coin Sprites and do kill I want to set to true because I do want to get rid of the coin and with that inside of the event Loop let me clean this one up a tiny bit more we essentially have an update part and we have a drawing part inside of the update part I want to call self and get coins if I run this now and I do have to be careful here because the player can only move left and right so I'm going to place the coins to the right if I run this now and the player moves to the right the coins disappear that's a good start although it's not exactly an exciting thing here for that I want to create a particle effect every time the player collects a coin which means after running all of this I want to or Sprite in collided coins I want to create a particle effect and this particle effect is going to be kind of like the animated Sprites except it's only going to play one animation and then destroy itself although and here once again we need assets we need a position and we need a group also this one we do have to import so besides animated I also want to have a particle or this one let's cover a couple of the arguments first position is the easiest one because in here I want to have Sprite Dot rect.center I'm going to place this particle in the same Center where we add the coins we just collided with for the group I want to have self.allsprites that is all we are going to need next up we are going to need the assets this I first of all want to import inside of main.pi inside of the coin section in here I have self dot particle this is what you have seen just a second ago inside of the items folder I also have particle let me open this one once again we have particle and inside of that we have a simple particle effect it's nothing particularly fancy this I now have to get into the level which I do with the asset dictionary in here I want to have particle and this I get with self Dodge particle now with that inside of the level we have something available although the problem is this get coins doesn't have access to this as a dictionary we have to figure out something else in my case I added another section that I called additional stuff not the greatest name but it gets the job done and yeah I want to have particle surfaces and this I get with the asset dictionary and what I want in here is the partic hilts I think I called it I actually just called it particle so self dot particle and with that I have some particle surfaces that I can pass in here for the assets now what we actually have to do is to create this particle class this once again is going to happen inside of the Sprites let's do it on top of the coins I want to have class particle this one I also want to inherit from animated and for the init method we know we need self we need the assets we need a position and we need a group and the first thing I want to do in here is called the super Thunder init method and pass in the assets the position and the group once again this and this thing is identical so we essentially are just creating an animated class although once again we have to account for the position which I can copy from here and we are good to go if we didn't add this line here the position of the particle would be slightly offset from the coin which I'm trying to avoid besides that we have to overwrite the animate method although we also need self and delta type the problem here is inside of animated this animate is designed to run forever but for the particle I only want to play the animation once and then destroy the object so we have to create a different kind of animate method this one could actually be a really interesting exercise for you write to write an animate method that only animates over all of the surfaces once and if we are beyond that we are going to destroy the entire object so pause the view now and try to figure this one out once again I want to have self.frame index plus equal animation speed multiplied by Delta time this part doesn't change but now I want to add an if statement that if self dot frame index is smaller than the length of self dot animation frames only if that is the case I want to update self.image with self dot animation frames and now in here I need the integer of self dot frame index so far we have kind of covered the first two lines of the first animation although this animation would simply stop once we reach the end of the animation which in our case means I want to have an else statement and I want to destroy with the kill method the entire object and with that I am good to go if I now run main.pi and I can place a gold coin and run the entire thing and if I now get over the coin you can see an animation this one worked really well which means we have a working particle on top of that what you could be doing in here is if Sprite dot coin type is equal to for example gold then we could I know I could print gold in this case and let me run the entire thing again place a couple of gold coins run it and now I'm getting gold and this information you can use to do well whatever you want in my case though I don't really care about it and I want to keep the entire thing a bit more streamlined this video is already getting really long so with that we have the coin logic and I can minimize a bunch of things and this is covering another major section for the next part now that we have some basic system to place things we can place all of the remaining objects and well let's Jump Right In most of this is not going to be too difficult we just have to create a few more classes once more we are inside of main.pi and I want to keep on working inside of the level specifically inside of build level because in here I want to have a few more cases quite a few of those are going to be fairly simple for example for case 11 I want to have another animated Sprite and this one is going to be for the small foreground palm tree let me type it in here small Palm foreground although this is just going to be an animation it doesn't do anything else so the class we already have we can just reuse and in here we need assets we need a position and we need a group once again the group is going to be self dot or Sprites the position we also have this is the one we have used up here and this we don't have to change the only problem we have is we are going to need some assets and this once again is going to happen inside of magnet Pi inside of imports in here I want to have another section that I called Palm Breeze in here we do have a bit of a problem now let me illustrate what I want to avoid here's the project folder I can go to graphics and inside of there we have terrain and we have palm trees in here we have a bunch of different folders and all of them contain some animation for palm tree my issue is I don't want to type the import for every single one of these folders which would be kind of annoying to do as a consequence I am going to store all of them inside of self dot Pawns and now we are going to use dictionary comprehension to import all of them what this is going to mean I want to have a folder as the key and inside of the folder I want to have import folder the function we already created and inside of the app we need a path and this path is going to be to all of the folders which is inside of Graphics inside of terrain inside of palm and then I want to look at the folder although this one has to be a variable and I should spell this properly as well this I want to do for folder in all of the folders my problem now is how do I get all of the folders I hope the rest of the logic here makes sense though all we're really doing we are importing a folder and for that folder we need a specific kind of path this we are getting from here the path to the main folder is always going to be the same but inside of that folder I want to look at every folder that exists inside of that folder which means here is the graphic folder and we are going inside of terrain and inside of palm every single folder is going to be the name of one of these folders this is what I want to get or rather this is what I'm trying to get here and that is information I am getting from walk although right now I don't have work available but that I can change quite easily I want from OS import walk if you remember from way earlier when we did all of the import folder this one here import folder addict and import folder we have used walk there as well so it shouldn't be entirely new inside of work I need a file path that is going to be the same file path I have used here let me copy it and paste it in here and this is going to give me way too much information also by default I can only use this in the for Loop so I have to convert this to a list and this is probably going to be really confusing so I'm going to cut all of this out comment out the entire line and just print what we're getting from this if I run this you can see we have a long list with information all I really care about is the first item in here that is this bit because what this one is telling me as a reminder when we are using work we are getting three bits of information and that is the name of the folder then we get all of the subfolders and then we get all of the actual files besides folders inside of this folder all I really care about is this list here everything else I can get rid of entirely so how can I get this bit then and this is actually quite easy I only care here about the first element so if I run this again and close the game now I'm only getting the first item returned and on this I can run indexing again I only care about item number one which means indexing here again with one I now get a list with all of the folder names and this is what I want to use inside of my dictionary comprehension I can uncomment this and paste what we have just created in here and now we are good to go once again if you have a large enough monitor this is going to be much easier to work with once we have this I'm going to print self dot this should be homes I am definitely getting worse at typing like so if I run this now we didn't get an arrow and this is looking pretty good for example now we get large background and this is a list of a bunch of surfaces and this we can use I hope this line here makes sense honestly it's not that complicated although you do have to look at it for a couple of seconds but then it should be fairly straightforward all right this I now want to get into my level which means inside of switch I want to have all of the poems and this is going to be self dot ohms now this I can use inside of the level to get the assets here I want to have the asset dictionary and inside of there we have the Palms which is going to give us another dictionary on this dictionary I want to use indexing again for example this pointer here number 11 is going to be the small foreground and this one needs to be a string once I have that we should be good to go let me try it actually if I now place a small palm tree run the entire thing we are getting a key error this happens inside of the level and I think the problem here is this key is Palms while I used Pawn now if I run this and place a palm tree and go to the level you can see we have one palm tree this is looking pretty good what we have to do now I can get rid of this comment and duplicate this thing a few more times because now we have 12 13 14 15 16 17 and 18. those are respectively we have the large foreground we have left foreground we have right foreground and then we basically have the same thing except for the background so we have small background we have large background then we have left background and finally we have right background all of those are just going to be animated Sprites that don't do anything else meaning now I can try all of this and place a bunch of palm trees to make sure I can work with all of them so I want to try the alternative ones like so and now let's try this and there we go we have all of the palm trees this looks really good later on we are going to add a few more things in here but for the basics this is literally all we need and I suppose I could add a couple of comments here this is going to be the palm trees and this part is going to be the coins the one thing we have to do now is to get the enemies the enemies are going to be a larger topic so I am just going to place some basic Sprites here that show us that we have an enemy but for those we have case seven we have the spikes then we have case eight this is going to be tooth that's the name of the enemy that's the walking one and this should be an eight and then we have case nine this is going to be the shell pointing left and this I can duplicate because now we have the shell pointing right these are the four cases we now have to account for the easiest one in here is spikes because this one is well not that complicated at all although I still want to place it in a separate Sprite class so I can work with it and the rest I can comment out so we're not going to get an error now for the spikes in here we don't need very much we need once again some assets we need a position and we need the groups position once again it's a really easy bit we don't have to worry about it for the groups I want to have two groups here I want to have self dot all Sprites and besides that I want to have another group that I called damage Sprites these are all of the Sprites that if the player collides with them the player is going to get damaged this doesn't exist right now but that we can change quite easily inside of the init method I want to have self.damaged Sprites and this is going to be pygam.spright dot group and now we have the same issue again we need to get the assets for the spikes this is going to happen inside of main.pi in here in the import I want to have the enemies the spikes here are going to be really simple because we have self.spikes and this is literally going to be a single surface so we can just use load and the file path is going to be one folder up then Graphics then we have enemies then we have spikes and inside of there we have spikes.png although don't forget I want to convert Alpha all of this so just to be thorough here we have all of the graphics I want to look at the enemies inside of there we have the spikes and there we have the spikes literally just one surface this I now have to get into the level in here I want to have spikes and this is going to be self dot spikes so with that inside of the level I can get the asset dictionary and I just care about this spikes cool all we have to do now is to actually create the spikes bikes like so and now inside of sprite I am going to add let me put it here I want to have all of the enemies this could actually be a comment enemies and this could be simple animated objects that way we keep the entire code a bit more organized in an actual example you might even want to think about separating all of this into multiple files for example the player could be its own file the enemies could be their own file and so on but in my case I think this is still fine I want to now create the spikes this one since there's no animation this can just inherit from generic and we don't have to do very much I want to create an init method in here we have self we have a surface we have a position and we have a group this is what we have done here we have a surface position and the groups those we now have to pass into the parent class with super and init and the generic class has position surface and group I can just pass them in here and we are good to go at least for now spikes is just going to be a copy of generic but later on we're going to add a tiny bit more to make this class better for the Collision I am basically going to add a mask but that's a fairly simple thing to add although now inside of level I am already importing the spikes so this should be working now inside of main let me add some terrain and some spikes I can place them anywhere I want actually let's do it like this if I run this now this is looking like we have some enemies very happy with that so that's one part covered next up we can work on tooth this once again is going to be another class and in here we need the assets again that we don't have yet then I want to have a position and then I'm going to need some groups position we have seen multiple times by now although for the groups I want to have the same groups I had for the spikes like so which means if the player is touching tooth the player should get hurt the last thing we have to figure out now is the assets and the same pattern we have already seen is going to follow here I want to have the asset dictionary and then here I have two although this one is going to be a bit more comprehensive than the spikes let me demonstrate actually here we have the folder with all of the graphics inside of there we have tooth and tooth has three different animations we have idle this one's quite long then we have run left and we have run right all of this we have to import this is going to be kind of similar compared to the palm trees which means in here self dot tooth is going to be something that looks somewhat comparable to this line here and to see if you understood that line this could actually be a really fun exercise import all the surfaces images from the file path that you need here is going to be let me copy it really quick this is the folder path you are going to need one folder up Graphics enemies and two and specifically what I want you guys to do is to create a dictionary for self.tooth and every subfolder inside of this folder is going to be the key and then the value is going to be all of the images inside of that subfolder so pause the video now and try to figure this one out should look very similar compared to this since all of this is going to be kind of similar I can just copy the entire bit and paste it in here and well mostly what we have to do is change some names in here most importantly I want to go to Graphics then enemies and inside of there I have two this I have to do for both of the folders so we have one here and we have one here the rest however can remain basically identical which means if I now print self.tooth not toggle move let's see what we get this is looking pretty good we get one key with idle this one has a bunch of surfaces then we have run left and we have run right I'm pretty happy with this and once again this we have to add to the level via the dictionary this is going to be tooth and then here self dot Doof which means now this one should be working so all we have to do is to create this class here and while we add it I want to import it as well so tooth in here and now inside of Sprites we can create tooth class two and just like the player TUF is going to inherit from generic in here as always we need a Dunder init method that needs self the assets the position and the group this is what we have done in here we have assets position and group should be fairly straightforward at this point and at some point in here we have to call Super init and the arguments we need here are for generic we need a position surface and group and in here we already have the position and we have the groups so once again all we need is going to be the surface for that this is going to be kind of similar compared to animated I want to have self dots animation frames this is going to be the assets we get and I want to have self dot frame index by default this one is going to be zero this is going to be identical to what we have done in here unfortunately though we couldn't just inherit from animate it because we have to make a few more changes the major issue is that this animation frames is not a list it's a dictionary what we have in here essentially is we have for example idle and inside of there we have the surfaces besides that we had walk left and this one also has a list of surfaces the issue is we have to first identify what our current state is and then we can use indexing to get the surface which means we have to get one more thing which in my case I get with self dot orientation and by default I want to to go in the right direction this I can now use to create a surface this surface is going to be self Dodge animation frames and in here I now want to create an F string that says run underscore and then the orientation remember here the frames could ever be run left or run right idle is essentially only for the editor inside of the actual game tooth is always going to run which means all we really have to change is the orientation to left or right and then tooth is going to run and phase in that direction with this we are getting an actual list and on this list we are getting self dot frame index and now we are good to go this surface we can pass in here which we already have and we should have a basic start let me get rid of this dictionary here and let's try this now I can play stuff as usual and now if I place tooth and some spikes let's see what happens we are getting an error and I can already tell where this is going this should be self dot orientation next attempt let's Place some spikes and proof and now let's try this and there we go we can see tooth doesn't do anything right now but at the very least we have something finally we need case 9 and 10 and both of those are going to be shells so I'm going to cover both of them at the same time which is quite simple because they are both made by the same class the only difference between the two is that one is going to face left so we're going to pass left and here's an argument and the other is going to face right besides that we have the normal arguments we have the assets we have the position and then we'll get a bunch of groups at least for now I only want self dot or Sprites the reason being the player should be able to stand on the shell without being heard as a consequence the shell is not going to be inside of the damaged Sprites which means all we have left is the assets and this we can work on inside of the Imports once again and then here I want to have self and shell like so and for this once again I want to have something that looks like this let me copy it and now we have to work with this import statement here inside of Graphics we have enemies and there we have shell we actually have left gel and we have right shell in our case fortunately we only need one and I'm gonna go with shell left let me show the folder actually here are all of the graphics we have enemies and there we have shell left and shell right if I got shell left we have idle looks like this and we have a tag looks like this and then we have the same thing for right something like this what we can do for the shell is import only shell left and then flip the entire Sprite if we have a right shell that way we don't have to import so much which means now all I have to do is copy all of this here and paste it inside of this one and we should be good to go let me print what we get self.shell just to make sure if I run this we now get attack and we get idle this is all we need so we have to get this into the level once again this happens with shell enter here self dot shell so now inside of the level I can get the asset dictionary once again and this is going to be shell which means now we just have to create the class for this one which is going to be shell and inside of Sprites we have to make the actual class so class shell this one as before is going to inherit from generic and in here we need it init method we need itself we need orientation we need the assets we need a position and we need a group orientation I do want to store as an attribute so self.orientation is going to be orientation besides that I want to have self dot frame animation frames and this is going to be the assets we just passed into although here's one thing that I realized while testing the game once it was finished this you want to copy because we are going to flip all of these assets if the shell is pointing to the right side and if we didn't add copy we would flip all of the assets even for other classes so this copy here is really important otherwise all of your shells are going to point in the direction of the last shell you have used although speaking of I can now check if the orientation is equal to right then we want to flip all of the frames inside of this frames and this could be an exercise for you I want you guys to flip all surfaces inside the animation frames keep in mind here animation frames is a dictionary with key value Pairs and only the values are actual surfaces and those you want to flip so pause the video now and see if we can figure this one out I want to start with four key and value in self dot animation frames and items and here I want to get once again my animation frames and I want to overwrite the current key or the key value pair and the item I want to add is going to be another list I can start by just copying what is in there and this is going to be surf for surf in value like so we're getting the value here and we are copying all of the surfaces but this is not exactly what I want to do instead what I want to do I want to manipulate this surface and this I get with pygame DOT Brands form dot lip and now we need to surface and we need information if you want to flip this in X and in y and those are going to be true fault statement I do want to flip this thing in X but I do not want to flip it in y and with that we are flipping all of the surfaces if the shell is pointing to the right so I can minimize this one and work on the rest of it what we need now is self dot frame Index this one once again is going to be zero and then I want to have self dot status by default this one is going to be idle and once I have that I can call this super in Niche method and once again we have the generic parameters that we need to cover I can just copy them and paste them in here the position we are getting from up here so this one is very simple the groups we're also getting from up here so nothing to worry about surface is what we do have to think about and this is going to be quite similar compared to two because animation frames is a dictionary we first have to get the status and then we can use indexing for this one I'm not going to create a separate variable because we don't really need it I can just self dot animation frames inside of there I can get self dot status and then I can use indexing with self dot frame index and for start this is all we are going to need let me run main.pi again without cutting an error I can play stuff as usual and now let me play some spikes the enemy and two shells and now if I run this we are getting an error that name assets is not defined this is happening inside of here because I forgot to pass in the proper value for this assets here this is literally the same information because we are flipping all of this data inside of the class now next attempt let's run out of this again let's Place some enemies like so nothing's crashing and there we go we have all of the enemies although you can see they all have a bit of an offset from the floor this area here looks a bit weird yes we can fix right now and then we are nearly done and once again the problem here is that we have a tile size of 64 by 64 and the shell for example is only covering this size which is why we're getting the Gap below that is a very easy thing to fix now we have self.rect and I want to update the bottom of this rectangle and the bottom here I get with self.rect.top plus the tile size which means I am getting the top of the rectangle this line here and I am adding the tile size so 64. and this is why I'm placing the bottom which means now we are getting the bottom information here the same thing I am going to tooth and make sure you're calling this after the Super method otherwise you are going to get an error but now I can run this again and let's try all of this one more time like so and now I can run this and this is looking much better cool so with that we have literally all of the objects inside of the game we just have to make them work a little bit better but at the very least we have a really good start in this section once again is getting quite long so let's finish this one up now that we have the level we can start working on the player movement and for that we are going to need a couple of things first of all the player already can move left and right that's a good start but I also want the player to be able to fall and jump however for that we are going to need collisions with the level otherwise falling and jumping is going to be kind of annoying which means we are going to start by creating collisions with the level let's have a look how that's going to work and let's do all of this trading code once again here we are in the code editor and I want to have a look at my level file in here there's one important thing that I have to figure out and that is when I'm building a level I also want to when placing all of these Sprites I have to figure out what kind of object I want to place that the player can collide with and here we do have to be quite careful for example for it to rain those are going to be fairly simple if we have for example a block or a Terrain block that looks like this I want all of those to be collidable where this becomes a bit more complicated is if we look at all of the palm trees these ones here because for all of those a palm tree could for example look like this with a long stem and what I want is that the player can only collide with this top part here which means for those we have to create some custom way to create collisions which we couldn't do with the animated class so we have to figure out something else and here's what I'm going to do I'm going to create a whole separate class for that inside of Sprites I am going to create a whole another class and this is going to be a very simple one so let me minimize everything else that way we can focus on things a bit easier there we go the class I'm going to create is going to be called class I call this one just block once again this one can inherit from generic because we are just going to create a very simple Sprite or the init method here I want to know I need a self I need a position now I need a size and now I need a group importantly here we do not have a surface the reason for that is imagine once again I have a palm tree that looks in a simplified way something like this what I want to do for this block is to spawn the block on top of the palm tree in this position with this size and this block is going to be collidable while the yellow part is not going to be collidable as a consequence the pink rectangle will not be visible so we don't need a fancy surface I am just going to create a surface from the size and since it's going to be invisible that's really all we need as always we need some kind of super Thunder image method and for this one we have to figure out these parameters here position surface and group position and group are going to be easy those we already have what we have to figure out is how to convert the size to a surface which means in here we need a surface this surface we get with pi game and surface and for this surface we always need a tuple with a size and that is the size we are actually getting so whenever I'm creating this kind of block the size here is going to be a tuple with X and Y once I have that surface I can pass it in here and I am good to go this is literally all I need with that I can minimize this class and back in level I first of all have to import it let me do it right next to generic I want to have a block now we just have to figure out how to use it for that inside of the init method when I'm creating my groups I want to create one more group in this one I'm going to call self.collision Sprites once again this is just going to be pygame.sprite.group and that's all we need in here so I can minimize this and now any kind of object that we are creating inside build level that is going to be inside of the group is going to be collidable with the player for example when I'm creating a Terrain this part here I want this to be in all Sprites and in self.collision Sprites just with that I can make this generic collidable with the player while this one here the water bottom tile is not going to be collidable because it's not inside of the group so with that we already have the terrain covered next up we have to figure out this slightly more complicated bit and that is all of these animated trees and also the shell needs to be collidable the shell is the easier bit because this one we can treat like the terrain I want this to be in all Sprites and self.collision Sprites that way the player later on can collide with them now a slightly more complicated part is going to be these palm trees here because those I couldn't just put into two groups and well that wouldn't work because we will be ending up with the entirety of the palm tree being collidable which I don't want let me first of all separate them into foreground palm trees and background palm trees the background ones we can just ignore because those are not going to be collidable at all those can just remain an animated Sprite and we don't have to worry about them what we have to worry about is the foreground palm trees and then here let me do one example besides the animated palm tree I also want to create a block for this one I'm going to need a position a size and a group for the group for now I'm going to place them in self dot all Sprites and self.collision Sprites although later on I'm going to remove all Sprites that way this block is not going to be drawn but the Collision is still going to work besides that we need position and size position once again is easy we already have that and we used it multiple times what we have to figure out is the size and for what this one well I could measure this in Photoshop it depends on the graphic but for this palm tree I want a width of 70 and a height of 50. also let me move this block that way we can see this a bit easier which makes bug fixing a bit more visual let me actually try this if I switch to main.pi and I play some small Pawn trees and run the entire thing there you can see we now have a black rectangle on top of the palm trees this later on is going to be the collision and I did notice here this I could probably make a tiny bit wider just to be a bit more accurate let's say 76 and let's try this again how to place palm trees again and this is definitely looking better you can play around with this as much as you want there's basically no end to it this we now have to do for the other palm trees as well next up we have the large foreground palm tree this one fortunately has the same top size as the small one so we can just copy this bit and call it a day besides that we have the left palm tree and the right palm tree those have a palm trees that look like this and then we have the top part here which means this is the entire bounding rectangle for the surface and we have to move the Collision One somewhere here that would be the case for the right one but for the left one we can keep it somewhere here because let me use a different color because the left one is going to look like this that is the one we are going to work on in here once again I want to copy the block and since we're always placing this position in the top left I can also leave this one as it is which means I can copy this one more time and now we have to figure out the right foreground Pawn Tree in my case all I really did was I added a vector with 40 and 0 to this and that's basically all I needed that way this block is going to be a bit further to the right which is perfect to capture this top part and let's try all of this if I now Place different palm trees like so and so and run the entire thing you can see that this is working reasonably well although this part here could do some more work let's move it a tiny bit further let's say I want to move it by 46 pixels and place all of them again and that is could still do a tiny bit more let's say I want to move this by 50 pixels and this is the only one I want to place and there we go this is looking really good with that we have a collidable object for all of the foreground palm trees body shells and for the terrain this is literally all we need obviously for the terrain and for the shell we can't really see them right now because we are using the object itself as a collision object but that is something we can work on later for now what I want to do is to remove these self.all Sprites from all of the palm tree Collision objects that way they're not going to be visible anymore but once we work on the player they are definitely going to be felt like so and this is all I need for this stuff here there's one more thing that I do need and that is when I'm creating the player all the way up here this player needs to know the position of all of the collidable Sprites I can just Place self dot Collision Sprites and here and that way the player is going to have access to them and really important here for the player I am assigning the player Sprite to the group all Sprites and I'm giving the player a reference to the Collision Sprites but the player itself is not inside of the group or is not going to be inside of the group this is different for example to the terrain the generic type we create up here we are placing this generic inside of all Sprites and collision Sprites understanding the difference here is really important the player only has a reference to Collision Sprites but is not itself in it because it couldn't collide with itself that would be weird but now the player has access to all of the collisions which means inside of sprite I can look at my player one more time and first of all we need another parameter this one is going to be the Collision Sprites this I want to capture inside of a variable let me add another section here that I called Collision I want self.collision Sprites it's going to be Collision Sprites and while we are here there's one more thing that I do want to do and that is that the player should have a hitbox and this is supposed to be a rectangle as well the size of it I think is best explained by looking at the graphics here is the folder for all of the graphics I want to look at the player and let's say I want to look at run left if I open a random one inside of this the entire surface is going to have a size something like this but not all of this is supposed to be collidable what I want to have is that the player can only collide with this rectangle here more or less which means I have to shrink the original rectangle quite a bit and for that I want to get self Dot rect and this I want to inflate and now I need to inflate it by an X and A Y amount Y is going to be zero because I'm happy with the height X however I want to shrink by 50 pixels and with inflate we are keeping the Center Constant which means if this one here is the original rectangle we are creating one that looks something like this that we are shrinking by 25 and 25 pixels on each side that looked best when I tested the entire game now we have to incorporate this hitbox into the player movement as well that is going to happen down here inside of the move method and this one for the collisions we have to change quite a bit anyway the most important thing that we have to do here for now is we have to split this into horizontal and vertical movement why that is you're going to see later but it is going to be really important for the collisions to fix this one first of all I still want to get myself.poss but now I want to get the X part of it to this I want to add self dot Direction dot X multiplied with self dot speed and multiply this by Delta time this I now want to use to move the hitbox so self Dot hitbox and remember the hitbox is just going to be a rectangle but you couldn't use the left for this one because this would make the math kind of awkward if I show the drawing again I want to start by moving this Collision rectangle and then later on make this actual rectangle that shows the position of the player follow in the same position and then placing this Collision rectangle in the top left is going to be kind of awkward because we couldn't translate this easily to the original top left which means in my case I'm going to place the center of the hitbox that way I can use this Center also for the positioning of the larger rectangle that shows the player that is going to make my math quite a bit easier so for this one I want to place this Center and this I'm getting with round self dot post dot X and once I have that I can place self.rect.center X it's going to be self dot hitbox dot Center X and I noticed this one should be Center X not Center because we only care about X or the horizontal movement for now the same thing we now have to do 40 horizontal movement which means I can copy all of this paste it in here and this bit I can get rid of and essentially now I just have to replace all of the X's with y's and then I should be good to go sort of the X should be a y and now we basically have the same outcome with one intermediate step we can see the hitbox however when we are creating the position when I'm creating this Vector I don't want to have the top left I want to have the center just to keep things consistent and with that let's try all of this actually so let me draw some terrain tiles run the entire thing and the player can still move left and right so that's a good start we make this even more visual let me minimize the build level and inside of run right now we are drawing all of the Sprites on top of that I also want to pygame dot draw Dot rect on self dot display surface with let's say a yellow color I want to draw self.player Dot hitbox if I run all of this again I can run the level straight away we can't see anything the reason for that is that right now the player has a width of 32 pixels and if we shrink this by 50 pixels we can't see anything but if I change this let's say to 80 now if I run the entire thing let me draw some terrain tiles and run this this is looking much better the yellow bit is now what is actually going to collide with the level so with that back and Sprites I can actually start working on the Collision logic this I'm going to cover in another method let's call it Collision in here we need self and we need the direction first of all here we have to look at all of the Collision objects which we get with four Sprite in self dot Collision Sprites remember all of the collidable Sprites we put inside of this group once we have that I want to check if Sprite dot rect dot collide rect with self Dot hitbox now I'm checking after I have all of my Sprites I want to check if the player hitbox collided with any of these Sprites inside of that if statement I want to add another if statement because now I want to check the direction is the direction equal to horizontal that I want to do horizontal collisions for now I'm going to add a pass if that is not the case so else I want to check vertical collisions for now I'm just going to add a pass in here in here now we just have to figure out some basic things let's say for example we have the player here and the player is moving to the right this direction we can get from up here the direction of the player that one is quite easy to get so we always know if the player is moving right or left and if the player for example is moving to the right and he just overlapped with an object like so all I really have to do is put the right side of the player so this part here on the left side of the obstacle and once I have that I basically have collisions which means inside of Direction I first of all want to check if self.direction.x is greater than zero this means we are moving right if that is the case we are moving right and we have a collision that means the players colliding with an object on the right side and this I can use to set self dot hitbox dot right equal to Sprite Dot rect.left if I draw all of this again the right side of the player is going to be this bit here and the left side of the obstacle is going to be this side here that way as soon as there's any kind of overlap we are putting the right side of the player on the left side of the obstacle and we have a collision the same thing we now have to do with if self.direction.x is smaller than zero if that is the case we are moving left and in here we can check self.hitbox.left is going to be sprite.rect dot right once we have done all of that I have to do two more things first of all we have to update the rectangle this is the one that the player is actually going to see for this one I also want to update the center X and I want to set this to self dot hitbox dot Center X what this means is imagine we have the player moving to the right but then because of a collision we moved this rectangle a bit further to the left as a consequence the center of this rectangle moved from here to let's say somewhere here all of that just means that the Collision has changed but it doesn't tell Pi game without this line here that we want to draw the player in a different position as well but once we have this line we know that we also want to draw the rectangle so what the player actually sees around this new center that way the player can actually see the Collision finally the actual position that we have so self.post.x I also want to update this is going to be self.hitbox.center X and that is all we are going to need for horizontal collisions I can call this method now self.collision don't forget to pass in horizontal in here and now if I run main.pi again and draw some terrain tiles next to the player and run the entire thing if I now move too far to the right I can't go any further same as the left side this is looking really good the same thing if I return to the editor I can also do with a palm tree let's place it here run the entire bit again and the same thing is also going to work with a palm tree so I'm very happy with this which means all we have to do now is copy all of this for the vertical collisions and this is going to be your exercise let me add a bit more space I want you guys to copy the logic here and apply it to the vertical axis so pause the view now and try to figure this one out this one is going to look basically identical compared to this one although we can make all of this a bit more space efficient but I also want to be able to test out of this for that first of all let me copy these lines here and now I want to check if the player is moving down or up and if that is the case I want to move y for all of these with that I have to add a pass in here again let me test this and Run the game and switch to the level now I can move the player around as I want obviously this is not going to be the logic for a side scroller but that we're going to implement in just a bit this is good enough to test things now in here I now want to copy this logic but make it a tiny bit more space efficient because there isn't that much happening here and writing six lines of code is kind of Overkill we can set self dot hitbox.top so this is what I'm doing here basically except for top and bottom I want to set this to sprite.rect dot bottom this means if the player is moving up and overlaps with a wall on the top if that is the case I want to move this top side here to this position the bottom of the wall but I only want to do this if self dot Direction dot Y is smaller than zero meaning the player is moving up if that is not the case so else I want to keep self.hitbox.top as it is the same thing I can do for the bottom so now I want to place the bottom of the player to the top of the rectangle which means now the player is moving down like so and overlaps with a wall on the bottom I want to get this bottom part of the player and move it on top of the wall this is what I'm getting here and this I only want to do if the player is moving down so Y is positive or direction that Y is positive to be a bit more specific if that is not the case I want to keep bottom as it is this Alliance basically do the same logic as these four lines here except in well much less space all we have to do now is copy these two lines here I want to set self dot rect.center Y and I want to set self dot pause dot y both of these are going to be self Dot hitbox Dot Center y all I have to do is copy this one and I am good to go with that we have covered the same logic that we have here for the vertical side in half the amount of lines which I think is also a bit more readable but it's a bit subjective let's try it actually now let me place a couple of terrain tiles all over so it's easy to test like so if I run all of this I can move around this Collision works pretty well and in here there is a bit of a problem the other collisions seem pretty good though oh this one is also not great so we have to look around here a bit so the vertical collisions definitely not ideal yet let's have a look I think I actually realized what the problem is I am not actually calling inside of the move method self dot collision with vertical now let's try this again if I now run main.pi let me draw a few things again like so now the collisions are working much better and this is pretty good I'm quite happy with that part okay this seems to be working just fine so I can leave this one as it is I can't see any kind of problem here while we're here I also want to make all of this as space efficient as this bit down here I guess I can also explain the logic a bit better I want to place self dot hitbox dot write to sprite.direct.left but only if this condition here is true if it is not true I want to keep self.hitbox.right where it was before this is going to cover this part here so I can take it out and duplicate this line and to duplicate this one here I want to place the left side of the hitbox to the right side of the wall but only if the direction is smaller than zero that way we're moving left and now I can get rid of this bit here finally I want to assign self.rec.centerx and self.post.x where the hitbox is like so and with that all of this is much more easily readable yes one thing I forgot and here at the end this should be hitbox left but with that we should be good to go let's try this if I now place a few more elements and try all of this still looks pretty good so yeah this is working just fine cool very happy with this with that we have Collision logic and the entire Collision logic here really isn't that complex this is still fairly simple it's like a minimize for now and now we have to work on the actual player side scroller movement logic which means that the player actually moves like a 2d platformer for that we first of all want to get rid of this one here because well the player shouldn't be able to just move up and down we should only be able to jump and fall inside of the init method I want to create a few more attributes the first one is going to be self dot gravity this one I have set to 4. besides that there's one more attribute that I want and this I called self and on lore this by default is going to be false later on the player is only supposed to be jumping if he is on the floor if it is not the player shouldn't be able to jump that way the player couldn't keep on jumping in the air now we have to implement all of this and for this let me minimize a couple of methods here besides move I want to have a method I called apply gravity this one needs self and since we have movement this is also Delta time and that is some horrible spelling all I really want here is self.direction.y plus equal self dot gravity multiplied by Delta time as always gravity just means we are falling down so y gets larger and larger and this number I now want to add to self.rect.y plus equal self.direction.y note here what is really important I am using plus equal twice which means that we have an exponential false speed this Direction gets larger and larger every single time and this number we're always adding towards the position but that is all we need I can minimize this one before I'm running move I want to self dot apply gravity with Delta time if I run this again now and let me just go to the level and the player is indeed falling that is a good sign now let me try the same thing again with some terrain and we have a platform and there we go now we have some basic movement although if I wait for a bit this should eventually break I just have to wait for a bit maybe it doesn't but basically now if I fall down the player moves down really really fast the reason here is when the player was still standing here we kept on increasing self.direction.y which means every millisecond the player stood on this platform the gravity that he would be subjected to was larger and larger in practice pygame would put the player down to let's say this position here realizes it's on top of a Terrain and place the bottom of the player back to this position here if this was running for long enough though we would eventually get to an arrow that is somewhere here and then pygen would assume that the player just jumped over the entire platform another problem that we have seen is if we wait on the platform here for a while and then fall down all of a sudden the player falls down at a really fast speed so we have to account for a couple of things here this is actually going to happen inside of collision what I want to do if the player is colliding with something vertical I want to reset the gravity which means I want to set self dot Direction dot y back to zero which effectively cancels out all of the Gravity we have applied inside of this method here and this is really important that way the player doesn't accumulate gravity while standing on the platform which would become a massive issue when we're trying to jump or falling down from a platform kind of hard to test but this is basically all we need in here okay and now that we have that I also want to cover the jump mechanic this one we are going to start inside of input and what I want to check in here is if he's is pygame dot k underscore space meaning the player is pressing the space button and self dot on floor is true if that is the case basically all I want to do is move the player upwards so self.direction.y is going to be 2 and just to test this let me set self dot on floor this we get up here to true if I run all of this now and let me add a platform here so we can see what we're doing we are getting an error that I have made a typo this one here now let's try this again and I create another platform and now if I press space the player goes up and comes down again this is looking really good I'm quite happy with this all we have to figure out now is how to check if the player is actually standing on the floor since we don't have that right now let me actually show what problem we have and let me add a couple of terrain tiles here so this is a bit easier to show if I am in the air the player can keep on jumping which um well I hope you can see the problem with this is is not his side scroller we rather have some kind of Flappy Bird kind of thing this we have to account for which means by default I want to set on floor back to false the input we don't need anymore and we also don't need the init method instead I want to have another method that I called check on floor no custom parameter needed here and essentially what I am going to do if this one here is the player I'm going to create a rectangle below the player like so and if this rectangle here is colliding with some kind of collidable object we know the player is going to be on some kind of floor for that first of all I want to create a floor rectangle this one is going to be pygame Dot rect and now we need the left the top the width and the height the height is going to be fairly subjective I've set this one to a 2. two pixels for this one is perfectly fine but we also have to figure out the width the top and the left side and this I think could be a really good exercise for you try to figure out all of these values and see what you can come up with so pause the video now and try this one yourself the width is very easy I want to get self.hitbox.wiff that part should make quite a bit of sense if this one here is the hitbox of the player and this one is the entire player drawing what I want is this area here this one right now is two pixats high that's what we are getting here and the width is going to be this area which is the same width as the hitbox which is what we are getting here while we have that let me draw this again we have the player hitbox and we have the floor rectangle now we have to figure out the top left and this one is going to be quite simple because all this is going to be is the bottom left of the hitbox let me turn the width and the height into a tuple that way we can turn the positioning also into Tuple and here I want self.hitbox.bottom left just to check if this one is working I want to turn this self.floor into an attribute now after we're moving I want to run self.check on floor and inside of the level after we are doing the update that's really important so after this line here I want to draw all of this I guess I can copy this rectangle Here and Now self.player.floor rectangle and I'm going to use a different color let's go with pink if I now run off this again draw something here it doesn't really matter what it is and now we have a very small pink rectangle on the bottom of the player it's quite difficult to see but if you squint you can definitely see it so this is working I guess just to make it a bit more visible let me change this to a 20. and try out of this again there you go now it's much more visible but this one should only be two otherwise we get weird results this rectangle we want to check if there's any kind of collision with the floor or rather with the Collision Sprites for this one I'm going to create another variable let me call it floor Sprites and in here I want to get all of the Sprites that this self.flor.rect is colliding with and this I get with Sprite or Sprite in self dot Collision Sprites now I'm copying all of the existing Sprites but I only want so if Sprite dot rect dot collide rect with the floor rectangle and this self we don't need anymore what this list comprehension here means is we are copying all of the Sprites from the Collision Sprites but only if a Sprite is colliding with the floor rectangle this we can now use to check that self on floor is going to be true if there's anything inside of this list meaning if we have floor Sprites if that is not the case so else it is going to be false that is all we need in here now inside of level I want to get rid of this line here because this one would throw an error but now inside of main.pi let me draw once again a couple of platforms and run this again now I can jump but I can only jump if I am on a platform this is quite nice I can also jump to another platform and this is looking much more like a side scroller except I can't play it well so with that we have the player movement another major step for the next part we can actually show the player that is going to make the game much more visually appealing with the player movement coverage we can work on the player graphics and this one isn't going to be terribly difficult first of all we have to import a couple of different things all to play animations then we have to figure out what the status of the player is so is the player falling jumping running we also have to know what direction the player is facing so left or right but once we have all of that we just need a simple animation and we are good to go which means once again let's jump into the code editor and let's have a look at all of this back in main.pi I need the first step I have to import some player Graphics which I want to do in here because the player has a ton of different Graphics I am going to place this all the way at the end here I have the player and all of this is going to be inside of one attribute let's call it player graphics once again if I open the folder we have the project here there we have Graphics there we have the player and here are all the different possible states that the player can have for example we have idle right we have four left lots of different things that we could import and what I want is a dictionary and the key is always the name of the folder and the value is going to be all of these surfaces imported this we have done a couple of times already which means I can just copy this one here for example and paste it in there the only difference being that when I look at the folder there should be graphics and layer and the same we're going to do for the other folder this should be graphics and layer there we go and now let me print self.player graphics just to make sure this is working and there we go this is looking pretty good now we have four left we have fall right and we have lots of other states I am quite happy with that now we have to get this into the level this once again is going to happen inside of the switch method in here I want to have another entry for the player this is going to be self dot player graphics that is all we need to import the graphics next up we can work inside of the level in here the important thing is that we are getting all of these Graphics into the player class so in here let me do it all the way at the top I want to have the asset dictionary and I want to have the player Graphics this I now have to store inside of Sprites inside of the player Sprite with another parameter so in here I want to have the assets this I now want to turn into some animation logic and here first of all we want to have animation frames and those we're getting from the assets next up we need self.frame Index this one is going to be 0 and now we need self dot status this one by default is going to be idle finally we're going to need self dot orientation by default this one is going to be right these two lines here are already the second step of what we have to cover now we have the graphics with this part here the next step is figuring out the player's status so what is the player doing and which way is the player facing once we have that though we can create a surface and for the surface we have a dictionary with all of the different states as a key and then Associated we have a list of values right now I want to combine these two here to pick one key from this dictionary to get one value or one list of surfaces and from that I want to get the first Index this could be a good exercise for you to see if you can follow along try to get the surfaces that are either right and pick the frame index 0 from that and set this as the surface and then you can pass this surface in here like so okay first of all we want to get all of the animation frames in here I want to get some kind of string that is going to be idle right so I'm combining this one with this one with an underscore separating the two and this I want to be more flexible so I'm going to use an F string replace the first one with self dot status like so and right should be self dot orientation this is going to give me the full status of the player and this entire thing here is going to return a list of services on this list of surfaces I now want to perform indexing with my frame index and that is the entire line that we need so if I now run may not Pi let me play something and go to the level we can't see anything the reason here is we are drawing over the entire surface this I don't want to do anymore I also don't want to draw this happen inside of level in the run method I don't want to draw the hitbox anymore like so and now let's try this if I now switch to the level we can now see the player it doesn't actually update but well that is something we can work on next the rest is still working just fine let me minimize the init method and now what we are going to need is two more methods the first one is going to be get status and here we need itself and nothing else let me add pass in here and besides that I want to have an animate method this one needs self and Delta time in here as well I also want to have pass let's work on animate first that one is going to be the easier one and this is the kind of method we have already seen a couple of times so if you want to do an exercise here right to write the animate method it's going to be quite similar compared to the one we have created in here I could actually just copy the entire thing at least for now and pass it in here all of these are actually I think the naming are kept fairly consistent so all of this should still work just fine we just have to call it so inside of update all the way at the end I want to have self Dot and made with Delta time oh although I did realize there's going to be one error in here and that is these animation frames by default are not going to work because as you have seen here we need something quite extensive to get the actual animation frames I think the best way to approach this is copy all of this and create a current animation and this is going to be what we get in here but we're not indexing from it I hope I didn't go too fast just now but once again we're getting the animation frames and then we are getting one list of surfaces by using the full status once we have that I can replace these animation frames with the current animation and those ones as well that way later on inside of get status all we have to do is change this status and this orientation and we always get the proper current animation but this one should already work let's try this one and if I now run the entire thing you can see we have an animation doesn't change but at the very least the player is animated very good so now we have to get get status in here I want to check if self.direction.y is smaller than zero if that is the case self dot status is going to be jump after that I want to have an L if statement and the condition is going to be self.direction.y is greater than zero now we are falling so self dot status is going to be all if neither of those two are the case I want to have an else statement and this else statement is only going to trigger if direction.y is zero and this means the player is standing somewhere on the platform all I really have to check is if self.direction.x is different from zero if that is the case the status of the player is going to be run however if Direction dot X so else if this one is zero then self dot status should be idle and I don't really like that we're using four lines of code for something so simple which means I can rewrite this a tiny bit I want to have self.status being run only if this condition here is true if it is not so else then I want to have self.status being idle this one down here and with that we have the entire thing much more concise this get status we now have to call let me do it right before animate self dot get status what is really important here is that you're calling this get status always after applying gravity and move especially move here is important because in there if the player is on a platform we are changing self.direction.y to zero and that way we know if the player is falling or jumping or standing on a platform and now let's try this one and you can already see something is working although the player is always falling that is not ideal also the player doesn't face in the right direction so there are a couple of things we have to work on first of all let's start with left and right that's actually the easier one because in here inside of input if the player is pressing right I want to set self dot orientation to write and if the player is pressing left the orientation should be left let's try this one now and let me Place once again a few more terrain tiles I guess while we're here I can also place a couple of palm trees like so and we are definitely making progress so I can move left and right I can see the player jumping and this is definitely looking better the problem now is if I am on the floor the player is always falling so this is not ideal or this one I can minimize the input method and the easiest way I found to fix this is when we are checking get status here right now I am checking if the direction.y is greater than zero but I want to set this to 1. if I try this now and create a few more platforms once again now this is going to work the reason here is highgame basically moves the player down a tiny bit on every single frame and then checks if we are colliding with something if that is the case Pi game moves to the bottom of the player here but because of this Collision check we always have a very low y direction and this one we know that this is so small it is never going to exceed one so if we have a one here this is fairly safe and with that I can clean all of this up a tiny bit and now we have the animations for the player so let me place a few more platforms to make sure this is working and I can place I guess a few more palm trees in here like so and let me also place a couple of background ones so we know that those don't cause a problem this is looking pretty good and the player can move around just fine and the animations also look really good so I am very happy with this the game is definitely taking shape so yeah we are absolutely making progress for the next part I want to create the camera there are basically two major things that we need here number one the camera should always follow the player meaning the player is essentially always in the middle of the window and everything else gets drawn around the player besides that I also want to sort all of the objects in the level by depth this one is going to ensure that we for example always have the background palm trees in the actual background right now Sprites are going to be sorted by the way they are being created so if one Sprite is being created after another Sprite the Sprite that is created later is going to be on top which isn't terribly reliable to well create any kind of graphic system so let's work on those two things this shouldn't be too difficult inside of the code I want to work inside of a level and the way the camera is going to work is we are drawing everything inside of all Sprites this I want to change a bit or well I want to instead create a camera group this is still going to be a spread group but a special one that is going to draw everything in relation to the player this I want to create in the same file so let me create another class here that I called camera group this one has to inherit from pygame.spright.group this one as always is going to need a niche but there's no need for any kind of custom parameter however we do need to call Super thunder in knit once we have that though we have basically created a perfect replica of a normal pygam Sprite Group which means if I run the entire thing now let me draw a couple of terrain tiles and let's test a few more just to make sure everything is still working is looking pretty good so we are now drawing everything via a custom group but so far this custom group is a perfect copy of its bright group this we want to change though and first of all I need a few more attributes the first one is the display surface this one I'm getting with pygame DOT is Lay dot get underscore surface and besides that I want to have an off set this one by default is going to be a vector what we are now going to need let me call it a custom raw method this one in itself and we also need to know where the player is in here though first of all we need to draw something in general and what pygame does internally it does for a Sprite in self works because we always attach all of the Sprites to this group and now all we need is pi game and now we can use this for blitting so I want to get self.displaysurface dot lit and then here I want to have Sprite dot image and Sprite Dot rect this I can now use inside of the run method instead of running all sprites.draw let me comment this one out I want to get self dot all Sprites dot custom draw and in here I don't need to display surface because this group always has the display surface instead what I need is the player this I get with self.player well now this doesn't do anything but later on we are going to draw everything in relation to this player but let me first of all try this if I draw and run the level so far we haven't made any kind of change and let me get rid of the comment here we don't need that one what I can do in here when I'm drawing or blitting all of the Sprites I am always putting them in the same position where the rectangle is but I don't necessarily have to do that instead I could for example get an offset rectangle and this offside rectangle is going to be Sprite dot right let's copy it and this offside rectangle I now want to offset this I can do with offset rect and let's move the center minus equal by self dot offset which means now instead of drawing this sprited rectangle I want to draw a surface wherever the offset rectangle is this one we have created here since the offsite right now is 0 and 0 this isn't going to do anything meaning if I run out of this once again there is no change whatsoever we always starting in the top left however what I can do now if I change this Vector to let's say something like 250 if I run this now and let me add a few more things in here now everything is drawn 200 pixels in this direction and 50 pixels up this I can use by default though this Vector here should be 0 and 0. the way I want to use this offset this should always be relative to the player and in here I need self.offset.x and self dot offset dot y I want to get player.rect Dot Center either X or Y depending on what axis we are looking at and from that I want to subtract the window over to window with like so or the window height like so and both of these I want to divide by two what this basically means is imagine that this one here is the player and I want to draw everything else in the level so all of the tiles everything relative to the position of that player this means I want to look at the center of the player this is what I'm getting here and then the top left of the current part of the window should be half of the window width to the left that's what we are getting here and half the window size up this is what we are getting here the resulting point is going to be the top left of the window if I try this one now and let me draw lots of terrain tiles like so go to the level and now you can see we have a camera following the player and with that we have some basic camera logic so this one here is kind of all we need for the camera although there's one problem that I do want to account for if I run the level editor again and let me draw some terrain tiles and place lots of palm trees floating in the air that should make it a bit easy to illustrate what I'm talking about also a couple of background ones like so and run the entire now inside of the level the player this one actually worked really good I want the player to be on top of the background palm trees and behind the foregone palm trees at least for the stem bit I place them a tiny bit too high but the problem here right now is that the depth of all of these tiles is decided when we are creating them so the later Sprite is going to be created the more on top it is going to be which sometimes could mean that the player is behind a palm tree which I really want to avoid and for that inside of Sprites let me minimize the player I am going inside of generic going to add one more parameter that parameter I called that and that by default is going to be I have different settings actually down here we have the different layers of the level all the way in the back we have the clouds then we have the ocean then we have the background water and Main most things are going to be in Main which means the default argument let me copy level layers in here is going to be inside of main that way once again we don't have to make any change to the existing Sprites which would be a pain to do this I now want to turn into an attribute so self.zet is going to be Z for the block we can ignore this system entirely because the block doesn't really care about where it's drawn oh well it's not even drawn at all so this one doesn't matter at all next one for animated this one doesn't need that although here once again I want to have a default argument that I can just pass in there so we don't have to make any change to the existing parts and this is that I want to pass into the parent class like so and this is the only change we really have to make here inside of level let me minimize the camera group and the init method and I want to look at my build level in here when I'm creating these palm trees and these palm trees this is the only time where I really care about the depth because those always need to be in the background and this I can achieve by adding one more argument all the way in the back and this is level layers this is what we're getting from settings and in here we have the key BG so inside of settings we have BG that way all of these palm trees are going to be drawn in the background in particular behind Main the other place where I really have to care about this for now is when I'm creating the water this one here this one also is going to need another argument for the level layers and this one here I called water so in here we have water this one I want to be on top of the background but behind Main and with that we have the basic information for all of the layers if we don't specify this one here these Sprites are always going to be on the main layer and for all of those I'm pretty happy with them we only really care about these and the water tiles those need to be in the background all we have to do now is to actually implement the logic for this drawing which means when we are doing our custom draw we know that every single Sprite has a z parameter and this set parameter can be really useful to draw the level inside of a layered manner all I really want to do is for a layer in level layers dot values this is going to give me the numbers between 1 2 3 4 and 5. and this I can now check if I indent this information I only want to draw a certain layer if Sprite dot Z is equal to the layer and only if that is the case I want to draw all of this and with that we have different layers let me run the entire thing now and let me Place lots of palm trees I hope some of them are going to be visible well this is a slightly more difficult thing to test let's try this one and well at the very least this one is working and this one is more deliberate later on when we have the clouds you're going to see the system a bit more but this one by itself is a pretty good start so all right with that we have another major part now that we have the player we can work on the enemies the first enemy I want to work on is the shell for this one it doesn't damage the player on contact that way the player can stand on top of it I think that should already work however the shell does shoot a pearl and this one damages the player so what we basically have to figure out is if this one here is the shell we want to shoot a pearl whenever the player is in a certain distance let's say in this radius here let's have a look at that once again I'm on the code editor and I want to work inside of the level more specifically inside of build level where we are creating this shell that happens here bodies we have to do a couple of things number one is they need a I called this one a pearl image this is what they are going to shoot next up number two they need to know where the player is this one should be quite obvious I want them to shoot if the player is in a certain distance and once the player is I want them to start shooting this Pearl image once we have those two we can work inside of the shell and add the stuff that we need but let's get started with the Pearl image this one as before is going to be imported inside of imports I will do this right below the shell I want to call this self dot Pearl and this is literally just a single surface so I can use load again and the file path here is going to be one fold up graphics and there we have enemies and in there we have Pearl and pearl dot PNG also don't forget to convert Alpha all of this just to double check this here we are in the folder I want to go to graphics and there we have enemies there is Pearl and inside there we have this simple image that's called Pearl this is what we are going to import and this we now have to get into the level that is once again happening inside of the dictionary here and I want to have Pearl with self dot Perl all right now we have this available in here and for both of the shells let me put them on separate lines that's going to be a bit easier to read actually this is probably best if I use named arguments we have orientation then we have assets and we have position and then we have groups and then I can put all of this over multiple lines that is going to make everything so much easier to read like so much more visible and in here I want to add one more entry this is going to be let's call it the Pearl surface this we also get from the asset dictionary although in here this one I called Pearl that's the one we just imported this one here or this one here with that we have covered the first part we have a pearl image the next part is going to be a bit different because now we have to know where the player is unfortunately now we do have a problem because we couldn't just add the player in here as another argument the reason is we are only creating the player here and there's a reasonable chance that this player will be created after these shells which means if we try to pass the player in here the player might not exist yet which is well not ideal the easiest way I found around that is I created another Sprite group let me call itself and shell brights this group we do have to create so inside of a knit I want to create self.shell Sprites once again this is going to be pygame dot Sprite dot group and that way I can Target all of my shells quite easily this I can then use all the way at the end of this entire statement here all the way at the end of this I want to Loop through all of my shells which means for sprite in Self Storage shell Sprites I want to add Sprite dot player is going to be self dot layer and let me minimize the match data for Loop because this one here I want to have on the same notation level as this original for Loop but this is literally all we need here and with that I believe we are done with the second part let me get rid of it and now inside of Sprites I have to account for all of these parameters although I already see I made a typo this is group and this I called groups so let me fix this one the rest is looking pretty good though although we do need one more parameter and that is the Pearl surface this I also want to store let me add another section here that I called I guess Pearl works first of all I need the Pearl surface as an attribute so per surface is Pearl's surface besides that though I do want to have a few more attributes here the first one is has shot by default this one is going to be false next up I want to have an attack cool down and this one is going to be a timer fortunately we already created a time up way earlier if I open my files in here we have timer and I can reuse one of these timers so inside of Sprites I want to from timer import timer now we have to create a duration I went with two seconds or 2 000 milliseconds there's one more thing that I forgot to add and that is self dot damage group what this one means inside of the level again if the player touches spikes for example the player is supposed to later on get damaged because these spikes are inside of damaged Sprites any kind of sprite inside of this is going to damage the player if the player is in contact with it and I want the Pearl surface to be inside of this damage Sprites as well as a consequence since we are creating this pulse surface inside of the shell I want shell to have access to the damaged Sprites but not be in it itself which means I want to have another argument in here and let's call this the damage Sprites is going to be self dot damage Sprites this is kind of similar compared to the player this Sprite has access to the group but is not in the group itself but now inside of my Sprites again I can add I think I called this damage Sprites yep and those let me name this properly damaged Sprites is going to be damage Sprites right with that we have all of the parameters we are going to need for the Pearl which means now we can start to animate it adding here I want to have animate with self and Delta time as always and I want to have an update method that also gets self and Delta time and this one is going to call self.nmate with Delta time this we have seen a couple of times already and in here once again we have to get the actual animation so let me start off this in a separate variable that I get with self dot animation frames and self dot status this one so far is quite simple we only really have two statuses we have idle or attack so not much can go wrong here then I want to get self dot frame index plus equal the animation speed multiplied by Delta time this one should also be fairly straightforward but now we do have to make a change and that is if self dot frame index is greater or equal than the length of the anime not animation animation I think earlier I call this the current animation that probably makes a bit more sense like so I want to have a proper if statement and this is different compared to for example animated where I put everything on a single line the reason is inside of this line here when we are checking if the animation is ending I want to do a few more things although for now I want to set self dot frame index back to zero and at the end of all of this I want to set self dot image back to the S is the current animation with integer and self dot frame Index this animation here is basically the same thing that we have done up here except a bit less concise but the function is basically identical but let's try this one actually I haven't run the code in a while so let's check if everything is still working I want to create two shells let's run this entire thing it doesn't crash and that's looking pretty good and the player can also stand on the shelves so we are definitely making some progress although right now you can see that the shells don't do anything but at the very least nothing is crashing that's usually a good sign right now they are animated but they're not doing anything because they are idling and the idle animation is a single image so it looks like a static image for that we have to add a bit more logic and I guess I can put out of this inside of a get status method or this one we need self and nothing else all I really want to check in here is if player is close enough that could be a random number then I want to set self dot status to attack and if that is not the case so I want to have an else statement then self.status should be idle remember here we do have access to self.player because of this line here all the way at the bottom which is all you really need to figure out the distance between the player and the shell and if you want a specific number let's say if the player has less than 500 pixels between himself and the shell I want the shell to attack and this could be a good exercise for you try to use some math to figure out the distance between the player and the shell and if the player is closer than 500 the shell should have the status of attack pause the video now and try to figure this one out obviously this is going to be an if statement and first of all I need a position of my player and this I get with self dot player.rect dot Center this I want to turn into a vector with Vector because this allows me to use one specific method that is called distance 2 which is giving me the distance to another vector and the other Vector I want to look at is self.rect.center or at the center of the shell and if the resulting number is smaller than 500 then the status should be attack however if that is not the case so else I want the status to be idle like so and I can get rid of this comment here and this is going to cover most of it so now before we animate we also call self.getstatus and let's try this one and let me add a longer level with a bit more stuff and I can play shells all throughout here let's try this and they can see the shells in the bottom are attacking so this one and this one is attacking but this one is just chilling however if I go closer at some point it starts attacking and they can see it perfectly this distance seems to working just fine cool also let me close the timer we don't need this one anymore now that we have that we can start to think about how to actually shoot a pearl and for that we need to work quite a bit more inside of this animate method but essentially all I really want to do in here is if a certain condition is true and there are quite a few in here let me go through them actually the first one is if in self dot frame index is equal to two this by itself is going to be kind of confusing I'm checking if we are on the third frame inside of the animation remember here we are starting at zero the reason why I'm choosing this Frame let me open the folder actually here we have it and we have Graphics enemies shell left and attack the frame we are looking at right now is this one here and I have chosen this one because this is the best frame to actually start creating the Pearl you can see here the shell is charging and here it's basically recovering so on this one I actually want to shoot it just imagine if it were on this Frame here and we would have one Pearl here it would look kind of silly because we have the Pearl in there and we're also shooting one that I want to avoid so I only want to create the Pearl if we are on this Frame that is this if statement here besides that obviously I also want to check if self dot status is equal to a tag this should be a comparison operator there we go and there's one more condition that we need and that is and not self dot has shot this one should be obvious once we have shot I want to run a timer that the shell can only shoot every two seconds that we are going to control up here with the timer and inside of here I need to do a couple of things I first of all need to get a pearl Direction so is the Pearl going left or right and this one is quite easy I want to have a vector with negative one and zero this one is going left if self dot orientation is equal to left this is the orientation we created earlier all the way at the top and this one is telling us what way the shell is facing if that is not the case so else I want to have a vector that goes 1 and 0. this one is going right once we have that I want to create a pearl for this one we are going to need another class I'm going to do that in a second but for now I just want to print Pearl was shot this we're going to replace in just a bit and after I have done that I also want to set self.hashot to true that way we're not going to trigger this multiple times what we now have to figure out is how to reset this self.hash shot and for that we have the timer up here and basically what I want to do after we set the self.frame index back to zero I want to check if self dot has shot is true which is going to be the case after we have short or after we have run this if statement here if that is the case I want to activate my attack cooldown which I do with activate and besides that I also want to set self dot has shot back to false with these two lines I can look at this get status again because I only want the status to be attack if the player is close enough and self dot attack cooldown is not active which means I want to have a not in here that way after we have activated this timer here the shell cannot attack which means this entire statement here would not be run the last thing we have to do is to update the timer so self dot it tag cooldown I called it dot update and with that we should be good to go and I just realized this one should be an end instead of an if this is looking much better so now let's try this and let me just create one shell then we can test this a bit better so right now it doesn't do anything because the player is too far but if we get close enough we get probably shot and there again after about two seconds and this keeps on going so this is looking pretty good and for this one it might be kind of hard to follow the logic I would definitely go over this a couple of times you want to understand how this part this part and this part here interact with each other but in my case I am going to continue and I'm going to create another class that is going to be the Pearl this one as always is going to inherit from generic and in here I want to have an init method for this one we need itself we need a position we need a direction we need a surface and we need a group and first thing that we are going to do in here is a super init method this one is going to come from generic so we need positions surface and group that's the stuff we are getting all the way to top here position surface and group that we can just ignore we now need a few more things first of all since this Pearl is going to be moving we need some movement attributes we want self.position and this is going to be a vector and a position here is self.rect dot top left besides that I want to have self.direction and this is the direction we are getting from the parameters this direction here we're just going to pass in here finally this one needs self Dot speed and I've set this one to 150. finally I want to have a selfdestruct mechanism because this Pearl if we didn't destroy it would keep on going forever and at some point we would have too many of them for that I'm going to create self.timer and this is going to be the time up we have already seen and I want to have a duration here of 6 seconds and after these six seconds are over I want to destroy this entire object which means right when I create this Pearl I want to activate the timer like so activate with that covered I can create an update method and here we need self and data time and now we have to figure out the movement and the timer for this class and I think this could be a good exercise for you move this Perl here in the direction by a certain speed this is either going to be left or right for the direction and then after the time has over destroy the entire class and if you want to go further you can also create the Pearl right in here as well and see if this one is going to work so possibly now and try to figure all of this out I want to have self.post.x plus equal self dot Direction dot X multiplied by self dot speech multiplied by Delta time this is going to give me new position and this position I'm going to use to update the rectangle which I'm doing with round self dot pause dot X and that is all we need for the movement next up for a timer I first of all want to self dot timer dot update so the thing actually runs and now I can check if self.timer is active but I only really care if this is not active and if that is the case I want to destroy the Sprite with the kill method and with that we have the Pearl I am going to copy the parameters and minimize this thing and now inside of these two lines here I can create a pearl with these arguments the direction we already have this is the Purl Direction surface we also have this is self dot Pearl surface bought a group we are going to need two important groups in here the first one is self dot damage Sprites this one should be obvious this is what we're getting from here however there's one more group that we need and that is all Sprites and this we absolutely need because this one is the only group that draws anything unfortunately we don't have all Sprites easily available but we do know when we are creating the shell we are assigning self.uspirites as the first group inside of this list and this we can use because this list is always ordered and we can access it so inside of Sprites when I am creating the Pearl besides the damaged Sprites I also want to get self Dot groups don't forget to call this and this is going to return a list with all of the groups that this shell Sprite is in and I want to get the first one this is going to be all Sprites Auto make sure here that you have the same order if this all Sprites for somewhere else you would need a different index but with that we have a pearl let's try so I can run the entire thing let me create a longer level and let me create two shells and now we're getting an error the reason is that this position has not been defined but that we can do quite easily I want to create this Pearl wherever self.rect.center is now let's try this again and I want to create a few more terrain tiles and let's put a shell here right now nothing happens but if I get close enough we are getting one shell two shells this is not looking bad at all the issue is right now the shell is a bit offset and this makes the entire thing look a bit weird so when we are creating the position of the shell I mean the Pearl we need to get an offset inside of this if statement here I want to have an offset and for this one I first of all need to get my Purl Direction and multiply this by 50. but this I only want to do if self dot orientation is equal to left if that is not the case else I want to get an offset and the number I found for this one is 20. the different sites here look a bit different so these numbers are necessarily equal but once we have that remember Pearl direction is a vector so we can just add this to the position and now this should be looking a bit better and let me try to add two shells here like so and so and now this is already looking much better the only problem now is that all of these pearls are a bit too low which I also don't really like so if you look at them they don't really align with the mouth of the shell or the opening or whatever it's called which means I want to have a bit more to this offset or both if statements I want to add plus vector and this is going to be 0 for x and 10 for y this should actually be negative 10 because we are going upwards and now let's try this again I want to create two more shells and now this is looking much better so I'm quite happy with this with that we are concluding the shell now obviously the player is not going to be heard by the Pearl but that I want to have in a separate chapter there we are going to add the interaction between the player and all of the enemies but next up let's work on tooth that's the other major enemy so let's start working on tooth and tooth is ultimately not that difficult he basically runs around and reverses Direction every time he collides with an obstacle or a cliff importantly here he doesn't actually have gravity he just moves left and right that is much easier to calculate that's kind of all we need so let's Jump Right In and let's have a look once again we are in the code editor and in here we first of all need the tooth Graphics those fortunately we already have we imported them way earlier so this I don't have to worry about which means inside of level we are creating two in this line here and most of this is perfectly fine that being said there's one thing that I do want to add and let me add tooth on the next line since tooth needs to reverse if there's some kind of collision tooth has to know where all of the Collision objects are as a consequence I'm going to add one more argument in here and that is self.collision Sprites with that kind of like the player tooth is inside of all of these groups but also has access to the Collision Sprites although he himself is not in it but once we have that I can work inside of the Sprites and I want to flesh out tooth right now he's quite simple and he needs Collision Sprites I want to start by creating a movement section and let me add in section here let's call it the general setup like for the Pearl we need self.direction first of all and this by default is going to be a vector that points at 1 and 0. although actually while we are here we could randomize this a tiny bit and for that I want to have from random import choice and this choice I want to use with Choice and then here I can pass in if one or a negative one that way the start direction is ever going to be left or right next up we need to position this we get once again as a vector and then here self.rect dot top left this should look like this finally I need a speed so self dot speed is going to be a hundred and twenty and I did forget we do need to turn the Collision Sprites into an actual attribute so Collision Sprites here and then we are good to go however there's one more thing that I do want to do and that is to destroy tooth at the beginning like so if e is not on a lore the reason here is tooth is going to move left and right and it's going to switch Direction every time he faces a cliff and there's no gravity for him whatsoever the problem with that is if we place them in the air it would look really weird so I want to add the logic that if tooth is just placed somewhere in the air without a floor tile I just want to destroy him right away and that could be a really good exercise for you try to figure out at the beginning when we are creating the Sprite if tooth is standing on the floor or not and if not destroy the Sprite immediately to figure out if tooth is standing on the floor I want to use list comprehension in here I want Sprite for sprite in Collision Sprites that's why I am checking all of the Collision Sprites but I only want to get a Sprite if sprite.racked dot Collide point and this point is going to be self.direct dot mid bottom and plus a vector of 0 and 10. that's why I'm checking if there's a point below the player and I'm going to check all of my Sprites in Collision Sprites if they are colliding with that this is then going to return a list and if this list is empty I know there's nothing below the player which means I want to destroy the Sprite this we can actually test right away let me run main.pi again and let's create a few terrain tiles and let's place two here here and then let's say here and here and let's see what happens and they can see all the ones in the air just disappeared so this is looking pretty good that's a very nice Safeguard and once we have that we can work on the other bits in here first of all I want to have an animate method as always with self and Delta time and this one is actually going to be quite simple so current animation is going to be self dot frames and for this one I want to have an F string and we always want to have run and the other thing we need is self dot orientation remember this is also what we got earlier up here although once I have this bit the rest is going to be very simple I want to increase self.frame index by the animation speed multiplied by Delta time and besides that I want to set self dot frame index to zero if self dot frame index is greater or equal than the length of the current animation and else I want to keep self dot frame index and finally I want to set self dot image to the current animation with self.frame index with cell frame index being an integer this we have already done a couple of times and well shouldn't be too difficult at this point once we have that I can call the update method with self and Delta time and actually call self.animate with Delta time and let's try if I run this again and select tooth we are getting an error that we have no frames because this frames here I called animation frames next attempt let's try this so and there we go now we have an animation looks pretty good we just have to move him now for that I'm going to create another method self dot move this one also needs Delta time in here move and solve with Delta time in the most basic sense all I want here is self.post.x plus equal self dot Direction dot X multiplied by self dot speed multiplied by Delta time we have seen this plenty of times already and once I have that self.rect dot X is going to be round self dot pause dot X with this I can run this one more time and let me place a few things here I can place two in many different places run the entire thing and there you can see they are moving except we have no bottom Collision so not ideal yet but at least something is happening now we have to figure out how to limit this movement only to a platform and for that what I have done this one here is tooth and I'm going to create a gap rectangle here and here and I'm also going to create a wall rectangle here and here the red ones here are checking for a cliff and the green ones are going to check for a wall and if there's any collision with any of them I'm going to change the direction so for example if tooth is moving to the right and there's a collision either with the green rectangle or there's no collision with this rectangle I want to reverse the direction to the left for that first of all I have to create a couple of things I want to have a right Gap I want to have a right lock then I want to have a left Gap and I want to have a left lock all of these unfortunately are going to have different positions for the right Gap or the right Cliff or whatever you want to call it I want to have self.rect.bot right and then here I want to add a vector that is one and one this means if this one here is tooth I am getting this bottom position and I am moving one and one pixel to the right and down next up for the right block I want to have self.rect dot mid right that is horrible spelling midrite and then here a vector that is one and zero for the left block this one is going to be self.rect dot bottom left plus a vector of negative one and one for this one we're going one to the left and one down finally the left block is self.direct dot mid left plus a vector of negative one and zero with that we have all of the different blocks we want to check now we just have to use them and then here first of all I want to check my Direction so self dot Direction dot X is greater than zero this means we are moving right we now have to check two conditions number one is going to be no floor Collision and number two is going to be a wall Collision the idea here is if this bottom right point doesn't have contact with the floor we know that tooth is facing a cliff and tooth should return this is going to be this part here the second part is going to be the wall collision and this we're checking with this point and all I'm really checking here is if there's any kind of collision with the wall and if that is the case I want two to return as well all of this by the way is going to look kinda similar compared to what we have done up here which means this could be an interesting exercise try to check those two conditions to see if tooth is either facing a cliff or a wall if that is the case I want to change direction.x and multiply it with negative one and self dot orientation is going to be left that is all you need for the movement so you have to figure out this if statement here try to see if you can do it I am going to put all of this over multiple lines that is going to make it much easier to read and let me call it floor Sprites for this one once again I want to have list comprehension and in here I want Sprite for sprite in self dot Collision Sprites this is going to copy all of the Sprites but I want to add an if condition that I only want a Sprite if sprite.racked dot Collide point with my right Gap this way I know if there's going to be a collision between the bottom point of my player this one here and the floor and if this list here is empty I know there is a cliff this I guess I can now copy and call it wall Sprites for this one I want to check the point right lock like so but the rest can stay basically identical once I have those two conditions I can I guess let me put the comments here a bit more proper once I have those two I can check if we have Wall Sprites or not lore rights then I want to do all of this the idea here is if there's anything inside of the wall Sprites or if lowest price is empty if either of those two is true then I know the players facing a wall or a cliff and should reverse Direction this we can test right away let me add a few platforms because I can't control the starting direction of tooth so let me just create a bunch of them and at least one of them should work out there we go and now on the right side you can see they are reversing this is looking pretty good and also if I add a wall in here let me do it for this one and run the entire thing you can see this is also working cool so this is definitely working now we just have to cover the other side and that part is going to be your exercise so possibly now and see if you can figure this one out first of all I want to check if self.direction.x is smaller than zero that means we are moving left and after I have that I guess I can copy all of this although now I want to check the left Gap and the left block and if that is the case these two are still working out as is this one but now the orientation should be right and by the way in actual code what you would probably do is not declare separate variables but instead you could do list comprehension right away inside of the if statement and if you add a line break this isn't even that hard to read like so and then I can get rid of these statements here although I did realize here I flipped the thingies so this should be like this we want to reverse direction if there's a collision with the wall or if there is not a collision with the floor so now let's try this everything is still working let me create a couple of terrain tiles and place tooth in here and now this is almost working so this is quite good the only problem is if I'm starting all of this again when we are starting at the beginning we have a random Direction this is what we are getting I can minimize move and animate when we're getting this random Direction here we are not updating the orientation that way it could happen that tooth is moving to the left while having the right orientation to fix that all we have to do is self.orientation is going to be left if self dot Direction dot X is smaller than 0 and else it is going to be right now we can try this again and let me add lots of platforms here it's not this one and now we can actually play around with this quite a bit because we have a fair bit of elements available oh and by the way since a shell is also considered a obstacle this one should also work as a limiter and this is looking pretty good so and complain about this one very happy with it obviously once again the player can't be hurt by tooth but that is going to be the next section actually but for this one we have once again made a ton of progress now that we have all of the enemies we can work on the player damage and this one basically means the player gets damaged when there is contact with the spikes the pearls or tooth and direction of the player is going to be a jump and a white Flash I didn't Implement a proper Health mechanic because I think this is already our 10 of this tutorial and well I do want to keep things at least somewhat focused but you could very easily implement this yourself finally we're going to need a mask for every object so the player despite the pearls and two that way we have much more precise collisions it's going to be really important for a platformer that is all we need so let's Jump Right In and let's have a look we are back in the code editor and the first thing that we have to do is to give all important objects a proper mask that way we have more specific collisions let's start with the spikes because that's the easiest one in here we are basically copying the generic Sprite on top of that I want to give this one a mask that we get with pygame DOT mask Dot from underscore surface added here I want to pass in self.image that way these Spikes have a mask which is much better for collisions this I do want to copy because we're going to use it a couple of times for tooth after we are doing all of this I also want to assign a mask however for all of these animated enemies after we are doing animation we also have to assign a new mask because in here the surface has changed not by very much but it's still good practice but that is all we need for the shell we don't need to do anything but for the Pearl we do need to add a mask this we can do right here and since this one doesn't animate we can just leave it here finally for the player all the way at the top I want to have a mask and now after every animation I want to have another mask or I want to update the mask and with that all of the important objects have a mask and this I can now use inside of level four collisions I am going to add another method below get coins because this one I want to call get damage there's no need for custom parameters in here and I want to get my Collision Sprites this I get with pygame DOT Sprite dot Sprite Collide and here first of all I need a Sprite that is myself dot player then I need a group for this one I have self dot damage Sprites then I want to kill so do I want to kill the Sprite my players colliding with in my case this is false finally we have to tell this method that we want to use a mask for the collisions that we get with pygam.spright DOT Collide underscore mask and once we have that I can simply check if there's any kind of Sprite in there so if Collision Sprites then self dot player and here I want to run a damage method this is going to happen inside of the player so in here let me do it all the way at the top Define damage funnel self and nothing else and I want to print ouch let's try this one and I want to have a couple of different elements here I want to have spikes I want to have two and I want to have this shell and I guess also a palm tree so the player isn't always a danger so if I collide with the spikes nothing is happening in fact nothing is happening at all and I can already tell why because I am not calling this get damage this happens inside of the run method in here self dot get not coins but damage next attempt let's try this again just with the spikes and we are getting an error because in here I have a typo next attempt let's see if this is working now that seems good and I get ouch this is definitely working so once I have that I can also place two and the shell and now let's try this again oh this one is still working and if I get hit by a shell we also get some updates this seems to be working pretty good we can't see too much yet but at the very least it's something okay so with that I can flesh out the player damage and what is going to happen first of all in here I want to have a timer this I call Self dot invulnerability timer and this is going to be timer with a duration of 200 which means after the player was damaged I want the player to be invulnerable for 200 milliseconds and I only want to be able to damage the player if this timer is not active so if not self dot inverldtimer dot active and we are calling this method then I want to start the involved timer with the activate method and then I want to make the player jump so self dot Direction dot y minus equal 1.5 I think was a good number we do have to make sure though that we are updating the timer all the way at the bottom actually let's do it right here self.inveltimer dot update and I think there are a bit too many methods open this is going to be confusing we don't need any of this or this or this the gravity can also go so this is basically all we need for now like so what we're doing is we are updating the timer constantly and we are only allowing damage if this timer is not active and by default it is not so let's try this and I'm just going to use some spikes and let's see if this has been working and there we go the player is jumping and this is at least something once again you could flesh this one out quite a bit more but well for this part it's pretty good I think finally what I also want to do this is going to happen inside of animate if the player is being damaged which means if self dot involt timer is active if that is the case I want to make the entire player flash white and for that I need a new Surface and this surface is going to be self dot mask and this I want to turn to a surface in this surface I want to set as the image so self load image is going to be this surface with that let me actually show what we get with some spikes and now we are getting something the problem here is this looks weird because we have the black background but other than that we are basically using the mask to create a new Surface and this turns the entire surface into a black and white silhouette kind of thing to make it look actually good we have to get rid of the black part and this we get with surface and set underscore color key and the color key I want to get rid of is going to be black this color key gets rid of one particular color inside of a surface which in my case is black that way we only have the white color left and now let me add a shell and let me shoot it and there we go we have some interaction so with that we have the interactions between the player and the enemies I guess I should try this one more time with tooth to make sure this one is working as well and there we go we also have collisions obviously we couldn't hurt tooth but well that could be your own project but with that we have the interactions between the player and the enemies another major step we are nearly finished the last major part is to create the sky this one is going to be like in the editor we have to create clouds continuously besides that we also have to create the Horizon and at this point if you still follow along this shouldn't be too difficult given that we have done this before I want to work inside of a level once again and in here I have to do a couple of things most importantly I guess we can start with the Horizon this we get when I'm building the level we also have case one this one is the sky and this I want to use in two ways first of all I want to create self dot Horizon this is the information I'm getting from position one if you remember ages ago when we created the editor this guy handle is what we are looking for right now and the sky handle is going to be inside of the canvas groups this one here actually and on this object we really just care about the Y position this is going to be our Horizon this we need to have available inside of our level and also inside of all Sprites so self dot all Sprites dot Horizon Y is going to be pause one we need it in both because we're going to create the clouds inside of the level so in here and we're going to draw all of them inside of all Sprites so both need this but this is all we need here so besides that inside of the camera group I want to add one more method and that is going to be raw or ryzen for this one and itself and nothing else in here first of all we need a y position and this I stored in a separate variable let me call it Horizon position for this one we need self.orizon.y this is what we already have but from this I want to subtract the self.offset dot y that way this one scales along with the player and now I can check if the Horizon position is smaller than the window height if that is the case once again I can create a rectangle and this is going to be pygame Dot rect and now we need left top width and height left is going to be zero top is going to be the Horizon position width is going to be the window width and height is going to be the window height minus the Horizon position meaning this one here is going to be our C this I can draw right away pygame.row.rect and self dot display surface here I have a c color I believe I called it this we get in settings we have C color this is what I want to draw and finally I want to draw this rectangle and I guess I should name it properly it should be the C rectangle all I have to do now is to call this and this importantly here I have to do before I'm drawing all of the Sprites self dot draw Horizon the reason should be obvious all of this should be in the background so let's try this one now I don't have to draw too much and we're getting an error the reason is I made a typo somewhere this should be Horizon position instead of horizon y I made the same mistake here and here now let's try this next attempt like so and there we go this is looking really good and now that we have that position we can draw up all of the other things which in my case means I want to have the horizon line that is the white line and then I want to have the three extra rectangles this if you look back at the editor Let Me minimize everything in here at some point instead of drawing the sky I think it was in here yeah in here I basically want to do this thing again and this could be an exercise for you inside of the level draw all of the stuff we used to see inside of the editor you could even copy it quite a bit of this is similar so pause the video now and try to figure this one out I guess the easiest way to approach this is to just literally copy all of them and paste them in here since the naming here I am using the same display surface this should actually still work although the one change I do have to make is this isn't y anymore now this is the Horizon position now if I try this and create some tiles and there we go with that we have a horizon we just need the line in between this I am getting with pygame DOT draw dot line and then here self dot display surface the color is going to be inside of settings I call this one the Horizon color I believe like so and now I need X and Y for the start point and I need X and Y for the end point the line width is going to be 3. X is going to be super simple because this is going to be 0 and the window width Y is also going to be quite simple because for this one I want to have the Horizon position and now let's try this one and there we go I am very happy with this with that we have some background all we have to do now is to figure out the clouds so I can minimize this method here although I guess what we could be doing is if the Horizon position is on top of the entire window so to draw all of this if this one here is the display surface and what we have checked here is if the Horizon is somewhere below the window height what we can also check is if the Horizon is somewhere up here that way I want to fill the entire surface with a blue color which means if the Horizon position is below zero then self dot display surface dot fill with the C color let's try this one and I am going to move this one really high up roll this thing and now everything is going to be blue if you have an underwater level this would be the start for it all right this is all we need inside of draw Horizon and let me get rid of this one white space here next up we have to work on the clouds and for that I'm going to create one more Sprite so inside of my Sprites I want to have let me put it all the way here at the top because this one is a fairly simple class I want to have class Cloud once again this one inherits from generic and in here inside of the init method I want to have self I need a position I need a surface and I need a group then we can call Super thunder in Niche and in here I have to pass in the surface the position the group and now for that this is what we usually didn't specify because most things are on Main however the clouds need to be in the background for that inside of level layers we have clouds here and this I want to pass in here with my clouds that way this is always going to be in the background the rest though is going to be for the movement and here I want self.position this is going to be a vector with self.rect DOT top left and besides that I want to have a speed and in here I want to have a random integer between 20 and 30. rent and we don't have right now so I'm going to import it finally all we need in here is the update method with self and Delta time and literally all we have to do in here is self.post.x minus equal self dot speed multiplied by Delta time a direction here we don't need because the clouds always go to the left so once we have that self.rec.x is going to be round self dot post dot X and with that we have a cloud so next up we need graphics for this Cloud this we get inside of main.pi and when I'm importing all of this stuff I need one more import I'm gonna put all of this all the way at the end and here we have clouds and self.clouds is going to be import folder and in there we have graphics and we have clouds this I now want to put inside of my level once again the same way I have clouds and then here self.louds I believe this is the last graphic we are going to need in there so besides that inside of the level we can now start to create some clouds and this I want to put in a separate method Define and create loud and here I want self and event I'm going to check if the event DOT type is equal to self and now we need a timer for the clouds I'm going to call this one Cloud timer although it doesn't exist right now let's actually create it right away so for now print cloud and inside of the init method I'm going to put all of this under additional stuff in here I want to have the cloud timer and this is going to be pygame dot user event and for this one I want to go with plus two because we already have a user event that was plus one and now pygame dot time dot set underscore timer self dot Cloud timer and I want to create a new Cloud every two seconds this I can now use inside of my event Loop and what I want to do in here is if the event DOT type is equal to self dot loud timer and in here I want to create the clouds actually I don't need this create Cloud I can do all of this straight inside of this method here or the if statement rather and here I need a surface I need the X position I need a y position and once I thought of that I want to create my cloud This Cloud I have to import so all the way at the end I want to have a cloud and for this Cloud just as a reminder we need a position surface and group the surfaces we have stored actually nowhere right now so we need to have access to them this I can also do in here self.load surfaces let me call it serves is going to be the asset dictionary and then here I want to have clouds with that I always have access to these surfaces meaning this I can use in here now I want to pick a random item from self.cloud services I don't think we have Choice available right now we don't so from random import choice next up we need an X and A Y position and for now let me set them to zero and 500. just to make sure that something is working once I have all of that I want to create a cloud and as a reminder I need a position I need a surface and I need a group the position is going to be super easy this is going to be X and Y the surface we already have that's the surface we created here and for the groups all I want is self dot all Sprites oh although I did make a mistake this shouldn't be 500 this should be self taught Horizon y by default I want to create the clouds on top of the Horizon so at the very least we can see something and for X since I want all of them to move to the left let's start with 500 for this one this still isn't going to be the ideal position but at the very least we should be able to see something if I now run main.pi let me run the entire thing and we should be able to see a cloud there and the second one in a second there we go we have a second cloud they still don't look ideal but at the very least we have a start so with that we can work but first of all I want to draw the clouds always in the background and more importantly I want to draw them behind the horizon for that I have added a second for Loop and this is going to be quite similar so for sprite in self and if Sprite dot Z is equal to level layers and in here I only want to draw the clouds which means I can copy all of this and only draw the clouds and nothing else and then down here I want to draw all of the other layers except if Sprite dot Z is then I can copy this part here I hope the logic here makes sense basically we start by drawing all of the clouds then we are drawing The Horizon and then we are drawing all of the other elements or all the elements that are not a cloud that way we have the clouds behind the Horizon which I think looks a bit better with that we can minimize the camera group and now since the clouds are going to be behind the Horizon we have to give this one an offset which I want to be a random number so Rand inch which we don't have just yet besides choice I want to import rent int and the random integer here is going to be between 100 and 1000. if you want to create a really tall level you probably want to have a higher number or something more flexible but I'm fine with this one so let's try all of this run the entire thing and now we should be able to see something at some point but we don't I think one problem here could be that we just got really unlucky with the numbers let me change this to 100 to 200 so we're always going to see something let me try this again and now there I go there we can see a cloud and second cloud and the third cloud and so on so in the last part I just draw the clouds too high cool this is definitely looking pretty good what we now have to figure out is let me change this to a 500. next up we have to figure out this number here the X part and for this we have to figure out what the level limits are and since I only want to do this once this is going to happen inside of the init method before I'm doing all of the additional stuff I want to get the level limits and think of it like this if I have a level that has a couple of tiles here a couple of tiles here stuff here and so on I want to by default create some clouds inside of roughly this area here and later on when I create new clouds the clouds should come from this side here on top of that if a cloud goes too far to the left or rather exceeds the left side of the level I want to destroy that cloud and for all of that I have to know the size of my level for that I have put all of this inside of a separate dictionary that I called level limits in here I want to have a left side and I want to have a right side the left side is actually the easier part because this I always want to set at negative 500. the reason here is I know left or the left side of the level is always going to be at position 0. so I want to have this with some offset so the player can never see a cloud disappear the right side however is going to be a tiny bit more complicated the way I approached it is I looked at all of my terrain tiles and got the one with the highest number so the right side should be the right most terrain tile with an offset let's say plus 500 and this I think could be a good exercise for you try to figure out the width of the level and there are different ways to approach this but I think using the terrain tiles is the best one because be always going to use them so positively now and try to figure this one out in here I first of all want to get my grid and inside of there I have my terrain tiles since I only care about the position I only want to have the keys this I want to sort which means I can put all of this in the sorted method oh and I forgot I do want to turn all of this into a list and this list I want to sort for it sorting I am going to need a key or this one as always we need a function and let me pass in a position as the parameter here we always get a position with X and Y as a tuple I only care about X this is going to return a list with all of the terrain tiles sorted by the horizontal position I only care about the last one the one with the highest number on this one I only care about the X part and this is going to give me the rightmost tile and to this I want to add 500. I guess there's one limitation here and that is if the player doesn't place any terrain tiles we are going to get an error although I don't expect this to happen and this you could expand yourself I think at this stage the project is more or less done we just have to make some minor things but you can definitely expand this quite a bit but alright with that I have the level limits when I am creating all of the clouds I want to have my self dot level limits get the right side and to this I want to add a random number so my clouds look a bit more random let's go between 100 and 300. oh I can see the problem here I am adding an equal instead of a plus now let's try this again if I now draw some level and now the clouds should come all the way from the right and there we go this is feeling much better kind of hard to see but it's definitely working now there are two more things that we do have to do and by default the clouds I want to randomly scale up like we have done in the editor that we can do by writing surf is going to be Pi game dot transform dot scale to X and I want to scale up the surface but only if Rand in let's say between 0 and 5 is greater than 3. else I want to keep the surface as it is if I try this one now draw a new floor and now at some point we should see a cloud that's twice as big and I think the first one there or already looks pretty good also I do want to change this to negative 50 to 600 for the Y position that way you do have a chance to have a cloud right behind the Horizon Lines which looks pretty good cool so with that I can minimize the event Loop and one more thing that I do want to do is to create some clouds by default this I can I think I call this start up louds all the way in the beginning and the name still works and for this one I want to create a random amount so for cloud in let's say range 100. and this probably shouldn't be Cloud we can just call this I because I'm not going to use this number anyway and here I'm going to do a fairly similar thing compared to what I have done here and you could be more elegant by putting all of this inside of a separate function but in my case I'm not too concerned although that being said we do have to make some changes here because all of these clouds are supposed to come in from the right whereas all of these clouds are supposed to be randomly distributed across the level y can stay the same but 4X I want to have a random number so Rand int between the left side and the right side of the level which means I want to have self dot level limits and in here I only care about the left side and then for the right side I only care about the right side here that is pretty much all I need so at the end of additional stuff I want to have my start up clouds and let's see if this is working if I now create some terrain again and now we have potentially too many clouds so this number here where did I put startup clouds there this number here you probably want to scale along with the width of the level so if I set this to a 40 probably looks a lot better yeah this is definitely better so in here the longer a level is the more clouds you want but in my case I think this is a pretty good start with that being done there's one more thing that we do have to do and that is in these clouds if a cloud goes further than the left side limit I want to get rid of the cloud and for that every time I'm creating a cloud so let me once again minimize everything I am creating a cloud either in the event Loop or inside of startup clouds both times I want to pass one more argument in here and that is going to be self.level limits and then here I only care about the left side this inside of Sprites I can now work with because in here I have the let's call it left limit this I want to store into an attribute self Dodge left limit is going to be left limit and this I can now use inside of update to destroy the cloud if it goes further than this which means if self.rect.x is smaller or equal than self dot left limit and if that is the case I want to destroy this object and with that we should be limiting the amount of clouds that we have it's going to be kind of hard to see but I'm going to assume that if there's no major crash this is probably fine and here you can see the limit is probably a bit too low so if I jump it you can see clouds disappearing but an important thing here is that the left side of the map so this area here is going to be 0 and 0 and this point here roughly would be negative 500. that way we have a bit more control over the numbers here but well I guess what I can set for the left level limit let's set this one to negative 1000. or I guess to be even better here this could be negative the window width that probably makes the most sense so now let's try this again let's create a platform and now the player should not be able to see when things are ending and this is looking pretty good we can just see a bunch of clouds and everything else works just fine okay there we go with that we have finished up the clouds and with that we have finished up all of the visual parts of the game for the last section all we really have to do is to add the sound and then we are good to go this isn't going to be a major section so let's Jump Right In we are in the code editor and I want to start with the editor because this one is going to need some background music this I want to do inside of the init method and in here all the way at the bottom I want to have some music this I get with self dot editor music and this we get with pygame.mixer DOT sound with proper spelling here and the file path now is one folder up then audio and inside of there we have a file called explorer.ogg and this I want to play right away so self dot editor music dot play importantly here you want to set Loops to negative one so it plays forever on top of that before we are playing it I want to set the volume this I get with set volume and I set this one to 0.4 now you can hear some music so this one is working already the problem is now when I am switching to the level I want to switch off the music for the editor and play some music for the level the logic for that I can actually keep inside of the editor if I minimize the init method and look at my event Loop for this one whenever I'm calling this if statement here I also want to stop playing the music so self dot editor music dot stop like so and that way we are stopping the music once we go to a level let's try this one and there we go no more background music although now if I return we also don't have music playing again because we don't restart it this we can Now cover inside of main because in here inside of toggle I can check if self dot editor active and if that is the case self dot editor like so and editor underscore music and this I now want to play let's try it up on way back in the level there's no music and now if I return we got some music so this one is working now and this is all the music I'm going to add for the editor that's basically all we need with that I can close the editor we don't need it anymore next up for the level I want to have a couple of music files and those once again I'm going to import in main.pi so I'm only doing it once this is also going to happen inside of imports and in here I want to add some sounds all of this is going to be inside of one dictionary let me call it sounds let's call it level sounds and here we have a couple of different files the first one is going to be coin let me indent this and this I get with pygame DOT mixer dot sound and here once again one fold up then we have audio and then we have oin dot wav this I want to do three more times we now have hit besides that there is jump and finally there is the music these files are called Hit then we have jump and finally we have a file that is called super hero file ending being Ogg with that we have all of the level sounds these we now have to get into the level and this once again happens with all of this thing here I actually don't want to use the dictionary instead I want to have another entry and that is going to be self taught level sounds it's going to be kind of hard to read so let me put every entry here on a separate line with some proper indentation like so and this bracket here can go like this now this means for the level besides the asset dictionary we also need music all of those I do have to store in their separate variables so I'm going to add another entry sound and we have self dot BG music this one is going to be music actually I don't think music is good here let's call it audio and audio in here this I called music but this one like for the editor I want to add self.pg music dot set underscore volume once again this should be 0.4 and finally I can play the entire thing with loops being set to negative one that way this one's going to play Forever let's try all of this thank you and at the very least we do have music but now we have to make sure that this sound here also stops once we leave the level that we can also do quite easily inside of the event Loop when we are switching back to the level inside of here I want self.pg music to stop and since we are creating a new instance of the level this one is always going to start playing once we start the level and it's going to stop once we end the level so this is all we need for the background music next up we have to work on the coins and this part is quite easy because in here we do have access to the coins which means after I have the sounds I also want self.coin sound and this I get with audio and this entry I called coin so in here coin and now for every Sprite or every coin the players colliding with I want self.coin sound dot play this is supposed to only happen once though and just to test this let me not play the background music inside of the level that makes it a bit more noticeable there we go we have some coins and now if the pet touches them we get sound this one is working really well possibly a bit loud but that we can change simply by setting self dot coinsound dot set underscore volume to 0.3 it's something fairly subjective just play around with this that covers the next part so next up we have hit and we have jump it is going to be the easier one because we have a get damage method here and we can basically do the same thing we have done for the coin sound which means in here self dot hit sound is going to be audio and this one I called Hit and while we're here it's sound set volume with 0.3 and now every time the player is hit I want to play self dot hit sound dot play and we should be good to go let's try this one and I've only placed a single Spike and we get some sound that's working pretty good now I can minimize those two methods and this is all I need here the last bit we need is the jump sound for the player and this we can only do inside of build level because in here we are creating the player which means I want to pass in audio and this one I called jump so on here I want to pass in the jump sound this I guess I can now minimize the init method and for build level we need one more parameter and that is the jump sound this I also want to pass into the player all the way at the end we have the jump sound and now inside of Sprites when I am creating the player all the way here I have a jump sound this I can store all the way at the end with sound and self.jump sound is going to be the jump sound this I now just have to call and this I get inside of input because in here the player is pressing jump if that is the case I want self.jump sound dot play with that covered let's try and we have a very annoying jump sound this is definitely too loud right now which means inside of the Sprites once again I want to set self Dodge jump sound and set the volume to 0.2 possibly that is definitely a major Improvement but once again this is something you can play around with a lot and that is going to cover all of the sound that we are going to need I guess I can close level Sprites and settings and with that we have the entire game although I just realized if I reopen level I do want to play that background music now we are basically done with the entire project with all of that in place we can finish up the game and there isn't that much to do we only have to fix a couple of bucks and then we are done I think the best way to illustrate this is let me actually run the game and then here we have all the stuff we created so far and most of this is working just fine but if I play some tiles and some palm trees and now use the mouse wheel you can see that the mouse wheel doesn't work either horizontally or vertically so this we have to fix on top of that if I show my mouse clicking on the menu works just fine however if I click between the menu buttons like so the entire game crashes and we get a key error those are the two bugs I want to work on and both have them inside of the editor for this one I want to minimize everything and in here we have to work on menu click and Pen input and if you want to challenge yourself you should be able to fix both of them yourself quite easily the problems really aren't that big let's start with the menu because this one is game breaking the issue essentially is let me draw this actually we have our main menu rectangle and this is what we're getting from the menu inside of there we have a couple of boxes like so and they all return a number so for example for terrain and water this was two or three for the items I think it was four five or six and so on this is the value we are storing in self.selection index and this is then what we use to select an item to draw in the editor Works reasonably fine the issue is when the player clicks between the buttons this area here the return value is going to be none and none you cannot use for indexing which is why we're getting an error here which obviously isn't very good this is a very easy thing to fix though in my case I'm going to store the value we are getting from menu click this one here inside of a new variable that I called new index and this value I'm going to assign to the selection index but only if new index actually exists so if we have a value different from none if that is not the case I want to keep myself.selectionindex and with that I should be good to go let's try the game still runs I can still select everything inside of the menu and now if I click between the buttons nothing happens either left clicking or right clicking it all works just fine cool so we have fixed the first bug so now we can minimize the method and not worry about it again next up we have pan input in here the mouse wheel is covered in these lines of code the issue we have right here is we are updating the origin but we don't tell all of the Sprites to update as well you can see the issue down here we covered this a couple of hours ago when pen is active I want to change the origin and also update all of the Sprites this part here is what is missing inside of the mouse wheel and all I really have to do after we are covering all of this I want to add a for Loop so for sprite in self dot canvas objects the same thing we have done down here as a matter of fact I want to copy all of this and paste it in here that should be all we need let's try I can place some elements doesn't really matter what it is but let's try a few different ones just to be sure there we go and now if I use the mouse wheel this works in both axes so with that we have fixed another bug and with that I think the entire game is basically ready to go so I hope you enjoyed this video and I'll see you around
