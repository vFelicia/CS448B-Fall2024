With timestamps:

00:00 - in this tutorial we talk about objects
00:02 - and classes
00:04 - and well more specifically i will talk
00:06 - about what objects and classes are i
00:08 - will cover how to create and use them we
00:11 - will cover dunder methods and also
00:13 - simple and complex inheritance
00:15 - and finally i will cover how to use
00:17 - classes in practice and well let's get
00:20 - started by talking about what objects
00:22 - are in the first place
00:24 - and well an object is just a container
00:27 - for variables and function
00:30 - for example
00:31 - we could make a video game with lots of
00:33 - monsters
00:34 - and i think video games are really good
00:36 - way to explain objects so i will stick
00:39 - with that for this entire video
00:42 - but basically for the monster we are
00:44 - going to create we want to have
00:45 - variables and functions
00:47 - and in this case i want a monster to
00:49 - have some health some energy stamina and
00:52 - damage and you could add whatever else
00:54 - you want in here it's really up to you
00:56 - and then besides that the monster should
00:59 - also be able to attack to move to
01:01 - animate and again you could add whatever
01:03 - else you want in here
01:06 - and what you have to understand here is
01:08 - that these variables and functions
01:10 - only exist inside of this monster object
01:15 - it's very similar compared to the local
01:17 - scope of a function if we tried to get
01:20 - this health outside of the container it
01:23 - wouldn't exist because this health
01:25 - exists only inside of monster object
01:28 - although in terms of naming there's one
01:30 - minor complication and that is special
01:33 - names
01:34 - all that really means is that variables
01:37 - inside of an object are called
01:38 - attributes and functions in an object
01:40 - are called methods
01:42 - and that is more or less the only
01:44 - difference
01:46 - the only reason why this exists is so
01:48 - that we are a bit more specific with our
01:50 - language
01:52 - for example when you talk about health
01:54 - with somebody else for your game you
01:57 - really want to emphasize that you don't
01:58 - talk about a global variable
02:00 - you talk about the specific attribute of
02:02 - one object
02:04 - and one more thing methods
02:06 - should actually be familiar to you
02:08 - because you are using methods very very
02:11 - often in python anyway for example when
02:13 - you call the upper method on any kind of
02:15 - string you are turning every letter
02:17 - inside of that string to an uppercase
02:19 - letter and that is also a method
02:23 - and that is the same kind of method we
02:25 - are seeing here essentially a string in
02:28 - python is just another object with
02:30 - functions inside of it
02:32 - or methods to be more specific this also
02:35 - applies to integers floating point
02:37 - numbers booleans all of that stuff is
02:39 - basically just other kinds of objects
02:41 - that python creates but that's something
02:44 - we don't have to worry about for now
02:47 - now another thing that is really
02:49 - important to understand is that it is
02:51 - possible to have multiple objects for
02:53 - example i could create three different
02:55 - monsters
02:57 - and each of these monsters could have
02:59 - customized attributes
03:02 - these
03:03 - red
03:05 - pieces of text here
03:07 - so my first monster has 90 health 20
03:09 - energy the next monster has 60 and 40
03:12 - and the final monster has 40 and 10.
03:15 - so when you create an object you can
03:18 - give it custom attributes
03:20 - however this does not apply to methods
03:24 - and as you can see here monster 1
03:26 - monster 2 and monster 3 all have the
03:29 - same methods
03:32 - and these can be customized to an extent
03:35 - but not nearly as much as the attributes
03:37 - that's something you do want to keep in
03:38 - mind
03:39 - but still each object has its own
03:42 - attributes and methods
03:45 - meaning that this attack here and this
03:48 - attack are not the same function or well
03:51 - the same method
03:53 - they always apply to their respective
03:55 - object
03:57 - and what you can also do is have objects
03:59 - interact with each other
04:01 - for example
04:03 - if
04:04 - monster3
04:05 - attacks
04:07 - one stat 2
04:08 - we could run some code to reduce the
04:10 - health of monster 2 from 60 to let's say
04:13 - 20.
04:15 - and that actually brings us to a really
04:17 - important topic and that is object
04:20 - oriented programming or oop in short
04:24 - and all that really means is that you
04:26 - are organizing your code via different
04:28 - objects
04:29 - and then you make these objects interact
04:31 - with each other
04:33 - and this approach is basically how
04:35 - almost all large projects are made in
04:38 - any programming language or at the very
04:40 - least any modern programming language
04:42 - meaning if you don't understand classes
04:44 - you will be very much lost and well you
04:47 - will have no idea what you see when you
04:48 - look at larger examples of code
04:51 - here we have a couple more objects
04:54 - we still have monster 1 and monster 2
04:56 - but now we also have a player we have an
04:59 - obstacle and we have a menu
05:02 - and all of these have slightly different
05:04 - attributes and slightly different
05:06 - methods
05:07 - and just to talk about how these
05:09 - different objects can interact with each
05:11 - other the one we have already seen is
05:13 - that monster 2 could for example attack
05:16 - monster 1 and then monster 1's health
05:19 - be reduced from 90 to 60.
05:22 - and if monster 2 is attacking
05:25 - it might reduce its own energy from 40
05:29 - to 20.
05:30 - so attacking isn't free for the monster
05:33 - what we can also do
05:35 - is have an object without any methods
05:38 - like the obstacle here and all the
05:40 - obstacle is is well an object with a
05:43 - position and a size
05:46 - and this we could use for example with
05:48 - the move method of any of the other
05:50 - classes
05:53 - so the player and the monsters
05:55 - all have a move method and this could
05:57 - interact with the obstacle
06:00 - and let me clean this up something even
06:02 - more interesting if you look at the
06:04 - player this one here and the menu
06:07 - those two do look very much connected
06:11 - because the player has one method called
06:14 - menu
06:15 - and what this one would do
06:17 - is to create or at the very least open a
06:20 - menu
06:21 - and then when we create the menu we are
06:24 - passing in the player itself so this
06:27 - player here
06:29 - is going to be passed in as one
06:31 - attribute of the menu object and this is
06:34 - totally fine to do you can totally add a
06:37 - function or an object inside of another
06:40 - object as an attribute
06:42 - and then
06:43 - this select could for example change
06:47 - the weapon of the player and we could
06:50 - close the menu as well
06:52 - and i hope this makes sense the main
06:54 - thing you have to understand is that
06:56 - objects can interact with each other
06:59 - and this is how you want to organize
07:01 - code it makes it very easy to work with
07:04 - and especially for larger bits of code
07:07 - this approach is essentially mandatory
07:10 - or at the very least it's the easiest
07:12 - way to organize it
07:13 - and let's actually do a practical
07:15 - example
07:16 - here is a zelda-like game that i made a
07:19 - while ago and basically everything you
07:21 - see on the screen is an object
07:24 - for example right in the middle we have
07:27 - the player and that's one object
07:29 - then we also have this raccoon here and
07:31 - this spirit and each of those are one
07:34 - object
07:36 - and beyond that each of these flames
07:39 - here is its own object
07:41 - and these are only created when the
07:44 - player is attacking with some magic
07:46 - and finally in the top left
07:50 - the
07:51 - bottom left and the bottom right
07:54 - you can see some ui elements
07:56 - and they are all part of the same object
08:00 - and this object is very much related to
08:02 - the player so those two work together
08:05 - very closely
08:07 - and besides that each of these pillars
08:10 - and trees and rocks and statues they are
08:14 - all objects that i created just for this
08:17 - game
08:18 - so i hope that illustrates how useful
08:20 - objects are that make it really easy to
08:22 - group together code chunks that should
08:25 - belong together
08:27 - and for a bit more detail the raccoon
08:29 - for example has three attributes health
08:31 - speed and damage and the methods attack
08:34 - and move
08:35 - and all the other objects would have
08:37 - similar attributes and methods
08:41 - and with that we have objects now the
08:44 - next question is what are classes
08:47 - and this is fairly easy to explain as
08:50 - well the class is basically a blueprint
08:52 - for an object
08:54 - meaning whenever we create an object we
08:56 - first have to create a class
08:59 - and a class can also accept arguments to
09:01 - customize the object we are creating
09:04 - for example this would be a class we
09:07 - have a class and this class has two
09:10 - attributes health and energy and right
09:13 - now the value for both of these is not
09:15 - being set
09:17 - this we do when we actually use this
09:19 - class to create an object
09:21 - but this class also has two methods
09:24 - attack and move and those do not change
09:27 - and basically what we're doing
09:30 - is use this class to create the object
09:33 - and in the process
09:35 - we are giving it the specific values for
09:38 - health and energy so in this case the
09:41 - monster is going to have 90 health and
09:43 - 20 energy
09:44 - and this process we could do as many
09:46 - times as we want for example earlier you
09:49 - have seen monster 1 we had monster 2
09:51 - monster 3 and we could continue with
09:54 - monster 4 5
09:56 - up to an unlimited number of monsters
10:00 - and that is essentially the main idea
10:02 - all you really have to understand is
10:04 - that we always need a class to create an
10:06 - object
10:08 - now what we can also do with classes is
10:10 - that one class can inherit from another
10:13 - class and the resulting objects will
10:15 - have attributes and methods from both
10:17 - classes
10:19 - for example
10:20 - let's say we want to create a shark
10:23 - class and this one right now only has
10:25 - speed for the attribute and byte for the
10:27 - method
10:29 - and this class will be fairly limited
10:31 - because we well don't have any attribute
10:34 - for health or for energy and we also
10:36 - don't have any kind of method for move
10:38 - or attack
10:40 - but we don't need to because what we can
10:42 - do is have this shark class inherit from
10:45 - the monster class
10:47 - and this means
10:48 - this shark is going to get the health
10:51 - and the energy
10:53 - from the monster parent class and that
10:56 - is also going to get the attack and the
10:58 - move
10:59 - from this class as well
11:02 - meaning when we actually use the shark
11:04 - class to create a shark object we are
11:07 - going to get health energy and speed for
11:09 - the attributes and attack move and byte
11:12 - for the methods
11:14 - and i think i should use better colors
11:16 - here
11:18 - in the shark class health and energy
11:22 - are coming from the monster class
11:25 - same with attack and move
11:28 - those two are coming from the monster
11:31 - class
11:33 - and then speed and
11:36 - byte
11:39 - are from the shark class
11:43 - and this would allow us to reuse code
11:45 - quite extensively for example we could
11:48 - have a lot of different monsters we
11:51 - could have a shark some flying enemies
11:54 - some armored enemies lots more and they
11:56 - all inherit from this one monster class
12:00 - and with this approach
12:02 - we would save a ton of writing in terms
12:04 - of code and on top of that if we change
12:07 - the move method for example it would
12:10 - affect every single other class as well
12:13 - which is very useful if you want to make
12:16 - some changes and make it affect every
12:18 - single other class
12:20 - and especially with larger projects this
12:23 - is just about the only way to manage
12:25 - them
12:26 - and let's do an example again
12:29 - here is the screenshot from earlier and
12:31 - we have a monster class we have another
12:33 - monster class and those two have the
12:36 - same attributes and methods although
12:38 - with different values
12:39 - and besides that we also have the player
12:43 - and what is really important to
12:44 - understand here is that all of these
12:46 - inherit from the entity parent class
12:50 - and this for example contains the method
12:52 - for movement
12:54 - because all of the monsters and the
12:56 - player move in the same way so they
12:59 - could share this method quite easily
13:03 - and just to emphasize it i do want to go
13:05 - over the advantages of classes and
13:07 - objects
13:08 - and the first point here is that classes
13:11 - and objects help you organize complex
13:13 - code
13:14 - and the second point is related classes
13:17 - and objects also help you to create a
13:19 - reusable code
13:20 - and just from these two points i hope it
13:23 - becomes obvious that if you want to
13:25 - create some really large projects let's
13:28 - say a really good looking game you need
13:30 - objects and classes without them it's
13:33 - still possible
13:34 - but significantly more difficult
13:37 - besides that
13:39 - classes are also used everywhere
13:42 - meaning if you don't understand them you
13:45 - will be very much lost
13:47 - as a matter of fact in python there are
13:50 - quite a few modules that require you to
13:53 - use classes
13:55 - for example pygame tkinter and
13:58 - matplotlib respectively the module you
14:00 - use for games for gui's and for data
14:02 - analysis they all work with classes
14:05 - primarily
14:06 - so if you don't know how to use it you
14:09 - pretty much cannot use these modules or
14:11 - at least you could only use a very small
14:13 - part of them
14:14 - and there's one more point that i
14:16 - haven't mentioned yet
14:18 - and that is that classes make it much
14:20 - easier to work with scope
14:22 - i will talk about this in more detail
14:24 - later
14:25 - but if you struggled so far with getting
14:27 - information in and outside of functions
14:30 - you will really like classes that make
14:32 - it very easy to work with different
14:33 - levels of scope
14:35 - so these are the arguments where you
14:37 - would want to use classes and objects
14:39 - however
14:40 - you can write code without using objects
14:43 - at all and this is very common
14:45 - especially for beginners and let me
14:48 - illustrate the problem here
14:50 - the yellow line is the need for classes
14:54 - and especially when you start writing
14:55 - code let's say you are somewhere here
14:58 - and your average program is something
15:00 - like 50 lines of code
15:03 - in this case there really isn't any need
15:05 - for classes because well your code is
15:07 - very simple and there isn't any need to
15:09 - organize complexity
15:11 - however the longer and more complex your
15:14 - code is becoming the more you will need
15:17 - classes
15:18 - and this ramps up really really fast
15:22 - but as long as you are in this area here
15:26 - it well it's very tempting to never use
15:29 - a class and ignore them entirely and
15:31 - this especially as a beginner you really
15:34 - want to avoid
15:35 - so even though when you are here
15:38 - i would really recommend you to use
15:40 - classes even though it's not strictly
15:42 - necessary in your example just to
15:44 - practice for more complex code because
15:47 - when you are an actual software
15:48 - developer you are never going to write
15:50 - just 50 lines of code most of the
15:52 - programs you are going to work are
15:54 - somewhere here with a few thousand lines
15:57 - of code let's say 2000
16:00 - and if you are up here and you don't use
16:02 - classes
16:03 - you are going to be in a lot of trouble
16:07 - all right with that we have the theory
16:09 - of objects and classes
16:12 - and for the next part
16:15 - we are actually going to create and use
16:17 - objects
16:19 - so let's have a look at some code
16:23 - here i have a completely empty sheet of
16:25 - code and the first way i want to do is
16:27 - to create a class and this you do with
16:30 - class and then the name of the class
16:33 - in my case i want to go with monster
16:36 - and here already we have to cover
16:38 - something important and that is the
16:40 - naming scheme
16:42 - so far in python what you probably have
16:45 - written is something like monster
16:48 - and generally you always used the snake
16:51 - case styling for any kind of text
16:54 - so why is this different here
16:58 - and well in python by convention last
17:01 - names are always written in the camel
17:03 - case
17:04 - so camelcase looks like this where you
17:08 - don't have any spaces between words or
17:10 - well any underscores but any word starts
17:13 - with an uppercase letter
17:16 - and this is different from normal python
17:18 - where variables are written in snake
17:20 - case
17:21 - where everything is lowercase and a
17:23 - space is an underscore
17:25 - and this isn't strictly necessary you
17:28 - can call a class
17:29 - monster with a lowercase m just fine
17:32 - this is purely convention
17:35 - but all the other python requirements
17:37 - for naming still apply for example a
17:40 - class couldn't start with a number
17:43 - and we also couldn't have a space in
17:45 - between
17:46 - so we don't have to learn any new naming
17:48 - scheme now next up what you have to do
17:50 - is a colon
17:52 - and now in here we can work on the
17:55 - attributes and methods of our class
17:57 - and for now i just want to create some
17:59 - basic attributes
18:01 - let's say i want to give this monster
18:03 - some health and for now i want to have
18:05 - specific numbers let's say 90
18:08 - i want to have energy and this one
18:10 - should be 40.
18:12 - so now we have a class
18:15 - and what we have to do now is turn this
18:17 - class into an object
18:20 - and this we do by typing the name of the
18:22 - class and then calling it by using
18:24 - brackets
18:25 - again very similar compared to functions
18:29 - and this is going to return the object
18:32 - so we have to capture that in a variable
18:35 - and this very often
18:37 - is written like this
18:39 - and here i hope you can see why we have
18:42 - the different naming schemes
18:44 - to python
18:46 - this name here and this name here are
18:48 - two completely different things because
18:50 - one starts with a lowercase the other
18:52 - with an upper case
18:54 - although to us as the programmer we can
18:57 - tell that those two are related because
19:00 - they basically have the same name
19:02 - and for that reason we are usually
19:04 - writing class names in camel case and
19:07 - variable names in snake case it makes it
19:10 - very easy to connect these two and
19:12 - clearly indicate that they are connected
19:14 - although you don't have to do any of
19:16 - this you could totally call this i don't
19:18 - know hamster
19:20 - and this could be
19:22 - lowercase it's totally fine all of this
19:25 - is just convention
19:27 - although you should follow conventions
19:29 - they are there for a reason
19:31 - but i can run the code now and i am not
19:33 - getting an error that's a good sign
19:36 - and now what i can do i can use print
19:39 - and
19:40 - monster
19:41 - dot let's say health
19:44 - and now if i run this we are getting 90.
19:47 - and this knight here is coming from this
19:51 - health
19:53 - and the same would also work for energy
19:56 - in just the same way so we get 90 and
19:58 - 40.
20:00 - now just to emphasize that both this
20:02 - health and this energy only exist inside
20:05 - of this class let me print
20:08 - health by itself that is horrible
20:11 - spelling health
20:13 - and if i run this python is going to
20:15 - give me an error and we have name health
20:18 - is not defined
20:20 - meaning python
20:22 - cannot find this health anywhere in the
20:25 - global scope which makes sense because
20:27 - there is no health in the global scope
20:29 - we only have health in the scope of this
20:32 - monster class and let me add
20:36 - some comments here to make this a bit
20:37 - more readable
20:39 - we have attributes and besides that i
20:41 - also want to create methods
20:43 - and those work kind of like functions we
20:46 - again need the define keyword or def
20:50 - and now we need a name for our function
20:53 - and for that we have the exact same
20:55 - naming scheme for normal functions
20:58 - for example attack would be a perfectly
21:00 - fine name and after that you need a
21:03 - colon and then let's say for this attack
21:07 - method i want to keep it simple and just
21:09 - print
21:10 - the monster has
21:12 - attacked
21:14 - and now i can call monster.attack
21:18 - and don't forget the brackets and now if
21:20 - i run this
21:22 - we are getting an error
21:24 - and this error says
21:27 - that monster.attack takes zero position
21:30 - arguments but one was given and this is
21:34 - probably very confusing because when we
21:37 - called this method here we didn't pass
21:40 - anything inside of it
21:42 - and the method itself doesn't have any
21:45 - parameters so why is python being so
21:49 - weird here
21:51 - now the reason why this is happening is
21:54 - that whenever we call a method so a
21:56 - function inside of a class
21:59 - what is going to happen
22:01 - is that python automatically passes a
22:04 - reference to the class as the first
22:06 - argument
22:07 - into
22:09 - this function or this method to be more
22:11 - specific
22:12 - in this first argument we always have to
22:14 - capture with some kind of parameter
22:18 - meaning a method always needs at very
22:21 - least one parameter and that parameter
22:23 - is a reference to the class itself
22:27 - for example i could just write monster
22:29 - in here
22:30 - and if i run this now we get the monster
22:33 - has attacked
22:36 - and let me just print what we actually
22:38 - get so i want to print the monster we
22:41 - get as an argument in here
22:44 - and what we get is main monster object
22:47 - at somewhere in our memory
22:50 - and well in my case i don't really care
22:53 - about this monster so let me remove the
22:55 - print statement but i do have to keep
22:58 - this first parameter
23:00 - however once we have the first parameter
23:03 - i can add as many custom parameters as i
23:06 - want
23:07 - for example i could add the amount of
23:10 - damage here
23:13 - and i could let's say print the amount
23:16 - with an f string
23:17 - and i want to say
23:21 - the amount
23:24 - of damage was
23:26 - dealt
23:28 - and now when i call this method down
23:30 - here i can pass in any number i want
23:33 - and i get the monster as attacked 40 of
23:36 - damage was dealt that does not make
23:38 - sense in terms of grammar let's try this
23:40 - again but the damage was stilled that
23:42 - feels much better
23:44 - so the one thing you want to remember is
23:47 - that for any kind of method you always
23:50 - need a reference to the actual class as
23:53 - the first parameter
23:54 - but after that you don't have to worry
23:56 - about it anymore and you just use it
23:58 - like any other function
24:01 - however you could also use this
24:03 - reference to the class
24:05 - what you could be doing for example is
24:07 - print
24:09 - and let me just print monster.energy
24:14 - if i now print this i get 40 again
24:18 - meaning this monster energy here
24:21 - is looking at the first argument it gets
24:24 - and this is a reference to the class
24:26 - itself so from there we can get this
24:28 - energy and also this health if you
24:31 - really wanted to
24:33 - and what you could also do
24:35 - is increase this amount
24:39 - so monster.energy
24:42 - minus equal 20 and if i print it now we
24:45 - get 20.
24:47 - and i hope you can tell how useful this
24:50 - can be because if you imagine that this
24:52 - monster here is the global scope and
24:55 - these attributes are global variables
24:59 - if this attack was just a normal
25:01 - function then this
25:03 - would not work
25:06 - because you would be creating a local
25:08 - variable that wouldn't work with the
25:09 - global ones
25:11 - but because of this first argument that
25:14 - the method always gets
25:16 - we can influence variables or well
25:18 - attributes outside of this function
25:21 - which is incredibly useful
25:24 - so i hope this kind of method here makes
25:27 - sense
25:28 - as a matter of fact let's practice this
25:31 - one i want you guys to create another
25:33 - method for this monster and this one
25:35 - should be called move
25:37 - and it should accept one arguments
25:39 - besides the reference to the class
25:41 - itself
25:42 - and that is the speed of the movement
25:44 - and then inside of the method you should
25:46 - just print that the monster has moved at
25:49 - a certain speed it doesn't really matter
25:51 - what you put in here as long as it is
25:53 - working
25:54 - so try to figure this one out yourself
26:00 - all right let's try together now i want
26:03 - to create a method called move
26:06 - and in here i want to have speed as a
26:08 - parameter however what we have learned
26:11 - from the attack method is that we always
26:13 - need a reference to the class itself as
26:16 - the first parameter
26:19 - meaning
26:20 - the first parameter here should be
26:22 - something for the monster
26:24 - and it really doesn't matter what you
26:26 - call it
26:27 - so i could even write something in here
26:30 - it would still work
26:32 - and now in here i can print
26:35 - monster has moved
26:39 - and let me add another line with an f
26:43 - string
26:46 - that says it has a speed of
26:50 - and then
26:51 - the speed
26:53 - and let me fix the typo
26:55 - and now i can call monster dot move
26:59 - and add let's say a 10 in here and let
27:02 - me comment out monster.attack
27:04 - and let's see what we get
27:06 - the monster has moved it has a speed of
27:09 - 10.
27:10 - so all of this seems to be working just
27:13 - fine
27:14 - so all of this seems to be working very
27:16 - nicely
27:18 - now obviously calling this first
27:20 - parameter something is a bit confusing
27:24 - and as a consequence in python there is
27:27 - a convention that this first parameter
27:29 - is always called self
27:32 - and this applies to all of the methods
27:35 - meaning this is what you are going to
27:37 - see most of the time and what i am going
27:39 - to use as well
27:41 - you don't have to do it but i think it
27:43 - makes the most sense
27:46 - although i do want to emphasize that
27:48 - this parameter here and this parameter
27:50 - here have no relation whatsoever they
27:54 - are entirely separate
27:56 - although that being said they both
27:58 - reference this monster class here but it
28:02 - is totally fine to call self here and
28:05 - self here the names are not in conflict
28:07 - with each other
28:09 - and all right with that we have the very
28:14 - basics of using classes and objects
28:17 - although right now we do have a problem
28:20 - that our monster always has the same
28:22 - health and the same energy
28:24 - so even if we created multiple monsters
28:27 - so what i could be doing is monster 1
28:31 - monster 2 monster 3
28:34 - and let me get rid of this one here
28:38 - all of these monsters would have the
28:40 - same amount of health and the same
28:41 - amount of energy
28:43 - and they all have the same attack and
28:45 - move method
28:46 - which is fine to an extent but i do want
28:49 - them to have different amounts of health
28:51 - and different amounts of energy
28:53 - and to implement that we need another
28:55 - concept and that is called dunder
28:57 - methods so let's talk about that one
29:01 - let's talk about dunder methods and the
29:04 - dunder here just stands for double
29:07 - underscore meaning we are talking about
29:10 - a double underscore at the beginning
29:12 - and at the end of the method
29:14 - but it's important here we are still
29:17 - talking just about methods
29:20 - so essentially we are calling a specific
29:23 - kind of function
29:25 - and let's talk about why it's special
29:28 - a dunder method is just another method
29:31 - the thing that makes it special is that
29:34 - it is not called by the user instead it
29:36 - is called by python when something else
29:38 - is happening for example there is the
29:41 - dunder edit method and this one is
29:44 - called when the object is being created
29:46 - another example is the lan method and
29:48 - this one is called when the object is
29:50 - passed into the len function
29:53 - and besides that we also have done the
29:55 - apps and this one is called when we are
29:56 - passing the object into the apps
29:58 - function
29:59 - and that is really the entire idea it
30:03 - honestly isn't that complicated the most
30:06 - important dunder method you have to
30:07 - understand is done their init
30:09 - this one you are going to be calling all
30:12 - the time
30:13 - but let's actually do all of this in
30:15 - code that should make the most sense
30:18 - all right here we have the class i
30:20 - created earlier and what we have seen
30:23 - earlier as well i can create monster 1
30:27 - and that is just going to be the monster
30:30 - and i can also have monster 2
30:34 - and if i now print
30:36 - monster 1
30:38 - dot health
30:40 - and monster 2 dot health
30:43 - we get the same number
30:45 - because we always set health to 90.
30:47 - there's no way to customize it and
30:50 - basically what i want to do is as soon
30:52 - as the class is being created then i
30:54 - want to create these different
30:56 - attributes
30:57 - and instead what i want to do is when
31:00 - this class is being created i want to
31:03 - create this health and this energy with
31:05 - custom values
31:07 - and for that to work
31:09 - we need to define a dunder method and
31:12 - the one we need is called dunder init
31:15 - and this is just going to be another
31:18 - method like attack and move we are just
31:21 - calling a method meaning the first
31:23 - parameter here has to be a reference to
31:25 - the class itself
31:27 - and for now let me just print
31:30 - the monster was created
31:34 - and do pay attention i am never calling
31:37 - the init method myself but if i run this
31:40 - we get the monster was created the
31:42 - monster was created and then 90 and 90.
31:46 - and what that means if i minimize this a
31:49 - bit
31:50 - every time we are creating a monster so
31:52 - first here
31:54 - and then here
31:56 - then we are calling this dunder method
32:00 - and this standard method we can also
32:02 - give some parameters
32:03 - for example we could specify in here the
32:06 - amount of health and the amount of
32:08 - energy we want
32:10 - and well i hope you can see where this
32:12 - is going basically what we can do now is
32:16 - we can set self.health
32:19 - to whatever health parameter we pass in
32:21 - and we can do the same thing for energy
32:25 - and the names here might be a bit
32:26 - confusing so let me add a bit of white
32:28 - space and explain
32:31 - this self.health here
32:33 - is referring to
32:35 - this self.health of the monster class
32:38 - whereas this health here refers
32:42 - to this parameter
32:44 - and the important point here is self
32:47 - because this one specifies where health
32:49 - belongs to
32:50 - i hope this makes sense this is
32:52 - something you see fairly often
32:54 - let me remove the white space again
32:57 - and now when i am calling the monster
33:00 - i can either pass in arguments or named
33:02 - arguments
33:04 - let's say for the first monster i want
33:06 - health 10 and energy 20
33:09 - and for the second monster i could
33:11 - specify health being 50
33:15 - and energy being 100.
33:19 - now if i run all of this
33:21 - we get monster 1 health is 10
33:24 - and monster 2 health is 50.
33:28 - and this 10 here refers to this 10 and
33:31 - this 50 is referring to this 50 here
33:36 - meaning now we can have custom
33:39 - attributes
33:40 - and what is even better
33:42 - since
33:43 - this self
33:44 - is a reference to the class itself we
33:47 - can just create the attribute in here
33:49 - which means we don't need those lines at
33:52 - all it would still work without them
33:55 - if i run this now this is still working
33:59 - just fine
34:01 - and this is what you see most of the
34:04 - time where the class by itself doesn't
34:07 - have any attributes we only create
34:09 - attributes when we are creating the
34:11 - class with the init method or the done
34:13 - there in it method
34:15 - and then instead of the other methods we
34:17 - are calling self all the time to refer
34:19 - to the class and i just realized this
34:22 - should be
34:23 - self instead of monster
34:25 - so we're capturing this self here
34:29 - and what you are going to notice is that
34:31 - you are going to write self all the time
34:34 - it is a little bit annoying but
34:36 - well it is manageable
34:38 - and well with that we have the first
34:41 - init method
34:43 - but there are quite a few more although
34:45 - those you wouldn't use that often and
34:48 - just to keep things simple let me get
34:50 - rid of monster 2
34:54 - and i don't want to print
34:56 - anything at all
34:59 - another danda method i talked about in
35:01 - the introduction
35:02 - is len
35:05 - and this one
35:06 - needs self and no other parameters
35:09 - and in here we just want to return
35:12 - something
35:13 - let me return
35:15 - the number five
35:18 - and what this one is going to do
35:21 - is if i call len and pass in monster one
35:26 - in there and this len just as a quick
35:29 - recap
35:30 - if i pass in any kind of string into len
35:34 - let's say test
35:36 - and if i print the result
35:40 - i get 4
35:42 - or the number of characters inside of
35:44 - the string
35:46 - i guess i could also pass a list in here
35:48 - that might make a bit more sense
35:51 - so i have a list with five entries and
35:53 - the length of it is five
35:56 - but what i can do now if my monster has
35:58 - a len method i can pass monster 1 in
36:01 - here
36:02 - and it would return 5 as well
36:05 - and any number that is being returned
36:07 - here
36:09 - is going to be passed into the length
36:10 - function
36:12 - and i guess for something slightly more
36:14 - relevant
36:15 - instead of returning a number
36:18 - i could return self.health
36:22 - and now if i run this i'm getting 10 or
36:24 - the amount of health my character has
36:26 - which is 10 right now
36:29 - and another example we have seen in the
36:32 - introduction that works in the same way
36:34 - is abs and we need dunder on both sides
36:38 - and in here self and again i have to
36:41 - return something so return
36:44 - and for this case let's say self.energy
36:48 - and if i copy this and pass it into
36:51 - absolute
36:52 - i get 20.
36:54 - now usually absolute is if you have a
36:57 - negative number
36:59 - and you want to make sure it's always
37:00 - positive that's what it does
37:03 - but well you could theoretically do
37:05 - whatever you want with it
37:08 - now what you can also do
37:10 - is one specific function in python and
37:13 - that is called dir short for directory i
37:17 - think or directory listing or something
37:19 - like that
37:20 - basically what it does you pass in
37:23 - an object
37:24 - and then you want to print
37:26 - the result
37:28 - and what you get from that
37:31 - is all of the dunder methods and at the
37:34 - end
37:35 - the attributes and the normal methods
37:39 - and in here you can see
37:41 - a lot of stuff actually
37:43 - and what you have to understand here is
37:45 - every time we are creating an object
37:47 - python already gives it some dunder
37:50 - methods for example here we can see the
37:53 - dir method and this one is necessary for
37:56 - the ear function to work
37:59 - it kind of works like the len method the
38:01 - one we have created ourselves or the abs
38:04 - function
38:06 - and i guess the one we have just created
38:08 - is the init method this is the really
38:11 - important one
38:12 - and most of those you really don't want
38:15 - to worry about because well they're just
38:17 - there to make the class work but we
38:19 - don't really have to worry about them
38:22 - although some dunder methods in here can
38:24 - be very useful
38:26 - for example dunder digt
38:29 - is well it's kind of a dictionary but
38:31 - not in the way you would expect
38:33 - basically how you would use that one
38:36 - let me print it right after the monster
38:41 - i want to print monster 1 and then dot
38:45 - dander
38:46 - dict
38:47 - and in here this is the one exception
38:49 - where this is not a method this is just
38:52 - an attribute so no brackets afterwards
38:55 - and this one gives us all of the
38:56 - attributes of the method inside of one
38:59 - dictionary
39:01 - can be quite useful sometimes although
39:03 - you wouldn't be using it too often
39:06 - now another way to get to this dict here
39:08 - is to let me duplicate the entire line
39:11 - you can call the varus function and pass
39:14 - in monster1
39:16 - and this one is giving us the very same
39:19 - thing
39:20 - although i have hardly ever used either
39:23 - of these most of the time you just don't
39:25 - need them
39:28 - with that you should understand dunder
39:29 - methods reasonably well
39:31 - now there are quite a few dunder methods
39:34 - that get a bit more advanced i only
39:37 - covered the really fundamental one some
39:39 - other examples of thunder methods is for
39:42 - example dunder call
39:45 - and in here we only need one parameter
39:48 - self
39:49 - and in here we can return something else
39:53 - again
39:55 - and let me distribute dunder on both
39:56 - sides
39:58 - let's say the monster was called
40:01 - and what this dunder call does
40:04 - is it essentially turns our object into
40:07 - a function
40:08 - meaning i can call monster 1 and then
40:11 - add brackets afterwards and if i do that
40:15 - we are not getting anything because i
40:17 - would have to print what i get
40:19 - so i have to put brackets around it and
40:21 - call print and now the monster was
40:24 - called
40:26 - i guess a cleaner way of doing this is
40:29 - to return
40:31 - nothing and just
40:34 - print
40:35 - this string
40:36 - so now if i call monster1
40:39 - we get the monster was called and
40:41 - nothing is being returned
40:44 - and when you create a function in python
40:48 - it basically behind the scenes creates
40:50 - an object with this standard method here
40:54 - and this we can just create ourselves it
40:56 - really isn't that complicated
40:58 - and what we can also do is to add and
41:00 - subtract numbers
41:02 - and this you would for example do
41:04 - with dunder at
41:07 - and in here you need two parameters
41:09 - first of all self as always and then you
41:11 - need some other number
41:14 - and what you can do in here is return
41:17 - something
41:18 - let's say i want to self.health
41:22 - and then plus whatever other number i
41:24 - get
41:25 - and now that i have that
41:28 - i can
41:30 - print
41:31 - monster 1
41:33 - last
41:34 - pen
41:35 - and if i run it i get 20
41:39 - which is if i find it
41:41 - so the health of my monster is 10 and i
41:44 - add 10 towards it so i get 20.
41:47 - and i guess to make this a bit more
41:49 - understandable let's add 55 in here
41:52 - and i get 65 which is 10 plus 55
41:58 - and well that is a couple more dunder
42:01 - methods
42:02 - they can be incredibly useful although
42:05 - most of the time you are only going to
42:07 - use thunder init this is the one you
42:09 - absolutely have to understand
42:12 - but i guess they don't really get that
42:13 - much more complicated so it shouldn't be
42:15 - too hard
42:17 - alright now for the challenge for this
42:19 - part i want you guys to do some research
42:22 - because there's another dunder method
42:24 - that is called str
42:27 - and i want you guys to look up online
42:30 - what it does and how to use it in code
42:37 - all right here we are in the official
42:40 - python documentation and there you can
42:42 - see dunder string or dunder str
42:46 - and basically what it does it's called
42:48 - by the str object built in function
42:50 - format and print to compute the informal
42:53 - or nicely printable string presentation
42:55 - of the object
42:57 - basically what it means is that this
42:58 - object is going to return some text so
43:01 - let's have a look at it
43:03 - here we are back in the code and i only
43:06 - need one parameter and that is self
43:09 - and now i have to return some kind of
43:11 - string
43:12 - and the string i want for this one let's
43:14 - say a monster
43:17 - and what i can do with that let me get
43:20 - rid of this print statement and instead
43:23 - i want to print str
43:26 - or monster1
43:28 - and this is going to return a monster
43:32 - and we don't even need this str because
43:36 - print is trying to find a string
43:39 - so let me duplicate this line and remove
43:43 - the str and just have monster one
43:47 - if i call this now i still get a monster
43:51 - and this can be a really nice way to
43:53 - look at your objects and see what they
43:55 - are doing
43:57 - because if we didn't have this done
43:59 - their method let me comment it out and
44:01 - run this again
44:03 - all we get is a monster object which
44:06 - really isn't that useful
44:09 - and obviously this str can return a lot
44:12 - more than just a simple string
44:15 - for example we could have an f string
44:20 - with
44:21 - health
44:23 - that says self dot health
44:26 - and energy
44:29 - that says self dot energy and now if i
44:32 - run this
44:34 - we get quite a bit of information
44:36 - by just passing the monster or the
44:38 - object into the print statement so this
44:41 - sdr can be really really useful
44:45 - and with that we have covered quite a
44:47 - few dunder methods if you look online
44:49 - you can find even more but well most of
44:52 - the time you're not going to need them
44:54 - this is very often a fairly advanced
44:57 - topic
44:58 - except thunder init this is the one you
45:00 - are going to use a lot
45:03 - all right with that we have dunder init
45:05 - methods covered
45:07 - and if you understand all of this so far
45:10 - you can actually understand python
45:12 - itself quite a bit more let's talk about
45:14 - this one in the next part
45:17 - and the one thing i think that confuses
45:19 - beginners quite a bit is that every
45:21 - single thing in python is an object
45:24 - meaning every time you see a string or
45:27 - integers you are going to see an object
45:30 - just like the objects that we have
45:31 - created so our monster
45:34 - and this even includes functions which
45:36 - are just objects with the call dunder
45:38 - method
45:40 - and i'm going to show you some examples
45:41 - in just a second but most of what i will
45:44 - cover here isn't really important i just
45:47 - want you guys to understand how it works
45:49 - so you don't get confused later on
45:51 - and there's another thing that i believe
45:54 - is very often confusing and that is the
45:56 - difference between a function and a
45:58 - method
45:59 - and the reason why this is confusing is
46:02 - both just execute a block of code
46:04 - so in terms of functionality they
46:06 - basically do the same thing however the
46:09 - difference is that a method always
46:12 - belongs to an object
46:14 - it doesn't matter if the object was
46:16 - created by us or by python
46:19 - and a good example here would be using a
46:20 - string
46:22 - so if we have a function this would be
46:24 - len for example and we can pass a string
46:27 - into it this will return 4.
46:30 - and a method would be something with dot
46:33 - and then upper for example for string
46:35 - returns uppercase letters for this
46:38 - string
46:39 - and that really is the entire difference
46:42 - that's the main thing you have to
46:43 - understand and it doesn't matter if we
46:46 - create the method ourselves or the
46:47 - function ourselves or if it's created by
46:50 - python
46:51 - and the reason why these are different
46:52 - for example is that the lan method could
46:55 - work for lots of other things as well
46:57 - for example you could pass in a list in
47:00 - here you could pass in a dictionary or a
47:04 - tuple
47:05 - it would still work with different data
47:06 - types
47:08 - whereas upper only works for strings you
47:12 - couldn't add a list with upper that one
47:15 - would not work
47:16 - so it makes sense in this case that
47:18 - upper only exists as a method for
47:21 - strings whereas the ln should be a
47:23 - function so you can pass in different
47:26 - kinds of objects in here and they would
47:28 - all work
47:29 - you could perfectly find create some
47:31 - kind of len method for test and it would
47:34 - work just fine although then you would
47:36 - also have to create a lan method for
47:38 - lists for dictionaries for tuples for
47:41 - all of that stuff and it would be quite
47:43 - labor intensive
47:45 - so all we're doing here is to keep
47:46 - things more efficient
47:48 - but all right let's have a look at some
47:50 - code and let's have a small deep dive
47:53 - into python
47:55 - here i have a completely empty sheet of
47:57 - code and what i want to create for now
48:01 - is create a test variable and this one
48:03 - should have a string let's call it a
48:06 - doesn't really matter what it is
48:09 - and what i can do now i can call my
48:11 - print
48:13 - bir and pass in my test in here
48:17 - and if i run this now
48:18 - i am getting
48:20 - a bunch of dunder methods and after they
48:23 - are over starting from here
48:26 - i get a couple of methods and attributes
48:28 - now the dir method doesn't separate
48:30 - between methods and attributes so we
48:32 - just get one big list
48:34 - but
48:35 - well basically what we get here is an
48:38 - object
48:39 - and anything in here you could just call
48:42 - like upper or title or strip all of
48:46 - these are very simple methods
48:49 - and along with that we have the len
48:51 - dunder method and this is what's being
48:53 - called when we are passing this string
48:55 - into the len function
48:58 - and besides that what you can also do
49:01 - let me get rid of this test and instead
49:03 - create
49:04 - define test
49:06 - and then here
49:07 - i let me just add pass
49:10 - so this is a function with the name test
49:12 - and i'm still printing dir test so if i
49:16 - run this
49:17 - i am getting another object
49:19 - and this object is special
49:21 - because it has a call dunder method
49:25 - meaning when we're adding brackets
49:27 - afterwards it is being executed and
49:29 - that's basically what a function is in
49:31 - python it's just an object with the
49:34 - dunder call method it really isn't much
49:36 - more than that
49:37 - although we do have a couple extra
49:39 - things that make this a bit more special
49:42 - but that's the main idea
49:45 - and if you really wanted to you could
49:48 - even store this function inside of a
49:51 - variable
49:53 - and this works because the function is
49:55 - an object so this is just going to be an
49:58 - object meaning if i now print a
50:02 - we are getting the same outcome
50:05 - although what we can even do now
50:07 - let's call it another attribute that is
50:11 - not how you spell that
50:13 - and this could just be 10.
50:15 - and now if i run this
50:17 - our function has another attribute
50:21 - and again this is working because
50:23 - functions are just objects
50:27 - although in practice you wouldn't really
50:29 - do this there's no reason for it
50:32 - but
50:33 - what is much more common is that you are
50:36 - passing functions or methods into other
50:39 - objects
50:41 - so what is much more common let's say
50:43 - for example a simple add function and
50:46 - this one takes a and b
50:48 - and is going to return a
50:51 - plus b
50:52 - obviously this still isn't particularly
50:55 - useful but i just want to illustrate
50:57 - what it does
50:58 - and now i can create a class and let's
51:01 - call it test
51:03 - and in here for the dunder init
51:06 - method i want to have self
51:09 - and i want to add an add function
51:13 - and now inside of this dunder init add
51:16 - function
51:17 - i can set an attribute self dot add
51:20 - function and this should be the argument
51:23 - we get from the parameter add function
51:26 - and now
51:27 - when i create this test
51:30 - i have to pass in
51:32 - one function and i want to have this add
51:35 - function here so i'm going to add it in
51:37 - here
51:39 - and let me use a named argument so it's
51:43 - a bit easier to see what's happening
51:45 - and in here it is really important that
51:48 - you don't add brackets because we don't
51:50 - want to call this function we want to
51:52 - get the function itself so the object of
51:55 - the function not what's being returned
51:58 - and if i run this now this is working
52:00 - just fine
52:02 - and even better what i can do i can call
52:05 - test dot
52:07 - add function
52:08 - and i can pass in let's say one and two
52:12 - and this is not doing anything because
52:14 - we're not printing anything we're just
52:16 - returning something
52:17 - so
52:18 - if i put all of this into a print
52:20 - statement now we are getting free
52:23 - and i hope all of this is making sense
52:26 - this is a really important thing to
52:27 - understand
52:28 - right now this here is creating an
52:31 - object of a function and this object we
52:34 - can pass around
52:36 - for example we could pass it
52:38 - inside of a class and this would work
52:40 - just fine and then inside of the class
52:42 - we can store it inside of an attribute
52:45 - and then call it from outside of the
52:47 - function this is working just fine
52:49 - there's no limitations on this
52:52 - and this is something you really want to
52:55 - practice because passing around
52:56 - functions is a really important thing to
52:58 - understand
53:01 - and i guess since this is really
53:04 - important we should practice this with a
53:07 - slightly larger exercise
53:09 - and let me add some comments that should
53:11 - help quite a bit
53:12 - first of all i want you guys to create a
53:14 - monster class with a parameter called
53:16 - func and this func should be stored as a
53:19 - parameter that's the first step
53:22 - after that
53:23 - i want you guys to create another class
53:26 - and this one is called attacks and this
53:28 - has four methods we have let me put it
53:31 - on another line
53:33 - we have byte strike slash and kick and
53:36 - for each method you just print some text
53:39 - basically whatever you want i would
53:41 - recommend to print kick slash strike and
53:43 - byte but it really doesn't matter
53:46 - and let me add proper white space here
53:48 - and then for the final step
53:52 - i want you guys to create a monster
53:53 - object and give it one of the attack
53:55 - methods from the attack class
53:58 - and remember here that methods are
54:01 - basically just functions the only
54:03 - difference is that they are part of an
54:05 - object so this should work kind of
54:08 - similar compared to what you have seen
54:09 - here
54:10 - but well it's going to be slightly
54:12 - different so experiment with this and
54:15 - see how far you get
54:19 - all right let's try together now first
54:21 - of all i want to create a monster class
54:24 - and this i do with class monster
54:27 - and in here i want a dunder init method
54:30 - that needs self and a funk
54:34 - and this funk i want to turn into an
54:36 - attribute so self dot func
54:40 - and i want to capture the parameter or
54:42 - the argument we get here in there
54:45 - and this is covering all of this
54:47 - next up we have to create another class
54:51 - so class and this one is called attacks
54:55 - and in here we don't need a dunder
54:57 - indeed method instead i want to create
55:00 - define let's start with byte
55:03 - and we need self as always and in here i
55:06 - just want to print
55:08 - byte
55:10 - and since we need four attack methods
55:13 - let me copy this
55:15 - a few more times
55:18 - and now besides byte
55:22 - i also want strike
55:25 - then i want
55:27 - slash
55:28 - and finally i want kick
55:33 - and i think you can already tell why
55:34 - this might be useful it's a very neat
55:37 - way to organize all of your different
55:39 - functions if you have a really large
55:41 - game with hundreds of different attack
55:43 - methods this may actually be really nice
55:46 - to organize all of this all right
55:49 - now finally i want to create an object
55:51 - of my monster
55:53 - so monster in lower case and then here i
55:56 - want to have my monster
55:58 - and now we have to define a function
56:02 - now this you could approach in a couple
56:04 - of different ways although there's one
56:07 - way that is definitely wrong and it's
56:09 - very tempting to go this way you could
56:11 - write something like attacks and then
56:14 - dot byte
56:15 - and if i run this code
56:17 - we get a 3 and this 3 comes from up here
56:21 - so let me comment out all of this
56:25 - and if i run this again now we can't see
56:28 - any difference
56:29 - but
56:30 - if i run monster.funk
56:34 - we are getting that attack.byte is
56:36 - missing one required positional argument
56:38 - and that is self
56:40 - and this is a reasonably common error
56:43 - the reason is that this here is not
56:47 - returning an actual object it's
56:48 - returning a class
56:50 - and this is confusing python now an easy
56:53 - way around this is to actually turn this
56:56 - class into an object by calling it so
56:58 - adding brackets afterwards
57:00 - and now if we run this we are getting
57:02 - byte
57:03 - and basically what is happening here
57:06 - think of this in terms of return
57:07 - statements when we are calling this
57:10 - attacks it's returning an object
57:13 - and then inside of this object we are
57:15 - getting the byte method which is this
57:19 - byte method here
57:21 - and if you don't like how this looks
57:24 - what you could also do
57:25 - is create a separate object let's call
57:28 - it attacks
57:29 - and in here i could add this attacks
57:32 - and then call attacks.byte and we will
57:35 - get the same result
57:38 - and this is something we are going to
57:40 - explore quite a bit more that you pass
57:43 - different things around different
57:44 - classes
57:46 - so that in this example
57:48 - we are taking the byte method and
57:51 - passing it into another object
57:54 - and this is getting incredibly powerful
57:57 - and really important to understand if
57:59 - you want to understand more complex code
58:01 - because a key part of object-oriented
58:04 - programming is that you work with
58:06 - different objects and make them interact
58:08 - with each other and this example here
58:11 - so this part down here is one example to
58:14 - make classes interact with each other
58:16 - and i would really recommend you to
58:18 - practice this in your own time it's
58:21 - really going to be helpful
58:23 - but all right with that we have covered
58:25 - a really basic deep dive into python
58:29 - although i do want to practice this a
58:31 - bit more and there's one important topic
58:33 - i do want to cover and that is going to
58:35 - be scope in terms of objects and classes
58:38 - let's talk about that one in the next
58:40 - section
58:41 - all right so let's talk about classes
58:44 - and scope and this is one of the really
58:46 - powerful parts of objects that make it
58:49 - really easy to work with this scope but
58:51 - let's talk about it
58:53 - basically every method so every function
58:56 - inside of a class has a reference to
58:58 - that class and because of that it's
59:01 - really easy to get and change class
59:04 - attributes
59:06 - and because of that methods are much
59:08 - easier to work with than normal
59:10 - functions
59:11 - meaning they rely much less on
59:12 - parameters the global keyword and return
59:15 - statements although you can still use
59:18 - them if you really want to and sometimes
59:20 - that does make sense
59:21 - but you are going to do this much less
59:24 - often
59:25 - and what is even better objects can be
59:27 - influenced from outside of the object
59:30 - itself and even from the local scope of
59:32 - a function
59:34 - basically objects you can change
59:36 - wherever you want there is no limitation
59:38 - on the scope for them which makes it
59:40 - even easier to work with them
59:43 - but i guess let's have a look at all of
59:45 - this in code that should illustrate this
59:48 - the best
59:49 - here i have a completely empty sheet of
59:51 - code and first of all i want to
59:54 - illustrate the problem so let's talk
59:56 - about scope again let me add a comment
59:58 - scope problem
60:00 - and let's say i have a game and i have
60:03 - some kind of health that right now is
60:05 - 10.
60:07 - and for this health i want to have a
60:09 - function let's call it update health and
60:12 - this one takes an amount and all it
60:15 - really does is it adds that amount to
60:18 - the health
60:19 - a super simple function just about the
60:23 - simplest function you could write
60:26 - now what i want to do let me say i want
60:28 - to print health
60:29 - then i want to update my health with 20
60:33 - and then i want to print my
60:35 - health again
60:37 - and if i were to run this what do you
60:40 - think is going to happen just think
60:42 - about it
60:43 - and well if i print it we are getting an
60:45 - error and what python is unhappy about
60:48 - is that we have a local variable health
60:51 - referenced before assignment
60:54 - and
60:55 - what is happening here is that this
60:57 - health to python is a local variable
61:00 - let me remove the error messages they
61:02 - are getting a bit annoying that's easier
61:04 - to work with
61:06 - essentially this health only exists in
61:08 - the scope of this function here
61:12 - or in other words
61:14 - this health here
61:15 - and this health here to python are two
61:19 - completely separate things
61:22 - and then when we are trying to update
61:24 - this health with some amount i even
61:26 - cannot find any starting amount for this
61:28 - health as a consequence we are getting
61:31 - an error
61:33 - and there are a couple of ways to get
61:35 - around this for example we could use
61:37 - global health
61:39 - that's probably the easiest one and now
61:41 - this would work although
61:43 - you could also use return statements but
61:46 - it really isn't the cleanest way to work
61:49 - with this
61:50 - so this is not great
61:53 - so let me comment it all out and let's
61:55 - do the same thing with classes
61:57 - so let me create a class monster again
62:01 - and in here i want to create a dander
62:03 - init method that needs self
62:06 - health and energy
62:09 - and then as always i want to set
62:11 - self.health
62:13 - equal to health and self.energy
62:16 - is going to be energy
62:19 - and now let me create an object from
62:22 - this class and let's give it a health
62:26 - of 100 and energy
62:30 - 50. it doesn't really matter what values
62:32 - you put in here
62:34 - so now i can print monster.health
62:38 - and we are getting a hundred
62:40 - so this one works just as expected
62:44 - and now what we can do we can just get
62:47 - monster.health
62:48 - and add let's say 20 to it and if i now
62:51 - print
62:52 - monster.health again we are getting 120
62:57 - ie the sum of 120.
63:01 - and what is even more powerful let me
63:04 - uncomment this function up here
63:07 - and now instead of the health i want to
63:09 - get my monster.health and update the
63:12 - amount
63:13 - and this would still work if you are
63:15 - using an object
63:17 - so let me get rid of these two lines
63:19 - here and instead call the function
63:22 - update health
63:23 - and let's say i want to raise this by 20
63:26 - again
63:27 - and now if i print monster.health
63:31 - after calling this function i get 120
63:36 - meaning even inside of the local scope
63:40 - of a function
63:41 - you can still update anything inside of
63:44 - an object but the simple reason that
63:46 - here python is very clear about what
63:49 - kind of object you're talking about
63:52 - this monster is not going to become a
63:54 - variable in the local scope
63:57 - and this monster could be updated
63:58 - anywhere it could be in the global scope
64:01 - it could be the local scope of a
64:02 - function it could be in the scope of
64:04 - another method it could even be inside
64:07 - of the object itself so this monster
64:10 - python just doesn't care
64:12 - which makes it really easy to work with
64:16 - so i guess one thing
64:18 - you do see fairly often is inside of a
64:21 - class you have something like let's call
64:24 - this one update
64:26 - energy
64:28 - and then here we need self and let's add
64:30 - an amount in here as well
64:33 - and all i really have to do to update
64:37 - this self.energy
64:39 - would be
64:40 - to first target the attribute itself so
64:43 - self dot energy and then plus equal
64:47 - amount
64:50 - and now i could just run monster dot
64:53 - update energy pass in anything i want in
64:56 - here
64:56 - and then print
64:59 - monster.energy
65:01 - and we are getting 70.
65:04 - and again here this is a very easy way
65:08 - to work with scope you don't have to
65:10 - worry about return statements you don't
65:11 - have to worry about global all you do is
65:14 - target the attribute and then you set it
65:16 - to a new value or update whatever you
65:18 - want that's it it's super easy to work
65:21 - with
65:23 - although if you wanted to you could use
65:26 - a return statement as well
65:28 - for example if i wanted to set
65:32 - energy
65:33 - and in here i want self and energy
65:38 - and let's say for this one i want to
65:39 - create a new local variable that i call
65:42 - new energy
65:44 - and this is going to be energy times two
65:47 - and then i want to return
65:49 - this new energy
65:52 - and now in my init method
65:54 - instead of setting energy straight as
65:57 - the attribute i want to call self.set
66:00 - energy and pass in the energy
66:03 - and now let me comment out this line
66:05 - down here to update the energy and just
66:07 - get the energy now we're getting 100
66:10 - which is
66:12 - this 50 here
66:15 - this 50 we are passing inside of this
66:18 - energy here
66:20 - from that energy we are passing it
66:22 - inside of another method inside of the
66:24 - monster class
66:26 - and this
66:27 - method
66:28 - is down here we are getting one
66:30 - parameter and this we are doubling and
66:34 - assigning it to new local variable
66:37 - inside of this method
66:39 - and after that we are returning the new
66:42 - energy and this new energy is going to
66:45 - become
66:46 - the attribute self.energy
66:49 - kind of a roundabout way of doing it but
66:51 - it is possible to do
66:53 - all i really want you to understand is
66:55 - that you can still use return and
66:56 - parameters just like with any other
66:59 - function although most of the time you
67:01 - don't really need it
67:04 - a better way for this one
67:06 - would be
67:07 - to
67:08 - remove this part entirely just call set
67:11 - energy
67:12 - and then
67:14 - self dot energy is going to be new
67:18 - energy this would work in exactly the
67:20 - same way although it is much cleaner to
67:22 - read so if i run this we are still
67:24 - getting a hundred
67:26 - and i hope you understand why self is
67:29 - really really powerful it essentially
67:31 - bypasses all of the scope issues very
67:34 - efficiently all right let me get rid of
67:36 - all of this because i don't really care
67:38 - about it
67:39 - and instead i want to set self.energy
67:42 - back to energy
67:45 - all right now with that let's do an
67:47 - exercise to practice this
67:50 - and what i want you guys to do first of
67:52 - all
67:53 - create a hero class with two parameters
67:59 - one is damage and the second one is a
68:01 - monster
68:03 - which is going to be
68:04 - this object here so this object you want
68:07 - to pass into another class as an
68:10 - argument
68:11 - and second of all
68:14 - the monster class
68:17 - should have a method that lowers the
68:21 - health
68:22 - and i guess you can call it get
68:25 - damage and this one should take an
68:28 - amount
68:29 - and then this amount you would reduce
68:31 - from the health of the monster
68:33 - and finally
68:36 - the hero class should have an
68:39 - attack method
68:41 - that calls the get
68:44 - damage method
68:46 - from the monster
68:49 - and let me put this on the second line
68:51 - and the amount of damage
68:54 - is hero dot damage
68:57 - which is going to be the damage you
68:59 - specified up here which should be an
69:01 - attribute
69:03 - so i hope all of this makes sense try to
69:05 - implement this yourself and see how far
69:07 - you get
69:10 - alright let's try it together now first
69:12 - of all i want to create a new class and
69:15 - this is going to be hero
69:18 - and the hero needs a dunder init method
69:22 - and here we need self and besides that i
69:24 - want damage and i want a monster
69:27 - and let me add a bit more white space
69:30 - there we go
69:31 - now i want self.damage to be damaged and
69:35 - i want self.monster
69:37 - to be monster
69:39 - and let me spell this correctly there we
69:40 - go
69:42 - and this would then be step number one
69:45 - and for step number two let me move it
69:48 - up a bit so it's easier to see what's
69:51 - going on
69:53 - the monster class should have a method
69:55 - that lowers the health and this i want
69:57 - to call get damage
69:59 - so define get
70:01 - underscore damage
70:03 - and then here i need self and i need the
70:05 - amount
70:07 - and all i really want to do in here is
70:08 - self dot health minus equal
70:12 - whatever amount we specify
70:14 - and this get damage i want to call from
70:18 - inside of the hero
70:20 - and this brings us to step number three
70:25 - and this
70:27 - right now we are still inside of the
70:29 - hero class which you can see by the
70:31 - indentation
70:33 - i probably should have actually
70:35 - mentioned that for the class we always
70:37 - define something by one level of
70:39 - indentation
70:40 - in here i want to now create let's call
70:44 - it an attack method and this one itself
70:48 - and nothing else
70:50 - and all i really want to do in here is
70:52 - get myself.monster
70:55 - and this self.monster is the monster we
70:57 - specified up here and on this monster we
71:01 - want to call get damage
71:04 - and all we really have to do for that is
71:06 - call get underscored damage
71:09 - and now we have to specify how much
71:11 - damage we want to cause to the monster
71:14 - and for that i want to get the damage of
71:17 - the hero
71:18 - and all we need for that is specify self
71:21 - dot damage and we are
71:24 - done and if you just read through this i
71:28 - hope this really illustrates why this
71:30 - makes a ton of sense
71:32 - it's basically a normal sentence we want
71:34 - to get the monster we want to cause the
71:36 - monster some damage and the amount of
71:38 - damage we want is self-dot damage so the
71:40 - damage of the hero
71:43 - and now with that all we have to do is
71:45 - to actually create the object of the
71:47 - hero
71:48 - meaning i want to create a hero object
71:51 - and this is going to be hero
71:53 - and then here we need damage let's say
71:55 - damage for the hero is 15
71:58 - and then we need a monster
72:00 - and the monster is going to be
72:03 - the monster object we created just a
72:05 - second ago this one here
72:07 - and this we're just passing in here
72:10 - and now let me print monster.health
72:15 - and if i run this we are getting a
72:17 - hundred
72:18 - which is this 100 here
72:22 - but now
72:24 - if i call hero dot attack
72:28 - and this one doesn't need any arguments
72:31 - and afterwards i can print
72:32 - monster.health
72:34 - again
72:35 - and now if i run this we get 85
72:39 - which is 100 minus 15. this is how this
72:43 - 85 comes about
72:45 - and to get to this point to lower the
72:47 - health of the monster we just had to
72:50 - call one method and that's it
72:53 - all we are really doing in here is we
72:55 - are passing different objects around and
72:57 - make them interact with each other and
72:59 - since we don't really have to worry
73:01 - about scope this is very easy to
73:03 - implement
73:05 - and again this is something you really
73:07 - want to practice on your own and try to
73:09 - work on this more to make sure you
73:11 - understand it
73:12 - but right with that we have covered
73:15 - scope and i guess for the next part
73:17 - let's talk about inheritance
73:21 - and inheritance really just means that
73:24 - one class gets the attributes and
73:26 - methods from another class or multiple
73:28 - classes
73:30 - and i have already shown an example
73:32 - earlier and that was we had a monster
73:35 - that we have already seen multiple times
73:37 - with health and energy
73:39 - and this right now is called a parent
73:42 - class
73:43 - and the reason why it is called the
73:45 - parent class is because there's a child
73:47 - class and this one was the shark
73:50 - and this shark by itself only has a
73:53 - speed and a byte method
73:55 - and what i want to happen
73:57 - is that the health and the energy of the
74:00 - monster parent class
74:02 - comes into the child class and the same
74:05 - for the method
74:07 - so attack and move should also be
74:09 - available inside of the shark class
74:13 - so that when i actually use this to
74:15 - create an object
74:17 - the shark object has health energy and
74:19 - speed for the attributes and attack move
74:22 - and bite
74:23 - meaning we are combining the monster and
74:26 - the shark class to create the actual
74:29 - shark object
74:31 - and the reason why we are doing this is
74:34 - this makes it very easy to reuse code
74:37 - let's say this monster here could be the
74:39 - parent class to every monster in our
74:42 - game
74:43 - and if we have this we never have to set
74:46 - the attributes health for energy for any
74:48 - other monster they are always available
74:51 - for every single class because they all
74:53 - inherit from this monster and obviously
74:56 - this is still a very simple example in
74:59 - an actual game the monster class might
75:01 - have a few hundred if not thousands of
75:03 - lines of code
75:04 - and then it really makes sense to reuse
75:07 - code as much as we can because then we
75:11 - don't have to create new classes all the
75:13 - time with all of these methods that we
75:16 - have to type over and over again
75:19 - and then on top of that if we wanted to
75:21 - make changes to how things move in the
75:23 - game so this method here
75:25 - if we didn't use inheritance and we want
75:27 - to make change how things move in the
75:29 - game we would have to change possibly
75:32 - hundreds of different move methods for
75:34 - every single monster
75:36 - but if we use inheritance we don't have
75:38 - to if we change one move method we are
75:40 - changing how every monster in the game
75:42 - moves
75:43 - so i hope that makes sense
75:47 - and one important concept here is that
75:49 - the class can inherit from an unlimited
75:51 - number of other classes this could look
75:53 - like this
75:56 - in here we could have a parent class 1 a
75:58 - parent class 2 and a parent class 3
76:02 - and then the child class would have the
76:04 - attributes and methods of all of these
76:07 - parent classes
76:09 - and you can also turn this around where
76:11 - you have a parent class and this parent
76:13 - class is being inherited from by an
76:14 - unlimited number of other classes and
76:17 - this would look something like this you
76:20 - have one parent class
76:22 - and you have one child class a second
76:25 - child class and a third child class and
76:28 - all three of those would have
76:31 - the methods and attributes of the parent
76:34 - class
76:36 - and this here for example could be the
76:39 - monster class
76:40 - and then this one here maybe the shark
76:44 - class and let's say this one here
76:47 - could be i don't know like a bird class
76:49 - or something
76:51 - now there's one thing you do want to be
76:53 - aware of though and that is that
76:55 - inheritance can get very
76:57 - very complex
76:59 - up to a point where it really doesn't
77:02 - become fun to work with them
77:04 - and this is also the part where
77:06 - beginners really start to struggle
77:08 - because well i'm going to show you an
77:10 - example later on but this can get very
77:12 - very complex and really hard to work
77:14 - with
77:15 - fortunately this is fairly rare most of
77:18 - the time you just need simple
77:20 - inheritance and this one is really easy
77:22 - to implement
77:23 - and this one might be something like
77:25 - this the example we have already seen
77:28 - and this one should be very easy to
77:30 - follow so for this section i just want
77:33 - to focus on implementing this part here
77:36 - and i guess let's actually implement
77:39 - this one in code and let's see how this
77:41 - is going to look like
77:43 - alrighty so here once again we can see
77:46 - our monster class and from this monster
77:49 - class
77:50 - i want to get
77:52 - a shark class
77:54 - and this one should get the health the
77:58 - energy the attack method and the move
78:00 - method of this monster class we want to
78:03 - put all of this inside of the shark
78:06 - now
78:07 - passing in the methods is very simple
78:10 - but the health and the energy are going
78:13 - to be a bit more complicated so for now
78:16 - let me simplify things a tiny bit by
78:18 - commenting out the dander indeed method
78:21 - and instead
78:22 - setting health to something constant
78:25 - let's say 50
78:26 - and energy to 100.
78:29 - the reason being that init is a bit more
78:32 - complicated for inheritance so i'm going
78:34 - to ignore this part for now just to keep
78:36 - things simple but we will implement this
78:39 - in just a bit
78:40 - all right now for this shark
78:44 - i want to create an
78:46 - init method by itself and this one needs
78:49 - self
78:50 - and in here i want to set this speed
78:54 - and now what i want to do is
78:57 - self.speed
78:58 - is going to be speed
79:01 - and this way we are getting our
79:03 - attribute and besides that i also want
79:05 - one method
79:06 - and that method i have called byte and
79:09 - in here we just need self and let me
79:12 - print
79:13 - the shark
79:15 - has bitten or whatever you want to put
79:18 - in here
79:19 - and this by itself would be a
79:21 - functioning class but also a very
79:24 - limited class because it only has a
79:26 - single attribute and one method it
79:28 - doesn't really do all that much
79:30 - so how can i get all of the monster
79:33 - attributes and methods inside of the
79:35 - shark
79:36 - and
79:37 - to get inheritance what we have to do is
79:40 - add brackets after the shark or the name
79:43 - of the shark class
79:44 - and then here we have to pass in
79:47 - what class we want to inherit from in my
79:49 - case this is monster
79:51 - and for start this is all you need
79:56 - meaning now i can create my shark by
79:59 - calling shark
80:01 - and i have to pass in a speed for the
80:04 - shark and let me just say i don't know
80:06 - 120.
80:09 - and now if i print my shark
80:12 - all of this works just fine and we are
80:15 - getting an object
80:16 - but what i can do now is get my shark
80:19 - dot health
80:20 - and this is the 50 we have set all the
80:23 - way at the top here
80:26 - i can also get my shark speed
80:29 - this is the 120 we set for the shark in
80:32 - here
80:33 - and besides that
80:34 - i can also call shark dot byte
80:38 - we get the shark as bitten and besides
80:40 - that i can also set shark dot
80:43 - attack
80:44 - and this one needs an amount so let's
80:46 - say 20
80:48 - and this is the attack method we have
80:50 - gotten from here so the parent class
80:54 - and if i run this we get the monster has
80:56 - attacked
80:58 - and well with that we already have super
81:01 - simple inheritance
81:03 - just by adding this brackets monster we
81:06 - are getting all of these attributes and
81:10 - these methods here
81:12 - so that's a pretty good start now what
81:14 - you can also do let's say let me remove
81:17 - some white space here
81:19 - let's say for the shark this move method
81:21 - here doesn't really work because for the
81:25 - shark i want something else i want the
81:27 - shark to swim
81:28 - and for the speed i want to set since i
81:30 - have a speed i want to use self.speed
81:33 - meaning i want to overwrite this speed
81:36 - from the parent class
81:38 - and to achieve that
81:40 - all you have to do is define a method
81:43 - with the same name in the child class so
81:46 - in here i want self.move
81:49 - and now i can add a print statement in
81:52 - here
81:53 - the shark has moved
81:56 - and let's say print again
81:59 - the speed of the shark is
82:04 - and then self dot speed and this should
82:08 - be an f string
82:10 - and now if i call shark dot move and we
82:14 - don't need any arguments if i call this
82:16 - the shark has moved the speed of the
82:17 - shark is 120.
82:20 - and what happens in here is we are first
82:23 - getting the inheritance from the monster
82:26 - and then this move here is being
82:29 - overwritten by this move here
82:33 - which means you can overwrite what you
82:35 - get from the parent class very easily
82:38 - and this you could also do with
82:40 - attributes
82:41 - although
82:42 - we actually have to talk about
82:43 - attributes let's do it right now
82:45 - the problem we are facing right now
82:48 - is that the monster has an init method
82:51 - let me remove this health and energy and
82:54 - uncomment the init method
82:57 - essentially the problem we have right
82:59 - now to give the monster the attributes
83:02 - this self.health and
83:04 - self.energy we have to first call the
83:08 - init method
83:10 - and if we don't call the init method we
83:12 - don't get these attributes so what we
83:14 - have to figure out inside of the init
83:17 - method how to call the parent init
83:20 - method
83:21 - so this would have to happen in here
83:24 - and for that we have two ways one that
83:27 - is a bit outdated but still works and
83:29 - one you actually want to use and let's
83:32 - cover both but you don't really need the
83:34 - first one anymore
83:36 - but just in case you see it let's cover
83:38 - it now what you can do
83:40 - you can call the parent class so monster
83:43 - and then call the dunder init method
83:47 - and now
83:48 - in here
83:49 - you have to pass all of the arguments so
83:52 - these ones here that you want for the
83:54 - parent class so we need self health and
83:57 - energy
83:58 - and these we have to get from arguments
84:01 - so when i initiate the shark besides
84:04 - speed i also want to get health for the
84:07 - shark and energy for the shark
84:11 - meaning when i actually create the
84:13 - object of the shark
84:15 - besides speed i want to set health to
84:18 - 100
84:19 - and energy to 80.
84:22 - now what i get let's go over this
84:24 - actually
84:26 - the first step happens down here
84:29 - i am calling the shark class and i'm
84:32 - passing in three arguments
84:34 - i have the speed i have the health and i
84:37 - have the energy
84:39 - and these three arguments are being
84:41 - covered in speed health and energy
84:46 - and inside of this init method we are
84:50 - calling the parent init method
84:53 - and into this init method we have to
84:55 - pass in three arguments
84:57 - self
84:58 - health and energy
85:01 - and self originally for the parent class
85:04 - was the class itself so this self here
85:06 - which refers to this monster
85:09 - however now the self is going to refer
85:12 - to this self here which is the shark
85:15 - meaning when we are setting self.health
85:18 - and self.energy we don't talk about the
85:20 - monster we are talking about the shark
85:23 - class
85:25 - and this is why the self here is
85:26 - important
85:27 - and then besides the self we also need
85:30 - health and energy and these are just
85:32 - going to be arguments we have to pass in
85:34 - here so this health and this energy
85:37 - and these two we get from these two
85:39 - parameters here which is health and
85:41 - energy and those are being passed in
85:44 - here
85:45 - and with the left move method i don't
85:47 - care about this one instead let me print
85:51 - shark
85:52 - dot let's start with speed let's
85:55 - actually print all of them so besides
85:57 - speed i want health and i want energy if
86:01 - i run this we get 120 180
86:05 - the numbers we have specified here
86:08 - and
86:09 - well this can get a bit complicated but
86:14 - look at the init method here and the
86:15 - init method here
86:17 - and
86:18 - if you didn't understand what i talked
86:19 - about in the last part practice this
86:21 - yourself and then go over this a couple
86:23 - of times
86:25 - if you get used to this it's eventually
86:27 - going to become fairly easy although i
86:29 - suppose in the beginning this can be a
86:30 - bit overwhelming
86:32 - the one really important thing you have
86:34 - to understand is that we are calling the
86:36 - init method and we are passing in the
86:38 - arguments that we want to set in this
86:40 - case speed health and energy
86:43 - and then inside of this init method we
86:46 - are right now calling the parent init
86:48 - method
86:49 - and then passing
86:51 - health and energy so these two
86:54 - in there as arguments
86:56 - so for example we first set the health
86:58 - here when we are creating the object
87:00 - this health goes into this health for
87:03 - the parameter and then this parameter
87:06 - goes into
87:07 - the init method of the parent
87:09 - and then the init method
87:11 - sets self dot health
87:15 - or the actual class
87:17 - and that way you can connect the init
87:19 - methods of different classes now this is
87:23 - how python used to work and this still
87:25 - works but there are some downsides to
87:27 - using it this way so this isn't really
87:30 - used anymore
87:31 - instead what we use is called super and
87:34 - this is a function
87:36 - and this super all it really does is it
87:38 - gets the parent class
87:41 - so if we have that we can just call the
87:43 - init method on it as well
87:47 - and in here we don't need self all we
87:49 - have to do is pass in health and energy
87:53 - and then we are done if i run this now
87:55 - we are getting the very same outcome
87:58 - meaning those two approaches here are
88:01 - functionally identical at least up to
88:03 - this point
88:05 - when we get to multiple inheritance or
88:07 - let's say more complex inheritance super
88:10 - is the much better method
88:12 - and this is why we don't use this
88:13 - initial approach anymore and i guess
88:15 - this one is also a bit easier to read it
88:18 - kinda is up to you but this is the one
88:20 - you do want to use
88:23 - and super you can actually use for a lot
88:25 - of other things as well
88:27 - for example i could call super
88:31 - and then call the move method of the
88:34 - parent and in here i have to pass in a
88:36 - speed let's say 10
88:38 - so now when i run the code
88:41 - i get the monster is moved at a speed of
88:43 - 10
88:44 - meaning when we are calling the init
88:46 - method of the shark class we are also
88:49 - calling the move method of the parent
88:52 - and this way even if you overwrite a
88:54 - method from the parent class you can
88:56 - still call it with super if you really
88:58 - want to
89:00 - which adds even more flexibility to all
89:02 - of this
89:04 - and this
89:05 - is simple inheritance
89:08 - which is something you definitely want
89:10 - to practice this is the one kind of
89:12 - inheritance you are going to use fairly
89:15 - often and the one you have to understand
89:18 - let's practice this one and let me add
89:20 - comments one more time
89:22 - let's do an exercise
89:25 - i want you guys to create a scorpion
89:28 - class that inherits from the monster
89:32 - and it should get health and energy from
89:36 - the parent
89:38 - and then besides that
89:40 - there should also be a poison
89:43 - damage attribute
89:45 - and i want you guys to overwrite
89:49 - the damage
89:50 - method
89:52 - to show poison
89:56 - damage
89:58 - kinda like what we have done for the
90:00 - move method for the shark
90:03 - pause the video now and try to implement
90:05 - this one yourself and see how far you
90:07 - get
90:10 - i want to start by creating a class
90:13 - called scorpion that is not used for
90:16 - scorpion there we go
90:18 - and this one should inherit from monster
90:21 - and now in here i want to create a
90:24 - dunder init
90:26 - method and this one itself and besides
90:29 - that i want poison
90:33 - mitch
90:34 - and now inside of the scorpion i want to
90:36 - set self poison damage
90:39 - as poison damage so we are getting an
90:42 - attribute
90:43 - and then besides that
90:46 - i want to define or well overwrite the
90:50 - attack method
90:51 - let me minimize the shark class so we
90:54 - can see the code a bit easier and i want
90:56 - to overwrite this attack method here
91:00 - and in my guess what i want i just want
91:02 - self because i already have the poison
91:04 - damage
91:05 - and all i want to do in here is print
91:09 - the
91:10 - scorpion has attacked
91:14 - and
91:14 - print
91:17 - it has
91:18 - dealt
91:20 - and then we want self dot poison damage
91:23 - and poison damage
91:26 - and this should be an f string
91:30 - alright so far this should have been
91:32 - fairly easy
91:33 - what i can do now let me delete all of
91:36 - this and let's delete a shark as well we
91:39 - don't need him for now
91:41 - and what i want to do is to create an
91:43 - instance or an object from my scorpion i
91:46 - am really bad at typing scorpion
91:49 - and here i bought my scorpion and right
91:51 - now we have a poison damage i don't know
91:54 - of 50.
91:56 - and now if i type scorpion dot attack
92:00 - this is working the scorpion has
92:02 - attacked it has dealt 50 poison damage
92:05 - this shouldn't have
92:07 - an underscore there we go it has dealt
92:10 - 50 poison damage this looks much better
92:13 - meaning what we have so far we have a
92:16 - scorpion with poison damage and we have
92:18 - overwritten the attack method
92:21 - and since we are inheriting from monster
92:23 - we are also getting this move method
92:25 - here meaning my scorpion can also move
92:29 - at a certain speed let's say 5 if i run
92:31 - this
92:32 - and let's make this a bit larger
92:36 - we have the attack method for the
92:37 - scorpion and we have the move method
92:40 - but what we don't have let me get rid of
92:44 - those two
92:45 - we don't have
92:47 - scorpion.health for example
92:50 - this attribute doesn't exist right now
92:53 - because
92:54 - monster
92:55 - only gets these two attributes once we
92:58 - are running the init method
93:00 - so what we have to do in the scorpion
93:03 - called the init method of the parent
93:05 - class
93:06 - which we get with super and then dunder
93:09 - init in here
93:12 - and if i scroll up
93:14 - the monster class for the init method
93:17 - needs two arguments health and energy
93:21 - so let me comment those two and in the
93:23 - unit method i want to pass in health and
93:26 - energy
93:27 - now these numbers have to come from
93:29 - somewhere
93:31 - although they don't necessarily have to
93:33 - i could for example just set static
93:35 - numbers in here let's say 50 and 10.
93:38 - if i run this now we get 50 for health
93:41 - because all we are doing here is calling
93:44 - a function that is done there init
93:47 - and we are just giving it different
93:49 - arguments
93:52 - although this lacks a lot of flexibility
93:54 - so i don't want to do it but we could if
93:56 - we wanted to
93:58 - instead i want to get this health and
94:00 - this energy
94:02 - from the init method of the scorpion
94:04 - class
94:05 - and in here just to be specific about
94:08 - what we are doing let me name this
94:10 - scorpion health
94:12 - and scorpion
94:14 - energy and somehow my brain always wants
94:17 - to add a tea to scorpion i have no idea
94:19 - why
94:21 - and now when i call the init method for
94:24 - the monster my health should be my
94:27 - scorpion health and my energy
94:30 - should be my scorpion energy
94:32 - when i am creating the actual object
94:36 - i want to have let me use named
94:38 - arguments that makes it a bit easier to
94:39 - read my poison damage should be 50
94:43 - my scorpion health should be 20
94:47 - and my scorpion energy
94:50 - should be 10.
94:52 - and now if i run this we get 20 for the
94:56 - health of the scorpion because remember
94:58 - we are only calling scorpion health the
95:01 - parameter so this is scorpion health
95:03 - here we don't actually set this
95:05 - parameter as an attribute instead what
95:08 - we do
95:09 - we are using the health attribute of the
95:11 - parent class and this gets the value of
95:13 - the scorpion health
95:15 - so our scorpion doesn't have scorpion
95:17 - health as an attribute it just has
95:19 - health
95:20 - and along those lines we also have
95:23 - energy if i run this we get 10.
95:27 - and i hope this starts to make a bit
95:30 - more sense this is definitely something
95:32 - you want to practice if you only
95:34 - partially followed along this is a
95:36 - really important concept to understand
95:39 - and definitely something you are going
95:41 - to see all the time
95:43 - and this you can actually make quite a
95:45 - bit more complex with well more complex
95:48 - inheritance so let's talk about that one
95:52 - and basically what that means so far we
95:55 - always had one parent class and then a
95:58 - child class so a pretty immediate
96:00 - connection
96:02 - something slightly more complex is you
96:04 - have a child class and two parent
96:06 - classes
96:07 - this is something we are going to build
96:09 - in this section
96:11 - but if you really wanted to you could do
96:13 - something like this and it would still
96:16 - work
96:17 - now maintaining something like this is
96:19 - going to be a ton of work
96:21 - although once you have it this child
96:24 - class is incredibly powerful because it
96:27 - gets information from a lot of parent
96:28 - classes
96:30 - so especially if you create something
96:31 - really large this is something you do
96:33 - want to be able to understand but for
96:36 - now especially if you're a beginner and
96:38 - this is the first time you've really
96:40 - engaged with objects
96:41 - i wouldn't recommend to worry about this
96:44 - too much because it gets overwhelming
96:46 - very fast
96:48 - instead make sure to understand this
96:50 - scheme if you understand that one you
96:53 - should be able to follow along with this
96:54 - one as well but for now just practice
96:58 - objects in the first place and once you
97:00 - have a better grasp of objects engage in
97:02 - this one so let's talk about how we
97:05 - could create something like this
97:07 - and this i think is best done in actual
97:10 - code so let's have a look how we can
97:12 - work with this
97:13 - now here i have some code already
97:17 - i have the monster class we have seen
97:20 - quite often by now this one i hope is
97:22 - familiar at this point besides that i
97:25 - also have a fish class now and this one
97:28 - is a very simple class all we have is an
97:31 - init method and this one sets a speed
97:34 - and has scales
97:36 - and besides that we have a swim method
97:39 - and this one just prints swimming at the
97:40 - speed of whatever the speed of the
97:42 - object is going to be
97:44 - and what i want to do i want to create
97:48 - my shark again
97:50 - but this time the shark is not just
97:53 - going to be inheriting from monster
97:55 - it is also going to be inheriting from
97:57 - fish
97:58 - so the first thing for multiple or
98:00 - complex inheritance is that
98:03 - all the objects you want to inherit from
98:05 - should be here in the brackets after the
98:08 - name of the class and in here you could
98:10 - add as many other classes you want
98:13 - there could be class 3 class 4 class 5
98:18 - as many as you want there isn't really a
98:21 - limit
98:22 - and now inside of this shark i want to
98:24 - set a dunder init method
98:27 - and in here we always need self this one
98:30 - should make sense by now
98:32 - and besides that for the shark let's say
98:34 - i want to set a byte strength
98:37 - and then
98:38 - inside of this init method i want to
98:41 - self dot byte strength is going to be
98:43 - byte strength this one should still make
98:46 - sense it's quite straightforward
98:48 - but the more complex one is if i now
98:52 - want to call super and then dunder init
98:56 - now we have a problem because i have no
98:59 - idea what to put in here
99:01 - and the question here is what arguments
99:04 - should go into this inhibit method
99:07 - should i add the arguments for the
99:09 - monster class or for the fish class
99:12 - or both how would this work
99:15 - and there are a couple of things you
99:18 - have to understand to solve this problem
99:20 - the first one is called the mro or the
99:23 - method resolution order and what this
99:27 - really means
99:28 - is
99:29 - let me add a comment here mro
99:32 - or
99:32 - method
99:34 - resolution
99:36 - order
99:37 - what this basically means is in what
99:40 - order the parent init methods are being
99:42 - called
99:43 - and this you can get
99:46 - by just printing and i want to get the
99:49 - shark class not the object the class
99:51 - itself and call mro on it and this is
99:55 - still going to work and if i call this
99:58 - we are getting invalid syntax because
100:00 - the question mark here is not something
100:02 - python likes so let me comment it out
100:04 - for now and now let's run this again
100:07 - and now
100:08 - we can see the mro or the resolution
100:11 - order and basically what it means is in
100:14 - what order python is going to go through
100:16 - the classes
100:18 - we start with the shark itself this one
100:20 - should make sense this is the class that
100:22 - we actually work in so this is where we
100:24 - want to start
100:26 - next up we are looking at the monster
100:28 - class then we look at the fish and
100:30 - finally we look at a generic object and
100:33 - this generic object you don't have to
100:35 - worry about because this is something
100:37 - inbuilt into python it's the thing that
100:40 - makes all of the objects work you don't
100:42 - have to worry about it
100:44 - so what we have to worry about is the
100:45 - shark the monster and the fish
100:48 - and how this order comes about is from
100:50 - the order of these arguments here
100:54 - and basically how this works is that the
100:55 - leftmost item monster in this case
100:58 - is always going to be the first in line
101:01 - with the class itself being the very
101:03 - first item so shark is going to be zero
101:05 - monster is one fish is two and then
101:08 - every subsequent item is going to be
101:10 - next
101:11 - meaning what i could be doing is turn
101:14 - these two around
101:16 - and call fish first and then monster if
101:19 - i run this now we are still starting on
101:21 - our shark but now fish is the first item
101:24 - of inheritance then we have monster and
101:27 - we still have object finally but in my
101:29 - case i do want to keep monster as the
101:32 - first item
101:33 - so the first thing you do have to
101:35 - understand is if we are calling the
101:37 - super dunder init method
101:39 - we are looking at the first item inside
101:42 - of these arguments here so in this case
101:45 - monster meaning for now i can minimize
101:48 - the fish class and just look at the
101:50 - monster and let me minimize these
101:52 - methods as well so it's a bit easier to
101:54 - see
101:55 - and basically what i can do now let me
101:58 - comment out the mro and i actually want
102:01 - to create a shark object from my shark
102:05 - and this is something you should be
102:08 - familiar with from simple inheritance
102:10 - right now we only have the byte strength
102:12 - so byte strength and this we can set to
102:14 - whatever we want let's say 50.
102:17 - but now for this superintendent method i
102:20 - need the arguments for the init method
102:23 - of the parent class in this case health
102:26 - and energy
102:27 - these two i want to pass in here
102:30 - now for these two i again i am going to
102:33 - need some numbers so for the init method
102:36 - of the shark class i also want health
102:39 - and energy
102:40 - meaning when i create the object i also
102:43 - want health and energy
102:45 - and let's set those to
102:48 - i don't know 200 and energy could be 55
102:52 - and with that we are essentially back to
102:55 - simple inheritance i first call the
102:58 - class itself and the first one we do
103:00 - after calling the class we are calling
103:02 - the init method
103:04 - and inside of the init method python
103:06 - knows
103:07 - that the first item of inheritance is
103:10 - the monster class
103:12 - and then after that python knows we have
103:15 - one
103:16 - parameter for byte strength and this
103:18 - we're just setting as a parameter and
103:20 - then we are done with it so this is as
103:23 - far as this one goes
103:25 - besides that we also have health and
103:28 - energy
103:29 - and these two we want to pass into the
103:31 - init method of the first parent class so
103:34 - the monster
103:35 - and those we are getting up here
103:39 - but now we have another problem and that
103:43 - problem is what happens to the fish
103:47 - let me run the code and let's see what
103:49 - happens
103:51 - we are not getting an error that's a
103:53 - pretty good sign
103:55 - now if i run
103:56 - shark
103:57 - and
103:59 - the methods we have here could for
104:02 - example be attack
104:04 - and for attack we need an amount let's
104:06 - say 10.
104:08 - the monster is attacked 10 damage was
104:10 - stealth so this attack method works just
104:13 - fine
104:15 - besides that i can also print
104:17 - shark.health
104:19 - and let me print this
104:21 - this one is working 200
104:24 - we also get shark dot energy with 55 and
104:28 - we are also getting the byte strength
104:31 - so far
104:32 - we have the shark itself
104:34 - and the monster
104:36 - what we don't have is the fish let me
104:38 - minimize the monster class and open the
104:40 - fish
104:41 - in here we have speed and has scales
104:44 - and this
104:46 - our class doesn't have right now
104:49 - so if i type shark and
104:52 - speed
104:53 - and run the code we are getting that the
104:56 - shark object has no attribute speed
104:59 - which means that the inheritance from
105:03 - the fish is not working right now
105:06 - and let me reopen the monster and hide
105:08 - the monster methods so we can see all of
105:11 - the classes quite easily
105:14 - basically what is happening
105:16 - the mro is important here again this one
105:19 - here
105:21 - essentially how you have to think about
105:23 - it
105:24 - we first of all call the shark and then
105:27 - we call the init method of the shark
105:30 - and then python knows the first item of
105:33 - inheritance is the monster
105:35 - and since we are calling super.init
105:38 - we are calling this init method up here
105:41 - and passing the arguments in there the
105:44 - consequence is that we have health and
105:47 - energy for the monster and the normal
105:49 - inheritance still works so we also have
105:51 - attack and move
105:53 - but now the problem is that the init
105:56 - method of the fish is never called
106:00 - and as a consequence speed and has
106:02 - scales doesn't exist inside of the shark
106:05 - and what we have to figure out is how to
106:07 - call this init method
106:11 - and since we still have to worry about
106:12 - the mro we have to figure out how to
106:15 - call this init method
106:17 - with the arguments
106:19 - from inside of the init method of the
106:23 - monster
106:26 - and for that purpose we are still going
106:28 - to need this super
106:31 - and then the dunder
106:33 - init
106:34 - method
106:35 - and this function is very smart because
106:39 - it follows the inheritance that we have
106:41 - set by the shark to begin with
106:44 - meaning if we call the monster from the
106:46 - shark it knows it has to look at the
106:48 - fish next in line
106:50 - however if we call the monster by itself
106:53 - this init method wouldn't really do
106:55 - anything so this is a very intelligent
106:57 - function
106:59 - in the simplest terms basically what
107:01 - this init method has to do is to set the
107:04 - speed and hash scales
107:06 - of the other class which is the fish
107:08 - again
107:10 - let me set some static numbers for the
107:12 - speed let's go with 75 and for scales
107:15 - this should be false
107:18 - and now if i run all of this again i get
107:23 - for speed let's try this again now for
107:25 - speed i get 75 and for hash scales
107:29 - i get false
107:30 - the arguments we have set in here
107:34 - and this is especially if you are
107:36 - starting with objects probably going to
107:39 - be really confusing but the one thing
107:41 - that makes all of this work is the order
107:43 - of the indent methods we are first
107:45 - calling this one here this is number one
107:48 - then we are looking at the monster
107:51 - which is this one here this init method
107:54 - is number two then and then finally
107:57 - we are looking at the second item in the
107:59 - inheritance which is the fish this for
108:01 - shear so this init method is called
108:04 - third
108:05 - and we always need
108:08 - the
108:08 - super init method to go to the next item
108:13 - and what we would want to add in here as
108:15 - well
108:16 - is a
108:17 - super
108:18 - and then dander init method for the fish
108:22 - as well so if there's going to be
108:24 - another item in the list of inheritance
108:26 - or in the mro
108:28 - we would also call that one
108:31 - and for that reason you very often see
108:33 - super init in most classes because it
108:37 - enables inheritance to work across
108:39 - multiple classes
108:41 - and well i hope you can still follow
108:43 - along this is getting quite complicated
108:45 - and it is just going to get worse
108:47 - because right now we do have one problem
108:50 - and that is that this speed here and the
108:53 - hair scales
108:54 - are constant right now
108:56 - but i want to be able to set them
108:59 - dynamically when i am creating the shark
109:02 - meaning what i want to do when i create
109:05 - a shark
109:06 - i want to set this speed
109:09 - let's set it to 120
109:12 - and i want to set has scales to
109:16 - false
109:17 - and this would then be all the stuff i
109:19 - have for the shark and i think it makes
109:21 - sense to put all of this on separate
109:23 - lines to make it a bit easier to read
109:27 - all right but now if i run this
109:30 - we are getting an error that shark init
109:33 - got unexpected keyword argument speed
109:36 - basically what pipeline is complaining
109:38 - about that this speed and this has
109:41 - scales don't exist in the parameters for
109:44 - the init method of the shark class
109:47 - we can fix that by adding a speed
109:50 - and has scales in here
109:53 - if i run this now this is going to work
109:56 - but we're not doing anything with either
109:58 - the speed or the hass scales we are
110:00 - still up here
110:02 - setting the speed and has scales as
110:04 - constant numbers
110:06 - and now we kind of have a problem
110:09 - because if i try to in this
110:11 - superintendent method at this speed and
110:14 - has scales
110:16 - then let me fix the typo first if i run
110:19 - this now
110:20 - we are getting the other problem that
110:22 - monster.init
110:24 - down here is the error we're getting
110:26 - right now
110:27 - monster.init takes three positional
110:29 - arguments but three were given
110:31 - meaning
110:32 - python in the monster class wants three
110:35 - arguments self health and energy
110:38 - and those we do get let minimize the
110:41 - fish for now so we can see what's going
110:42 - on
110:43 - we are getting health and energy and
110:46 - this is what this init method wants
110:49 - but besides that now we are also adding
110:52 - speed and has scales
110:54 - and for this the init method doesn't
110:57 - have any parameters
110:59 - so python is very unhappy because it
111:02 - gets too many arguments and it doesn't
111:04 - know what to do with them
111:06 - but this is a problem for us
111:08 - because we need those two arguments to
111:13 - pass into the init method for the fish
111:16 - but the init method of the monster
111:18 - doesn't have as many parameters so we
111:21 - have a problem here
111:23 - and to overcome this we need one special
111:26 - concept and that in python is called
111:29 - keyword unpacking
111:31 - and basically what it means is in my
111:34 - monster class
111:36 - after i have added all of the parameters
111:38 - i definitely know i need
111:41 - i want to add star star and then keyword
111:44 - arguments
111:46 - and that way any argument i get after
111:50 - the parameters i am going to store those
111:53 - in a separate dictionary
111:56 - let me actually print what we get so i
111:58 - want to print
111:59 - my keyword arguments without the stars
112:02 - for now
112:03 - and for these double stars python is
112:05 - expecting keyword arguments so all of
112:08 - the arguments for the init method here
112:10 - need to be keyword arguments meaning
112:13 - health.health energy is energy
112:18 - speed is speed
112:20 - and has underscore scales is has scales
112:25 - and now if i run this
112:27 - we are getting a dictionary with speed
112:31 - and has scales
112:33 - and this faults here we are getting from
112:36 - printing shark has scales let me remove
112:39 - that and try this again now
112:41 - so now we can focus on just a dictionary
112:44 - and that is something really useful
112:47 - because this we could use in here now
112:51 - and essentially what you have to do is
112:54 - call the unpacking operator again and
112:56 - passing in the keyword arguments
112:59 - and now if i run this again
113:02 - we are still getting the same dictionary
113:05 - so we are getting
113:07 - speed and we are getting hash scales
113:11 - but what happens now if we are calling
113:14 - this star again
113:16 - it turns each key value pair inside of
113:19 - this dictionary into a named argument
113:21 - meaning this speed under 20 is going to
113:24 - become a named argument
113:26 - and then this we are passing into the
113:28 - init method of the next class in the
113:30 - method resolution order
113:33 - and with that if i now print
113:39 - shark
113:40 - dot
113:41 - speed
113:43 - and actually display what we get
113:47 - i now get 120 the one we have specified
113:50 - in here
113:52 - and this is how you would work with this
113:55 - now for an actual example you would add
113:58 - a lot more quarks to all of these
114:01 - classes for example the fish would also
114:04 - have
114:06 - double star and keyword arguments and
114:08 - then you would pass this
114:10 - into the init method as well so in here
114:13 - quarks as well
114:14 - now in this case
114:15 - the keyword arguments is going to be
114:17 - empty if i print it keyword arguments
114:21 - and run this
114:22 - we're getting an empty dictionary
114:25 - because we don't have any additional
114:27 - named arguments that we have to worry
114:28 - about so this dictionary here is going
114:31 - to be empty well this dictionary
114:33 - actually
114:34 - but if we had more named arguments they
114:37 - would all go in there
114:39 - and this is then how you would deal with
114:42 - multiple inheritance
114:44 - and if again you are just starting with
114:48 - inheritance
114:49 - this really isn't something you want to
114:51 - worry about too much
114:53 - probably if you're watching this for the
114:55 - first time and you're still struggling
114:57 - with objects in general this is going to
114:59 - be way too much
115:01 - i would recommend just practice objects
115:04 - and simple inheritance for now
115:06 - and once you are more comfortable with
115:08 - them come back to this
115:11 - this sort of inheritance is only really
115:13 - something you are going to see once you
115:14 - get much more advanced
115:16 - especially for making games or for
115:18 - making gui's you probably don't need any
115:21 - of this whatsoever
115:24 - all of the games i have made so far have
115:26 - never used multiple inheritance they all
115:29 - use simple inheritance and they worked
115:31 - just fine
115:33 - but well at this point we have covered
115:35 - all the main parts of classes
115:39 - i guess at this point there is some more
115:41 - smaller things i do want to cover but
115:43 - they're all going to be fairly simple so
115:46 - let's talk about them in the next
115:47 - section
115:49 - alright for this part i want to talk
115:51 - about some extra parts for classes and
115:54 - those are things i couldn't really fit
115:56 - in in any of the other sections but
115:58 - they're all fairly simple but they can
116:00 - be quite useful
116:02 - and
116:03 - well let's do all of this straight in
116:04 - code i think that's going to be the
116:06 - easiest
116:08 - alright once more we have the monster
116:11 - class
116:12 - and this is just something i want to use
116:15 - to illustrate what we are going to do
116:18 - and let me create an instance of this
116:21 - monster with monster and for the health
116:24 - i want 20 for the energy i want 10. it
116:27 - really doesn't matter what number we go
116:28 - with here
116:30 - and now there are three things i want to
116:32 - cover
116:34 - the first one is private attributes
116:38 - the second one is has utter and set
116:43 - utter
116:45 - and the third one is going to be the dog
116:49 - string
116:51 - and once we have those we are basically
116:53 - done with classes
116:54 - and the first one is going to be private
116:57 - attributes which is just going to be an
117:00 - attribute inside of a class that cannot
117:02 - be influenced from outside of the class
117:05 - which may be something like an id number
117:07 - that you really want to make sure of
117:09 - cannot be changed from outside of the
117:11 - class to be sure that it doesn't mess
117:14 - with some other code
117:16 - and this actually isn't possible in
117:18 - python we are always able to change the
117:20 - attribute of a class
117:22 - so python developers came up with
117:25 - something else
117:26 - and this let me copy this comment here
117:29 - and in the init method of the monster
117:32 - class
117:33 - i want to create
117:35 - a private attribute
117:37 - and how you would do this is first add
117:40 - an underscore and then the name of the
117:42 - attribute let's say in this case i want
117:44 - to have an id
117:45 - and the number i want here could be 5
117:48 - but it could be anything it really
117:49 - doesn't
117:50 - matter and now this id by convention is
117:55 - not supposed to be changed
117:57 - but this is just a convention
118:00 - basically what you do with this format
118:03 - is you tell other developers that this
118:05 - attribute should not be worked on
118:08 - but you totally could work on it for
118:10 - example what i can do i can print
118:14 - monster and then underscore id
118:17 - and i get 5.
118:19 - meaning you can work with it but there's
118:22 - a very clear indicator that you
118:24 - shouldn't so if you ever work with
118:26 - somebody else and they added something
118:28 - like this
118:29 - you probably should not change it
118:31 - and well that is all you need to know
118:33 - about private attributes you could do
118:36 - the same thing for methods you are
118:38 - essentially following a naming scheme so
118:40 - this works with both attributes and
118:41 - methods
118:43 - all right next up we have has utter and
118:47 - set utter
118:48 - and what those two are doing is they
118:50 - allow us to check if a class has an
118:52 - attribute and we can also use it to set
118:55 - an attribute
118:56 - and the first one is going to be has
118:59 - utter and that is just going to be a
119:01 - normal python function
119:03 - and this one wants two arguments
119:06 - it first of all wants to have an object
119:09 - and besides that it wants a string
119:12 - with an attribute name
119:15 - and let's try this one i want to look at
119:18 - my monster
119:19 - and for my monster i want to check if
119:22 - the monster has health
119:25 - and this is then going to return a
119:27 - boolean that either says true or false
119:31 - meaning i can print all of this and i
119:34 - get true so this monster has the
119:37 - attribute health
119:38 - if i check for something that doesn't
119:40 - exist let's say a weapon i get false
119:43 - because the monster doesn't have a
119:44 - weapon
119:46 - and
119:47 - this you could then use an if statement
119:50 - for example if has utter monster health
119:54 - and if it has health i want to print
119:57 - the monster has
119:59 - and i guess then we can use an f string
120:01 - monster dot health
120:05 - and that is terrible spelling
120:07 - and let's turn this into an f string
120:10 - and add
120:11 - health at the end
120:13 - and now if i run this the monster has 20
120:15 - health and that is what we have set here
120:19 - and this is has utter it's a really
120:22 - useful way to check if a certain class
120:24 - has an attribute you are going to use
120:26 - this fairly often actually it's a really
120:28 - useful function
120:30 - and besides that set utter works in kind
120:34 - of the same way so let me call it set
120:37 - utter
120:38 - and in here we need three arguments
120:41 - first of all we need an object
120:43 - then we need a string of an attribute
120:47 - name let's call it attribute again
120:49 - and then we have to set a new value and
120:52 - this could be a string it could be a
120:53 - number it's really up to you
120:57 - i guess let's say again i want to look
120:59 - at my monster
121:00 - the attribute i want to set is a weapon
121:04 - and for the value let's give the monster
121:07 - a sword
121:09 - and now i can print
121:11 - monster.web
121:13 - pin
121:14 - and i get sword
121:17 - and this set utter is basically the same
121:20 - thing as calling monster dot weapon
121:24 - and setting this to sword
121:27 - these two things essentially do the same
121:30 - thing
121:31 - and now you might be wondering why do we
121:34 - have this kind of redundancy that this
121:37 - is
121:37 - kind of pointless at least similarly
121:40 - that we have this entire function that
121:42 - does something very obvious
121:44 - but the reason for it that this allows
121:47 - us to very efficiently create new
121:49 - attributes
121:51 - for example what we could be doing let
121:53 - me
121:54 - comment those two out
121:56 - and i could run a for loop
121:59 - and let me add a let's call it new
122:03 - tributes
122:06 - and this is going to be a tuple with
122:08 - lists
122:10 - i want to have for example a weapon
122:12 - and there i can have an x
122:15 - besides that i want to have another list
122:18 - with let's say
122:20 - armor
122:22 - and the armor could be a shield
122:26 - and finally i want to have one more list
122:29 - and this could be
122:30 - potion
122:31 - i could set something like mana or
122:34 - whatever you want to go for
122:36 - and now
122:38 - i can use that as a for loop
122:41 - so
122:41 - for
122:43 - attribute and value
122:46 - in new attributes
122:49 - i can call set utter
122:52 - i can pass in my monster in here
122:55 - and then i want my attribute
122:57 - and my value
123:00 - and if i run this
123:02 - we are not getting an error
123:04 - which is a good sign
123:06 - and now i can print
123:09 - my vars
123:10 - for the monster
123:13 - and i get
123:14 - the new weapon the new armor and the new
123:16 - potion
123:18 - and this way
123:19 - you can set a lot of new attributes and
123:23 - values for class by using this
123:26 - if you just used monster.weapon this one
123:28 - here this would not be possible
123:31 - and this is why set utter exists
123:34 - although you probably would want to
123:37 - create all of these attributes when you
123:39 - actually create the object itself so
123:42 - this isn't something you want to do too
123:43 - often although in some situations it can
123:46 - be really useful
123:48 - alright with that we have set utter and
123:52 - has utter
123:53 - and finally
123:55 - we have doc
123:57 - and doc is just there to explain what
123:59 - your object does
124:01 - that's really just about it
124:04 - you are getting doc or the doc's string
124:06 - to be more specific by calling monster
124:09 - and then dunder
124:10 - dock
124:11 - and in this case if i run this we get
124:14 - none
124:15 - for the simple reason that we have to
124:17 - create a dock string for our object
124:21 - and this you do
124:22 - first thing in the object and all you do
124:25 - in here is you set a triple quotation
124:29 - mark like this
124:31 - and then in there you are setting what
124:33 - you want for the monster for example i
124:36 - could write in here a monster that has
124:39 - some attributes
124:42 - and i am really bad at spelling monster
124:44 - for some reason
124:46 - and now if i run this print again
124:49 - and now i get a monster that has some
124:50 - attributes
124:52 - and this you could make significantly
124:55 - longer depending on what kind of class
124:57 - you have but this is usually what you
124:59 - want to set to explain your code to
125:02 - other people
125:04 - and especially if you work in a team
125:06 - with much larger projects it's really
125:08 - helpful to set something like this
125:11 - because well somebody else might have no
125:13 - idea what you're talking about
125:14 - what you can also do
125:16 - is let me comment out this print
125:19 - statement here and instead call help
125:22 - and i want to look at my monster
125:24 - if i run this
125:26 - i am getting a long list of different
125:29 - things
125:30 - and in here i can see lots of useful
125:32 - things
125:34 - for example i can see
125:36 - monster and its parameters i can see the
125:39 - dog string
125:41 - and i can see all of the methods inside
125:44 - of it
125:45 - and if you just find a new object you
125:47 - don't really know much about the help
125:49 - function is really useful
125:52 - as a matter of fact
125:53 - you can also pass normal python code in
125:57 - here for example what i could pass in
125:59 - here is just str for string
126:02 - and now python gives me the help
126:05 - function for strings
126:07 - and if i go all the way to the top
126:09 - there you can see
126:11 - basically that we have another object
126:14 - and the object takes one argument which
126:16 - is going to be a string
126:18 - then we have the dot string and this one
126:21 - explains what this object does
126:23 - and afterwards we have all of the
126:25 - methods and there are quite a few
126:27 - because strings are very complex objects
126:32 - and with that we have covered objects
126:34 - and classes i hope that wasn't too
126:37 - difficult but this is definitely
126:39 - something you do want to practice
126:42 - so hope that was helpful and i will see
126:44 - you around

Cleaned transcript:

in this tutorial we talk about objects and classes and well more specifically i will talk about what objects and classes are i will cover how to create and use them we will cover dunder methods and also simple and complex inheritance and finally i will cover how to use classes in practice and well let's get started by talking about what objects are in the first place and well an object is just a container for variables and function for example we could make a video game with lots of monsters and i think video games are really good way to explain objects so i will stick with that for this entire video but basically for the monster we are going to create we want to have variables and functions and in this case i want a monster to have some health some energy stamina and damage and you could add whatever else you want in here it's really up to you and then besides that the monster should also be able to attack to move to animate and again you could add whatever else you want in here and what you have to understand here is that these variables and functions only exist inside of this monster object it's very similar compared to the local scope of a function if we tried to get this health outside of the container it wouldn't exist because this health exists only inside of monster object although in terms of naming there's one minor complication and that is special names all that really means is that variables inside of an object are called attributes and functions in an object are called methods and that is more or less the only difference the only reason why this exists is so that we are a bit more specific with our language for example when you talk about health with somebody else for your game you really want to emphasize that you don't talk about a global variable you talk about the specific attribute of one object and one more thing methods should actually be familiar to you because you are using methods very very often in python anyway for example when you call the upper method on any kind of string you are turning every letter inside of that string to an uppercase letter and that is also a method and that is the same kind of method we are seeing here essentially a string in python is just another object with functions inside of it or methods to be more specific this also applies to integers floating point numbers booleans all of that stuff is basically just other kinds of objects that python creates but that's something we don't have to worry about for now now another thing that is really important to understand is that it is possible to have multiple objects for example i could create three different monsters and each of these monsters could have customized attributes these red pieces of text here so my first monster has 90 health 20 energy the next monster has 60 and 40 and the final monster has 40 and 10. so when you create an object you can give it custom attributes however this does not apply to methods and as you can see here monster 1 monster 2 and monster 3 all have the same methods and these can be customized to an extent but not nearly as much as the attributes that's something you do want to keep in mind but still each object has its own attributes and methods meaning that this attack here and this attack are not the same function or well the same method they always apply to their respective object and what you can also do is have objects interact with each other for example if monster3 attacks one stat 2 we could run some code to reduce the health of monster 2 from 60 to let's say 20. and that actually brings us to a really important topic and that is object oriented programming or oop in short and all that really means is that you are organizing your code via different objects and then you make these objects interact with each other and this approach is basically how almost all large projects are made in any programming language or at the very least any modern programming language meaning if you don't understand classes you will be very much lost and well you will have no idea what you see when you look at larger examples of code here we have a couple more objects we still have monster 1 and monster 2 but now we also have a player we have an obstacle and we have a menu and all of these have slightly different attributes and slightly different methods and just to talk about how these different objects can interact with each other the one we have already seen is that monster 2 could for example attack monster 1 and then monster 1's health be reduced from 90 to 60. and if monster 2 is attacking it might reduce its own energy from 40 to 20. so attacking isn't free for the monster what we can also do is have an object without any methods like the obstacle here and all the obstacle is is well an object with a position and a size and this we could use for example with the move method of any of the other classes so the player and the monsters all have a move method and this could interact with the obstacle and let me clean this up something even more interesting if you look at the player this one here and the menu those two do look very much connected because the player has one method called menu and what this one would do is to create or at the very least open a menu and then when we create the menu we are passing in the player itself so this player here is going to be passed in as one attribute of the menu object and this is totally fine to do you can totally add a function or an object inside of another object as an attribute and then this select could for example change the weapon of the player and we could close the menu as well and i hope this makes sense the main thing you have to understand is that objects can interact with each other and this is how you want to organize code it makes it very easy to work with and especially for larger bits of code this approach is essentially mandatory or at the very least it's the easiest way to organize it and let's actually do a practical example here is a zeldalike game that i made a while ago and basically everything you see on the screen is an object for example right in the middle we have the player and that's one object then we also have this raccoon here and this spirit and each of those are one object and beyond that each of these flames here is its own object and these are only created when the player is attacking with some magic and finally in the top left the bottom left and the bottom right you can see some ui elements and they are all part of the same object and this object is very much related to the player so those two work together very closely and besides that each of these pillars and trees and rocks and statues they are all objects that i created just for this game so i hope that illustrates how useful objects are that make it really easy to group together code chunks that should belong together and for a bit more detail the raccoon for example has three attributes health speed and damage and the methods attack and move and all the other objects would have similar attributes and methods and with that we have objects now the next question is what are classes and this is fairly easy to explain as well the class is basically a blueprint for an object meaning whenever we create an object we first have to create a class and a class can also accept arguments to customize the object we are creating for example this would be a class we have a class and this class has two attributes health and energy and right now the value for both of these is not being set this we do when we actually use this class to create an object but this class also has two methods attack and move and those do not change and basically what we're doing is use this class to create the object and in the process we are giving it the specific values for health and energy so in this case the monster is going to have 90 health and 20 energy and this process we could do as many times as we want for example earlier you have seen monster 1 we had monster 2 monster 3 and we could continue with monster 4 5 up to an unlimited number of monsters and that is essentially the main idea all you really have to understand is that we always need a class to create an object now what we can also do with classes is that one class can inherit from another class and the resulting objects will have attributes and methods from both classes for example let's say we want to create a shark class and this one right now only has speed for the attribute and byte for the method and this class will be fairly limited because we well don't have any attribute for health or for energy and we also don't have any kind of method for move or attack but we don't need to because what we can do is have this shark class inherit from the monster class and this means this shark is going to get the health and the energy from the monster parent class and that is also going to get the attack and the move from this class as well meaning when we actually use the shark class to create a shark object we are going to get health energy and speed for the attributes and attack move and byte for the methods and i think i should use better colors here in the shark class health and energy are coming from the monster class same with attack and move those two are coming from the monster class and then speed and byte are from the shark class and this would allow us to reuse code quite extensively for example we could have a lot of different monsters we could have a shark some flying enemies some armored enemies lots more and they all inherit from this one monster class and with this approach we would save a ton of writing in terms of code and on top of that if we change the move method for example it would affect every single other class as well which is very useful if you want to make some changes and make it affect every single other class and especially with larger projects this is just about the only way to manage them and let's do an example again here is the screenshot from earlier and we have a monster class we have another monster class and those two have the same attributes and methods although with different values and besides that we also have the player and what is really important to understand here is that all of these inherit from the entity parent class and this for example contains the method for movement because all of the monsters and the player move in the same way so they could share this method quite easily and just to emphasize it i do want to go over the advantages of classes and objects and the first point here is that classes and objects help you organize complex code and the second point is related classes and objects also help you to create a reusable code and just from these two points i hope it becomes obvious that if you want to create some really large projects let's say a really good looking game you need objects and classes without them it's still possible but significantly more difficult besides that classes are also used everywhere meaning if you don't understand them you will be very much lost as a matter of fact in python there are quite a few modules that require you to use classes for example pygame tkinter and matplotlib respectively the module you use for games for gui's and for data analysis they all work with classes primarily so if you don't know how to use it you pretty much cannot use these modules or at least you could only use a very small part of them and there's one more point that i haven't mentioned yet and that is that classes make it much easier to work with scope i will talk about this in more detail later but if you struggled so far with getting information in and outside of functions you will really like classes that make it very easy to work with different levels of scope so these are the arguments where you would want to use classes and objects however you can write code without using objects at all and this is very common especially for beginners and let me illustrate the problem here the yellow line is the need for classes and especially when you start writing code let's say you are somewhere here and your average program is something like 50 lines of code in this case there really isn't any need for classes because well your code is very simple and there isn't any need to organize complexity however the longer and more complex your code is becoming the more you will need classes and this ramps up really really fast but as long as you are in this area here it well it's very tempting to never use a class and ignore them entirely and this especially as a beginner you really want to avoid so even though when you are here i would really recommend you to use classes even though it's not strictly necessary in your example just to practice for more complex code because when you are an actual software developer you are never going to write just 50 lines of code most of the programs you are going to work are somewhere here with a few thousand lines of code let's say 2000 and if you are up here and you don't use classes you are going to be in a lot of trouble all right with that we have the theory of objects and classes and for the next part we are actually going to create and use objects so let's have a look at some code here i have a completely empty sheet of code and the first way i want to do is to create a class and this you do with class and then the name of the class in my case i want to go with monster and here already we have to cover something important and that is the naming scheme so far in python what you probably have written is something like monster and generally you always used the snake case styling for any kind of text so why is this different here and well in python by convention last names are always written in the camel case so camelcase looks like this where you don't have any spaces between words or well any underscores but any word starts with an uppercase letter and this is different from normal python where variables are written in snake case where everything is lowercase and a space is an underscore and this isn't strictly necessary you can call a class monster with a lowercase m just fine this is purely convention but all the other python requirements for naming still apply for example a class couldn't start with a number and we also couldn't have a space in between so we don't have to learn any new naming scheme now next up what you have to do is a colon and now in here we can work on the attributes and methods of our class and for now i just want to create some basic attributes let's say i want to give this monster some health and for now i want to have specific numbers let's say 90 i want to have energy and this one should be 40. so now we have a class and what we have to do now is turn this class into an object and this we do by typing the name of the class and then calling it by using brackets again very similar compared to functions and this is going to return the object so we have to capture that in a variable and this very often is written like this and here i hope you can see why we have the different naming schemes to python this name here and this name here are two completely different things because one starts with a lowercase the other with an upper case although to us as the programmer we can tell that those two are related because they basically have the same name and for that reason we are usually writing class names in camel case and variable names in snake case it makes it very easy to connect these two and clearly indicate that they are connected although you don't have to do any of this you could totally call this i don't know hamster and this could be lowercase it's totally fine all of this is just convention although you should follow conventions they are there for a reason but i can run the code now and i am not getting an error that's a good sign and now what i can do i can use print and monster dot let's say health and now if i run this we are getting 90. and this knight here is coming from this health and the same would also work for energy in just the same way so we get 90 and 40. now just to emphasize that both this health and this energy only exist inside of this class let me print health by itself that is horrible spelling health and if i run this python is going to give me an error and we have name health is not defined meaning python cannot find this health anywhere in the global scope which makes sense because there is no health in the global scope we only have health in the scope of this monster class and let me add some comments here to make this a bit more readable we have attributes and besides that i also want to create methods and those work kind of like functions we again need the define keyword or def and now we need a name for our function and for that we have the exact same naming scheme for normal functions for example attack would be a perfectly fine name and after that you need a colon and then let's say for this attack method i want to keep it simple and just print the monster has attacked and now i can call monster.attack and don't forget the brackets and now if i run this we are getting an error and this error says that monster.attack takes zero position arguments but one was given and this is probably very confusing because when we called this method here we didn't pass anything inside of it and the method itself doesn't have any parameters so why is python being so weird here now the reason why this is happening is that whenever we call a method so a function inside of a class what is going to happen is that python automatically passes a reference to the class as the first argument into this function or this method to be more specific in this first argument we always have to capture with some kind of parameter meaning a method always needs at very least one parameter and that parameter is a reference to the class itself for example i could just write monster in here and if i run this now we get the monster has attacked and let me just print what we actually get so i want to print the monster we get as an argument in here and what we get is main monster object at somewhere in our memory and well in my case i don't really care about this monster so let me remove the print statement but i do have to keep this first parameter however once we have the first parameter i can add as many custom parameters as i want for example i could add the amount of damage here and i could let's say print the amount with an f string and i want to say the amount of damage was dealt and now when i call this method down here i can pass in any number i want and i get the monster as attacked 40 of damage was dealt that does not make sense in terms of grammar let's try this again but the damage was stilled that feels much better so the one thing you want to remember is that for any kind of method you always need a reference to the actual class as the first parameter but after that you don't have to worry about it anymore and you just use it like any other function however you could also use this reference to the class what you could be doing for example is print and let me just print monster.energy if i now print this i get 40 again meaning this monster energy here is looking at the first argument it gets and this is a reference to the class itself so from there we can get this energy and also this health if you really wanted to and what you could also do is increase this amount so monster.energy minus equal 20 and if i print it now we get 20. and i hope you can tell how useful this can be because if you imagine that this monster here is the global scope and these attributes are global variables if this attack was just a normal function then this would not work because you would be creating a local variable that wouldn't work with the global ones but because of this first argument that the method always gets we can influence variables or well attributes outside of this function which is incredibly useful so i hope this kind of method here makes sense as a matter of fact let's practice this one i want you guys to create another method for this monster and this one should be called move and it should accept one arguments besides the reference to the class itself and that is the speed of the movement and then inside of the method you should just print that the monster has moved at a certain speed it doesn't really matter what you put in here as long as it is working so try to figure this one out yourself all right let's try together now i want to create a method called move and in here i want to have speed as a parameter however what we have learned from the attack method is that we always need a reference to the class itself as the first parameter meaning the first parameter here should be something for the monster and it really doesn't matter what you call it so i could even write something in here it would still work and now in here i can print monster has moved and let me add another line with an f string that says it has a speed of and then the speed and let me fix the typo and now i can call monster dot move and add let's say a 10 in here and let me comment out monster.attack and let's see what we get the monster has moved it has a speed of 10. so all of this seems to be working just fine so all of this seems to be working very nicely now obviously calling this first parameter something is a bit confusing and as a consequence in python there is a convention that this first parameter is always called self and this applies to all of the methods meaning this is what you are going to see most of the time and what i am going to use as well you don't have to do it but i think it makes the most sense although i do want to emphasize that this parameter here and this parameter here have no relation whatsoever they are entirely separate although that being said they both reference this monster class here but it is totally fine to call self here and self here the names are not in conflict with each other and all right with that we have the very basics of using classes and objects although right now we do have a problem that our monster always has the same health and the same energy so even if we created multiple monsters so what i could be doing is monster 1 monster 2 monster 3 and let me get rid of this one here all of these monsters would have the same amount of health and the same amount of energy and they all have the same attack and move method which is fine to an extent but i do want them to have different amounts of health and different amounts of energy and to implement that we need another concept and that is called dunder methods so let's talk about that one let's talk about dunder methods and the dunder here just stands for double underscore meaning we are talking about a double underscore at the beginning and at the end of the method but it's important here we are still talking just about methods so essentially we are calling a specific kind of function and let's talk about why it's special a dunder method is just another method the thing that makes it special is that it is not called by the user instead it is called by python when something else is happening for example there is the dunder edit method and this one is called when the object is being created another example is the lan method and this one is called when the object is passed into the len function and besides that we also have done the apps and this one is called when we are passing the object into the apps function and that is really the entire idea it honestly isn't that complicated the most important dunder method you have to understand is done their init this one you are going to be calling all the time but let's actually do all of this in code that should make the most sense all right here we have the class i created earlier and what we have seen earlier as well i can create monster 1 and that is just going to be the monster and i can also have monster 2 and if i now print monster 1 dot health and monster 2 dot health we get the same number because we always set health to 90. there's no way to customize it and basically what i want to do is as soon as the class is being created then i want to create these different attributes and instead what i want to do is when this class is being created i want to create this health and this energy with custom values and for that to work we need to define a dunder method and the one we need is called dunder init and this is just going to be another method like attack and move we are just calling a method meaning the first parameter here has to be a reference to the class itself and for now let me just print the monster was created and do pay attention i am never calling the init method myself but if i run this we get the monster was created the monster was created and then 90 and 90. and what that means if i minimize this a bit every time we are creating a monster so first here and then here then we are calling this dunder method and this standard method we can also give some parameters for example we could specify in here the amount of health and the amount of energy we want and well i hope you can see where this is going basically what we can do now is we can set self.health to whatever health parameter we pass in and we can do the same thing for energy and the names here might be a bit confusing so let me add a bit of white space and explain this self.health here is referring to this self.health of the monster class whereas this health here refers to this parameter and the important point here is self because this one specifies where health belongs to i hope this makes sense this is something you see fairly often let me remove the white space again and now when i am calling the monster i can either pass in arguments or named arguments let's say for the first monster i want health 10 and energy 20 and for the second monster i could specify health being 50 and energy being 100. now if i run all of this we get monster 1 health is 10 and monster 2 health is 50. and this 10 here refers to this 10 and this 50 is referring to this 50 here meaning now we can have custom attributes and what is even better since this self is a reference to the class itself we can just create the attribute in here which means we don't need those lines at all it would still work without them if i run this now this is still working just fine and this is what you see most of the time where the class by itself doesn't have any attributes we only create attributes when we are creating the class with the init method or the done there in it method and then instead of the other methods we are calling self all the time to refer to the class and i just realized this should be self instead of monster so we're capturing this self here and what you are going to notice is that you are going to write self all the time it is a little bit annoying but well it is manageable and well with that we have the first init method but there are quite a few more although those you wouldn't use that often and just to keep things simple let me get rid of monster 2 and i don't want to print anything at all another danda method i talked about in the introduction is len and this one needs self and no other parameters and in here we just want to return something let me return the number five and what this one is going to do is if i call len and pass in monster one in there and this len just as a quick recap if i pass in any kind of string into len let's say test and if i print the result i get 4 or the number of characters inside of the string i guess i could also pass a list in here that might make a bit more sense so i have a list with five entries and the length of it is five but what i can do now if my monster has a len method i can pass monster 1 in here and it would return 5 as well and any number that is being returned here is going to be passed into the length function and i guess for something slightly more relevant instead of returning a number i could return self.health and now if i run this i'm getting 10 or the amount of health my character has which is 10 right now and another example we have seen in the introduction that works in the same way is abs and we need dunder on both sides and in here self and again i have to return something so return and for this case let's say self.energy and if i copy this and pass it into absolute i get 20. now usually absolute is if you have a negative number and you want to make sure it's always positive that's what it does but well you could theoretically do whatever you want with it now what you can also do is one specific function in python and that is called dir short for directory i think or directory listing or something like that basically what it does you pass in an object and then you want to print the result and what you get from that is all of the dunder methods and at the end the attributes and the normal methods and in here you can see a lot of stuff actually and what you have to understand here is every time we are creating an object python already gives it some dunder methods for example here we can see the dir method and this one is necessary for the ear function to work it kind of works like the len method the one we have created ourselves or the abs function and i guess the one we have just created is the init method this is the really important one and most of those you really don't want to worry about because well they're just there to make the class work but we don't really have to worry about them although some dunder methods in here can be very useful for example dunder digt is well it's kind of a dictionary but not in the way you would expect basically how you would use that one let me print it right after the monster i want to print monster 1 and then dot dander dict and in here this is the one exception where this is not a method this is just an attribute so no brackets afterwards and this one gives us all of the attributes of the method inside of one dictionary can be quite useful sometimes although you wouldn't be using it too often now another way to get to this dict here is to let me duplicate the entire line you can call the varus function and pass in monster1 and this one is giving us the very same thing although i have hardly ever used either of these most of the time you just don't need them with that you should understand dunder methods reasonably well now there are quite a few dunder methods that get a bit more advanced i only covered the really fundamental one some other examples of thunder methods is for example dunder call and in here we only need one parameter self and in here we can return something else again and let me distribute dunder on both sides let's say the monster was called and what this dunder call does is it essentially turns our object into a function meaning i can call monster 1 and then add brackets afterwards and if i do that we are not getting anything because i would have to print what i get so i have to put brackets around it and call print and now the monster was called i guess a cleaner way of doing this is to return nothing and just print this string so now if i call monster1 we get the monster was called and nothing is being returned and when you create a function in python it basically behind the scenes creates an object with this standard method here and this we can just create ourselves it really isn't that complicated and what we can also do is to add and subtract numbers and this you would for example do with dunder at and in here you need two parameters first of all self as always and then you need some other number and what you can do in here is return something let's say i want to self.health and then plus whatever other number i get and now that i have that i can print monster 1 last pen and if i run it i get 20 which is if i find it so the health of my monster is 10 and i add 10 towards it so i get 20. and i guess to make this a bit more understandable let's add 55 in here and i get 65 which is 10 plus 55 and well that is a couple more dunder methods they can be incredibly useful although most of the time you are only going to use thunder init this is the one you absolutely have to understand but i guess they don't really get that much more complicated so it shouldn't be too hard alright now for the challenge for this part i want you guys to do some research because there's another dunder method that is called str and i want you guys to look up online what it does and how to use it in code all right here we are in the official python documentation and there you can see dunder string or dunder str and basically what it does it's called by the str object built in function format and print to compute the informal or nicely printable string presentation of the object basically what it means is that this object is going to return some text so let's have a look at it here we are back in the code and i only need one parameter and that is self and now i have to return some kind of string and the string i want for this one let's say a monster and what i can do with that let me get rid of this print statement and instead i want to print str or monster1 and this is going to return a monster and we don't even need this str because print is trying to find a string so let me duplicate this line and remove the str and just have monster one if i call this now i still get a monster and this can be a really nice way to look at your objects and see what they are doing because if we didn't have this done their method let me comment it out and run this again all we get is a monster object which really isn't that useful and obviously this str can return a lot more than just a simple string for example we could have an f string with health that says self dot health and energy that says self dot energy and now if i run this we get quite a bit of information by just passing the monster or the object into the print statement so this sdr can be really really useful and with that we have covered quite a few dunder methods if you look online you can find even more but well most of the time you're not going to need them this is very often a fairly advanced topic except thunder init this is the one you are going to use a lot all right with that we have dunder init methods covered and if you understand all of this so far you can actually understand python itself quite a bit more let's talk about this one in the next part and the one thing i think that confuses beginners quite a bit is that every single thing in python is an object meaning every time you see a string or integers you are going to see an object just like the objects that we have created so our monster and this even includes functions which are just objects with the call dunder method and i'm going to show you some examples in just a second but most of what i will cover here isn't really important i just want you guys to understand how it works so you don't get confused later on and there's another thing that i believe is very often confusing and that is the difference between a function and a method and the reason why this is confusing is both just execute a block of code so in terms of functionality they basically do the same thing however the difference is that a method always belongs to an object it doesn't matter if the object was created by us or by python and a good example here would be using a string so if we have a function this would be len for example and we can pass a string into it this will return 4. and a method would be something with dot and then upper for example for string returns uppercase letters for this string and that really is the entire difference that's the main thing you have to understand and it doesn't matter if we create the method ourselves or the function ourselves or if it's created by python and the reason why these are different for example is that the lan method could work for lots of other things as well for example you could pass in a list in here you could pass in a dictionary or a tuple it would still work with different data types whereas upper only works for strings you couldn't add a list with upper that one would not work so it makes sense in this case that upper only exists as a method for strings whereas the ln should be a function so you can pass in different kinds of objects in here and they would all work you could perfectly find create some kind of len method for test and it would work just fine although then you would also have to create a lan method for lists for dictionaries for tuples for all of that stuff and it would be quite labor intensive so all we're doing here is to keep things more efficient but all right let's have a look at some code and let's have a small deep dive into python here i have a completely empty sheet of code and what i want to create for now is create a test variable and this one should have a string let's call it a doesn't really matter what it is and what i can do now i can call my print bir and pass in my test in here and if i run this now i am getting a bunch of dunder methods and after they are over starting from here i get a couple of methods and attributes now the dir method doesn't separate between methods and attributes so we just get one big list but well basically what we get here is an object and anything in here you could just call like upper or title or strip all of these are very simple methods and along with that we have the len dunder method and this is what's being called when we are passing this string into the len function and besides that what you can also do let me get rid of this test and instead create define test and then here i let me just add pass so this is a function with the name test and i'm still printing dir test so if i run this i am getting another object and this object is special because it has a call dunder method meaning when we're adding brackets afterwards it is being executed and that's basically what a function is in python it's just an object with the dunder call method it really isn't much more than that although we do have a couple extra things that make this a bit more special but that's the main idea and if you really wanted to you could even store this function inside of a variable and this works because the function is an object so this is just going to be an object meaning if i now print a we are getting the same outcome although what we can even do now let's call it another attribute that is not how you spell that and this could just be 10. and now if i run this our function has another attribute and again this is working because functions are just objects although in practice you wouldn't really do this there's no reason for it but what is much more common is that you are passing functions or methods into other objects so what is much more common let's say for example a simple add function and this one takes a and b and is going to return a plus b obviously this still isn't particularly useful but i just want to illustrate what it does and now i can create a class and let's call it test and in here for the dunder init method i want to have self and i want to add an add function and now inside of this dunder init add function i can set an attribute self dot add function and this should be the argument we get from the parameter add function and now when i create this test i have to pass in one function and i want to have this add function here so i'm going to add it in here and let me use a named argument so it's a bit easier to see what's happening and in here it is really important that you don't add brackets because we don't want to call this function we want to get the function itself so the object of the function not what's being returned and if i run this now this is working just fine and even better what i can do i can call test dot add function and i can pass in let's say one and two and this is not doing anything because we're not printing anything we're just returning something so if i put all of this into a print statement now we are getting free and i hope all of this is making sense this is a really important thing to understand right now this here is creating an object of a function and this object we can pass around for example we could pass it inside of a class and this would work just fine and then inside of the class we can store it inside of an attribute and then call it from outside of the function this is working just fine there's no limitations on this and this is something you really want to practice because passing around functions is a really important thing to understand and i guess since this is really important we should practice this with a slightly larger exercise and let me add some comments that should help quite a bit first of all i want you guys to create a monster class with a parameter called func and this func should be stored as a parameter that's the first step after that i want you guys to create another class and this one is called attacks and this has four methods we have let me put it on another line we have byte strike slash and kick and for each method you just print some text basically whatever you want i would recommend to print kick slash strike and byte but it really doesn't matter and let me add proper white space here and then for the final step i want you guys to create a monster object and give it one of the attack methods from the attack class and remember here that methods are basically just functions the only difference is that they are part of an object so this should work kind of similar compared to what you have seen here but well it's going to be slightly different so experiment with this and see how far you get all right let's try together now first of all i want to create a monster class and this i do with class monster and in here i want a dunder init method that needs self and a funk and this funk i want to turn into an attribute so self dot func and i want to capture the parameter or the argument we get here in there and this is covering all of this next up we have to create another class so class and this one is called attacks and in here we don't need a dunder indeed method instead i want to create define let's start with byte and we need self as always and in here i just want to print byte and since we need four attack methods let me copy this a few more times and now besides byte i also want strike then i want slash and finally i want kick and i think you can already tell why this might be useful it's a very neat way to organize all of your different functions if you have a really large game with hundreds of different attack methods this may actually be really nice to organize all of this all right now finally i want to create an object of my monster so monster in lower case and then here i want to have my monster and now we have to define a function now this you could approach in a couple of different ways although there's one way that is definitely wrong and it's very tempting to go this way you could write something like attacks and then dot byte and if i run this code we get a 3 and this 3 comes from up here so let me comment out all of this and if i run this again now we can't see any difference but if i run monster.funk we are getting that attack.byte is missing one required positional argument and that is self and this is a reasonably common error the reason is that this here is not returning an actual object it's returning a class and this is confusing python now an easy way around this is to actually turn this class into an object by calling it so adding brackets afterwards and now if we run this we are getting byte and basically what is happening here think of this in terms of return statements when we are calling this attacks it's returning an object and then inside of this object we are getting the byte method which is this byte method here and if you don't like how this looks what you could also do is create a separate object let's call it attacks and in here i could add this attacks and then call attacks.byte and we will get the same result and this is something we are going to explore quite a bit more that you pass different things around different classes so that in this example we are taking the byte method and passing it into another object and this is getting incredibly powerful and really important to understand if you want to understand more complex code because a key part of objectoriented programming is that you work with different objects and make them interact with each other and this example here so this part down here is one example to make classes interact with each other and i would really recommend you to practice this in your own time it's really going to be helpful but all right with that we have covered a really basic deep dive into python although i do want to practice this a bit more and there's one important topic i do want to cover and that is going to be scope in terms of objects and classes let's talk about that one in the next section all right so let's talk about classes and scope and this is one of the really powerful parts of objects that make it really easy to work with this scope but let's talk about it basically every method so every function inside of a class has a reference to that class and because of that it's really easy to get and change class attributes and because of that methods are much easier to work with than normal functions meaning they rely much less on parameters the global keyword and return statements although you can still use them if you really want to and sometimes that does make sense but you are going to do this much less often and what is even better objects can be influenced from outside of the object itself and even from the local scope of a function basically objects you can change wherever you want there is no limitation on the scope for them which makes it even easier to work with them but i guess let's have a look at all of this in code that should illustrate this the best here i have a completely empty sheet of code and first of all i want to illustrate the problem so let's talk about scope again let me add a comment scope problem and let's say i have a game and i have some kind of health that right now is 10. and for this health i want to have a function let's call it update health and this one takes an amount and all it really does is it adds that amount to the health a super simple function just about the simplest function you could write now what i want to do let me say i want to print health then i want to update my health with 20 and then i want to print my health again and if i were to run this what do you think is going to happen just think about it and well if i print it we are getting an error and what python is unhappy about is that we have a local variable health referenced before assignment and what is happening here is that this health to python is a local variable let me remove the error messages they are getting a bit annoying that's easier to work with essentially this health only exists in the scope of this function here or in other words this health here and this health here to python are two completely separate things and then when we are trying to update this health with some amount i even cannot find any starting amount for this health as a consequence we are getting an error and there are a couple of ways to get around this for example we could use global health that's probably the easiest one and now this would work although you could also use return statements but it really isn't the cleanest way to work with this so this is not great so let me comment it all out and let's do the same thing with classes so let me create a class monster again and in here i want to create a dander init method that needs self health and energy and then as always i want to set self.health equal to health and self.energy is going to be energy and now let me create an object from this class and let's give it a health of 100 and energy 50. it doesn't really matter what values you put in here so now i can print monster.health and we are getting a hundred so this one works just as expected and now what we can do we can just get monster.health and add let's say 20 to it and if i now print monster.health again we are getting 120 ie the sum of 120. and what is even more powerful let me uncomment this function up here and now instead of the health i want to get my monster.health and update the amount and this would still work if you are using an object so let me get rid of these two lines here and instead call the function update health and let's say i want to raise this by 20 again and now if i print monster.health after calling this function i get 120 meaning even inside of the local scope of a function you can still update anything inside of an object but the simple reason that here python is very clear about what kind of object you're talking about this monster is not going to become a variable in the local scope and this monster could be updated anywhere it could be in the global scope it could be the local scope of a function it could be in the scope of another method it could even be inside of the object itself so this monster python just doesn't care which makes it really easy to work with so i guess one thing you do see fairly often is inside of a class you have something like let's call this one update energy and then here we need self and let's add an amount in here as well and all i really have to do to update this self.energy would be to first target the attribute itself so self dot energy and then plus equal amount and now i could just run monster dot update energy pass in anything i want in here and then print monster.energy and we are getting 70. and again here this is a very easy way to work with scope you don't have to worry about return statements you don't have to worry about global all you do is target the attribute and then you set it to a new value or update whatever you want that's it it's super easy to work with although if you wanted to you could use a return statement as well for example if i wanted to set energy and in here i want self and energy and let's say for this one i want to create a new local variable that i call new energy and this is going to be energy times two and then i want to return this new energy and now in my init method instead of setting energy straight as the attribute i want to call self.set energy and pass in the energy and now let me comment out this line down here to update the energy and just get the energy now we're getting 100 which is this 50 here this 50 we are passing inside of this energy here from that energy we are passing it inside of another method inside of the monster class and this method is down here we are getting one parameter and this we are doubling and assigning it to new local variable inside of this method and after that we are returning the new energy and this new energy is going to become the attribute self.energy kind of a roundabout way of doing it but it is possible to do all i really want you to understand is that you can still use return and parameters just like with any other function although most of the time you don't really need it a better way for this one would be to remove this part entirely just call set energy and then self dot energy is going to be new energy this would work in exactly the same way although it is much cleaner to read so if i run this we are still getting a hundred and i hope you understand why self is really really powerful it essentially bypasses all of the scope issues very efficiently all right let me get rid of all of this because i don't really care about it and instead i want to set self.energy back to energy all right now with that let's do an exercise to practice this and what i want you guys to do first of all create a hero class with two parameters one is damage and the second one is a monster which is going to be this object here so this object you want to pass into another class as an argument and second of all the monster class should have a method that lowers the health and i guess you can call it get damage and this one should take an amount and then this amount you would reduce from the health of the monster and finally the hero class should have an attack method that calls the get damage method from the monster and let me put this on the second line and the amount of damage is hero dot damage which is going to be the damage you specified up here which should be an attribute so i hope all of this makes sense try to implement this yourself and see how far you get alright let's try it together now first of all i want to create a new class and this is going to be hero and the hero needs a dunder init method and here we need self and besides that i want damage and i want a monster and let me add a bit more white space there we go now i want self.damage to be damaged and i want self.monster to be monster and let me spell this correctly there we go and this would then be step number one and for step number two let me move it up a bit so it's easier to see what's going on the monster class should have a method that lowers the health and this i want to call get damage so define get underscore damage and then here i need self and i need the amount and all i really want to do in here is self dot health minus equal whatever amount we specify and this get damage i want to call from inside of the hero and this brings us to step number three and this right now we are still inside of the hero class which you can see by the indentation i probably should have actually mentioned that for the class we always define something by one level of indentation in here i want to now create let's call it an attack method and this one itself and nothing else and all i really want to do in here is get myself.monster and this self.monster is the monster we specified up here and on this monster we want to call get damage and all we really have to do for that is call get underscored damage and now we have to specify how much damage we want to cause to the monster and for that i want to get the damage of the hero and all we need for that is specify self dot damage and we are done and if you just read through this i hope this really illustrates why this makes a ton of sense it's basically a normal sentence we want to get the monster we want to cause the monster some damage and the amount of damage we want is selfdot damage so the damage of the hero and now with that all we have to do is to actually create the object of the hero meaning i want to create a hero object and this is going to be hero and then here we need damage let's say damage for the hero is 15 and then we need a monster and the monster is going to be the monster object we created just a second ago this one here and this we're just passing in here and now let me print monster.health and if i run this we are getting a hundred which is this 100 here but now if i call hero dot attack and this one doesn't need any arguments and afterwards i can print monster.health again and now if i run this we get 85 which is 100 minus 15. this is how this 85 comes about and to get to this point to lower the health of the monster we just had to call one method and that's it all we are really doing in here is we are passing different objects around and make them interact with each other and since we don't really have to worry about scope this is very easy to implement and again this is something you really want to practice on your own and try to work on this more to make sure you understand it but right with that we have covered scope and i guess for the next part let's talk about inheritance and inheritance really just means that one class gets the attributes and methods from another class or multiple classes and i have already shown an example earlier and that was we had a monster that we have already seen multiple times with health and energy and this right now is called a parent class and the reason why it is called the parent class is because there's a child class and this one was the shark and this shark by itself only has a speed and a byte method and what i want to happen is that the health and the energy of the monster parent class comes into the child class and the same for the method so attack and move should also be available inside of the shark class so that when i actually use this to create an object the shark object has health energy and speed for the attributes and attack move and bite meaning we are combining the monster and the shark class to create the actual shark object and the reason why we are doing this is this makes it very easy to reuse code let's say this monster here could be the parent class to every monster in our game and if we have this we never have to set the attributes health for energy for any other monster they are always available for every single class because they all inherit from this monster and obviously this is still a very simple example in an actual game the monster class might have a few hundred if not thousands of lines of code and then it really makes sense to reuse code as much as we can because then we don't have to create new classes all the time with all of these methods that we have to type over and over again and then on top of that if we wanted to make changes to how things move in the game so this method here if we didn't use inheritance and we want to make change how things move in the game we would have to change possibly hundreds of different move methods for every single monster but if we use inheritance we don't have to if we change one move method we are changing how every monster in the game moves so i hope that makes sense and one important concept here is that the class can inherit from an unlimited number of other classes this could look like this in here we could have a parent class 1 a parent class 2 and a parent class 3 and then the child class would have the attributes and methods of all of these parent classes and you can also turn this around where you have a parent class and this parent class is being inherited from by an unlimited number of other classes and this would look something like this you have one parent class and you have one child class a second child class and a third child class and all three of those would have the methods and attributes of the parent class and this here for example could be the monster class and then this one here maybe the shark class and let's say this one here could be i don't know like a bird class or something now there's one thing you do want to be aware of though and that is that inheritance can get very very complex up to a point where it really doesn't become fun to work with them and this is also the part where beginners really start to struggle because well i'm going to show you an example later on but this can get very very complex and really hard to work with fortunately this is fairly rare most of the time you just need simple inheritance and this one is really easy to implement and this one might be something like this the example we have already seen and this one should be very easy to follow so for this section i just want to focus on implementing this part here and i guess let's actually implement this one in code and let's see how this is going to look like alrighty so here once again we can see our monster class and from this monster class i want to get a shark class and this one should get the health the energy the attack method and the move method of this monster class we want to put all of this inside of the shark now passing in the methods is very simple but the health and the energy are going to be a bit more complicated so for now let me simplify things a tiny bit by commenting out the dander indeed method and instead setting health to something constant let's say 50 and energy to 100. the reason being that init is a bit more complicated for inheritance so i'm going to ignore this part for now just to keep things simple but we will implement this in just a bit all right now for this shark i want to create an init method by itself and this one needs self and in here i want to set this speed and now what i want to do is self.speed is going to be speed and this way we are getting our attribute and besides that i also want one method and that method i have called byte and in here we just need self and let me print the shark has bitten or whatever you want to put in here and this by itself would be a functioning class but also a very limited class because it only has a single attribute and one method it doesn't really do all that much so how can i get all of the monster attributes and methods inside of the shark and to get inheritance what we have to do is add brackets after the shark or the name of the shark class and then here we have to pass in what class we want to inherit from in my case this is monster and for start this is all you need meaning now i can create my shark by calling shark and i have to pass in a speed for the shark and let me just say i don't know 120. and now if i print my shark all of this works just fine and we are getting an object but what i can do now is get my shark dot health and this is the 50 we have set all the way at the top here i can also get my shark speed this is the 120 we set for the shark in here and besides that i can also call shark dot byte we get the shark as bitten and besides that i can also set shark dot attack and this one needs an amount so let's say 20 and this is the attack method we have gotten from here so the parent class and if i run this we get the monster has attacked and well with that we already have super simple inheritance just by adding this brackets monster we are getting all of these attributes and these methods here so that's a pretty good start now what you can also do let's say let me remove some white space here let's say for the shark this move method here doesn't really work because for the shark i want something else i want the shark to swim and for the speed i want to set since i have a speed i want to use self.speed meaning i want to overwrite this speed from the parent class and to achieve that all you have to do is define a method with the same name in the child class so in here i want self.move and now i can add a print statement in here the shark has moved and let's say print again the speed of the shark is and then self dot speed and this should be an f string and now if i call shark dot move and we don't need any arguments if i call this the shark has moved the speed of the shark is 120. and what happens in here is we are first getting the inheritance from the monster and then this move here is being overwritten by this move here which means you can overwrite what you get from the parent class very easily and this you could also do with attributes although we actually have to talk about attributes let's do it right now the problem we are facing right now is that the monster has an init method let me remove this health and energy and uncomment the init method essentially the problem we have right now to give the monster the attributes this self.health and self.energy we have to first call the init method and if we don't call the init method we don't get these attributes so what we have to figure out inside of the init method how to call the parent init method so this would have to happen in here and for that we have two ways one that is a bit outdated but still works and one you actually want to use and let's cover both but you don't really need the first one anymore but just in case you see it let's cover it now what you can do you can call the parent class so monster and then call the dunder init method and now in here you have to pass all of the arguments so these ones here that you want for the parent class so we need self health and energy and these we have to get from arguments so when i initiate the shark besides speed i also want to get health for the shark and energy for the shark meaning when i actually create the object of the shark besides speed i want to set health to 100 and energy to 80. now what i get let's go over this actually the first step happens down here i am calling the shark class and i'm passing in three arguments i have the speed i have the health and i have the energy and these three arguments are being covered in speed health and energy and inside of this init method we are calling the parent init method and into this init method we have to pass in three arguments self health and energy and self originally for the parent class was the class itself so this self here which refers to this monster however now the self is going to refer to this self here which is the shark meaning when we are setting self.health and self.energy we don't talk about the monster we are talking about the shark class and this is why the self here is important and then besides the self we also need health and energy and these are just going to be arguments we have to pass in here so this health and this energy and these two we get from these two parameters here which is health and energy and those are being passed in here and with the left move method i don't care about this one instead let me print shark dot let's start with speed let's actually print all of them so besides speed i want health and i want energy if i run this we get 120 180 the numbers we have specified here and well this can get a bit complicated but look at the init method here and the init method here and if you didn't understand what i talked about in the last part practice this yourself and then go over this a couple of times if you get used to this it's eventually going to become fairly easy although i suppose in the beginning this can be a bit overwhelming the one really important thing you have to understand is that we are calling the init method and we are passing in the arguments that we want to set in this case speed health and energy and then inside of this init method we are right now calling the parent init method and then passing health and energy so these two in there as arguments so for example we first set the health here when we are creating the object this health goes into this health for the parameter and then this parameter goes into the init method of the parent and then the init method sets self dot health or the actual class and that way you can connect the init methods of different classes now this is how python used to work and this still works but there are some downsides to using it this way so this isn't really used anymore instead what we use is called super and this is a function and this super all it really does is it gets the parent class so if we have that we can just call the init method on it as well and in here we don't need self all we have to do is pass in health and energy and then we are done if i run this now we are getting the very same outcome meaning those two approaches here are functionally identical at least up to this point when we get to multiple inheritance or let's say more complex inheritance super is the much better method and this is why we don't use this initial approach anymore and i guess this one is also a bit easier to read it kinda is up to you but this is the one you do want to use and super you can actually use for a lot of other things as well for example i could call super and then call the move method of the parent and in here i have to pass in a speed let's say 10 so now when i run the code i get the monster is moved at a speed of 10 meaning when we are calling the init method of the shark class we are also calling the move method of the parent and this way even if you overwrite a method from the parent class you can still call it with super if you really want to which adds even more flexibility to all of this and this is simple inheritance which is something you definitely want to practice this is the one kind of inheritance you are going to use fairly often and the one you have to understand let's practice this one and let me add comments one more time let's do an exercise i want you guys to create a scorpion class that inherits from the monster and it should get health and energy from the parent and then besides that there should also be a poison damage attribute and i want you guys to overwrite the damage method to show poison damage kinda like what we have done for the move method for the shark pause the video now and try to implement this one yourself and see how far you get i want to start by creating a class called scorpion that is not used for scorpion there we go and this one should inherit from monster and now in here i want to create a dunder init method and this one itself and besides that i want poison mitch and now inside of the scorpion i want to set self poison damage as poison damage so we are getting an attribute and then besides that i want to define or well overwrite the attack method let me minimize the shark class so we can see the code a bit easier and i want to overwrite this attack method here and in my guess what i want i just want self because i already have the poison damage and all i want to do in here is print the scorpion has attacked and print it has dealt and then we want self dot poison damage and poison damage and this should be an f string alright so far this should have been fairly easy what i can do now let me delete all of this and let's delete a shark as well we don't need him for now and what i want to do is to create an instance or an object from my scorpion i am really bad at typing scorpion and here i bought my scorpion and right now we have a poison damage i don't know of 50. and now if i type scorpion dot attack this is working the scorpion has attacked it has dealt 50 poison damage this shouldn't have an underscore there we go it has dealt 50 poison damage this looks much better meaning what we have so far we have a scorpion with poison damage and we have overwritten the attack method and since we are inheriting from monster we are also getting this move method here meaning my scorpion can also move at a certain speed let's say 5 if i run this and let's make this a bit larger we have the attack method for the scorpion and we have the move method but what we don't have let me get rid of those two we don't have scorpion.health for example this attribute doesn't exist right now because monster only gets these two attributes once we are running the init method so what we have to do in the scorpion called the init method of the parent class which we get with super and then dunder init in here and if i scroll up the monster class for the init method needs two arguments health and energy so let me comment those two and in the unit method i want to pass in health and energy now these numbers have to come from somewhere although they don't necessarily have to i could for example just set static numbers in here let's say 50 and 10. if i run this now we get 50 for health because all we are doing here is calling a function that is done there init and we are just giving it different arguments although this lacks a lot of flexibility so i don't want to do it but we could if we wanted to instead i want to get this health and this energy from the init method of the scorpion class and in here just to be specific about what we are doing let me name this scorpion health and scorpion energy and somehow my brain always wants to add a tea to scorpion i have no idea why and now when i call the init method for the monster my health should be my scorpion health and my energy should be my scorpion energy when i am creating the actual object i want to have let me use named arguments that makes it a bit easier to read my poison damage should be 50 my scorpion health should be 20 and my scorpion energy should be 10. and now if i run this we get 20 for the health of the scorpion because remember we are only calling scorpion health the parameter so this is scorpion health here we don't actually set this parameter as an attribute instead what we do we are using the health attribute of the parent class and this gets the value of the scorpion health so our scorpion doesn't have scorpion health as an attribute it just has health and along those lines we also have energy if i run this we get 10. and i hope this starts to make a bit more sense this is definitely something you want to practice if you only partially followed along this is a really important concept to understand and definitely something you are going to see all the time and this you can actually make quite a bit more complex with well more complex inheritance so let's talk about that one and basically what that means so far we always had one parent class and then a child class so a pretty immediate connection something slightly more complex is you have a child class and two parent classes this is something we are going to build in this section but if you really wanted to you could do something like this and it would still work now maintaining something like this is going to be a ton of work although once you have it this child class is incredibly powerful because it gets information from a lot of parent classes so especially if you create something really large this is something you do want to be able to understand but for now especially if you're a beginner and this is the first time you've really engaged with objects i wouldn't recommend to worry about this too much because it gets overwhelming very fast instead make sure to understand this scheme if you understand that one you should be able to follow along with this one as well but for now just practice objects in the first place and once you have a better grasp of objects engage in this one so let's talk about how we could create something like this and this i think is best done in actual code so let's have a look how we can work with this now here i have some code already i have the monster class we have seen quite often by now this one i hope is familiar at this point besides that i also have a fish class now and this one is a very simple class all we have is an init method and this one sets a speed and has scales and besides that we have a swim method and this one just prints swimming at the speed of whatever the speed of the object is going to be and what i want to do i want to create my shark again but this time the shark is not just going to be inheriting from monster it is also going to be inheriting from fish so the first thing for multiple or complex inheritance is that all the objects you want to inherit from should be here in the brackets after the name of the class and in here you could add as many other classes you want there could be class 3 class 4 class 5 as many as you want there isn't really a limit and now inside of this shark i want to set a dunder init method and in here we always need self this one should make sense by now and besides that for the shark let's say i want to set a byte strength and then inside of this init method i want to self dot byte strength is going to be byte strength this one should still make sense it's quite straightforward but the more complex one is if i now want to call super and then dunder init now we have a problem because i have no idea what to put in here and the question here is what arguments should go into this inhibit method should i add the arguments for the monster class or for the fish class or both how would this work and there are a couple of things you have to understand to solve this problem the first one is called the mro or the method resolution order and what this really means is let me add a comment here mro or method resolution order what this basically means is in what order the parent init methods are being called and this you can get by just printing and i want to get the shark class not the object the class itself and call mro on it and this is still going to work and if i call this we are getting invalid syntax because the question mark here is not something python likes so let me comment it out for now and now let's run this again and now we can see the mro or the resolution order and basically what it means is in what order python is going to go through the classes we start with the shark itself this one should make sense this is the class that we actually work in so this is where we want to start next up we are looking at the monster class then we look at the fish and finally we look at a generic object and this generic object you don't have to worry about because this is something inbuilt into python it's the thing that makes all of the objects work you don't have to worry about it so what we have to worry about is the shark the monster and the fish and how this order comes about is from the order of these arguments here and basically how this works is that the leftmost item monster in this case is always going to be the first in line with the class itself being the very first item so shark is going to be zero monster is one fish is two and then every subsequent item is going to be next meaning what i could be doing is turn these two around and call fish first and then monster if i run this now we are still starting on our shark but now fish is the first item of inheritance then we have monster and we still have object finally but in my case i do want to keep monster as the first item so the first thing you do have to understand is if we are calling the super dunder init method we are looking at the first item inside of these arguments here so in this case monster meaning for now i can minimize the fish class and just look at the monster and let me minimize these methods as well so it's a bit easier to see and basically what i can do now let me comment out the mro and i actually want to create a shark object from my shark and this is something you should be familiar with from simple inheritance right now we only have the byte strength so byte strength and this we can set to whatever we want let's say 50. but now for this superintendent method i need the arguments for the init method of the parent class in this case health and energy these two i want to pass in here now for these two i again i am going to need some numbers so for the init method of the shark class i also want health and energy meaning when i create the object i also want health and energy and let's set those to i don't know 200 and energy could be 55 and with that we are essentially back to simple inheritance i first call the class itself and the first one we do after calling the class we are calling the init method and inside of the init method python knows that the first item of inheritance is the monster class and then after that python knows we have one parameter for byte strength and this we're just setting as a parameter and then we are done with it so this is as far as this one goes besides that we also have health and energy and these two we want to pass into the init method of the first parent class so the monster and those we are getting up here but now we have another problem and that problem is what happens to the fish let me run the code and let's see what happens we are not getting an error that's a pretty good sign now if i run shark and the methods we have here could for example be attack and for attack we need an amount let's say 10. the monster is attacked 10 damage was stealth so this attack method works just fine besides that i can also print shark.health and let me print this this one is working 200 we also get shark dot energy with 55 and we are also getting the byte strength so far we have the shark itself and the monster what we don't have is the fish let me minimize the monster class and open the fish in here we have speed and has scales and this our class doesn't have right now so if i type shark and speed and run the code we are getting that the shark object has no attribute speed which means that the inheritance from the fish is not working right now and let me reopen the monster and hide the monster methods so we can see all of the classes quite easily basically what is happening the mro is important here again this one here essentially how you have to think about it we first of all call the shark and then we call the init method of the shark and then python knows the first item of inheritance is the monster and since we are calling super.init we are calling this init method up here and passing the arguments in there the consequence is that we have health and energy for the monster and the normal inheritance still works so we also have attack and move but now the problem is that the init method of the fish is never called and as a consequence speed and has scales doesn't exist inside of the shark and what we have to figure out is how to call this init method and since we still have to worry about the mro we have to figure out how to call this init method with the arguments from inside of the init method of the monster and for that purpose we are still going to need this super and then the dunder init method and this function is very smart because it follows the inheritance that we have set by the shark to begin with meaning if we call the monster from the shark it knows it has to look at the fish next in line however if we call the monster by itself this init method wouldn't really do anything so this is a very intelligent function in the simplest terms basically what this init method has to do is to set the speed and hash scales of the other class which is the fish again let me set some static numbers for the speed let's go with 75 and for scales this should be false and now if i run all of this again i get for speed let's try this again now for speed i get 75 and for hash scales i get false the arguments we have set in here and this is especially if you are starting with objects probably going to be really confusing but the one thing that makes all of this work is the order of the indent methods we are first calling this one here this is number one then we are looking at the monster which is this one here this init method is number two then and then finally we are looking at the second item in the inheritance which is the fish this for shear so this init method is called third and we always need the super init method to go to the next item and what we would want to add in here as well is a super and then dander init method for the fish as well so if there's going to be another item in the list of inheritance or in the mro we would also call that one and for that reason you very often see super init in most classes because it enables inheritance to work across multiple classes and well i hope you can still follow along this is getting quite complicated and it is just going to get worse because right now we do have one problem and that is that this speed here and the hair scales are constant right now but i want to be able to set them dynamically when i am creating the shark meaning what i want to do when i create a shark i want to set this speed let's set it to 120 and i want to set has scales to false and this would then be all the stuff i have for the shark and i think it makes sense to put all of this on separate lines to make it a bit easier to read all right but now if i run this we are getting an error that shark init got unexpected keyword argument speed basically what pipeline is complaining about that this speed and this has scales don't exist in the parameters for the init method of the shark class we can fix that by adding a speed and has scales in here if i run this now this is going to work but we're not doing anything with either the speed or the hass scales we are still up here setting the speed and has scales as constant numbers and now we kind of have a problem because if i try to in this superintendent method at this speed and has scales then let me fix the typo first if i run this now we are getting the other problem that monster.init down here is the error we're getting right now monster.init takes three positional arguments but three were given meaning python in the monster class wants three arguments self health and energy and those we do get let minimize the fish for now so we can see what's going on we are getting health and energy and this is what this init method wants but besides that now we are also adding speed and has scales and for this the init method doesn't have any parameters so python is very unhappy because it gets too many arguments and it doesn't know what to do with them but this is a problem for us because we need those two arguments to pass into the init method for the fish but the init method of the monster doesn't have as many parameters so we have a problem here and to overcome this we need one special concept and that in python is called keyword unpacking and basically what it means is in my monster class after i have added all of the parameters i definitely know i need i want to add star star and then keyword arguments and that way any argument i get after the parameters i am going to store those in a separate dictionary let me actually print what we get so i want to print my keyword arguments without the stars for now and for these double stars python is expecting keyword arguments so all of the arguments for the init method here need to be keyword arguments meaning health.health energy is energy speed is speed and has underscore scales is has scales and now if i run this we are getting a dictionary with speed and has scales and this faults here we are getting from printing shark has scales let me remove that and try this again now so now we can focus on just a dictionary and that is something really useful because this we could use in here now and essentially what you have to do is call the unpacking operator again and passing in the keyword arguments and now if i run this again we are still getting the same dictionary so we are getting speed and we are getting hash scales but what happens now if we are calling this star again it turns each key value pair inside of this dictionary into a named argument meaning this speed under 20 is going to become a named argument and then this we are passing into the init method of the next class in the method resolution order and with that if i now print shark dot speed and actually display what we get i now get 120 the one we have specified in here and this is how you would work with this now for an actual example you would add a lot more quarks to all of these classes for example the fish would also have double star and keyword arguments and then you would pass this into the init method as well so in here quarks as well now in this case the keyword arguments is going to be empty if i print it keyword arguments and run this we're getting an empty dictionary because we don't have any additional named arguments that we have to worry about so this dictionary here is going to be empty well this dictionary actually but if we had more named arguments they would all go in there and this is then how you would deal with multiple inheritance and if again you are just starting with inheritance this really isn't something you want to worry about too much probably if you're watching this for the first time and you're still struggling with objects in general this is going to be way too much i would recommend just practice objects and simple inheritance for now and once you are more comfortable with them come back to this this sort of inheritance is only really something you are going to see once you get much more advanced especially for making games or for making gui's you probably don't need any of this whatsoever all of the games i have made so far have never used multiple inheritance they all use simple inheritance and they worked just fine but well at this point we have covered all the main parts of classes i guess at this point there is some more smaller things i do want to cover but they're all going to be fairly simple so let's talk about them in the next section alright for this part i want to talk about some extra parts for classes and those are things i couldn't really fit in in any of the other sections but they're all fairly simple but they can be quite useful and well let's do all of this straight in code i think that's going to be the easiest alright once more we have the monster class and this is just something i want to use to illustrate what we are going to do and let me create an instance of this monster with monster and for the health i want 20 for the energy i want 10. it really doesn't matter what number we go with here and now there are three things i want to cover the first one is private attributes the second one is has utter and set utter and the third one is going to be the dog string and once we have those we are basically done with classes and the first one is going to be private attributes which is just going to be an attribute inside of a class that cannot be influenced from outside of the class which may be something like an id number that you really want to make sure of cannot be changed from outside of the class to be sure that it doesn't mess with some other code and this actually isn't possible in python we are always able to change the attribute of a class so python developers came up with something else and this let me copy this comment here and in the init method of the monster class i want to create a private attribute and how you would do this is first add an underscore and then the name of the attribute let's say in this case i want to have an id and the number i want here could be 5 but it could be anything it really doesn't matter and now this id by convention is not supposed to be changed but this is just a convention basically what you do with this format is you tell other developers that this attribute should not be worked on but you totally could work on it for example what i can do i can print monster and then underscore id and i get 5. meaning you can work with it but there's a very clear indicator that you shouldn't so if you ever work with somebody else and they added something like this you probably should not change it and well that is all you need to know about private attributes you could do the same thing for methods you are essentially following a naming scheme so this works with both attributes and methods all right next up we have has utter and set utter and what those two are doing is they allow us to check if a class has an attribute and we can also use it to set an attribute and the first one is going to be has utter and that is just going to be a normal python function and this one wants two arguments it first of all wants to have an object and besides that it wants a string with an attribute name and let's try this one i want to look at my monster and for my monster i want to check if the monster has health and this is then going to return a boolean that either says true or false meaning i can print all of this and i get true so this monster has the attribute health if i check for something that doesn't exist let's say a weapon i get false because the monster doesn't have a weapon and this you could then use an if statement for example if has utter monster health and if it has health i want to print the monster has and i guess then we can use an f string monster dot health and that is terrible spelling and let's turn this into an f string and add health at the end and now if i run this the monster has 20 health and that is what we have set here and this is has utter it's a really useful way to check if a certain class has an attribute you are going to use this fairly often actually it's a really useful function and besides that set utter works in kind of the same way so let me call it set utter and in here we need three arguments first of all we need an object then we need a string of an attribute name let's call it attribute again and then we have to set a new value and this could be a string it could be a number it's really up to you i guess let's say again i want to look at my monster the attribute i want to set is a weapon and for the value let's give the monster a sword and now i can print monster.web pin and i get sword and this set utter is basically the same thing as calling monster dot weapon and setting this to sword these two things essentially do the same thing and now you might be wondering why do we have this kind of redundancy that this is kind of pointless at least similarly that we have this entire function that does something very obvious but the reason for it that this allows us to very efficiently create new attributes for example what we could be doing let me comment those two out and i could run a for loop and let me add a let's call it new tributes and this is going to be a tuple with lists i want to have for example a weapon and there i can have an x besides that i want to have another list with let's say armor and the armor could be a shield and finally i want to have one more list and this could be potion i could set something like mana or whatever you want to go for and now i can use that as a for loop so for attribute and value in new attributes i can call set utter i can pass in my monster in here and then i want my attribute and my value and if i run this we are not getting an error which is a good sign and now i can print my vars for the monster and i get the new weapon the new armor and the new potion and this way you can set a lot of new attributes and values for class by using this if you just used monster.weapon this one here this would not be possible and this is why set utter exists although you probably would want to create all of these attributes when you actually create the object itself so this isn't something you want to do too often although in some situations it can be really useful alright with that we have set utter and has utter and finally we have doc and doc is just there to explain what your object does that's really just about it you are getting doc or the doc's string to be more specific by calling monster and then dunder dock and in this case if i run this we get none for the simple reason that we have to create a dock string for our object and this you do first thing in the object and all you do in here is you set a triple quotation mark like this and then in there you are setting what you want for the monster for example i could write in here a monster that has some attributes and i am really bad at spelling monster for some reason and now if i run this print again and now i get a monster that has some attributes and this you could make significantly longer depending on what kind of class you have but this is usually what you want to set to explain your code to other people and especially if you work in a team with much larger projects it's really helpful to set something like this because well somebody else might have no idea what you're talking about what you can also do is let me comment out this print statement here and instead call help and i want to look at my monster if i run this i am getting a long list of different things and in here i can see lots of useful things for example i can see monster and its parameters i can see the dog string and i can see all of the methods inside of it and if you just find a new object you don't really know much about the help function is really useful as a matter of fact you can also pass normal python code in here for example what i could pass in here is just str for string and now python gives me the help function for strings and if i go all the way to the top there you can see basically that we have another object and the object takes one argument which is going to be a string then we have the dot string and this one explains what this object does and afterwards we have all of the methods and there are quite a few because strings are very complex objects and with that we have covered objects and classes i hope that wasn't too difficult but this is definitely something you do want to practice so hope that was helpful and i will see you around
