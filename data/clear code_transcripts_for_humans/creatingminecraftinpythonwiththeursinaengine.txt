With timestamps:

00:00 - hello there in this tutorial we are
00:03 - going to create a really basic minecraft
00:04 - clone in python
00:06 - and well it works like any other
00:08 - minecraft game you can create blocks you
00:10 - can destroy blocks
00:11 - and i also have different blocks that
00:13 - you can just switch to
00:14 - just to make it a bit easier and there
00:17 - are quite a few different ones and you
00:18 - can just work with them
00:20 - and play around pretty straightforward
00:22 - when it comes down to it
00:23 - and of course with that you can make
00:25 - well in my case a really simple house
00:28 - but if you want the tube you could just
00:29 - add more stuff to it or get rid of stuff
00:32 - well it's basically how minecraft works
00:37 - and all of this is made with the usina
00:40 - game engine
00:40 - so let's talk about that one the ostina
00:43 - game engine
00:44 - was released sometime last year and it's
00:47 - a really neat engine it can do really
00:48 - powerful stuff with very few lines of
00:50 - code
00:51 - for example the entire game you just saw
00:53 - took about 90 lines of code to write
00:56 - and you can make it in about an hour
00:58 - it's really easy
00:59 - so it's quite a good engine for
01:01 - beginners i feel
01:03 - and especially for 3d games osena is
01:06 - quite a bit more powerful than pygame
01:08 - for example
01:09 - but that doesn't mean it doesn't have
01:10 - problems and there's one big warning i
01:13 - do have to give that your cena game
01:14 - engine is only available for windows and
01:16 - linux
01:17 - so if you have mac os i'm really sorry
01:20 - this tutorial is not going to be for you
01:22 - but with all of that out of the way
01:24 - let's first do a brief introduction to
01:26 - the
01:26 - cena game engine and once we have the
01:28 - basics covered we can actually come to
01:30 - making the game
01:31 - so for this part we're talking about how
01:33 - cena works and how we can make some
01:35 - basic stuff with it
01:36 - and obviously the very first thing you
01:38 - have to do is to install it
01:39 - so in the powershell type pip install
01:42 - cena
01:42 - and then you should see a fairly lengthy
01:44 - dialog to install it
01:45 - and once that's done you should be good
01:47 - to go this works like literally any
01:49 - other module for python
01:51 - and once you have installed it go to the
01:53 - code editor of your choice in my case
01:55 - sublime
01:56 - and type import or cena and now if you
01:59 - run it
02:00 - you should be getting a message that is
02:02 - something like this
02:04 - the really important part you're looking
02:05 - for here is that you're not getting an
02:07 - error message
02:08 - if you don't you have installed it
02:09 - properly and now that we have that
02:11 - let me close it we can actually start
02:13 - working in oceana
02:14 - and the first thing we need to do is
02:16 - that i don't want to import usina by
02:18 - itself
02:19 - instead i want to go from from yocena
02:22 - import everything so star and the reason
02:26 - for that is that there are lots of
02:27 - objects that rely on oceana
02:29 - and having to type ocena every time is
02:31 - going to be quite cumbersome
02:33 - and now we need two lines to create the
02:35 - entire game the first line is to create
02:37 - the basic instance of the game
02:39 - and this has to be stored in a variable
02:40 - that i'm going to call app
02:42 - and to create this one all we have to
02:44 - type is orcina
02:46 - and make sure the first letter is
02:48 - capitalized that one is important
02:50 - and once we have that what i want to do
02:52 - is app.run
02:54 - so i create an instance and i run the
02:56 - instance and with that if i run my code
02:58 - now
02:59 - we get a really basic window we can see
03:02 - our frame rate
03:02 - and we can close the window that's about
03:05 - it nothing much happens
03:06 - yet but it's already a really good start
03:10 - that we have a window with just two
03:11 - lines of code
03:12 - so for example this would be much easier
03:14 - than pygame for example
03:17 - now we have to figure out how can we
03:18 - actually put stuff on the screen
03:20 - and for that we have to understand the
03:22 - most important concept for oceana
03:24 - and that is called entities and an
03:27 - entity
03:27 - in oceana can basically be anything it
03:30 - can be square it can be a cube it can be
03:32 - a circle
03:33 - it could also be a button basically
03:35 - anything you see on the screen
03:37 - is going to be an entity and then when
03:39 - you create this entity you can customize
03:41 - it quite a bit
03:42 - and once it's created it's automatically
03:44 - added to the game
03:46 - so all you have to take care of is
03:48 - creating it and then you're good to go
03:49 - so let's create one i want to create
03:53 - let's say let's call it test square
03:57 - where i just want to create a basic
03:58 - square on the screen and for that we
04:00 - have to create an entity
04:02 - and now we have to give it a couple of
04:04 - arguments
04:05 - the first one is what's called the model
04:07 - and this one determines what kind of
04:09 - shape it's going to take
04:10 - so is it going to be a cube is it going
04:12 - to be square is it going to be a circle
04:15 - and for now let's just go with circle
04:18 - that tends to be a really easy shape
04:20 - and with that we would get a circle and
04:22 - now let's give it a color argument
04:24 - and for that i need the color keyword
04:27 - and to assign it any color
04:29 - i need the keyword color and then the
04:31 - color i want to go with let's say for
04:33 - now let's go with red
04:34 - and with that we should have a red
04:36 - circle so let me run the code
04:38 - and we can see a red circle right in the
04:41 - middle of our screen
04:42 - so this one's working really well and
04:44 - what you can do now
04:45 - is change this circle to something else
04:48 - so for example if you want to square
04:50 - you would need the quad keyword and if i
04:52 - want to go now
04:53 - we get a square now you could
04:56 - if you wanted a cube so a
04:58 - three-dimensional object
04:59 - you could type cube in here although if
05:01 - i run this because we're looking at only
05:03 - one side of this cube we can't really
05:05 - see it
05:06 - but we're going to come to that in just
05:08 - a bit for now
05:10 - don't worry about it and let's leave it
05:12 - at the quad for now that one's the
05:14 - easiest to see
05:15 - and what you can also do in the
05:17 - parameters here is you can for example
05:19 - set a scale
05:20 - and then they can pass in a tuple with
05:23 - the x and the y scale
05:25 - so if i passed in let's say one and four
05:29 - we would stretch it four on the y and
05:32 - one on the x axis
05:33 - and of course you could also change the
05:36 - position
05:37 - and this could for example be let's say
05:39 - five and one and let's see what happens
05:42 - so now we have moved the entire thing
05:44 - one unit upwards and five units to the
05:46 - right
05:48 - and a really important thing here is
05:49 - that the origin point is in the center
05:51 - of the screen
05:54 - so y has to be positive if you want to
05:56 - go up has to be negative if you want to
05:57 - go down
05:58 - kind of like it would make sense and
06:00 - just to demonstrate it let's make this a
06:02 - higher value
06:02 - to 4 and now we get even higher
06:06 - so this would be quite different
06:07 - compared to pie game for example
06:10 - so now we have a basic thing on the
06:11 - screen how could we
06:13 - move it and that is also really easy in
06:16 - oceana because all we need
06:18 - is to create a function so def and this
06:21 - function has to be called
06:22 - update it doesn't need any arguments and
06:25 - this update function
06:26 - is going to be called biocena on every
06:28 - frame automatically
06:30 - so as long as you have this name and
06:31 - function you are good to go
06:34 - so for example what i could be doing in
06:36 - here is just to print
06:38 - test and then run the entire thing and
06:41 - now in the console you can see we get
06:42 - test
06:43 - quite a bit and now if i wanted to move
06:47 - this test square all i would have to do
06:50 - is to get the object itself and then
06:53 - influence one parameter for now let's go
06:56 - with x
06:58 - and i could just change the values so i
07:00 - could go with minus equal 1
07:01 - which would move it to the left although
07:04 - if i were to run this right now we go
07:06 - really fast
07:07 - so this is way too fast and this would
07:10 - also
07:11 - not adjust to different frame rates so
07:13 - this would be quite inconsistent
07:15 - but all we have to do to fix that is to
07:17 - add times time
07:18 - dot delta so this is the time between
07:21 - different frames
07:23 - so if we multiply this with the movement
07:24 - speed our object is going to move in
07:26 - accordance with the frame rate
07:28 - which is going to make our game quite
07:29 - smooth so now let's try it again
07:33 - and there we go this feels much better
07:36 - cool
07:37 - and we could even make it a bit faster
07:38 - let's go with minus equal
07:40 - four and yeah that feels better
07:44 - cool now you could make this even more
07:46 - sophisticated
07:47 - by adding keyboard input and for that
07:50 - all you need
07:51 - is held keys and from that
07:55 - we just have to pass in one specific key
07:59 - let's say my case a and now i have to
08:02 - indent this
08:03 - and i can just run the game again and
08:06 - now
08:06 - this thing is only going to move to the
08:08 - right if i press a and that's all we
08:10 - need
08:12 - and this could be any letter on your
08:14 - keyboard any number or even your mouse
08:16 - keys it's really flexible
08:18 - and all right with that we have our
08:20 - basic object and we have a way to move
08:22 - it
08:23 - now what we can also do let me add
08:26 - another square
08:27 - and let's call this sun's you've seen a
08:29 - second why
08:30 - and for this one i want to add a custom
08:32 - texture but i can add any kind of
08:34 - picture i want into this
08:36 - and for this i am still going to need an
08:37 - entity and the entity is supposed to be
08:40 - a quart again so we're getting a square
08:44 - and now i want to add a custom picture
08:47 - to this and for that i will need the
08:49 - texture
08:50 - keyword and now for the texture i
08:54 - have to create a texture and there are a
08:55 - couple of ways of doing it
08:57 - the one i would recommend is to create
09:02 - a texture in its own variable and then
09:04 - we need the keyword
09:05 - load texture and then you can select
09:08 - from your folder
09:09 - in my case i have a folder called assets
09:12 - and in that folder i have a file called
09:17 - sans.png and now that
09:20 - i can just pass in here and let's try
09:23 - now let's see what happens
09:25 - and now we get suns from undertale
09:27 - pretty nice and easy
09:29 - and we can actually make this easier we
09:32 - don't actually have to do
09:33 - this entire line we could just pass this
09:36 - straight into here and it would load
09:39 - automatically
09:40 - so if i run this now this would also
09:42 - work perfectly fine
09:44 - so this would be fine but i generally
09:46 - feel like importing all your textures at
09:48 - the beginning is a
09:49 - more readable way to approach this but
09:51 - it's ultimately up to you
09:53 - so with that we have a couple of really
09:55 - simple objects in our game
09:57 - but in an actual game you really want to
10:00 - have more control
10:00 - over all of these things so this kind of
10:04 - thing
10:04 - is generally just to create really
10:06 - simple ones if we wanted to create more
10:08 - complex ones
10:09 - we could also do that and for that we
10:12 - have to create an entirely class
10:14 - that inherits from an entity for example
10:16 - so
10:17 - let's create a more complex cube and
10:20 - with that we can also go into 3d
10:22 - so i want to create a new class and
10:25 - let's call this one
10:26 - test cube and this one has to inherit
10:29 - from entity and now and there
10:32 - i want to create an init method it needs
10:34 - self and nothing else
10:36 - or you could pass something in there
10:37 - would be fine and then there i want my
10:39 - super method
10:41 - and then the init and now when i
10:44 - initiate the parent
10:45 - i can specify a ton of different
10:48 - arguments
10:49 - so in here for example i could create a
10:51 - model
10:52 - for now i want a cube i could give it a
10:56 - color
10:57 - let's give it let's say the color white
11:00 - just for now and then of course i can
11:02 - also give it a texture
11:03 - and osena has a couple of textures in
11:06 - build that you can use
11:07 - one of those is called white underscore
11:09 - cube
11:11 - so this one you don't have to load it's
11:12 - inbuilt into a c now
11:15 - and with this we have our own class that
11:17 - we can add lots of stuff to that
11:19 - is something we are going to do in just
11:21 - a bit and now all we have to do
11:23 - to create an actual block from this
11:25 - class
11:26 - is well to call it so let me call my
11:29 - test cube
11:30 - and this is supposed to be my test cube
11:32 - class
11:34 - and now if we run this we can see a
11:37 - white cube
11:38 - right in the middle of our screen and
11:40 - you can't really see that it's a cube
11:41 - yet
11:42 - so let's give it some rotation and for
11:45 - that
11:45 - all i have to do is to give it a
11:47 - rotation argument
11:48 - and this one needs to be a vector 3 with
11:51 - the x
11:52 - y and z rotation and let's just go with
11:54 - 45
11:55 - 45 and 45. so now if we run this
11:59 - we can see our cube so this one is
12:01 - working pretty well
12:03 - and you could still move this thing
12:04 - around with position and this would work
12:06 - perfectly well
12:08 - now with that we have already quite a
12:09 - few things covered
12:11 - but there's one more concept we need
12:12 - before we can get to the actual game
12:14 - and that is to create a button and
12:17 - buttons work
12:18 - slightly differently or well not that
12:20 - much let's actually create one that's
12:21 - going to be the fastest way
12:23 - so to create a button i still have to
12:26 - create a class
12:27 - and i'm going to call it test button
12:31 - and this one has to inherit from a class
12:33 - called button itself
12:35 - and now here i have to create again
12:38 - a done there init method that needs self
12:41 - and inside of that
12:42 - i want to get my super method and init
12:45 - that one and in here i can create lots
12:48 - of different stuff for the button
12:50 - so for example my button could be a cube
12:54 - just like my test cube i could give it a
12:57 - texture
12:58 - and let's say another inbuilt one is
13:00 - called brick
13:02 - i could give it a color and this one
13:04 - would be let's go with
13:07 - color blue just to use one we haven't
13:10 - seen yet
13:11 - and with that we have a really basic
13:13 - button let's actually create it
13:15 - and let me get rid of the test cube just
13:18 - so we don't have it in the way
13:20 - so now instead of test cube i want a
13:22 - test button
13:24 - and now if i run this we can see a
13:27 - giant button and you can see if i hover
13:30 - over it it gets slightly brighter
13:33 - but now it is kind of weird how buttons
13:36 - work
13:37 - because this button is significantly
13:39 - larger than this test cube
13:41 - and the reason for that is that a test
13:43 - button needs one more argument
13:45 - and is called the parent argument and
13:48 - the parent we need
13:48 - is the scene so the actual game scene
13:50 - again
13:52 - and now if i run this again now we can
13:54 - see the normal size button
13:56 - i am not actually sure why the parent
13:59 - argument is needed for the test button
14:01 - but not for the test cube it's a little
14:03 - bit weird
14:04 - but if you want to create a button this
14:06 - has to be parented to the scene
14:08 - and that's the actual game what we can
14:10 - also do
14:11 - for a button is to give it different
14:13 - colors depending on what you do with it
14:15 - so for example there is a highlight
14:18 - underscore
14:18 - color argument that changes the color if
14:21 - we hover over the button
14:23 - so this could for example be color let's
14:26 - go with red
14:27 - and then we also have a pressed
14:30 - underscore color
14:31 - and this is the color we get when the
14:33 - button is pressed and for this one let's
14:35 - go with color
14:36 - dot lime and now if we run this again
14:41 - we get our button if i have over it it
14:44 - becomes red
14:44 - and if i click it it becomes green so
14:47 - this one is working quite well
14:49 - and now how could we use a button
14:53 - and well this one is also incredibly
14:55 - easy all we have to do is to create a
14:57 - new method
14:58 - that is called input it needs self as
15:01 - usual
15:02 - and then it needs one more argument that
15:04 - is called key and that's the key we are
15:06 - pressing to activate it
15:08 - and now inside of that method we have to
15:10 - create an if statement that if self
15:12 - dot overt so if our mouse is over the
15:14 - button
15:16 - and inside of that what we want to check
15:17 - is if key
15:19 - so the key we pass into it is equal to
15:22 - the left mouse button argument which is
15:25 - called
15:26 - left mouse down
15:29 - and if that is the case let's just print
15:33 - button pressed and now
15:37 - if i run out of this it's still working
15:39 - and if i press on the button
15:40 - we get button pressed so this one is
15:43 - working pretty well
15:46 - and with that we can actually come to
15:49 - the game
15:49 - so let's talk about minecraft and really
15:52 - the one important thing you have to know
15:54 - about minecraft
15:55 - is that minecraft is a voxel-based game
15:58 - and really all that means
15:59 - is that every single block that you see
16:01 - in minecraft is a voxel
16:03 - so these are the things that we have to
16:05 - create ourselves but besides that
16:07 - there really isn't other much else that
16:09 - we do need
16:10 - so let's actually jump straight into our
16:13 - code again
16:13 - and let's have a look at this all right
16:17 - welcome back i have gotten rid of all
16:19 - the code i have used to explain with
16:21 - cena itself
16:22 - so all we have now if we run the code is
16:24 - an empty window
16:25 - that we can use to create an actual game
16:28 - and the first thing i have to do
16:30 - is to create a new class for all the
16:33 - voxels we want to create
16:35 - so the class is going to be called voxel
16:37 - and this one has to inherit
16:38 - from the button class for the simple
16:41 - reason that whenever i click on a voxel
16:43 - i want to create another voxel right
16:45 - next to it
16:46 - so i need to know where each voxel is
16:48 - that's why it's a button
16:49 - and in here we need our init method
16:52 - again
16:54 - itself and nothing else for now at least
16:58 - and let me just type it properly and in
17:01 - here we again need the super method with
17:04 - the underscore init
17:07 - and now we have to specify a couple of
17:09 - arguments the first one is parent the
17:11 - one that we have seen earlier this would
17:12 - be scene
17:14 - so the actual scene of the game next up
17:17 - we would need a position
17:20 - and the position for now let me just
17:22 - place it at
17:23 - 0 0 and 0. although this we are going to
17:27 - change later when we set up the game
17:29 - next up i want to create a model so what
17:31 - the thing is going to look like
17:33 - and this one for now is going to be a
17:35 - cube although this also is going to
17:37 - change at least somewhat then i need the
17:40 - origin
17:42 - y so effectively the height and 3d space
17:45 - of this cube
17:46 - and this one is going to be 0.5
17:50 - and once we have that we need a texture
17:53 - so we can actually see the cube
17:56 - and for the texture for now i'm just
17:58 - going to go with white
17:59 - underscore cube the one that we have
18:01 - seen earlier
18:03 - and this also we are going to change in
18:05 - just a bit for now i just want to have a
18:06 - basic setup
18:08 - and next up we are going to need a color
18:11 - and
18:11 - one important thing you need both a
18:13 - texture and a color
18:15 - and both of these colors are going to be
18:17 - multiplied together so if you only have
18:19 - the texture and no color it is going to
18:21 - look weird
18:22 - and for now let's just stick with white
18:24 - i think that's going to be fine
18:26 - and besides that i also want to create a
18:29 - high
18:30 - light underscore color and this one
18:33 - let's go with color
18:35 - dot lime so
18:38 - really all that's happening here is we
18:40 - create a button that is going to be a
18:42 - cube with a white texture
18:44 - and if we hover over it then it's going
18:47 - to be lime colored
18:48 - then we have a position 0 0 and 0 so
18:50 - it's right in the middle
18:51 - except it's slightly lifted up by 0.5
18:55 - that's really that's all that's
18:56 - happening here so
18:58 - now that we have all of that we have to
19:01 - create our button
19:03 - and for that let me put it right between
19:05 - those two lines of code
19:08 - i could just create voxel is equal to
19:11 - voxel and let's actually run this and
19:14 - let's see what happens
19:15 - so now we can see one button and it
19:18 - becomes greenish when we hover over it
19:20 - so this one well it's a start but
19:23 - i don't just want to create a single
19:25 - button i want to create
19:27 - multiple and to create multiple buttons
19:30 - really all i need is for z
19:34 - in let's go with range of 8 so i want to
19:37 - create eight blocks in the z
19:39 - space and inside of that
19:42 - i'm going to go for x in range
19:46 - eight so effectively what i have done
19:49 - is i have gone forwards and backwards by
19:51 - eight units and then i've also gone left
19:53 - and right
19:53 - for each of these units and now what i
19:57 - can do in there
19:58 - is to create a voxel and then this voxel
20:02 - is always going to get the voxel class
20:04 - itself
20:05 - so this way we are creating 64 voxels
20:08 - and now if we run this we still
20:12 - can't really see it and the reason for
20:14 - that
20:15 - right now is because they are all in the
20:17 - same position so this one doesn't
20:19 - really help us so i have to place in
20:22 - some kind of information in here to
20:24 - customize the position
20:25 - so when i call this class on the init
20:28 - method
20:29 - i want to give it a position that by
20:32 - default is supposed to be
20:34 - zero zero and zero so that we always end
20:37 - up with this position if nothing is
20:38 - passed in here
20:39 - and this one is getting position so if i
20:42 - run this again now
20:43 - nothing is going to change but what i
20:46 - can do now when i create all of these
20:47 - voxels
20:48 - i can pass an x 0 and
20:51 - z so that we actually use this
20:54 - information
20:55 - and this information to place each
20:57 - individual voxel
20:58 - so now if i run this again we are
21:01 - getting an error because
21:03 - all of this has to be a tuple and i
21:06 - could even give it the
21:07 - position keyboard and now let's try this
21:10 - again
21:11 - there we go now we can see all of them
21:13 - right next to each other
21:14 - the problem now is how can we actually
21:16 - create a first person character in all
21:18 - of this
21:19 - and in here usina makes this incredibly
21:22 - easy
21:23 - because it has a couple of predefined
21:25 - classes that we can use to just create a
21:27 - first person character
21:28 - we don't really have to do anything
21:30 - ourselves for that
21:32 - and really all we have to do is to
21:34 - import something else first
21:36 - and what we have to import is from usina
21:40 - dot prefabs dot first
21:44 - underscore person underscore controller
21:47 - and then import first
21:51 - person controller i hope i spelled that
21:54 - right
21:56 - so this by default is not being imported
21:58 - into oceana so we have to do it ourself
22:00 - but once we do have it all we have to do
22:03 - to create a first person character
22:05 - is to create a new variable where we
22:07 - store it and then call
22:08 - first person controller and this is also
22:12 - class
22:12 - so we have to call it and now
22:15 - i can run the game and we get a first
22:19 - person player
22:20 - so well with that we already have
22:24 - really the basics of what we need for a
22:26 - game
22:28 - and the buttons also work and the
22:30 - collision between them also works
22:32 - automatically so you don't have to worry
22:33 - about this
22:34 - at all which is really powerful
22:41 - and now if you do want to close the game
22:43 - because you can't use the mouse anymore
22:45 - i just switch between my windows and
22:48 - then close it from there this tends to
22:49 - be the easiest
22:51 - and cool now we have our first person
22:54 - controller
22:55 - and if you want to make all of this
22:56 - larger we could go with something like
22:59 - 20 times 20.
23:02 - and now we have a much larger field
23:07 - although one of the problems with the
23:09 - game right now is that if you added too
23:11 - many of these fields the game would slow
23:13 - down
23:14 - so there would be quite a bit of
23:15 - optimization work to do
23:19 - but all right what we have to figure out
23:21 - now is how to make all of this
23:22 - more interactive so how can you create
23:25 - and destroy blocks
23:26 - and again this is going to be super easy
23:29 - because
23:30 - effectively what we want to do is that
23:32 - if you press on the voxel button
23:34 - then we want to create a new block on
23:36 - that position
23:38 - so the first thing we have to do is to
23:41 - create a new button press functionality
23:43 - and this is something we have seen
23:44 - earlier because this voxel
23:47 - is just a button that we can press so we
23:49 - can give it an input method
23:51 - and this one itself and key separated by
23:54 - a comma
23:55 - and in here again i need if self dot
23:59 - avert and now i want to check is if
24:03 - e is equal to left
24:07 - mouse down and if that is the case
24:11 - i want to create a new voxel and this
24:13 - one again
24:14 - is going to need the voxel class so
24:17 - really what's happening in here is if we
24:19 - are pressing this button
24:21 - we are creating a new button in a
24:23 - certain position that we can specify
24:26 - and now we actually have to specify the
24:28 - position
24:29 - of this button and there are two parts
24:32 - we have to combine
24:33 - the first one is self dot position
24:36 - so that we get the position of the
24:38 - button we are pressing right now
24:40 - but then we have to add mouse
24:44 - dot normal and once we have that i can
24:48 - actually try all of this
24:49 - and see if it works so now if i press on
24:51 - any button
24:52 - we get a new well voxel button cube
24:56 - thing so this one is actually pretty
24:58 - good start
24:59 - so what's happening here and let me
25:01 - explain in the game that's going to be
25:03 - the easiest
25:04 - so here we have some more space
25:08 - so right now i'm looking at this button
25:11 - here or this voxel
25:13 - so i get the position of the voxel
25:14 - itself and the normal
25:16 - is the surface we are looking at so
25:19 - right now the normal is pointing upwards
25:21 - and this is what we are using when we
25:23 - create a new voxel button
25:25 - that we want to get the position itself
25:27 - plus the upward direction
25:29 - so when we press it that's where we are
25:31 - going to create the new voxel button
25:33 - and this we can do for any kind of
25:35 - surface that we just get the position
25:37 - itself
25:38 - plus the surface we are pointing at and
25:41 - in what way it's
25:42 - facing and once we have that we can
25:45 - really create
25:46 - all the different cubes that we wanted
25:49 - and this
25:49 - is pretty much a perfect minecraft
25:52 - functionality
25:53 - so really nice
25:56 - what we can do now is to add another if
25:59 - statement
26:00 - if we wanted to destroy all of these
26:02 - boxes
26:03 - so if key is equal to right
26:06 - mouse down and all i need to destroy
26:10 - a button is the destroy self
26:13 - and this is literally all we needed so
26:15 - now i can run the thing again
26:17 - and if i left click i create a voxel if
26:20 - i right click i destroy it
26:24 - and with that we can even create our
26:27 - bottom itself
26:29 - and fall into a bottomless pit of
26:30 - nothingness
26:33 - hey it's working and one more thing that
26:35 - we could be doing
26:36 - is to change the color and give it a bit
26:38 - more variety so right now every single
26:41 - block is perfectly white
26:42 - which well tends to get a little bit
26:44 - boring even if we added textures
26:46 - so instead what we can do is to give it
26:49 - color.color
26:50 - and in here we can specify rgb values
26:55 - and in my case i want this to be 0 and 0
26:57 - and then i want
26:59 - random dot uniform
27:02 - and this is supposed to between 0.9 and
27:05 - 1
27:06 - so that the color of every block is
27:07 - going to be slightly random
27:10 - and now if we run this it still works
27:13 - and now each of these blocks gets a
27:15 - slightly different shade of gray
27:18 - although there's one more thing that i
27:20 - am slightly confused about
27:22 - is that what these specific arguments in
27:24 - here mean
27:25 - is a bit confusing because if you change
27:28 - this one from zero to one
27:31 - nothing really seems to change however
27:35 - if you change the second one
27:38 - to a one now the entire thing is going
27:40 - to be red
27:42 - so i assume these values are going to be
27:45 - rgba but i'm really not entirely sure
27:50 - but let's leave it for now as it is and
27:51 - it's perfectly fine
27:53 - and all right with that we have a really
27:56 - basic setup
27:57 - for a very simple and nice
28:00 - game setup that works kind of like
28:02 - minecraft
28:04 - and all of this is exactly the same
28:06 - setup for one of the demos for usina and
28:09 - this is exactly what i have copied
28:11 - so if you've gotten this far you have
28:12 - basically replicated one demo from the
28:14 - cena game so definitely check out the
28:17 - github page
28:18 - and there are lots more examples i would
28:20 - really recommend to check them out
28:21 - they're really fun to play around with
28:23 - but alright now that we have our basic
28:25 - setup we can make all of this
28:27 - look much better and there are a
28:30 - couple of things that we need to make
28:32 - all of this work and let's start by
28:34 - creating proper cubes that we can use
28:36 - this is going to be the biggest change
28:38 - that we can
28:40 - and to create proper blocks with the
28:41 - proper textures we do have to cover
28:44 - one specific topic that right now we
28:47 - have used an inbuilt
28:48 - cube which worked decently fine but it's
28:51 - very limited in terms of how you can add
28:53 - a texture to it
28:55 - and the reason for that is that there's
28:56 - no uv map for
28:58 - it and a uv map is basically how you
29:01 - wrap a texture
29:02 - around a cube or really any 3d object
29:05 - and the default cube in oceana doesn't
29:07 - really have a uv map
29:09 - so when we apply the proper texture to
29:10 - it it wouldn't really
29:12 - work so what we have to do is to create
29:15 - our own block
29:16 - and apply texture to it and then import
29:18 - all of that into oceana
29:20 - which fortunately is really easy and i
29:22 - have used blender to create a basic
29:24 - block
29:25 - and in the project folder for this game
29:27 - i'm going to link the blender file in
29:28 - case you want to have a look at this
29:30 - but i'm going to import the finished
29:31 - file itself which is going to be the
29:33 - most straightforward way
29:35 - but let's go through it step by step
29:37 - that's going to be the easiest one
29:39 - so here i'm back in my code and the
29:41 - first thing i want to do
29:42 - is to get rid of this cube and instead
29:45 - what i want to do
29:46 - is to import from my assets folder and
29:48 - there i have a file called block
29:51 - and this is assets block
29:54 - and this block is a block i have created
29:56 - in blender that has a uv map
29:58 - so if we applied a more proper texture
30:00 - to it it would show up properly
30:03 - as a matter of fact i have created a
30:05 - couple of textures
30:07 - and just to save me some typing let me
30:09 - paste them all in
30:10 - so i have a grass texture i have a stone
30:12 - texture i have a brick texture and i
30:14 - have a dirt texture
30:16 - and all of these get a texture loaded
30:17 - right into the game
30:19 - and now i don't want to use the white
30:21 - cube texture anymore
30:23 - instead for now let's just go with the
30:25 - grass texture
30:27 - and let's actually look how this looks
30:30 - ah and if i run this now we get an error
30:32 - but a simple reason that we first have
30:35 - to create
30:35 - oceana and only then we can load
30:37 - textures so i need app
30:39 - is equal to cena first and then i can
30:41 - run all of this
30:44 - and now let's try it again this should
30:46 - be working now and there
30:47 - we go now
30:51 - you can kind of see the problem that the
30:53 - positioning
30:54 - is kind of messed up and the reasoning
30:58 - here
30:58 - is that the default buttons are a
31:00 - different size from the buttons we have
31:02 - imported
31:04 - but that we can change very easily all
31:06 - we need is scale
31:08 - is equal to 0.5 so now if i try this
31:11 - again
31:13 - now this looks much better and i can
31:15 - still create all of the blocks
31:16 - and i get my basic blocks so this one
31:20 - is still working exactly the same way
31:21 - except now we have a nicer looking
31:23 - texture edit
31:24 - and also what i want to do now i want to
31:27 - get rid of this highlight color
31:28 - because it makes the entire thing look
31:30 - kind of weird
31:32 - so now let's try it again and yeah i
31:35 - feel this is looking a bit better
31:37 - but you could leave it if you wanted to
31:39 - alright
31:40 - so now we're making some progress but i
31:43 - don't want this grass texture every time
31:45 - instead i want to be able to pick from
31:47 - any of these textures
31:49 - so what i want to do is when i create
31:51 - this voxel class
31:52 - i want to assign it a texture
31:56 - and by default this should be the grass
31:58 - texture
31:59 - but if i specify the keyword this could
32:01 - be
32:02 - any texture in here so now if i run all
32:05 - of this again we should still see the
32:07 - same outcome
32:08 - cool but now what we could be doing
32:12 - is when we are specifying the voxel
32:15 - itself let's do it down here actually
32:17 - let's do it up here so you can see the
32:18 - difference a bit better
32:20 - so whenever i click on a voxel i want to
32:23 - give it
32:24 - a more specific texture and let's go
32:26 - with the stone
32:28 - texture so now the default voxels are
32:32 - going to be the grass texture
32:33 - but when i click on one i'm creating a
32:35 - stone texture or a stone
32:38 - so now if i click on something we are
32:40 - getting a stone cool this is working
32:42 - pretty well
32:45 - and really all we have to do now is to
32:48 - figure out
32:48 - some kind of input that we can select
32:51 - specific kind of textures
32:53 - and what i have done is i have
32:57 - created an
33:00 - update function so the same thing we
33:02 - have seen earlier and this one is going
33:03 - to be run on every single frame
33:05 - and effectively what i have done in here
33:08 - i have created
33:09 - a new variable actually outside of it
33:11 - that i've called
33:12 - block underscore pick
33:15 - and by default this is one and then all
33:18 - i'm doing in here
33:19 - is if held underscore keys
33:23 - one then i want to set block
33:26 - pick to one
33:30 - and now i can copy this thing a couple
33:31 - of times and change this to two
33:35 - three and four and then 2
33:38 - 3 and 4. and i have to set this
33:42 - to global block
33:46 - pick so really all that's happening in
33:49 - here
33:50 - is that if i press any of this button
33:52 - this block pick gets a different number
33:54 - and this we can then use further down
33:57 - here
33:58 - to influence how this entire thing is
34:00 - going to look
34:01 - so instead of just creating a texture
34:04 - itself
34:05 - i also want to check if log pic
34:08 - is equal to 1 and if that is the case
34:12 - only then do i want to create a voxel
34:14 - with the
34:15 - let's put this one for the grass texture
34:18 - and i think can put all of them on the
34:20 - same line that makes it a bit more
34:21 - readable
34:22 - and with that i am only going to create
34:25 - a grass texture
34:26 - if block pick is equal to one
34:30 - but let's say if i pressed two
34:33 - then i want to create a stone texture
34:37 - if i picked 3 i want this to be
34:41 - a thing i call this a brick texture
34:45 - it was indeed a brick texture and then
34:48 - for number four
34:50 - i want this to be a dirt texture
34:53 - and all right let's try this now let's
34:56 - see what happens
34:57 - so i'm still in my basic game if i
35:00 - clicked
35:01 - just by itself we get this but now if i
35:03 - press two on my keyboard
35:05 - and try this again we're getting a stone
35:07 - block
35:08 - if i press three we're getting a brick
35:10 - and if i press four we're getting some
35:12 - dirt
35:13 - or however you call this one and alright
35:16 - this is
35:16 - really starting to come together so this
35:18 - is already helping to make the game look
35:20 - nicer
35:21 - but there are three more elements that
35:22 - can really help to bring the game across
35:25 - number one is the skybox number two is a
35:27 - hand and number three is sounds
35:30 - and let's go for them step by step the
35:32 - first one is a sky box
35:33 - and a skybox basically is what we can
35:36 - see as sky
35:37 - but to emulate this in our game all we
35:39 - basically do
35:40 - is we create a giant sphere that has a
35:44 - sky texture on it that's really all it
35:45 - is and
35:47 - well we can go straight to creating it
35:49 - it's super easy to do
35:50 - so here i'm back in my code and what i
35:53 - want to do is to create a new class that
35:54 - i'm going to call
35:55 - sky and this one is just going to
35:57 - inherit from entity
36:00 - and in there i need def init and it
36:03 - needs self nothing else
36:05 - and in there i need my super and then
36:08 - init and in here we have to specify
36:12 - a couple of things the first one just to
36:14 - be sure is the parent
36:15 - which needs to be the scene so we're
36:17 - part of the actual game
36:19 - but now for the model we need something
36:21 - new and that is
36:23 - a sphere so well a round object
36:27 - and now for the texture i want to create
36:31 - a sky texture and this one
36:35 - doesn't exist yet but all we have to do
36:37 - is to import it
36:38 - so in my textures i want a sky
36:41 - texture and let me line it up properly
36:45 - i want to lower texture again and in my
36:48 - assets folder there is one file
36:52 - that is called sky box
36:56 - dot png and this is the one i want to
37:00 - use
37:01 - let me add a bit more space below the
37:02 - class itself and this
37:04 - would actually already give us something
37:07 - so
37:08 - let me actually create it so below the
37:10 - player i'm also going to create
37:12 - a new variable called sky and this one
37:14 - gets
37:15 - my sky class
37:18 - and let's run the entire thing and see
37:20 - what happens i'm getting an error
37:22 - because this is supposed to be a comma
37:25 - now we go okay right now i can't see
37:27 - anything but if i turn around
37:29 - there we can see a very tiny world so
37:32 - this thing we want to scale up massively
37:36 - and really all we have to do is to give
37:39 - it a scale argument
37:40 - and in there i passed in 150
37:44 - so now if i run this again we can't well
37:47 - we can't see
37:48 - anything and well the reason for that is
37:52 - that this texture right now is only on
37:54 - the outside
37:55 - so if we are inside of this object we
37:58 - can't see it
37:59 - but we can change this very easily all
38:01 - we need is
38:02 - double underscore cited
38:06 - and this needs to be true and now if i
38:08 - run this again this should be working
38:10 - and there we go now this is looking much
38:13 - nicer
38:14 - although this isn't the perfect sky
38:16 - texture especially you can see
38:17 - there there's one seam this is where the
38:19 - texture start and end
38:21 - connect so well this isn't great but i
38:23 - think it's good enough for now
38:25 - so with that we have our sky now i can
38:28 - close this class and never think about
38:30 - it again
38:32 - now the next thing i'm going to need is
38:34 - a hand and this one is purely decorative
38:36 - it doesn't really do anything besides
38:38 - simulating having a hand it's
38:39 - a really simple thing and for that we
38:42 - are going to learn one new thing
38:44 - but i think this is best explained by
38:45 - actually implementing it and i want to
38:47 - create a new class
38:48 - that i call hand and this one is also
38:51 - going to be an
38:51 - entity and in there as always i need
38:55 - my done there init method that needs
38:58 - self and nothing else and inside of that
39:00 - i need my super
39:02 - and then init for that one
39:06 - and in here we have to specify the
39:08 - parent
39:09 - but the parent is not going to be the
39:11 - scene instead it is going to be camera
39:14 - dot ui and let me explain what that is
39:17 - so far we have only used the scene and
39:19 - this is the actual 3d space
39:21 - of our game the camera ui is the actual
39:24 - 2d space of our camera so if you want to
39:27 - create
39:28 - a ui it would be on this space and this
39:30 - one is not going to move along with the
39:32 - game itself
39:33 - it's just a static space that is kind of
39:35 - on top of the game itself
39:37 - it's essentially a glass sheet that the
39:39 - player is looking through
39:41 - or in most other game engines this would
39:43 - be a viewport this would also be a good
39:44 - way to think about it
39:46 - now what i also want is to give this a
39:48 - model
39:50 - and again i have a custom model that is
39:52 - in my assets folder
39:54 - and it's just called arm and this also
39:57 - has a texture
39:59 - and the texture let's load it straight
40:02 - in there
40:04 - and i call this one arm
40:07 - texture that needs an equal and
40:11 - load texture and this one is also an
40:14 - assets and i've called this one
40:18 - arm texture dot png
40:22 - and now i can assign this texture it's
40:24 - arm texture
40:26 - and with that we have our basic hand
40:29 - let's
40:29 - actually create this object using the
40:31 - class so i call this hand
40:34 - and let's see what happens
40:37 - so well um it's a touch
40:40 - large i feel so what we have to do for
40:43 - now
40:44 - is to make this entire thing a little
40:45 - bit smaller so
40:47 - i want to go scale 0.2
40:51 - an equal sign and let's try this now
40:56 - and now we get a much better
40:57 - proportioned hand
40:59 - although it's pointing right at us so
41:01 - that's
41:02 - not great and for that
41:05 - all i have to do is to give it a
41:07 - rotation and a position
41:09 - and the rotation is going to be a
41:12 - vector3
41:13 - and the rotation i went with is 150
41:16 - negative 10
41:17 - and 0. and let's try this now
41:22 - and there we go now we can see our hand
41:25 - a little bit better
41:26 - although it's still in the completely
41:27 - wrong position but well
41:29 - we are making progress and the rest
41:30 - still works perfectly fine
41:33 - so now let's give it a position so
41:36 - position
41:37 - is equal to and this needs to be a
41:39 - vector 2 because we're moving in a 2d
41:41 - space
41:42 - and i have moved this 0.4 to the right
41:46 - and then downwards by negative 0.6
41:51 - and now let's try this again and now
41:54 - this is looking much nicer
41:55 - cool so with that we have a basic hand
41:59 - but right now it doesn't animate and
42:02 - well that looks a bit weird
42:04 - so let's add a really basic animation
42:07 - although calling it an animation
42:08 - is well kind of overkill of course all
42:11 - i've effectively done is that if the
42:13 - player presses the mouse button
42:15 - their hand is in one position if the
42:16 - mouse button is not pressed
42:18 - the hand is in the default position
42:19 - that's really all that's happening here
42:20 - it's not really an animation
42:22 - but you could very easily make it one
42:25 - all i really have to do
42:26 - is to create a method for this hand that
42:29 - i called
42:30 - active and in itself and in there i
42:33 - changed
42:34 - the hand position and rotation to be
42:36 - more in the middle of the screen
42:39 - so i need self position
42:42 - and self dot rotation
42:46 - and no comma or bracket afterward
42:49 - and for the position i went with 0.3
42:52 - and negative 0.5 and the rotation i
42:56 - actually didn't touch
42:57 - so we can just leave it as it is and
43:01 - then for the other state
43:04 - passive ozone itself
43:07 - and for this one i just took this
43:10 - position
43:11 - and assigned it to it so self dot
43:14 - position so now we have two methods that
43:17 - can influence the position
43:19 - of the hand and if i click the mouse i
43:22 - want the active method to run
43:23 - if i don't click the mouse i want the
43:25 - passive method to run
43:27 - so with that i have to go to my update
43:29 - function and
43:30 - add another if statement in here and
43:32 - let's do it right at the top although it
43:33 - doesn't really matter
43:35 - and really all i want to do is if held
43:38 - keys
43:41 - as left mouse
43:46 - or held keys
43:49 - is equal to right mouse so for pressing
43:53 - the left mouse button
43:54 - or the right mouse button we want to
43:55 - trigger one of these
43:57 - and here's something slightly weird that
43:59 - if you use
44:00 - the update function you have to use the
44:02 - left mouse however when you use a button
44:05 - you have to use the left mouse down so
44:07 - it's a slight difference be careful with
44:08 - that
44:10 - but right now we have our if statement
44:13 - and all i have to do in there is either
44:17 - hand dot active
44:20 - and if that's not the case i want hand
44:23 - dot
44:23 - passive and
44:27 - that's literally all we have to do for
44:28 - the hand and if i run the code now
44:31 - and if i click my hand moves a tiny bit
44:34 - or at least we get the illusion of a
44:36 - movement but everything else still works
44:38 - really well
44:39 - and well this is quite nice so we are
44:42 - really making some good progress
44:44 - cool and really all that's left to do
44:46 - now is to add a sound to it
44:48 - and this is also really easily done i
44:51 - first have to import a sound
44:53 - and i have called mind punch sound
44:56 - and this now happens with the keyword
44:59 - audio
45:00 - and this is also new class and when we
45:02 - initiate this sound we need again a file
45:05 - and i have one in assets and i called
45:07 - this punch
45:08 - underscore sound and i didn't need the
45:11 - file ending
45:12 - and now we have to specify a couple more
45:14 - things the first one is loop
45:16 - and this one is supposed to be false
45:17 - because we only want one punch sound
45:20 - and i need autoplay and this is also
45:23 - supposed to be
45:23 - false and with that we have imported our
45:27 - audio file
45:28 - so now we have to figure out when to
45:30 - play it and the one i went with let me
45:32 - minimize
45:33 - all the other parts is that whenever you
45:36 - click
45:36 - or delete one of these cubes then we are
45:39 - going to play the sound
45:41 - and all i have to do to play a sound is
45:43 - to get the sound itself
45:44 - and then play and i want to do this for
45:48 - both creating
45:49 - and deleting a block so let me put this
45:53 - above destroy it feels better
45:56 - and now if we try all of this
46:01 - we ah i
46:04 - think i made one mistake let me get out
46:06 - of it
46:07 - so right now the sound is kind of double
46:09 - playing and the reason is
46:11 - well quite simple that whenever i call
46:13 - the input method
46:15 - and we're hovering over any of the
46:17 - buttons
46:18 - then we are playing the sound but i only
46:21 - want to play the sound
46:22 - if we're actually pressing it so that
46:24 - way
46:25 - it's going to work properly and now
46:28 - let's try this again
46:32 - and this is feeling so much better
46:36 - and cool this is basically the finished
46:39 - game
46:41 - there are a couple of tiny things that
46:42 - you can do
46:44 - and well they're really tiny basic
46:47 - things
46:48 - so let me do an all the way to top what
46:50 - we could do for example
46:52 - is window dot fps underscore counter
46:56 - dot enabled a build
47:00 - is true right now but i want this to be
47:03 - false
47:04 - so we can see a tiny number in the top
47:06 - right i hope this
47:08 - i feel makes the game look a bit nicer
47:11 - and since we're not using
47:12 - the escape button we can also hide that
47:14 - one
47:15 - so window dot exit underscore button
47:19 - dot visible is equal to
47:23 - false
47:26 - and now we get the whole window and this
47:29 - is literally what i have showed you
47:31 - earlier at the beginning of this video
47:33 - really what you can do now is just keep
47:35 - on building different blocks and just
47:38 - add more and more stuff towards it and
47:41 - get rid of stuff if you don't like it
47:43 - it works pretty well so well
47:46 - that's pretty much it there are a couple
47:48 - of things you do want to be aware of
47:51 - number one is that well lots of things
47:54 - are missing
47:55 - that we don't have an inventory we only
47:57 - create a very basic square
47:59 - and not much is happening yet so if you
48:02 - wanted to expand this entire thing
48:04 - you would have to add quite a bit more
48:06 - code because in the current setup if you
48:08 - had too many blocks the game slows down
48:10 - very noticeably so this would be one
48:13 - thing to work on
48:14 - number two is that if you look very
48:17 - closely at the textures you can see it
48:18 - very well here
48:20 - is that there are lots of little seams
48:21 - between them which happens because
48:24 - i well i didn't spend too much time
48:26 - making them because this is just a demo
48:28 - but if you spend a bit more time on them
48:30 - you can make them look much nicer
48:33 - and well you can also add an inventory
48:35 - and lots more tiny things
48:37 - but well what you have so far is
48:39 - essentially a basic start for the game
48:41 - so if you play rhombus more you can
48:43 - probably make quite a bit more of this
48:46 - so i hope you enjoyed and i will see you
48:49 - around
48:51 - bye

Cleaned transcript:

hello there in this tutorial we are going to create a really basic minecraft clone in python and well it works like any other minecraft game you can create blocks you can destroy blocks and i also have different blocks that you can just switch to just to make it a bit easier and there are quite a few different ones and you can just work with them and play around pretty straightforward when it comes down to it and of course with that you can make well in my case a really simple house but if you want the tube you could just add more stuff to it or get rid of stuff well it's basically how minecraft works and all of this is made with the usina game engine so let's talk about that one the ostina game engine was released sometime last year and it's a really neat engine it can do really powerful stuff with very few lines of code for example the entire game you just saw took about 90 lines of code to write and you can make it in about an hour it's really easy so it's quite a good engine for beginners i feel and especially for 3d games osena is quite a bit more powerful than pygame for example but that doesn't mean it doesn't have problems and there's one big warning i do have to give that your cena game engine is only available for windows and linux so if you have mac os i'm really sorry this tutorial is not going to be for you but with all of that out of the way let's first do a brief introduction to the cena game engine and once we have the basics covered we can actually come to making the game so for this part we're talking about how cena works and how we can make some basic stuff with it and obviously the very first thing you have to do is to install it so in the powershell type pip install cena and then you should see a fairly lengthy dialog to install it and once that's done you should be good to go this works like literally any other module for python and once you have installed it go to the code editor of your choice in my case sublime and type import or cena and now if you run it you should be getting a message that is something like this the really important part you're looking for here is that you're not getting an error message if you don't you have installed it properly and now that we have that let me close it we can actually start working in oceana and the first thing we need to do is that i don't want to import usina by itself instead i want to go from from yocena import everything so star and the reason for that is that there are lots of objects that rely on oceana and having to type ocena every time is going to be quite cumbersome and now we need two lines to create the entire game the first line is to create the basic instance of the game and this has to be stored in a variable that i'm going to call app and to create this one all we have to type is orcina and make sure the first letter is capitalized that one is important and once we have that what i want to do is app.run so i create an instance and i run the instance and with that if i run my code now we get a really basic window we can see our frame rate and we can close the window that's about it nothing much happens yet but it's already a really good start that we have a window with just two lines of code so for example this would be much easier than pygame for example now we have to figure out how can we actually put stuff on the screen and for that we have to understand the most important concept for oceana and that is called entities and an entity in oceana can basically be anything it can be square it can be a cube it can be a circle it could also be a button basically anything you see on the screen is going to be an entity and then when you create this entity you can customize it quite a bit and once it's created it's automatically added to the game so all you have to take care of is creating it and then you're good to go so let's create one i want to create let's say let's call it test square where i just want to create a basic square on the screen and for that we have to create an entity and now we have to give it a couple of arguments the first one is what's called the model and this one determines what kind of shape it's going to take so is it going to be a cube is it going to be square is it going to be a circle and for now let's just go with circle that tends to be a really easy shape and with that we would get a circle and now let's give it a color argument and for that i need the color keyword and to assign it any color i need the keyword color and then the color i want to go with let's say for now let's go with red and with that we should have a red circle so let me run the code and we can see a red circle right in the middle of our screen so this one's working really well and what you can do now is change this circle to something else so for example if you want to square you would need the quad keyword and if i want to go now we get a square now you could if you wanted a cube so a threedimensional object you could type cube in here although if i run this because we're looking at only one side of this cube we can't really see it but we're going to come to that in just a bit for now don't worry about it and let's leave it at the quad for now that one's the easiest to see and what you can also do in the parameters here is you can for example set a scale and then they can pass in a tuple with the x and the y scale so if i passed in let's say one and four we would stretch it four on the y and one on the x axis and of course you could also change the position and this could for example be let's say five and one and let's see what happens so now we have moved the entire thing one unit upwards and five units to the right and a really important thing here is that the origin point is in the center of the screen so y has to be positive if you want to go up has to be negative if you want to go down kind of like it would make sense and just to demonstrate it let's make this a higher value to 4 and now we get even higher so this would be quite different compared to pie game for example so now we have a basic thing on the screen how could we move it and that is also really easy in oceana because all we need is to create a function so def and this function has to be called update it doesn't need any arguments and this update function is going to be called biocena on every frame automatically so as long as you have this name and function you are good to go so for example what i could be doing in here is just to print test and then run the entire thing and now in the console you can see we get test quite a bit and now if i wanted to move this test square all i would have to do is to get the object itself and then influence one parameter for now let's go with x and i could just change the values so i could go with minus equal 1 which would move it to the left although if i were to run this right now we go really fast so this is way too fast and this would also not adjust to different frame rates so this would be quite inconsistent but all we have to do to fix that is to add times time dot delta so this is the time between different frames so if we multiply this with the movement speed our object is going to move in accordance with the frame rate which is going to make our game quite smooth so now let's try it again and there we go this feels much better cool and we could even make it a bit faster let's go with minus equal four and yeah that feels better cool now you could make this even more sophisticated by adding keyboard input and for that all you need is held keys and from that we just have to pass in one specific key let's say my case a and now i have to indent this and i can just run the game again and now this thing is only going to move to the right if i press a and that's all we need and this could be any letter on your keyboard any number or even your mouse keys it's really flexible and all right with that we have our basic object and we have a way to move it now what we can also do let me add another square and let's call this sun's you've seen a second why and for this one i want to add a custom texture but i can add any kind of picture i want into this and for this i am still going to need an entity and the entity is supposed to be a quart again so we're getting a square and now i want to add a custom picture to this and for that i will need the texture keyword and now for the texture i have to create a texture and there are a couple of ways of doing it the one i would recommend is to create a texture in its own variable and then we need the keyword load texture and then you can select from your folder in my case i have a folder called assets and in that folder i have a file called sans.png and now that i can just pass in here and let's try now let's see what happens and now we get suns from undertale pretty nice and easy and we can actually make this easier we don't actually have to do this entire line we could just pass this straight into here and it would load automatically so if i run this now this would also work perfectly fine so this would be fine but i generally feel like importing all your textures at the beginning is a more readable way to approach this but it's ultimately up to you so with that we have a couple of really simple objects in our game but in an actual game you really want to have more control over all of these things so this kind of thing is generally just to create really simple ones if we wanted to create more complex ones we could also do that and for that we have to create an entirely class that inherits from an entity for example so let's create a more complex cube and with that we can also go into 3d so i want to create a new class and let's call this one test cube and this one has to inherit from entity and now and there i want to create an init method it needs self and nothing else or you could pass something in there would be fine and then there i want my super method and then the init and now when i initiate the parent i can specify a ton of different arguments so in here for example i could create a model for now i want a cube i could give it a color let's give it let's say the color white just for now and then of course i can also give it a texture and osena has a couple of textures in build that you can use one of those is called white underscore cube so this one you don't have to load it's inbuilt into a c now and with this we have our own class that we can add lots of stuff to that is something we are going to do in just a bit and now all we have to do to create an actual block from this class is well to call it so let me call my test cube and this is supposed to be my test cube class and now if we run this we can see a white cube right in the middle of our screen and you can't really see that it's a cube yet so let's give it some rotation and for that all i have to do is to give it a rotation argument and this one needs to be a vector 3 with the x y and z rotation and let's just go with 45 45 and 45. so now if we run this we can see our cube so this one is working pretty well and you could still move this thing around with position and this would work perfectly well now with that we have already quite a few things covered but there's one more concept we need before we can get to the actual game and that is to create a button and buttons work slightly differently or well not that much let's actually create one that's going to be the fastest way so to create a button i still have to create a class and i'm going to call it test button and this one has to inherit from a class called button itself and now here i have to create again a done there init method that needs self and inside of that i want to get my super method and init that one and in here i can create lots of different stuff for the button so for example my button could be a cube just like my test cube i could give it a texture and let's say another inbuilt one is called brick i could give it a color and this one would be let's go with color blue just to use one we haven't seen yet and with that we have a really basic button let's actually create it and let me get rid of the test cube just so we don't have it in the way so now instead of test cube i want a test button and now if i run this we can see a giant button and you can see if i hover over it it gets slightly brighter but now it is kind of weird how buttons work because this button is significantly larger than this test cube and the reason for that is that a test button needs one more argument and is called the parent argument and the parent we need is the scene so the actual game scene again and now if i run this again now we can see the normal size button i am not actually sure why the parent argument is needed for the test button but not for the test cube it's a little bit weird but if you want to create a button this has to be parented to the scene and that's the actual game what we can also do for a button is to give it different colors depending on what you do with it so for example there is a highlight underscore color argument that changes the color if we hover over the button so this could for example be color let's go with red and then we also have a pressed underscore color and this is the color we get when the button is pressed and for this one let's go with color dot lime and now if we run this again we get our button if i have over it it becomes red and if i click it it becomes green so this one is working quite well and now how could we use a button and well this one is also incredibly easy all we have to do is to create a new method that is called input it needs self as usual and then it needs one more argument that is called key and that's the key we are pressing to activate it and now inside of that method we have to create an if statement that if self dot overt so if our mouse is over the button and inside of that what we want to check is if key so the key we pass into it is equal to the left mouse button argument which is called left mouse down and if that is the case let's just print button pressed and now if i run out of this it's still working and if i press on the button we get button pressed so this one is working pretty well and with that we can actually come to the game so let's talk about minecraft and really the one important thing you have to know about minecraft is that minecraft is a voxelbased game and really all that means is that every single block that you see in minecraft is a voxel so these are the things that we have to create ourselves but besides that there really isn't other much else that we do need so let's actually jump straight into our code again and let's have a look at this all right welcome back i have gotten rid of all the code i have used to explain with cena itself so all we have now if we run the code is an empty window that we can use to create an actual game and the first thing i have to do is to create a new class for all the voxels we want to create so the class is going to be called voxel and this one has to inherit from the button class for the simple reason that whenever i click on a voxel i want to create another voxel right next to it so i need to know where each voxel is that's why it's a button and in here we need our init method again itself and nothing else for now at least and let me just type it properly and in here we again need the super method with the underscore init and now we have to specify a couple of arguments the first one is parent the one that we have seen earlier this would be scene so the actual scene of the game next up we would need a position and the position for now let me just place it at 0 0 and 0. although this we are going to change later when we set up the game next up i want to create a model so what the thing is going to look like and this one for now is going to be a cube although this also is going to change at least somewhat then i need the origin y so effectively the height and 3d space of this cube and this one is going to be 0.5 and once we have that we need a texture so we can actually see the cube and for the texture for now i'm just going to go with white underscore cube the one that we have seen earlier and this also we are going to change in just a bit for now i just want to have a basic setup and next up we are going to need a color and one important thing you need both a texture and a color and both of these colors are going to be multiplied together so if you only have the texture and no color it is going to look weird and for now let's just stick with white i think that's going to be fine and besides that i also want to create a high light underscore color and this one let's go with color dot lime so really all that's happening here is we create a button that is going to be a cube with a white texture and if we hover over it then it's going to be lime colored then we have a position 0 0 and 0 so it's right in the middle except it's slightly lifted up by 0.5 that's really that's all that's happening here so now that we have all of that we have to create our button and for that let me put it right between those two lines of code i could just create voxel is equal to voxel and let's actually run this and let's see what happens so now we can see one button and it becomes greenish when we hover over it so this one well it's a start but i don't just want to create a single button i want to create multiple and to create multiple buttons really all i need is for z in let's go with range of 8 so i want to create eight blocks in the z space and inside of that i'm going to go for x in range eight so effectively what i have done is i have gone forwards and backwards by eight units and then i've also gone left and right for each of these units and now what i can do in there is to create a voxel and then this voxel is always going to get the voxel class itself so this way we are creating 64 voxels and now if we run this we still can't really see it and the reason for that right now is because they are all in the same position so this one doesn't really help us so i have to place in some kind of information in here to customize the position so when i call this class on the init method i want to give it a position that by default is supposed to be zero zero and zero so that we always end up with this position if nothing is passed in here and this one is getting position so if i run this again now nothing is going to change but what i can do now when i create all of these voxels i can pass an x 0 and z so that we actually use this information and this information to place each individual voxel so now if i run this again we are getting an error because all of this has to be a tuple and i could even give it the position keyboard and now let's try this again there we go now we can see all of them right next to each other the problem now is how can we actually create a first person character in all of this and in here usina makes this incredibly easy because it has a couple of predefined classes that we can use to just create a first person character we don't really have to do anything ourselves for that and really all we have to do is to import something else first and what we have to import is from usina dot prefabs dot first underscore person underscore controller and then import first person controller i hope i spelled that right so this by default is not being imported into oceana so we have to do it ourself but once we do have it all we have to do to create a first person character is to create a new variable where we store it and then call first person controller and this is also class so we have to call it and now i can run the game and we get a first person player so well with that we already have really the basics of what we need for a game and the buttons also work and the collision between them also works automatically so you don't have to worry about this at all which is really powerful and now if you do want to close the game because you can't use the mouse anymore i just switch between my windows and then close it from there this tends to be the easiest and cool now we have our first person controller and if you want to make all of this larger we could go with something like 20 times 20. and now we have a much larger field although one of the problems with the game right now is that if you added too many of these fields the game would slow down so there would be quite a bit of optimization work to do but all right what we have to figure out now is how to make all of this more interactive so how can you create and destroy blocks and again this is going to be super easy because effectively what we want to do is that if you press on the voxel button then we want to create a new block on that position so the first thing we have to do is to create a new button press functionality and this is something we have seen earlier because this voxel is just a button that we can press so we can give it an input method and this one itself and key separated by a comma and in here again i need if self dot avert and now i want to check is if e is equal to left mouse down and if that is the case i want to create a new voxel and this one again is going to need the voxel class so really what's happening in here is if we are pressing this button we are creating a new button in a certain position that we can specify and now we actually have to specify the position of this button and there are two parts we have to combine the first one is self dot position so that we get the position of the button we are pressing right now but then we have to add mouse dot normal and once we have that i can actually try all of this and see if it works so now if i press on any button we get a new well voxel button cube thing so this one is actually pretty good start so what's happening here and let me explain in the game that's going to be the easiest so here we have some more space so right now i'm looking at this button here or this voxel so i get the position of the voxel itself and the normal is the surface we are looking at so right now the normal is pointing upwards and this is what we are using when we create a new voxel button that we want to get the position itself plus the upward direction so when we press it that's where we are going to create the new voxel button and this we can do for any kind of surface that we just get the position itself plus the surface we are pointing at and in what way it's facing and once we have that we can really create all the different cubes that we wanted and this is pretty much a perfect minecraft functionality so really nice what we can do now is to add another if statement if we wanted to destroy all of these boxes so if key is equal to right mouse down and all i need to destroy a button is the destroy self and this is literally all we needed so now i can run the thing again and if i left click i create a voxel if i right click i destroy it and with that we can even create our bottom itself and fall into a bottomless pit of nothingness hey it's working and one more thing that we could be doing is to change the color and give it a bit more variety so right now every single block is perfectly white which well tends to get a little bit boring even if we added textures so instead what we can do is to give it color.color and in here we can specify rgb values and in my case i want this to be 0 and 0 and then i want random dot uniform and this is supposed to between 0.9 and 1 so that the color of every block is going to be slightly random and now if we run this it still works and now each of these blocks gets a slightly different shade of gray although there's one more thing that i am slightly confused about is that what these specific arguments in here mean is a bit confusing because if you change this one from zero to one nothing really seems to change however if you change the second one to a one now the entire thing is going to be red so i assume these values are going to be rgba but i'm really not entirely sure but let's leave it for now as it is and it's perfectly fine and all right with that we have a really basic setup for a very simple and nice game setup that works kind of like minecraft and all of this is exactly the same setup for one of the demos for usina and this is exactly what i have copied so if you've gotten this far you have basically replicated one demo from the cena game so definitely check out the github page and there are lots more examples i would really recommend to check them out they're really fun to play around with but alright now that we have our basic setup we can make all of this look much better and there are a couple of things that we need to make all of this work and let's start by creating proper cubes that we can use this is going to be the biggest change that we can and to create proper blocks with the proper textures we do have to cover one specific topic that right now we have used an inbuilt cube which worked decently fine but it's very limited in terms of how you can add a texture to it and the reason for that is that there's no uv map for it and a uv map is basically how you wrap a texture around a cube or really any 3d object and the default cube in oceana doesn't really have a uv map so when we apply the proper texture to it it wouldn't really work so what we have to do is to create our own block and apply texture to it and then import all of that into oceana which fortunately is really easy and i have used blender to create a basic block and in the project folder for this game i'm going to link the blender file in case you want to have a look at this but i'm going to import the finished file itself which is going to be the most straightforward way but let's go through it step by step that's going to be the easiest one so here i'm back in my code and the first thing i want to do is to get rid of this cube and instead what i want to do is to import from my assets folder and there i have a file called block and this is assets block and this block is a block i have created in blender that has a uv map so if we applied a more proper texture to it it would show up properly as a matter of fact i have created a couple of textures and just to save me some typing let me paste them all in so i have a grass texture i have a stone texture i have a brick texture and i have a dirt texture and all of these get a texture loaded right into the game and now i don't want to use the white cube texture anymore instead for now let's just go with the grass texture and let's actually look how this looks ah and if i run this now we get an error but a simple reason that we first have to create oceana and only then we can load textures so i need app is equal to cena first and then i can run all of this and now let's try it again this should be working now and there we go now you can kind of see the problem that the positioning is kind of messed up and the reasoning here is that the default buttons are a different size from the buttons we have imported but that we can change very easily all we need is scale is equal to 0.5 so now if i try this again now this looks much better and i can still create all of the blocks and i get my basic blocks so this one is still working exactly the same way except now we have a nicer looking texture edit and also what i want to do now i want to get rid of this highlight color because it makes the entire thing look kind of weird so now let's try it again and yeah i feel this is looking a bit better but you could leave it if you wanted to alright so now we're making some progress but i don't want this grass texture every time instead i want to be able to pick from any of these textures so what i want to do is when i create this voxel class i want to assign it a texture and by default this should be the grass texture but if i specify the keyword this could be any texture in here so now if i run all of this again we should still see the same outcome cool but now what we could be doing is when we are specifying the voxel itself let's do it down here actually let's do it up here so you can see the difference a bit better so whenever i click on a voxel i want to give it a more specific texture and let's go with the stone texture so now the default voxels are going to be the grass texture but when i click on one i'm creating a stone texture or a stone so now if i click on something we are getting a stone cool this is working pretty well and really all we have to do now is to figure out some kind of input that we can select specific kind of textures and what i have done is i have created an update function so the same thing we have seen earlier and this one is going to be run on every single frame and effectively what i have done in here i have created a new variable actually outside of it that i've called block underscore pick and by default this is one and then all i'm doing in here is if held underscore keys one then i want to set block pick to one and now i can copy this thing a couple of times and change this to two three and four and then 2 3 and 4. and i have to set this to global block pick so really all that's happening in here is that if i press any of this button this block pick gets a different number and this we can then use further down here to influence how this entire thing is going to look so instead of just creating a texture itself i also want to check if log pic is equal to 1 and if that is the case only then do i want to create a voxel with the let's put this one for the grass texture and i think can put all of them on the same line that makes it a bit more readable and with that i am only going to create a grass texture if block pick is equal to one but let's say if i pressed two then i want to create a stone texture if i picked 3 i want this to be a thing i call this a brick texture it was indeed a brick texture and then for number four i want this to be a dirt texture and all right let's try this now let's see what happens so i'm still in my basic game if i clicked just by itself we get this but now if i press two on my keyboard and try this again we're getting a stone block if i press three we're getting a brick and if i press four we're getting some dirt or however you call this one and alright this is really starting to come together so this is already helping to make the game look nicer but there are three more elements that can really help to bring the game across number one is the skybox number two is a hand and number three is sounds and let's go for them step by step the first one is a sky box and a skybox basically is what we can see as sky but to emulate this in our game all we basically do is we create a giant sphere that has a sky texture on it that's really all it is and well we can go straight to creating it it's super easy to do so here i'm back in my code and what i want to do is to create a new class that i'm going to call sky and this one is just going to inherit from entity and in there i need def init and it needs self nothing else and in there i need my super and then init and in here we have to specify a couple of things the first one just to be sure is the parent which needs to be the scene so we're part of the actual game but now for the model we need something new and that is a sphere so well a round object and now for the texture i want to create a sky texture and this one doesn't exist yet but all we have to do is to import it so in my textures i want a sky texture and let me line it up properly i want to lower texture again and in my assets folder there is one file that is called sky box dot png and this is the one i want to use let me add a bit more space below the class itself and this would actually already give us something so let me actually create it so below the player i'm also going to create a new variable called sky and this one gets my sky class and let's run the entire thing and see what happens i'm getting an error because this is supposed to be a comma now we go okay right now i can't see anything but if i turn around there we can see a very tiny world so this thing we want to scale up massively and really all we have to do is to give it a scale argument and in there i passed in 150 so now if i run this again we can't well we can't see anything and well the reason for that is that this texture right now is only on the outside so if we are inside of this object we can't see it but we can change this very easily all we need is double underscore cited and this needs to be true and now if i run this again this should be working and there we go now this is looking much nicer although this isn't the perfect sky texture especially you can see there there's one seam this is where the texture start and end connect so well this isn't great but i think it's good enough for now so with that we have our sky now i can close this class and never think about it again now the next thing i'm going to need is a hand and this one is purely decorative it doesn't really do anything besides simulating having a hand it's a really simple thing and for that we are going to learn one new thing but i think this is best explained by actually implementing it and i want to create a new class that i call hand and this one is also going to be an entity and in there as always i need my done there init method that needs self and nothing else and inside of that i need my super and then init for that one and in here we have to specify the parent but the parent is not going to be the scene instead it is going to be camera dot ui and let me explain what that is so far we have only used the scene and this is the actual 3d space of our game the camera ui is the actual 2d space of our camera so if you want to create a ui it would be on this space and this one is not going to move along with the game itself it's just a static space that is kind of on top of the game itself it's essentially a glass sheet that the player is looking through or in most other game engines this would be a viewport this would also be a good way to think about it now what i also want is to give this a model and again i have a custom model that is in my assets folder and it's just called arm and this also has a texture and the texture let's load it straight in there and i call this one arm texture that needs an equal and load texture and this one is also an assets and i've called this one arm texture dot png and now i can assign this texture it's arm texture and with that we have our basic hand let's actually create this object using the class so i call this hand and let's see what happens so well um it's a touch large i feel so what we have to do for now is to make this entire thing a little bit smaller so i want to go scale 0.2 an equal sign and let's try this now and now we get a much better proportioned hand although it's pointing right at us so that's not great and for that all i have to do is to give it a rotation and a position and the rotation is going to be a vector3 and the rotation i went with is 150 negative 10 and 0. and let's try this now and there we go now we can see our hand a little bit better although it's still in the completely wrong position but well we are making progress and the rest still works perfectly fine so now let's give it a position so position is equal to and this needs to be a vector 2 because we're moving in a 2d space and i have moved this 0.4 to the right and then downwards by negative 0.6 and now let's try this again and now this is looking much nicer cool so with that we have a basic hand but right now it doesn't animate and well that looks a bit weird so let's add a really basic animation although calling it an animation is well kind of overkill of course all i've effectively done is that if the player presses the mouse button their hand is in one position if the mouse button is not pressed the hand is in the default position that's really all that's happening here it's not really an animation but you could very easily make it one all i really have to do is to create a method for this hand that i called active and in itself and in there i changed the hand position and rotation to be more in the middle of the screen so i need self position and self dot rotation and no comma or bracket afterward and for the position i went with 0.3 and negative 0.5 and the rotation i actually didn't touch so we can just leave it as it is and then for the other state passive ozone itself and for this one i just took this position and assigned it to it so self dot position so now we have two methods that can influence the position of the hand and if i click the mouse i want the active method to run if i don't click the mouse i want the passive method to run so with that i have to go to my update function and add another if statement in here and let's do it right at the top although it doesn't really matter and really all i want to do is if held keys as left mouse or held keys is equal to right mouse so for pressing the left mouse button or the right mouse button we want to trigger one of these and here's something slightly weird that if you use the update function you have to use the left mouse however when you use a button you have to use the left mouse down so it's a slight difference be careful with that but right now we have our if statement and all i have to do in there is either hand dot active and if that's not the case i want hand dot passive and that's literally all we have to do for the hand and if i run the code now and if i click my hand moves a tiny bit or at least we get the illusion of a movement but everything else still works really well and well this is quite nice so we are really making some good progress cool and really all that's left to do now is to add a sound to it and this is also really easily done i first have to import a sound and i have called mind punch sound and this now happens with the keyword audio and this is also new class and when we initiate this sound we need again a file and i have one in assets and i called this punch underscore sound and i didn't need the file ending and now we have to specify a couple more things the first one is loop and this one is supposed to be false because we only want one punch sound and i need autoplay and this is also supposed to be false and with that we have imported our audio file so now we have to figure out when to play it and the one i went with let me minimize all the other parts is that whenever you click or delete one of these cubes then we are going to play the sound and all i have to do to play a sound is to get the sound itself and then play and i want to do this for both creating and deleting a block so let me put this above destroy it feels better and now if we try all of this we ah i think i made one mistake let me get out of it so right now the sound is kind of double playing and the reason is well quite simple that whenever i call the input method and we're hovering over any of the buttons then we are playing the sound but i only want to play the sound if we're actually pressing it so that way it's going to work properly and now let's try this again and this is feeling so much better and cool this is basically the finished game there are a couple of tiny things that you can do and well they're really tiny basic things so let me do an all the way to top what we could do for example is window dot fps underscore counter dot enabled a build is true right now but i want this to be false so we can see a tiny number in the top right i hope this i feel makes the game look a bit nicer and since we're not using the escape button we can also hide that one so window dot exit underscore button dot visible is equal to false and now we get the whole window and this is literally what i have showed you earlier at the beginning of this video really what you can do now is just keep on building different blocks and just add more and more stuff towards it and get rid of stuff if you don't like it it works pretty well so well that's pretty much it there are a couple of things you do want to be aware of number one is that well lots of things are missing that we don't have an inventory we only create a very basic square and not much is happening yet so if you wanted to expand this entire thing you would have to add quite a bit more code because in the current setup if you had too many blocks the game slows down very noticeably so this would be one thing to work on number two is that if you look very closely at the textures you can see it very well here is that there are lots of little seams between them which happens because i well i didn't spend too much time making them because this is just a demo but if you spend a bit more time on them you can make them look much nicer and well you can also add an inventory and lots more tiny things but well what you have so far is essentially a basic start for the game so if you play rhombus more you can probably make quite a bit more of this so i hope you enjoyed and i will see you around bye
