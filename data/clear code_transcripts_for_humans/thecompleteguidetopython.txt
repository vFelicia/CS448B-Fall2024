With timestamps:

00:00 - python is the world's most popular
00:01 - programming language and that is for a
00:04 - reason you can use it to make games and
00:06 - apps run databases build robots and
00:09 - create artificial intelligence with ease
00:11 - the example you see right now is an ai
00:14 - program that tracks my face it took me
00:15 - about five minutes to write
00:17 - and that is a general theme for python
00:20 - it is incredibly easy to learn while
00:22 - also giving you a ton of power for more
00:23 - advanced functionalities and all of this
00:26 - you're going to learn in this video
00:27 - starting from scratch
00:29 - i am assuming that you have never used
00:31 - any kind of programming language before
00:33 - so we are starting all the way from the
00:35 - bottom and over the next 10 or so hours
00:38 - you are going to learn basically
00:39 - everything you need to know about python
00:41 - and after that you can learn pretty much
00:44 - whatever you want in the language and it
00:45 - should be fairly straightforward
00:47 - as a matter of fact this video is part
00:50 - of a larger paid course and this one is
00:53 - going to use all of the stuff you're
00:54 - learning about python and uses it to
00:56 - make four games and that way you are
00:59 - learning in much more detail how to
01:00 - actually use all of this in practice
01:03 - so check this one out if you're
01:05 - interested although this entire video
01:07 - works by itself and you can use it for
01:09 - any other non-gaming purpose as well
01:11 - it's a general introduction to python
01:13 - before we start the program we need to
01:15 - cover some fundamentals first of all if
01:18 - you are just getting into programming
01:20 - you are probably overwhelmed by choice
01:23 - besides python you could learn a few
01:25 - hundred other programming languages some
01:28 - have clear names like html5 or java
01:31 - while others are much more difficult to
01:33 - separate like c c sharp and c plus plus
01:37 - so what makes each language different
01:40 - and where should you start
01:42 - also how does python compare to these
01:44 - other languages
01:46 - one good way to separate these languages
01:48 - is by using two axes
01:50 - the first one is about the language
01:52 - being made for a specific purpose or if
01:54 - it is more open-ended for example sql
01:57 - and r are programming languages for
01:59 - highly specific purposes
02:01 - databases and data analysis respectively
02:05 - on the other side you have languages
02:07 - like python that can also analyze data
02:09 - and run databases but can do a lot more
02:12 - besides that
02:14 - this flexibility is one of the reasons
02:16 - why python is so popular it just can do
02:19 - a ton of different things
02:21 - although this line is not static the
02:24 - best example for that is html initially
02:27 - it was purely a language to make
02:29 - websites it was very much designed for a
02:32 - single purpose however over time people
02:35 - kept on adding more to it and nowadays
02:38 - you can make apps and games with html
02:41 - it became much more flexible and that is
02:44 - the main reason why modern websites are
02:46 - as powerful as they are
02:48 - the other axis is the level of
02:50 - abstraction
02:51 - now when i say a language is more
02:53 - abstract than another i don't mean to
02:55 - say it's more complex instead
02:57 - abstraction refers to how far removed a
03:00 - language is from physical computer
03:02 - hardware
03:03 - let's use html again
03:05 - to see a website written in html5 you
03:08 - first need a browser like chrome or
03:10 - safari that browser in turn runs on an
03:13 - operating system and only that operating
03:16 - system has access to actual physical
03:18 - computer hardware there is a huge
03:20 - distance between the html code and the
03:23 - computer it runs on
03:24 - that means html is a very abstract
03:27 - language
03:29 - this however does not mean that html is
03:32 - more difficult than a less abstract
03:34 - language quite the opposite actually in
03:36 - broad terms the more abstract a language
03:39 - is the easier it is to use
03:42 - that is because a less abstract language
03:44 - needs to work with computer hardware it
03:47 - needs to be very specific about memory
03:49 - management you sometimes have to write
03:51 - for different kinds of computer hardware
03:54 - and generally it is very easy to break
03:56 - things
03:57 - now in this axis python like html is a
04:01 - very abstract language in fact python
04:04 - itself was created using another
04:06 - programming languages that one is called
04:08 - c
04:09 - and this language is much less abstract
04:12 - generally in the bottom right of this
04:14 - graph you have all of the c languages
04:17 - like c c sharp and c plus plus you also
04:20 - have java down there the differences
04:22 - between them are mostly technical and
04:24 - you don't really have to worry about
04:25 - them at least for now that being said
04:28 - c-sharp was only created because
04:30 - microsoft didn't want to pay license
04:32 - fees to the creators of java these two
04:34 - languages are very similar so there can
04:37 - be a ton of overlap between these
04:39 - different languages they are not
04:41 - entirely unique
04:43 - now when you are just getting started
04:45 - you want to begin in the top right of
04:47 - this graph with more abstract general
04:50 - purpose languages
04:51 - these are easy to learn work everywhere
04:54 - there's a huge community for support and
04:56 - resources
04:57 - and you can use them for a huge variety
04:59 - of projects
05:01 - what you also want to be aware of is
05:03 - that all programming languages are
05:04 - somewhat similar if you know python for
05:07 - example you can learn c or sql much more
05:10 - easily
05:12 - this is actually a really common pattern
05:14 - people start programming in python and
05:16 - then migrate to another language
05:18 - python was actually designed to be a
05:20 - tool to learn programming itself and it
05:23 - just happened to expand over time to
05:25 - become a really popular languages by
05:27 - itself
05:28 - although that doesn't mean that you
05:30 - couldn't stick with python
05:32 - especially for data science think of
05:34 - artificial intelligence databases and
05:36 - data analysis python very often is the
05:39 - default choice and these are fields
05:41 - where you can earn a lot of money it is
05:44 - totally fine to stick with python by
05:45 - itself entirely for your entire career
05:48 - lots of people do that
05:50 - but generally if you are not sure yet
05:52 - what language you want to go for don't
05:54 - worry about it what you're learning in
05:57 - python can very easily be migrated to
05:59 - another language
06:01 - what you want to do is just get started
06:03 - somewhere and work on projects you like
06:05 - and see how far you get
06:07 - and if you feel like changing you can
06:09 - totally do that and not start from
06:11 - scratch a lot of things you are going to
06:13 - learn you can use in other languages as
06:15 - well
06:16 - you are always going to make some
06:18 - progress even if you are switching
06:21 - alright in this video we are going to
06:23 - install python and the main target of
06:26 - this session is to write hello world
06:28 - using python
06:30 - now this task you can approach in two
06:32 - ways
06:33 - number one you can do all of this on
06:36 - your computer and this is going to be
06:38 - the main way if you want to use python
06:40 - normally you want it to be installed on
06:42 - your computer now that being said you
06:45 - can also run python online and for that
06:47 - you don't have to install anything
06:50 - if you just want to have a quick look at
06:51 - python and check if you like it i would
06:54 - recommend to just run python online for
06:56 - now and then if you decide that you do
06:58 - like it you can install it properly so
07:01 - let's start with some websites that let
07:03 - you run python code there are quite a
07:06 - few actually
07:08 - here for example we have one website
07:10 - called programmist.com and this one lets
07:13 - you run python code online besides that
07:16 - you could also use other languages like
07:18 - c c plus javascript and quite a few more
07:22 - but in our case i want to get rid of all
07:24 - the code in here
07:26 - and to print anything in python
07:29 - remember we want to write the word hello
07:32 - world
07:34 - and to print this you have to do a
07:36 - couple of things first of all you have
07:38 - to put this entire
07:41 - phrase into quotation marks could either
07:43 - be single or double quotation marks and
07:46 - for now just follow along i will explain
07:48 - all of this in much more detail later on
07:50 - but now that you have this word it
07:53 - should be green
07:54 - and what you have to do now is write
07:56 - print
07:57 - and then put the quotation mark phrase
08:00 - inside of brackets which means we first
08:03 - of all have the word print then we have
08:06 - a bracket
08:07 - then we have hello world in quotation
08:09 - marks and then we have a closing bracket
08:14 - and if you have all of this you can
08:16 - click on run
08:17 - and now you get hello world if you could
08:20 - follow along so far you have written
08:21 - your first python code and if you don't
08:24 - want to install anything on your
08:25 - computer or register for anything this
08:28 - website here would be really really good
08:30 - so this is definitely something i would
08:32 - recommend you can also make it a bit
08:33 - larger that's a bit easier to read
08:36 - besides that there is also a website
08:39 - called rapple.8 or replit i'm never sure
08:41 - how to pronounce it
08:43 - in here you also have an online editor
08:45 - that you can use for python here we
08:48 - already have print hello world if i run
08:49 - this we get hello world for this one to
08:52 - use it properly you do have to register
08:54 - although it is a bit more powerful but
08:57 - both of these are really good to get
08:59 - started using python although keep in
09:01 - mind you are running all of this in a
09:04 - browser which is somewhat limiting what
09:07 - you ultimately want to do is run python
09:09 - on your own computer that way you have
09:12 - significantly more power and you also
09:14 - have more flexibility so this is what we
09:17 - want to do now for that we have to
09:19 - install python on your computer and the
09:22 - important thing to understand here is
09:24 - that python is just another program that
09:26 - you have to install on your computer
09:29 - it's working basically like word or
09:31 - excel or literally any video game
09:34 - and the file you have to install you get
09:36 - from python.org so let's have a look at
09:38 - this one
09:39 - here we have the python website and what
09:42 - you have to do is click on downloads and
09:45 - in here you want to download python and
09:47 - then the latest version right now this
09:49 - is
09:50 - 3.10.5 by the time you are watching this
09:52 - there's probably a higher number but
09:54 - that isn't going to make much of a
09:56 - difference so click on download and then
09:58 - you get the file downloaded and this is
10:01 - going to work with your specific
10:02 - operating system in my case i have
10:05 - windows but if you have a mac this would
10:07 - also work although you would get a
10:09 - slightly different file
10:11 - and once you have that you click on open
10:13 - file
10:14 - and now you get either install now or
10:17 - customize installation however
10:20 - before you do anything in here there is
10:23 - one incredibly important thing and that
10:26 - you can see down here it says add python
10:28 - 3.10 to path
10:30 - this is an incredibly important option
10:33 - that you absolutely have to take
10:36 - this one you really want to add i will
10:39 - explain later why this is important but
10:41 - do keep in mind this is incredibly
10:43 - important if you don't add this you are
10:45 - going to run into a ton of problems
10:48 - but besides that you can leave
10:49 - everything as it is and then click on
10:51 - install now
10:54 - then you get an installation
10:58 - and this one is going to work like
11:00 - literally any other program so just wait
11:03 - until it finishes and you should be good
11:05 - to go
11:08 - there we go the setup was successful now
11:11 - we can close it and
11:13 - nothing changed
11:14 - however now what you can do if you press
11:17 - the windows key you can type python and
11:20 - you have python 3.10 installed on your
11:22 - computer
11:24 - if you run this you get something like
11:26 - this in here you can write whatever you
11:29 - want for example what you could be
11:31 - writing is what we have already seen you
11:34 - can write
11:35 - print
11:37 - then in quotation marks hello world
11:41 - close the bracket and now if you press
11:43 - enter you get hello world and this was
11:46 - done using python
11:48 - in here you could also write something
11:49 - like one plus two you would get the
11:51 - result
11:52 - and you can do quite a bit more but this
11:55 - is basically valid python
11:58 - so with that we have basic python code
12:00 - although the limitation here is that we
12:03 - can only ever write a single line of
12:05 - code which well isn't great what we need
12:09 - is some kind of code editor and that we
12:12 - are going to cover in the next video
12:13 - because this is a slightly larger
12:15 - section
12:16 - and just to make sure that everybody can
12:18 - follow here i have mac os
12:20 - in there i still have to click on
12:22 - download python and now i'm downloading
12:25 - a pkg file
12:28 - other than that i can click on open file
12:31 - and now we're getting a python installer
12:34 - that messed with my window sorry about
12:35 - that but in here you click on continue
12:38 - you click on continue continue more
12:41 - you click on agree and then you click on
12:44 - install
12:45 - now you need your password
12:47 - as always install software
12:50 - and then you're just installing anything
12:53 - for mac os you don't have to worry about
12:55 - a path
12:56 - and now here you can see all of my
12:58 - programs and i have python 3.10
13:03 - although just wait a second and there we
13:04 - go now the entire thing finished i can
13:07 - click on close and move this thing to
13:09 - the bin and now i have python installed
13:12 - now to actually use it on macos i need
13:15 - my launcher and you have a program
13:17 - called python launcher although this one
13:20 - does look a bit weird in here you can't
13:23 - do very much although you have a tick
13:26 - box that says run in terminal window or
13:28 - at least i hope you do
13:30 - a terminal is another program inside of
13:33 - mac os
13:34 - if you open the launcher again and type
13:36 - terminal
13:37 - there you have a terminal
13:40 - and let me increase the font size here a
13:41 - bit so this is easier to read
13:43 - now what you want to do in here is you
13:46 - want to type python 3
13:50 - and then press enter and now you can
13:52 - write python code for example you could
13:54 - write print
13:56 - brackets open then quotation mark hello
13:59 - world
14:00 - and then closing quotation mark closing
14:02 - bracket and now if you print this you
14:04 - get hello world and like we have done on
14:07 - windows you could type one plus two and
14:09 - you're getting free
14:11 - and this is valid python code but once
14:14 - again you're only writing a single line
14:16 - of code
14:17 - but for that again we're going to work
14:19 - on the code editor
14:21 - in this part we are going to install a
14:23 - code editor and let's first talk about
14:25 - why we are going to need that
14:28 - right now we can run python code which
14:32 - is a really good start but we cannot use
14:34 - python comfortably
14:36 - right now we can write single lines of
14:38 - code but later on we want to write
14:40 - hundreds if not thousands of lines of
14:43 - code and right now we just cannot do
14:45 - that for that we are going to need some
14:48 - kind of text editor for our code think
14:50 - of this like word or pages it's simply a
14:53 - text editor except now we are writing
14:55 - code instead of sentences
14:57 - and there are a ton of popular code
15:00 - editors here's the list of the really
15:02 - famous one we have visual studio code
15:05 - pycharm atom and sublime
15:07 - although there are a lot more there
15:10 - basically is no end to code editors the
15:13 - one that i am going to use is called
15:15 - sublime this is a really straightforward
15:18 - and simple code editor that you can also
15:20 - customize quite a bit which i really
15:22 - enjoy
15:23 - but basically all of those would be fine
15:25 - if you have a strong preference although
15:28 - i would recommend just to follow along
15:30 - to also use sublime and this is going to
15:33 - be just another program that we have to
15:35 - install oh i should mention all of them
15:37 - are completely free you don't have to
15:38 - pay anything but let's install it
15:42 - alright here we are on the website of
15:44 - sublime and the url is sublimetext.com
15:47 - the full name of the code editor is
15:49 - sublime text but nobody really calls it
15:51 - that and then here you can go to
15:53 - download and download the entire thing
15:55 - now you can see it already probably
15:58 - there is also a buy option you can
16:01 - purchase sublime it costs about 80 i
16:03 - think but you don't have to do it the
16:05 - free version has exactly the same
16:07 - features and this is what we are going
16:09 - to use
16:10 - basically when you are buying it you are
16:12 - supporting the creators but you don't
16:13 - have to do it so in download you can
16:16 - download the version you need either mac
16:18 - os windows or linux in my case i need
16:21 - windows so i'm clicking on that and now
16:23 - i have a download for my specific
16:26 - version
16:28 - obviously if you have a different
16:29 - operating system this would look a bit
16:31 - different but now you click on open file
16:35 - and then you get this kind of menu in
16:38 - here you just click on next
16:40 - and you install it
16:42 - like anything else and
16:45 - finish there we go now you have
16:47 - installed sublime
16:49 - on mac os the installer might look
16:50 - slightly different but that is minor
16:53 - details
16:54 - but once you have all of that you can
16:56 - type sublime text
16:58 - and now you should be seeing something
17:02 - like this this is our code editor
17:05 - and in here you can write any
17:07 - kind of text whatever you want to write
17:11 - in my case what i want to write in here
17:13 - is print
17:15 - and brackets
17:17 - and now quotation marks hello
17:20 - world
17:21 - and this is going to be the python code
17:23 - we want to execute
17:25 - now to execute all of this we need two
17:28 - major steps
17:30 - number one this is the easy one we have
17:32 - to save our file this we do under file
17:36 - and save or controller command s
17:40 - if i do that
17:41 - i end up somewhere in my file system in
17:43 - my case i have the folder here already
17:46 - you can save it wherever you want it
17:47 - really doesn't make any difference
17:50 - although what does make a difference is
17:52 - the naming of the file
17:53 - let me call this one test
17:55 - but you do have to specify an ending so
17:58 - you want dodge and then add p y short
18:02 - for python this is telling your computer
18:04 - that you have a python file
18:06 - you could compare all of this to word
18:09 - which always needs a docx ending or a
18:12 - text file which always has a txt ending
18:15 - but in our case we want dot pi and now i
18:17 - want to save
18:19 - and what you should be seeing now is
18:21 - that the colors of our text changed
18:25 - if they didn't don't worry too much
18:26 - about it but now what you want to do let
18:29 - me show my mouse
18:31 - and i want to go to tools
18:33 - and in here we have build and build with
18:36 - this basically means you want to execute
18:39 - your code
18:40 - i want to click on build
18:42 - and now i can see hello world down here
18:46 - now you might be seeing something else
18:48 - what you might be seeing is
18:51 - a dialog that looks something like this
18:54 - in here you want to select python so if
18:56 - i click on this one you're getting the
18:58 - same result
19:00 - the reason here is when you're running
19:02 - python for the first time sublime does
19:05 - want to double check that you do indeed
19:06 - want to run python but if you have done
19:09 - that once sublime does remember
19:12 - and most of the time what i am going to
19:14 - do
19:14 - is instead of up here clicking on build
19:17 - i am pressing ctrl or command b
19:20 - this one is going to give you the same
19:22 - result and if you want to close this
19:24 - dialog down here you press on escape
19:28 - although there is a really important
19:30 - topic i do want to cover
19:32 - and that is
19:34 - when we are running any kind of code in
19:36 - sublime what essentially happens is that
19:39 - sublime inserts all of the code into the
19:41 - python app however sublime doesn't know
19:44 - by default where that python app is
19:47 - because remember python is just another
19:50 - program on our computer it's nothing
19:52 - special
19:53 - the only reason sublime right now can
19:56 - find the python app is because of the
19:58 - path files
20:00 - these path files are basically a
20:02 - directory inside of windows that makes
20:04 - it easier for programs to find other
20:07 - programs
20:08 - and because of that sublime can find
20:11 - python very easily if we didn't add
20:13 - python to the path though sublime would
20:16 - not be able to find it and you would
20:18 - have to add quite a bit more yourself to
20:20 - make it all work which fortunately we
20:23 - didn't need because we did add python to
20:25 - the path files
20:27 - if you forgot that for some reason just
20:29 - uninstall python and reinstall it with
20:31 - the pathfire selected that's the easiest
20:33 - way to go on about it
20:35 - but alright what you can do now you
20:38 - could for example copy this line here
20:41 - and paste it multiple times run all of
20:44 - this
20:45 - and you can see hello world multiple
20:47 - times
20:48 - once again how all of this works in
20:50 - detail i will cover in the next well 10
20:53 - hours or so
20:54 - but in here what you can also do
20:57 - is inside of print add a math operation
21:00 - like 5 10 and now run all of this again
21:03 - under tools and build and you get 15 all
21:07 - the way at the end
21:09 - and with that we can run python code
21:12 - over multiple lines
21:14 - so with this we can basically start the
21:17 - actual python tutorial
21:19 - although before we get started on that
21:22 - there's one more thing i do want to do
21:23 - that you don't necessarily have to
21:25 - follow because i think all of this is
21:28 - looking kind of ugly and a bit hard to
21:30 - read
21:31 - as a consequence i want to change the
21:33 - styling
21:34 - but i am literally only going to change
21:37 - the look of sublime in terms of
21:38 - functionality nothing is going to change
21:42 - so if you want to skip this part you can
21:44 - totally do so
21:46 - let me show my mouse what i want to do
21:48 - most importantly under view i can hide a
21:51 - couple of things that we don't need for
21:54 - example all the way in the bottom
21:56 - you can see a couple of bits of
21:58 - information that we don't need so i want
22:01 - to hide all of this
22:02 - this is the status bar and i want to
22:04 - hide the status bar
22:07 - already looking better
22:09 - besides that up here you can see the
22:12 - tabs
22:13 - if you have multiple python files this
22:15 - can be really useful each tab would be
22:18 - one python file
22:19 - but for a long time we are only ever
22:22 - going to have a single python file later
22:25 - on we are going to use these tabs though
22:27 - but for now i want to go to view and
22:30 - hide tabs
22:31 - already looking much cleaner
22:34 - besides that what you can also do is
22:37 - hide the menu and this is making
22:40 - everything look even cleaner
22:41 - if you want the menu back you are
22:43 - clicking on alt and now you can see it
22:45 - until you click outside of it but then
22:47 - you can bring it back
22:49 - and all of this is already looking
22:51 - significantly cleaner now if you want to
22:53 - get rid of this top bar here you have to
22:56 - click on f11 and now you have a full
23:00 - screen app
23:01 - which i think is much nicer to work in
23:04 - now what you can also do is change the
23:07 - text size
23:08 - what you do with controller command and
23:10 - then either the equal or the minus sign
23:12 - equal makes the text larger minus makes
23:15 - the text smaller
23:17 - and in here just choose whatever you can
23:19 - see best in my case i usually aim for
23:22 - having 30 lines of code on one screen
23:25 - so in my case the font size i usually
23:28 - choose if i copy this a couple of times
23:32 - is something like this
23:35 - i have 30 lines of code on one window
23:37 - but this is entirely subjective you
23:40 - probably want to have something smaller
23:42 - and finally what we can do is change the
23:46 - color scheme and the theming of this
23:48 - and for this you can install external
23:51 - themes this you do with control or
23:53 - command shift and p
23:55 - if you click all of them
23:57 - you get a couple of options that you can
23:59 - use inside of sublime in here you want
24:03 - to click on
24:04 - install package now click on enter
24:07 - now sublime is going to think for a
24:09 - second and now you can install external
24:11 - modules
24:12 - some of these change the functionality
24:14 - of sublime but most of them are just
24:16 - different color schemes
24:18 - and in my case what i want to install is
24:21 - the agila theme so if you type agila
24:24 - this should be the first result and now
24:27 - just press enter
24:30 - and there you can see
24:33 - the nodes for the argila theme but we
24:36 - don't care about that now to get back to
24:38 - our code you want to press alt for the
24:40 - menu
24:41 - and at least for now i do want to show
24:43 - tabs so we can navigate around here
24:46 - although this package control message
24:48 - you can close by clicking on the x here
24:50 - and now we are back in the code but
24:53 - nothing has changed now to actually
24:55 - apply the changes you have to go to
24:58 - preferences
24:59 - and in here you have select a color
25:01 - scheme and select a theme
25:04 - let's start with the theme in here you
25:06 - have a bunch of different themes if you
25:08 - click on down you can see what is
25:11 - changing
25:15 - so if i click on a couple
25:17 - you see what the difference is in my
25:19 - case i just want to use the agile theme
25:21 - so if i click on this we already have a
25:23 - couple of changes what you can also do
25:26 - now if you click on preferences again
25:28 - you can select the color scheme this one
25:31 - changes the actual code in terms of what
25:33 - you see and in here once again you can
25:36 - select a lot of different things i don't
25:38 - want to go over this too fast because it
25:40 - might be a ton of colors and well i
25:43 - don't overwhelm you but in here you can
25:45 - search for different color schemes
25:48 - depending on what you have installed
25:50 - in my case i'm gonna look for agila and
25:53 - then oceanic next
25:57 - if i select this one all of this is
26:00 - looking significantly nicer
26:02 - if i now
26:04 - go to view and
26:06 - hide the tabs
26:07 - this is basically what you're going to
26:09 - see most of the time and i think this is
26:11 - much easier to read although you might
26:14 - be wondering what is this line here on
26:17 - the left and
26:18 - well for now you really don't have to
26:20 - worry about it it's something much more
26:22 - advanced you can entirely ignore it as a
26:25 - consequence since it is not going to be
26:28 - relevant for this entire tutorial i have
26:30 - hidden it
26:31 - which is bringing us to some more
26:33 - optionality inside of sublime so if i go
26:36 - to preferences and here i go to settings
26:40 - we get another window and in here you
26:43 - can see the settings
26:45 - now you might be used to other programs
26:47 - you just have checkboxes in sublime this
26:50 - is working a bit different you are
26:52 - basically
26:53 - having on the left here all of the
26:55 - different options you could be changing
26:57 - for example you could change the margin
26:59 - size to a four and to change this
27:02 - you would have to copy this one here and
27:04 - paste it on the right side
27:07 - like this and now you can change the
27:09 - margin to whatever you want although my
27:11 - case i don't want to do this
27:13 - and i don't want to add too many
27:15 - complications in here because all of
27:17 - this is getting a bit more advanced so
27:20 - what i'm going to do is i have a text
27:22 - file let me increase the size of the
27:24 - right one
27:25 - i have a text file that you can just
27:27 - copy if you want to have the exact same
27:29 - styling that i do you just paste it in
27:31 - here
27:32 - and now if you click on control s to
27:34 - save everything
27:36 - you should see not much of a difference
27:38 - although the yellow bar for example
27:40 - disappeared
27:41 - and all of these options here you can
27:43 - find in the description
27:45 - so with that you can minimize all of
27:47 - this and now all of this looks as clean
27:50 - as it can be at least i think so
27:53 - so with that we have python installed
27:55 - and we can get started i want to start
27:58 - by talking about how code in python or
28:02 - in basically any programming language is
28:04 - being executed
28:06 - and there are a couple of things you
28:07 - have to understand
28:09 - the most important concept is that code
28:12 - will always be executed from the first
28:14 - to the last line for example if we have
28:17 - these three lines of code python is
28:19 - going to start from the top so line one
28:22 - this one here
28:23 - then we do line two line three
28:26 - and then we continue until we reach the
28:28 - end of the code
28:31 - and later on we are going to learn some
28:33 - tools to make this more flexible
28:36 - for example if we want to repeat code or
28:38 - only run code if a certain condition is
28:40 - true but for now i just want to execute
28:44 - some basic code so we can get started
28:47 - and let's have a look at all of this in
28:49 - some actual python file
28:51 - and here we have a completely empty one
28:54 - and something we have seen already is to
28:57 - use the print statement and in here you
29:00 - can just write a random word
29:02 - so a random word
29:05 - and now if i execute the code
29:08 - which again i do with ctrl b or if i
29:11 - press alt
29:12 - i can go to tools and build
29:16 - same thing if i click on it i get a
29:19 - random word
29:20 - and just to be a bit more specific here
29:23 - let me change this word to first line of
29:27 - code
29:28 - and now if i add another print statement
29:31 - let me duplicate this line which i by
29:33 - the way do with ctrl shift and d that
29:36 - way you can duplicate lines and sublime
29:38 - very easily
29:40 - now what i want to do for the second
29:42 - line of code i want to rename this to
29:44 - second line of code
29:46 - and now if i run this we get the second
29:49 - line of code
29:50 - meaning this line here was run first
29:52 - then we have number two and this would
29:54 - then continue forever we are essentially
29:58 - executing code downwards in this
30:00 - direction
30:01 - and this would work with any other data
30:03 - type as well for example i could print
30:06 - some numbers and now we will get one two
30:09 - and three
30:10 - and that is then giving us the most
30:13 - basic thing you have to understand that
30:14 - now we can execute some lines of code
30:18 - and i suppose there's one more important
30:20 - thing when we are talking about words
30:22 - and print and that is let me copy this
30:25 - again
30:26 - a space in here would also show up
30:29 - meaning if i add a ton of white space
30:32 - and run this again
30:34 - we now get this line of code here let me
30:36 - rename it really quick third line of
30:39 - code
30:40 - all of this white space here is still
30:42 - showing up
30:44 - so just keep that in mind
30:46 - and well with that we have covered all
30:49 - of the basics of really basic code
30:52 - execution
30:53 - and i guess with that let's do an
30:55 - exercise
30:57 - i want you guys to use these print
31:00 - statements to print some kind of tree
31:03 - looking shape and for that you want to
31:06 - use basic characters and white space and
31:09 - then combine these two and create that
31:11 - shape so pause the video now and see how
31:14 - far you get
31:18 - the way you have to think about it i
31:20 - want to print again and i want to write
31:23 - five axes
31:25 - and if i run the code now we can see
31:28 - these five axes
31:30 - if i now print these five axes again one
31:34 - two three four five
31:35 - but
31:36 - remove the first two and replace them
31:39 - with a space
31:41 - if i now do this i get the three axis on
31:44 - top of the five axes
31:46 - and before the first x we have a white
31:48 - space so we start to have some kind of
31:51 - pyramid shape
31:53 - i just want to continue
31:55 - i want to print two spaces and an x and
32:00 - if i run the code now
32:01 - we can see we have a proper triangle and
32:05 - this would be the top of my tree
32:07 - and now i can copy this line
32:10 - and at the bottom of the tree i can add
32:13 - it 3 times if i run this now
32:15 - we have a tree this is looking pretty
32:19 - good
32:20 - granted it doesn't look too nice but it
32:23 - is what it is
32:24 - i suppose
32:26 - what we can also do i can just print
32:29 - empty strings with no word inside if i
32:31 - do that
32:32 - we have one line of space between the
32:35 - words we have covered earlier and our
32:37 - tree although one important thing really
32:39 - quick there is one line in here
32:42 - that i left intentionally empty to
32:44 - organize my code
32:46 - for python this line does not exist if i
32:49 - run the code the empty line we have here
32:52 - is because of this empty statement this
32:56 - one comes right below the one two three
32:58 - this one to three this line for python
33:01 - is just being ignored
33:03 - meaning if you don't write a line of
33:04 - code python is just going to ignore it
33:07 - which is really helpful to keep your
33:09 - code organized so alright this is then
33:13 - the most fundamental thing you have to
33:14 - understand and it's pretty simple we are
33:17 - just executing code from the top to the
33:19 - bottom
33:20 - in this part we are going to learn about
33:22 - math operations and those are in python
33:26 - fairly similar because you probably
33:28 - already know them from basic math
33:30 - classes that you learned when you were
33:32 - something like 5 or 6 it's really basic
33:35 - we have plus minus multiply and divide
33:38 - and besides that we also have power
33:41 - floor divide and remainder i guess the
33:43 - letter 3 are a tiny bit more advanced
33:45 - but not that much
33:48 - besides that
33:49 - you can also use brackets perfectly fine
33:52 - like in any kind of computer calculator
33:54 - you ever used
33:56 - there are also comparison operators like
33:59 - smaller than or smaller equal then
34:01 - but those we will cover later because
34:03 - they work ever so slightly differently i
34:06 - guess i can talk about them for a tiny
34:08 - bit but don't worry about those too much
34:10 - yet
34:11 - let's have a look at all of this
34:13 - here again i have a completely empty
34:15 - python file
34:17 - and i want to start by printing a math
34:20 - operation and this i just do by typing
34:23 - the math operation in here for example
34:26 - 10 plus 5
34:28 - is going to give me 15.
34:31 - and that is literally it it's quite
34:34 - simple
34:35 - if i duplicate this line
34:37 - i can change this to a minus
34:40 - and now we get 5.
34:43 - i could duplicate this again
34:45 - change this to multiply and duplicate it
34:47 - once more
34:48 - and change this to divide and that way
34:51 - we have all the basic operators
34:53 - so if i run this we get 15 5 50 and 2. i
34:58 - guess the one thing you do want to
35:00 - notice here is that when we're using
35:02 - division this operation here python is
35:04 - giving us 2.0
35:07 - it happens to add a point zero even
35:09 - though we wouldn't need it
35:12 - it's really not a big deal but just keep
35:15 - it in mind besides that we have slightly
35:17 - more advanced math operators
35:19 - let me print
35:21 - 10
35:22 - star star and 5 and this is giving us a
35:26 - fairly large number
35:28 - because we are taking the power here i
35:30 - guess if i do a 2
35:33 - we have the equivalent of 10 to the
35:35 - power of 2 which is 10 multiplied by 10
35:40 - which is 100
35:43 - and this is what we are getting down
35:44 - here
35:45 - besides that we also have what is called
35:48 - a floor divide
35:50 - and to understand what that means
35:52 - let me divide 10 by 3. if i do this we
35:56 - get
35:58 - 3.333 and it continues basically forever
36:02 - if floor divide essentially gets rid of
36:05 - all of the stuff after the decimal point
36:07 - and this floor divide you get with two
36:10 - divide symbols
36:12 - meaning if i run the code now we are
36:14 - only getting three
36:16 - you are essentially rounding the result
36:19 - of whatever you are getting in here
36:21 - although keep in mind
36:23 - this value
36:25 - is not rounding the result
36:27 - what we're doing is truncating the
36:29 - result which is a fancy word for saying
36:32 - we are cutting off anything after the
36:34 - decimal point
36:35 - i can demonstrate this by dividing 7
36:39 - over 2.
36:41 - if you do this in your head you are
36:43 - going to get
36:44 - 3.5 with a normal division
36:47 - and if we were to round this number it
36:50 - should be 4 because 0.5 is closer to 4
36:53 - than it is to 3
36:55 - but if i run the code again i am getting
36:58 - 3.
36:59 - and just be careful here this can
37:01 - sometimes cause you some errors where
37:02 - you're losing decimal points and then
37:04 - end up thinking you're rounding when
37:06 - you're not actually doing that
37:08 - there's one more math operation we need
37:10 - and that is done with the percentage
37:12 - sign
37:13 - for example this could look like seven
37:16 - percentage two
37:18 - and if i run this let's see what we get
37:20 - we are getting one
37:22 - and this one here is the remainder
37:26 - the best way to think about it is
37:29 - we have seven units in total
37:32 - we have one two three four five six and
37:37 - seven
37:38 - and when we are dividing seven by two
37:41 - we are basically looking for two whole
37:43 - units to get a full number
37:45 - meaning here is one
37:47 - there is two
37:48 - and here is 3.
37:51 - and that is giving us the result we got
37:53 - from this operation
37:55 - and
37:56 - this
37:58 - percentage symbol is giving us whatever
38:00 - remains at the end which is this one
38:02 - here and since this is one the one we're
38:06 - getting down here is well a one
38:09 - you don't see this symbol too often but
38:12 - it can be really useful to figure out if
38:14 - a number is even or odd something you do
38:16 - surprisingly often we're going to have a
38:18 - look at that later
38:20 - there's one more thing i do want to
38:22 - cover and that is brackets
38:25 - for example i could print
38:27 - 5 times 2
38:29 - and the result
38:31 - is going to be 10 this should be fairly
38:33 - simple
38:34 - but now if i do 5 plus 5 multiplied by 2
38:39 - think about it for a second and see what
38:40 - you should be getting
38:43 - the result is 15 and it is 15 because we
38:48 - always do multiplication first and then
38:52 - we are doing addition and subtraction
38:54 - meaning this operation is basically 5
38:57 - plus 10 which gets us 15.
39:02 - if i don't want to do that and add 5
39:04 - plus 5 first of all i have to put both
39:07 - of those into brackets and now i'm
39:09 - getting 20.
39:11 - what we're doing now is 5 plus 5 is 10
39:14 - and this we multiply with 2 which is
39:17 - getting us 20.
39:19 - i guess the one thing we can also cover
39:22 - is very simple comparison operators
39:26 - and those do work in the same way that
39:29 - you would expect them to work to be
39:30 - honest for example i could type 10
39:34 - is greater than 5.
39:37 - the difference here is the result we are
39:39 - getting because the result we're getting
39:41 - is true
39:43 - which i guess doesn't make sense because
39:45 - 10 indeed is greater than 5.
39:48 - if i flip this around
39:49 - that 10 is smaller than 5 and run the
39:52 - code again
39:53 - we are getting false
39:55 - and how we can use these values we will
39:58 - see later on but for now don't worry too
40:01 - much about this one
40:03 - now with that we have covered the basic
40:05 - operations
40:06 - and let's do an exercise
40:08 - what i want you guys to do is to get the
40:10 - average of the numbers from one to seven
40:13 - so one plus two plus three plus four
40:15 - plus five plus six plus seven all
40:17 - divided by seven
40:19 - and see how far you
40:22 - get once again i have to type print and
40:26 - now in here i want one plus two plus
40:30 - three plus four plus five plus six plus
40:35 - seven
40:37 - and all of this has to be inside of
40:40 - brackets because what we're going to do
40:42 - afterwards is divide all of this by 7.
40:46 - and the issue is in terms of math if we
40:49 - left it like this we would first divide
40:51 - seven by seven which would be one and
40:53 - then we are adding all of these numbers
40:56 - but what we want to do instead
40:58 - is do all of this here first
41:01 - and then divide it by seven
41:04 - for this sort of thing sublime is quite
41:06 - intelligent i can just select the entire
41:08 - text
41:10 - create and open brackets and then
41:12 - sublime automatically adds the closing
41:14 - bracket afterwards
41:16 - and with that we are done if i execute
41:20 - the code now we get 4.0
41:23 - although looking at the result here i
41:26 - realized for this entire part so far i
41:29 - have only ever used full numbers which
41:32 - you don't have to it is perfectly fine
41:34 - to write something like one plus one
41:36 - plus five
41:38 - you would still get the appropriate
41:40 - result any number in here is going to be
41:42 - fine this is working like any math
41:45 - operation you have ever seen
41:48 - in this part we are going to talk about
41:51 - how to connect different lines of code
41:53 - and let me explain the problem
41:56 - let's say we have some kind of math
41:58 - operation
41:59 - and we want to print the result of that
42:01 - map operation on the next line
42:04 - the issue we have now is how can we
42:06 - connect these two lines
42:08 - and the answer here is we are going to
42:11 - need variables
42:13 - and variables are an incredibly
42:15 - important topic in any programming
42:17 - language
42:18 - so let's talk about it
42:20 - all that variables essentially are is a
42:24 - simple container for any kind of data
42:28 - we could for example put a word a number
42:30 - or really anything we have a python in
42:32 - there
42:34 - and once you have created this container
42:36 - you can reuse it over and over again
42:39 - and this variable you create like this
42:42 - we have the variable name
42:44 - then we have the assign operator and
42:46 - that is just an equal sign and then we
42:49 - have the actual data or the value we
42:51 - want to assign
42:52 - and that is basically it
42:55 - this instead of a word could also be a
42:57 - number like one and it could be anything
43:00 - else
43:01 - but how you would solve the earlier
43:03 - problem is you would first store the
43:06 - math operation result in a variable
43:08 - called result
43:09 - and then this result you would print on
43:12 - the next line
43:14 - and i suppose let's actually try all of
43:17 - this
43:18 - once more completely empty python file
43:20 - and in here i want to do a map operation
43:23 - again and so far we always used print
43:26 - and then did some math in here let's say
43:29 - ten plus five
43:30 - but this print we don't need
43:34 - we could just have lines like this
43:36 - although if i execute the code now again
43:39 - by pressing ctrl b
43:41 - nothing would happen
43:43 - although
43:44 - something did happen python did
43:46 - calculate the result here
43:48 - we just didn't tell to print the result
43:50 - so it doesn't print a result and we
43:52 - can't see anything but something did
43:55 - indeed happen instead of printing this
43:57 - result i want to store it in the
43:59 - variable
44:00 - and this variable i called result
44:03 - and this is going to be the name of my
44:05 - variable now
44:07 - and now to assign this value here to
44:09 - this result
44:11 - we are going to need
44:14 - the equals sign
44:16 - which is telling python that the result
44:18 - of this operation should be assigned to
44:20 - this variable
44:22 - and now on the next line we can just
44:25 - print that result
44:28 - and if i run the code now we are getting
44:31 - 15
44:32 - or the result of this operation here and
44:36 - what is even better
44:38 - we could use this result for further
44:40 - operations and we would use it like the
44:43 - actual value
44:45 - for example what i could be doing
44:48 - i could have another variable let's call
44:50 - it result 2 and the value here should be
44:54 - the original result
44:56 - divided by 2.
44:58 - and if i now print result 2
45:02 - we can see we get 15 and 7.5
45:06 - which is this result divided by 2.
45:09 - and this we could do forever this result
45:12 - is basically a stand in for the value we
45:15 - have created here
45:17 - although there's one thing you do want
45:20 - to be careful about and that is variable
45:23 - naming let's talk about this one really
45:25 - quick there are two variable naming
45:28 - parts the first one is the mandatory
45:30 - parts that you have to follow if you do
45:33 - not follow these naming conventions
45:34 - python is going to throw an error
45:37 - and fortunately they are fairly simple
45:40 - the most important one is that variable
45:42 - names can only contain letters numbers
45:45 - and the underscore symbol
45:47 - you couldn't use something like the
45:48 - dollar sign percentage space something
45:51 - like this space in particular should
45:54 - make sense quite intuitively if there's
45:56 - a space in a variable name it's really a
45:59 - python to tell if we have one variable
46:01 - or two variables it just gets messy
46:04 - and if you have a longer variable name
46:07 - and you want to add multiple words
46:09 - together you would use an underscore and
46:11 - that is quite a common thing to do i
46:13 - will show you in a second
46:15 - the second rule is a variable name must
46:18 - start with a letter or an underscore the
46:20 - important thing here is numbers are not
46:23 - allowed a variable name cannot start
46:25 - with a number finally variable names
46:28 - must be different from the inbuilt
46:30 - python tools for example we couldn't
46:33 - name a variable print
46:35 - i hope this one makes sense as well it
46:37 - would just be confusing
46:39 - and i guess let's have a look at all of
46:42 - these rules and see if we can play
46:44 - around with them
46:46 - i want to create a new variable let me
46:49 - call it test
46:50 - and then here we can just add a word
46:52 - test it doesn't really matter
46:55 - if i run this code now
46:57 - we are not getting an error because this
47:00 - variable name here is perfectly fine
47:03 - and i could also add an underscore add
47:06 - some numbers add another underscore and
47:09 - add some capital
47:13 - letters
47:14 - all of this for python totally fine
47:17 - although this name here
47:19 - probably really confusing
47:21 - what python doesn't like let me put this
47:24 - on the next line is if we for example
47:27 - start with a number for the variable
47:30 - let's say to test
47:32 - and the value here could be test again
47:34 - it doesn't matter
47:36 - if i run this now
47:37 - we are getting a syntax error
47:40 - oh well we are getting quite a bit let's
47:42 - actually go through this error message
47:44 - here
47:45 - first of all python is telling me which
47:47 - file has caused the error
47:49 - and also it's telling me on what line
47:51 - the error occurred line 8 in this case
47:55 - which you can see here on the left side
47:58 - besides that i also get the actual line
48:00 - that caused the error so 2 test is equal
48:03 - to test
48:04 - and below that we have the really
48:07 - important information
48:08 - and that is
48:10 - this syntax error
48:12 - invalid decimal literal it sounds
48:15 - somewhat cryptic but what python is
48:17 - complaining about here is that we are
48:19 - starting a variable name with a letter
48:22 - however if i change this to
48:24 - 2 test
48:26 - everything is working just fine again
48:29 - and on top of that adding a number
48:32 - anywhere else inside of the variable
48:34 - name is perfectly fine i could for
48:36 - example add the two at the end this
48:38 - would also work just fine
48:40 - the other thing that you are really not
48:42 - allowed to do is to add spaces in your
48:44 - variable name
48:45 - and if i run this one now we are getting
48:48 - invalid syntax again
48:50 - and here python is giving me a ton more
48:53 - information although it really doesn't
48:55 - tell me all that much
48:57 - this line here is the really important
48:59 - one
49:00 - and i think it does make sense why
49:04 - there's no space allowed
49:06 - if we have something like this it looks
49:08 - like we have two separate variables
49:10 - which obviously would be kind of
49:12 - confusing so what programmers i usually
49:15 - do in basically any programming language
49:17 - is they always add underscore signs to
49:20 - show that we want to add a space
49:23 - but with that we have all of the basics
49:25 - for variable naming or at the very least
49:27 - the mandatory parts
49:28 - there are some more that are more
49:30 - optional let's talk about those
49:33 - the most common rule that you are going
49:35 - to see is that you should use snake case
49:39 - and snake case just means
49:42 - that when you are starting a new word
49:44 - you always start with lowercase
49:46 - and every additional word always is
49:49 - lowercase you basically only use
49:51 - lowercase letters
49:52 - and then to connect words you're using
49:55 - the underscore and this one you have to
49:57 - use anyway since this is a python rule
50:00 - what snare case basically means is you
50:03 - are always going to use lowercase
50:05 - letters and space is replaced with an
50:07 - underscore that's all it means
50:09 - besides that the other rule is that
50:12 - variable names should make sense
50:15 - this sounds very obvious but i can show
50:18 - you a couple of examples in just a
50:20 - second that might get very confusing
50:23 - generally it's fine to have longer
50:25 - variable names but make sure that the
50:27 - variable name expresses its content
50:30 - it's very easy to not do that and end up
50:33 - with code that you do not understand
50:34 - anymore
50:36 - so always write long names that express
50:38 - what the variable actually does and
50:41 - finally variable names should be
50:43 - consistent
50:45 - i suppose this one is pretty obvious
50:48 - and i guess the really important one is
50:50 - this one here because this one is
50:53 - looking terrible
50:54 - if you were working with other people
50:56 - and try to name a variable like this
50:59 - you would have some questions about your
51:01 - mental wellness i suppose
51:05 - something better would be more like test
51:07 - variable
51:09 - and let's call it practice
51:11 - this one here would be a perfectly fine
51:14 - variable name it isn't a snake case
51:17 - because we have lowercase letters and we
51:19 - are connecting the words with an
51:21 - underscore and this one here would also
51:23 - be at least a valid python name but we
51:27 - are kind of inconsistent we are first
51:29 - writing a word with letters and then the
51:31 - actual number
51:32 - so what you might want to do here is
51:35 - write 2 a bit more consistently or don't
51:37 - use any numbers when variable names
51:40 - begin and always stick with numbers
51:43 - whatever you prefer just be consistent
51:45 - it really helps
51:47 - the final thing i really want to mention
51:49 - what i see a lot of beginners do is do
51:52 - something like x equals i don't know
51:55 - some
51:56 - words
51:57 - and this is fine for shorter programs
52:01 - but once you have longer ones it can be
52:03 - really confusing
52:05 - meaning you want to replace this with
52:06 - something that actually means something
52:09 - it is a really common thing that you
52:11 - write a program you don't look at the
52:13 - program for half a year then you come
52:14 - back to the program and you have no idea
52:16 - what you did half a year ago
52:19 - happens to literally every programmer
52:21 - and naming your variables properly makes
52:24 - it a lot easier to read what your code
52:26 - actually does
52:28 - so name your variables properly
52:30 - there's one more thing that i really
52:32 - want to do because now that we have
52:33 - variables we get a few more math
52:36 - operations
52:38 - although those math operations are going
52:41 - to look a bit weird
52:43 - they are looking like this we have plus
52:46 - equal minus equal divide equal and
52:48 - multiply equal
52:50 - i think to explain what they do let's do
52:52 - an example
52:54 - let's say i have num one is equal to one
52:57 - a really basic variable and i want to
53:00 - increase the value of this num by a
53:03 - certain amount for example let's say by
53:06 - 5.
53:07 - to do that
53:09 - i could write some code like this that
53:12 - num1 is itself plus 5.
53:15 - and this would be fine but this also
53:17 - feels kind of clumsy
53:19 - and for that we have these operators
53:22 - here
53:23 - what you would do instead in python is
53:25 - something like this
53:26 - we have num itself
53:28 - then plus equal 5
53:31 - and those two
53:33 - code snippets here do exactly the same
53:36 - thing they take the original variable
53:38 - and then add a certain value to it
53:41 - let's do this in code actually i think
53:42 - that's going to make more sense
53:44 - i want to create another variable let me
53:46 - call it num1 and by default this one is
53:49 - 10.
53:50 - and now this 10 i want to increase by 5
53:54 - again
53:55 - and
53:56 - this could look like this
53:58 - i want to get my original num1 and then
54:00 - add
54:01 - 5 to it
54:03 - if i now print
54:04 - num 1
54:06 - we are getting the value all the way at
54:08 - the end which is 15 again
54:10 - i guess let me use different numbers so
54:12 - we get some different results
54:15 - now we get 20 which is 10 the value of
54:18 - num1 plus 10.
54:20 - but again this here is kind of clumsy
54:24 - and python gets around this biting plus
54:28 - equal and then we are adding 10
54:31 - meaning now we are taking the original
54:34 - value of num1 and adding 10 towards it
54:37 - and assigning all of this again to num1
54:41 - and if i run this we are getting the
54:43 - same result
54:44 - so
54:45 - if i spell this out
54:47 - a bit better
54:50 - these two lines here are doing the exact
54:53 - same thing
54:54 - and this is working with the other math
54:56 - operators as well for example we could
54:58 - have minus equal and we are getting zero
55:02 - we could add multiply equal
55:04 - which is getting us a hundred and we
55:06 - have divide equal which is getting us
55:09 - one
55:10 - and if you just want to update a
55:12 - variable this is how you would do it
55:15 - and this is now bringing us to the
55:17 - exercise for this part and what i want
55:20 - you guys to do is to create a variable
55:24 - that has some kind of snake case and try
55:26 - to use a bit of a longer word
55:28 - assign a value to it and on the next
55:31 - line increase this value by 20
55:34 - and then on the third line print the
55:36 - variable
55:41 - let's get started by creating a
55:43 - really long
55:45 - variable
55:47 - name
55:48 - that
55:50 - is
55:50 - a
55:51 - bit
55:53 - annoying
55:56 - obviously you would never use something
55:57 - like this in practice but i hope you get
55:59 - the idea
56:01 - and the value i want to assign is let's
56:04 - go with 10.
56:05 - on the next line
56:07 - i want to get my really long variable
56:09 - name that is a bit annoying and i
56:11 - realized i do have a typo let me fix it
56:14 - really quick and i want to increase this
56:17 - value so i want plus equal and i think i
56:21 - said 20.
56:23 - and now finally i want to print my
56:26 - really long variable name that is a bit
56:28 - annoying
56:29 - and if i print this we are getting 30.
56:32 - and with that we have variables which is
56:34 - an incredibly important concept
56:37 - in this part we are going to talk about
56:39 - functions
56:41 - and all that functions are are special
56:43 - commands in python we have actually seen
56:46 - one already and that is print which is
56:49 - printing a certain kind of text this one
56:52 - you should be really familiar with at
56:53 - this point
56:55 - but there are quite a few more for
56:57 - example len gives you the amount of
56:59 - characters in a word
57:01 - and another one would be abs or absolute
57:05 - which is giving you the absolute number
57:07 - which in practice just means if we have
57:10 - a negative one and we're using apps this
57:14 - is turning into a one
57:16 - although to understand functions we need
57:18 - one really important concept and that is
57:21 - brackets
57:23 - meaning when we're adding brackets after
57:25 - the name of the function
57:26 - we are calling it
57:28 - and this we have done multiple times
57:30 - already anytime we use print we have
57:33 - called a function by adding brackets
57:35 - afterwards and inside of the brackets we
57:38 - are adding what is called arguments
57:40 - for example for print we can add any
57:42 - kind of argument and this is then what
57:45 - we are going to print in the case of
57:47 - well print
57:48 - and let's have a look at all of this in
57:51 - code i want to once again start with
57:54 - print and this is the name of the
57:56 - function
57:57 - and to call it i need brackets
58:00 - and what we're adding in here is the
58:03 - argument which right now is the word
58:05 - which
58:06 - that's called test and what this
58:09 - function does is it prints the word so
58:12 - we can see it another function that we
58:15 - can use is called len and in here
58:19 - we could add another
58:21 - word if i run the code now we can't see
58:24 - any result because this is only giving
58:26 - us a value but we're not doing anything
58:29 - with that value and to overcome that we
58:32 - have to print the result
58:34 - and now if we run this we are getting 12
58:38 - and this 12 means that inside of this
58:41 - word we have 12 characters we have 1 2 3
58:46 - 4 5 6 7 8 9 10 11 and 12.
58:51 - notice here that python is counting a
58:53 - space as well
58:55 - and all of this could also be used with
58:57 - variables for example this len
58:59 - i could assign to the variable word
59:02 - length and then on the next line i want
59:05 - to print my word length and i get 12
59:08 - again
59:09 - and this would be a slightly cleaner way
59:11 - of doing this although the previous one
59:13 - would also be perfectly fine
59:16 - and another function we can also work
59:18 - with is absolute or abs
59:21 - and in here i can add negative 50 and
59:25 - for this once again i have to print
59:28 - the result otherwise we wouldn't see it
59:31 - but now if i run the code we are getting
59:33 - 50 meaning abs removes this negative 50.
59:38 - and there's one more really important
59:41 - thing that you can also do with
59:42 - functions
59:43 - that right now we always only added a
59:46 - single argument but for some functions
59:49 - you could add more than that print is
59:52 - actually one example of that
59:54 - let's put this on a separate line
59:56 - so far for print i always added one
60:01 - argument
60:02 - but what i can do i can add a comma
60:05 - and then add
60:06 - another
60:07 - argument
60:09 - and now i have two arguments if i run
60:12 - the code
60:13 - i get one argument and then print adds
60:16 - the other argument and print
60:19 - accepts an unlimited number of other
60:22 - arguments
60:23 - meaning if i run this now
60:24 - we are getting more and more arguments
60:28 - the important thing here is you always
60:30 - add one argument then a comma and then
60:33 - another argument another comma and so on
60:36 - depending on what the function accepts
60:39 - and some functions only accept a single
60:42 - argument for example absolute only takes
60:45 - one if i added another
60:48 - we will get an error and that is abs
60:51 - takes exactly one argument and we have
60:54 - given two python here is very clear
60:57 - apps only gets one argument but that is
61:01 - essentially the basic concept of calling
61:03 - functions
61:04 - now for the exercise i want you guys to
61:07 - do some research online
61:09 - and i want you guys to look up the
61:11 - function called max
61:13 - and try to figure out what it does and
61:15 - call it inside of this code
61:21 - here i have google open although you
61:23 - could use any search engine
61:25 - and to learn coding you have to do a ton
61:28 - of research so it's a really good idea
61:30 - to start early
61:32 - and what we want to do right now is look
61:35 - at the python function
61:37 - max
61:38 - and let's just see what we get
61:41 - in here we can see a bunch of websites
61:43 - and for python all of them are basically
61:46 - fine
61:47 - w3schools program is
61:50 - are really big ones geeks for geeks is
61:52 - also really big but the one you probably
61:55 - want to use the most is
61:57 - docs.python.org
61:59 - this is the official python
62:01 - documentation
62:02 - if i click on this one
62:04 - we can see all of the built-in functions
62:06 - for python
62:08 - and the one i'm looking for is called
62:10 - max
62:11 - if i click on this i get a ton of
62:14 - information the most important one is
62:16 - right in the beginning
62:18 - it's returning the largest item in an
62:20 - iterable
62:21 - or the largest of two or more arguments
62:25 - what an iterable is we have no idea so
62:28 - far but what we do know is the largest
62:31 - of two or more arguments
62:33 - so let's have a look at that one
62:36 - once again we are in the code and i want
62:40 - to use my max function and in here i
62:43 - want to just add a couple of random
62:45 - numbers
62:48 - now i once again have to print the
62:51 - result
62:52 - and if i run this i get
62:55 - 10.
62:57 - and well we get 10 because max is
63:01 - selecting the largest argument that we
63:04 - are passing into it which right now is
63:07 - 10.
63:08 - and well that is basically what it does
63:12 - if you understand this one you also
63:13 - understand min which is taking the
63:16 - lowest number which in our case is 2.
63:19 - and with that we have covered functions
63:23 - besides functions we also have methods
63:26 - and especially for beginners methods and
63:28 - functions can be very similar so let's
63:31 - compare the two
63:33 - in the most basic sense a method does
63:35 - the same as a function the only
63:37 - difference being that the method is
63:39 - always attached to an object
63:41 - which means
63:43 - we are still calling a method with the
63:45 - name of the method followed by brackets
63:48 - and this is still called calling a
63:49 - method just like a function
63:52 - we can also still pass an argument in
63:54 - here this works in exactly the same way
63:57 - the difference is that methods always
64:00 - are connected to an object and this
64:02 - happens with a dot which in practice
64:04 - looks like this
64:06 - we always start with some kind of object
64:09 - in this case it's a word it could also
64:10 - be a number or any other data type in
64:13 - python
64:14 - this is then followed by a dot and this
64:16 - is really important then we have the
64:18 - method name and then we have brackets
64:20 - with whatever argument you want to put
64:22 - in
64:23 - and then all of this does a certain
64:25 - thing just like a function
64:27 - what this thing could be is for example
64:30 - we can use the upper method and this one
64:32 - takes a word and returns the same word
64:35 - all in uppercase letters
64:37 - and i think this example also
64:39 - illustrates why we have functions and
64:41 - methods
64:42 - sometimes functionality only makes sense
64:45 - for a certain kind of data type or for
64:47 - certain objects with a certain data type
64:50 - and
64:51 - here the upper case really only makes
64:53 - sense for a word there's no uppercase
64:56 - for a number for example
64:58 - and this is why we have methods
65:01 - and i suppose we can implement all of
65:03 - this a bit more practically so let's
65:06 - have a look at all of this in code once
65:08 - again i have a completely empty python
65:11 - file and i want to create a new variable
65:13 - let's call it test
65:15 - and the value for this test is going to
65:17 - be a word
65:19 - to get started i want to print my test
65:22 - variable
65:24 - and if i print it we are getting a word
65:27 - so far all of this should be very
65:28 - familiar
65:30 - and the method we have seen we are
65:32 - calling with a dot after the word and
65:34 - then the name is upper and don't forget
65:37 - the brackets if i run this now we can
65:40 - see a word all in uppercase letters
65:44 - and with that we have called a method
65:47 - what we can also do let me demonstrate
65:49 - it first and then explain i can cut out
65:52 - this upper here
65:53 - and run it on this variable
65:56 - if i run all of this now we are getting
65:58 - the same outcome
66:00 - and why this happened i will explain in
66:02 - the next section but in the most basic
66:05 - sense
66:07 - methods always change a value
66:10 - where you change that value is really up
66:12 - to you
66:13 - in the first example
66:15 - we created the word and then when we are
66:17 - creating the word we are calling the
66:19 - upper method
66:20 - and this is returning
66:23 - the uppercase letters and storing them
66:25 - in the test variable and once we have
66:27 - that we are printing the test variable
66:30 - that's all that's happening here
66:32 - and then the second example
66:34 - looked like this
66:36 - and in here
66:37 - we first created the word and saved the
66:40 - word inside of the test variable
66:44 - after that we are still printing the
66:45 - test variable but now when we are
66:48 - printing it we are modifying it with the
66:50 - upper method which is giving us the
66:52 - uppercase word the result for both of
66:55 - these examples is the same
66:57 - how this works in detail you are going
66:59 - to understand very soon
67:01 - for now i'm going to call the upper
67:02 - method when i create this value
67:05 - now obviously this example really isn't
67:08 - all that useful
67:10 - let's do something more relevant
67:12 - let's say we have some kind of user
67:16 - name
67:17 - and we are expecting something like john
67:21 - smith
67:22 - where we have a first name and a surname
67:24 - but since you are allowing user input
67:27 - this might instead look something like
67:29 - this we have a typo and maybe we have
67:32 - some access at the end and let me add
67:35 - another typo in here
67:37 - this
67:38 - would still be valid user input but
67:40 - obviously it would look terrible
67:43 - which is something we couldn't use for
67:45 - our purposes and methods are really good
67:48 - to clean all of this up
67:50 - and the one method we could start with
67:52 - is called title
67:54 - and let me print the username and see
67:57 - what that one does
67:58 - now we get always let's expand this a
68:02 - tiny bit
68:04 - we are always getting the first letters
68:06 - uppercase and then every other letter is
68:08 - lowercase meaning now we have john smith
68:11 - in the proper spelling at least for
68:13 - names
68:15 - meaning with this we get rid of this o
68:17 - and this i
68:18 - what you can also do is combine
68:20 - different methods
68:22 - what you do by adding another dot after
68:24 - whatever value you want to change and
68:26 - then calling the other method in my case
68:29 - for this one
68:30 - i want to get rid of these two axes
68:33 - and for that i need this strip method
68:38 - and what this one does is it looks at
68:40 - the right and the left side of any word
68:44 - and removes a certain kind of value
68:47 - whatever we specify inside of the
68:49 - arguments
68:51 - and in my case i want to get rid of
68:53 - these two axes
68:55 - which means
68:57 - i want to add the string
68:59 - x in here
69:01 - and if i run this now
69:03 - we can see there is no difference so
69:07 - what went wrong here and i think you can
69:09 - already tell what the problem might be
69:12 - in the original word the two axes were
69:15 - uppercase and this is what we are trying
69:17 - to remove
69:18 - but what this strip method here sees
69:22 - is this string
69:24 - changed by this title
69:27 - meaning strip doesn't see a capital x it
69:30 - sees a lowercase x
69:33 - and for python again remember
69:35 - capitalization really matters an
69:37 - uppercase and the lowercase letter are
69:39 - two completely different things for
69:41 - python
69:42 - to fix that all we need is a lowercase
69:44 - letter and if i run this now we have
69:47 - removed the two values
69:49 - you might be asking yourself what
69:51 - methods are available and there are a
69:54 - couple of ways to achieve that
69:56 - if you want to stay inside of a code
69:57 - editor you would use the dir function
70:01 - and in here you can pass in any value to
70:03 - figure out what methods it has
70:06 - for example i could pass in the user
70:08 - name in here and if i run the code now
70:10 - nothing happens
70:11 - the reason is that this function only
70:14 - returns all of the methods it doesn't
70:17 - print them for that we again need the
70:20 - print function
70:22 - now if we run this we get something that
70:24 - looks a fair bit more technical
70:27 - and you have two main things in here
70:30 - you start with all of this stuff here
70:33 - a lot of names with double underscores
70:36 - before and after the word
70:38 - like this lte here we have two
70:40 - underscores before and two underscores
70:43 - afterwards what these mean we're going
70:45 - to cover much later what you want to
70:48 - focus on for now is all the stuff down
70:51 - here
70:52 - these are the methods that you could be
70:54 - using and we have actually used a couple
70:56 - of them already for example strip we
70:59 - have used title and we have used upper
71:03 - i guess we can do one more method and
71:05 - let's use is alpha what this method does
71:09 - is it checks if the values inside of a
71:12 - word are in the alphabet meaning they
71:14 - are not numbers
71:16 - let me close this one and instead of the
71:19 - dir function
71:21 - i want to print user name and then dot
71:24 - is alpha
71:26 - and don't forget to call it
71:28 - and now if i run this
71:30 - this is saying false
71:32 - the reason for that is that inside of
71:34 - this word we have one value that isn't
71:37 - inside of the alphabet and that is this
71:40 - space here
71:41 - if i remove it and run out of this again
71:44 - now it says true
71:46 - meaning every letter inside of the word
71:48 - is inside of the alphabet
71:50 - if i added any kind of number in here
71:52 - this would go back to false
71:56 - although i don't really want to do that
71:58 - but this would be another way to check
72:00 - something in your word that may become
72:02 - useful especially when you work with
72:04 - something like user input you might want
72:06 - to check if there are numbers inside of
72:08 - the name
72:10 - however if i go back to the dir function
72:14 - run this again
72:16 - this list here still isn't that useful
72:18 - because you have a name but you don't
72:20 - really have an explanation of what the
72:22 - specific method does
72:24 - and well to really understand what a
72:27 - method does you do want to use google
72:30 - and
72:31 - if you want to google for specific
72:33 - things you need to know their names for
72:35 - example in python or in really any
72:38 - programming language a word is always
72:41 - called a string
72:43 - we're going to cover that in much more
72:45 - detail in the next major section
72:47 - just remember for now a word in
72:49 - programming is always called a string
72:52 - and with that let's do some googling
72:55 - in here i want to look for python string
73:00 - methods
73:01 - and then i am getting a ton of different
73:04 - results and again all of these websites
73:06 - here work quite well
73:09 - the one that is the official
73:10 - documentation by python is called
73:12 - docs.python.org and this one says built
73:15 - in types python something something
73:17 - documentation
73:18 - and in here on the left side you can see
73:21 - all of the data types again we're going
73:23 - to cover those in a lot more detail very
73:26 - soon
73:27 - for example here you have numeric types
73:30 - we have sequence types and then we have
73:33 - text sequence type str which stands for
73:36 - string methods this is the one i want to
73:39 - look at
73:40 - and in here you have a very long list
73:43 - let me minimize this part you have a
73:45 - very long list of methods that you could
73:47 - be using
73:49 - along with a fair bit of text explaining
73:52 - what they do
73:57 - for example here is is alpha
74:00 - the one we have just looked at
74:04 - and if you have any kind of problem
74:05 - yourself you would probably read through
74:08 - this list and try to figure out what
74:10 - method works for your purpose
74:13 - and i suppose let's have a look at
74:15 - another website for example w3schools is
74:18 - also really good and in here
74:21 - we also have a long list of all of the
74:23 - methods the list contains the same
74:25 - number of methods and in here let's say
74:28 - if i click on is alpha
74:30 - we get to another website we have an
74:32 - explanation along with an example
74:35 - you honestly can use any of these
74:37 - websites they all cover basically the
74:39 - same thing
74:40 - all right with that we can do an
74:42 - exercise
74:44 - and in my case i want you guys to do
74:46 - some research because i have an exercise
74:50 - string
74:51 - that is saying i like
74:54 - puppies
74:56 - and what i want you guys to do is to
74:57 - find a method that replaces the word
74:59 - puppies with let's say kitties or any
75:02 - other animal that you really like
75:04 - so pause the video now and try to figure
75:07 - this one out yourself
75:11 - in my case i want to look for python a
75:14 - string remember this is just a word and
75:17 - i want to replace a let's say a value
75:21 - if i do this i already get one answer
75:24 - predicted by google that is called
75:25 - replace
75:27 - although if i go down i see replace a
75:29 - bunch more times and well
75:32 - i just had to look at one of them
75:34 - doesn't really matter which one it is
75:37 - let's choose program miss this time
75:39 - this one is really good and then here we
75:42 - have an explanation of what this one
75:44 - does we have an example
75:47 - and then we have the syntax so how we
75:50 - would use it and in here
75:52 - we have a string so any kind of word
75:55 - then the replace method then we have an
75:57 - old value a new value and a count
76:01 - and down here then we can see how we
76:04 - would use these values the old value
76:06 - here means the value we want to replace
76:09 - the new value is what we want to replace
76:11 - it with
76:12 - and then
76:14 - the count basically means if we have the
76:16 - old value multiple times how many times
76:18 - we want to replace it
76:20 - and this one is optional so you could
76:22 - leave it out entirely and with that we
76:25 - can implement all of this
76:27 - back in my code i want to add a dot and
76:30 - then the replace method
76:32 - and in here we first of all need the old
76:35 - word which in my case is puppies
76:38 - after that we need the new word and this
76:41 - in my case is going to be kittens
76:43 - although any kind of word would be fine
76:45 - in here
76:46 - and these two values would be mandatory
76:49 - so we have to have them
76:51 - but once we have them
76:53 - we can print the result and run this now
76:58 - and all the way at the bottom we get i
77:00 - like kittens we have successfully
77:02 - replaced puppies with kittens we could
77:05 - also add a third value and this one
77:08 - determines how many times we would want
77:10 - to replace this value
77:13 - let me actually paste it in a few times
77:16 - here
77:17 - now we have puppies four times
77:19 - by default i am replacing all of them
77:21 - with kittens
77:23 - meaning what i get is i like kittens
77:25 - kittens kittens and kittens
77:27 - but if i add another value in here and
77:30 - this has to be a number let's say i want
77:32 - to add a 2.
77:34 - now if i run this
77:35 - i am only replacing the first two
77:38 - instances of puppies with kittens but
77:40 - after that i keep my puppies around
77:43 - and again there are a lot more methods
77:46 - far too many to cover them in one video
77:48 - what you basically do as a programmer is
77:51 - you keep on working and you learn more
77:53 - and more methods as you go along but
77:56 - that being said even after a few years
77:58 - you are not going to know all of them
78:00 - for that you have google and you just
78:02 - look up different methods
78:04 - i have been programming for years and i
78:05 - still forget them all the time it's
78:07 - really not a major issue
78:09 - and with that we have methods
78:14 - in this part we are going to cover
78:16 - return and return is one of the most
78:20 - important concepts in all of programming
78:23 - so let's talk about it
78:25 - in the most basic sense return is the
78:27 - glue that connects everything in python
78:30 - what that means is that any operation
78:33 - returns a value
78:35 - for example if we calculate 2 plus 2 f4
78:38 - is being returned
78:40 - we also have functions and methods and
78:42 - those can also return values for example
78:45 - upper returns the uppercase letters of a
78:47 - string
78:48 - and by combining different return values
78:51 - you are creating more complex logic
78:54 - and what you are basically going to do
78:56 - in programming is combining different
78:58 - return values to create something more
79:01 - complex
79:02 - and an example here could look something
79:05 - like this
79:06 - just read through this and try to think
79:09 - of what the outcome here is going to be
79:13 - and let's go through this line step by
79:15 - step
79:16 - we are always starting with the
79:17 - innermost part in this case it is a word
79:21 - and then we are applying right now the
79:23 - first function which is len this is
79:26 - going to return a value and the value it
79:29 - is going to return is 6 or the amount of
79:32 - letters inside of this word
79:35 - and next up this value we are going to
79:38 - multiply with negative 10.
79:40 - this again is going to return another
79:42 - value negative 60. this is then going to
79:46 - return 60 because the absolute function
79:48 - always turns a negative number into a
79:50 - positive number
79:52 - and this would be one example of the
79:54 - return statement where we are taking
79:56 - specific functionalities like the length
79:58 - function here and then use the value
80:01 - they return in another operation like
80:04 - this 6 multiplied by negative 10.
80:07 - what you absolutely have to understand
80:09 - is that every operation in python
80:11 - returns a value and then this value you
80:14 - can combine with other operations like
80:16 - using it in another function or with
80:18 - another method or in a math operation
80:21 - it's really up to you but this is a
80:23 - really powerful system that allows you
80:26 - to add lots of logic on a single line of
80:28 - code
80:29 - let's play around with this i think that
80:31 - is going to be really important
80:34 - once more completely empty python file
80:36 - and let me create a test
80:39 - variable
80:40 - let's use the example from the previous
80:42 - part where we had e word and then we
80:46 - used upper
80:48 - let me print it as well and we are
80:50 - getting a word all in uppercase letters
80:53 - and
80:54 - i think i want to have a bit of white
80:56 - space around it
80:58 - that makes my life a bit easier
81:00 - what happened in here is
81:02 - we have a word and then we're using the
81:06 - upper method to change the word
81:09 - what this combined statement here
81:11 - returns is a word all in uppercase
81:14 - letters
81:15 - and once we have that
81:18 - we can add another method to it and the
81:21 - method we could be using here the one we
81:23 - have already seen let's use replace
81:27 - and what we want to do in here is
81:29 - replace the letter a
81:31 - with the letter let's say x
81:34 - and now if i run this
81:36 - we have x word
81:39 - what happened here is that this
81:41 - first statement returned e-word this one
81:44 - should be obvious by itself
81:46 - after that
81:47 - we have used the upper method to turn
81:50 - this e-word into e
81:53 - word all in uppercase letters after that
81:58 - we have used the replace method to
82:00 - change this a
82:02 - to
82:03 - an x
82:04 - and we could continue this forever
82:07 - for example what we could do for example
82:10 - what we could be doing
82:12 - is wrap all of this inside of the len
82:15 - function
82:16 - and now if i run this
82:18 - we are getting six
82:20 - we start with a word
82:22 - then we are turning all of this into
82:24 - uppercase letters
82:26 - then we are changing the first letter
82:28 - from an a to an x
82:30 - so what we have inside of these brackets
82:32 - is x
82:34 - word all in uppercase letter
82:37 - and what we do then is use the len
82:39 - method to count how many characters we
82:42 - have inside of this word
82:44 - which right now is 6 and this is what we
82:47 - are storing inside of the variable i
82:50 - hope this makes sense it is a really
82:52 - important concept to understand
82:55 - all it means is every time you perform
82:57 - some kind of operation a different kind
82:59 - of value is being returned and then this
83:02 - value is what you are working with next
83:05 - you really have to be aware that every
83:07 - operation returns some kind of value
83:10 - although this can be kind of weird
83:12 - sometimes
83:14 - one really good example let me remove
83:16 - the white space here
83:19 - and then let's play around with the
83:22 - print function
83:23 - because this one by itself just prints
83:26 - whatever we pass inside
83:28 - so what's going to happen when we print
83:32 - a print function
83:34 - and let's see
83:36 - we are getting 6 and none
83:39 - the 6 we are getting from this inner
83:42 - part
83:43 - and the none is what gets returned by a
83:47 - print statement and none is an actual
83:49 - data type in python you can work with it
83:52 - but it basically denotes the absence of
83:55 - a value
83:56 - but again print is returning something
84:00 - although in this case what it is
84:01 - returning is the data type none i hope
84:04 - you get the idea here
84:06 - now for this part i am not going to do
84:08 - an exercise but i would recommend you to
84:11 - play around with this yourself in your
84:12 - own time and see what you can do
84:15 - yourself
84:17 - throughout this series we are going to
84:19 - do a lot of examples so there's plenty
84:22 - of time for practice
84:23 - a really important thing you have to
84:25 - understand is comments and comments do
84:28 - not influence your code whatsoever they
84:31 - are just explaining it or well they are
84:33 - commenting what your code does
84:36 - and you really want to use comments
84:38 - quite extensively because they are
84:40 - really useful to help how you organize
84:42 - your code and to understand what it does
84:45 - especially if you work in a team you
84:47 - want to add lots of comments because
84:49 - other people would really appreciate it
84:52 - it also works as a really good reminder
84:54 - for your own code it's a really common
84:56 - thing for programmers that you write
84:58 - some code you don't look at it for half
85:00 - a year and then you have no idea what it
85:02 - does anymore and writing comments is a
85:05 - very good way to remind yourself
85:07 - there are two ways to write comments in
85:09 - python the first one is the hashtag
85:12 - symbol anything on that line after the
85:14 - symbol is going to be ignored by python
85:17 - the other way is a triple quotation mark
85:20 - this one will comment out anything
85:23 - inside of these quotation marks this
85:25 - would also work over multiple lines
85:28 - although technically it's not a comment
85:31 - we are going to learn later what this is
85:33 - but you can use it as a comment and
85:35 - let's say i have again a test variable
85:39 - and this one is a really important
85:43 - value
85:44 - i want to add a comment to explain that
85:46 - this is a really important
85:50 - value
85:51 - we are just using the hashtag symbol and
85:54 - anything after that symbol is going to
85:56 - be a comment
85:57 - you can also add multiple
85:59 - if you want to add some specific kind of
86:01 - styling which is fairly common actually
86:06 - what you see fairly often is programmers
86:08 - doing something like this then a
86:11 - comment and then
86:13 - something like this at the end i guess
86:15 - we can close this box as well to make it
86:18 - look a bit prettier with something like
86:21 - this you have a very clear section
86:22 - inside of your code but the important
86:24 - thing here to understand is that
86:26 - anything after hashtag symbol on the
86:28 - line of code is going to be ignored
86:31 - i guess let me actually run the code by
86:33 - printing the test variable run this now
86:36 - and we can only see a really important
86:39 - value
86:40 - anything here and here
86:43 - was ignored by python you could also put
86:45 - this anywhere else in your code for
86:47 - example here and then this line of code
86:49 - is going to be ignored entirely
86:51 - and something that would make more sense
86:53 - is you could comment out the entire line
86:56 - and that is basically it for the easiest
86:59 - kind of commenting
87:00 - although for this type of comment
87:02 - sublime has a very neat trick let me
87:05 - duplicate it a couple of times
87:07 - and imagine all of these are different
87:10 - examples of code
87:12 - and you want to comment out all of them
87:14 - it would be really annoying to write a
87:17 - hashtag in front of every single line of
87:19 - code it just wouldn't be efficient
87:21 - so what you can do is select all of them
87:24 - and then press ctrl and the forward
87:27 - slash the one below the question mark if
87:30 - you do that all of them are being
87:32 - commented out
87:33 - and if you press it again the comment
87:35 - disappears
87:37 - which is what i am using all the time
87:40 - and well with that we have the first
87:42 - type of comment what you can also do
87:45 - i guess let me add something below here
87:48 - let me call it another
87:50 - variable
87:53 - let me just use some numbers
87:55 - and now duplicate this a few more
87:58 - times and again i want to comment out
88:02 - multiple lines of code
88:04 - for that i can use three quotation marks
88:08 - at the start and at the end
88:11 - you can already tell the color was
88:13 - changed to gray and this tells us this
88:15 - is going to be a comment
88:17 - meaning if i run the code now
88:19 - we wouldn't be able to see it okay
88:21 - granted we wouldn't be able to see this
88:23 - at all so let me add a print statement
88:26 - in here with another
88:30 - variable
88:32 - if i run this now we still cannot see
88:34 - the print statement because all of this
88:36 - is a comment
88:38 - now this example here
88:40 - isn't exactly great because it's just
88:43 - lots of individual variables that i
88:45 - copy-pasted
88:46 - how you would use this kind of comment
88:48 - most of the time is by adding a couple
88:51 - of lines of code that explains something
88:53 - more complex
88:55 - let's say this is a really important
88:59 - section
89:00 - it does a couple of things
89:05 - that
89:06 - we need for the code to work
89:10 - whatever you want to put in here
89:12 - after that you would have the rest of
89:14 - your code
89:16 - this is what you see fairly often and
89:18 - python actually incorporated this into
89:21 - its functionality we're going to see
89:22 - this later on as well
89:25 - i guess for now the really important
89:27 - thing you want to be aware of is this
89:28 - one here the simple kind of comment that
89:30 - you can just put anywhere and that way
89:32 - you can either add explanations or
89:34 - sections to your code which really help
89:36 - with the organization before we are
89:38 - finishing off this section i want to
89:40 - talk a bit more about the lines of
89:42 - execution logic because there are a few
89:44 - things that i haven't covered yet let's
89:47 - go through them the most important part
89:49 - is that how you see lines differs from
89:52 - how python sees them a really good
89:55 - example here
89:56 - is that python does not see empty lines
89:59 - in the code only you do and let me
90:02 - illustrate what i mean
90:03 - if i start typing print and let's call
90:07 - it first line and then duplicate the
90:10 - line and type in second line if i
90:13 - execute this code i get first line and
90:16 - second line this is the stuff we have
90:18 - already seen quite a lot it should be
90:20 - fairly obvious by this point
90:22 - however what happens if i add a space in
90:25 - here
90:26 - now we have a line of code nothing and
90:29 - another line of code
90:30 - if i run all of this now we are still
90:33 - seeing the same result
90:35 - the reason being that python ignores a
90:39 - line without any code
90:41 - if there's nothing on the line python is
90:43 - just going to ignore it
90:45 - meaning what you could be doing is add a
90:49 - huge amount of white space and it would
90:51 - not make any difference to your code
90:54 - which is very often something you do
90:56 - want to work with quite extensively
90:58 - because this is making it much easier to
91:00 - organize your code
91:02 - especially if you add more comments with
91:04 - something like let's say second line
91:08 - and then this could be
91:10 - the first line
91:13 - you could have a setup like this which
91:16 - in your case might make it much easier
91:18 - to read but all that python sees is this
91:21 - line and this line here
91:24 - which is giving you a ton of work to
91:26 - customize whatever explains your code
91:28 - the best but there are quite a few more
91:31 - things that you should be aware of what
91:34 - i have also covered is that python
91:36 - ignores white space within a line
91:39 - meaning you can add as many spaces as
91:41 - you want let's have a look at this one
91:43 - as well for example what i could be
91:45 - doing inside of a string i could add as
91:48 - much white space as i want
91:50 - and this one is going to be reflected in
91:52 - the code i am running
91:54 - what i can also do
91:56 - is add white space between the different
91:59 - parts of the code
92:00 - something like this would still work
92:03 - just fine
92:04 - although granted in this case there
92:06 - isn't much reason to do something like
92:08 - this
92:09 - i suppose
92:11 - something slightly more relevant might
92:13 - be
92:13 - we could add 1
92:15 - plus 2
92:18 - plus
92:20 - 4 and so on
92:22 - and for this line python would just
92:24 - ignore the white space meaning if i run
92:26 - this we are just getting the result
92:28 - python doesn't care what you do between
92:31 - these lines
92:32 - which i suppose you could be using for
92:34 - something like 5 multiplied by 5
92:37 - and then plus
92:40 - 10
92:41 - so you indicate which operation comes
92:43 - first the 5 multiplied by 5 although
92:46 - still kind of a stretch what you can
92:49 - also do is use tab
92:51 - you can add this as much as you want
92:53 - python doesn't care it trades tabs like
92:56 - white space
92:58 - that being said there's something really
93:00 - important
93:02 - and that is
93:04 - python
93:05 - really cares about the indentation of an
93:08 - entire line let me demonstrate this this
93:10 - is going to become incredibly important
93:13 - later on
93:14 - what we have seen so far is that these
93:16 - annotations do not matter to python
93:19 - however what python does care about is
93:22 - if this entire line is indented if i
93:25 - indent this entire line and run this
93:28 - again python is going to give me an
93:30 - error the error we are getting is called
93:32 - indentation error unexpected indent why
93:36 - that is you are going to learn later
93:38 - what you have to keep in mind for now is
93:40 - that inside of a line you can add as
93:42 - much white space as you want but you
93:45 - couldn't add white space when you start
93:46 - the line like here python is not going
93:49 - to like that but right there's one more
93:52 - topic i do want to cover
93:54 - and that is how to break the line space
93:57 - or at least how to make it a bit more
93:59 - flexible because you can create multiple
94:02 - lines of code in one line the reason
94:05 - here again
94:06 - is what you see as a line and what
94:08 - python sees as a line are two separate
94:12 - things
94:13 - if you want to be a bit more specific
94:14 - about it
94:15 - what you see is a physical line
94:18 - all that really means is whatever is in
94:21 - a single line of code it's as simple as
94:23 - that
94:24 - but what python sees is a logical line
94:27 - and this is what gets executed one step
94:30 - at a time let me demonstrate this one as
94:33 - well actually
94:34 - let me clean all of this up actually so
94:37 - things are a bit easier to read
94:40 - we have two physical lines and two
94:42 - logical lines meaning what we see and
94:45 - what python sees is identical we have
94:47 - this line and we have this line
94:50 - however what i can do now is put both of
94:53 - these print statements on the same line
94:55 - and python isn't going to like this at
94:58 - all
94:59 - and the reason here is that for us this
95:02 - is one physical line and we can i guess
95:05 - read it
95:06 - but to python this is one logical line
95:09 - now that doesn't make sense python can
95:12 - only execute one of these functions at a
95:14 - time
95:15 - it has to execute this line first and
95:18 - then this line second it cannot do them
95:21 - at the same time
95:22 - which is why we are getting an error
95:24 - here
95:25 - although this logic you can break to
95:28 - some extent
95:29 - and there are two ways of doing that the
95:32 - first one is you can use a semicolon and
95:35 - this way you can separate a physical
95:37 - line into logical lines
95:40 - all of this here would be a physical
95:42 - line but because of the semicolon python
95:45 - is going to break this one out into two
95:48 - logical lines and is going to keep happy
95:51 - the opposite operation i suppose you
95:54 - could call it would be a forward slash
95:57 - this one is breaking two physical lines
95:59 - into one logical line
96:01 - this is something you are going to use
96:04 - fairly often if you have a really long
96:06 - operation
96:07 - the example here is we're just adding
96:09 - some numbers and at some point we ran
96:11 - out of monitor space as a consequence we
96:14 - wanted to have all of this on the same
96:16 - line
96:17 - meaning this is two physical lines but
96:20 - because of the forward slash python turn
96:23 - all of this into one logical line and
96:25 - keeps being happy so all is good
96:28 - and let's have a look at those two and
96:30 - then we are done with this entire
96:31 - section
96:32 - and i guess we can start with the
96:34 - semicolon
96:36 - if i put print and print on the same
96:38 - line run this again python is going to
96:41 - be unhappy but if i put a semicolon
96:44 - between the two
96:45 - then python is going to remain happy
96:48 - because this semicolon is breaking a
96:50 - logical line now that being said this
96:53 - semicolon you are probably never going
96:56 - to use or at the very least you are very
96:58 - rarely going to use it it really is very
97:01 - very uncommon
97:03 - what is however much more common is let
97:06 - me create another variable let's call it
97:08 - a
97:09 - what you do see fairly often is some
97:11 - kind of very long math operation let's
97:13 - say one plus two plus three plus four
97:17 - plus five and this could go on forever
97:20 - and you want to break this up and for
97:22 - that you would use forward slash and
97:24 - then on the next line you can continue
97:26 - writing the line as you would normally
97:29 - do
97:30 - meaning i could add a plus 6 plus 7 plus
97:34 - 8 and so on
97:35 - if i now print a
97:38 - and run this we are getting a proper
97:41 - result
97:42 - keeping your code readable is a priority
97:45 - that you want to keep in mind and the
97:47 - forward slash is really useful for that
97:50 - but right with that we have all of the
97:52 - basics covered
97:54 - in this section we are going to cover
97:56 - data types and this is going to be an
97:59 - incredibly important part because
98:01 - understanding data types is one of the
98:04 - most fundamental things you have to
98:06 - understand about programming python does
98:09 - have quite a few different data types we
98:11 - have actually seen some already the one
98:14 - that we have used the most is words
98:16 - which is just a string
98:19 - it really is just a fancy word that
98:21 - programmers use we are just talking
98:22 - about words
98:24 - besides that we have also used different
98:26 - kind of numbers
98:28 - we have seen integers and we have seen
98:30 - floating point numbers
98:33 - the only difference between the two is
98:35 - that floating point numbers has decimal
98:37 - points whereas integers are always full
98:40 - numbers
98:41 - the reason why that is is quite
98:44 - technical and you don't have to worry
98:45 - about it you can work with them very
98:48 - very easily and they are basically
98:50 - interchangeable from your point of view
98:52 - there are only very rare exceptions
98:54 - where that is not the case
98:56 - and those exceptions you probably are
98:58 - not going to come across unless again to
99:00 - some very specific topics
99:02 - besides that there's one more data type
99:05 - that we have seen as well and that is a
99:07 - boolean and boolean data types can only
99:10 - ever have two values
99:12 - they are either true or false
99:14 - and in the context where we have seen
99:16 - them is some kind of math operation for
99:18 - example 10 is greater than 5
99:21 - was true these boolean values you are
99:24 - going to work quite a lot later with to
99:27 - organize the flow of your code for
99:29 - example you might only want to run some
99:31 - code if a certain condition is true
99:35 - besides those four data types python has
99:38 - quite a few more some are more important
99:41 - some are less important but there are
99:43 - four that you absolutely have to know
99:46 - and let's start with the easiest one a
99:48 - list
99:49 - this is basically just a container to
99:51 - store other data types for example in
99:54 - this list right now we have three values
99:58 - we have one and two and both of those
100:01 - are integers
100:03 - and besides that we have a string
100:05 - which is just a word you could also
100:08 - store boolean or floating point numbers
100:10 - and you could even store a list inside
100:13 - of another list
100:14 - python really is flexible here
100:17 - besides that we have tuples we have sets
100:20 - and we have dictionaries
100:22 - and all four of those data types are
100:25 - just there to store other values
100:27 - the difference between them is that they
100:29 - are storing data slightly differently
100:32 - a list and a tuple
100:34 - differ because a list can be changed
100:37 - whereas a tuple cannot be changed
100:41 - a set would be different because every
100:43 - value inside of it has to be unique and
100:46 - there are a lot of ways to compare
100:49 - different sets to filter out data
100:51 - and finally a dictionary
100:53 - is a much more organized way to store
100:55 - your data in here we always have a name
100:58 - and then a data type
101:00 - i am going to go through all of those in
101:02 - detail throughout this section and then
101:05 - we are going to go in quite some detail
101:07 - into all of them
101:08 - besides those
101:09 - there are also some data types that are
101:11 - much less common i will cover those at
101:14 - the end of this section they really
101:16 - aren't that important but you do want to
101:18 - be aware of where they appear and why
101:21 - they matter
101:23 - but generally
101:24 - python is incredibly relaxed about
101:27 - different data types most of the time
101:30 - you are actually not even going to
101:31 - notice for example
101:33 - if you have an integer and a floating
101:35 - point number
101:37 - for example this could be 1 plus 1.2
101:41 - and python here would automatically
101:44 - convert these two numbers into a
101:46 - floating point number with 2.2
101:50 - you have essentially combined different
101:52 - data types but because python is so
101:54 - flexible about it you didn't even notice
101:57 - which is one of the main reasons why
101:59 - integers and floating point numbers
102:01 - especially for beginners are basically
102:03 - identical and you never have to worry
102:05 - about them
102:06 - on top of that python also has a ton of
102:09 - functionality to change different data
102:11 - types i'm going to cover that very soon
102:14 - as well
102:15 - let's get started by talking about
102:17 - integers and floats or well just numbers
102:21 - and i just covered them but just as a
102:24 - recap
102:25 - we are creating numbers either with
102:26 - integers or with floating point numbers
102:29 - and again the only difference between
102:31 - the two is decimal points for floating
102:33 - point numbers and integers are always
102:36 - full numbers
102:38 - again
102:38 - the difference is because of how
102:40 - computers work but you really don't have
102:43 - to worry about it the most important
102:45 - thing for you is that all math operators
102:47 - work just as normal meaning if you add
102:51 - an integer and a floating point number
102:53 - you are getting a floating point number
102:56 - let's have a look at some examples
102:58 - and a really useful function to
103:00 - understand what data type you're working
103:02 - with is called type if i write type and
103:05 - then add an integer so a one in here
103:08 - python is going to tell me what data
103:10 - type i am working with
103:12 - and again
103:14 - we have to print the result so we can
103:16 - see something if i run the code now
103:18 - we're getting class and integer what a
103:22 - class is you're going to learn much
103:23 - later in this series
103:25 - but the important thing for now is the
103:27 - integer this is the kind of data type we
103:30 - are working with
103:31 - if i change this 1 to a 1.1
103:34 - then we are getting a float or a
103:36 - floating point value
103:38 - which means you are working with
103:40 - different data types
103:42 - you could also add a string in here so a
103:45 - word let's say a
103:47 - word that is horrible spelling but you
103:49 - get the idea and we have sdr for string
103:53 - let's stick to a1 actually we don't need
103:56 - to type at all anymore instead what we
104:00 - can look at
104:01 - is
104:02 - the conversion between different data
104:04 - types and for numbers this is all
104:06 - automatic
104:08 - and here
104:09 - i could just type 1 plus 1 plus 1 and we
104:12 - get 2.1
104:14 - since this does have a decimal point we
104:16 - have a floating point value
104:19 - although if you didn't know this
104:20 - specifically you would never notice
104:23 - although i guess sometimes this can be
104:25 - slightly weird we have actually seen
104:27 - this very early on in this entire series
104:31 - if you divide any number by another
104:33 - number let's say 10 divided by 5
104:36 - i am going to get a floating point
104:39 - number even though i wouldn't
104:40 - necessarily need it
104:42 - and this always happens in python you
104:45 - can't really get around it
104:47 - but that is basically all you have to
104:49 - know about numbers in python in terms of
104:51 - data types python here is really
104:53 - flexible and makes all of this very easy
104:56 - which does make it much easier than most
104:58 - other programming languages
105:00 - i guess one thing we can cover as well
105:03 - is let me add this on the next line
105:06 - you can use functions to convert
105:08 - different data types for example
105:10 - let me print something again and i have
105:14 - a integer
105:15 - let's say 2 and i really want to convert
105:19 - this integer into a floating point
105:22 - number
105:22 - one way of doing this is to add 0.0 to
105:26 - it if i run this now we get 2.0 although
105:30 - this isn't exactly elegant so we're not
105:33 - going to use it
105:35 - a better way would be to use a function
105:38 - that is called float and float converts
105:41 - any kind of integer into a floating
105:43 - point value if i run this now we're
105:46 - getting the same result
105:48 - you can see it's a float because we have
105:50 - a decimal
105:52 - this would also work the other way
105:53 - around let me put this on the next line
105:56 - if i print a number like let's use
106:00 - something else 5.1
106:02 - if i want to convert this 5.1 into an
106:05 - integer
106:06 - i could use
106:08 - the
106:09 - int function or int for integer
106:12 - if i run this i am only getting 5
106:15 - because remember integers are always 4
106:18 - numbers we do not have values after
106:20 - decimal so we are losing some data
106:24 - also keep in mind when you are using int
106:27 - you are not rounding the operation you
106:29 - are doing is truncating
106:31 - and truncating means we are getting rid
106:34 - of anything
106:35 - after the decimal point
106:38 - which means if i had 5.9
106:41 - and run all of this again we are still
106:44 - getting 5. if you wanted to round you
106:47 - would use round
106:49 - and then you were getting 6.
106:51 - it would also return an integer because
106:53 - again we don't have any decimal point
106:56 - now there's one thing that you do want
106:58 - to be really careful about and that is
107:00 - that floating point numbers sometimes
107:02 - can get really weird especially if you
107:05 - combine integers and floating point
107:07 - numbers for example if i print
107:10 - 1.1 times 3
107:13 - what we would be expecting here is 3.3
107:17 - however if i run the code we are getting
107:19 - something really weird three point three
107:23 - and then zero
107:25 - a lot and then a three at the end
107:27 - technically this result is wrong it
107:31 - resulted because floating point numbers
107:33 - are kind of weird in computers
107:36 - now that being said in most cases
107:39 - this error here makes absolutely no
107:41 - difference because it's such a small
107:44 - deviation you are never going to notice
107:46 - it but do keep it in mind you generally
107:49 - want to avoid floating point numbers
107:51 - because they can add some arithmetic
107:54 - errors once in a while
107:56 - generally integers are much easier and
107:59 - much cleaner to work with
108:00 - but obviously sometimes you just have to
108:02 - use floating point numbers and then you
108:04 - can just use them they work just fine in
108:07 - basically all circumstances
108:09 - the next data type i want to talk about
108:12 - are strings and this is the one we have
108:14 - seen a lot by now all we're talking here
108:17 - are words
108:19 - and this is something we do have to talk
108:21 - quite a lot about because we are going
108:23 - to use them extensively
108:26 - strings are created either with single
108:28 - or with double quotation marks you could
108:30 - either write word with single quotation
108:33 - marks this one and this one
108:35 - or you could use double quotation marks
108:37 - this one and this one python really
108:40 - doesn't care the only limitation is that
108:43 - you have to stick to the same kind of
108:44 - quotation mark
108:46 - you couldn't add a single quotation mark
108:48 - and then end with a double quotation
108:50 - mark
108:51 - and strings have a ton of methods to
108:54 - manipulate them i guess some examples we
108:56 - have seen are upper is numeric and strip
108:59 - what we haven't seen yet is you can also
109:02 - use strings with math operations for
109:04 - example if you add hello plus world you
109:07 - are combining these two strings we are
109:09 - going to explore that functionality a
109:11 - bit more in this section
109:13 - besides that you can also add values
109:16 - into strings in quite a few different
109:18 - ways the most important concept here
109:20 - that you have to understand are f
109:22 - strings
109:23 - you will see in a second what that means
109:25 - it's basically another kind of method
109:28 - and finally
109:29 - we can also cover how to write over
109:32 - multiple lines and how to add quotation
109:34 - marks inside of a string
109:36 - and that's a ton of stuff to cover so
109:39 - let's have a look at all of this
109:41 - let's start by creating some test
109:43 - variable
109:44 - and in here to create a string we can
109:47 - either use single quotation marks or
109:49 - double quotation marks
109:51 - i guess let's start with single
109:52 - quotation marks let's call it test 1
109:55 - and then for test variable 2
109:58 - we can have double quotation marks with
110:01 - test 2.
110:02 - if i run the code now all of this is
110:05 - going to work just fine
110:07 - as a matter of fact if i print testvar1
110:10 - and testvar2
110:12 - both of them are going to give the same
110:14 - result python does not care if we use
110:17 - double or single quotation marks the one
110:19 - thing python does care about is that we
110:21 - do not mix quotation marks meaning
110:23 - something like this wouldn't work if i
110:25 - run it
110:26 - we are getting a syntax error
110:28 - undetermined string literal i think the
110:31 - reason here should be quite obvious it
110:33 - would be very strange
110:35 - what i also want to do starting from
110:37 - well now is to comment my code so it's
110:40 - going to be a bit easier to read when
110:42 - you read through it
110:43 - and this section here is about quotes
110:47 - for strings
110:49 - along with that there's one important
110:51 - thing that we do have to cover and that
110:53 - is quotes inside of strings
110:58 - what that means let me create another
111:00 - test variable let's call it testvar3
111:03 - and let's do an example let's say i have
111:07 - the case
111:08 - that he said
111:11 - and then i want other quotation marks
111:14 - this was
111:15 - great
111:16 - and let me add a bit of white space here
111:18 - so this is easier to understand
111:21 - we are using quotation marks here and
111:25 - here and that way we are creating a
111:27 - string
111:28 - inside of this string though we have
111:31 - another quote
111:32 - and you can already see by the colors
111:34 - here python is not exactly happy about
111:37 - it
111:38 - if i run out of this
111:40 - we are getting an error invalid syntax
111:42 - python just doesn't know what to make of
111:44 - it
111:46 - as far as python is concerned
111:48 - we are starting a string here and we are
111:50 - ending the string here
111:52 - then we are adding some random words and
111:55 - then we are creating another string
111:59 - the reason now where python is confused
112:01 - is because these three words are neither
112:04 - variables nor inbuilt functions so
112:06 - python just doesn't know what to do with
112:08 - them and it gives us an error so how can
112:10 - we get around it and there are two ways
112:13 - of doing this
112:14 - the first one that you are probably
112:16 - going to use the most is to mix the
112:18 - quotation marks
112:20 - now we have
112:22 - single quotation marks to create a
112:24 - string and inside of the string we have
112:27 - double quotation marks
112:29 - to explain that we have a quote this
112:32 - python is completely fine with
112:35 - let me print it actually testvar free
112:39 - if i run this now we are getting he said
112:42 - this was great python has no problem
112:44 - with that
112:46 - and let me remove the white space that
112:48 - should make all of this a bit easier to
112:50 - read
112:51 - while we add it i also want to comment
112:53 - out
112:54 - this stuff here at the top so things are
112:56 - a bit easier to see now if i run this we
112:59 - can see we have quotes inside of a
113:01 - string
113:02 - this would also work the other way
113:04 - around
113:05 - if i start with double quotation marks
113:07 - and end with double quotation marks
113:10 - then
113:10 - inside of here
113:13 - i can add single quotation marks like
113:15 - this run it again and we would also see
113:18 - the result now we have single quotation
113:20 - marks
113:21 - this would be one way to approach this
113:23 - although this system has its limitation
113:27 - for example if i add a test var4
113:31 - and in here
113:33 - we want to have for whatever reason a
113:36 - single quotation mark a double quotation
113:39 - mark and then a single quotation mark as
113:41 - well
113:43 - and this would just not work
113:46 - python would just get very confused
113:49 - not exactly something you would do all
113:51 - the time but it might come up once every
113:54 - year and then you have a problem to
113:56 - overcome this you need what is called an
113:59 - escape character let me add a comment
114:01 - and escape
114:03 - character an escape character is again a
114:07 - forward slash and this you need in front
114:09 - of every character you want python to
114:12 - just interpret as a string
114:15 - and this you need in front of every
114:16 - character you want python to interpret
114:18 - as a normal character
114:20 - so in my case i want this escape
114:22 - character in front of my double
114:24 - quotation mark and my single quotation
114:26 - mark and now you can see the comment
114:28 - appears as a proper comment
114:31 - if i print it
114:32 - i can see the two quotation marks this
114:35 - way you can literally add any kind of
114:37 - character without disturbing your code
114:40 - as a matter of fact let me rename this
114:42 - to simple escape character because
114:44 - escaped characters can do quite a bit
114:47 - which means i want to add another
114:49 - comment for escape characters
114:54 - what we can do in here let me comment
114:56 - out the earlier part
114:58 - and now i want to have a test var
115:01 - five
115:02 - and for this one i want to print some
115:04 - text over multiple lines
115:07 - let's say i want to have line 1
115:09 - [Music]
115:11 - some text
115:12 - and then i want to have line 2
115:16 - some more text
115:18 - and i want to tell python that this
115:21 - should be over multiple lines of code
115:24 - for example if you want to build some
115:26 - kind of text editor you want to store
115:29 - all of the text inside of one string but
115:31 - when you present a string you want to
115:33 - have line breaks between them how could
115:36 - you do that
115:37 - i guess let me print the test bar first
115:40 - if i run this
115:41 - we get all of this on one line
115:44 - and to create a line break in here we
115:47 - need once again the forward slash and
115:50 - then the letter n
115:52 - if i run this now we are getting those
115:54 - two lines on well different lines
115:57 - forward slash n tells python that we
116:00 - want to add a line break between these
116:03 - two different parts of the string
116:05 - there are actually quite a few more for
116:07 - example forward slash t
116:09 - is adding a tab inside of your string
116:14 - there's also forward slash r this one
116:16 - adds another kind of line break you
116:19 - don't really have to know the difference
116:21 - here for your purposes work essentially
116:23 - the same
116:25 - forward slash n though is the most
116:27 - common one
116:29 - so that way you can write text over
116:31 - multiple lines
116:32 - besides that
116:34 - let me add multiple lines as a comment
116:37 - here
116:38 - there's another way to write multiple
116:39 - lines and this is one way we have
116:42 - actually already seen
116:44 - what you need here are triple quotation
116:47 - marks
116:48 - something that python by default
116:50 - considers a
116:51 - comment
116:53 - however if you assign
116:55 - this comment here to a variable let's
116:58 - call this one test var
117:00 - six
117:01 - all of a sudden
117:03 - it changes the color and it becomes a
117:05 - string
117:06 - and this string is kind of special
117:09 - because for this one python does respect
117:11 - the white space
117:13 - which means now i can press space
117:15 - end up on another physical line
117:18 - write some more text do the same thing
117:21 - again and then write on another line if
117:26 - i print this test var 6
117:29 - python is going to preserve all of the
117:32 - line breaks
117:34 - for example what we could be doing in
117:36 - here let me actually copy it that should
117:39 - save some time i could copy
117:42 - something like this in here if i run
117:45 - this now we have the tree we created in
117:48 - one of the very first section of this
117:50 - entire series
117:51 - and this is a much easier way to see
117:53 - what's going on
117:55 - although granted because of the first
117:57 - line here this is a bit difficult to
117:59 - understand
118:00 - but with all of this covered we have
118:02 - quite a bit more understanding about
118:04 - strings
118:05 - now there are two more things that i do
118:07 - want to cover the first one is math and
118:11 - strings
118:12 - and before we start that let me comment
118:15 - out the earlier stuff so it doesn't get
118:18 - confusing
118:19 - what you can do
118:21 - let's call this testvar7
118:24 - you can add something like one string
118:26 - hello
118:27 - and then plus
118:29 - a
118:30 - world
118:31 - and python when it sees this plus it is
118:35 - just going to combine these two strings
118:38 - if i print test bar 7 now we are getting
118:42 - hello world
118:43 - keep in mind here
118:44 - there's no space between the two
118:47 - because neither hello nor world have any
118:50 - white space
118:51 - one way to add them would be to just add
118:53 - them here
118:55 - and then
118:56 - combine all of these with another plus
118:59 - you can add as many pluses here as you
119:01 - want there's no limit on it
119:03 - this would also work with different
119:05 - types of quotation marks
119:07 - python literally does not care
119:10 - another math operation that we can use
119:13 - let me create a test var eight
119:16 - i can let me write a word like copy i
119:19 - can multiply it for example times ten
119:22 - if i now print the result
119:24 - i get the word copy copied ten times
119:28 - but again i think this concept here
119:30 - should be fairly straightforward
119:33 - let me comment it out and now we come to
119:35 - the most important section of this
119:37 - entire video and that is how to get
119:41 - values into strings and let's do this by
119:45 - example i have a name and in here i have
119:49 - bob
119:50 - and i have an h and let's go i don't
119:53 - know 40.
119:54 - now i want to create another let's call
119:58 - it a greeting
120:00 - string
120:02 - and this greeting string i want to say
120:05 - hello
120:07 - bob
120:08 - you are
120:10 - 40 years old
120:13 - let me add the print statement as well
120:15 - so we can see what's going on
120:17 - i want to have the greeting string and
120:19 - let's run this
120:20 - i can see hello bob you are 40 years old
120:24 - right now the two values are matching
120:26 - we have
120:28 - bob here and bob here and we have 40
120:31 - here and 40 here
120:33 - but this is only the case because i have
120:36 - written bob
120:38 - if i change this bob to tom
120:41 - and run all of this again we wouldn't
120:43 - see a difference
120:44 - so what i want to do is to somehow get
120:47 - this name variable into here
120:50 - and this h variable into here
120:54 - and python has quite a few ways of
120:56 - achieving that
120:59 - the one people tend to learn first is
121:01 - called format this is just another
121:03 - method
121:04 - this one works by adding curly brackets
121:08 - inside of your string where you want to
121:10 - add a variable in my case i want to
121:12 - replace the name with a curly bracket
121:15 - and the age with another curly bracket
121:18 - and now i can add values into this
121:20 - format this could for example be a one
121:23 - and a two
121:24 - if i run all of this now i can see hello
121:27 - one you are two years old
121:29 - what python has done here is it looked
121:32 - at the first curly brackets
121:34 - and then it looked inside of format and
121:37 - found the first value after that it saw
121:40 - another curly bracket and looked for the
121:43 - second value inside of format and then
121:46 - inserted it into the string granted just
121:49 - adding one and two in this example isn't
121:51 - particularly helpful
121:53 - but what we can do is add variables in
121:56 - here as well like name and age
122:00 - if i run this now we get hello tom you
122:02 - are 40 years old
122:04 - and this now means we can change these
122:06 - variables let's say a hundred and
122:11 - something it really doesn't matter what
122:13 - it is
122:14 - although you do have to be careful about
122:16 - the order if i switch them around with h
122:19 - coming first and then name
122:21 - now we have hello100 you are something
122:24 - years old
122:25 - the order here being wrong messed all of
122:28 - this up which can be kind of annoying
122:32 - especially if you have longer strings
122:34 - where you want to add more variables
122:37 - this can become very confusing
122:39 - and as a consequence python has a way to
122:42 - make all of this more organized
122:44 - you can inside of the curly brackets add
122:47 - something like variable names
122:49 - let me call them one and two and now you
122:52 - can assign one to name and two to the
122:56 - age
122:57 - if i run this now we are getting the
122:59 - same outcome
123:01 - although now we know very specifically
123:03 - which value is being assigned to which
123:05 - curly bracket
123:06 - one gets this one here
123:09 - and two
123:11 - is getting this value here
123:13 - meaning now we're going to sign h to 1
123:16 - and
123:17 - i guess we could keep h for 2 as well if
123:20 - i run this now we get hello 100 you are
123:23 - 100 years old
123:25 - the reason is we are assigning h to both
123:27 - 1 and 2
123:29 - which is putting this age into here and
123:33 - into here
123:34 - and that way you can be much more
123:36 - deliberate about where you put the
123:38 - variables
123:39 - that being said
123:41 - very few people
123:42 - use this kind of method because when you
123:45 - look at it it's kind of inefficient
123:48 - why do we have to add a whole method
123:51 - with arguments why couldn't we just add
123:53 - variables straight inside of these curly
123:56 - brackets that would be much better and
123:59 - python developers agree
124:01 - and to achieve that
124:04 - they have created what is called an f
124:06 - string
124:07 - let me create another variable let's
124:10 - call it greeting string
124:12 - better
124:13 - for this one i want to copy this entire
124:16 - string and paste it in here
124:18 - and now i'm going to add the variables i
124:21 - want straight into the curly brackets
124:24 - we have name for hello and h4 years old
124:29 - although now if i print greeting strings
124:32 - better
124:33 - i am getting hello name you are 8 years
124:36 - old python interprets this and this
124:40 - as a simple part of the string which
124:44 - isn't ideal
124:45 - to tell python that these are supposed
124:48 - to be variables we have to add an f at
124:51 - the beginning of the string and that is
124:53 - all we need if i run this now we're
124:56 - getting hello something you are 100
124:58 - years old
125:00 - and you can see it by the colors
125:02 - the name
125:04 - and the age are not green anymore
125:08 - which in our case means they are not a
125:10 - string anymore although your colors may
125:13 - vary depending on what color scheme you
125:14 - have
125:15 - we can let me return to bob who is 40
125:18 - years old this is still going to work
125:22 - and this version here is much more
125:24 - readable than this one up here i guess
125:28 - let me fix it this is better
125:30 - but still this one here is very annoying
125:33 - to read whereas this one is really clear
125:36 - and f strings can actually do quite a
125:38 - bit more inside of these curly brackets
125:41 - you could even do basic math operations
125:44 - for example we could add h plus 10
125:47 - all of this would also still work with
125:50 - that we have covered a lot of stuff for
125:52 - strings and i think this part is getting
125:54 - quite long so let's do an exercise and
125:56 - then finish it off
125:57 - and what i want you guys to do is this
126:00 - one here i want you guys to create an f
126:03 - string that says hello my name is x and
126:05 - my hobby is y
126:07 - x and y should both be separate
126:09 - variables
126:11 - and the second half of the sentence
126:13 - should be on a separate line and by
126:15 - second half i mean and my hobby is y
126:18 - this should be on a separate line when
126:20 - it is being printed pause the video now
126:22 - and try this one yourself
126:26 - let me comment out all of this here so
126:29 - we're not getting confused
126:31 - and now let's go for this step by step
126:34 - first of all i want to start by creating
126:37 - an f string here
126:39 - let me copy it
126:41 - and let's call this the exercise
126:44 - string
126:45 - in here i want hello my name is x my
126:48 - hobby is y
126:49 - since we want x and y to be in separate
126:52 - variables
126:53 - x should be in curly brackets and y
126:56 - should also be in curly brackets
126:58 - and since we want python to interpret
127:00 - these as variables we need an f at the
127:03 - beginning of the string
127:05 - so now we have to tell python the values
127:08 - for x and y
127:10 - let me put x here
127:12 - and y here
127:14 - let's say for x a value we haven't used
127:16 - yet is lisa
127:18 - and i like i don't know
127:21 - programming
127:24 - with that i can print the exercise
127:27 - string and we have hello my name is lisa
127:29 - my hobby is programming
127:32 - this is already covering the first two
127:34 - parts of the exercise
127:36 - next up is the second half of the
127:37 - sentence should be on a separate line
127:40 - and this we could approach in two
127:42 - different ways
127:44 - the first one is we could use an escape
127:46 - character
127:47 - meaning
127:48 - forward slash n
127:50 - and now if i run this we get hello my
127:53 - name is lisa and my hobby is programming
127:55 - on two different lines
127:57 - another way of approaching this let me
127:59 - copy it
128:01 - you could use triple quotation marks
128:04 - so i add two at the beginning and two
128:06 - more at the end now i get rid of the
128:09 - line break and put all of this on
128:11 - separate lines
128:12 - i guess let me call this exercise string
128:14 - two
128:15 - and now print two and we're getting the
128:18 - same result
128:19 - these two lines here and this line here
128:22 - both do practically the same thing
128:24 - although i guess this one is a bit more
128:27 - readable well i guess it's debatable
128:30 - you could choose here whichever you like
128:32 - although be aware the first one is much
128:35 - more common also keep in mind here the
128:37 - variable naming i used capital x and
128:40 - capital y is quite bad
128:42 - this should rather be called name and
128:44 - hobby in this part we are going to learn
128:47 - two more data types lists and tuples
128:50 - both are very similar and both are
128:53 - simply data containers for other data
128:55 - types
128:56 - which means they are storing other kinds
128:59 - of data that's what a container does
129:01 - and they can contain any kind of data
129:04 - this could be a string a number it could
129:07 - also be a boolean other lists and tuple
129:09 - and a lot more there's no limitation on
129:12 - what they can store a tuple would look
129:15 - something like this
129:17 - we are starting with normal brackets
129:20 - and we're also ending with normal
129:22 - brackets and inside of that we have
129:24 - values that are being separated by a
129:26 - comma
129:27 - for example in this case we are starting
129:29 - with an integer and then we're adding a
129:31 - comma
129:32 - then we have a string
129:34 - another comma
129:35 - then we have a boolean value another
129:38 - comma and then we have a tuple inside of
129:41 - this original tuple which python is
129:44 - totally fine with and inside of this
129:46 - tuple we have another string and that is
129:48 - the only value for this tuple so it
129:51 - really doesn't make too much sense i
129:53 - just wanted to illustrate that you can
129:54 - do it
129:55 - besides a tuple we have a list
129:59 - and a list is looking very similar the
130:02 - only difference now
130:04 - is that to create a list we need square
130:07 - brackets
130:08 - but other than that we are still adding
130:10 - values inside like integers strings
130:13 - booleans and other lists and we are
130:16 - separating each value with a comma like
130:18 - here here and here
130:20 - on the surface those two would look
130:23 - identical and you would be kind of
130:25 - correct the two are very similar but
130:27 - there's one incredibly important
130:29 - difference
130:31 - tuples are what is called immutable
130:34 - which just means that they cannot be
130:36 - changed
130:37 - for example
130:39 - you could use something like list append
130:42 - and this would work because list can be
130:44 - changed
130:45 - but a tuple and depending a value would
130:48 - not work because we cannot change a
130:50 - tuple under any circumstance
130:53 - if you really wanted to add a new value
130:55 - to a tuple you would have to create a
130:58 - whole new tuple and combine the old
131:00 - values with a new value
131:02 - which you can do fairly easily but if
131:05 - you are going to do that you could just
131:07 - use a list it would be much easier
131:10 - that being said because of this
131:13 - immutability
131:14 - tuples process a tiny bit faster in
131:18 - python
131:19 - although the difference is so small you
131:21 - are hardly ever going to notice
131:23 - i guess let's have a look at all of this
131:25 - and see how far we get let's get started
131:27 - by creating some lists
131:30 - and a list let me store it in the
131:32 - variable again
131:34 - you are always creating with square
131:36 - brackets and in here you're adding
131:38 - values that are separated by a comma for
131:41 - example you could be adding numbers like
131:44 - 1 2 and 3
131:45 - you could add floating point values like
131:47 - 4.5
131:49 - and you could be adding words like let's
131:52 - say word
131:53 - those are the data types we have already
131:55 - seen but any data type would be valid in
131:58 - here
132:00 - now if i print
132:01 - my list
132:03 - we can see
132:05 - the output we have entered into this
132:07 - list it does work pretty seamlessly
132:10 - what you can also do is to use the
132:13 - functions we have already seen for
132:15 - example len
132:18 - is now going to give us the amount of
132:20 - items we have inside of this list which
132:23 - right now is 5.
132:25 - finally you could also use the list with
132:28 - methods and lists do have quite a lot of
132:32 - methods
132:33 - i suppose a simple one would be clear
132:36 - this one removes every value from the
132:38 - list
132:39 - meaning if i print my list after running
132:43 - this method
132:44 - i am getting 5 items from this line here
132:49 - and this line now is going to print an
132:52 - empty list i suppose if you want to look
132:54 - this up
132:56 - in google all you would have to do is
132:58 - look for something like python list
133:00 - methods once again you are going to find
133:04 - a lot of different websites that talk
133:06 - about it
133:07 - the official python documentation this
133:09 - one here is probably the one you want to
133:11 - use
133:12 - and in here
133:14 - let me hide this one we have append
133:17 - extend insert remove and a lot more the
133:20 - one we have just seen was called clear
133:23 - this one is removing all items from a
133:25 - list and it is equivalent to something
133:28 - else
133:29 - what this part here means we are
133:32 - actually going to learn in a couple of
133:33 - minutes it's super useful for now just
133:36 - keep in mind there are a lot of
133:38 - different methods in here that you could
133:39 - be using another easy one would be
133:42 - reverse this one reverses the list let's
133:45 - have a look at this one
133:46 - i suppose we could change clear to
133:49 - reverse and now if i run the code
133:53 - we are getting the entire list in the
133:55 - reverse order compared to this list here
133:58 - just like with words or well with
134:00 - strings
134:01 - the main way you are going to learn the
134:03 - different methods is by just using
134:04 - python and encountering different
134:06 - problems and finding the solutions to
134:08 - them and most of the time the solution
134:10 - is going to involve some kind of method
134:13 - at some point you are going to get used
134:15 - to different methods for a list
134:18 - that being said also
134:20 - you don't need to know all of them by
134:21 - hard i myself completely forgot about
134:24 - reverse until i saw it when i prepared
134:26 - for this video
134:28 - but well with that we have lists
134:31 - and i guess we have functions and we
134:33 - have methods at least in a very basic
134:36 - outline
134:37 - although there's one really important
134:39 - method that i do want to talk about and
134:42 - that one is called
134:44 - append
134:46 - and
134:47 - this one appends a value i think the
134:49 - name makes sense here
134:51 - basically anything you add in here as an
134:53 - argument will be added at the end of the
134:56 - list
134:58 - for example if i added
135:00 - let's say it 10 at the end
135:03 - run all of this
135:05 - now we can see all the way at the end we
135:07 - have this 10.
135:09 - this would be one of the ways you add an
135:11 - item to a list there are quite a few
135:13 - more but this is a really basic one that
135:16 - i just want to cover for now with that
135:19 - we can look at the other kind of
135:20 - container and that is called a tuple and
135:24 - the tuple you let me save it in a
135:26 - variable that i called my tuple
135:29 - you would be creating with brackets
135:33 - and in here again you can add any kind
135:36 - of value you want could be a number
135:37 - could be a floating point number
135:40 - it could be a word
135:42 - or it could be a list as well that
135:45 - itself contains other values
135:48 - let's say 7 8 and 9.
135:51 - let me comment out the earlier stuff and
135:54 - print my tuple
135:57 - and there we go now we can see all the
135:59 - values we have added in here
136:03 - a tuple and a list work in very similar
136:06 - ways
136:07 - at least up to a point because there is
136:10 - a major difference
136:12 - that difference being that tuples
136:16 - cannot be changed under any
136:18 - circumstances
136:20 - this means
136:21 - i couldn't run something like my tuple
136:24 - append
136:25 - and then let's use a 10 again
136:28 - the method we have used up here
136:31 - if i run this line of code we're getting
136:33 - an error that tuple object has no
136:36 - attribute append
136:38 - we also couldn't delete a value and we
136:40 - couldn't reverse the order of this tuple
136:44 - let me demonstrate the reverse one this
136:46 - one here
136:47 - this one also would not work on a tuple
136:51 - most of the time when you are using
136:53 - tuples
136:54 - you generally only want to use tuples
136:57 - when you know you are not going to
136:59 - change the values
137:00 - but most of the time let's say 70 80
137:04 - you are going to use a list this one is
137:06 - the much more common data type because
137:08 - it is more flexible with that covered we
137:11 - have to cover a really important topic
137:14 - and that is how to pick
137:17 - elements from a tuple or a list
137:21 - what that means is for example i might
137:25 - want to get this floating point value
137:27 - here from the list and then work with it
137:30 - so how could i get this value
137:33 - and for that
137:34 - we need a specific process that in
137:37 - python is called either indexing or
137:39 - slicing
137:40 - the two are very much related
137:43 - let's talk about it actually
137:45 - let me actually go for this a bit more
137:47 - properly to restate the problem
137:49 - we want to pick one element from a list
137:52 - this could also be a tuple they both
137:54 - work in exactly the same way for us to
137:56 - do that we need to cover two important
137:59 - concepts
138:01 - the first one is that python assigns
138:03 - each value in a list on a tuple and
138:06 - index number
138:07 - if this is our list python would give
138:10 - each of these numbers an index
138:13 - the first number is always going to be a
138:15 - zero and then every successive number is
138:18 - going to be plus one of that number
138:21 - meaning the second value is one the
138:23 - third value is two and then so on
138:26 - and a really important point to notice
138:27 - here is that we always start counting
138:29 - from zero not one
138:31 - and this can be a very annoying concept
138:34 - to deal with i think for beginners
138:36 - forgetting about this covers about half
138:38 - of all of your errors just be ready for
138:40 - that
138:41 - but anyway the concept we have for now
138:44 - is that every item inside of a list has
138:46 - an index and this index we can use to
138:49 - pick an element and this works by adding
138:52 - square brackets after the list or tuple
138:56 - in practice this would look something
138:58 - like this
138:59 - right now we have our list and then
139:01 - after the list we have another set of
139:03 - square brackets with an integer and this
139:06 - integer is going to pick
139:08 - one specific index right now the index
139:11 - one which is going to be the second
139:14 - element this one here meaning this
139:16 - operation would return the value 2 and
139:20 - since we are using an index this entire
139:22 - operation is called indexing
139:25 - it works on quite a few data types lists
139:28 - and tuples should be fairly obvious we
139:30 - could also be using it with strings
139:32 - because they are basically another kind
139:35 - of container we can have a look at this
139:37 - one as well
139:38 - however indexing does not work on
139:41 - dictionaries and sets
139:43 - dictionaries work in a slightly
139:44 - different way and sets work in a very
139:46 - different way we are going to see that
139:48 - later on and i guess let's play around
139:50 - with all of this
139:52 - here i am back in my code and i want to
139:55 - comment out
139:57 - the two methods for the tuple and i want
140:00 - to uncomment my list
140:03 - meaning now i have a list and a tuple to
140:06 - work with
140:07 - and i want to just pick some random
140:09 - elements from them i guess we can start
140:11 - with my list and in here i am using
140:14 - square brackets and now i need an
140:16 - integer i'm going to pick 0 just to pick
140:19 - the first element
140:21 - this zero now
140:23 - is going to refer to the first element
140:26 - inside of my list or the one with the
140:29 - index zero
140:31 - if we added a one we will get the next
140:33 - element two three four and so on
140:37 - to show all of this we have to print it
140:39 - again now if i run this we are getting
140:42 - one indeed the value up here
140:45 - if i added it 2 in here
140:48 - and run this again we are getting the
140:50 - integer 3 which is
140:53 - this item here we have 0 1 and 2. all of
140:58 - this would also work with a tuple
141:01 - meaning if i use my tuple this tuple
141:04 - here
141:05 - and now pick let's say
141:07 - the item number 5.
141:11 - run this again
141:12 - we are now getting the list
141:14 - this one here at the end of the tuple
141:17 - because this one is the element with the
141:18 - index five
141:20 - we have zero one two three four and five
141:26 - what we can do now as well
141:28 - is to add another square brackets
141:30 - afterwards because remember what we are
141:33 - getting from this one here
141:35 - is going to return one item from this
141:38 - tuple in this case this list here which
141:41 - means that this operation here
141:44 - stands in for this tuple so when we add
141:48 - the square brackets afterwards these
141:50 - ones here
141:51 - we are basically adding the square
141:53 - brackets after here and then we can take
141:56 - other elements from that
141:58 - if i add a zero in here we should be
142:00 - getting seven
142:02 - my tuple five gets us
142:04 - this list here
142:06 - and then the zero gets us the first
142:08 - element inside of it
142:10 - these operations are fairly common right
142:13 - now i assume they do seem quite
142:15 - confusing but if you play around with
142:17 - them for a while they should become
142:19 - fairly familiar just remember what is
142:21 - getting returned and how you can work
142:23 - with that
142:25 - there's one more thing that you could be
142:27 - doing in here let me duplicate the line
142:29 - i only want to use one indexing
142:32 - operation
142:34 - what you can also do is go in the
142:36 - negative direction for example if i use
142:39 - negative one
142:40 - we are getting the list again
142:43 - what this negative one means is we are
142:45 - always starting at zero and if we go in
142:48 - the positive direction we are basically
142:50 - going to the right
142:52 - however if we are choosing a negative
142:54 - number
142:55 - we are
142:56 - going all the way to the back of the
142:58 - list and then going in the opposite
143:00 - direction meaning this list here would
143:02 - be negative 1
143:04 - word would be negative 2
143:06 - and the 1.45 would be
143:09 - negative 3
143:10 - which means that negative 3 and 4 should
143:13 - have the same result unless i made an
143:15 - error let's try
143:17 - if i enter negative 3 we get 1.45
143:21 - if i add 4
143:23 - we are getting word and i just realized
143:26 - i can't count um
143:28 - sorry about that
143:29 - this should be a 3 and this is a 4.
143:34 - talking and writing can be kind of
143:35 - challenging i guess you noticed this one
143:37 - already but now
143:40 - what you should be able to see is if i
143:42 - add a 3 in here we are getting 1.45 and
143:46 - if i add a negative 3 we are also
143:48 - getting 1.45 all right with that we have
143:53 - basically all we need to get started
143:55 - with indexing this is a very simple
143:58 - operation when it comes down to it
144:00 - although this video is getting kind of
144:02 - long so let's do an exercise and then we
144:05 - finish this section
144:06 - and what i want you guys to do let me
144:08 - paste it in here's the exercise
144:11 - we have a long string and of the string
144:15 - i want you guys to pick one word or
144:17 - string and that is hello that is going
144:20 - to be this element here
144:22 - although do notice here that this is a
144:26 - list
144:27 - inside of
144:29 - a list inside of another list so you
144:33 - have to pick elements that are quite a
144:36 - bit nested
144:37 - but if you paid attention so far this
144:39 - should be doable so pause the video now
144:42 - and try this one yourself
144:46 - alrighty let's get started and just to
144:49 - illustrate what is happening here
144:51 - let me save all of this in a separate
144:53 - variable that i'm going to call solution
144:55 - var
144:57 - and this
144:58 - is going to be we always have to start
145:00 - with the exercise list
145:02 - now we need square brackets and we want
145:05 - to pick
145:06 - one item from here with the index
145:09 - we have item number zero we have item
145:13 - number one and we have item number two
145:15 - and item number one covers this entire
145:18 - list here this is what we want meaning
145:21 - in here i want item number one which
145:24 - means if i print the solution variable
145:27 - and comment out all of the stuff above
145:31 - and run all of this now we can see we
145:34 - have the list with one two three four
145:35 - five and then the other list inside and
145:38 - from this we want to get another index
145:41 - now we have let me clean this one up a
145:44 - tiny bit
145:45 - purely inside of this list here we have
145:48 - a few more elements
145:50 - we have 0 we have 1 and then we have 2
145:54 - 2 being this entire thing this is all we
145:58 - want right now
146:00 - which means we now want the index number
146:03 - 2.
146:04 - now if i print my solution i get another
146:07 - list with zero and hello we are getting
146:10 - very close
146:11 - now inside of this final list
146:14 - this list alone here we have two entries
146:17 - we have zero and we have 1
146:20 - and 1 is our solution
146:23 - which means at the end of this i want to
146:26 - add a 1 and then we should be done so
146:30 - let's try and there we go we get hello
146:33 - obviously
146:34 - you would very rarely see something like
146:36 - this this is very poor data management
146:39 - because it's a very messy list that is
146:41 - really hard to work with
146:43 - but i guess it's a very good exercise
146:46 - this video is going to be part 2 on
146:48 - lists and tuples and this is primarily
146:51 - going to be about picking multiple
146:52 - elements
146:54 - so the main problem we have to cover is
146:56 - how to pick multiple elements from a
146:58 - list
146:59 - let's say we have a list with the
147:01 - numbers one two four and we want to get
147:03 - the second and the third element how
147:05 - could we do that right now we can only
147:07 - pick a single element fortunately python
147:10 - can do this with something that is very
147:12 - similar compared to indexing and that is
147:14 - slicing
147:16 - how this works is you are still going to
147:18 - need square brackets like with indexing
147:21 - but now instead of adding one number you
147:23 - are adding two numbers separated by a
147:25 - colon
147:26 - the first number is the start and the
147:28 - second number is the end value for
147:30 - example it could look something like
147:32 - this
147:33 - for example in here we have the indexes
147:36 - from zero to three
147:39 - one right now is going to refer to this
147:42 - two here
147:43 - and 2 is going to refer to the index
147:46 - number 2 which right now is going to be
147:48 - a 3. this is how we are picking the
147:50 - start and the end value however there is
147:53 - going to be a really important concept
147:54 - you have to understand
147:56 - and that is python only goes up to the
147:59 - end but it does not include it which
148:02 - means in this case we would only get one
148:05 - number
148:06 - we would be starting on this 2 here that
148:09 - is our start value however we are only
148:12 - going up to
148:14 - index number two we are not including it
148:17 - so in practice our list indexing ends
148:20 - here right before our end index
148:24 - as a consequence this operation here is
148:27 - only going to return this two and
148:29 - nothing else
148:31 - that is going to be a fairly common
148:33 - issue but you will get used to it let's
148:35 - practice this one once again here i have
148:38 - a completely empty python file and i
148:41 - want to create a test list and that is
148:43 - the list we have just seen this one has
148:45 - the values one two three and four
148:49 - and just to demonstrate what i've just
148:50 - talked about i want to print my test
148:54 - list
148:54 - and in here i want the values from 1
148:57 - colon 2.
149:00 - if i now run this i am getting another
149:02 - list with 2.
149:04 - that means that list slicing always
149:07 - returns a list even if there's only a
149:09 - single value inside for example what we
149:12 - could even do is go from index 1 to
149:15 - index 1
149:16 - which would get us if i run this an
149:18 - empty list
149:20 - and this is something you always have to
149:22 - keep in mind if you want in this case
149:24 - for example the second and the third
149:26 - element you have to go to the index
149:28 - after that in this case this is going to
149:31 - be one two three
149:33 - if i run this now we are getting the
149:36 - numbers 2 and 3.
149:38 - and that for start is all you have to
149:40 - know about slicing although you can do
149:43 - quite a bit more but let's talk about
149:44 - this inside of my slides
149:47 - besides the start and the end value you
149:49 - can also add a third number for the
149:51 - direction
149:53 - by default this one is going to be zero
149:55 - meaning we are always moving plus one in
149:57 - the positive direction it might look
150:00 - something like this we again have the
150:02 - same list and we have our indexes 0 1 2
150:06 - and 3.
150:07 - and this one here at the end
150:09 - means that we are moving in the positive
150:12 - direction in a step size of 1
150:15 - which right now will get us the next
150:17 - element but we could have a larger or
150:19 - smaller value you could also have
150:21 - negative values to go into the other
150:23 - direction
150:25 - here we are back in the code and i want
150:27 - to add a few more values to this list so
150:29 - it's a bit easier to visualize what's
150:31 - happening
150:32 - now we have the values from 1 to 10.
150:35 - although if i run this one here
150:38 - it is going to give us the same result
150:40 - but now let's say i want to have the
150:42 - values from 0 to
150:44 - 8. if i run this we are getting the
150:48 - first eight values
150:50 - although now what i can do i can add
150:52 - another set of colons and then for
150:54 - example add a two in here
150:56 - and now if i run this i am only getting
150:59 - every second value
151:01 - so we are starting at the index number
151:03 - zero and we are only ever picking every
151:06 - second value which is the three the five
151:09 - and then the seven
151:11 - and since our last index is going to be
151:14 - here we're not including this 9 anymore
151:17 - and then we're getting the values 1 3 5
151:20 - and 7 the values down here
151:23 - and this step size can also be negative
151:26 - for example you could in here add a
151:28 - negative one although right now this
151:30 - wouldn't do very much
151:33 - so the issue here is we are starting at
151:35 - this value as our starting point
151:38 - and our end value is eight which i
151:40 - believe is this value here
151:43 - and since we are now moving in this
151:45 - direction there simply isn't any value
151:47 - so this entire operation doesn't give us
151:49 - anything
151:51 - however what we can do is flip those two
151:53 - around so our start value is 8 and our n
151:56 - value is 0.
151:58 - if i now run out of this we get all of
152:00 - these values reversed
152:02 - and negative values you can add actually
152:05 - everywhere in here so for example you
152:08 - could have the start value of negative
152:10 - one and the end value let's say at four
152:14 - this is going to work just like normal
152:16 - indexing this would mean you are
152:18 - starting here all the way at the end
152:21 - that is the negative one and then we're
152:23 - going to the fourth element which is
152:25 - going to be
152:26 - zero one two three and four this one
152:30 - here is index number four
152:32 - so we are expecting to get the numbers
152:34 - from ten to six
152:37 - let's see if that's the case
152:39 - and it is we get numbers from 10 to 6
152:42 - and that is basically all you have to
152:44 - understand about the basics here
152:46 - although there's one more thing that you
152:48 - can do
152:49 - and that is you can also leave values
152:51 - entirely empty when using slicing this
152:54 - might look something like this
152:56 - this does look a bit strange but it does
152:59 - work
153:00 - what it means is let me talk through it
153:03 - every number in the slicing operation
153:05 - has a default value
153:07 - so we have a start and end and a step
153:09 - value for start the default value is
153:12 - always the very first item inside of the
153:14 - list in the example here it would be a
153:17 - 1.
153:18 - the end value by default is always going
153:20 - to be the last item inside of the list
153:23 - in this case here that would be a 4
153:26 - and for the step size the default value
153:28 - is a 1 which means we are always moving
153:32 - plus one in the positive direction by
153:34 - default this one should make sense it's
153:37 - quite straightforward
153:38 - and let's play around with all of that
153:40 - let's see how far we get
153:42 - so here we are back in the code and
153:45 - let me actually add all of this inside
153:47 - of a variable
153:49 - let's call it negative slicing i should
153:52 - probably add more variables so it's
153:54 - easier to follow in the notes
153:56 - but let's start working on leaving
153:58 - values empty this i want to save in a
154:00 - variable let me call it default
154:04 - slicing
154:06 - in here as always i need my test list
154:09 - and in here i want to go from my start
154:12 - to the end of the list
154:14 - and i only want to get every second
154:16 - value
154:18 - now the start is going to be easy
154:20 - because this one is always going to be
154:22 - one but you could also leave it
154:24 - completely empty it would have the same
154:26 - result and here we could also leave
154:29 - empty that would get us the very last
154:32 - item inside of a list 10 right now and
154:34 - this is actually really useful because
154:36 - by default we don't know what the last
154:38 - index is going to be finally i want to
154:41 - have every second element
154:43 - this would be a 2 in here
154:46 - and now let me print the default slicing
154:49 - variable let's run this and we're only
154:51 - getting every second value
154:54 - we could also add every third value in
154:56 - here
154:56 - and there we go
154:58 - if you left all three of them empty and
155:01 - run this again you will get all of the
155:03 - numbers so this is looking a bit strange
155:06 - but it certainly is working
155:08 - and this system can be incredibly useful
155:12 - as a consequence let's do an exercise
155:15 - and what i want you guys to do
155:17 - is this exercise here i want you guys to
155:20 - start from 8 and go to 2 and only pick
155:23 - every second element
155:24 - and when i say 8 and 2 i mean actual
155:28 - number not indexes
155:30 - so you want to start at this 8 here and
155:32 - then go to this to here at the end these
155:35 - are the values you are going to cover
155:38 - except only every second element meaning
155:40 - the 7 shouldn't be in here this 5
155:42 - shouldn't be in here and so on
155:44 - so pause the video now and try to figure
155:46 - this one out
155:50 - let me save all of this inside of a
155:52 - variable and as always we need the test
155:55 - list
155:56 - in here
155:57 - we need square brackets for slicing and
156:01 - now we need a start an end and a step
156:04 - size
156:05 - since we do have to go negative remember
156:07 - we are starting from 8 and we are going
156:09 - to 2 this has to be a negative number
156:12 - let's say negative 1 now just to have a
156:14 - start value
156:16 - while i do this let me show the solution
156:19 - right now what we are going to get is
156:22 - the entire list in reverse
156:25 - although in my case i don't want to
156:26 - start at 10 i want to start at 8
156:30 - meaning we have to figure out how we can
156:32 - get this 8 here
156:34 - that would be our start value
156:37 - and one mistake you could be making in
156:38 - here is simply add an 8 because this
156:42 - would not work
156:44 - right now we are starting at 9.
156:46 - the problem here is remember when we're
156:49 - using indexing we are starting at zero
156:51 - meaning this is zero one two three four
156:55 - five six seven eight and nine
156:59 - meaning if we are adding the index eight
157:01 - we are adding on the nine here which
157:04 - isn't helpful
157:05 - instead what we could do is add a 7 in
157:08 - here and now if i run this again we are
157:10 - starting at 8. alternatively what you
157:13 - could also do is add a negative 3 in
157:16 - here
157:17 - if i run this one we are also starting
157:19 - at 8.
157:21 - and i guess remember we could also go
157:23 - negatively so this 9 would be negative 1
157:26 - then we have negative 2 and negative 3
157:30 - that would be our 7.
157:32 - both would be fine it's really up to you
157:34 - what you prefer i guess the 7 here is a
157:37 - bit more expressive but
157:39 - well it's basically subjective
157:42 - but now we have to find the end value
157:45 - and in here you might be very tempted to
157:47 - pick one for the index
157:49 - let me actually do that
157:51 - if i add a one in here run this again
157:54 - we are ending on three as our final
157:56 - element
157:58 - the reason is that
158:00 - python always only goes up to the final
158:03 - element but it doesn't include it
158:06 - as a consequence three is going to be
158:08 - our final element the way around that
158:10 - one is this should be a zero
158:13 - now our final element is this zero so
158:16 - we're going up to that element but we're
158:17 - not including it so two is our final
158:20 - number
158:21 - the final thing we need is we only want
158:23 - to pick every second element
158:26 - this is quite easy all we need is a
158:28 - negative two if i now run out of this
158:30 - again we get eight six four and two and
158:34 - with that we are done this is basically
158:37 - all you need for slicing and this would
158:39 - also work for a tuple i guess let me
158:42 - demonstrate this one really quick let's
158:44 - call it tuple
158:46 - slicing
158:48 - and then here we have a test pupil and
158:51 - this one would just have the values one
158:53 - two three four five six seven 8 9 and 10
158:58 - and in here i could for example print
159:01 - test
159:02 - pupil
159:03 - with the values 0
159:05 - 5 and let's say 3
159:07 - it should be a colon
159:09 - and let me comment out the exercise here
159:13 - and there we go we get 1 and 4.
159:17 - once again a list and a tuple are
159:20 - incredibly similar the only difference
159:22 - is is that a list can be modified
159:24 - whereas a tuple cannot
159:27 - there is one more topic that i want to
159:29 - cover with lists and tuples and that is
159:31 - unpacking
159:33 - basically what that means is
159:35 - both lists and tuples can be unpacked in
159:38 - a way like this we have a and b and we
159:41 - are assigning a tuple to them
159:44 - what this is doing we are taking the
159:46 - first value and assigning it to the
159:48 - first variable a and 10 in this case
159:51 - and the second value gets assigned to
159:53 - the second value and that way you are
159:56 - unpacking a tuple on two variables
160:00 - this would also work with a list
160:02 - you would have the exact same result and
160:05 - let's have a look at all of this in code
160:07 - so for example what we can do i have a
160:09 - variable called a and a variable called
160:12 - b
160:13 - and i want to assign them to the values
160:16 - 10 and 5 inside of a list
160:18 - and this is well all we need if i now
160:21 - print a and print b
160:24 - we are getting an n5 we have unpacked
160:27 - this tuple on these two variables
160:30 - although keep in mind this only works if
160:33 - you have the same number of items as you
160:35 - have variables
160:36 - if for example i added a third item to
160:39 - this tuple let's say a 1.
160:42 - if i run this now
160:43 - we're getting an error that we have too
160:45 - many values to unpack and python
160:48 - expected 2 which we don't have
160:51 - but if you have the same number of
160:52 - variables as you have in the tuple you
160:54 - are good to go
160:56 - and this would also work inside of a
160:59 - list but let me add two more variables
161:01 - let's say c and d
161:02 - and now we have a list with i know 20
161:06 - and this also works with strings let's
161:08 - say hello
161:10 - if i now print c and i print d
161:14 - we are getting 20 and hello and this you
161:17 - can also make more powerful
161:19 - because when you are creating a tuple
161:21 - you don't actually need brackets for
161:24 - example you can have a list like this or
161:26 - you could create a list like this
161:28 - without the brackets just having values
161:31 - separated by a comma automatically
161:33 - creates a tuple
161:35 - although most of the time when you want
161:36 - to create a tuple it makes more sense to
161:39 - write the brackets because it's clearer
161:40 - what you are doing but you don't
161:42 - actually have to do it now where all of
161:45 - this becomes really interesting is when
161:47 - you combine these two approaches
161:49 - because by doing that you can assign
161:51 - multiple values to multiple variables on
161:53 - a single line of code which is super
161:56 - powerful
161:57 - for example we have the variables a b
162:00 - and c
162:01 - and we are assigning the values 1
162:04 - hello and 4.5 we have assigned values to
162:08 - three variables inside of a single line
162:10 - of code so let's have a look at this one
162:13 - in practice and then we can do an
162:14 - exercise
162:16 - for example for video game you could
162:18 - have health you could have energy and
162:20 - you could have a weapon
162:22 - and this you could all assign inside of
162:24 - a single line for the health we could
162:26 - have 100 for the energy we could have 50
162:29 - and for the weapon we could have a sword
162:33 - and now i could print weapon for example
162:36 - and all the way at the end we are
162:38 - getting sword
162:40 - and i hope you see the value of this if
162:42 - you have to assign multiple variables
162:44 - this is really really useful to keep
162:45 - your code a bit more organized
162:48 - and all right this video is going to be
162:50 - a bit shorter we can do the exercise
162:53 - right away
162:54 - and what i want you guys to do is this
162:57 - we have a variable 1 with the value 10
163:00 - and variable 2 with the value test and i
163:04 - want you guys to switch the values of
163:05 - these two variables
163:07 - meaning value 1 should have the value
163:09 - test and value 2 should have the value
163:12 - 10.
163:13 - so pause the video now and try to figure
163:15 - this one out
163:19 - alright the solution here is actually
163:21 - incredibly simple all you have to do is
163:24 - you want to assign value 1
163:26 - and value 2
163:28 - and what you want to assign them to is
163:31 - value 2 and value
163:34 - 1. basically what we're doing now is for
163:39 - value 2 we are assigning it to value 1
163:43 - and value 1 gets assigned to value 2.
163:47 - this is basically how you would switch
163:49 - around different values across different
163:51 - variables
163:53 - meaning now if i print
163:55 - value one let me run this we are getting
163:58 - test
163:59 - the value the value that used to be in
164:01 - the second variable
164:03 - before we're getting to the next section
164:05 - i want to do a short intermission and
164:07 - this one is strings lists and tuples
164:10 - because those are surprisingly similar
164:15 - all three of them are basically just
164:17 - containers they just happen to have
164:19 - different formats
164:21 - and as a consequence you can move
164:23 - between them very easily and also use
164:25 - indexing on strings
164:27 - let me demonstrate all of this actually
164:30 - i already have two variables a test
164:32 - string and a test list
164:35 - i suppose we can start by
164:37 - turning a string into a list or a tubal
164:43 - the two are very similar we don't really
164:45 - have to worry about the difference here
164:47 - and to convert a string to a list or
164:50 - tuple you have a couple of different
164:51 - ways
164:52 - the first one we can use to test string
164:56 - and then use the method split
164:59 - and this one splits the string at a
165:01 - certain point if you don't specify
165:03 - anything in here and print a result
165:06 - we are using a space to separate the
165:08 - values
165:09 - if you enter a value in here let's say a
165:12 - t and run this again we now separate
165:15 - this wherever we have a t
165:18 - we start at the beginning here and the t
165:20 - in there disappears meaning now in the
165:23 - string this t disappears and we have an
165:27 - empty
165:28 - string at the beginning of the list
165:31 - then we have all of this stuff here
165:34 - up to the next t which is his is a and
165:37 - then a space
165:39 - then we have the next t here and this
165:42 - one then gets us to the next point the e
165:45 - s bit this one here and then finally we
165:48 - have another t and this one disappears
165:50 - and we are just left with an empty
165:52 - string
165:54 - most of the time you are just going to
165:56 - use the space here this one does make a
165:58 - whole lot more sense another thing you
166:01 - could do
166:02 - is to use the list function
166:04 - and this one turns any kind of data type
166:07 - into some kind of list or at least it
166:09 - tries to it doesn't work with every data
166:11 - type but a string definitely does work
166:15 - if i run this
166:16 - we are now turning every single
166:18 - character into one element inside of a
166:21 - list
166:22 - this would also work with a tuple this
166:26 - is another function
166:27 - here we can add test string once again
166:30 - and now we have the same thing except
166:32 - now it's a tuple instead of a list
166:35 - the other way also works just fine we
166:38 - can turn a list or a tuple into a string
166:43 - although the process here can be a bit
166:46 - weird basically what you would be doing
166:49 - is you first get a string
166:51 - and right now i'm going to leave it
166:53 - empty intentionally
166:55 - then i need a dot and then i need a
166:57 - specific method and this method is
166:59 - called join
167:01 - and into this method as an argument i
167:03 - have to pass in some kind of list
167:06 - and as an argument here we are going to
167:08 - need a list or a tuple although it has
167:12 - to be a special kind of tuple because
167:14 - this one has to contain
167:16 - some kind of string
167:19 - let's say one
167:21 - and two just to keep it simple
167:24 - and now for run this
167:27 - these two elements here
167:29 - have been merged together what we are
167:31 - specifying inside of the string is going
167:34 - to be
167:35 - what determines the gap between the two
167:37 - right now it's empty so there's no gap
167:40 - between 1 and 2.
167:43 - i guess i could just add the gap in here
167:45 - if i run this now we get one gap two
167:49 - if we added more values in here
167:51 - let's say three
167:53 - and
167:54 - four
167:56 - we would always have a gap between each
167:58 - of these values
168:00 - most of the time you are just going to
168:02 - leave it empty and now you have one
168:04 - space between the values
168:06 - what you really have to be careful here
168:08 - though is that all of these values have
168:10 - to be a string
168:12 - i guess let me copy it and replace this
168:16 - with the test list
168:18 - we have up here
168:20 - if i run this now we are getting an
168:22 - error
168:22 - that python has a type error sequence
168:25 - item 0 expected is string instance in
168:29 - found
168:30 - which is python's way of saying
168:33 - it wanted a word or a string but it
168:35 - found a number and it's really not happy
168:38 - about it
168:40 - finally what you can do
168:42 - is to let me print it again
168:44 - you can use the str function and pass in
168:48 - a list in here
168:50 - to turn this list into a string
168:53 - if i run this now
168:54 - we are getting what looks like a list
168:58 - but this is actually a word or a string
169:02 - to demonstrate this let me put all of
169:04 - this inside of the type function if i
169:08 - run this now
169:09 - we get class string this one here is
169:13 - going to be a string it just looks like
169:16 - a list
169:17 - but i hope you get the idea
169:20 - one more thing really quick and that is
169:22 - indexing on strings this one works like
169:26 - it would work for a list
169:28 - for example i could have my test string
169:30 - and in here i want
169:32 - the first element which right now should
169:35 - be a t
169:37 - if i print all of this i am indeed
169:40 - getting a t
169:42 - just like with a list in the string the
169:44 - first element is going to be 0 then we
169:46 - have 1 2 3 and so on
169:50 - you could even use slicing here and for
169:53 - example at the 5 and now we're getting
169:55 - this the first word
169:58 - and i think it is quite valuable here to
170:01 - compare these two data types because
170:04 - when you think about words they really
170:06 - are just containers for individual
170:08 - characters and for python it made a lot
170:11 - of sense to make these interchangeable
170:13 - with a list or a tuple because well it
170:16 - does make kind of sense
170:18 - one of the major operations you are
170:20 - going to do as a programmer is to work
170:22 - between different data types so
170:24 - understanding how you can change one
170:26 - data type to another data type is a
170:28 - really valuable experience
170:31 - but okay there's one exercise i do want
170:33 - you guys to do and that is going to be
170:36 - connected to this operation here
170:39 - let me copy it and add an exercise here
170:43 - at the end
170:44 - what i want you guys to do on this
170:46 - string test list
170:48 - i want you guys
170:50 - to use string methods
170:53 - to remove all of the stuff so you only
170:55 - get one two three and four
170:58 - let me comment out
171:00 - all of the other parts to see what we
171:02 - get
171:03 - right now we're getting square brackets
171:05 - then 1 comma 2 comma 3 comma 4
171:08 - and square brackets again
171:10 - and i only want to have 1 2 3 and 4.
171:14 - try to use some methods to get rid of
171:18 - all of the other values besides the
171:19 - numbers and see how far you get
171:24 - to make this a bit easier
171:26 - let me save the result in a separate
171:28 - variable let's call it exercise
171:31 - this is also what i want to print
171:34 - right now we have to get rid of a couple
171:37 - of different things
171:38 - let's start with the square brackets
171:41 - for those
171:42 - we need the method we have already seen
171:44 - much earlier called strip
171:47 - and this one
171:48 - we want to start with one of the square
171:50 - brackets doesn't really matter which one
171:52 - you start with
171:53 - if i run this now we got rid of one
171:56 - square bracket
171:57 - and remember we can combine
172:00 - different methods meaning i can call
172:02 - strip again
172:04 - and now add the other square brackets
172:07 - the closing one we now have all the
172:09 - numbers and the commas in between them
172:12 - and to get rid of the commas we want to
172:15 - replace them
172:16 - meaning i want to target my comma
172:19 - and then replace it with an empty string
172:21 - so nothing
172:24 - now if we run this we are only getting
172:26 - the numbers 1 2 3 and 4 and we are done
172:30 - if you wanted to you could even get rid
172:32 - of the spaces here as well
172:35 - and this you would achieve with another
172:37 - replace method
172:39 - and now i want to target the empty space
172:41 - and replace this with nothing
172:44 - now if i run this
172:45 - we have all of the numbers right next to
172:47 - each other whichever you prefer
172:50 - at this point this is hopefully at least
172:52 - manageable
172:55 - the next important data type is a
172:57 - dictionary and this one is a more
173:01 - complex container but still just a
173:03 - container for other variables
173:06 - this one always has a key and a value
173:09 - pair the example 4 that i have is this
173:12 - one in here we have a key and we have a
173:16 - value the key right now is an integer
173:20 - the one
173:21 - but it could also be any other data type
173:23 - python is fairly flexible here
173:26 - and then we have a value this one here a
173:28 - list but again it could also be any
173:30 - other data type
173:32 - what you ultimately have to understand
173:34 - about dictionaries is that they are a
173:35 - container but a more organized one
173:38 - where every value has a key associated
173:41 - and you would use the key to access the
173:43 - value that way you wouldn't go by
173:46 - indexing you would instead have specific
173:48 - values we're going to cover that in more
173:50 - detail later on but let's start playing
173:52 - around with that
173:53 - let me start by creating a test
173:56 - dictionary
173:57 - and a dictionary you always create with
174:00 - curly brackets
174:01 - and inside of the curly brackets you
174:03 - need a key
174:05 - then a colon and then a value
174:09 - both of those have to be valid python
174:11 - data types
174:12 - for example for the key let me call it
174:15 - capital a
174:17 - and the value could just be an integer
174:19 - let's say one two three this would now
174:22 - be one key value pair if you want to add
174:25 - a second one you would add a comma and
174:27 - then the second key value pair
174:29 - let's say i want to call this one b
174:32 - and now i need a colon again and for the
174:34 - value now i want a list with the values
174:38 - i guess one two and three again
174:40 - i guess let me print this one so we can
174:42 - see the result if i run this we can see
174:45 - we have a dictionary with two key value
174:48 - pairs
174:50 - right now the key is always a string but
174:52 - this doesn't have to be the case you
174:54 - could also use a number like 1
174:58 - and then give it the value of i guess we
175:00 - haven't used the boolean yet so i can
175:02 - just add true in here if i now run this
175:05 - we get another key value pair the one
175:08 - limitation you do want to be aware of
175:11 - here is you cannot duplicate keys
175:14 - for example if i added another a
175:17 - with i don't know let's say another
175:19 - value and if i now run this
175:22 - this first value has disappeared
175:26 - the reason being that once we add the
175:28 - same key we are overwriting the original
175:32 - key value pair
175:33 - although most of the time that really
175:35 - isn't an issue you are too concerned
175:37 - about and once again you also have a ton
175:40 - of methods you could be using for
175:42 - dictionaries to go through all of them
175:44 - here is w3schools with a list of all of
175:48 - the methods you have available
175:50 - some that you are going to use fairly
175:52 - often are values keys and items this one
175:57 - here because those return specific parts
175:59 - of the dictionary let's play around with
176:02 - a couple actually
176:03 - right now if i run this we are getting
176:05 - the entire dictionary but if i add
176:08 - another method here and add values don't
176:11 - forget the brackets run this again
176:13 - now i am getting some kind of list
176:16 - looking thing
176:18 - with
176:19 - just the values from this dictionary
176:22 - keep in mind this is a different kind of
176:25 - data type
176:26 - if i put this
176:27 - into the type function run this again
176:31 - we're getting class dictionary values
176:34 - this is a completely separate data type
176:36 - in and of itself
176:38 - although you don't have to worry about
176:40 - it too much there are specific use cases
176:42 - for it and they all work basically
176:44 - automatically and you never think about
176:46 - the data type here
176:47 - the other method would be keys and this
176:50 - one gives you all of the keys again in
176:52 - the dig keys data type
176:54 - finally what we could also be looking at
176:57 - is items and this one is going to return
177:00 - the list but now it has two builds
177:02 - inside and those we could also access we
177:04 - are going to learn how this works later
177:06 - on
177:07 - and if you go for the list of the
177:08 - different methods this one should be
177:10 - fairly straightforward
177:12 - besides that
177:13 - you can also use once again the lan
177:15 - method is incredibly versatile in here
177:18 - we can add the test dictionary and we
177:21 - would get three meaning we have three
177:23 - key value pairs inside of this
177:25 - dictionary we have one two and three
177:29 - and that's kind of it for the basics of
177:32 - a dictionary it really isn't that
177:34 - complicated i guess let me add a comment
177:37 - here at the top for basics of a
177:40 - dictionary
177:42 - one topic i do want to cover really
177:44 - quick is converting a dictionary
177:47 - for example what we could be doing i
177:49 - guess let me print the results straight
177:51 - away
177:52 - i could get my test dictionary and
177:54 - convert it to a list for example
177:58 - if i run this
177:59 - we are now getting an actual list with
178:02 - all of the keys
178:04 - meaning the list contains a
178:06 - b
178:07 - and 1.
178:08 - something you really want to keep in
178:10 - mind when you are converting the data
178:12 - type here
178:13 - tuple
178:15 - would result in the very same outcome i
178:18 - guess finally you could also convert all
178:20 - of this to a string
178:21 - and then you would get the entire
178:23 - dictionary as a string
178:26 - probably not the most useful thing you
178:27 - could do but well you can do it
178:30 - i do want to cover one more important
178:32 - thing and that is indexing with
178:35 - dictionaries
178:38 - and here we have a problem because
178:41 - indexing the way we have learned it so
178:43 - far does not work and i think this makes
178:46 - sense if you have a dictionary like that
178:48 - and you want to add some kind of
178:51 - indexing operation at the end let's say
178:53 - with the number zero
178:55 - this to python would be kind of
178:57 - confusing
178:59 - this could for python mean you want to
179:01 - have the first item inside of the index
179:04 - or it could mean you are supposed to
179:06 - look for
179:08 - a key
179:09 - with the value 0.
179:11 - in this dictionary this doesn't exist
179:13 - but python doesn't know it when it sees
179:15 - this number here
179:16 - as a consequence the normal indexing
179:19 - does not work
179:20 - but there is another way actually there
179:22 - are two other ways you would do
179:24 - something like this
179:26 - instead of an integer you would add the
179:28 - name of the key in this case
179:31 - we have square brackets with an a and
179:34 - the a refers to this key here
179:38 - what is then being returned is
179:41 - the value associated with the key which
179:43 - is the one another way of doing this is
179:46 - the method get
179:47 - this one works in the same way you are
179:50 - passing in a key this key looks for a
179:53 - specific key value pair in the
179:54 - dictionary and we are getting the value
179:57 - associated returned
179:58 - back in my code i want to print
180:02 - test dictionary
180:04 - and now i want to get the value for
180:07 - capital a
180:09 - if i run this now we get 1 2 3 which is
180:12 - the value we have gotten all the way up
180:15 - here along the same lines
180:17 - instead of using square brackets you
180:19 - could use the method get
180:21 - and in here pass in the key you are
180:24 - looking for and you will get the value
180:26 - associated with it one two three again
180:29 - you may be wondering now what is the
180:31 - difference between these two approaches
180:34 - and generally get is slightly better
180:38 - because if you're looking for a key that
180:40 - doesn't exist let's say x in this case
180:43 - if you use square brackets
180:45 - you are going to get an error meaning
180:47 - your entire code is going to crash
180:50 - which usually is not a good sign
180:52 - but if you use the get method
180:54 - you don't get an error instead you get
180:57 - none returned
180:59 - which means let me add comments
181:01 - doesn't crash
181:03 - when it cannot find a key and i guess
181:07 - the comment here would be does crash
181:10 - when it doesn't find the key
181:15 - or e
181:17 - besides that the two approaches are
181:20 - pretty much identical
181:22 - and with that we have covered all of the
181:24 - basic things for this part so let's do
181:27 - an exercise what i want you guys to do
181:30 - is to do some research and look up the
181:33 - update method for a dictionary
181:35 - and via this method add another key
181:38 - value pair to this dictionary
181:43 - once again i am on a website that looks
181:47 - at all of the different methods that we
181:49 - could be using with a dictionary
181:51 - and the one we want to look for right
181:53 - now is called update if i click on it
181:57 - we have an example a definition syntax
182:00 - and quite a few different things that we
182:02 - could be doing
182:04 - usually what i'm looking at is the
182:05 - example
182:06 - in here
182:07 - we have one dictionary and then we're
182:10 - using the update method and we are
182:12 - passing in as an argument in another
182:14 - dictionary and this dictionary has a key
182:17 - and a value pair and this is going to
182:19 - insert all of this into the other
182:21 - dictionary
182:23 - so let's have a look at this
182:25 - i want to get my test dictionary and i
182:28 - want to use the update method
182:30 - and what we have seen so far is to
182:32 - insert another dictionary
182:34 - and in here we can just add some values
182:38 - let's say i want another key that's not
182:41 - how you spell that then a colon
182:45 - and then some other values i guess what
182:47 - we haven't used yet is a tuple
182:50 - with
182:50 - i don't know some other values in here
182:52 - if i run this we're not going to see any
182:55 - difference because we are not printing
182:56 - our new dictionary
182:58 - meaning now if i print my task
183:00 - dictionary
183:02 - i can now see another key and one two
183:05 - three at the end
183:07 - although you could be using this method
183:09 - in another way as well
183:11 - let me get rid of the argument we had so
183:13 - far and what you could be doing as well
183:16 - is specify
183:18 - some kind of name for a key in my case c
183:20 - and then specify a value let's say let
183:23 - me call it test
183:24 - if i run this now
183:26 - we get a string c and then test as
183:29 - another value
183:31 - and you could even add multiple values
183:33 - in here let's say d is going to be
183:37 - i know one two three it doesn't really
183:39 - matter and with that we have well
183:42 - another value i suppose while we are
183:45 - here there's one more way to add a value
183:48 - inside of a dictionary or a key value
183:51 - pair to be more specific
183:53 - and that is by using test dictionary
183:56 - and then using brackets and specifying a
183:59 - new key here this is very similar to
184:02 - using the key here except now we are
184:04 - creating a whole new key value pair
184:08 - a value we haven't used yet would be e
184:11 - and now you can just assign a new value
184:13 - to it let's say a hundred
184:16 - if i now run this
184:17 - we have all the way at the end
184:20 - the key e with the value 100 the thing
184:23 - we have specified here
184:25 - and that is basically all you have to
184:27 - know about dictionaries it really is a
184:30 - fairly simple data type but one that
184:32 - gives a lot of order to your code
184:35 - the final major data type is a set
184:38 - and these are also simple containers
184:41 - just like the other containers we have
184:43 - seen but this one is kind of different
184:47 - and special in some way it would look
184:50 - like this we still have curly brackets
184:53 - like in the dictionary at the start and
184:55 - at the end and inside we have values
184:58 - separated by a comma
184:59 - so far all of this is really
185:01 - straightforward
185:04 - the only difference compared to
185:05 - dictionary is we don't have keys we just
185:08 - have values
185:09 - where a set becomes unique is that every
185:12 - single value inside of a set has to be
185:15 - unique and any kind of duplicate will be
185:18 - deleted
185:21 - once more i have a completely empty
185:22 - python file and i want to create a
185:25 - variable let's call it my set
185:28 - and here
185:29 - i need curly brackets and inside of
185:32 - those i want to have some values i want
185:34 - to have separated by commas
185:37 - once i have that i can print this
185:39 - variable run the code and we can see we
185:42 - have some kind of set
185:44 - you know it's a set because we have
185:46 - values surrounded by curly brackets
185:48 - without any kind of keys if they had
185:50 - keys it would be a dictionary
185:52 - the one crucial thing you have to
185:54 - understand is that if i have a duplicate
185:56 - value in here let's say i have two fours
185:59 - if i run this again the second four is
186:02 - going to disappear because every value
186:05 - in here has to be unique and python is
186:08 - going to get rid of any value that is
186:09 - duplicated
186:11 - let's say duplicate values will be
186:15 - exterminated
186:16 - all right but other than that we can do
186:18 - quite a few normal things with a set for
186:22 - example we could print the len of my set
186:26 - that is not a bracket let's run this now
186:30 - and we know this set has a length of 4
186:34 - because we have 4 elements inside of it
186:36 - because we get rid of the duplicate
186:37 - values what you can also do is to use
186:41 - methods and sets do have quite a few
186:44 - one that is fairly popular is you can
186:47 - add another value and in here you just
186:50 - add as an argument the value you want to
186:52 - add and if you run out of this now we
186:54 - have a 5 added at the end of the set
186:57 - along the same lines you can also remove
187:01 - a value
187:02 - and let's say i want to remove the 2 in
187:05 - here
187:05 - if i run this now
187:07 - we don't have a 2 in the set anymore
187:11 - for the full list of all the methods you
187:12 - have available let's use a different
187:14 - website this time i'm using a website
187:16 - called geeksforgeeks this one is also
187:18 - quite good for python and i do want you
187:20 - guys to get used to looking at different
187:22 - websites they all do very similar things
187:25 - but slightly different so it is a really
187:28 - good idea to understand different ones
187:30 - all i really did was i typed python set
187:32 - methods into google and there we have
187:34 - w3schools we have programmers we have
187:37 - geeks for geeks and we have the python
187:39 - documentation
187:41 - these are the four that usually come up
187:44 - in google that tell you all you need to
187:46 - know about specific parts of python
187:49 - in here if you scroll down you have a
187:52 - whole list of all the methods you could
187:55 - be using
187:57 - the one you have just seen was add and
187:59 - this one adds another value
188:02 - and in here well you have a lot of
188:05 - different stuff you can work with and
188:07 - the list really isn't that long it
188:09 - should be fairly easy to work with
188:11 - now
188:12 - there's one thing
188:14 - that is quite limiting for sets and that
188:17 - is that indexing and slicing
188:21 - does not
188:22 - work
188:24 - i guess let me put these two print
188:26 - statements at the top and now i want to
188:28 - print
188:30 - my set
188:31 - and then
188:32 - the one with the index 0. if i run this
188:36 - we are getting an error and the type
188:38 - error we are getting is set object is
188:40 - not subscriptable
188:42 - which is a pythonic way of saying that
188:44 - you cannot use indexing for a set as a
188:48 - matter of fact there actually isn't a
188:51 - really easy way to pick one element from
188:54 - a set
188:55 - the one that gets closest to it is to
188:58 - use the pop method
189:00 - let me comment this one out and instead
189:03 - i want to have my set and then use the
189:06 - pop method
189:09 - if i run the code now we are getting a 1
189:12 - or the first item inside of the set
189:15 - however what this one is doing if i
189:18 - print this set
189:20 - after this operation
189:22 - the one has now disappeared
189:25 - the reason being that this pop takes the
189:28 - first item from the set returns it and
189:31 - then removes it from the set
189:33 - if you call this multiple times at some
189:35 - point your set is going to run out of
189:38 - items
189:39 - which again very often is not what you
189:42 - want to do
189:43 - sets are not designed for indexing or
189:46 - generate to pick items from them
189:49 - the actual use case is something
189:50 - entirely different i'll cover that in a
189:53 - second but first of all we could
189:55 - actually do a really interesting
189:57 - exercise just in the middle of this
190:00 - and the exercise i want you guys to try
190:03 - is to use type conversion to get one
190:05 - item from the set by index
190:07 - basically what that means is you should
190:10 - try to convert this set into another
190:13 - data type and then on this data type get
190:16 - the index
190:17 - the main thing i want you guys to take
190:19 - away from this is that you can very
190:20 - easily change the data type of something
190:22 - in python and then use different methods
190:25 - or different operations
190:27 - so see if you can figure this one out
190:32 - we know that we cannot take the index of
190:35 - a set this one just doesn't work
190:38 - however what we can do
190:40 - is get the index of a list
190:43 - so what i can do is convert my set to a
190:46 - list and then from this list i want to
190:48 - take the index
190:50 - meaning if i run this now this one is
190:52 - going to work i get the first index i
190:55 - could get the index at one
190:59 - or any other index this is now going to
191:01 - be a list that we can work with
191:03 - if i remove the indexing and show the
191:06 - entire thing that we are getting is well
191:08 - it's just a list that came from the set
191:12 - and this is also non-destructible we are
191:14 - just doing this for this one print
191:16 - statement outside of it the set is going
191:18 - to remain a set we are not changing the
191:20 - entire variable just for this one line
191:23 - we are changing the data type for a very
191:25 - specific purpose
191:27 - which is what you are going to do very
191:29 - often as a programmer
191:31 - meaning this is something you definitely
191:32 - want to get used to
191:34 - and that way you would select different
191:37 - values from a set although that really
191:40 - isn't the idea of a set
191:42 - but i guess let's talk about what the
191:44 - actual purpose of a set is in python
191:47 - and what they are supposed to do is
191:49 - being used for comparison operators sets
191:52 - are incredibly good at that
191:55 - there are a lot of ways to check if two
191:58 - sets have values in common or if they
192:00 - have different values
192:02 - for example what we could be doing is
192:03 - set one and check if there's a union
192:05 - with a set two and that way we are
192:08 - getting all of the shared elements
192:11 - another way we'll be looking at the
192:12 - intersection between two elements and
192:15 - now we only get the values that are
192:17 - present in both data sets
192:19 - there are actually quite a few more
192:22 - let's go through a couple of them
192:24 - let me add another comment for another
192:26 - section and let's call this
192:28 - comparison
192:30 - operators
192:33 - and in here to keep things a bit cleaner
192:35 - i want to have two more sets
192:37 - set one and set two that do share some
192:40 - values
192:41 - and everything else i want to comment
192:44 - out so we are not going to get confused
192:47 - what you can do
192:48 - for example the one we have seen already
192:51 - i can print set 1 and then union
192:55 - and set 2.
192:57 - if i run this now
192:58 - we essentially merged these two sets
193:01 - i suppose an operation that is a bit
193:03 - easier to see in terms of what's going
193:05 - on is the intersection method
193:10 - if i run this one we are now only
193:12 - getting 4 because 4 is the only value
193:16 - that is shared with set 1 and set 2.
193:19 - any other value disappears because they
193:22 - are not shared by the two sets
193:24 - a really good way to think about it is
193:26 - to use venn diagrams this one is set one
193:29 - this one is set to and let me draw two
193:32 - circles
193:33 - and set two would be the other circle
193:37 - what intersection is doing this one here
193:40 - is it only finds the shared values
193:42 - between the two
193:43 - union
193:45 - got
193:46 - all
193:47 - of the values
193:49 - and the third operation we could go we
193:51 - can have set one and
193:53 - the one here is difference again i want
193:57 - to check with set two and this looks
193:59 - like a typo difference this fits better
194:02 - let's run this now and there we go
194:05 - now we only get the values one two and
194:08 - three
194:09 - these three here
194:11 - we are getting this area here now where
194:14 - we only get the values that are not
194:17 - present in set 2
194:18 - which specifically here means that 4 is
194:22 - disappearing and those are the main
194:24 - comparison operators that being said
194:27 - there are a few more
194:29 - there's a different way to use these
194:31 - methods
194:32 - and those are going to look slightly
194:34 - weird for the union instead of writing
194:37 - union
194:38 - we could do set one
194:40 - then i think this is called a pipe
194:42 - operator
194:43 - and then set two
194:45 - let me comment out the other two lines
194:48 - so we're not getting confused if i run
194:51 - this now we get the exact same outcome
194:54 - along the same lines in this section
194:57 - we could replace with the and character
195:01 - so set one and set
195:04 - two
195:05 - if i run these two i am getting four we
195:08 - are only getting the values shared by
195:10 - both sets
195:12 - and finally
195:13 - difference
195:15 - we could access with set one
195:18 - minus set two and if i run this
195:21 - we are again getting the same values
195:24 - this one may look weird but it actually
195:26 - makes a lot of sense we are basically
195:30 - taking set one and we are subtracting
195:32 - all of the values from set 2.
195:35 - if they exist they are going to remove
195:37 - the value for in this case if they don't
195:39 - we're just going to ignore them
195:41 - now that being said
195:42 - these operators or sets in general
195:45 - you are not going to see all that often
195:48 - they are very rarely used
195:50 - list tuples and dictionaries are the
195:52 - really common one and sets you only
195:54 - really use when you do some more data
195:56 - oriented stuff
195:58 - all right now with that we are nearly
196:01 - done i just want you guys to do an
196:03 - exercise
196:05 - and for the exercise i have a long list
196:08 - i'm not even sure how many numbers are
196:10 - in here but there are a lot
196:12 - and what i want you guys to do is to use
196:14 - a set to figure out if this list has
196:17 - duplicate values try to figure this one
196:20 - out yourself it's a really common
196:21 - operation that is incredibly useful
196:26 - i have added a comment to explain what
196:28 - the exercise is going to be but it
196:31 - actually isn't all that difficult the
196:34 - function you want to use here is len
196:37 - and right now if i pass the list in here
196:41 - i know we have 34 items in there in
196:44 - total
196:45 - let me comment out the earlier stuff so
196:48 - we're not getting confused we have 34
196:50 - items inside of this list how we can use
196:53 - this is
196:55 - we know
196:56 - if we are creating a set
196:58 - so i want to create a set from this test
197:02 - list
197:03 - since a set cannot have any duplicate
197:05 - values
197:06 - if the length of this set is shorter
197:09 - than the length of this original list
197:11 - then we know there are going to be
197:13 - duplicates inside of this list
197:16 - which means
197:17 - if i
197:18 - run the lan method on this
197:20 - run both
197:22 - we are getting 26
197:24 - which means we have quite a few
197:26 - duplicate values in the original list
197:29 - if you want to do this a bit more fancy
197:32 - you could also do i guess let me put
197:34 - this on a separate line you could print
197:37 - len of the test list then the comparison
197:40 - operator i don't think we have seen this
197:42 - one yet but this checks if two values
197:44 - are equal to each other
197:46 - and then
197:47 - we have len of the set of the test list
197:52 - and if i run this now we are getting
197:54 - false and if this is false we know there
197:56 - are duplicate values
197:58 - with that we have all the important
198:00 - stuff for a set
198:03 - although keep in mind sets are fairly
198:06 - rare in python you would only really use
198:08 - them when you run something that
198:10 - requires a lot of data work like running
198:12 - a database or doing data analysis
198:14 - for anything else like making a gui or
198:16 - making games they really aren't used
198:19 - that often
198:20 - so don't worry too much about them for
198:22 - now when you actually need them you can
198:24 - learn about them in more detail
198:26 - the next incredibly important data type
198:29 - is a boolean
198:31 - all a boolean is is either true or false
198:35 - and usually we are creating booleans
198:38 - with comparison operators
198:40 - for example
198:41 - if we are running something like 5
198:43 - smaller than 10 we are getting the
198:45 - boolean value true
198:47 - and this is incredibly useful to control
198:49 - the flow of our code something we are
198:51 - going to talk about a lot in the next
198:53 - section for example if a condition is
198:55 - true then you want to do something
198:58 - and booleans can be created in a lot of
199:01 - different ways
199:03 - the one way we have seen already is
199:05 - we're using either integers or floats
199:07 - and then we use comparison operators
199:10 - we can also use some string methods like
199:12 - is num
199:13 - to check if there's a number inside of a
199:16 - string i think we have seen is alpha
199:18 - to check if there are only letters
199:20 - inside of a string
199:22 - another way is we can check if there are
199:24 - values inside of a list instead of
199:26 - tuples or a set or a dictionary this
199:28 - would also work
199:29 - we could also compare different sets to
199:31 - create booleans and finally we can also
199:34 - create booleans by themselves although
199:36 - that's something you really aren't going
199:38 - to do too often
199:40 - i guess let's go through this entire
199:41 - list and we're going to start with
199:43 - comparison operators and there are quite
199:46 - a few the one we have just used in the
199:48 - last part is the equal sign so we are
199:50 - checking if two values are equal with
199:53 - two equal signs and we are using two
199:55 - because a single equal sign is reserved
199:58 - to assign a data type to a variable
200:00 - meaning we couldn't use it
200:01 - and to check if two numbers are not
200:03 - equal we have the exclamation mark equal
200:06 - and that checks if two numbers are
200:08 - different
200:09 - and finally we have smaller or smaller
200:11 - equal to check if something is smaller
200:13 - than or smaller or equal than and
200:15 - greater and greater equal would work in
200:17 - the same way
200:18 - those are the main comparison operators
200:21 - in my code let me start by printing and
200:25 - i want to print if 1 is equal to 1.
200:29 - if i run this we are getting true
200:32 - if i use a different number let's say 10
200:35 - run out of this again i am getting false
200:37 - because 1 is different from 10 this
200:39 - should be quite
200:40 - obvious the next operator
200:44 - would be
200:45 - exclamation mark equal and let me add
200:48 - comments
200:49 - is not equal whereas the double equal
200:52 - sign
200:53 - looks for is equal if i run those two we
200:57 - get false and true
200:59 - false here because those two are not
201:00 - equal and we get true from this
201:02 - operation because they are indeed
201:05 - different
201:06 - i suppose a better way of writing the
201:08 - comment here would be true
201:10 - if
201:12 - is equal or is not equal
201:14 - or besides not equal is different
201:18 - we can also print if 1 is smaller than
201:22 - 10
201:23 - and this one gives us the obvious result
201:25 - because 1 is indeed smaller than 10
201:27 - and we could also use smaller or equal
201:30 - than and this one in this case would
201:32 - also be true
201:33 - i guess where this one matters if we
201:35 - have a 10
201:36 - smaller equal here is going to be true
201:38 - but 10 is not going to be smaller than
201:41 - 10 meaning this operation would return
201:43 - false
201:44 - this also works with greater than
201:46 - again this would be false because 10 is
201:48 - not greater than 10. and those are all
201:51 - the major comparison operators for
201:53 - integers
201:55 - for the next part we could look at lists
201:57 - and booleans and in here we can check if
202:00 - a value is in a list or if a value is
202:03 - not in the list
202:05 - and this by the way also works with
202:06 - strings
202:08 - an important point here is that not
202:10 - reverses a boolean
202:12 - if we have not false it is going to be
202:14 - true if we have not true it is going to
202:16 - be false
202:17 - python here works very similar compared
202:20 - to what you would use in a sentence
202:22 - and i am trying to be better with
202:24 - comments
202:26 - let's do this booleans and numbers i
202:30 - think it's a good name here
202:32 - next up we have booleans and lists and
202:36 - strings
202:38 - what you could do for example here is
202:40 - you could check if one is in the list
202:44 - one two and three
202:46 - if i run this we're getting true because
202:49 - one is indeed in the list of one two and
202:51 - three
202:52 - let me comment out this part here so
202:55 - we're not getting confused and run this
202:56 - again now we are only getting true
202:59 - and this is also going to work with
203:00 - different data types
203:02 - if i for example had a tuple
203:06 - and run this again we would have the
203:08 - very same outcome if i duplicate all of
203:10 - this i can also check if e
203:14 - is in the word hello
203:17 - and run this again and we will be
203:19 - getting true again because e is indeed
203:22 - in the word hello
203:23 - finally what you can also do is to use
203:25 - the not operator
203:27 - for example you could be checking if 4
203:30 - is not in
203:31 - the list of 1 2 and 3.
203:34 - if i run this one now we're getting true
203:37 - again because 4 is indeed not in this
203:40 - list
203:41 - generally not reverses all of these
203:44 - operations
203:46 - i could for example uncomment
203:48 - this print 10 is greater than 10 and
203:51 - this one
203:52 - let me keep it the only one without a
203:55 - comment
203:56 - if i just had this one line by default
203:58 - this one is going to be false
204:00 - but if i put a not in front of it
204:04 - and run this again we are now getting
204:06 - true
204:07 - not reverses any kind of boolean so if
204:11 - you have not true you are going to get
204:12 - false you can actually do this by itself
204:16 - let me add another comment and
204:18 - let's call it booleans by themselves
204:22 - and comment out everything else what you
204:25 - could do
204:26 - you could just create a boolean by just
204:28 - writing true
204:30 - or false if you wanted to and this one
204:33 - would get you true which is its own data
204:35 - type and if you write not true
204:38 - you would get false this i think is
204:41 - going to make sense
204:42 - and i guess while we are here
204:46 - we can do another data conversion
204:47 - exercise
204:49 - so data conversion
204:52 - exercise
204:55 - and what i want you guys to do
204:57 - here are the notes i have an e
205:00 - and this one contains three key value
205:02 - pairs
205:03 - it's always the integer of a number and
205:05 - then the word of the number as well
205:08 - although honestly it really doesn't
205:10 - matter what the specific value here is
205:13 - and i want you guys to do two things
205:15 - number one check if one of these keys
205:17 - exists specifically if this key one
205:20 - exists just assume you don't know what's
205:23 - inside of the dictionary and you want to
205:24 - check if this key exists in the first
205:26 - place
205:27 - and number two i want you guys to check
205:30 - if the value not the key the value for
205:34 - exists inside of the dictionary and
205:36 - again assume you don't know the actual
205:38 - content of the dictionary
205:40 - so try to figure out these two problems
205:45 - the first problem i guess let me put it
205:48 - right below is the easier one
205:50 - we want to check for a specific key
205:53 - and in here we can use the same thing we
205:55 - have used up here it works in the same
205:57 - way i can just check if one exists
206:00 - inside of the e-dictionary
206:03 - and let me comment out
206:05 - this print statement down here so we're
206:07 - not getting confused if i run this now
206:10 - we're getting true because we can see it
206:13 - right here
206:14 - this one does exist inside of the
206:16 - dictionary as a key
206:19 - if you want to be more specific about it
206:21 - you could also use the method dot keys
206:24 - and you would get the same result
206:26 - this edict.keys would now return
206:29 - something that looks like a list with
206:31 - only the keys inside of it
206:34 - although this is what you get by default
206:36 - anyway so you don't really have to use
206:38 - it
206:39 - the second part
206:40 - is we want to check if the value 4
206:44 - is in the e dictionary
206:48 - although this right now is not going to
206:50 - work because this edict is checking for
206:53 - keys not for values which wouldn't help
206:56 - us all that much
206:58 - to access the values we would need the
207:01 - values method the one we learned about
207:03 - earlier and now we're getting something
207:05 - that is basically a list and it only
207:08 - contains all of the values of the
207:10 - dictionary
207:11 - if i run this now we're getting false
207:13 - because we know this 4 does not exist as
207:16 - a value inside of this e dictionary
207:19 - although if we had a 3
207:21 - this one would be true
207:23 - so we know it is working all right with
207:26 - that
207:27 - there's one more really important topic
207:29 - i want to cover and that is the bool
207:32 - function let's talk about this one bool
207:35 - is a function that creates a boolean
207:37 - data type and this one can accept
207:40 - basically any kind of other data type
207:43 - it's really flexible here we could pass
207:45 - a number a string any type of container
207:48 - and we would still get a value
207:50 - as a matter of fact
207:52 - bool accepts so many different values
207:54 - that are actually different rules that
207:56 - determine how the values are going to be
207:59 - converted
208:00 - and just think about the problem here
208:02 - you have some really complex data set
208:04 - let's say a really long word and you
208:07 - pass this into the boolean function to
208:09 - ever get true or false
208:11 - how is python going to determine what
208:13 - values count is true and what values
208:15 - count as false and the logic here is
208:18 - actually so common that python has
208:20 - dedicated words for it we have the words
208:23 - truthy and fault c
208:25 - truffy means all the values that will be
208:27 - converted to true and false c is all the
208:29 - values that will be converted to false
208:32 - the way you have to think about it is
208:34 - that some values will always be
208:36 - converted to false and those are fairly
208:38 - specific and anything else will always
208:41 - be true
208:42 - and faulty values are
208:44 - 0 or 0.0 so integers or floats that have
208:48 - the value 0 any positive or negative
208:51 - number will become true
208:54 - any kind of empty string so a string
208:57 - without any content not even a space
209:00 - any kind of empty list tuple set or
209:02 - dictionary is also going to become false
209:05 - and finally none so the absence of a
209:07 - value
209:09 - and literally any other value is going
209:12 - to become true
209:15 - meaning you don't actually have to learn
209:17 - that much
209:18 - now this is something we definitely want
209:20 - to play around with so let's have a look
209:22 - at all of this in code let me comment
209:24 - out all of the stuff we have written
209:26 - earlier
209:27 - so things are not getting confusing
209:30 - right
209:31 - the bull function
209:32 - is another function that creates a
209:35 - boolean data type and i do want to print
209:38 - the result
209:40 - we could for example add in a number any
209:42 - kind of number
209:44 - and we will get true
209:47 - what python basically does is it looks
209:49 - at a number and then determines if the
209:51 - value is truthy or falsey if it is
209:53 - truthy we get true if it is falsy we're
209:56 - getting false
209:57 - and what i talked about just now is that
209:59 - any number besides zero will be true
210:02 - this one here indeed has become true
210:04 - this would also work with negative
210:06 - numbers let's say negative one
210:08 - is also true
210:10 - the only time a number becomes false is
210:14 - when you have zero this one is false or
210:17 - 0.0 this one is also false as soon as
210:21 - you have any other value besides zero
210:23 - let's say zero point a lot of zeros and
210:25 - one
210:26 - you are getting true again
210:28 - but if you have any floating point with
210:30 - just zeros it is going to be false
210:33 - and this was the first rule
210:35 - besides that for strings
210:38 - if you have any kind of word even if
210:40 - it's just a space
210:41 - it is going to be true
210:43 - however
210:44 - if you have an empty string this one is
210:46 - going to be false
210:48 - finally
210:49 - if you have an empty list
210:51 - this one is also going to be false but
210:53 - if you have any kind of value inside it
210:56 - is going to be true the way you want to
210:59 - think about it is that if any kind of
211:01 - data type has an actual value then it is
211:03 - going to be converted to true if it
211:06 - doesn't have any content it is going to
211:08 - be false
211:09 - there's one more data type we haven't
211:11 - really covered yet in detail and that is
211:14 - the absence of a value so none
211:16 - and this by itself is also data type in
211:18 - python
211:19 - and this one obviously is also going to
211:21 - become false i think this one makes
211:23 - sense
211:24 - we are actually going to talk about this
211:25 - in just a second in a bit more detail
211:27 - but it's not something you have to worry
211:29 - about too much
211:30 - but well with that we have boolean data
211:33 - types that's kind of all you need to
211:35 - know and in the next section we are
211:37 - going to use this a lot more
211:39 - before we are finishing off this entire
211:41 - section i want to cover some other data
211:44 - types because python does have a lot
211:47 - what we have seen so far is that python
211:50 - is really flexible with data types
211:52 - sometimes data is even converted
211:54 - automatically like with integers and
211:56 - floating point numbers
211:58 - but other than that we also have
212:00 - functions to change data types
212:03 - and this is the entire list for the
212:05 - major data types you would most of the
212:08 - time actually need
212:10 - and these are very forgiving python here
212:13 - again is super flexible
212:15 - now besides those we do have a couple of
212:17 - data types you see once in a while but
212:20 - not very often or in other words data
212:23 - types you don't specifically use
212:26 - the most common one here is none or the
212:28 - absence of a value
212:31 - this could for example happen if a
212:33 - certain kind of value got deleted or if
212:36 - you didn't get value from some kind of
212:37 - input field
212:39 - but besides that we also have a sequence
212:41 - like a range of numbers
212:43 - bytes complex numbers memory view frozen
212:45 - sets
212:46 - lots of really specific data types that
212:48 - you sometimes see in very specific
212:51 - circumstances
212:53 - you usually have to look them up and
212:54 - they are very rare so i am not going to
212:56 - cover them
212:58 - i will however cover later on none and
213:01 - sequence
213:02 - those you do see reasonably often
213:05 - but values like bytes
213:08 - complex numbers memory view frozen sets
213:11 - you would only ever use in highly
213:13 - specific circumstances and i'm not going
213:15 - to cover them because we don't really
213:17 - need them
213:18 - almost the entire time
213:20 - you are going to be perfectly happy with
213:23 - these
213:24 - data types here and they are what i am
213:27 - going to focus on
213:29 - so right with that we can come to the
213:31 - next major section
213:32 - and welcome back in this section we are
213:36 - going to work with the flow of our code
213:38 - now what does that mean
213:40 - basically so far we always executed code
213:43 - from the start to the finish meaning if
213:46 - these are different lines of code
213:49 - we are starting all the way at the top
213:51 - and we are going down line by line
213:54 - which works fine by itself but it is
213:57 - fairly limiting
213:58 - because sometimes we want to do
214:00 - something else
214:01 - for example we might only want to run
214:04 - code if a certain condition is true or
214:06 - we might want to run code multiple times
214:09 - or we might want to run code for every
214:11 - item inside of a list or a tuple or
214:13 - something like that
214:15 - and all of these things can be done
214:16 - quite easily
214:18 - python has a lot of ways to control the
214:20 - flow of your code
214:22 - although to understand how it is going
214:24 - to work we need to understand one really
214:27 - important concept
214:29 - and that is how python groups chunks of
214:32 - code together
214:34 - you're going to see in a second why that
214:36 - is important but the way python groups
214:39 - code together is by using indentation
214:43 - let's say we only want to run some code
214:46 - if the condition is true
214:48 - and this white line here is the left
214:50 - side of our code editor just to better
214:52 - illustrate how we are using indentation
214:56 - the basic problem we have now is if we
214:59 - have code below this condition
215:02 - how do we tell python that it belongs to
215:04 - the condition and isn't something that's
215:06 - independent of the condition
215:09 - for that we need indentation anything
215:12 - that is indented by one indentation
215:14 - after this line belongs to this if
215:17 - condition meaning these three lines here
215:21 - all belong to this if condition i think
215:24 - i actually added a bit more text here
215:26 - yeah there we go indentation determines
215:28 - where the code belongs to
215:30 - if we added some other code in here like
215:32 - line three and line four
215:34 - those would be independent of each other
215:37 - they would run
215:38 - no matter what happens whereas
215:41 - line 1 line 2 and line 3 would only run
215:45 - if this condition is true if it was
215:47 - false
215:49 - then none of this would be run but line
215:51 - 4 and line 5 would still run
215:54 - meaning lines that are not indented do
215:56 - not belong to that if statement
215:59 - i hope this makes sense once you
216:01 - understand the system it makes a lot of
216:02 - sense
216:04 - and indentations indentations in general
216:06 - and python are incredibly important you
216:09 - are going to see them all the time
216:12 - but first of all
216:14 - once we understand indentation there are
216:16 - four major ways to determine the flow of
216:18 - the code the first one is if l if and
216:22 - else these are different kind of if
216:24 - conditions to run code if certain
216:26 - conditions are true
216:29 - we are going to talk about this one in
216:30 - the next part besides that we have match
216:34 - this one is kind of like if but it's
216:36 - more designed for specific value to find
216:38 - one very specific condition
216:42 - then we have while and this one just
216:44 - repeats code as long as the certain
216:46 - condition is true
216:47 - and finally
216:48 - we have four and this one is about
216:50 - running some code for every item inside
216:53 - of a container let's say you have a list
216:56 - with
216:58 - one two and three
217:00 - and you want to run some code for every
217:02 - item inside of the list a for loop for
217:05 - that would be perfect
217:07 - and those are the four major concepts
217:09 - that we are going to learn there are
217:11 - also a few more extra tools you can use
217:13 - like breaking a certain kind of
217:15 - statement or skipping to a next part in
217:18 - a while loop
217:19 - i will talk about those at the
217:20 - appropriate point
217:23 - so i guess with that let's start with
217:25 - the first major part
217:27 - possibly the most important concept to
217:29 - determine the flow of your code is the
217:31 - if statement all this one does is it
217:34 - tells python to only run some code if a
217:36 - certain condition is true
217:38 - note here we are always looking for a
217:41 - boolean value
217:43 - they are crucial to make all of this
217:45 - work
217:46 - and an if statement can also be extended
217:48 - with l if and else
217:50 - and you can also add different
217:52 - conditions together we're gonna cover
217:54 - all of this in quite a bit more detail
217:56 - over the next two videos
217:58 - let's have a look at all of this in code
218:00 - let's do a super quick recap of boolean
218:03 - values all i really do is if i have
218:06 - something like 10 is greater than 5 i
218:08 - print it i'm getting true because this
218:11 - condition is indeed true
218:13 - and if i do the other way around that 10
218:15 - is smaller than 5 this would get me
218:18 - false because this condition is not
218:20 - correct
218:21 - and these boolean values we can now use
218:23 - to control the flow of our code for
218:25 - example we could run some code if a
218:30 - value in a variable
218:33 - is greater than let's say 10. for that
218:37 - let me first of all create a variable
218:39 - let me call it x and let's start with
218:41 - five
218:42 - and now i want to run some code only if
218:45 - this value is greater than 10.
218:48 - and for that i would need the word if
218:51 - and then the condition i want to check
218:53 - which in my case is x
218:56 - is greater than 10.
218:58 - after that i need a colon and now if i
219:01 - press enter
219:02 - sublime is very intelligent here and
219:05 - already creates one level of indentation
219:08 - so we are here if i write some code
219:12 - and this is really important
219:15 - let me write some code here actually
219:17 - let's say print
219:19 - the if statement was true
219:24 - because of this indentation we know that
219:27 - this print statement belongs
219:29 - to this if statement here if i execute
219:33 - all of this we can see nothing the
219:36 - reason why we can't see anything
219:38 - is that this condition here was not true
219:41 - 5 is not greater than 10 but if i change
219:44 - this 5 to a 15
219:46 - run all of this again
219:48 - now we can see
219:49 - this print statement here
219:52 - the main thing that you have to
219:53 - understand here is this condition
219:56 - if it becomes true
220:00 - then we are running all the indented
220:02 - parts below the if statement and if it
220:05 - is false we're not running any of the
220:07 - indented parts
220:10 - this would also work over multiple lines
220:11 - of code i could for example print
220:15 - another line
220:16 - if i run this again we get another line
220:18 - as well i could also create another
220:21 - variable in here let me call it y is
220:23 - equal to 10
220:25 - and i could print
220:27 - y all of this works just fine we can
220:30 - write any kind of code in here as long
220:32 - as it's indented it always belongs to
220:34 - this if statement
220:36 - however
220:37 - if i write now
220:39 - some other line of code after the if
220:41 - statement that is not indented
220:43 - let me call it some other code
220:47 - this one
220:48 - is always going to run regardless of
220:50 - what the if statement does because it's
220:52 - not indented
220:54 - if i run the entire code right now we
220:56 - can see some other code the line we get
220:59 - here and if i
221:01 - return x back to 5 run this again
221:04 - we now can still see some other code
221:07 - because this line is not affected by the
221:10 - if statement because again of the
221:12 - indentation indentation is really
221:15 - important to python you absolutely have
221:17 - to understand it
221:19 - although that being said this is the
221:22 - core part of an if statement it really
221:24 - isn't that complex
221:26 - although you can extend the logic here
221:29 - in two different ways a very easy one
221:32 - would be an else statement
221:34 - this one again is going to need a colon
221:37 - and now if i press enter again we have
221:40 - another indentation and in here i can
221:43 - write
221:45 - the code
221:46 - that was run
221:48 - if
221:49 - the statement was
221:52 - false
221:54 - how does this work
221:55 - basically
221:57 - this else statement always has to be
221:59 - connected to an if statement
222:03 - and what it does is if this condition
222:06 - here is false then we are not running
222:08 - any of this but we are running anything
222:11 - inside of the else statement
222:14 - since x is 5 this condition is going to
222:17 - be false meaning none of this will run
222:20 - but this one here should be run
222:23 - and this line is going to run no matter
222:25 - what happens so if i run the code i
222:28 - should be seeing the output of this line
222:30 - and of this line
222:31 - let's try it
222:33 - and there indeed we can see these two
222:36 - lines
222:37 - and there's one more thing that you can
222:39 - do
222:40 - and that is called an l
222:42 - if statement
222:45 - and again this elf statement has to be
222:47 - connected to an if statement
222:50 - basically what it means is shorthand for
222:53 - else if
222:55 - it's kind of similar to the else
222:57 - statement except now we are adding a
222:59 - condition which means if
223:02 - this condition here
223:04 - is false
223:05 - then we want to run
223:07 - this statement here but we only want to
223:09 - run this one if another condition is
223:13 - true
223:14 - and this condition is just going to be
223:17 - another boolean value
223:19 - let's say i want to check x again
223:23 - and i want to check if x is different
223:27 - from 0.
223:29 - if that is the case i once more need
223:31 - some indented code
223:33 - and for this one let me print
223:36 - the l if statement was
223:39 - correct
223:40 - and now we have a much more complex if
223:43 - statement we first check if this
223:46 - condition here is true
223:48 - which in our case right now is going to
223:50 - be false because 5 is smaller than 10
223:54 - meaning this would be a false statement
223:57 - then we are coming to the al if
223:59 - statement and now we are checking if let
224:02 - me use a different color if x is
224:05 - different from zero and since five is
224:08 - different from zero this one is going to
224:10 - be true
224:12 - as a consequence we are going to run or
224:14 - expect this code here to be run let me
224:18 - add it properly here so we can see
224:20 - what's inside of the line
224:22 - and once any of these lf statement has
224:24 - run we are stopping this if statement
224:27 - meaning this else statement here would
224:30 - not be run at all
224:31 - and once again this print statement here
224:34 - is going to be happy either way because
224:36 - it does not care what happens in this
224:39 - entire thing
224:40 - let's try all of this now and we can see
224:42 - the al if statement was correct which is
224:44 - this line here and then we have some
224:46 - other code this bit here i suppose we
224:50 - could be doing another example and now
224:52 - let me add a zero in here and i would
224:55 - really recommend you to go over this one
224:57 - yourself and see
225:00 - which line
225:01 - you would expect to run here
225:04 - once again we are starting at the first
225:06 - line and we know 0 greater than 10 is
225:10 - going to be false that can never be true
225:13 - next up we are looking at x being
225:16 - different from 0 which in this case is
225:19 - also going to be false
225:21 - which means at the end we are left with
225:23 - this else statement
225:26 - which means the code we are expecting is
225:28 - the code that was run in the if
225:30 - statement was false
225:32 - and we're also expecting this one at the
225:34 - end although that's getting repetitive
225:36 - let me run the code now
225:38 - and we get the code that was run if the
225:40 - if statement was false and some other
225:42 - code
225:43 - with that we have all the basics for an
225:46 - if statement if you understand if l if
225:48 - and else you already understand what you
225:51 - need
225:52 - i guess one more thing that i haven't
225:53 - covered yet
225:54 - is if and else
225:57 - can only occur once inside of this if
225:59 - statement but l if
226:02 - you can multiply as many times as you
226:05 - want
226:06 - for example i could add x is greater
226:08 - than negative 20 for example
226:11 - and then add something else i know print
226:13 - something
226:14 - else
226:17 - and you could add as many if statements
226:19 - as you want or as you need
226:22 - but else and if can only occur once
226:26 - although what you could be doing is add
226:29 - another if statement afterwards
226:31 - i guess we could add if
226:33 - one in the list one two and three
226:38 - and then we want to print
226:40 - another if statement
226:44 - when i said an if statement or an else
226:46 - statement can only occur once i was
226:48 - always referring to this
226:50 - block here
226:52 - where we are starting with an if and
226:54 - inside of that we can only have one else
226:56 - we couldn't have a second else however
226:58 - python is totally happy to have a
227:00 - completely separate if statement
227:03 - but with that we can do an exercise
227:07 - and what i want you guys to do is this
227:10 - one here
227:11 - we have one variable that determines how
227:14 - much money we have
227:15 - and from this amount of money i want you
227:17 - guys to figure out what we are going to
227:19 - eat
227:20 - if we have greater or equal than 80
227:23 - units of money i want you guys to print
227:26 - eat something fancy
227:28 - if the money is greater than 45 eat
227:30 - something nice if it is greater than 15
227:32 - eat something okay
227:34 - and else eat something cheap
227:36 - and obviously there should only ever be
227:38 - one print statement running at any point
227:40 - in time
227:41 - so pause the video now and try this one
227:43 - yourself
227:47 - before we start i want to comment out
227:50 - all of this because it would otherwise
227:52 - get kind of confusing first of all
227:55 - we need an if statement and now i want
227:57 - to check the money available
228:00 - and i want to work on the first line
228:02 - here
228:02 - and what we are being asked to do is
228:05 - greater or equal than 80
228:08 - which we get with greater or equal and
228:11 - we want to check for 80. if you want a
228:14 - reminder on boolean values check out the
228:16 - last section on boolean data types this
228:19 - is going to be really important for this
228:21 - entire section
228:23 - but in here i now need a colon and now i
228:26 - want to print eat something fancy
228:31 - i guess let's add an exclamation mark
228:32 - because why not
228:34 - the really important part here this
228:36 - print statement has to be indented
228:38 - but with that we have covered the first
228:40 - line of the exercise
228:42 - next up we want to check if the money is
228:45 - greater than 45
228:47 - which means we want to first check if
228:50 - the money is greater than 80 but if that
228:53 - is not the case and the money is still
228:55 - greater than 45 we want to do something
228:58 - else which means we need an l if
229:01 - statement else
229:03 - because we want something else in the if
229:04 - statement and if because we have another
229:07 - condition
229:08 - what i want to check in here if the
229:10 - money available is greater than 45 after
229:13 - that again i need a colon
229:16 - i need an indented line and now i want
229:18 - to print
229:19 - eat something nice
229:22 - and with that we have covered this line
229:24 - here
229:25 - next up we have a very similar line
229:28 - meaning now we again need l if
229:31 - and what i want to check now if the
229:33 - money available is greater than 15.
229:37 - if that is the case this is getting a
229:38 - bit repetitive i want to print it
229:41 - something
229:42 - okay
229:44 - that covers this line and finally we
229:46 - have an else statement
229:48 - that if all of these conditions are
229:50 - false we want to do something else
229:54 - anything else we want to do is to print
229:57 - eat something cheap
230:00 - and there we go this is going to cover
230:02 - all of the four if statements if i run
230:05 - this now we get each something fancy
230:08 - because the first if statement
230:11 - this one here
230:12 - is true
230:14 - however if i change this 100 to let's
230:17 - say 50
230:19 - we get eat something nice
230:21 - if i change it to 20
230:23 - we get eat something okay and if i
230:26 - change it to 5
230:28 - we get eat something cheap
230:30 - and with that we have basic if
230:32 - statements
230:34 - now that we have learned about basic if
230:36 - statements we can work on the more
230:38 - complex ones because if statements can
230:41 - be extended
230:43 - number one is you can combine different
230:45 - conditions inside of one if statement on
230:48 - the same line
230:49 - and number two is you can nest one if
230:52 - statement inside of another if statement
230:55 - which lets you create really complex
230:57 - systems that check different values
230:59 - let's start with combining conditions
231:02 - and in here the two keywords we need are
231:04 - and and or
231:06 - kind of confusing to say but you get the
231:08 - idea
231:10 - how this would look like is we have if 5
231:13 - is smaller than 1 and e in hello or 10
231:17 - is different from 4.
231:19 - this may look confusing
231:21 - but let's go through it one by one to
231:23 - understand how this works we have to
231:25 - understand and and or
231:27 - and means that all the parts have to be
231:31 - true
231:31 - meaning when we are talking about this
231:33 - and here
231:35 - this bit in particular
231:38 - both of these conditions five is more
231:40 - than one and e and hello have to be true
231:43 - individually
231:44 - for this entire statement here to return
231:48 - true as a whole whereas or works in the
231:51 - opposite way where only one or a
231:54 - statement has to be true which means if
231:57 - this or statement here is true then it
232:00 - wouldn't matter if all of this is false
232:02 - because as long as one or statement is
232:05 - true
232:05 - then the entire if statement
232:08 - is going to return true as a whole
232:11 - and this is probably going to sound very
232:13 - confusing so let's do this a bit more
232:15 - practically
232:17 - let's do this actually in the simplest
232:18 - possible way let's say i have if true
232:22 - and i want to print
232:25 - true
232:26 - this if statement here
232:28 - really doesn't make too much sense but
232:30 - to illustrate the point it's really
232:32 - useful
232:33 - but since we're adding the boolean value
232:35 - true in this if statement this is always
232:37 - going to run meaning if i execute the
232:39 - code we are getting true and now what we
232:43 - can do is use and in here and if i add
232:47 - false now and run this again
232:50 - nothing is going to happen this line
232:52 - will not be executed because of and
232:56 - both the first one this one here and the
232:59 - second one have to be true for this
233:01 - entire condition to be true as a whole
233:04 - which there aren't right now
233:07 - but if it was true
233:09 - then this would run again
233:12 - the way you have to think about and is
233:14 - i'm only going to run this if statement
233:17 - if this is true and this is true and
233:20 - anything else is true and if any single
233:22 - statement is false then the entire thing
233:25 - is not going to be run
233:27 - i hope that makes sense it does take
233:29 - some time to get used to it let me go
233:31 - back to false
233:33 - and the other word we can use is or now
233:36 - we want to run this line of code if this
233:39 - is true or this is true meaning if
233:42 - either of these is true then the entire
233:45 - if statement is going to run if i run
233:48 - this now this is going to be true
233:50 - because for or only one of them has to
233:53 - be true
233:54 - and once you get so far you can combine
233:57 - and and or for example what i can do is
234:00 - true and true and true or true
234:04 - now this
234:06 - would obviously return true as a whole
234:09 - because we only have true values in here
234:12 - but now if i set this to false
234:14 - this would still run
234:17 - and the reason is let me add a bit of
234:19 - white space around it so i have more
234:21 - space to draw on i am assuming that this
234:24 - is kind of confusing right now still
234:26 - python essentially combines all of the n
234:29 - statements into one block inside of the
234:32 - if statement and this entire block can
234:34 - either be true or false
234:37 - for and every single value has to be
234:40 - true and if a single value is false then
234:43 - the entire thing is going to be false in
234:46 - our case since there is one fault
234:48 - statement
234:50 - the entire block here is going to be
234:53 - false
234:54 - once we have that python is looking at
234:56 - the or statement this bit here and as a
235:00 - consequence of this we now have false
235:03 - from all of the and statements and then
235:05 - we are checking false or true and if
235:08 - either of these are true then the entire
235:10 - if statement is going to be true which
235:12 - in this case it is
235:14 - just to make sure let's do one exercise
235:17 - for this one already
235:18 - and what i want you guys to do
235:21 - is here we have three variables and the
235:24 - exercise is going to be fairly similar
235:26 - compared to what we have done in the
235:27 - last video
235:29 - what you should be working on
235:30 - is another if statement that checks if
235:32 - the money available is greater than 80
235:34 - and if you are hungry if those two
235:37 - conditions are true print eat something
235:39 - fancy or whatever you want however this
235:43 - should also run if board is true
235:46 - and for that to work you have to combine
235:48 - end and or statements so pause the video
235:51 - now and try to figure this one out
235:57 - to get started i need an if statement
236:00 - once again and now i want to check if
236:02 - money available
236:03 - is greater than 80.
236:06 - this covers this first bit
236:09 - on top of that i also want to check the
236:12 - end
236:14 - if hungry
236:16 - is equal to
236:17 - true
236:19 - with that i have covered this entire bit
236:23 - now that i have that
236:24 - i can print
236:27 - eat something
236:30 - fancy
236:32 - if i run this now
236:34 - this is going to return eat something
236:37 - fancy let me comment out this stuff at
236:39 - the top so we're not getting confused
236:41 - eat something fancy
236:43 - if i change hungry to false
236:45 - run this again we are not getting
236:47 - anything
236:49 - the simple reason being
236:50 - that both of these statements have to be
236:54 - true
236:55 - because of the end
236:57 - statement here if either of these is
237:00 - false then
237:02 - the entire thing is going to return
237:06 - false
237:07 - which it does right now so none of this
237:09 - is going to be run
237:11 - however now what we can do
237:14 - is use an or statement as well to cover
237:17 - the last bit or if bored
237:21 - and now i want to check our board equals
237:24 - to true as well
237:26 - if we run all of this now
237:28 - we get eat something fancy and what
237:31 - happened here is python first checks
237:34 - the two statements connected by and
237:39 - and it sees that money available is 100
237:42 - which indeed is greater than 80 meaning
237:44 - this part here is going to be true
237:47 - but then for hungary equals true it
237:50 - looks at the hungry variable and this
237:52 - one is false
237:53 - meaning this one is going to return
237:56 - false
237:58 - as a consequence
238:00 - the entire bit here
238:02 - is going to give us a big false
238:06 - the difference now is we are also
238:08 - checking this or statement which means
238:12 - we want to check if anything in here is
238:15 - true
238:16 - or if this condition is true which it
238:19 - actually is right now
238:22 - and as a consequence
238:23 - the entire thing combined is going to
238:26 - return
238:28 - true consequence being we are going to
238:31 - run this line of code
238:33 - and i hope this makes sense using these
238:36 - and or keywords can be a bit confusing
238:39 - definitely play around with this in your
238:40 - own time if you're struggling
238:42 - that being said most of the time you are
238:45 - going to keep this fairly simple
238:47 - you usually only have a single and
238:50 - statement in here and then you are good
238:51 - to go
238:53 - don't overthink this
238:55 - the other way to make if statements more
238:57 - complex is by nesting them
238:59 - and let me do an example
239:02 - we could have an if statement if a is
239:04 - inside of the list a and b
239:06 - right now this one would be true but
239:08 - inside of this we can add another if
239:11 - statement that is indented by one line
239:14 - and inside of that we could even add
239:16 - another if statement and this system we
239:18 - could continue forever as long as we
239:21 - keep on adding more indentation levels
239:23 - let's have a look at this one in a bit
239:25 - more detail
239:27 - i'm going to comment out the stuff we
239:29 - have done earlier i guess i could
239:31 - organize it a tiny bit better there we
239:32 - go
239:34 - and now i will look at nested if
239:37 - statements
239:39 - and to keep comments a bit more
239:41 - consistent let me add one for the first
239:43 - part
239:44 - let's call it combining conditions
239:47 - the example we have just seen is we want
239:49 - to check if the letter a
239:52 - is in the list a
239:54 - and
239:55 - b
239:56 - if that is the case
239:58 - i let's say i want to print
240:01 - a is in
240:03 - the list
240:05 - executing the code is going to print
240:07 - this line this one should be fairly
240:09 - straightforward
240:11 - and again remember we are on one level
240:14 - of indentation on this line of
240:16 - indentation though we could add another
240:18 - if statement
240:20 - we could for example check
240:22 - if
240:23 - a
240:25 - and then use the method
240:31 - then i need a colon again and now i need
240:33 - another indentation line or another
240:35 - level of indentation
240:37 - and then here let me print
240:40 - it is a
240:41 - letter
240:42 - if i run this now
240:44 - i get a is in the list and it is a
240:47 - letter
240:48 - now this example really doesn't make too
240:51 - much sense but we can make it quite a
240:53 - bit more interesting for example what
240:56 - you could be doing is create a variable
240:59 - and in this right now i want to have
241:02 - let's say the string a
241:04 - and now i want to check if x is inside
241:07 - of this list and i want to check x is
241:10 - alpha
241:11 - if i run this again we are going to get
241:13 - the same result we essentially just
241:15 - replaced the string a with a variable
241:18 - that contains the same string
241:20 - but once we have that i could add
241:23 - another string in here that contains a 1
241:26 - which is not in the alphabet
241:28 - so if i check this one here what i
241:32 - expect now to happen is that this is
241:34 - still going to be inside of the list so
241:37 - this entire condition should be true
241:40 - as a consequence this print statement
241:42 - should run
241:43 - however
241:44 - the number one
241:46 - even if it's inside of a string is not
241:48 - in the alphabet
241:49 - so this condition should not be true
241:53 - and if i run this we can indeed only see
241:56 - this line here was run but this was
241:58 - false and as a consequence this line
242:00 - here was not executed
242:03 - if you wanted to you could even add
242:05 - another level of indentation
242:07 - i don't know let me just add true so we
242:09 - always execute it and inside of that you
242:11 - could keep on adding more if statements
242:14 - there's absolutely no limitation on how
242:16 - many if statements you can add the only
242:18 - thing you really have to consider here
242:20 - is that each if statement has to be on a
242:22 - separate level of indentation
242:24 - at the very least if you want them to be
242:26 - part of the other if statement
242:29 - if you added
242:30 - an if statement here
242:32 - let me get rid of this one
242:35 - you would check those two individually
242:38 - the way you want to think about it is
242:40 - that each if statement is one block of
242:42 - code this if statement here is one block
242:46 - inside of this if statement we have one
242:48 - block for this if statement and another
242:50 - block for this if statement
242:53 - and these two here are independent of
242:55 - each other but they both depend on this
242:58 - if statement to run if this if statement
243:00 - does not run neither of those will run
243:04 - just to have something in here let me
243:05 - print
243:06 - something
243:08 - and let me add some purple white space
243:10 - so this looks a bit cleaner all right
243:12 - with that we can do another exercise and
243:14 - then finish this part
243:17 - what i want you guys to do let me copy
243:19 - it from up here
243:22 - i want you guys to check these three
243:25 - conditions but now instead of using
243:28 - this system here
243:30 - i want you guys to create a nested if
243:32 - statement
243:34 - and if all three conditions are true so
243:36 - you have enough money you are hungry and
243:39 - you are bored
243:40 - then i want you guys to print eat
243:42 - something fancy or really whatever you
243:44 - want it doesn't matter that much
243:47 - let me actually uncomment them and add a
243:50 - comment for the exercise and now pause
243:53 - the video and do this one yourself
243:58 - let's start with money available is
244:01 - greater than 80. that's the one we have
244:03 - already
244:04 - used and
244:06 - i guess while we are here i can also
244:08 - print something to check on what if
244:11 - statement we are for this one i want to
244:13 - print i have
244:15 - enough
244:16 - money
244:19 - after that
244:20 - i want to check the next if statement
244:23 - and i just want to check if hungary is
244:26 - equal to true
244:28 - and if that the case i can print
244:32 - and i am hungry
244:36 - inside of that
244:38 - i want to check if board is equal to
244:40 - true and if that the case i want to
244:43 - print the final thing eat
244:46 - something
244:47 - fancy
244:49 - before i run it i do want to comment out
244:52 - this part here so we keep things a bit
244:55 - cleaner if i run this now we only get up
244:58 - to i have enough money this line here
245:01 - we are not getting to if hungry because
245:04 - hungry is false
245:06 - if i said this hungry too true
245:10 - we get let me expand this a tiny bit
245:13 - i have enough money i am hungry
245:16 - and eat something fancy all three
245:18 - conditions here are true
245:20 - and with that we have if statements
245:23 - obviously you could also add else
245:25 - statements in here if you really wanted
245:27 - to and make this even more complex
245:30 - now there's one more thing that i want
245:31 - to cover really quick
245:33 - writing something like this is a bit
245:36 - redundant
245:37 - all you really need
245:38 - is hungry by itself if i run this it
245:41 - would still work
245:43 - what happens here is that python
245:46 - looks at the hungry variable and the
245:48 - value for hungry is true meaning this if
245:51 - statement here is essentially if true
245:55 - and keeping like this is much more
245:57 - readable
245:58 - if a value is truthy you could just add
246:00 - it in here and then python would take
246:02 - care of the rest for you
246:04 - but being more explicit about it would
246:06 - also still work perfectly fine but
246:08 - alright with that we have if statements
246:10 - covered in this part we're going to
246:12 - cover the match case statement
246:15 - and this one is kind of similar to an if
246:17 - statement the major difference is
246:20 - you still run some code if a certain
246:22 - condition is true
246:25 - but match case is more designed to check
246:28 - for one specific value out of a long
246:31 - list of possible values
246:33 - that probably doesn't mean too much
246:34 - let's do an example
246:36 - let's say you want to check the mood of
246:39 - something if you used an if statement it
246:42 - might look something like this we have
246:43 - if hungry you want to run some code and
246:46 - else if you're tired or bored you want
246:48 - to run some other code
246:50 - all of this would be just fine but it
246:52 - also feels kind of inefficient having
246:55 - one l if statement for each mood seems
246:59 - kind of annoying to write every single
247:01 - time
247:02 - and as a consequence python has a
247:04 - slightly different way to approach this
247:06 - kind of case and this is a match case
247:09 - you would use the match keyboard and
247:12 - then you would look at the variable in
247:13 - this case i am looking at the mood
247:16 - and then you can specify different kinds
247:18 - of cases for example case for hungary
247:22 - and if that is the case we have colons
247:24 - again and we are running some code
247:26 - inside of it and then we can check for
247:28 - different cases and run some code for
247:31 - all the different possibilities
247:33 - it is very very similar to an if
247:36 - statement
247:37 - if you compare the two
247:39 - match case is actually a tiny bit longer
247:42 - if that makes a difference to you
247:44 - although the main thing you want to look
247:46 - at here is readability
247:48 - all of these l if statements here
247:50 - eventually get kind of annoying to read
247:53 - whereas case this case that gets much
247:56 - better and is a much easier way to check
247:58 - the value of this mood
248:00 - both approaches here would be perfectly
248:03 - fine though
248:04 - as a matter of fact
248:06 - match case is a reasonably recent
248:09 - addition to python
248:10 - which is the reason why very few people
248:13 - actually use it
248:14 - most of the time you are going to see
248:16 - some kind of if statement which is still
248:19 - perfectly fine but in some cases match
248:21 - is the more appropriate way to go on
248:24 - but well let's have a look at all of
248:26 - this in code
248:27 - once again i have a completely empty
248:29 - python file and i want to create a new
248:32 - variable let's call it mood
248:34 - and right now my mood is going to be
248:37 - hungry
248:38 - if that is the case i want to run some
248:41 - code
248:42 - what we have seen so far you could use
248:44 - an if statement if
248:46 - mood is equal to hungry
248:50 - then
248:51 - let me print
248:53 - get some food or something like that
248:57 - running this
248:58 - will get me indeed get some food
249:01 - this one is working just as intended
249:04 - the difference now is if we have lots of
249:07 - options here for our mood we could be
249:09 - hungry bored thirsty tired and whatever
249:12 - else you want
249:13 - for each of these conditions we would
249:15 - have to add
249:17 - another
249:18 - l if statement to check for all of the
249:20 - possibilities
249:22 - which does eventually get kind of
249:24 - cumbersome to write
249:26 - and because of that we have
249:28 - match
249:29 - and then we want to look at the variable
249:32 - mood in my case
249:34 - now you need a colon
249:35 - and if i press enter we are again
249:38 - indented by one line
249:40 - and now i have to specify a case
249:43 - that could be one scenario for this mood
249:46 - for example the case could be hungry
249:50 - if i add a color now
249:52 - and press enter we are once again on a
249:55 - separate line and now i can print
249:58 - get some
250:00 - food
250:02 - if i run all of this
250:03 - we are again back to get some food this
250:07 - result here
250:08 - is basically a simple if statement the
250:11 - difference now is that we can specify
250:14 - other cases for example a case first d
250:19 - and then let me copy this one get some
250:23 - water
250:24 - i could specify a case
250:28 - for
250:30 - tired
250:32 - and continue like this forever there
250:34 - really isn't any limitation how many
250:36 - cases you can have let me just write it
250:39 - out get some sleep
250:41 - with that established i can now change
250:44 - the variable and get different outcomes
250:47 - i suppose there's one more thing that
250:49 - you could include here
250:51 - and that would be case
250:53 - underscore
250:55 - still needs a colon and now you can
250:58 - print in here any other
251:00 - mood
251:02 - because an underscore is run when none
251:06 - of the other cases are correct for
251:08 - example right now if i write in here
251:11 - something like
251:13 - board
251:14 - a case we haven't accounted for yet
251:17 - if i run this we get any other mood
251:20 - if python doesn't find any of these it
251:22 - is going to run the underscore one and
251:24 - with that we have match case covered
251:27 - and i am fully aware this is about as
251:30 - efficient as an if-else statement it
251:33 - really isn't that much of a difference
251:36 - match case really is not something you
251:38 - absolutely have to use if you want to
251:40 - stick to if else statements this would
251:42 - also be perfectly fine
251:44 - but all right let's do an
251:46 - exercise what i want you guys to do is
251:49 - this one here
251:51 - create a variable with an integer
251:53 - between 1 and 5 and this should be a
251:55 - great a grade you could be getting at
251:57 - school
251:58 - and then create a match case statement
252:01 - for all of the values that this grade
252:03 - could have
252:04 - one would be very good and five would be
252:07 - very bad and print something like this
252:09 - for each of these cases
252:11 - and i mean all of them from one to five
252:14 - also don't forget to include some
252:16 - default behavior if you get the value
252:18 - you didn't expect like a 10 for example
252:20 - pause the video now and try this one
252:22 - yourself
252:26 - let's get started and i want to comment
252:29 - out all of this
252:30 - and then
252:31 - we can start by creating the great
252:34 - variable and let's start with number one
252:37 - i want to start by writing my match and
252:40 - what i want to look for
252:42 - is the great variable
252:44 - then i need a double colon and now on an
252:47 - indented line i want to check for one
252:49 - case
252:50 - and the case right now could be a one
252:53 - now i need a colon again and once again
252:55 - on an indented line
252:57 - i want to print
252:59 - very good i can now run this and we get
253:02 - very good indeed
253:04 - with that we have one case now we can do
253:06 - case 2
253:08 - print let's say
253:10 - still good
253:12 - case 3 would be print
253:17 - ok
253:18 - case 4
253:20 - would then be print
253:23 - needs improvement and finally case five
253:28 - i want to print
253:31 - very
253:32 - bad i think i said yeah very bad up here
253:36 - and this would already be a working
253:39 - match case statement i can run this
253:40 - again we get very good the same we had
253:42 - earlier
253:44 - let's say if i use a 3 we get ok and if
253:47 - i use 5 we get very bad
253:51 - the one thing we haven't done yet is if
253:53 - i have a 7 a value we don't have
253:55 - accounted for nothing is running in here
253:58 - i guess i haven't specifically mentioned
254:00 - that but if the match case doesn't find
254:03 - a value it just doesn't run
254:06 - we do not get an error message just keep
254:08 - that in mind it's a specific behavior of
254:11 - it
254:12 - all right but i want to add case
254:14 - underscore for all the other values i
254:17 - haven't accounted for
254:19 - and for this one i can print let's say
254:23 - great not
254:26 - recognized
254:28 - if i run this now we get great not
254:30 - recognized
254:32 - this would also work with
254:33 - i don't know something else python
254:36 - doesn't really care what the value here
254:38 - is
254:39 - all right with that we have match case
254:43 - something fairly similar to an if else
254:45 - statement but it could be useful in very
254:47 - specific scenarios
254:49 - a really important concept in python is
254:51 - the while loop and this one is actually
254:53 - quite simple all it does is it repeats
254:56 - some code as long as the condition is
254:58 - true
255:00 - for example this could look like while
255:02 - true i want to print an infinite loop
255:05 - this infinite loop here
255:07 - would run forever unless we manually
255:09 - break the code
255:11 - not exactly the most realistic scenario
255:13 - but something we could be doing
255:16 - i suppose something slightly more
255:17 - realistic would be something like this
255:21 - we are starting with x being 0.
255:24 - then we are checking
255:26 - if
255:27 - x keeps on being smaller than 10 and
255:29 - inside of this while loop we want to
255:32 - print a certain thing and we are also
255:35 - going to increase the value of x on this
255:38 - line here this condition now is only
255:41 - going to run 10 times
255:43 - and this is how often we are going to
255:44 - print this loop here
255:47 - and with that we have some basic theory
255:49 - out of the way let's actually have a
255:51 - look at all of this in code
255:53 - i guess we can start with the examples i
255:55 - just talked about
255:57 - we always start with the while keyword
256:00 - once we have that we need some kind of
256:02 - boolean statement
256:03 - this could either be true
256:05 - or false although if you have false this
256:09 - while loop is not going to run it will
256:11 - only run if the value is true if that is
256:14 - the case in here you can print i think i
256:17 - called it infinite loop
256:20 - if i run this now we get
256:22 - an infinite loop that keeps on running
256:24 - forever
256:26 - it's not particularly exciting but it
256:28 - definitely does work the way you would
256:30 - exit this one is by just pressing escape
256:33 - and it would stop although you really
256:35 - want to be careful with while loops
256:38 - it can
256:39 - not crash your code but it can make your
256:42 - code not work anymore
256:44 - let's say if you have some kind of game
256:46 - and you end up in a while loop that you
256:47 - can't escape from anymore your game
256:49 - might just stop because your computer is
256:51 - stuck in this while loop and it doesn't
256:53 - continue from it
256:55 - let me get rid of this one and let's do
256:57 - something a bit more reasonable instead
256:59 - i want to create a variable x and by
257:02 - default this one is going to be 0.
257:04 - and now i want to check while x is
257:07 - smaller than
257:09 - i want to print
257:12 - x
257:14 - look at this code if i run it what do
257:17 - you think is going to happen
257:18 - what we get is if i run this we have a
257:21 - whole bunch of zeros that keep on
257:23 - running forever
257:25 - and the reason here should be fairly
257:27 - clear
257:29 - this boolean condition x smaller than 10
257:32 - is always going to be true because x is
257:35 - always zero and we are never changing it
257:38 - the consequence being that this print
257:41 - statement is going to run forever it is
257:44 - never going to stop
257:47 - to overcome that we would have to do
257:49 - something like x plus equals 1.
257:52 - and now if i run this we get the values
257:54 - from 0 to 9.
257:56 - i suppose what you could also be doing
257:59 - is combine this with an if statement for
258:02 - example if x is equal to 5 and this has
258:06 - to be indented really important to tell
258:09 - python that this if belongs to this
258:11 - while loop here
258:13 - but once we have that i want to colon
258:15 - again and on another level of
258:17 - indentation i want to print x is
258:21 - 5.
258:22 - if i run this now
258:24 - we get the values from 1 to 9 and at the
258:28 - value 5 we have x is 5. and this way you
258:31 - can repeat code quite easily that being
258:34 - said there are two ways to make all of
258:36 - this a bit more complex let's talk about
258:39 - it
258:39 - you can break an entire while loop and
258:42 - you can also skip one iteration of the
258:44 - while loop and let's do this by example
258:47 - this is a bit difficult to explain
258:49 - here's the example i've shown you
258:51 - earlier and this one would just print
258:53 - the word loop 10 times on the screen
258:57 - but what you can do let's say with one
258:59 - if statement
259:01 - you could for example
259:02 - add the break keyword and just a keyword
259:05 - no brackets just break and if you write
259:09 - this
259:10 - the entire while loop is going to end
259:14 - whenever x is equal to 5
259:16 - you would never get to this 10 here at
259:19 - the end
259:20 - besides that
259:21 - you also have continue continue doesn't
259:25 - break the while loop instead it just
259:27 - skips to the next iteration of the while
259:30 - loop
259:31 - meaning in this case if x is 5
259:34 - this print down here
259:36 - would be skipped over because after
259:39 - continuing this line here we would go
259:41 - back to the while loop and then continue
259:43 - with the next iteration
259:45 - i think i added a bit more text here
259:47 - there we go
259:48 - so break ends an entire while loop while
259:51 - continue skips to the next iteration of
259:53 - the while loop and that's basically all
259:55 - you have to understand about it let's
259:57 - play around with it
259:58 - i already have an if statement inside of
260:00 - the while loop and this one i want to
260:03 - use let's start with the break keyword
260:06 - and you can already tell sublime is
260:09 - coloring it differently so we know that
260:12 - it has some kind of special
260:13 - functionality
260:14 - if i run the code now
260:16 - we get only the numbers from 0 to 4
260:20 - and this happens because of this break
260:22 - here it ends the entire while loop as
260:25 - soon as xs5
260:28 - the other keyboard we have seen is
260:30 - continue
260:32 - and this one right now is not going to
260:34 - work
260:35 - and maybe you can figure out why let me
260:38 - run it actually in this case we are
260:41 - getting all of the numbers and try to
260:44 - think of why we didn't skip over one of
260:46 - them
260:47 - after we are running continue we are
260:50 - skipping the rest of the current while
260:52 - loop in our case though we don't have
260:55 - anything after continue continue is on
260:57 - the last line of this while loop
261:00 - which means it doesn't actually do
261:02 - anything
261:04 - we could change this though by putting
261:05 - the print statement after continue
261:08 - and let me add a bit more white space
261:11 - here this looks a bit cleaner
261:13 - if i run this now we would expect this
261:16 - print statement to be skipped if x is
261:19 - equal 5 meaning we shouldn't see 5 in
261:22 - the output
261:23 - let's try it and indeed
261:26 - after 4 we skip straight to 6. we do not
261:29 - have 5
261:31 - because of this continue here
261:34 - and with that we have a while loop
261:37 - let's do an exercise and then we are
261:40 - done that is horrible spelling there we
261:43 - go
261:43 - what i want you guys to do is to use a
261:45 - while loop to create a list with only
261:48 - even values from 0 to 100
261:51 - i guess as a tip here create an empty
261:54 - list first and then from the while loop
261:56 - append more values
261:58 - i haven't covered yet how to only get
262:01 - even or odd values
262:03 - maybe try to do some research it should
262:05 - be fairly doable but let's see if you
262:07 - can figure this one out
262:12 - i guess this one was a slightly more
262:14 - challenging exercise but let's try it
262:16 - together i first need some kind of list
262:19 - let me call it my list and this is just
262:22 - empty brackets for an empty list and
262:24 - there's one more thing that i am going
262:26 - to need and that is some kind of counter
262:29 - by default i want to set this one to
262:31 - zero
262:32 - this is what we are going to use to
262:34 - control the while loop like the x we
262:36 - have used up here
262:37 - actually let me comment out this earlier
262:40 - stuff so we are not getting confused
262:42 - what i want to do with that is run my
262:45 - while loop again
262:46 - with counter is smaller or equal than
262:50 - 100
262:51 - because this is the maximum number we
262:54 - want to go to and we are starting from
262:56 - zero which is the value here
262:58 - and let's start by adding every single
263:00 - value to the list for that we need my
263:03 - list
263:04 - append and then the counter
263:07 - once we have that i can just print
263:11 - my list and let's see what we get and we
263:14 - are getting nothing
263:16 - the reason here
263:18 - look at this again
263:19 - i have actually made the mistake i
263:21 - warned you about earlier
263:23 - right now the code is stuck inside of
263:25 - the while loop
263:27 - let me end it with the escape button
263:29 - this if this was an actual code example
263:32 - would have been really bad the reason
263:34 - here is this counter doesn't increase
263:38 - it always stays at 0 and as a
263:40 - consequence this condition will always
263:42 - be true
263:43 - and as a consequence we keep on adding
263:46 - the value 0 to this list
263:48 - and besides that we would do pretty much
263:51 - nothing else i would spend my entire
263:53 - processing time just adding zeros to a
263:55 - list
263:56 - which not only would break my code it
263:58 - would also be a waste of resources
264:00 - the way around it is i want to increase
264:03 - the value of the counter by 1.
264:05 - and now if i run this
264:07 - we are very quickly getting the values
264:09 - from 0 to 100
264:11 - already a pretty good start but now i
264:15 - don't want every single value i only
264:17 - want the even ones meaning i want 0 2 4
264:21 - 6 and so on
264:23 - for that we are going to need an if
264:25 - statement inside of the while loop
264:28 - all you really need is the
264:30 - percentage sign
264:32 - and this we want to use with the number
264:34 - 2.
264:35 - if this is 0 we know we are getting an
264:39 - even number
264:40 - if i run this now
264:42 - i am getting only the even numbers
264:46 - this operation here if you forgot about
264:48 - it is the remainder
264:50 - for example if the counter was at three
264:55 - i think early on i used dots and that's
264:56 - a really good system to explain it let's
264:59 - say we have three
265:02 - dots here representing this three and if
265:05 - we're dividing this number by 2
265:07 - we have one full block
265:09 - and this would be 1 unit after division
265:14 - and what this percentage sign here gives
265:16 - us is the remainder so this one here
265:19 - and if this is any value besides zero we
265:22 - know we have an odd value
265:25 - on the same line if there is any value
265:27 - so if i use different from zero we are
265:30 - only getting the odd values
265:34 - and this is the most common use case for
265:36 - this remainder operation it's a really
265:39 - easy way to get even or odd values
265:42 - i guess while we are here we should also
265:45 - practice
265:46 - skipping one while loop so let me extend
265:49 - the exercise
265:51 - i also want you guys to
265:54 - do not add the value
265:57 - 58.
265:59 - for some reason i really do not like
266:01 - this one
266:02 - try to add this one as well
266:05 - all right this is turning kind of into
266:08 - extra practice for the if operator but i
266:11 - suppose that can't hurt
266:13 - we can approach this in two different
266:14 - ways we could either add another if
266:16 - statement in here or add an end keyword
266:21 - after the original if condition
266:23 - i guess let's start with this one
266:26 - i want to check if my counter
266:29 - has a remainder of 0
266:32 - and my counter
266:37 - is different from 58 this is the number
266:40 - i want to avoid
266:42 - if i run the code now i get let me find
266:45 - the value we have 54 56 and then we skip
266:49 - to 60. we do not have 58.
266:52 - this would be one way to add it here
266:54 - a different approach could be another if
266:57 - statement inside of this counter
266:59 - i could check in here if counter
267:02 - is
267:03 - different from 58
267:06 - and then
267:08 - this append here has to be
267:10 - on one more level of indentation to tell
267:12 - python it belongs to this if statement
267:14 - here
267:15 - and if i run this now we are getting the
267:18 - same outcome here with the 58 being
267:20 - skipped
267:21 - all things considered while and if work
267:25 - really well together
267:26 - and all right with that we have while
267:29 - loops something fairly similar to a
267:31 - while loop is a for loop and this one
267:33 - works in a somewhat similar way we are
267:36 - still running code a certain amount of
267:38 - time so we are basically repeating code
267:41 - the difference now is that we are
267:43 - running code for every item inside of a
267:46 - container
267:48 - this could for example look something
267:50 - like this
267:51 - we want to run a
267:53 - for loop for every item inside of the
267:56 - list that contains one two and three
268:00 - the way this works is that python goes
268:02 - through this entire list and picks every
268:04 - single value one two and three here and
268:07 - then for each cycle it assigns the value
268:09 - to the x in this case but you could name
268:11 - it whatever you want
268:14 - meaning if you added something like a
268:15 - print inside of this for loop you would
268:18 - print
268:19 - 1 2 and three
268:22 - four cycles over every single item in
268:25 - the list and then it stores the value
268:27 - inside of x and you can treat it like a
268:29 - variable
268:31 - and just like with while you can also
268:32 - use break and continue
268:35 - and that is basically it let's have a
268:37 - look at it
268:39 - i want to create let me call it a basic
268:42 - list
268:43 - and here let's use the example i have a
268:46 - list with the numbers 1 2 and 3. and i
268:50 - want to run a for loop to access every
268:53 - single item of this list
268:55 - the example we have used is for x in
268:58 - basic list
269:00 - and then inside of it we have printed x
269:04 - if i run this now we're getting one two
269:06 - and three
269:07 - so what happened here i think it
269:10 - actually makes kind of sense
269:12 - python is going to run this block of
269:15 - code here
269:16 - for every item inside of this list
269:20 - and on every cycle it picks one of the
269:24 - values starting from one then two and
269:26 - then three and it always assigns this
269:29 - item to the variable we have specified
269:32 - here
269:33 - but you could use any python variable
269:35 - name
269:36 - and then inside of the for loop we are
269:38 - doing something with that value right
269:41 - now we're just printing it we could also
269:43 - add it to a list or doing some math
269:44 - operations or really do whatever we want
269:47 - and that way we can run code for every
269:49 - item inside of a list and this would
269:52 - also work with the other types of
269:54 - containers like a tuple a dictionary or
269:56 - a set
269:58 - as a matter of fact there are lots of
269:59 - different things you could be cycling
270:01 - over for example a string would also
270:04 - work inside of a for loop and there's
270:06 - one particular case i do want to cover
270:09 - if you want to cycle over a number this
270:11 - would also work but it does need some
270:13 - adjustment let's actually play around
270:15 - with all of this and i have pre-written
270:17 - some values these ones here we have a
270:20 - basic tuple a basic dictionary a basic
270:22 - set a basic string and a basic number
270:26 - tuples and sets work exactly like the
270:28 - list if i replace the basic list with a
270:31 - basic tuple
270:33 - we get the very same outcome and we
270:35 - would also get the same thing with a set
270:39 - there we go we always get one two and
270:41 - three python just really doesn't care
270:44 - what kind of container you have it's
270:47 - fine cycling over any of them
270:50 - the basic dictionary also works but it
270:52 - looks a bit different in terms of what
270:54 - you
270:54 - get let me paste it in here basic dict
270:58 - and now we are still getting one two and
271:00 - three
271:01 - we are getting all of the keys
271:04 - which if you cycle over a dictionary is
271:07 - probably not what you want to do the way
271:10 - around it is you would use either values
271:14 - to get the values now get one two and
271:16 - three the strings attach to each key
271:19 - or we would use items
271:21 - and that way you're getting a tuple
271:23 - returned with the key and the value
271:27 - we are going to learn later on how to
271:29 - work with dictionaries in a bit more
271:31 - detail but for now i think this is all
271:33 - we are going to need
271:35 - for a basic string
271:38 - we can just paste it in here and now
271:40 - python takes the string apart and gives
271:43 - us every individual letter including the
271:46 - space
271:47 - finally
271:48 - we have a basic number and this right
271:52 - now is not going to work if i run it
271:55 - we get a type error into object is not
271:58 - iterable
272:00 - let's talk about why this one didn't
272:03 - work
272:04 - to loop over a number so the operation
272:06 - we have seen was for x and three and
272:09 - this one didn't work the reason it
272:11 - didn't work is because python needs some
272:14 - kind of iterable and integers cannot be
272:17 - iterated over that being said iterating
272:20 - from zero to a certain number is such a
272:23 - common operation that there's a specific
272:25 - python function for it it is called
272:28 - range
272:29 - how you would use that is you would add
272:32 - a number in it and then it creates a
272:34 - range object
272:35 - if you use something like range 3
272:38 - we would get a range object from 0 and
272:41 - then all the way to 3.
272:44 - and this we can iterate over
272:47 - it's fairly similar to a list although
272:49 - it is its own data type
272:51 - meaning if you want to iterate over a
272:54 - number you would use for x in range and
272:57 - then the number
272:58 - and i guess let's implement this one as
273:00 - well here we are back in the example and
273:03 - instead of using the number i have to
273:05 - put the number inside of the range
273:08 - function
273:09 - if i print this now
273:11 - we are getting the numbers 0 1 and 2
273:15 - which if you pay close attention is kind
273:17 - of different from these numbers here we
273:20 - are not even getting 3 we are again
273:22 - starting at 0 and then going all the way
273:25 - to 3 but we are not including 3 and this
273:29 - is why we are getting two
273:31 - a better way of illustrating this let me
273:33 - copy this and comment out this entire
273:36 - for loop
273:37 - and just print
273:39 - the range object
273:42 - running this gets me a range object from
273:44 - 0 to 3.
273:46 - it very much is its own data type
273:49 - and this one simply gives us something
273:51 - we can loop over and it starts from 0
273:53 - and goes all the way to a number we
273:55 - specified but it doesn't include it
273:59 - which granted is a bit confusing to read
274:02 - the range function actually works very
274:04 - similar compared to slicing
274:07 - because inside of range right now
274:10 - we only specified one value which was
274:12 - the end point but you could specify up
274:15 - to three values in here
274:18 - you could have the start the end and the
274:21 - step size for the values
274:24 - start by default is going to be
274:27 - zero and the step size is always going
274:30 - to be one meaning if we don't specify
274:32 - them
274:33 - we are getting those values
274:35 - most of the time you are only specifying
274:37 - the end value which is what we have done
274:40 - ourselves
274:42 - but in here you could specify something
274:44 - like 10
274:46 - let's say 20 and 2.
274:49 - if i run this now we are getting range
274:51 - object from 10 20 and a step size of 2
274:55 - which by itself isn't particularly
274:57 - useful
274:58 - but if i cut all of this out get rid of
275:01 - this print statement
275:03 - and uncomment this for loop
275:06 - and now
275:07 - i want my range object to look like this
275:12 - if i run it now
275:13 - we get only the even values from 10 to
275:16 - 20 and again we are not including 20.
275:20 - but that is essentially the for loop
275:25 - it is very often used alongside the
275:28 - range function they are very much
275:30 - connected to each other
275:32 - and i guess with that let's do an
275:35 - exercise
275:36 - once more
275:37 - and what i want you guys to do is this
275:39 - one here
275:40 - and this list contains other lists these
275:44 - are nested lists
275:46 - you are supposed to cycle through this
275:48 - entire list using a for loop and then
275:50 - only print the numbers below 50.
275:53 - although skip the values below 10.
275:55 - as a tip here
275:57 - you will need one for loop to go through
275:59 - this list and then another nested for
276:02 - loop to go through each individual list
276:04 - inside of this list
276:06 - finally i want you guys to break this
276:09 - for loop if any value is above 100 which
276:13 - is the case here for this one you are
276:16 - going to need a for loop inside of a for
276:18 - loop and also throw an if statement in
276:20 - there somewhere
276:21 - see if you can figure this one out
276:22 - yourself
276:29 - alright let's do it together now first
276:31 - of all i need for
276:34 - and now i need a good name
276:37 - and since i know that each of these
276:39 - lists here are nested inside of
276:43 - this practice list
276:45 - i want something like for a nested list
276:48 - inside of my practice list
276:51 - meaning i'm looking at this practice
276:52 - list here and i'm cycling over this
276:55 - entire list
276:57 - what i'm getting from that is going to
276:59 - be let me print the nested list
277:02 - i am getting these three lists here
277:06 - we still get the earlier results let me
277:08 - comment out all of this to make all of
277:10 - this a bit cleaner there we go
277:12 - now we have a couple of lists with
277:14 - numbers inside of them
277:16 - problem is this still doesn't help us
277:19 - figure out individual values
277:21 - for example i want to print this 10 here
277:25 - but right now i can't access it because
277:27 - it's inside of a list
277:29 - to overcome that
277:30 - we are going to need another for loop
277:34 - with for let me call it value inside of
277:37 - the nested list
277:40 - and now if i print this value
277:43 - and let me comment out printing the
277:46 - nested list that's going to get
277:47 - confusing
277:48 - if i run this now
277:50 - i am getting all of the numbers
277:52 - basically what happens here let me use
277:54 - different colors for this
277:56 - the first for loop this one here
278:00 - is going to go through this entire list
278:03 - and it is looking at every item and an
278:06 - item is counted at anything separated by
278:10 - a comma meaning this is one item this is
278:12 - another item and this is the final item
278:16 - python doesn't care if the item is a
278:18 - list or a number it treats all of them
278:20 - the same
278:22 - and to access every value inside of this
278:25 - nested list we have this second for loop
278:28 - here
278:28 - and this one is going to go for every
278:31 - individual list it starts with this one
278:33 - then it does this one and then this one
278:36 - and via this for loop we are going
278:38 - through every individual value inside of
278:42 - the list or the nested list to be more
278:44 - specific
278:45 - the result being that this value here is
278:48 - going to be every individual value from
278:52 - all of the lists and this is what we are
278:55 - printing
278:56 - that is a really good start so now we
278:59 - have to cover that we only want to print
279:02 - the numbers below 50 and we want to skip
279:04 - values that are below 10.
279:07 - i guess we can start with if the value
279:11 - is below 50
279:14 - only then do we want to print the entire
279:16 - value
279:17 - let me run this now and we are only
279:20 - getting values below 50.
279:23 - this is going to cover the entire first
279:25 - line
279:26 - now we have to cover the part to skip if
279:28 - a value is below 10.
279:31 - and this again we could either do by
279:34 - adding an end here
279:36 - or we could add another if statement
279:39 - inside of here
279:42 - i guess i'm going to stick with the if
279:44 - statement inside of here although it
279:46 - really doesn't matter i want to skip the
279:48 - values if we are below 10 meaning if
279:52 - the value is below 10
279:55 - then i want to use continue
279:58 - if this is the case
280:00 - we are stopping this entire cycle and we
280:03 - are not getting to the print value
280:06 - so let's try this and indeed we are only
280:09 - getting values that are at least 10
280:12 - and the values two and 4 we have skipped
280:17 - now finally we have to cover the last
280:20 - part that i want to end this entire for
280:22 - loop if we get a value above 100 which
280:26 - is going to be this one here
280:29 - and now you might be very tempted to add
280:31 - something like if value
280:34 - is greater than 100
280:37 - then i want to break this entire code
280:40 - or at the very least the for loop
280:42 - however now this is not going to work
280:46 - i guess to demonstrate it
280:48 - the last value after 101 is going to be
280:51 - this 10 here and since this is not below
280:54 - 10 we do expect this to run although i
280:57 - just realized that since we have a 10
280:59 - here enter 10 here it might be a bit
281:01 - hard to see
281:02 - let me change the name here to a 12 so
281:05 - we have a specific number
281:07 - if we run the code now
281:08 - we still can't see the 12
281:11 - and i would recommend you to look over
281:14 - this and see why we can still see a 12.
281:18 - the error here is because of one of the
281:20 - if statements try to have a look for it
281:24 - the error happened on this line here
281:27 - this if statement checks if the value is
281:30 - below 50 meaning we are never getting a
281:33 - value above that 50.
281:36 - as a consequence
281:38 - when we are getting to this line here if
281:40 - value is above 100
281:42 - this line doesn't even run because we
281:44 - never get to it
281:46 - after this line here we are only getting
281:48 - values below 50.
281:50 - so this line here is essentially
281:52 - pointless we can however cut it out and
281:57 - paste it at the top of
282:01 - of the inner for loop
282:03 - let me fix this one
282:05 - now when we are looking inside of this
282:06 - for loop if we find any value above 100
282:10 - we are breaking the entire thing and
282:12 - none of this would run
282:15 - i guess let me run it and now the last
282:18 - value is 10
282:19 - this 10 here
282:21 - this does look confusing especially if
282:23 - you're just starting to program but if
282:25 - you get used to indentation here this
282:27 - should eventually make more and more
282:29 - sense this is definitely something you
282:31 - want to practice in your own time even
282:33 - more
282:34 - when it comes to python and the flow of
282:36 - the code understanding indentation is
282:39 - really important to understand what's
282:40 - going on
282:42 - there's one more topic i do want to
282:44 - cover before finishing this section and
282:46 - that is flow and line breaks
282:49 - so far we always wrote code with a colon
282:52 - and then with an annotation on the next
282:54 - line
282:55 - you don't have to do that you could just
282:57 - write straight after the colon for
282:59 - example
283:00 - for a for loop instead of the line break
283:04 - after the colon and the indentation here
283:07 - you could simply continue writing the
283:09 - print statement here
283:11 - this would also work with an if
283:13 - statement it would also work with a
283:14 - while loop
283:16 - as a matter of fact you could even use a
283:19 - semicolon to add multiple lines of code
283:23 - all of these here
283:24 - would be counted as indented python is
283:27 - totally fine with that
283:29 - that being said most of the time you do
283:31 - want to indent your code because having
283:33 - multiple lines is easier to read but
283:36 - that's not always the case
283:38 - sometimes if you have a very simple
283:40 - statement it might make more sense to
283:42 - have it on the same line
283:44 - for example match case very often has
283:47 - each case on an individual line without
283:50 - a line break between the case and the
283:52 - actual code because the idea here is
283:55 - each case should be fairly simple we're
283:57 - gonna have a look at that in a second
283:59 - but much more important for the if
284:01 - statement python does have a special
284:04 - operation here to have a one line if
284:07 - statement and this is called a ternary
284:09 - operator
284:11 - this one works like this let's say we
284:14 - have x equals 5 and we want to check
284:16 - something like
284:18 - if the value is below 5 we want color
284:20 - equals blue and else the color should be
284:23 - red a really simple if statement
284:26 - the problem is that we have four lines
284:28 - of code for something that really is
284:30 - very simple
284:31 - we could make this more space efficient
284:34 - by skipping the line break here
284:37 - this way we only have two lines and this
284:40 - i think is more readable but this may be
284:43 - debatable here
284:44 - however there is an even more efficient
284:46 - way of doing all of this
284:48 - and this would look like this
284:50 - this by the way is called the ternary
284:52 - operator
284:53 - this entire line
284:56 - would be
284:57 - this bit here
284:59 - then we have the if statement as always
285:01 - but now the if statement this bit here
285:05 - with the condition
285:07 - is this part here from the original if
285:09 - statement
285:11 - we also have an else and then we have
285:13 - the else condition so this red here
285:16 - would be assigned to the color if the
285:19 - condition this one here was false
285:22 - and the way you would understand this
285:24 - ternary statement here is if you read it
285:27 - like a sentence i want the color blue if
285:30 - the value of x is below 5 if that is not
285:32 - the case so else i want the color red
285:36 - and that way if you have a simple if
285:38 - statement you can cover all of this on a
285:41 - single line of code
285:43 - once again we have a completely empty
285:45 - python file and i want to start with the
285:48 - match case statement
285:50 - and here is the exercise we have done
285:53 - earlier
285:54 - if you see this now with the
285:56 - understanding that we don't have to do
285:58 - these line breaks i think all of this
286:00 - starts to make a whole lot more sense
286:02 - this one we could write like this
286:08 - let me get rid of all of the line breaks
286:12 - this here
286:13 - is something incredibly readable
286:16 - especially if you have some kind of
286:18 - statement where you would expect a lot
286:20 - of specific values you want to check for
286:22 - this would be a very readable way to
286:24 - organize all of it
286:26 - although granted using if-else statement
286:29 - wouldn't look all that different
286:31 - the much more important operator is the
286:33 - ternary operator
286:36 - and let me comment out the match case
286:38 - stuff because we don't need it
286:41 - the example i've used earlier was x
286:43 - equal 5. from this value i want to
286:46 - assign some kind of color
286:48 - and in here you first of all need the
286:50 - value in my case red
286:52 - if the condition you want to check for
286:54 - is true i want to have red
286:56 - if the value of x is i think smaller
287:00 - than 5 i said doesn't really matter what
287:02 - it is
287:03 - if that is not the case so else i want
287:06 - to assign a different value which in my
287:08 - case is blue
287:10 - and that is all we need if i now print
287:13 - my color
287:15 - run this we are getting blue because 5
287:18 - is
287:19 - well this condition here is false
287:22 - but if i change x to 1 run this again we
287:25 - are getting red
287:27 - and this way if you have a very simple
287:30 - if statement you can cover it on a
287:32 - single line
287:34 - i guess let me go over this a bit more
287:36 - theoretically
287:37 - a ternary operator always looks like
287:39 - this
287:40 - we have a true
287:43 - value
287:44 - if an expression
287:46 - results in true
287:48 - if the expression is false let me add a
287:51 - cross here then we are getting the else
287:54 - value so the false value
287:56 - and then either the true or the false
287:58 - value
287:59 - will be assigned to whatever kind of
288:02 - variable
288:03 - we are assigning all of this to
288:06 - that way you can cover an if statement
288:08 - on a single line of code
288:10 - and this is really readable and very
288:12 - efficient if you have a simple if
288:14 - statement if the if statement gets more
288:17 - complex obviously you want to use a
288:19 - normal if statement the ones we have
288:21 - already seen
288:23 - i guess one thing i haven't covered yet
288:25 - is that this sort of operation here
288:28 - this ternary operator works in a lot of
288:31 - different tools as well for example you
288:33 - can use it inside of an f-string or when
288:35 - you are creating a list
288:37 - let's have a look at those two examples
288:40 - let me get rid of this print statement
288:42 - and instead i want to print an f string
288:46 - and in here i want to write something
288:48 - like the color is
288:51 - and then i want to have an operation
288:53 - and in here
288:55 - i could copy
288:56 - this entire thing instead of the
288:58 - variable and it would still work
289:01 - so i can copy it although there's one
289:04 - thing that we do have to take care of
289:06 - and that is that right now the quotation
289:09 - signs are going to confuse python so it
289:11 - doesn't know where the string ends and
289:13 - where it begins
289:14 - the way around it is to use double
289:16 - quotation marks at the end and at the
289:19 - start
289:20 - and this should be working now let's try
289:22 - it and there we go the color is red
289:25 - and in here we have a fairly complex
289:28 - statement inside of a string this way we
289:32 - don't have to assign variables before or
289:34 - after we can keep everything nice and
289:37 - neat inside of one line
289:39 - finally we could also do something like
289:42 - a is equal to
289:44 - some kind of value in the list
289:46 - and in here i could once again copy all
289:48 - of this paste it inside of the list and
289:51 - then have some other values like i know
289:54 - yellow and
289:55 - green
289:57 - if i now print the entire list
290:00 - we're getting red yellow and green all i
290:04 - really want you guys to take away from
290:05 - this is that this sort of operation
290:07 - works basically anywhere in python
290:10 - you could also put it inside of a
290:12 - function or a method python really
290:14 - doesn't mind and this can give you a ton
290:17 - of power and avoid you having to write
290:19 - extra code that you wouldn't need
290:22 - in this section we are going to cover
290:24 - functions and let's talk about what
290:27 - functions are and what purpose they
290:29 - serve
290:30 - so far we covered some basic data types
290:33 - like integers and strings and we also
290:36 - learned how to change them using
290:38 - functions and methods
290:40 - on top of that we also learned how to
290:42 - change the flow of the code using if
290:44 - else match well for statements and stuff
290:47 - like that
290:48 - so we are basically able to create
290:50 - simple programs that work just fine
290:53 - but all of this only gets us so far and
290:56 - to understand why
290:58 - let's do a metaphor
290:59 - and
291:00 - let's say we want to build a car and the
291:03 - tools we have learned about so far are
291:05 - the basic parts that you would need for
291:07 - a car like screws pipes wires plastics
291:10 - and all the most basic parts you can
291:12 - have for a car
291:13 - the problem is these parts don't really
291:17 - make a car we don't build a car out of
291:19 - plastics and wires instead we build a
291:23 - car out of an engine out of steering
291:25 - systems out of control systems batteries
291:28 - and stuff like that meaning what we want
291:30 - to do in our code is to take these
291:33 - simple parts here and use them to create
291:36 - more complex systems like a control
291:39 - system or like an engine
291:41 - and once we have these more complex
291:43 - systems we actually create the entire
291:47 - car
291:48 - and in this analogy a function is one of
291:51 - these more complex systems like the
291:53 - engine the control the battery
291:55 - they are just more complex parts but
291:58 - they're still made out of these simple
291:59 - bits here and the main purpose of this
292:02 - is to make our code more reusable and
292:04 - more organized
292:06 - so what we are going to focus on for
292:08 - this section is to combine these simple
292:10 - tools to create more complex parts
292:13 - and that is the main purpose of
292:15 - functions
292:16 - later on we are going to learn even more
292:18 - powerful ways to organize your code
292:20 - using classes but that comes later for
292:23 - now we are just going to look at
292:25 - functions and the one really important
292:28 - thing i already want you guys to
292:29 - understand is that a function is simply
292:32 - a block of code that can be reused we're
292:35 - not really learning anything
292:36 - fundamentally new instead we are just
292:38 - putting our pre-existing code into a
292:40 - simple block or container and then we
292:43 - are using this container to execute that
292:45 - code that's basically it although to use
292:47 - functions we need a two-step process
292:50 - let's talk about that one and then we
292:51 - actually create some functions
292:53 - for function we first of all have to
292:56 - create the function and this is where we
292:58 - are adding all of the code to the
293:00 - function or while we are creating the
293:02 - code inside of the function
293:04 - once we have that we have to do what is
293:07 - called calling the code this is a very
293:10 - common word calling a function means you
293:12 - are executing the function or you're
293:14 - telling the function to run and execute
293:16 - the code inside of it and you can also
293:18 - add information into the function when
293:20 - you called it we will see that in just a
293:22 - second
293:23 - but with all of that covered let's
293:25 - actually create some basic functions and
293:28 - this we should do in our code so let's
293:30 - have a look at that
293:32 - and to create a function we need a
293:34 - special keyword and this is called def
293:37 - short for define
293:39 - and now we need a name for a function
293:42 - and in here we have the same naming
293:44 - convention that we have for variable
293:46 - naming
293:46 - so for example a name for function could
293:49 - be test underscore function
293:51 - and this would be perfectly fine
293:53 - and once we have the name we need a pair
293:56 - of brackets and those you always need i
293:59 - will explain in a second what they
294:00 - actually do i am going to leave them
294:03 - empty for now though
294:04 - and now we need a colon and if i now
294:07 - press enter
294:08 - i am going to be in one level of
294:10 - indentation
294:11 - this space here
294:13 - tells python or while this indentation
294:15 - that any code we have inside of here
294:18 - belongs to this function
294:21 - really important to understand
294:23 - it works like a for loop or an if
294:24 - statement same principle
294:26 - and now in here we can write any code we
294:30 - have already seen for example i could
294:32 - print
294:34 - hello
294:35 - i could create a new variable let me
294:37 - call it test and test could just be one
294:40 - plus two
294:41 - and then i could print test
294:44 - we can write the very same code in here
294:46 - that we can write in normal code
294:49 - and once i have this i have created a
294:52 - function so this is the first step
294:54 - and now to call it i need my test
294:57 - function so the name of it and then add
295:00 - brackets afterwards and this entire
295:02 - process here is called calling a
295:04 - function
295:05 - essentially every time you're adding
295:08 - brackets
295:09 - after the name of a function you are
295:11 - calling that function
295:13 - and what that essentially means is
295:15 - you're telling python you want to
295:16 - execute all of this code here
295:20 - if i run the code we can see hello and
295:23 - free so this hello here and the result
295:26 - of oneplus 2 printed in this line
295:29 - and what i can also do now i can
295:31 - duplicate
295:32 - this call of the function and run this
295:34 - again and we can see this code run or
295:37 - executed multiple times and i hope you
295:41 - can already see why this is useful you
295:44 - can basically create some specific
295:46 - functionality in here and then execute
295:48 - it wherever you need so if you had
295:51 - some really complex code and you wanted
295:54 - to organize it better this is one of the
295:56 - main ways you would be doing it
295:59 - and let's actually do another example
296:02 - and for this one let's do something more
296:03 - specific i want to create a
296:06 - calculator
296:08 - and again i need brackets and all i
296:11 - really want to do in here
296:13 - i want to create a variable result and
296:17 - this result should be the result of
296:19 - number one plus
296:21 - number two
296:22 - and once i have that i want to print
296:26 - my result
296:28 - meaning this would be an incredibly
296:30 - simple calculator that just adds two
296:32 - numbers together
296:34 - but for this to work we kind of have a
296:36 - problem and that is how can we get this
296:39 - and this number here
296:41 - and for that we're going to need these
296:43 - brackets here
296:44 - and those brackets are called parameters
296:47 - and what they mean is let me add them
296:50 - actually i can add a parameter for
296:52 - number one and a parameter for number
296:54 - two
296:55 - and let's actually do the entire
296:58 - function now when i call this calculator
297:01 - and execute it with brackets i have to
297:04 - add arguments in here let's say two and
297:08 - three
297:09 - if i run this now i can see five
297:11 - which is the result of two plus three
297:14 - now
297:15 - why did this happen
297:17 - essentially this number one here and
297:19 - this number two are both parameters and
297:22 - a parameter is essentially a variable
297:25 - that you can only use inside of the
297:27 - function meaning this number one here we
297:30 - can use as a variable inside of this
297:33 - function same for this number two here
297:36 - and then the value for these two
297:38 - parameters or these two variables inside
297:40 - of the function
297:41 - come from
297:43 - the information that we pass into the
297:45 - function when we call it meaning this
297:47 - number two here is going to be the value
297:50 - for number one
297:51 - and number three is going to become the
297:53 - value for number two let's actually do
297:56 - this the other way around
297:58 - when we are calling the calculator by
298:00 - calling the name of the function and
298:01 - adding brackets afterwards python is
298:04 - looking what happens inside of the
298:05 - bracket
298:07 - and right now we are adding two numbers
298:09 - two and three
298:11 - and next up python looks at the actual
298:14 - function and the parameters and right
298:16 - now it has number one and number two
298:20 - and now what happens is that python is
298:23 - going to add the first argument which
298:25 - right now is this 2 it is going to
298:28 - assign the value of this 2 to the first
298:31 - parameter
298:32 - and then the second argument so this 3
298:35 - here
298:36 - is going to be passed into
298:38 - the second parameter and that way num1
298:41 - becomes 2 and num2 becomes 3.
298:44 - and once we have that we can use those
298:46 - two numbers like variables inside of the
298:48 - function
298:50 - although one thing you do have to be
298:52 - aware of is that both of these
298:54 - parameters only exist inside of the
298:56 - function meaning if i try to print num1
299:00 - outside of the function i would get an
299:02 - error and that error is name 1 is not
299:05 - defined because this name 1 here only
299:08 - exists inside of this function
299:11 - so in the code besides coding the
299:13 - calculator once i could also call it
299:15 - twice and add different numbers let's
299:17 - say 10 and 20
299:20 - and i would get the result again so
299:22 - again this function here we can call
299:24 - multiple times
299:26 - and well with that we already have the
299:28 - basics of functions so let's do
299:32 - an
299:33 - exercise
299:35 - and what i want you guys to do is to
299:37 - work on this calculator and give it some
299:39 - more functionality it should still
299:41 - accept num1 and num2 for two numbers you
299:44 - can add but besides that the user should
299:47 - also be able to add an operation so a
299:50 - third parameter and i want you guys to
299:52 - add a plus and a minus operation here
299:56 - so for example if the user adds let's
299:59 - call it the better
300:01 - calculator
300:02 - in here we can add one two and then we
300:05 - can add minus
300:07 - or we can add plus
300:09 - and obviously if the user does that we
300:11 - get either plus or minus operations
300:17 - now first of all i have to create a new
300:20 - function by writing better calculator
300:22 - the name of our function
300:24 - and now in here i need three parameters
300:27 - i want num1 and num2 again and besides
300:30 - that i need an operation or operator
300:33 - doesn't really matter what you call it
300:35 - and one important thing really quick
300:38 - since these parameters are always
300:40 - relevant only to the function we can
300:43 - reuse names here quite easily meaning to
300:46 - python these num1 and num2 parameters
300:49 - and these up here have no relation
300:54 - whatsoever
300:55 - so don't worry about naming here
300:57 - now what i want to do inside of this
301:00 - function is to add an if statement and
301:03 - in here i want to check if the operation
301:06 - is plus
301:08 - and if that is the case
301:10 - my result
301:11 - should be num1 plus num2
301:15 - and once i have that i want to print
301:18 - let's do this a bit more fancy i want to
301:20 - add an f string and in here i want num1
301:24 - plus
301:26 - num2 is equal to the result
301:31 - and we can actually try this so i
301:33 - already call the function with 1 2 and
301:35 - plus
301:36 - and the plus we have in this if
301:38 - statement here
301:39 - meaning if i run this i get 1 plus 2 is
301:42 - 3. and let me comment out these two
301:46 - lines here so it's a bit cleaner
301:48 - and one important thing here the
301:50 - indentations continue on each additional
301:54 - level i guess we haven't talked about
301:56 - this too much yet but inside of this
301:58 - function all of the code has to be on
302:00 - one level of indentation
302:02 - and now if we use more code inside of
302:04 - this like an if statement for example
302:07 - we have to add the code for this if
302:09 - statement inside of another level of
302:11 - indentation
302:12 - and that way python knows that this code
302:14 - here belongs to the if statement and all
302:18 - of this code here belongs to the
302:20 - function
302:21 - it's really important to understand
302:23 - indentation early on python uses it
302:25 - extensively to organize the code
302:28 - if i add a minus to this calculator
302:31 - we get nothing because we have no if
302:34 - statement or any of this
302:36 - but we can add it quite easily
302:38 - because i want to add an l if statement
302:41 - and in here operation
302:43 - i want to check for
302:45 - minus
302:46 - and now for this one
302:48 - i can just copy all of this
302:52 - and now the result should be num1 minus
302:55 - num2
302:56 - and then for printing all of this there
302:59 - should be num1 minus num2
303:01 - and now if i run all of this again
303:04 - i get 1 minus 2 is negative 1. that
303:06 - seems right
303:08 - and now i can copy this line change the
303:11 - numbers let's say i don't know some
303:13 - larger numbers
303:15 - let's add a plus here this is not how
303:18 - you spell that let's run this now and we
303:21 - are getting something that looks pretty
303:22 - good
303:23 - and i hope now that we have some better
303:26 - examples you can see the value of
303:28 - functions
303:29 - this is a really good way to organize
303:31 - your code because when we actually
303:33 - execute the code we just have one line
303:36 - but this one line executes a whole bunch
303:38 - of code
303:39 - and in actual programming examples you
303:42 - might have hundreds of lines inside of
303:43 - one function
303:45 - and what you see most of the time
303:47 - is that programmers create all of the
303:50 - functions at the top of the file and
303:52 - then a bit further down the actual code
303:55 - logic is written and that way you create
303:58 - some pretty good logic that is quite
303:59 - easy to follow and you can just change
304:01 - some functions here if you wanted to
304:04 - now with that we have basic functions
304:07 - although you can do quite a bit more
304:09 - with functions
304:10 - and the next part we have to talk about
304:12 - is arguments and parameters
304:15 - so let's talk about that in the next
304:17 - section
304:18 - so let's talk about parameters and
304:21 - arguments and let's do a quick recap
304:23 - because it's really important to
304:25 - understand these names
304:27 - when we are creating a function we are
304:29 - setting some parameters this would look
304:31 - like this for this function we are
304:33 - creating parameter one and we are
304:35 - creating parameter two and these
304:37 - parameters we can use like variables
304:40 - inside of the function so for example
304:42 - inside of the function we could print
304:43 - perimeter one and parameter 2.
304:46 - and again remember these parameters only
304:49 - exist inside of the function and now the
304:51 - next important step is when we are
304:53 - calling the function we are adding an
304:55 - argument to give the parameter a value
304:58 - which means when i call the function and
305:02 - i pass in hello and 42
305:06 - then the first argument is going to be
305:08 - assigned as the value to the first
305:10 - parameter and the second argument will
305:12 - become the value for the second
305:14 - parameter and after that we are using
305:17 - those two parameters like variables
305:19 - inside of the function
305:21 - and the output we would get in this
305:23 - example would be hello and 42
305:27 - and the basic thing you have to take
305:28 - away from this is that a parameter is
305:31 - basically a slot for an argument we are
305:33 - only using arguments when we are calling
305:35 - the function here and the parameters are
305:38 - the slots that we add the arguments to
305:41 - now there's one thing that we also have
305:43 - to talk about and that is how this
305:46 - ordering happens so how do we assign
305:49 - this hello to parameter one
305:51 - and by default arguments are being
305:55 - assigned to parameters via their
305:56 - position meaning the first argument is
305:59 - going to be assigned to the first
306:00 - parameter and the second argument to the
306:02 - second parameter and so on but there is
306:05 - another options and that is called
306:07 - keyword arguments and for this one you
306:10 - specified the specific parameter you
306:13 - want to add an argument to
306:15 - and let's have a look at this in
306:17 - practice that should explain this the
306:19 - best
306:20 - here again we have a completely empty
306:23 - sheet of code and i want to create
306:25 - another function that i called test
306:28 - function
306:29 - and right now i want to have argument 1
306:32 - argument 2 argument 3 and argument 4.
306:36 - and then inside of the function i just
306:38 - want to print
306:40 - all of these arguments so let me copy it
306:42 - a few times
306:44 - three and four
306:46 - and now
306:47 - when we are calling this test function
306:50 - i can add for example one i can add
306:53 - hello
306:55 - i could add true
306:57 - and let's say for a list i could add
307:00 - one
307:02 - to
307:03 - and
307:04 - test
307:06 - you can essentially pass anything you
307:08 - want as an argument inside of a function
307:11 - if i execute this function we get one
307:13 - hello true and a list
307:16 - now the problem we have here when we are
307:19 - using position to assign this argument
307:21 - to this parameter for example
307:23 - is that this can get messy really fast
307:27 - and i think you can already see this one
307:29 - here
307:30 - where it's kind of hard to tell where
307:32 - things belong to it's really starting to
307:34 - look messy
307:36 - and for arguments still is a fairly low
307:39 - amount imagine we had 20 arguments in
307:41 - here which isn't impossible so we want
307:44 - to have something to organize this a bit
307:46 - better and for that we have keyword
307:49 - arguments
307:50 - and what those are is well we're adding
307:54 - the name of the parameter in this case
307:56 - arg1
307:57 - and then we are assigning it a value
308:00 - like we are assigning values to a
308:02 - variable
308:03 - this in this case i want to do for all
308:06 - of these
308:08 - different arguments this would be
308:10 - argument 3 and this would be argument 4.
308:15 - and if i run this now we can see the
308:18 - very same result
308:19 - although here when we're using keyword
308:21 - arguments python does not care about the
308:24 - order for example
308:26 - i could assign argument 4 here and at
308:29 - the end
308:30 - i assign argument 1. if i run this now
308:33 - the first item so argument 1 that we are
308:36 - printing here is going to be this list
308:40 - and this would then be a clearer way to
308:42 - call your function
308:44 - what you can also do
308:46 - is to add this over multiple lines
308:48 - so i can do something like this
308:52 - and call all of this again and it would
308:55 - still work python here is quite smart
308:57 - and it understands that all of this is
308:59 - one function
309:01 - and this one here is actually fairly
309:03 - readable so even if we had more
309:05 - arguments this would be workable quite
309:07 - easily
309:09 - now what you can also do is combine
309:12 - positional and keyword arguments
309:14 - although you do have to be careful here
309:17 - and let me do one example
309:19 - let's say
309:20 - i want to assign argument 1 argument 2
309:22 - and argument 3
309:24 - via keyword arguments
309:26 - and then
309:27 - the final argument should just be a
309:29 - positional argument
309:31 - if i run the code now python is going to
309:33 - complain
309:35 - and the complaint here is positional
309:37 - argument follows keyword argument
309:40 - and this is a general rule you have to
309:43 - follow that positional arguments always
309:46 - have to come before keyboard arguments
309:49 - meaning this positional argument here
309:52 - would have to be before all of the
309:54 - keyword arguments
309:56 - let's say now i only want to have
309:58 - argument 1
310:00 - as a positional argument and all of the
310:02 - other arguments this one is arg4
310:06 - i want to have as keyword arguments if i
310:08 - run the code now this is working just
310:11 - fine
310:12 - and the basic reason why we have this is
310:15 - let's say i want to assign this argument
310:18 - here via position
310:20 - and right now this would be the fourth
310:23 - argument because this is the fourth item
310:26 - when we are calling the function
310:28 - problem is
310:29 - if i
310:30 - change this argument to to argument four
310:34 - then
310:35 - this
310:37 - keyword argument would also be
310:38 - referencing this argument for here and
310:42 - as a consequence python would get
310:44 - confused
310:46 - and if we have positional arguments
310:48 - before the keyword arguments this is
310:50 - somewhat mitigated
310:52 - although you could still mess this up
310:54 - for example if this first argument here
310:58 - is argument 1 and then the first keyword
311:00 - argument also references this arg1 and i
311:03 - run the code
311:04 - we are getting an error the test
311:07 - function got multiple values for arc 1.
311:10 - so you do have to be careful here but
311:13 - it's generally quite doable
311:15 - now with that we have positional and
311:17 - keyword arguments there's one more
311:19 - concept that i do want to cover and that
311:22 - is default arguments and the concept
311:25 - here is really simple
311:27 - let's say for this argument 4 if we
311:30 - don't get a value i want to assign a
311:32 - default value and this i do by simply
311:35 - adding an equal sign and now adding a
311:37 - value let's say for argument 4 i want
311:40 - argument 4. if i have this set up here
311:44 - i can get rid theoretically of this
311:47 - argument 4 comma function and now
311:50 - argument 4 is going to be argument for
311:53 - here or the parameter value is going to
311:56 - be this string
311:57 - and what you could even do if you really
312:00 - wanted to you could assign a default
312:02 - argument
312:04 - to all of your parameters
312:06 - that would look like this i hope i
312:08 - didn't forget anything
312:10 - and now you could call the function
312:12 - without a single argument and it would
312:15 - still work just fine
312:17 - although this again becomes kind of hard
312:19 - to read but sometimes this can be quite
312:22 - useful
312:23 - now let's do an exercise
312:27 - and let me copy in what i want you guys
312:29 - to do it's getting a bit long
312:33 - so i want you guys to create a greeter
312:35 - function with free arguments oh well
312:37 - free parameters we have person greet and
312:40 - weekday person and greed should have
312:44 - default arguments person for the person
312:46 - parameter and hello for greet
312:49 - and inside of the function use an f
312:52 - string to print the greet and the person
312:54 - and also print the weekday
312:56 - and when you're calling the function use
312:58 - at least one positional argument and one
313:00 - keyword argument
313:02 - and pause the video now and implement
313:04 - all of this yourself
313:09 - i want to create my function all the way
313:11 - at the top below my test function
313:14 - and the function name is greater
313:18 - and in here i want three parameters let
313:20 - me actually fix this one three
313:22 - parameters
313:25 - i want to have person i want to have
313:27 - greed and i want to have the weekday
313:30 - and with that we have covered the entire
313:32 - first line
313:34 - now next up for person and greed we want
313:36 - to have default arguments for person
313:39 - this should be person
313:42 - and for greed
313:44 - this should be
313:45 - hello
313:47 - and now inside of the function
313:51 - i want to print
313:52 - an f string and that is the third line
313:55 - of the exercise
313:56 - and in here
313:58 - i want to print
314:00 - the person
314:02 - and i want to print the greet and i
314:06 - guess on top of that we can print
314:09 - another f string and in here let's say
314:12 - it is
314:14 - the weekday
314:16 - and now with that we only have to call
314:20 - the function and let me comment out the
314:22 - test function
314:23 - and instead
314:25 - i want to call my greed turf
314:29 - and now we need one positional and one
314:31 - keyword argument
314:33 - let's say the first argument has to be
314:35 - positional because remember position
314:37 - arguments come before keyword arguments
314:40 - and let's say the person then is going
314:43 - to be bob for me now next up we need a
314:46 - keyword argument and for this one i want
314:48 - to go with weekday
314:51 - and let's say it's tuesday
314:53 - and now since greed has a default value
314:57 - this should be all we need
315:00 - so if i run this we are getting an error
315:03 - and the error here is that non-default
315:05 - argument follows a default argument
315:08 - meaning python is unhappy that we have a
315:10 - default argument a default argument and
315:13 - then no default argument
315:15 - and this again can cause confusion in
315:17 - terms of what
315:18 - argument we are assigning to what
315:20 - parameter
315:21 - and i guess in our case to fix it
315:24 - for the weekday we can also assign a
315:27 - default argument let's say monday is our
315:30 - default weekday
315:32 - so now if i run this this function is
315:34 - working just fine
315:36 - and i can assign arguments via keyword
315:40 - arguments so i have person weekday and
315:44 - for greed let's say i can say
315:47 - welcome
315:48 - this would also work
315:50 - and i can also use positional arguments
315:53 - to assign the values like so
315:57 - and if i run this we would get something
315:59 - slightly weird because now we are
316:02 - assigning this tuesday here to this
316:05 - greet so you do have to be careful
316:07 - but at the very least this is working
316:10 - and i guess let me put this exercise
316:13 - on top of the greeter so it's a bit
316:15 - easier to read
316:16 - and right with that we have some default
316:20 - arguments and keyword and positional
316:22 - arguments
316:23 - the main thing you should be taking away
316:24 - from this video is how you assign
316:26 - arguments to parameters understanding
316:28 - that is really important to use
316:30 - functions
316:32 - we can actually do some more things with
316:34 - arguments so let's put this in the next
316:37 - section okay so let's talk a bit more
316:39 - about parameters and arguments and the
316:42 - main question we have to answer for this
316:44 - part is what if you don't know the
316:47 - number of arguments
316:49 - can you still make a function
316:51 - and the answer for that is absolutely
316:53 - yes although we do have to learn some
316:55 - new things and let's do this trading
316:57 - code
316:58 - here i have a completely empty file and
317:01 - i want to create a new function that i
317:04 - want to call print all
317:06 - and this function
317:08 - should take an unlimited number of
317:10 - arguments
317:11 - and then inside of the function i want
317:13 - to print all arguments
317:17 - but the problem is i don't know how many
317:19 - arguments i am going to get now one
317:23 - thing that you might have already
317:24 - figured out you could add some parameter
317:27 - called arguments
317:28 - and this arguments would be a list
317:31 - meaning if i run print all
317:34 - and add a list in here with let's say
317:36 - one two three four five and hello
317:40 - now inside of the function i could run
317:43 - for argument that is not how you spell
317:46 - that
317:47 - in arguments and i want to print
317:51 - the
317:51 - argument
317:53 - and this is indeed working
317:56 - via the list we can basically add as
317:58 - many arguments as we want
318:01 - and this would still be working just
318:02 - fine there's no limit on this
318:05 - although this is kind of annoying to
318:08 - work with
318:09 - and because of that python has a special
318:12 - way to work with unlimited arguments and
318:16 - this is called let me add a comment here
318:19 - it is called list unpacking
318:22 - and how this works is we are adding a
318:25 - star
318:26 - before the parameter that we want to
318:29 - unpack
318:30 - and now what i can do when i'm calling
318:32 - the function i can remove this list here
318:35 - and just have unlimited values and if i
318:38 - run this now we are getting the same
318:40 - result
318:42 - so what is happening here and i think
318:45 - the best way to understand this is just
318:47 - to print what we get so let me print the
318:50 - arguments
318:52 - and run the code again
318:53 - and now you can see
318:55 - we have a tuple with all of these values
318:58 - here and then later on inside of the
319:00 - function we are just looping over this
319:02 - tuple and printing each item inside of
319:05 - it that's all that's happening in here
319:08 - and that is essentially all the
319:10 - unpacking operator does it looks at all
319:13 - of the arguments we potentially have and
319:16 - then return all of them as a tuple and
319:19 - we can use it along with other
319:21 - parameters
319:22 - for example if i added another parameter
319:24 - here let's call it first
319:27 - i want to print my arguments and i want
319:29 - to print first and let's see what we get
319:32 - we get one and then we get all of the
319:35 - other items
319:36 - meaning what happened
319:38 - in
319:39 - this function call here
319:41 - python sees that this one here
319:44 - is the first position argument and we
319:47 - have one parameter so python is putting
319:50 - this one in there and then it sees
319:53 - we have
319:54 - a list unpacking arguments and we have a
319:57 - ton of arguments here so all of these
320:00 - are being stored in this arguments as a
320:02 - tuple
320:04 - and once we have that we can work with
320:06 - them inside of the function
320:08 - and this would also work
320:11 - with a parameter after the list
320:14 - unpacking although for this one here
320:17 - we would need keyword arguments so let
320:20 - me print
320:21 - the extra parameter here the one that
320:24 - comes after the list unpacking
320:26 - if i run this now
320:28 - we have print all is missing one
320:30 - required keyword only argument extra
320:33 - and python here is quite specific
320:36 - we want a keyboard argument for extra
320:39 - and this extra here since it comes after
320:42 - the unpacking has to be a keyboard
320:44 - argument
320:45 - the reason for that is that python by
320:47 - default doesn't know when this list
320:49 - unpacking ends and when this parameter
320:52 - starts
320:53 - but well we can fix that quite easily
320:56 - let me remove the error message
320:59 - i can assign extra another value let's
321:01 - say 12 and remove this 12 here if i run
321:04 - this now this would be working again
321:07 - and here are the values we are getting
321:09 - and with that we have simple list
321:12 - unpacking
321:13 - and now we can essentially add unlimited
321:15 - numbers of arguments inside of our
321:17 - functions
321:19 - now this you can actually make even more
321:21 - powerful
321:22 - and how this would be working
321:25 - is with
321:26 - keyword unpacking
321:29 - and for that let's create another
321:31 - function and this let's call it print
321:34 - more and here i again want to have my
321:37 - arguments
321:38 - and those i want to unpack
321:41 - but now i want to unpack them again
321:44 - and those i want to unpack but now i
321:46 - want to use two stars and you see in a
321:48 - second why
321:49 - and i guess inside of this function
321:52 - let's just print the arguments of what
321:54 - we are going to get
321:56 - and let me comment out print all
321:59 - and let's call print more what this
322:03 - double star arguments does is it looks
322:06 - for keyword arguments and then unpacks
322:08 - all of them inside of a dictionary
322:11 - so we have arg1 could be one
322:14 - then we have arc 2 is going to be test
322:19 - and finally we have arg3 is going to be
322:23 - let's say a list with 1 2 and 3.
322:26 - if i run this now
322:28 - we get a dictionary with three key value
322:31 - pairs
322:32 - we have arc one with the value one arc
322:34 - two with test and arc three with a list
322:38 - and those are the three arguments we
322:40 - passed in here or keyword arguments to
322:42 - be more specific and we're getting this
322:45 - dictionary because of this double star
322:47 - here
322:48 - now so far we haven't really learned how
322:50 - to work with dictionaries so we don't
322:53 - really know how to use this dictionary
322:55 - but we're going to learn about that in
322:56 - the next major section so for now don't
322:58 - worry too much about this but we are
323:00 - going to work with this quite a bit more
323:02 - later on when we learn more about
323:04 - dictionaries for now all you have to
323:06 - understand is if we're using double star
323:09 - and arguments then we get all of our
323:12 - keyword arguments as a dictionary
323:15 - returned in our function
323:17 - and what you can also do finally is
323:20 - combine these arguments or the list
323:22 - unpacking arguments and the keyword
323:24 - unpacking arguments inside of one
323:26 - function
323:27 - and for that let's create a final
323:29 - function let's call this one print
323:32 - even
323:33 - more
323:34 - and in here
323:36 - i want to have my arguments and i want
323:38 - to have my keyword arguments
323:42 - and these arcs and quarks is what you
323:44 - see quite often it's just a shorthand
323:46 - for arguments and keyword arguments
323:49 - and now inside of this function we could
323:51 - basically pass in whatever we want it
323:54 - would all be captured by these two
323:56 - parameters
323:57 - let me print the arcs
323:59 - and the quarks
324:02 - and now
324:04 - i can comment out this function call and
324:08 - add print even more
324:11 - and now in here i can just add whatever
324:14 - i want let me add hello
324:17 - and
324:18 - true
324:20 - and then besides that i can also add i
324:23 - know test is going to be one
324:25 - test two is going to be five whatever
324:28 - you want in here and now if i execute
324:30 - the code we get a tuple from the arcs
324:33 - parameter and the dictionary from the
324:35 - quarks parameter
324:37 - and even if you didn't add anything in
324:39 - here
324:40 - so if i didn't have any keyword
324:42 - arguments
324:44 - it would still work i would just get an
324:45 - empty dictionary and that means if you
324:48 - have this kind of setup as long as you
324:50 - add any kind of parameter that is valid
324:52 - python code into the function you are
324:55 - going to execute that function or at
324:56 - least you're not going to get an error
324:58 - in this stage of the code
325:00 - and well with that we have covered some
325:02 - really powerful stuff
325:04 - and let's practice it actually and what
325:07 - i want you guys to do let me add an
325:10 - exercise down here
325:13 - and what i want you guys to do let me
325:15 - paste it in here i want you guys to
325:17 - create a calculator function that prints
325:20 - the sum of an unlimited number of
325:22 - numbers or what a limited amount of
325:24 - numbers so pause the video now and try
325:27 - to figure this one out yourself
325:32 - all right let me paste this exercise
325:35 - here so we have all of our function at
325:37 - the top of the code
325:38 - and i want to create a new function that
325:41 - i'm going to call calculator
325:43 - and in here we want to have an unlimited
325:46 - number of numbers so i want the tuple or
325:49 - the list unpacking operator and let's
325:51 - call it args
325:53 - and now essentially what i am going to
325:56 - get in here is a list let's actually
325:58 - print it so i want to print my arguments
326:02 - and now let me comment out this function
326:05 - here
326:06 - and i want to have my calculator
326:09 - and add a random amount of numbers
326:12 - if i run this now
326:13 - we are getting a tuple with the numbers
326:15 - we are passing into it that's a really
326:18 - good start
326:19 - what we have to figure out now is to get
326:21 - the sum of all of these numbers
326:23 - and this we can actually do quite easily
326:27 - but let me do it over two lines so it's
326:29 - a bit easier to read
326:31 - i first of all want to create a new
326:33 - variable let's call this one the result
326:36 - and the result is going to be the sum of
326:39 - my arguments
326:40 - remember here this argument or these
326:43 - arcs is going to be a tuple and tuples
326:46 - can be used with the sum function and
326:49 - the sum function is just going to return
326:51 - the sum of all the numbers inside of
326:54 - that list this list here in our case
326:57 - and once i have that i want to print the
327:00 - result
327:01 - so now if i run this and we are getting
327:04 - 21 this seems accurate
327:06 - if you wanted to be more efficient with
327:08 - your code you wouldn't actually need
327:09 - this result here
327:11 - so you could just print
327:14 - some of the arguments and not the result
327:17 - at all let me comment it out
327:19 - this one would also work just fine
327:22 - although the earlier one was a bit
327:24 - easier to read so let's stick with this
327:25 - one
327:27 - and with that we have a function that
327:28 - uses list unpacking
327:30 - alrighty welcome back in this part we
327:33 - are going to talk about functions and
327:35 - scope
327:36 - which can be a really annoying but very
327:40 - important topic
327:41 - basically what it means is that
327:43 - variables created inside of a function
327:46 - are only available inside of that
327:49 - function
327:50 - and this is called a local scope
327:53 - and if we are creating variables outside
327:55 - of a function we are creating a variable
327:58 - in the global scope
328:00 - and the problem a lot of beginners have
328:02 - is to combine the local and the global
328:05 - scope and i think all of this is going
328:07 - to sound a bit cryptic so let's do this
328:09 - in a bit more of a practical way here we
328:12 - have a completely empty python file and
328:14 - i want to create a variable i called a
328:17 - and assigned a value 10. it doesn't
328:19 - really matter what it is
328:20 - and after that i want to create a
328:23 - function let's call it test func
328:26 - we don't need any parameters and in here
328:29 - i want to print
328:31 - a
328:32 - and this is going to work if i print
328:35 - test func i can run this we get 10 all
328:38 - of this is working perfectly fine and
328:40 - there are no problems whatsoever
328:43 - however now
328:45 - we can do something weird
328:47 - let's say i want to get a and add some
328:50 - kind of value to it let's say 2.
328:53 - if i now run the code we are getting an
328:56 - error and the error we get is a local
328:59 - variable a
329:01 - was referenced before the assignment
329:05 - now to understand that we have to
329:07 - understand the local and the global
329:09 - scope
329:10 - and this a here is a global variable
329:14 - and we know it is a global variable
329:16 - because it was not created inside of a
329:18 - function it is just there by itself
329:21 - however this test function has a local
329:25 - scope
329:26 - and the reason why we got an error is
329:29 - because when we are creating a variable
329:32 - like this a inside of the function
329:34 - we are creating a new variable inside of
329:37 - the scope of this function only here
329:41 - and since we are now adding a value to
329:44 - it when we are creating it python gets
329:45 - confused because there is no original
329:48 - value at least according to python what
329:50 - we could be doing is set this a just to
329:53 - 2 and now run this again and this is
329:56 - going to work and now this might be even
329:58 - more confusing because now we have an a
330:01 - inside of the function and an a outside
330:04 - of it and to python
330:06 - those two
330:07 - are completely separate variables there
330:09 - are no connections for python and the
330:12 - reason why there is no connection is
330:14 - again because this is a local scope of
330:17 - the test function and all the variables
330:20 - we are creating inside of it only exist
330:22 - inside of this function
330:24 - meaning what i could also do now is
330:27 - create another function let's call it
330:29 - test func
330:31 - 2
330:32 - and in here again i can create variable
330:35 - a again let's give it another value 200
330:39 - and print a again
330:41 - and now i can run test func 2
330:45 - and run all of this and now the value
330:49 - for this a here
330:51 - is going to be 200 the one we are
330:54 - getting down here
330:56 - and again the reason why this works is
330:58 - that each of these functions have their
331:00 - own local scope
331:02 - and on top of that we have this global
331:05 - variable here
331:06 - and understanding scope does take some
331:09 - time but there's one really important
331:11 - thing i do want to cover
331:13 - and that is that functions are supposed
331:16 - to be separate from the rest of the code
331:18 - this scope isn't a necessity it's by
331:21 - design
331:22 - and the reason is that once the code
331:25 - becomes more complex it is really easy
331:28 - to run out of variable names which can
331:30 - be very annoying for example for the car
331:33 - we have we could have one function for
331:35 - the battery and one function for the
331:37 - tank and both might have some kind of
331:40 - capacity variable
331:42 - and because of the local scope this is
331:44 - perfectly fine we can reuse that word
331:47 - if we didn't have functions we would
331:49 - have to play around with that like
331:51 - capacity battery capacity tank but then
331:54 - if we have more more capacities this
331:56 - gets really annoying and this is one of
331:59 - the main reasons for scope inside of
332:01 - functions that we want functions to be
332:04 - separate from each other so we can focus
332:06 - on one function at the time
332:08 - so let me put it in red local scopes
332:10 - inside of a function help us keep things
332:13 - organized especially later on when we
332:15 - are writing more complex code this is
332:17 - becoming incredibly important and
332:19 - incredibly useful as well
332:22 - but right still when you get started
332:24 - with this it's very very annoying so
332:26 - let's talk about the rules of scope they
332:29 - are not that complicated
332:31 - the first one is that every function has
332:33 - its own local scope and every local
332:36 - scope is separate
332:38 - and let's play around with that one
332:41 - and this we have actually already seen
332:42 - in practice we have test func here and
332:46 - testfund2 and both of those have the
332:49 - variable a inside of them and this
332:52 - variable a is completely separate for
332:54 - each function
332:56 - and i guess just to keep with the
332:58 - example from earlier
332:59 - this could be something like capacity
333:02 - and i could print that capacity as well
333:07 - and we will get different numbers
333:10 - and i am probably repeating myself but
333:12 - this capacity here for example only
333:15 - exists inside of this function here
333:19 - and this also means i couldn't print
333:22 - capacity or well i could but python
333:24 - would give me an error that name
333:25 - capacity is not defined
333:28 - and the problem here
333:30 - is that this capacity we are trying to
333:33 - print in the global scope
333:36 - but capacity does not exist in the
333:39 - global scope so i can't do that i can
333:42 - only print capacity inside of the local
333:44 - scope of the test function because in
333:46 - there it does exist
333:49 - and well that is the first rule of scope
333:52 - inside of a function
333:54 - for number two we have global variables
333:57 - and those can be accessed in the local
333:59 - scope but they cannot be changed or
334:01 - created at least not by default
334:04 - and let's have a look at this one and
334:06 - practice a bit more this one is really
334:08 - important
334:10 - and let me comment out all of this so we
334:13 - have an easier example
334:15 - and this is actually what we have seen
334:16 - earlier so let me run
334:19 - test func let's call it test function to
334:22 - keep things a bit more organized
334:24 - when we started this part i just printed
334:27 - a and this did work meaning now
334:31 - if i run test func 3
334:34 - we get 10.
334:36 - and what happened here is we are
334:38 - creating a variable inside of the global
334:40 - scope and then inside of the local scope
334:43 - of the test function we are printing
334:45 - this and if we are running all of this
334:48 - we don't get an error and we are
334:50 - printing the global variable this is
334:53 - working just fine
334:55 - and the reason why it is working is
334:57 - because we can access global variables
335:00 - inside of a function
335:02 - however what we cannot do
335:04 - is update the value
335:06 - meaning we couldn't do something like a
335:09 - plus equals two because then we are
335:11 - updating the value which python doesn't
335:13 - like
335:14 - now with that we have the problem of
335:17 - scope the question now is how can we
335:20 - solve it
335:21 - and for that we can use parameters
335:24 - global and return
335:27 - and parameters we have already seen it's
335:30 - just normal function parameters and
335:32 - those allow us to pass global variables
335:34 - inside of the local scope of a function
335:37 - the more interesting ones
335:39 - are global and return
335:42 - and i do want to emphasize straight away
335:44 - that global is a very easy solution to
335:47 - scope but not a good one you will see in
335:49 - a second why but the one you want to use
335:52 - the most is return this one is much
335:54 - better and global you generally want to
335:57 - avoid
335:58 - but let's actually have a look at how
335:59 - they work
336:01 - the first way to overcome the local
336:04 - scope of a function is by declaring a
336:06 - variable to be global and this you do by
336:09 - just typing global and then the name of
336:12 - the variable you want to declare as
336:14 - global in my case a
336:16 - and now if i run this this is working
336:19 - just fine
336:20 - the reason why it is working just fine
336:22 - is because when python now sees this a
336:25 - plus equal to
336:27 - we are telling it that this a is a
336:29 - global variable
336:31 - which means python is now looking in our
336:33 - global scope for the variable a
336:36 - and then we're using that value
336:38 - and if you really wanted to
336:41 - you could declare global all of your
336:44 - local variables inside of every function
336:46 - you ever write and then never worry
336:47 - about scope ever again
336:49 - which i guess would be possible but a
336:52 - really bad solution you are supposed to
336:55 - be using a local scope and keep
336:56 - variables inside of that
336:59 - which is why global is not really used
337:02 - that often and when it's used it's not
337:04 - really looked at favorably upon you
337:07 - generally want to avoid it
337:09 - a better way would be using parameters
337:11 - and return
337:12 - and parameters we have already seen
337:15 - so for this test function we can just
337:17 - create a parameter let's call it a as
337:19 - well and now when i'm calling this test
337:22 - function free i want to pass in my
337:25 - and if i run this now we are getting 12
337:28 - again
337:29 - meaning if you want to update a global
337:32 - variable inside of a function
337:35 - you would want to use a parameter
337:37 - that is generally how you get global
337:39 - variables inside of a function and then
337:41 - work with them and to get values outside
337:44 - of a function
337:45 - you usually want to use the return value
337:49 - and in my case for this function i want
337:51 - to return the value a
337:54 - and this return is the same return that
337:57 - basically anything in python does it's
337:59 - just a custom implementation of that
338:01 - principle
338:02 - meaning if i have that
338:04 - i can comment out my print a and now
338:07 - when i run this function it is going to
338:09 - return the value of this a
338:12 - i could for example print it and if i
338:15 - run this
338:16 - i get 12 again or 10 plus 2.
338:20 - and just to go over what's happening
338:22 - here
338:23 - i first declare a 10 inside of the
338:25 - variable a inside of the global scope
338:28 - then this a i pass into the function so
338:31 - we have a parameter inside of the
338:33 - function that is local to this function
338:36 - only
338:37 - and to this value we are adding the
338:39 - integer 2.
338:41 - and after we are doing this
338:43 - we are returning this new value
338:47 - and then this value is being printed
338:50 - with the print function and we are
338:52 - getting 12
338:53 - and all of this is working really well
338:57 - and if you wanted to update this value
338:59 - here you could even do something like a
339:02 - equals the test function with a
339:05 - and now we could print a
339:07 - and get the same result
339:09 - and this is then how you would actually
339:12 - want to work with functions that you're
339:14 - using parameters and a return statement
339:17 - to keep everything inside of the
339:18 - function organized and separate from the
339:20 - rest of the code
339:23 - and especially for beginners this is
339:25 - generally something kind of confusing so
339:27 - i guess when you are just getting
339:29 - started using global can be okay
339:31 - sometimes but you generally want to
339:33 - rather use return it is a much cleaner
339:36 - way
339:37 - all right let's do an exercise on all of
339:40 - this and let's see how well you
339:41 - understand it
339:43 - and basically what i want you guys to do
339:45 - let me copy all of it
339:48 - i want you guys to create two global
339:50 - variables called multiplier and has
339:52 - calculated
339:54 - multiplier should have an integer and
339:56 - has calculated should be set to the
339:58 - boolean false what integer you set is
340:01 - entirely up to you i really don't care
340:03 - after you have done that create a
340:05 - function called multiply calculator in
340:07 - this one should take one argument and
340:09 - then calculate the multiplication
340:12 - let me put this on another line
340:14 - it simply multiplies that number that's
340:17 - just about it
340:18 - all you really have to do is inside of
340:20 - the function multiply the parameter with
340:22 - the global variable multiplier
340:25 - and once the calculation is done set has
340:28 - calculated to true and that is this
340:31 - global variable has calculated
340:34 - then store the new number in a variable
340:36 - called result and return it from the
340:38 - function and finally print a return
340:41 - value of the function after it was
340:43 - called with the number
340:45 - okay um probably read for this a couple
340:47 - of times it's a tiny bit longer but
340:50 - pause the video now and try this one
340:52 - yourself
340:56 - alrighty let's do it together now and
340:58 - let me comment out all of this at the
341:00 - beginning so we don't get confused
341:03 - first of all i have to create two global
341:06 - variables
341:07 - one is called multiply
341:11 - and this one i want to set to an integer
341:13 - let's say 5.
341:15 - and after i have that i want another
341:17 - variable called has calculated and this
341:21 - one by default is going to be false and
341:24 - with that we have these two parts
341:27 - already covered
341:29 - next up i want to create a function
341:32 - called
341:33 - mold
341:34 - supply
341:36 - calculator
341:39 - and this one takes one argument so it
341:42 - needs one parameter
341:44 - let's call it number
341:46 - meaning now we are basically here
341:49 - so next up i want to do this step here
341:53 - i want to multiply
341:55 - my number
341:56 - with my multiplier
341:59 - and this is perfectly fine for python
342:01 - because remember
342:02 - we can use global variables inside of
342:05 - the local scope
342:06 - so this multiplier here is from the
342:09 - global scope so we can use it but we
342:12 - couldn't update it
342:14 - but next up we have to take care of the
342:17 - has calculated and set it to true this
342:20 - part here
342:22 - and for that
342:23 - i want to set has calculated to
342:26 - true
342:28 - but here now we have the problem this is
342:31 - the local scope so we cannot update this
342:34 - global variable here
342:36 - and i guess for now the easiest way of
342:38 - doing this would be to set global has
342:41 - calculated
342:43 - and well with that we have this part
342:46 - covered here now next up
342:48 - we have to store the new number
342:50 - generated inside of a variable called
342:52 - result and return it
342:55 - and all i really want to do in here is
342:58 - the result
343:01 - is the result of well this operation
343:04 - here
343:04 - and let me put this
343:06 - below has calculated that feels a bit
343:08 - cleaner
343:10 - and now what i want to do is to return
343:13 - that result
343:14 - meaning whenever we call this
343:16 - multiplication function
343:18 - we are returning this value here
343:21 - and this i want to use
343:23 - with print and i want to
343:27 - multiply calculator
343:29 - and in here i can add any number i want
343:31 - let's say 10 and let's see what we get
343:34 - 50
343:35 - which is 10 times 5. so this is working
343:38 - just fine
343:40 - and what i can also do now i can print
343:43 - as calculated and this is now true
343:46 - so as soon as we're calling this
343:48 - function
343:49 - this is being updated
343:51 - although there's one really important
343:53 - thing about the return statement that i
343:55 - forgot to mention earlier and that is
343:57 - that return ends the execution of the
344:00 - function
344:01 - for example if has calculated is after
344:04 - return and i run this again has
344:07 - calculated is still false
344:09 - because this has calculated is equal to
344:12 - true is not being executed
344:15 - and that happens because return ends
344:17 - this function call the function
344:19 - essentially ends here
344:21 - this is something you do want to be
344:23 - careful about
344:24 - but right with that we have scope and
344:28 - again scope very early on can be kind of
344:31 - a tricky topic so i hope all of that
344:33 - makes sense
344:34 - but for now don't worry too much about
344:37 - it just play around with different
344:38 - examples of code and come back to this
344:40 - video when you get to something more
344:42 - complex
344:43 - it will become more important and i hope
344:45 - eventually starts to make more sense for
344:48 - this part we are going to cover lambda
344:51 - functions and lambda functions are
344:54 - fortunately fairly simple
344:56 - all they really are are single line very
344:58 - simple functions
345:00 - and the syntax for them looks like this
345:02 - we have
345:04 - the lambda keyword then we get whatever
345:07 - parameters we want to use
345:09 - and then we have a colon
345:12 - and at the end we have an expression and
345:14 - this is the actual code
345:16 - that's really all it does it's a single
345:19 - line function if you have some very
345:20 - simple functions you want to work with
345:22 - and you don't really want to write a
345:24 - whole function
345:25 - this for example could look like this
345:28 - where we have lambda then we have an x
345:31 - parameter and inside of the function we
345:33 - are just adding x plus 1. and an
345:36 - important thing about lambdas is that
345:39 - the result of this expression this one
345:42 - here is returned automatically meaning
345:45 - when we are passing 10 in here this
345:47 - lambda function returns 11 automatically
345:51 - and i guess let's have a look at this in
345:53 - practice this shouldn't be too hard
345:55 - all right once more we have a completely
345:58 - empty python file and i want to create a
346:00 - lambda function
346:02 - and let's use the example i've just
346:04 - mentioned
346:05 - so i have a lambda function
346:09 - and the one parameter i want to use is x
346:12 - and what i want to return is x
346:15 - plus one
346:16 - and this is then the entire function
346:19 - how you would use this is by assigning
346:21 - it to a variable
346:24 - and this variable now contains a
346:26 - function meaning we can call it by using
346:30 - brackets again and passing in any number
346:32 - we want let's say a 10
346:34 - and if i run the code now we don't get
346:36 - anything because we have to print this
346:40 - value
346:41 - let me print it and we get 11.
346:44 - and that is the main idea of lambda
346:47 - functions it's basically very very
346:50 - simple functions that only consist of
346:52 - one line of code
346:54 - i guess a slightly more useful one could
346:56 - be let me copy this one here let's call
347:00 - this one simple calculator
347:03 - and for this lambda i want a and b
347:06 - and all i really want to do is return a
347:09 - plus b
347:11 - meaning now i can call my simple
347:13 - calculator and pass in let's say two and
347:16 - three if i run this we get five
347:19 - obviously right now these examples are
347:22 - so simple that you wouldn't even create
347:24 - a function for it in the first place
347:27 - i guess instead of this simple
347:28 - calculator you just write 2 plus 3 and
347:31 - you would get the same result if you can
347:33 - type properly
347:35 - so why would you ever use these kind of
347:37 - lambda functions
347:39 - and there are two main reasons that we
347:42 - don't really are going to cover in too
347:44 - much detail
347:45 - the first one is that some functions
347:49 - want our functions as
347:52 - argument
347:53 - and this is something we are going to
347:55 - see later for example python has a sort
347:59 - function and this one sorts any kind of
348:01 - list for example a list like one two
348:03 - three four and five
348:05 - and we could sort this if it was
348:07 - unordered let me mess it up a bit
348:11 - to something like this
348:14 - to order this function python is
348:16 - expecting another function to tell it
348:18 - how to order this list
348:20 - and this function
348:22 - would usually be a lambda because we
348:25 - don't want anything too complicated we
348:28 - are going to cover this later on the
348:30 - other examples where you see lambdas
348:32 - fairly often is with graphical
348:36 - user interfaces
348:39 - and essentially what happens in there is
348:41 - that every button gets one lambda
348:43 - function because a button would only
348:45 - return a value like 5 for example so you
348:48 - don't really want a full function you
348:50 - just want some very simple line of code
348:52 - that executes some basic thing when a
348:54 - button is being pressed
348:56 - so this could be really useful but for
348:58 - this introduction to python we are not
349:00 - going to cover it
349:01 - but alright with that let's do an
349:04 - exercise and then we should be done with
349:06 - it
349:08 - and for the exercise
349:10 - i want you guys to create a lambda
349:12 - function that accepts one argument that
349:14 - should be an integer
349:16 - and if the integer is greater than 5
349:18 - return hello and otherwise return by
349:22 - and then obviously
349:23 - when you have created this call this
349:25 - function and print the result
349:30 - let me comment out these lambda
349:32 - functions here and i want to create a
349:35 - new lambda function that accepts one
349:38 - argument let's call this one x for the
349:40 - parameter name
349:42 - and now
349:43 - i want to return hello if this x is
349:47 - greater than 5
349:48 - and by if it is below 5
349:51 - and for that i want hello
349:54 - if x is greater than 5 and if that is
349:58 - not the case so else i want to print by
350:02 - and this lambda function i now want to
350:05 - assign to a variable let's call it x but
350:07 - it doesn't really matter what it is
350:10 - and now i can print my x
350:13 - and pass in a free we get by and if i
350:17 - pass in a 10 we get hello
350:20 - and with that we have covered lambdas
350:22 - they honestly aren't that difficult and
350:25 - you really aren't going to use them that
350:27 - often so don't worry too much about them
350:30 - all right next up we have one final
350:32 - topic for functions that is actually
350:34 - really important although it might not
350:36 - seem that much
350:38 - for this part we are going to talk about
350:40 - documenting functions
350:42 - and this is incredibly important
350:45 - although we are not adding more
350:47 - functionality
350:48 - all we are doing in here is explaining
350:51 - what our function does
350:53 - and this might not seem important but it
350:55 - really is
350:57 - because functions can get really
350:59 - complicated so you want to explain them
351:02 - and this is something you are going to
351:04 - notice when you are starting to code
351:06 - where you are writing a function and
351:08 - then don't look at it for a couple of
351:10 - weeks
351:10 - you probably have absolutely no idea
351:12 - what you did
351:14 - and when you look at other people's code
351:16 - it might be even worse and well
351:18 - explaining what your function does is
351:20 - just good form and really helps you when
351:23 - you work with other people
351:25 - and there are two things you can do to
351:26 - your functions to explain what they do
351:29 - the most common one is you just add some
351:32 - explainer text and this is called a docs
351:34 - string
351:35 - and besides that you can also add what
351:38 - is called type hinting and all that
351:40 - really means is you indicate what you
351:42 - expect for the parameters and for the
351:44 - return value of the function
351:46 - and if you have all of that your
351:48 - function should make quite a bit more
351:50 - sense
351:51 - so
351:52 - let's implement all of this all right
351:55 - here we have a very simple example of a
351:58 - function if i run this we are just
352:00 - printing two arguments so
352:03 - obviously this isn't complicated but i
352:05 - just want to keep it simple
352:07 - and to explain what your function does
352:10 - you can add what is called a dog string
352:13 - at the beginning of a function
352:16 - and a dog string you create with
352:19 - quotation marks like any other string
352:22 - and for a dog string you always want
352:25 - three quotation marks on each side it
352:28 - looks like this and sublime essentially
352:30 - turns this into a comment by default
352:33 - and now for this dock string you can
352:35 - write whatever you want or well whatever
352:37 - explains your function the best
352:39 - let's say i could call this one a simple
352:42 - function that prints two
352:45 - parameters
352:47 - and if i run the function we don't see
352:51 - any difference
352:52 - however now what you can do you can
352:55 - print
352:56 - the name of the function test in my case
352:59 - then dodge
353:00 - underscore underscore dock and
353:03 - underscore underscore again
353:06 - and if i run this
353:08 - i get the docs string of the function or
353:11 - a simple function that prints two
353:12 - parameters
353:14 - now why we're using two underscores
353:17 - before and after this dog you are going
353:19 - to understand later on for now just
353:22 - write it like this it really isn't too
353:24 - important for you right now just
353:26 - remember how it looks like
353:28 - i suppose another way you could be
353:30 - accessing this is by writing help and
353:32 - then test
353:34 - and if i run this
353:35 - we get some more information about the
353:37 - function
353:39 - and in here we also can see the docs
353:41 - string a simple function that prints two
353:43 - parameters
353:44 - and it is fairly common to use either of
353:46 - those to understand what a function does
353:50 - meaning if you write code with a team
353:52 - you really want to use this
353:54 - but well that's basically it it isn't
353:57 - that complicated
353:59 - now besides that what you can also do is
354:02 - to hint what you are expecting for these
354:05 - parameters and what the function should
354:07 - return
354:08 - and right now this function doesn't
354:10 - return anything so let's add return a
354:14 - plus b
354:16 - and now i want to indicate that for
354:18 - these parameters i am expecting integers
354:23 - all you have to do for that is to add a
354:25 - colon after the parameter and then add
354:28 - integer
354:29 - if you wanted to you could also set a
354:32 - default parameter for this and this you
354:34 - do in a normal way by just adding an
354:36 - equal sign and let's say 10 for this
354:38 - value
354:39 - and all this really means i am telling
354:41 - other programmers that for this a
354:43 - parameter i am expecting an integer and
354:46 - by default this parameter is going to be
354:48 - 10.
354:50 - and for b i also want an integer but i
354:53 - don't have a default value and with that
354:57 - we have some default parameters where we
354:59 - are indicating that we are looking for
355:01 - integers
355:03 - and let's say for b i want the default
355:05 - value of 0.
355:07 - and with that we are indicating to other
355:10 - programmers that we want two integer
355:13 - values that both have a default
355:14 - parameter
355:16 - meaning if i run the code now
355:18 - we can't see well not much of a
355:20 - difference
355:21 - because this isn't supposed to influence
355:23 - what the function actually does
355:26 - and besides that we can also indicate
355:29 - what is being returned from this
355:30 - function so this line here
355:33 - and this could do by adding an arrow
355:36 - after the function but before the colon
355:38 - that's really important
355:40 - and then here you again add the name
355:42 - of
355:43 - the type
355:45 - and here again use the name of the type
355:48 - you want to return for an integer this
355:50 - would be int i guess other data types
355:53 - could be str for string
355:55 - bool for a boolean
355:58 - list for well a list
356:01 - and dictionary for a dictionary
356:04 - but in my case i want to stick with an
356:06 - integer
356:07 - and now i can run this again and we
356:09 - again don't see any kind of difference
356:12 - and a really important thing you have to
356:14 - understand about type hinting is that
356:16 - all of this is optional and it can be
356:18 - ignored
356:20 - so for example what i could be doing
356:22 - is add a string
356:25 - in here
356:26 - and also a string in here i know let's
356:29 - say test
356:30 - if i run this now
356:32 - the function is still going to work let
356:34 - me comment out those two lines here to
356:36 - make it a bit more readable
356:38 - so now we have indicated for the
356:40 - function we are expecting an integer but
356:43 - when we actually call the function
356:45 - we are adding two strings and python
356:49 - doesn't really mind it still works just
356:51 - fine
356:52 - so you don't have to follow it it's
356:55 - mostly indication of what is being
356:57 - expected
356:59 - but alright with that we have covered
357:01 - all you need to know about functions
357:04 - in this section we are going to cover
357:05 - more advanced data operators
357:08 - and this is one of the parts where
357:10 - python is incredibly powerful there are
357:13 - lots of ways to manipulate data and get
357:15 - a certain kind of outcome there is a
357:18 - reason why python is really popular for
357:20 - data science and machine learning
357:23 - it is because there are lots of
357:24 - different ways to work with data
357:26 - so let's have a look what we can do
357:29 - what we are going to cover in this
357:30 - section is more advanced ways to loop
357:32 - over data we are going to sort data we
357:35 - are going to learn list comprehension a
357:37 - really important topic even though the
357:39 - name here is probably a bit weird and
357:42 - finally data handling if we want to
357:44 - import or export data
357:47 - let's get started by looking at more
357:49 - advanced ways to loop over data
357:51 - so in this part we are going to
357:53 - manipulate lists to get stronger for
357:56 - loops and this is a super powerful topic
357:59 - because very often python you want to
358:02 - merge a list and then loop over this
358:04 - merged list and for this for example
358:07 - python has a zip function that zips
358:09 - together two lists and you could also
358:11 - get the index for each of the lists when
358:13 - you use a for loop and i suppose all of
358:16 - this is going to sound a bit abstract so
358:18 - let's do all of this a bit more
358:20 - practically
358:21 - here we have a nearly empty python file
358:24 - and i already have two lists we have
358:27 - inventory names and inventory numbers
358:30 - and the scenario we have here is you are
358:33 - running some kind of warehouse and
358:35 - people gave you two lists
358:37 - one with the things in your inventory
358:39 - and then how much of that thing you have
358:42 - and for the order here you are looking
358:44 - at the index meaning the first item
358:48 - and the first number belong together
358:50 - then we have the second item and the
358:52 - second number then the third one and so
358:55 - on we are sorting things here by their
358:58 - order
358:59 - this could for example happen if
359:01 - somebody copies a column from excel it's
359:03 - very easy to get
359:05 - the problem for you is if you want to
359:07 - write a for loop and you have two lists
359:10 - you kind of have a problem if you want
359:12 - to access both of these lists at the
359:14 - same time so the scenario here might be
359:17 - you have some kind of website and on
359:19 - this website you want to display all of
359:21 - this information for customers so you
359:24 - want to loop over both of these lists
359:27 - but this you can't do right now you can
359:30 - either do for name in inventory names
359:34 - or you could do for let's call it num in
359:38 - inventory numbers but both of these for
359:41 - loops are going to be independent of
359:43 - each other so you have no way to connect
359:46 - the two python in this case has one
359:48 - specific function and that is called zip
359:52 - what zip does is it wants two lists
359:55 - we want inventory names in our case and
359:58 - inventory numbers
360:00 - if i
360:02 - print the result we are getting a zip
360:05 - object some point in our memory not
360:08 - particularly useful
360:10 - we're going to see how to use this in
360:12 - just a second but for now what you can
360:14 - do is to convert all of this into a list
360:18 - with the list function
360:19 - if i run this now
360:21 - we can see something much more useful
360:23 - we have a list
360:25 - with tuples inside and each tuple is
360:28 - right now the combination in this case
360:31 - of screws
360:32 - and of the number
360:34 - and these are again sorted by the index
360:37 - which is what i want in this case
360:40 - that being said this zip you hardly ever
360:42 - use in the list and inside of a print
360:44 - statement
360:45 - instead you would usually use it inside
360:47 - of a for loop
360:49 - and the follow-up here could be let's
360:51 - say for thing
360:53 - in and now i want to have the zip of
360:55 - inventory names and inventory numbers
360:59 - and this i can now print as the thing
361:02 - and let's see what we get
361:03 - there we go this is looking not too bad
361:06 - we have a tuple with our screws and how
361:10 - many of these we have
361:12 - but the issue still is we want to have
361:14 - each individual value to work with we
361:16 - don't want to have an entire list i
361:19 - guess what you could be doing here is
361:21 - use indexing to get one value from this
361:24 - tuple
361:25 - 0 would give you the items and one would
361:28 - give you the inventory number
361:30 - and you could
361:32 - access both
361:34 - like this
361:35 - and you would get the name of the item
361:37 - and how many you have
361:39 - this would work but it's kind of hard to
361:42 - read
361:43 - thing here really isn't too specific
361:46 - for that python has some really
361:49 - interesting functionality
361:51 - basically what we have seen earlier when
361:53 - we assign two values to two variable
361:56 - name
361:56 - instead of writing thing
361:58 - we could write for example name and
362:02 - number
362:03 - and now when python goes through this
362:05 - list
362:06 - and it sees a tuple let's say for the
362:08 - first example we have screws and we have
362:12 - 43
362:15 - so this screws here and this 43 this
362:18 - would be the first item we get inside of
362:21 - this zip operation here it's kind of
362:23 - hard to read
362:25 - if you have a tuple and you write more
362:27 - than one variable name here python is
362:29 - going to unpack this tuple into these
362:32 - separate variables
362:34 - meaning in this case
362:36 - screws would be stored in name
362:39 - and the 43 would be stored in number
362:42 - and that way we can access them much
362:44 - easier inside of the for loop so name
362:47 - and number if i run this now
362:49 - this is still giving us the same result
362:52 - except now this is much easier to read
362:55 - and this is an operation you do
362:56 - surprisingly often
362:58 - i guess what we can do here to make all
363:00 - of this a bit easier to read we could
363:03 - use an f string
363:04 - and then i want to write something like
363:07 - let's say
363:09 - name
363:10 - and
363:11 - current
363:12 - index
363:14 - with the
363:16 - number if i run this now
363:18 - we get screws current index 43.
363:21 - i guess index isn't ideal let's use
363:24 - inventory that's better so we have
363:27 - screws current inventory 43
363:29 - and this information if you give it to
363:31 - somebody designing a website would be
363:33 - very easy to work with
363:35 - another thing that you could be using
363:37 - here
363:37 - is
363:39 - called the enumerate
363:41 - function
363:43 - and this one
363:45 - is basically used to get the current
363:48 - index inside of the for loop i guess an
363:51 - example here could be if you are cycling
363:54 - over this list
363:55 - and when you get halfway into this list
363:58 - somewhere here
363:59 - you want to run some other code the
364:01 - question then would be how do you know
364:03 - when you are halfway into the list
364:06 - and for that you would have to know the
364:08 - current index
364:09 - i guess let me demonstrate how this
364:11 - actually works that should make much
364:12 - more sense
364:14 - we need enumerate and this is a function
364:17 - what it wants is some kind of list or
364:20 - something you can iterate over in my
364:22 - case i want to go with my inventory
364:24 - names
364:26 - and now
364:27 - if i print what this is giving us
364:31 - we are getting once again an enumerate
364:32 - object
364:33 - doesn't help us too much but if i
364:36 - convert all of this into a list
364:39 - i am getting
364:40 - the index
364:41 - and the item from the list
364:45 - this zero here is the index of this
364:48 - screws inside of the list
364:50 - wheels would be number one metal parts
364:52 - would be number two rubber bits number
364:54 - three and these are the numbers we are
364:56 - getting down here and again
364:59 - this enumerate you would basically
365:02 - always use inside of a for loop
365:04 - let's say again for thing
365:07 - in
365:08 - and now i want to have the enumerate
365:09 - function
365:10 - and inside of this let me print the
365:13 - thing
365:14 - if i run this now we are getting again a
365:17 - tuple with the index and with the name
365:19 - of the item
365:21 - and just like we have done up here we
365:23 - can unpack this again what you usually
365:26 - see is index and then the name of the
365:29 - item or whatever you want to call it
365:31 - this
365:32 - is entirely up to you but index here is
365:34 - the common name for what enumerator
365:36 - returns
365:37 - once i have that i could do something
365:40 - let me print an f string again
365:42 - and here index
365:44 - with the name of the thing
365:47 - and there we have the current index and
365:50 - the screws
365:51 - and this i could for example use if the
365:54 - index
365:56 - is
365:57 - let's say the example i had earlier if
366:00 - we are halfway into this list i want to
366:02 - run some other code
366:04 - maybe i want to notify my boss that my
366:06 - operation here is halfway done something
366:08 - like that
366:09 - i want to check if the length of my
366:12 - inventory names
366:15 - is equal to the index and this will give
366:16 - me the whole list but i only want half
366:19 - of that
366:21 - and then here you do want a flow
366:23 - operator so you're getting an integer or
366:25 - a whole number because the index is
366:27 - always going to be a whole number in and
366:29 - of itself
366:30 - and if that is the case i can print
366:32 - something like half way done
366:36 - now if i run this
366:37 - i am getting the first half and then the
366:40 - second half although you might have to
366:42 - tinker around with this to get exactly
366:44 - to the halfway point
366:46 - the most important part here is that
366:48 - enumerate gives you the current index
366:50 - where you are inside of the list
366:52 - when you are using a for loop and with
366:55 - that we have two functions you see very
366:57 - often alongside four loops
367:00 - the other one we have seen earlier was
367:01 - the range function which also is almost
367:04 - always used alongside the for loop
367:07 - we can do an exercise and then finish
367:10 - this part
367:11 - and what i want you guys to do is to
367:13 - combine zip and enumerate to get some
367:16 - kind of string like screws then in
367:18 - square brackets id 0 and then inventory
367:22 - and then the number of inventory items
367:24 - for each of these numbers
367:27 - from this list here
367:29 - so pause the video now and try to figure
367:31 - this one out yourself
367:36 - let's go through it step by step
367:38 - first of all we need some kind of for
367:40 - loop and let me start by just writing
367:43 - thing
367:44 - we can refine this in a bit and i want
367:46 - for thing in let's start with inventory
367:49 - names
367:51 - in here i can already print
367:53 - something we definitely didn't have
367:55 - string
367:56 - and i want to have my
367:58 - thing this should be in curly brackets
368:02 - let me run this now
368:04 - i forgot
368:05 - we got lots of stuff because i have to
368:07 - comment out all of this
368:09 - if i run this now we get the different
368:11 - items from this list
368:13 - not a bad start we have the first word
368:16 - but well we're getting there
368:18 - i suppose next up
368:20 - i can put all of this inside of the zip
368:24 - function
368:25 - and then combine
368:26 - inventory names and the
368:29 - inventory numbers i called it
368:32 - if i run this now
368:34 - we're getting a tuple we essentially
368:36 - create a new list full of tuples and
368:39 - each tuple will be captured by the
368:41 - variable thing and this is what we are
368:44 - pasting inside of here
368:46 - this we can unpack i want to have my
368:48 - name and i want to have the number
368:52 - this is basically what we have done up
368:54 - here
368:55 - i want to have a name
368:56 - and then i can add
368:59 - my inventory
369:01 - with a colon now i need curly brackets
369:04 - and the number
369:06 - running this now gets me screws
369:08 - inventory 43.
369:10 - we are definitely making progress
369:13 - finally we need to get the current id of
369:17 - each of these objects and for that we
369:19 - need enumerate
369:21 - what that means is i want to wrap the
369:23 - entire zip function inside of a numerit
369:28 - i find this one very hard to write you
369:30 - might struggle as well
369:32 - and before we work more on this
369:35 - i want to check out what we actually get
369:38 - returned from
369:39 - this
369:40 - thing here it's quite a complex one
369:43 - so let's see if i print thing
369:47 - in here we have one tuple and inside of
369:49 - this tuple we have two values the first
369:52 - one is the index the second one is
369:54 - another tuple that we got from this zip
369:57 - operation here
369:59 - unfortunately now this thing is kind of
370:02 - annoying to unpack we can't do this
370:04 - easily
370:05 - what you might be very tempted to do
370:07 - here is something like index
370:10 - name and number but if you run this
370:13 - python is not going to be happy
370:15 - because
370:16 - we have not enough values to unpack what
370:20 - that means is that python here returned
370:22 - two items inside of some kind of data
370:25 - structure in our case this is a tuple
370:30 - with the index let's say 1 and then the
370:32 - other value is a tuple with the let me
370:35 - call it the name
370:36 - and let's say 43 for the number
370:40 - and don't let me forget the closing
370:42 - brackets that is important
370:44 - now python looks at this tuple and it's
370:46 - these two items this one and this one
370:49 - but we are telling python inside of the
370:51 - for loop down here that we want to
370:53 - unpack all of this into three parts but
370:56 - python doesn't know how to do this
370:58 - because it only sees two items as a
371:00 - consequence we are getting an error
371:04 - what is most efficient here is to only
371:06 - use two unpacking variables we have
371:08 - index and then we have let's call it the
371:11 - inventory
371:13 - to pill
371:15 - let me print the index here
371:17 - and the
371:19 - inventory tuple
371:22 - now we're getting all of this
371:24 - not ideal but definitely something you
371:26 - can work with
371:28 - let me get rid of this one here and
371:30 - uncomment all of this
371:32 - now what we want the name
371:34 - is going to be part of the inventory
371:37 - tuple and it is the one with the index
371:40 - zero because remember this one is just a
371:43 - tuple nothing else
371:45 - after we have that i want something like
371:47 - this square brackets with id and then
371:50 - the current id
371:52 - meaning i need square brackets inside of
371:54 - that the word id a colon and then curly
371:58 - brackets with my index
372:00 - finally
372:02 - i want to have my inventory
372:05 - tuple
372:06 - and now i need the first item inside of
372:09 - this tuple
372:10 - and with that let me run it
372:12 - we get
372:13 - all of the different items properly
372:15 - formatted
372:17 - i suppose the most important part here
372:19 - is to understand this and what different
372:21 - values are being returned
372:24 - definitely play around with this one and
372:25 - understand how these things interlock
372:27 - with each other
372:30 - zip first of all returns a new list with
372:32 - tuples inside that are zip values from
372:35 - names and numbers and then enumerate
372:39 - creates a whole new tuple by adding an
372:41 - index and then adding the original tuple
372:43 - it got from the zip operation
372:46 - for this part we are going to cover one
372:48 - of the most powerful parts of python and
372:51 - that is called list comprehension
372:54 - a very strange name but it is for a
372:57 - super powerful concept
372:59 - basically what a list comprehension is
373:02 - is a way to create a list on one line of
373:05 - code
373:06 - and this can get surprisingly powerful
373:10 - you can either use it to create a list
373:12 - or to manipulate existing lists like to
373:14 - filter out values for example but let's
373:17 - keep it simple for now
373:19 - and let's say you want to create a list
373:22 - with the numbers from 0 to 99
373:25 - for that right now you will probably
373:27 - write something like this you start with
373:29 - an empty list
373:32 - then use before loop so for num in range
373:35 - from 0 to 100 because remember we only
373:38 - go up to this number we don't include it
373:40 - and we want to end at 99
373:43 - and then inside of this for loop we are
373:46 - getting our list and we are appending
373:49 - the number we are getting from this for
373:51 - loop
373:52 - fairly simple operation and since it is
373:54 - so simple
373:56 - wasting three lines of code on it feels
373:58 - kind of pointless
374:00 - as a consequence we would use list
374:02 - comprehension this one would look like
374:04 - this
374:06 - it's kind of comparable to a ternary
374:08 - operator actually
374:10 - we still keep most of the words here so
374:13 - we have four
374:14 - the same four we had here then we have
374:17 - num we still have the num here then we
374:20 - have the in in both of them and also the
374:23 - range stays the same as well
374:26 - we pretty much put the whole line here
374:29 - after the number the major difference
374:32 - now is
374:34 - instead of writing my list dot append we
374:37 - only need num inside of this this one
374:41 - automatically gets appended
374:43 - to the list you are assigning it to
374:47 - and that way you can write all of this
374:49 - much more efficiently
374:51 - and this is only a very simple example
374:53 - this can get significantly more powerful
374:56 - but let's have a look at some easy
374:58 - examples
374:59 - here is the operation i have just shown
375:01 - you in the slides
375:03 - and this if i print my list
375:07 - we are getting the values from 0 to 100
375:10 - inside of a list
375:12 - and again here this is three lines of
375:15 - code for something that ultimately is
375:18 - kind of simple
375:20 - so let's do all of this in one line and
375:23 - let me call it my list comprehension or
375:26 - just comp
375:27 - and in here we always need square
375:29 - brackets this
375:31 - always has to come in there
375:33 - and then we again need this entire line
375:36 - here as a matter of fact
375:38 - let me actually copy it
375:40 - so we have four num in range 100.
375:43 - the difference now
375:44 - is we don't add a colon and then the
375:47 - operation we want to do like my list dot
375:50 - append none of this is going to happen
375:52 - instead
375:54 - the value we want to return to this list
375:56 - comes as the first word inside of it
376:00 - and this will automatically be appended
376:02 - to this list
376:04 - as a consequence we would just need this
376:06 - we need num for num in range 0 to 100
376:11 - if i print this now
376:13 - we are getting exactly the same outcome
376:17 - all we really have done is condensed
376:19 - this entire line here into a single word
376:23 - with the entire rest of the for loop
376:25 - staying identical
376:27 - that being said now
376:28 - you can make more changes to this part
376:31 - here for example you could multiply all
376:34 - of this by two
376:35 - run this again and now you have every
376:38 - value multiplied you could also put all
376:40 - of this inside of let's say a tuple
376:44 - and then add num num and num
376:47 - and now python would automatically
376:49 - assign each value inside of the number
376:52 - basically what we are doing is
376:54 - this num
376:56 - looks at the range and gets the values
376:58 - from 0 to
377:00 - 99
377:01 - and then it assigns each of these
377:03 - numbers to one of the values inside of
377:06 - the tuple and this is then what we're
377:09 - getting here so we'll get 0 0 0 1 1 1 2
377:12 - 2 and so on
377:15 - and this is only the most basic kind of
377:18 - list comprehension you can do and
377:20 - there's one way to make this
377:22 - significantly more powerful
377:24 - you can combine list comprehension with
377:26 - the ternary operator which is just a
377:28 - fancy way of saying you can add if to a
377:30 - list comprehension
377:32 - there are actually two ways of doing it
377:35 - the first one would be at the end
377:38 - so num for num in range 0 to 100 if a
377:42 - certain condition is true
377:43 - although an important thing here is
377:46 - else does not work i don't actually know
377:50 - why but you just get an error if you add
377:53 - an else after this
377:55 - however the other way would look like
377:57 - this where you first add the value you
378:00 - want to return and then the conditional
378:02 - statement so if num is 10 else 0 and
378:06 - then the for loop we have seen up here
378:10 - and choose whichever works better for
378:12 - you both are totally fine just keep in
378:15 - mind the second one is a tiny bit more
378:17 - powerful
378:18 - i honestly have no idea why the first
378:20 - one doesn't work with else statements it
378:22 - might be something internal
378:24 - and this is something really powerful
378:27 - because you could be using it to filter
378:29 - other lists
378:31 - let's have a look at this in practice
378:32 - actually
378:33 - and let's do some basic examples first
378:36 - i can add an if statement here at the
378:38 - end and i only want to get
378:40 - these values here
378:42 - if the number
378:44 - is let's say below 20.
378:47 - if i run this now my list comprehension
378:49 - stops at 19.
378:51 - although again keep in mind else 0 for
378:54 - example would not work i would get an
378:57 - error that says invalid syntax
379:00 - so this is not good
379:03 - but what i have to do to get around that
379:07 - i would have to cut all of this out and
379:09 - paste it
379:10 - here now if i run this this is working
379:14 - just fine
379:15 - we get all of the two bits from 0 to 19
379:17 - and then for any other value we are
379:20 - getting 0.
379:22 - and that is basically a trade if
379:24 - statements in here one example how you
379:27 - could be using this
379:29 - here are the two lists you have seen
379:30 - from the last part
379:32 - and i want to clean them up
379:35 - let's say i want to create a list
379:39 - with all of the parts that have less
379:42 - than 25 items so i want to select wheels
379:45 - because they only have 12 items and i
379:48 - want to select the screwdrivers because
379:50 - they only have 23 items
379:53 - and for that list comprehension could be
379:55 - really really powerful
379:57 - along with the other stuff we have
379:59 - already seen
380:02 - let me call it the
380:03 - replenish
380:06 - that's not how you spell that replenish
380:08 - list
380:10 - and now in here
380:11 - we want to look through
380:14 - all of these items
380:16 - and for that first of all
380:18 - we again
380:19 - need square brackets
380:21 - and let's start with thing for thing in
380:25 - and i want to again use my zip list
380:28 - because i want to access both of these
380:29 - lists and here i need inventory not
380:32 - numbers but names
380:34 - and now inventory
380:36 - numbers
380:39 - if i print now my replenish list
380:43 - i get the entire list
380:45 - inside of the square brackets
380:48 - so far this isn't helpful at all
380:51 - but now what i can do first of all this
380:54 - thing here instead of thing i want to
380:57 - name
380:58 - let's call it name and number
381:02 - and to get the same outcome again i
381:04 - would need my name and my number
381:07 - so far again we are still going to get
381:10 - the same outcome
381:11 - but now i only want to do all of this if
381:14 - a certain condition is true and in my
381:16 - case the condition is if the number is
381:18 - below 25.
381:21 - if i run this now
381:22 - we are only getting two items with the
381:25 - name and the number attached to it
381:28 - which is a very nice way to get data out
381:32 - of this list here and this is a kind of
381:34 - operation you would actually do fairly
381:36 - often in python and list comprehension
381:38 - for that is what you would use very very
381:40 - often now what you can also do
381:43 - is to combine different list
381:45 - comprehensions let me add a comment here
381:48 - let's call it combine list comprehension
381:53 - although this one is going to get a
381:55 - little bit more complex but let's go
381:58 - through it in a really simple example
382:00 - let me create a new variable combined
382:03 - comprehension
382:05 - and in here first of all i want to have
382:08 - something really simple
382:10 - let's say x for x in range 5
382:15 - then i'm going to comment out all the
382:17 - stuff we have done so far and print what
382:20 - we are getting from the combined
382:22 - comprehension
382:24 - we are getting the numbers from 0 to 4.
382:28 - this should make sense it is fairly
382:30 - simple at least i hope it is
382:33 - but now what we can do is put all of
382:35 - this inside of another list
382:38 - comprehension
382:39 - so all of the stuff we have seen so far
382:42 - for y in range
382:44 - let's say 10.
382:46 - if i now run this
382:48 - we're getting something that
382:50 - possibly looks a bit weird
382:53 - i think there's a better way of
382:54 - presenting this instead of printing the
382:57 - list by itself i want for row in
383:01 - combined comp
383:02 - print
383:03 - row
383:04 - and now if i run this
383:07 - we can see the entire output like this
383:10 - much easier to read
383:12 - and let's go through what happened here
383:14 - that is probably kind of confusing right
383:17 - now
383:18 - i think the best way to go over this is
383:20 - to separate these two lists we have an
383:23 - inner list this x for x in range five
383:26 - and then we have an outer range the
383:28 - entire list comprehension that's a
383:30 - terrible line let's do it like that's
383:32 - still a terrible line let's do it like
383:34 - this
383:36 - the yellow part is always this inner
383:38 - part here and this we now got multiple
383:41 - times we have one here one here one here
383:44 - and so on
383:45 - they are all x for x and range five
383:48 - the reason why we got this multiple
383:49 - times is because of this part here
383:53 - we basically created this
383:56 - list 10 times
383:59 - and that way you can create a list that
384:00 - contains other lists
384:02 - although
384:03 - still not particularly useful but where
384:06 - this system becomes incredibly powerful
384:09 - is you can put
384:11 - this yq for example
384:14 - into the original list
384:16 - let me actually demonstrate
384:18 - instead of
384:19 - just having the x as the value for this
384:21 - list i want to have instead a tuple with
384:25 - x and y
384:26 - if i run this now
384:28 - we are getting
384:30 - let me use different colors for this we
384:32 - have a tuple this tuple here
384:35 - and this tuple is inside of a list
384:38 - this list here
384:41 - that is the list we are getting from
384:43 - this inner list comprehension
384:46 - finally then we have a list of lists and
384:50 - this is the entire list comprehension
384:54 - and i suppose inside of the tuple we
384:56 - have the x and we have the y value
385:02 - x increases on every column
385:05 - and y is increasing on every single row
385:08 - e is y0 y1 y2 and so on
385:12 - with the system you can create
385:15 - incredibly complex data structures
385:18 - you could theoretically even add a third
385:21 - and a fourth list comprehension but by
385:23 - that point things are a bit overkill i
385:26 - think
385:27 - i would not recommend overthinking this
385:29 - it can get really complex and it doesn't
385:31 - have to be as complex
385:33 - if you really wanted to make something
385:34 - more complex you probably want to use a
385:37 - for loop
385:39 - but alright with that we can do an
385:42 - exercise and then we are basically good
385:45 - to go
385:46 - and what i want you guys to do is to
385:48 - create the fields for a chess
385:52 - board
385:53 - and just in case you had actually fun
385:55 - hobbies at school a chessboard has the
385:58 - fields a b c d e f g and h
386:02 - which is eight letters in total
386:04 - and then we also have the fields from
386:06 - one let's say one two three four five
386:09 - six seven and eight
386:12 - which basically means the first field
386:14 - you are going to get is a one
386:17 - and then you keep on creating more
386:20 - fields and at some point all the way at
386:23 - the bottom
386:24 - you should have h8
386:27 - and if you want an extra challenge this
386:29 - is not actually a chess board because a
386:32 - real chess board would have the a1 at
386:35 - the bottom and the h8 in the top right i
386:40 - guess i can cover both see how far you
386:42 - get but pause the video now and try this
386:44 - one yourself
386:48 - let's get started by commenting out all
386:52 - of this
386:53 - and then i want to start let me call it
386:56 - chess
386:57 - board
387:00 - and in here i want to start with the
387:02 - square brackets for my list
387:03 - comprehension
387:05 - and i guess we can start with the
387:07 - numbers so num for num
387:10 - in
387:11 - and now we want range
387:13 - and let's start with 8 and let's see
387:16 - what we get
387:18 - i want to print my chessboard and i get
387:20 - the numbers from zero to seven
387:23 - which is not a chess board
387:26 - we need the numbers from one to eight
387:30 - for that i'm going to specify a start
387:32 - value here and now the end value is
387:35 - going to be 9.
387:36 - if i run this now we get the numbers
387:38 - from 0 to 8.
387:40 - we have the inner
387:43 - list comprehension
387:45 - now for the outer
387:47 - and now this might have been the one
387:48 - part where you struggled that was how to
387:51 - get each individual letter here
387:54 - and the solution is actually really
387:55 - simple all you need is to type the
387:57 - string a b c d e f g and h
388:01 - if you have this and i run this again we
388:03 - get this entire list except it's very
388:06 - hard to read
388:07 - so let me do it again for row in
388:10 - chessboard
388:12 - print
388:13 - the row
388:15 - there we go this is much easier to read
388:19 - the problem now is that we want to have
388:21 - the letter and the number this happens
388:24 - inside of this part here
388:26 - i want to have the letter
388:30 - and then the number
388:32 - if i run this now
388:33 - we have a 1 in the top left and h8 in
388:37 - the bottom right
388:39 - that's a good start although i guess
388:41 - doing this as a tuple isn't ideal
388:44 - but you don't have to you could totally
388:46 - create an f string here
388:48 - and in there i want to have the letter
388:52 - and i want to have the number
388:55 - now running this gets me something like
388:57 - this i think that looks a bit more
388:59 - appropriate
389:01 - the difference here really doesn't
389:03 - matter all that much
389:04 - and now if you wanted to invert all of
389:07 - this
389:07 - meaning that instead of the
389:10 - a1 here you would want this top part to
389:13 - be
389:14 - h1
389:16 - and then this part down here would be a1
389:21 - in a chess board the bottom left field
389:23 - is always a1 and the top right one this
389:26 - one here would be h8
389:29 - to achieve that
389:31 - you could just type out this string here
389:34 - in reverse but that would be kind of
389:36 - annoying and not exactly scalable if you
389:39 - wanted to make something larger
389:42 - but here we can do something really
389:44 - clever we can use slicing
389:47 - remember this from quite a few videos
389:49 - ago we are specifying a start an end and
389:54 - a step size
389:55 - now the start and the end
389:58 - if we leave them empty is giving us the
390:01 - entire string
390:02 - but now if we specify for the step size
390:05 - negative one
390:07 - then we are going to go backwards over
390:10 - the string
390:11 - now to understand this part you have to
390:13 - understand return statements basically
390:16 - what happens here is originally we just
390:18 - returned this string but now because of
390:22 - this slicing operation
390:24 - the four letter in
390:26 - is looking at the entire operation here
390:31 - because this is what gets returned
390:34 - this is really something you eventually
390:36 - understand when you play around more
390:37 - with python it does take some time but
390:40 - now if i run this we are starting with
390:42 - h1 in the top left and a8 in the bottom
390:45 - right
390:46 - and with that we have a proper chest
390:48 - field
390:50 - i hope that wasn't too bad list
390:52 - comprehension especially early on can
390:54 - get very confusing
390:57 - besides a list comprehension we have
390:59 - other types of comprehension as well one
391:01 - for each type of container at least kind
391:04 - of
391:05 - and before i cover them i really want to
391:07 - emphasize that list comprehension are by
391:10 - far the most common comprehension you
391:12 - are going to do
391:14 - i am going to include these mostly for
391:16 - completion sake but you probably aren't
391:18 - going to use them very much
391:21 - comprehensions work quite easily with
391:23 - dictionaries and sets this would look
391:25 - like this for a dictionary and like this
391:27 - for a set set is actually super easy
391:31 - all we are doing here is we are
391:32 - replacing the square brackets with curly
391:35 - brackets and then we are done that is
391:37 - literally the only difference
391:39 - for a dictionary the one thing you
391:41 - really have to keep in mind is that we
391:43 - always need the key
391:45 - then a colon
391:47 - and then a value
391:50 - in this case
391:51 - both of them would be num meaning we
391:54 - would create a dictionary that would
391:56 - have key value pairs like 1 and 1.
392:00 - then 2 and 2 three and three and so on
392:02 - not exactly useful but it's something
392:05 - you can refine
392:07 - and that brings us to the final type of
392:08 - comprehension a tuple comprehension this
392:12 - one works a bit differently
392:14 - in here you are still using num for num
392:16 - in range 10. the problem is for python
392:20 - this kind of operation was already
392:22 - covered using the normal brackets as a
392:24 - consequence this operation gets a bit
392:26 - weird
392:28 - to create a proper tuple out of it you
392:30 - would need the tuple function but after
392:33 - you have done that
392:34 - you are back to a normal tuple with
392:37 - whatever operation you have in here so
392:39 - not that much of a change
392:42 - and that is basically it
392:44 - let's have a look at all of this in code
392:47 - and let's get started with a set
392:49 - comprehension
392:51 - this one we are creating with curly
392:53 - brackets
392:54 - and now in here we can just do the
392:55 - normal comprehension stuff for example
392:58 - num for num in range
393:01 - let's say 100
393:03 - and if i print the set comprehension
393:06 - i am getting all the numbers from 0 to
393:08 - 99
393:10 - this is basically all you have to know
393:12 - and well let's get to the next one the
393:14 - much more interesting one
393:17 - the dictionary comprehension
393:21 - for this one we again need curly
393:23 - brackets
393:24 - but now the important thing is we need a
393:26 - key and we need a value
393:29 - but once you have those two you would
393:31 - still continue with four x in some kind
393:34 - of list
393:36 - in my case let's go with num in
393:41 - range 100
393:43 - and now i have to define values for key
393:46 - and for value
393:47 - i guess from the example i could name
393:50 - both num
393:51 - and then print the entire
393:55 - dictionary comprehension and now we are
393:57 - getting a dictionary although i do want
394:00 - to fix the typo that is annoying me
394:04 - there we go
394:06 - now what we are getting in here is a
394:08 - dictionary with lots of key value pairs
394:10 - this is one this is another this is the
394:12 - third and so on
394:15 - and in here we have set the key and the
394:18 - value to the same number as a
394:20 - consequence they both have the same
394:22 - number which really is not useful
394:26 - to make this a bit more interesting we
394:28 - could for example
394:29 - get the power of num
394:32 - and run this again now we can see a bit
394:34 - more of a difference the key is 2 for
394:36 - this one and the value is 4. 3 gets us 9
394:40 - and so on this way you can at least see
394:42 - different values
394:44 - that is basically it for dictionary
394:46 - comprehensions finally we have tuple
394:49 - comprehensions
394:51 - and in here you would use normal
394:53 - brackets
394:55 - and now you would still write something
394:57 - like num for a num in range 100.
395:00 - if i print this tuple comprehension
395:04 - we are getting a generator object at
395:07 - some
395:08 - location in our memory
395:10 - which well is really not useful
395:13 - that being said you could work with this
395:15 - super comprehension for example in a for
395:18 - loop i could write for let's say value
395:21 - in tuple comprehension
395:23 - and i want to print
395:25 - the value if i run this now
395:28 - we are getting all of the values inside
395:30 - of it
395:31 - meaning this object is working as
395:33 - intended we just can't really see the
395:36 - result
395:37 - to actually see it we would have to
395:39 - convert it to a tuple and then we are
395:42 - done
395:43 - if i print the tuple comprehension run
395:46 - this again
395:47 - now we can see the result we would
395:49 - expect
395:50 - the reason for this is that these normal
395:53 - brackets are used quite often in python
395:56 - and in this case they are in conflict
395:57 - with the tuple comprehension but that's
396:00 - not something you have to worry about
396:01 - too much
396:02 - i have never ever seen anybody use a
396:04 - tupel comprehension to be honest
396:07 - the one thing you see once in a while is
396:09 - a dictionary comprehension but most of
396:11 - the time you see a list comprehension
396:13 - and nothing else
396:15 - and i guess with that we can do an
396:17 - exercise
396:19 - what i want you guys to do is to create
396:21 - a dictionary with the keys a b c d and e
396:26 - and each key should have a list as a
396:28 - value with the values one two three four
396:30 - and five
396:31 - that should be one list for each of
396:33 - these keys
396:35 - pause the video now and try to figure
396:37 - this one out yourself
396:42 - all right let me start by creating an
396:44 - exercise comprehension or whatever you
396:47 - want to name it
396:49 - since we are creating a dictionary i
396:51 - want to have my curly brackets
396:53 - now in here let's get started by
396:55 - creating the keys
396:56 - we need to format key and value
397:01 - then for x
397:03 - in
397:04 - some kind of iterable
397:07 - and since these are the values that
397:09 - change the iterable here should be a
397:12 - string with a b c d and e
397:16 - for proper naming here let me rename
397:18 - this x to a letter
397:20 - and now my key should be this letter
397:24 - and since the value doesn't change it is
397:27 - always one two three four and five i can
397:30 - just type the value in here and now all
397:33 - i have to do is to print the exercise
397:36 - comprehension run all of this
397:38 - and we can see
397:40 - we have the dictionary here
397:42 - this one worked pretty well
397:44 - let me comment out the earlier part
397:46 - there we go this looks much cleaner
397:49 - in this part we are going to cover
397:52 - functions that take functions as
397:54 - argument which is probably going to
397:56 - sound a bit weird but let's talk about
397:59 - it
398:00 - when you pass arguments into a function
398:03 - it is perfectly fine to pass a function
398:06 - as an argument into another function
398:09 - and let's do this by example to actually
398:11 - illustrate what i mean
398:12 - and for that i want to use the sorted
398:14 - function this one sorts some kind of
398:17 - iterable in some kind of way it looks
398:19 - like this
398:21 - the name of the function is sorted we
398:24 - have to pass in some kind of iterable
398:26 - most of the time it's going to be a list
398:28 - but it doesn't have to be
398:30 - and then we need some kind of function
398:34 - to tell python how it needs to sort this
398:37 - list
398:37 - for example do you want to sort the list
398:41 - from the smallest to the largest number
398:44 - do you want the opposite of that
398:48 - or if you have for example a list that
398:51 - contains strings how do you want to sort
398:53 - that do you want to go by the character
398:56 - in the alphabet do you want to go by the
398:58 - amount of characters inside of each
399:00 - string
399:01 - it really depends here python doesn't
399:03 - know by itself
399:05 - meaning you have to write a function to
399:07 - tell how to sort this iterable
399:11 - and this is the function we have to
399:14 - create ourselves
399:16 - which well isn't that difficult but you
399:19 - do have to understand the system so
399:21 - let's have a look at this straight in
399:22 - code
399:25 - in my code i already have one list and
399:28 - this list right now is kind of unsorted
399:32 - it's a bit random and to sort it i need
399:35 - the sorted function
399:38 - and in here at the very least i have to
399:40 - pass in one argument
399:42 - and that is the list i want to sort
399:45 - what i get returned from this
399:47 - let me print it
399:49 - i am getting the list sorted
399:52 - and this you usually do with a list as a
399:55 - matter of fact a list even has a sword
399:58 - method that sorts the entire list
400:02 - if i run this
400:04 - and let me comment out
400:06 - this line here list.sort after i run
400:09 - this i can print my list1 and now the
400:11 - list was sorted as well
400:14 - this method and this function they are
400:16 - basically doing the same thing but this
400:18 - is not what we are here for
400:20 - we want to look at sorted
400:23 - via the other arguments and there are
400:25 - two you can pass in here
400:29 - one is really easy and one is the
400:31 - function i just talked about but let's
400:33 - start with the easier one
400:35 - the one argument you can use here and
400:37 - let me use a keyboard argument we want
400:39 - to specify a reverse
400:42 - and then here python expects a boolean
400:44 - if i set this to true it reverses the
400:47 - entire list
400:48 - now we go from the highest to lowest
400:51 - instead of the lowest to the highest
400:52 - that's basically it
400:54 - what is much more interesting is the key
400:58 - argument or parameter
401:00 - because in here python is expecting some
401:03 - kind of function
401:04 - and let me actually demonstrate a use
401:07 - case where you would need it
401:09 - for that i have another list that i want
401:13 - to store in let's call it list 2.
401:17 - in here i have a list that contains two
401:19 - builds in each tuple we have for example
401:22 - a and 3 we have b and 10 c and 6 and so
401:26 - on
401:27 - and this would be
401:29 - really difficult to sort if i print
401:31 - sorted and list 2 let me comment out the
401:35 - first part and run this again
401:38 - we now get well no change in the list
401:41 - python just doesn't know what to do with
401:42 - this list
401:44 - but in my case i want to sort this list
401:48 - by
401:48 - the integer inside of each tuple
401:52 - meaning this one here should be first
401:54 - then the second then this third and then
401:57 - this last
401:58 - and for that behavior i have to tell
402:00 - python which value to access
402:03 - and for that
402:04 - we have to create a function
402:06 - let me do it straight below the list
402:09 - although most of the time you would do
402:10 - it straight at the top of the code but
402:12 - in my case i'm going to keep this a bit
402:14 - more readable
402:16 - i want to create let me call it a sort
402:19 - function
402:21 - and this is always going to need one
402:22 - argument let me call it item
402:25 - and now how this is going to work inside
402:28 - of my sorted function i have to specify
402:32 - a key
402:33 - and for this key i want to have my sort
402:36 - function
402:37 - and really important now you do not call
402:40 - this function
402:42 - there should not be any brackets after
402:44 - the sort function except to close sorted
402:46 - and print you are only passing in the
402:48 - function you are not calling the
402:51 - function
402:52 - python or well sorted does this one
402:54 - internally so you don't have to do it
402:57 - and basically what is happening is that
403:01 - sorted goes through each of these tuples
403:04 - in this example and passes each tuple
403:08 - inside
403:09 - of the sort function as an argument
403:12 - and then this function has to return
403:15 - some kind of integer
403:18 - let me write i n t
403:21 - and the size of this integer is going to
403:24 - determine how we are ordering this list
403:28 - so in my case
403:30 - all i want to do inside of the function
403:32 - i want to return item and then 1.
403:36 - for example if i'm getting this tuple
403:39 - here as an argument all i really want to
403:41 - do is to pick this integer and return it
403:46 - and then python knows what to look for
403:49 - inside of this list for the sorting
403:50 - algorithm
403:52 - and that is literally it if i run this
403:54 - now we can see the list is sorted now
403:58 - via the integer inside of the tuple so
404:00 - we have 3 5 6 and 10.
404:04 - and of course inside of this function
404:06 - you can be really fancy and add a whole
404:10 - bunch of stuff
404:11 - the thing is most of the time you are
404:14 - not going to do that
404:16 - in almost all cases you simply want to
404:18 - tell python a bit more in detail what
404:20 - kind of value you are looking for this
404:23 - is very rarely becoming complicated
404:26 - as a consequence you hardly ever write a
404:28 - dedicated function instead you use
404:31 - lambdas
404:33 - let me actually
404:35 - copy this line
404:37 - and now i want to have my list 2 and for
404:40 - the key now
404:41 - i don't want a function instead i want a
404:44 - lambda function
404:47 - and for this one we again as the first
404:49 - argument here we have to specify what
404:52 - kind of parameter we want that is this
404:55 - item here this one would be equivalent
404:57 - to this item here
404:59 - inside of this
405:00 - we have to tell python what to do with
405:03 - this item
405:04 - in this case all i want to do is get the
405:06 - item and then pick the first index
405:10 - and since this item here
405:13 - will be returned automatically this is
405:15 - equivalent to all of this
405:19 - and with that we are done i can run this
405:22 - now
405:22 - and we get the same result so this is
405:25 - working just fine
405:27 - and that is essentially it now with that
405:32 - we can do an exercise
405:34 - and for the exercise
405:36 - i want to stick with the same data we
405:38 - have used earlier this one here we have
405:40 - inventory names inventory numbers and i
405:43 - already used zip to zip these two
405:45 - together
405:46 - meaning now let me comment out all of
405:49 - this
405:52 - i want to print my
405:54 - combined list
405:56 - run this one now and we have a list with
405:58 - tuples inside and inside of each tuple
406:01 - we have the name of the item and the
406:03 - amount of how much we have of that item
406:05 - and i want you guys to do two operations
406:07 - actually
406:09 - number one is sort this list by
406:13 - inventory
406:15 - numbers
406:16 - for this list the first item
406:19 - should be
406:20 - this 12 year with wheels
406:23 - next up should be 23 with screwdrivers
406:26 - and so on
406:27 - and number two sort this list by length
406:32 - of
406:33 - the inventory
406:36 - name
406:38 - this means that the longer the word gets
406:41 - the later it should be in the list i
406:43 - guess what
406:44 - should be first and screwdrivers should
406:47 - be last
406:49 - we are looking at the length of each
406:51 - string here
406:52 - and well pause the video now and try
406:54 - this one yourself
406:58 - let's start let me call the first one
407:02 - sorted
407:03 - comp
407:04 - by numbers
407:06 - and here i want to have the sorted
407:08 - function and inside of list i have to
407:11 - first of all pass my combined list
407:13 - now i have to specify a key and for this
407:17 - one i want to have a lambda function
407:20 - let me use
407:21 - a num here as the parameter name
407:24 - since the argument we are expecting is
407:27 - some kind of tuple
407:28 - let's call this one the inventory tuple
407:33 - all we want to do with this one is to
407:35 - get the inventory tuple
407:38 - inventory tuple
407:40 - and get the item with index number one
407:44 - we should be done let me print this
407:46 - sorted comp by num
407:48 - and there we go
407:50 - the first tuple is now with 12 then 23
407:53 - 43 43 95 and 421 this is working just
407:58 - fine
407:59 - so next one
408:01 - we get the sorted comprehension
408:05 - by
408:06 - name
408:07 - once again we are going to need sorted i
408:10 - want the combined list
408:12 - and now we have to specify a key
408:15 - i guess here again we are still going to
408:18 - get the inventory tuple
408:21 - inside of this
408:22 - we still want to look at the inventory
408:24 - tuple but now we want to have the index
408:27 - 0 because we want to look at the strings
408:31 - and we don't want to return the strings
408:34 - we want to return the length
408:36 - of the string
408:37 - meaning we want to have the length
408:39 - function and then the result of that is
408:42 - going to get returned
408:43 - i can now print the sorted comp name
408:47 - and we get
408:49 - the first item is wood there are four
408:51 - letters in here then we have screws
408:55 - this is six characters
408:57 - wheels is also six and metal parts is
409:00 - definitely more than six
409:02 - meaning this seems to be working just
409:04 - fine and with that we have the sorted
409:07 - function
409:08 - but there are two more functions like it
409:10 - that i would like to cover
409:12 - for this part we are going to look at
409:14 - two more functions that take functions
409:16 - as arguments besides sorted we also have
409:19 - map and filter at least for basic python
409:23 - now that being said
409:24 - you probably are very rarely going to
409:27 - actually use or see them they have
409:29 - basically been replaced by list
409:31 - comprehension
409:32 - which is a more elegant way to do all of
409:35 - this but let's have a look at all of
409:36 - this in practice
409:39 - once again i have an empty python file
409:41 - except now i have my list that contains
409:44 - a list with the numbers from 1 to 5.
409:47 - the two functions let's start with map
409:50 - all that this one really does is it
409:52 - changes values with a function inside of
409:57 - a iterable
410:00 - just like we've sorted we have to start
410:02 - by using the map function name and in
410:05 - here we need two arguments we need some
410:08 - kind of key and then we need an iterable
410:12 - in my case the iterable is going to be
410:15 - my list
410:16 - for the key i want to create some kind
410:20 - of function
410:22 - and in my case i want to create a power
410:24 - function
410:27 - so basically what map does
410:30 - is it cycles through this list which in
410:33 - our case is going to give us one two
410:35 - three four and five
410:37 - every single one of these values
410:39 - will be passed into the power function
410:42 - as an argument
410:44 - and then whatever the power function
410:46 - returns
410:47 - will be used to create a new list
410:50 - instead of sorting it we are just
410:52 - changing every single value
410:54 - map in a way is simpler than sorted
410:57 - i want to create a power function
411:00 - and this one again is going to need some
411:02 - kind of parameter in my case i'm going
411:04 - to call it num
411:06 - and now we have to return
411:08 - what we want this new value to be in my
411:10 - case i just want to take the power of
411:13 - this num
411:15 - and that is all we needed
411:17 - now i can print
411:19 - all of this and let's see what we get
411:22 - we are getting a map object cool
411:25 - completely useless
411:27 - but we can convert this to a list
411:30 - and then we can actually read it if i
411:32 - run this now
411:34 - you can see we have taken the power of
411:37 - every single value inside of this
411:39 - original list
411:41 - one remained a one
411:43 - but the two became a four and the three
411:47 - became a nine and so on
411:49 - we went through this list and we applied
411:52 - this function to every single value and
411:54 - that is literally all that happened here
411:57 - once again
411:59 - since it's kind of annoying to write a
412:01 - whole function for something so simple
412:04 - we are usually going to use a lambda
412:07 - function
412:08 - we need the lambda keyword and now the
412:11 - name of the parameter in my case i want
412:13 - to go with num all i want to return here
412:16 - is num
412:18 - and the power of that if i run this now
412:21 - we get the same outcome
412:23 - if you compare this to list
412:24 - comprehension it really should look kind
412:27 - of familiar we're going to talk about
412:29 - this in a bit more detail but first of
412:31 - all
412:32 - i want to look at the filter function
412:35 - and this one filters out values
412:39 - from a
412:40 - condition
412:42 - for example let's say in this list here
412:46 - i only want to get the values that are
412:48 - smaller than four one two and three we
412:51 - would need the filter function and in
412:53 - here again
412:55 - we are going to need some kind of
412:58 - key
412:59 - and then an iterable we want to change
413:02 - the iterable in my case is going to be
413:05 - my list
413:07 - and for the key i guess
413:09 - we can create another function
413:12 - let me call it get
413:14 - below
413:15 - 4
413:16 - that is not an underscore and for this
413:19 - function
413:20 - we are going to need another parameter
413:23 - once again i'm going to stick with num
413:27 - i want to check if this number is below
413:29 - 4 so if num
413:31 - is below 4
413:34 - i want to return
413:35 - true
413:36 - and if that is not the case i want to
413:39 - return false
413:40 - and this is the function i want to pass
413:43 - in here
413:44 - and this let me comment out all of the
413:47 - stuff we have seen earlier
413:49 - now i can print my filter
413:51 - and you might already expect what we are
413:54 - going to see
413:55 - we are getting a filter object which is
413:58 - useless for us
413:59 - but we can convert it to a list
414:02 - and then we can see now we only have
414:04 - values smaller than four
414:07 - essentially what happened in here is
414:10 - that filter looks for every item inside
414:13 - of this list we are again looking at 1 2
414:15 - 3 4 and 5.
414:17 - each of these numbers is going to be
414:19 - passed into
414:22 - this get below 4 as an argument
414:25 - and depending on what python gets
414:27 - returned here
414:28 - this item either stays inside of a list
414:31 - or it gets filtered out
414:33 - if python is getting true from this
414:34 - function the number is going to stay
414:36 - inside of the list one two and three all
414:40 - have the function returning true
414:43 - however four and five
414:47 - had the function return false as a
414:49 - consequence they were filtered out out
414:52 - of the list that is literally all that
414:55 - filter does
414:57 - i guess once again i can duplicate the
415:00 - entire line because we don't have to
415:02 - create a whole function we can use
415:05 - lambdas for that which is kind of how
415:07 - this was intended to be used
415:10 - i want a lambda in here i want my number
415:13 - and in here i want to run num is smaller
415:17 - than 4
415:18 - and this works because python is going
415:21 - to convert all of this into a boolean
415:23 - value
415:24 - so if i run all of this now we are
415:27 - getting the same outcome except this
415:29 - line here is much easier and shorter
415:32 - than all of this
415:34 - and with that we have filter and map
415:38 - basically two functions you very rarely
415:41 - see nowadays
415:43 - why that is we can actually see from the
415:46 - exercise
415:47 - what i want you guys to do is to convert
415:50 - both of the power
415:53 - and the filter function so this one and
415:56 - this one here let me uncomment all of
415:58 - this
415:59 - i want you guys to convert this one and
416:02 - this one to a list comprehension
416:05 - and see how much you remember
416:10 - let me copy the two functions first and
416:13 - now i can comment out all of this here
416:16 - so we are not getting confused
416:19 - the first one is the map function
416:22 - and for this one let me do it straight
416:24 - inside of a print statement
416:26 - in here i need to square brackets for
416:28 - the list comprehension
416:30 - and now i want num for num in
416:34 - my list
416:36 - this is the list we have gotten all the
416:38 - way up here
416:39 - all we want to do is to get the power of
416:42 - it
416:43 - and with that we are actually already
416:46 - done if i run this now we're getting the
416:49 - same result
416:50 - except i think it's pretty obvious this
416:53 - is much easier to read than all of this
416:56 - which is why map is very rarely used
416:59 - nowadays
417:00 - if you really wanted to you could even
417:02 - use a function in here as well and this
417:04 - would imitate map even more
417:08 - so there's very rarely a reason nowadays
417:11 - to use map the main reason why you are
417:13 - still learning it is because some older
417:15 - code examples might use it and you know
417:18 - what they mean but chances are that you
417:20 - aren't going to use it yourself
417:23 - all right now besides that
417:25 - we can do the same thing for filter and
417:28 - let me comment out those two
417:30 - for this one again i want to have my
417:33 - list comprehension
417:34 - and i want num for num
417:38 - in
417:39 - my list
417:41 - which if i run this is giving me the
417:43 - entire list
417:44 - but now i only want this number
417:47 - if the number is smaller than four
417:51 - and running this is giving me the exact
417:54 - same result and again this is much
417:57 - easier to read than this one here
418:00 - which again is why filter is very very
418:03 - rarely used nowadays
418:05 - in this part we are going to cover file
418:07 - handling
418:09 - meaning we are going to open a file and
418:11 - we are going to write into that file
418:14 - which is surprisingly simple
418:16 - python is very capable of opening simple
418:19 - file formats the one we are going to see
418:22 - in this video is dot txt
418:24 - which is the simplest form of storing
418:26 - text on windows computers also works on
418:29 - a mac they are kind of universal
418:32 - besides that you could also open a
418:33 - picture and there are a couple of other
418:35 - basic file formats you could be working
418:37 - with but i'm going to stick to txt
418:41 - now that being said
418:42 - python could at least in theory open
418:45 - basically any kind of file
418:48 - let's say a blender file an excel file a
418:51 - word file a pdf document python can open
418:54 - all of them but most of the time you are
418:56 - going to need external modules to do
418:58 - that
418:59 - what those are and how to use them we
419:01 - are going to cover later in this series
419:04 - i guess as a good example here for some
419:06 - self-promotion a while back i made a
419:08 - video on how to create a snake game in
419:10 - excel using python
419:12 - totally doable
419:14 - kind of fun although very strange but
419:17 - anyway let's have a look at all of this
419:18 - in code
419:19 - before we start coding i want to look at
419:22 - my folder this one is looking like this
419:24 - let me extend it a tiny bit inside of
419:27 - the code i have the python file itself
419:30 - and i have a txt file called test if i
419:33 - open this one
419:34 - i am getting a simple txt file with a
419:37 - bit of text inside nothing complicated
419:40 - but well we don't want to over
419:42 - complicate things
419:43 - this is the file i want to open and this
419:46 - is also the file i want to write in keep
419:48 - in mind here both the python file and
419:51 - the text file are in the same folder
419:53 - that is important
419:55 - to open it you have two ways
419:58 - you could either open and close it
420:02 - manually
420:04 - this means
420:05 - i want to create a new variable let me
420:07 - call it file and the function you're
420:09 - looking for here is called open
420:11 - and this open wants a file path and the
420:14 - name of the file in my case this is
420:17 - going to be test.txt
420:20 - let me actually print what we get so i
420:22 - want to print the file
420:25 - we are once again get some random thing
420:28 - that we can't read but this
420:31 - we could convert to a list
420:34 - and now we have the document as a list
420:37 - with all of the text inside
420:40 - notice here at the end of each line
420:43 - we have a line break the one we have
420:45 - seen all the way at the beginning
420:48 - this way the document knows where to end
420:50 - one line
420:51 - the one thing you want to be aware of
420:53 - right now is that we only need the file
420:55 - name because both files are in the same
420:57 - folder
420:58 - if that wasn't the case
421:00 - you would have to specify in what folder
421:02 - you are for example if the text was
421:06 - inside of a folder you would need folder
421:08 - then a slash and then the name of the
421:10 - file and if you want to go up one folder
421:14 - you would need two dots and that's
421:17 - basically it
421:19 - this way you can create file paths and
421:21 - find specific documents you want to open
421:25 - besides that there's one more thing that
421:27 - you do want to keep in mind
421:29 - and that is
421:31 - we have to close the file again
421:33 - if we had a longer code example and kept
421:35 - it like this
421:37 - we would keep this file in memory which
421:40 - wouldn't be necessary
421:42 - to do that you would need file.close
421:46 - if you run this again now you are not
421:47 - going to see any difference
421:49 - but this line removes the file out of
421:51 - the memory which is more efficient
421:54 - and with that you can open and close a
421:57 - file
421:58 - that being said this approach isn't
422:00 - really used that often
422:02 - because the better way is let me call it
422:05 - open and close it
422:08 - automatically
422:11 - the way you would most of the time
422:13 - import a file is with the with statement
422:16 - in here we need with open
422:19 - and then the file name this is still
422:21 - going to be test dot txt
422:24 - and now
422:25 - you have to write s and give this a name
422:28 - in my case i am going to go with file
422:31 - what's happened here
422:33 - is basically the same that we have done
422:37 - up here
422:38 - we opened a file just like we have done
422:41 - here
422:42 - and this file we are storing in a
422:44 - variable called file the same thing we
422:46 - have done up here
422:49 - the difference now is we have to write
422:51 - some indented code in here
422:55 - and as soon as this indentation is over
422:58 - then we are closing the file
423:00 - automatically that way we are not going
423:02 - to need this line here this is also more
423:05 - deliberate and possibly easier to read
423:08 - it's basically up to you both approaches
423:10 - are fine but this is the one you are
423:12 - going to see more often
423:14 - in here we could for example print
423:17 - and let me use the same line
423:19 - i want to print the list of my file
423:22 - and we get exactly the same outcome
423:25 - let me comment out the earlier part
423:27 - because this is the one i want to work
423:28 - with the most now python has a few
423:31 - functions that you can use to read
423:35 - documents especially txt files
423:37 - the one you're probably going to use the
423:39 - most is file.read
423:42 - don't forget the brackets if you're
423:44 - calling this you get a proper output
423:48 - from all of the stuff
423:50 - read basically converts this into
423:52 - something that you can work with more
423:53 - easily
423:54 - although keep in mind this read
423:57 - is going to return if i use the type
424:00 - function it is going to give me a string
424:03 - which means if i convert all of this to
424:06 - a list
424:07 - i would get a whole bunch of individual
424:09 - characters that don't help me that much
424:12 - the way you want to use this read
424:14 - function is just to get an overview of
424:16 - what you have it's kind of difficult to
424:18 - cycle through this
424:21 - but for that you could use something
424:23 - like for
424:25 - line
424:26 - and then i want the list of the file and
424:29 - now i can print
424:31 - the line and i want to comment out this
424:34 - part here and now i get basically the
424:37 - same thing
424:38 - since i'm not going to use this too much
424:39 - i'm going to keep it short but this is
424:41 - kind of all you need to know about it
424:44 - if you had other kind of data you could
424:46 - work more with this but that's beyond
424:49 - this video
424:51 - what is not beyond this video is write
424:54 - some
424:55 - file
424:58 - let me comment all of this out
425:00 - and
425:01 - to write a file we again need with open
425:05 - and in here i again want to open my
425:09 - document
425:11 - but now i have to specify another
425:13 - argument
425:15 - and this has to be a string
425:17 - most of the time this could be r it
425:20 - could be a
425:21 - or it could be w
425:23 - r stands for read a stands for append
425:26 - and w stands for write
425:29 - the default one is r meaning we are just
425:32 - going to read the document
425:34 - but the one that we could also use is a
425:37 - for append
425:39 - and now i want to keep this as a file
425:42 - and in here now i could use file dot
425:45 - write
425:46 - as an argument in here i can now
425:49 - write some more text
425:52 - and just to make it a bit more visible
425:54 - let me add
425:55 - a whole bunch of axes
425:57 - so we know what we're doing
425:59 - if i run the code now
426:00 - we cannot see any kind of difference
426:03 - that being said if i now
426:06 - open the folder again
426:08 - open the document we can now see
426:10 - the end the one we already had and then
426:13 - write some more text with axes around it
426:17 - the kind of annoying thing here is at
426:19 - the end we don't have a line break
426:22 - this one you would get by adding
426:25 - a line break character manually and now
426:28 - if i run this again
426:29 - and open the folder
426:32 - with the document we now have all of
426:35 - this on a whole new line
426:37 - and you do want to be careful here
426:40 - because this a means append if you write
426:44 - w
426:45 - you're going to write a whole new file
426:47 - with this content here
426:49 - let me run it
426:52 - if i open the folder again
426:54 - test file is still there but if i open
426:56 - it we only have write some text with a
426:59 - line break on the first line the reason
427:02 - here is that this w tells python to
427:06 - create a whole new file if there already
427:08 - is a file python is going to write over
427:11 - it
427:12 - and this you could also use to create
427:14 - new files
427:15 - for example if i renamed this test to
427:18 - new
427:19 - file
427:20 - that is terrible spelling
427:23 - if i run this now with proper spelling
427:25 - and open the folder we now have new file
427:29 - python has created a text document
427:32 - and that is basically all you need to
427:34 - get started with reading and writing
427:36 - into text files
427:38 - let's do an exercise
427:40 - i want you guys to create a new text
427:43 - file and draw a tree in it
427:46 - kind of like the tree we have seen all
427:48 - the way at the beginning of this entire
427:50 - series
427:51 - so pause the video now and try to figure
427:53 - this one out yourself
427:57 - i
427:58 - first of all want to comment out all the
428:01 - stuff i had earlier
428:02 - and now i want with
428:05 - open
428:06 - and let me call this tree dot txt
428:10 - for this one to work i need w as an
428:13 - argument
428:14 - and i want to call this one as
428:17 - let me call it the tree
428:19 - file
428:21 - inside of here let me save the tree
428:24 - inside of a string
428:26 - and this i want to do
428:28 - with the triple quotation marks
428:31 - that are going to be assigned to the
428:33 - tree string
428:34 - i have to work with white space and
428:37 - access
428:38 - to create a tree so
428:42 - three axis i hope i can still
428:45 - get it just right
428:47 - something like this should be good
428:50 - and i realized i have one quotation mark
428:53 - too much
428:54 - now that i have that i want to have my
428:56 - tree file
428:58 - and i want to write in it what i want to
429:00 - write is the tree string
429:03 - now i can run this
429:05 - we don't have an error that's a good
429:06 - start and if i open my folder once again
429:10 - we now have a tree file and inside of
429:12 - that we have a tree although i messed up
429:15 - here a tiny bit
429:17 - i think if i put this x on the next line
429:20 - run this again
429:22 - and open my folder run this now and
429:25 - there we go now we have a tree or an
429:27 - arrow but you get the idea
429:30 - and all right with that we have file
429:33 - writing and file opening for this part
429:36 - we are going to look at deleting stuff
429:38 - which is something you can do but you
429:41 - rarely need to let's talk about it
429:43 - the way you can delete something in
429:45 - python is with the del keyword
429:48 - this one here all you have to do is
429:50 - specify what you want to delete and
429:52 - python gets rid of it this would even
429:54 - work with variables if you delete them
429:57 - they are going to be gone thing is
429:59 - you basically never need it that way it
430:03 - hardly ever happens that you absolutely
430:05 - have to get rid of a variable
430:07 - instead most of the time you only need
430:10 - to delete values from a list and this is
430:12 - what i am going to focus on for this
430:15 - part
430:16 - let's have a look at it
430:17 - i want to start by just creating a basic
430:19 - variable let me call it a and give it a
430:22 - value of 1.
430:24 - inside of my python file i want to
430:26 - create one variable let me call it a it
430:28 - really doesn't matter because we are
430:30 - going to delete a
430:33 - if i print
430:35 - a now
430:36 - hyphen is going to be unhappy because a
430:38 - is not defined
430:40 - which is python's way of saying a does
430:42 - not exist
430:43 - which makes sense because we just
430:45 - deleted a
430:47 - that's kind of all you need here
430:50 - the thing is this kind of operation you
430:53 - basically never do there just isn't a
430:55 - need for it
430:57 - although if you are going to learn other
430:59 - languages they are much more aggressive
431:01 - about clearing memory after you used
431:03 - something so you might see something
431:06 - there
431:07 - but in python
431:08 - all you ever really are going to do is
431:11 - remove items from
431:13 - a
431:14 - list
431:15 - i guess let me reuse a and i want to
431:18 - assign it
431:19 - one two and three and i want to delete
431:23 - individual values from this one
431:25 - here delete is where you are going to
431:28 - see it the most it removes an item by
431:32 - index
431:35 - so for example i could write delete a
431:38 - and then the index 1.
431:40 - if i now print a
431:42 - we are getting an error message because
431:44 - up here we still have the problem if i
431:47 - comment this one out run this again we
431:49 - now can see one and three the reason we
431:53 - can't see two anymore
431:54 - is because we deleted the item with the
431:57 - index 1. inside of a we have index 0
432:01 - index 1 and index 2
432:03 - and we have told python to delete the 1
432:06 - with the index 1. that's all that
432:08 - happened here what you could also do let
432:11 - me comment this one out
432:13 - you can remove an item by value and this
432:17 - should be a comment
432:20 - so let's say in this list
432:23 - you want to get rid of any value that
432:25 - has a free but you don't know what index
432:28 - that three is on
432:30 - for that python or while a list has to
432:33 - remove method
432:35 - all you need is a dot remove and then
432:38 - specify what you want to get rid of in
432:40 - my case a free
432:42 - if i now print the list
432:45 - we only get one and two the three has
432:48 - disappeared
432:50 - besides that let me comment this one out
432:53 - you can also use the pop
432:56 - method
432:57 - what this one does is it removes an item
433:00 - again by index although the default
433:02 - value here is negative one after i have
433:06 - run this i can print my list again
433:09 - and we again get rid of the three all
433:12 - the way at the end
433:13 - the difference between pop and remove is
433:16 - that pop pops out the value we have
433:18 - deleted meaning we could print this one
433:22 - as well
433:23 - so if i run all of this i get free the
433:26 - value that was deleted and then the list
433:28 - itself with this line here
433:30 - and finally
433:32 - you can just clear the entire list
433:37 - and this i think we have actually
433:38 - already seen all you need is a dot clear
433:42 - and if you then print the list
433:44 - it is going to be empty
433:46 - most of the time this is kind of
433:48 - overkill but well it is something you
433:50 - can do
433:52 - and with that you have a couple of
433:53 - operations to get values out of a list
433:56 - or well remove items from a list
433:59 - in this tutorial we talk about objects
434:01 - and classes
434:03 - and well more specifically i will talk
434:05 - about what objects and classes are i
434:08 - will cover how to create and use them we
434:10 - will cover dunder methods and also
434:12 - simple and complex inheritance
434:14 - and finally i will cover how to use
434:16 - classes in practice and well let's get
434:19 - started by talking about what objects
434:21 - are in the first place
434:23 - and well an object is just a container
434:26 - for variables and functions
434:29 - for example
434:30 - we could make a video game with lots of
434:32 - monsters and i think video games are
434:35 - really good way to explain objects so i
434:38 - will stick with that for this entire
434:39 - video
434:41 - but basically for the monster we are
434:43 - going to create we want to have
434:44 - variables and functions
434:46 - and in this case i want the monster to
434:48 - have some health some energy stamina and
434:51 - damage and you could add whatever else
434:54 - you want in here it's really up to you
434:56 - and then besides that the monster should
434:58 - also be able to attack to move to
435:00 - animate and again you could add whatever
435:02 - else you want in here
435:05 - and what you have to understand here is
435:07 - that these variables and functions
435:10 - only exist inside of this monster object
435:14 - it's very similar compared to the local
435:16 - scope of a function if we tried to get
435:20 - this health outside of the container it
435:22 - wouldn't exist because this health
435:24 - exists only inside of a monster object
435:27 - although in terms of naming there's one
435:29 - minor complication and that is special
435:32 - names
435:34 - all that really means is that variables
435:36 - inside of an object are called
435:37 - attributes and functions in an object
435:39 - are called methods
435:41 - and that is more or less the only
435:44 - difference
435:45 - the only reason why this exists is so
435:47 - that we are a bit more specific with our
435:49 - language
435:51 - for example when you talk about health
435:53 - with somebody else for your game you
435:56 - really want to emphasize that you don't
435:57 - talk about a global variable you talk
436:00 - about the specific attribute of one
436:02 - object
436:03 - and one more thing methods
436:06 - should actually be familiar to you
436:07 - because you are using methods very very
436:10 - often in python anyway for example when
436:13 - you call the upper method on any kind of
436:14 - string you are turning every letter
436:17 - inside of that string to an uppercase
436:18 - letter and that is also a method and
436:22 - that is the same kind of method we are
436:24 - seeing here essentially a string in
436:27 - python is just another object with
436:29 - functions inside of it
436:32 - or methods to be more specific this also
436:34 - applies to integers floating point
436:36 - numbers booleans all of that stuff is
436:39 - basically just other kinds of objects
436:40 - that python creates but that's something
436:43 - we don't have to worry about for now
436:46 - now another thing that is really
436:48 - important to understand is that it is
436:50 - possible to have multiple objects for
436:52 - example i could create three different
436:55 - monsters
436:56 - and each of these monsters could have
436:58 - customized attributes
437:01 - these
437:02 - red
437:04 - pieces of text here
437:06 - so my first monster has 90 health 20
437:08 - energy the next monster has 60 and 40
437:11 - and the final monster has 40 and 10.
437:14 - so when you create an object you can
437:17 - give it custom attributes however this
437:19 - does not apply to methods
437:23 - and as you can see here monster 1
437:25 - monster 2 and monster 3
437:28 - all have the same methods
437:31 - and these can be customized to an extent
437:34 - but not nearly as much as the attributes
437:36 - that's something you do want to keep in
437:38 - mind
437:39 - but still each object has its own
437:41 - attributes and methods
437:44 - meaning that this attack here and this
437:48 - attack are not the same function or well
437:50 - the same method
437:52 - they always apply to their respective
437:54 - object
437:56 - and what you can also do is have objects
437:59 - interact with each other
438:00 - for example
438:02 - if
438:03 - monster 3
438:04 - attacks
438:06 - one stat 2
438:07 - we could run some code to reduce the
438:09 - health of monster 2 from 60 to let's say
438:12 - 20.
438:14 - and that actually brings us to a really
438:16 - important topic and that is object
438:19 - oriented programming or oop in short
438:23 - and all that really means is that you
438:25 - are organizing your code via different
438:27 - objects
438:28 - and then you make these objects interact
438:30 - with each other
438:32 - and this approach is basically how
438:34 - almost all large projects are made in
438:37 - any programming language or at the very
438:39 - least any modern programming language
438:42 - meaning if you don't understand classes
438:43 - you will be very much lost and well you
438:46 - will have no idea what you see when you
438:48 - look at larger examples of code
438:50 - here we have a couple more objects
438:53 - we still have monster 1 and monster two
438:56 - but now we also have a player we have an
438:58 - obstacle and we have a menu
439:01 - and all of these have slightly different
439:03 - attributes and slightly different
439:05 - methods
439:06 - and just to talk about how these
439:08 - different objects can interact with each
439:10 - other the one we have already seen is
439:12 - that monster 2 could for example attack
439:15 - monster 1 and then monster 1's health
439:18 - be reduced from 90 to 60.
439:22 - and if monster 2 is attacking it might
439:25 - reduce its own energy from 40 to 20.
439:29 - so attacking isn't free for the monster
439:32 - what we can also do
439:34 - is have an object without any methods
439:37 - like the obstacle here and all the
439:39 - obstacle is is well an object with a
439:42 - position and a size
439:45 - and this we could use for example with
439:47 - the move method of any of the other
439:50 - classes
439:52 - so the player and the monsters
439:54 - all have a move method and this could
439:56 - interact with the obstacle
439:59 - and let me clean this up something even
440:01 - more interesting if you look at the
440:03 - player this one here and the menu
440:06 - those two do look very much connected
440:10 - because the player has one method called
440:13 - menu
440:14 - and what this one would do
440:16 - is to create or the very least open a
440:19 - menu
440:20 - and then when we create the menu we are
440:23 - passing in the player itself so this
440:26 - player here
440:28 - is going to be passed in as one
440:30 - attribute of the menu object and this is
440:33 - totally fine to do you can totally add a
440:36 - function or an object inside of another
440:39 - object as an attribute
440:41 - and then
440:42 - this select could for example change
440:46 - the weapon of the player
440:48 - and we could close the menu as well
440:51 - and i hope this makes sense the main
440:53 - thing you have to understand is that
440:55 - objects can interact with each other
440:58 - and this is how you want to organize
441:00 - code it makes it very easy to work with
441:03 - and especially for larger bits of code
441:06 - this approach is essentially mandatory
441:09 - or at the very least it's the easiest
441:11 - way to organize it
441:12 - and let's actually do a practical
441:14 - example here is zelda like game that i
441:17 - made a while ago and basically
441:20 - everything you see on the screen is an
441:22 - object
441:23 - for example right in the middle we have
441:26 - the player and that's one object
441:28 - and we also have this raccoon here and
441:30 - this spirit and each of those are one
441:33 - object
441:35 - and beyond that each of these flames
441:38 - here is its own object and these are
441:41 - only created when the player is
441:43 - attacking with some magic
441:46 - and finally in the top left
441:49 - the
441:50 - bottom left and the bottom right
441:53 - you can see some ui elements
441:55 - and they are all part of the same object
441:59 - and this object is very much related to
442:02 - the player so those two work together
442:04 - very closely
442:06 - and besides that each of these pillars
442:09 - and trees
442:11 - and rocks and statues they are all
442:13 - objects that i created just for this
442:16 - game
442:17 - so i hope that illustrates how useful
442:19 - objects are that make it really easy to
442:22 - group together code chunks that should
442:24 - belong together
442:26 - and for a bit more detail the raccoon
442:28 - for example has three attributes health
442:30 - speed and damage and the methods attack
442:33 - and move
442:34 - and all the other objects would have
442:36 - similar attributes and methods
442:40 - and with that we have objects now the
442:43 - next question is what are classes
442:46 - and this is fairly easy to explain as
442:49 - well the class is basically a blueprint
442:52 - for an object
442:53 - meaning whenever we create an object we
442:56 - first have to create a class
442:58 - and a class can also accept arguments to
443:00 - customize the object we are creating
443:03 - for example this would be a class we
443:06 - have a class and this class has two
443:09 - attributes health and energy and right
443:12 - now the value for both of these is not
443:14 - being set
443:16 - this we do when we actually use this
443:18 - class to create an object
443:20 - but this class also has two methods
443:23 - attack and move
443:24 - and those do not change
443:26 - and basically what we're doing
443:29 - is use this class to create the object
443:32 - and in the process
443:34 - we are giving it the specific values for
443:37 - health and energy so in this case the
443:40 - monster is going to have 90 health and
443:42 - 20 energy
443:43 - and this process we could do as many
443:45 - times as we want for example earlier you
443:48 - have seen monster 1 we had monster 2
443:51 - monster 3 and we could continue with
443:53 - monster 4 5
443:55 - up to an unlimited number of monsters
443:59 - and that is essentially the main idea
444:02 - all you really have to understand is
444:03 - that we always need a class to create an
444:05 - object
444:07 - now what we can also do with classes is
444:09 - that one class can inherit from another
444:12 - class and the resulting objects will
444:14 - have attributes and methods from both
444:16 - classes
444:18 - for example
444:20 - let's say we want to create a shark
444:22 - class and this one right now only has
444:24 - speed for the attribute and byte for the
444:26 - method
444:28 - and this class will be fairly limited
444:30 - because we well don't have any attribute
444:33 - for health or for energy and we also
444:35 - don't have any kind of method for move
444:38 - or attack
444:39 - but we don't need to because what we can
444:41 - do is have this shark class inherit from
444:44 - the monster class and this means
444:47 - this shark is going to get the health
444:50 - and the energy
444:52 - from the monster parent class
444:54 - and that is also going to get the attack
444:57 - and the move
444:58 - from this class as well
445:01 - meaning when we actually use the shark
445:03 - class
445:04 - to create a shark object we are going to
445:07 - get health energy and speed for the
445:09 - attributes and attack move and byte for
445:11 - the methods
445:13 - and i think i should use better colors
445:16 - here
445:17 - in the shark class health and energy
445:21 - are coming from the monster class
445:24 - same with attack and move
445:27 - those two are coming from the monster
445:30 - class
445:32 - and then speed and
445:36 - byte
445:38 - are from the shark class
445:42 - and this would allow us to reuse code
445:45 - quite extensively for example we could
445:48 - have a lot of different monsters we
445:50 - could have a shark some flying enemy
445:53 - some armored enemies lots more and they
445:56 - all inherit from this one monster class
445:59 - and with this approach
446:01 - we would save a ton of writing in terms
446:03 - of code and on top of that if we change
446:07 - the move method for example
446:09 - it would affect every single other class
446:11 - as well
446:12 - which is very useful if you want to make
446:15 - some changes and make it affect every
446:17 - single other class
446:19 - and especially with larger projects this
446:22 - is just about the only way to manage
446:24 - them
446:25 - and let's do an example again
446:28 - here is the screenshot from earlier and
446:30 - we have a monster class we have another
446:32 - monster class and those two have the
446:35 - same attributes and methods although
446:37 - with different values
446:39 - and besides that we also have the player
446:42 - and what is really important to
446:43 - understand here is that all of these
446:45 - inherit from the entity parent class
446:49 - and this for example contains the method
446:51 - for movement
446:53 - because all of the monsters and the
446:55 - player move in the same way so they
446:58 - could share this method quite easily
447:02 - and just to emphasize it i do want to go
447:04 - over the advantages of classes and
447:06 - objects
447:08 - and the first point here is that classes
447:10 - and objects help you organize complex
447:12 - code
447:13 - and the second point is related classes
447:16 - and objects also help you to create a
447:18 - reusable code and just from these two
447:21 - points i hope it becomes obvious that if
447:24 - you want to create some really large
447:26 - projects let's say a really good looking
447:28 - game you need objects and classes
447:31 - without them it's still possible but
447:34 - significantly more difficult
447:36 - besides that
447:38 - classes are also used everywhere
447:41 - meaning if you don't understand them you
447:44 - will be very much lost
447:46 - as a matter of fact in python there are
447:49 - quite a few modules that require you to
447:52 - use classes
447:54 - for example pygame tkinter and
447:57 - matplotlib respectively the model you
447:59 - use for games for guise and for data
448:01 - analysis they all work with classes
448:04 - primarily
448:06 - so if you don't know how to use it you
448:08 - pretty much cannot use these modules or
448:10 - at least you could only use a very small
448:12 - part of them
448:14 - and there's one more point that i
448:15 - haven't mentioned yet
448:17 - and that is that classes make it much
448:19 - easier to work with scope
448:21 - i will talk about this in more detail
448:23 - later
448:24 - but if you struggled so far with getting
448:26 - information in and outside of functions
448:29 - you will really like classes that make
448:31 - it very easy to work with different
448:33 - levels of scope
448:34 - so these are the arguments where you
448:36 - would want to use classes and objects
448:38 - however
448:39 - you can write code without using objects
448:42 - at all and this is very common
448:44 - especially for beginners and let me
448:47 - illustrate the problem here
448:49 - the yellow line is the need for classes
448:53 - and especially when you start writing
448:54 - code let's say you are somewhere here
448:57 - and your average program is something
448:59 - like 50 lines of code
449:02 - in this case there really isn't any need
449:04 - for classes because well your code is
449:06 - very simple and there isn't any need to
449:09 - organize complexity
449:10 - however the longer and more complex your
449:13 - code is becoming the more you will need
449:16 - classes
449:18 - and this ramps up really really fast
449:21 - but as long as you are in this area here
449:25 - it well it's very tempting to never use
449:28 - a class and ignore them entirely and
449:31 - this especially as a beginner you really
449:33 - want to avoid
449:34 - so even though when you are here
449:37 - i would really recommend you to use
449:39 - classes even though it's not strictly
449:41 - necessary in your example
449:43 - just to practice for more complex code
449:45 - because when you are an actual software
449:47 - developer you are never going to write
449:49 - just 50 lines of code most of the
449:51 - programs you are going to work are
449:53 - somewhere here with a few thousand lines
449:56 - of code let's say 2000
449:59 - and if you are up here and you don't use
450:01 - classes
450:02 - you are going to be in a lot of trouble
450:06 - but all right with that we have the
450:08 - theory of objects and classes
450:11 - and for the next part
450:14 - we are actually going to create and use
450:16 - objects
450:18 - so let's have a look at some code
450:22 - here i have a completely empty sheet of
450:24 - code and the first way i want to do is
450:26 - to create a class and this you do with
450:29 - class and then the name of the class
450:32 - in my case i want to go with monster
450:35 - and here already we have to cover
450:37 - something important and that is the
450:39 - naming scheme
450:41 - so far in python what you probably have
450:44 - written is something like monster
450:47 - and generally you always used the snake
450:50 - case styling for any kind of text
450:53 - so why is this different here
450:57 - and well in python by convention last
451:00 - names are always written in the camel
451:02 - case so camelcase looks like this
451:07 - where you don't have any spaces between
451:08 - words or well any underscores but any
451:11 - word starts with an uppercase letter
451:15 - and this is different from normalpython
451:17 - where variables are written in snake
451:19 - case where everything is lowercase and a
451:22 - space is an underscore
451:24 - and this isn't strictly necessary you
451:27 - can call a class
451:28 - monster with a lowercase m just fine
451:31 - this is purely convention
451:34 - but all the other python requirements
451:36 - for naming still apply for example a
451:39 - class couldn't start with a number
451:42 - and we also couldn't have a space in
451:44 - between so we don't have to learn any
451:47 - new naming scheme now next up what you
451:49 - have to do is a colon
451:51 - and now in here
451:52 - we can work on the attributes and
451:54 - methods of our class
451:56 - and for now i just want to create some
451:58 - basic attributes
452:00 - let's say i want to give this monster
452:02 - some health and for now i want to have
452:04 - specific numbers let's say 90
452:07 - i want to have energy and this one
452:09 - should be 40.
452:11 - so now we have a class
452:14 - and what we have to do now is turn this
452:17 - class into an object
452:19 - and this we do by typing the name of the
452:21 - class and then calling it by using
452:23 - brackets
452:24 - again very similar compared to functions
452:28 - and this is going to return the object
452:31 - so we have to capture that in a variable
452:34 - and this very often
452:36 - is written like this
452:38 - and here i hope you can see why we have
452:41 - the different naming schemes
452:43 - to python
452:45 - this name here and this name here are
452:47 - two completely different things because
452:49 - one starts with a lowercase the other
452:51 - with an upper case
452:53 - although to us as the programmer
452:56 - we can tell that those two are related
452:58 - because they basically have the same
453:00 - name
453:01 - and for that reason we are usually
453:03 - writing class names in camel case and
453:06 - variable names in snake case it makes it
453:09 - very easy to connect these two and
453:11 - clearly indicate that they are connected
453:14 - although you don't have to do any of
453:15 - this you could totally call this i don't
453:17 - know hamster
453:19 - and this could be
453:21 - lowercase it's totally fine all of this
453:24 - is just convention
453:26 - although you should follow conventions
453:28 - they are there for a reason
453:30 - but i can run the code now and i am not
453:32 - getting an error that's a good sign
453:35 - and now what i can do i can use print
453:38 - and
453:39 - monster
453:40 - dot let's say health
453:43 - and now if i run this we are getting 90.
453:46 - and this knight here is coming from this
453:50 - health
453:52 - and the same would also work for energy
453:55 - in just the same way so we get 90 and
453:57 - 40.
453:59 - now just to emphasize that both this
454:01 - health and this energy only exist inside
454:04 - of this class let me print
454:08 - health by itself that is horrible
454:10 - spelling health
454:12 - and if i run this python is going to
454:14 - give me an error and we have name health
454:17 - is not defined
454:19 - meaning python
454:21 - cannot find this health anywhere in the
454:24 - global scope which makes sense because
454:26 - there is no health in the global scope
454:28 - we only have health in the scope of this
454:31 - monster class
454:32 - and let me add
454:35 - some comments here to make this a bit
454:36 - more readable
454:38 - we have attributes and besides that i
454:40 - also want to create methods
454:42 - and those work kind of like functions we
454:45 - again need the define keyword or def
454:49 - and now we need a name for our function
454:53 - and for that we have the exact same
454:54 - naming scheme for normal functions
454:57 - for example attack would be a perfectly
454:59 - fine name
455:01 - and after that you need a colon and then
455:04 - let's say for this attack method i want
455:06 - to keep it simple and just print
455:09 - the monster has attacked
455:13 - and now i can call monster dot attack
455:17 - and don't forget the brackets and now if
455:20 - i run this
455:21 - we are getting an error
455:23 - and this error says
455:26 - that monster.attack takes zero position
455:29 - arguments but one was given and this is
455:33 - probably very confusing
455:35 - because when we called this method here
455:38 - we didn't pass anything inside of it
455:41 - and the method itself doesn't have any
455:44 - parameters so why is python being so
455:48 - weird here
455:50 - now the reason why this is happening is
455:53 - that whenever we call a method so a
455:55 - function inside of a class
455:58 - what is going to happen is that python
456:00 - automatically passes a reference to the
456:02 - object created by the class as the first
456:05 - argument into the method
456:08 - in this first argument we always have to
456:10 - capture with some kind of parameter
456:14 - meaning a method always needs at very
456:17 - least one parameter
456:19 - for example i could just write monster
456:21 - in here
456:22 - and if i run this now we get the monster
456:25 - has attacked
456:28 - and let me just print what we actually
456:30 - get so i want to print the monster we
456:32 - get as an argument in here
456:36 - and what we get is main monster object
456:39 - at somewhere in our memory
456:42 - and well in my case i don't really care
456:45 - about this monster so let me remove the
456:47 - print statement but i do have to keep
456:50 - this first parameter
456:52 - however once we have the first parameter
456:55 - i can add as many custom parameters as i
456:58 - want
456:59 - for example i could add the amount of
457:02 - damage here
457:04 - and i could let's say print the amount
457:07 - with an f string
457:09 - and i want to say
457:12 - the
457:13 - amount
457:15 - of damage was
457:18 - dealt
457:19 - and now when i call this method down
457:22 - here i can pass in any number i want
457:25 - and i get the monster as attacked 40 of
457:27 - damage was dealt that does not make
457:30 - sense in terms of grammar let's try this
457:31 - again but the damage was dealt that
457:34 - feels much better
457:35 - what is really important to understand
457:37 - here is that this monster or more
457:40 - specifically the first parameter of any
457:43 - method always references
457:46 - the object created by the class so this
457:50 - class up here
457:51 - creates an object and then this monster
457:54 - is a reference to that object
457:57 - the monster is not a reference to the
457:59 - class itself
458:01 - and this is really important because
458:03 - that way you can create multiple objects
458:06 - that always work with the first
458:08 - parameter here for example i could have
458:11 - monster 1 that i'm creating from the
458:14 - same class and now call
458:16 - monster 1 dot attack let's say with 10
458:21 - in here
458:22 - and now the first argument passed in
458:24 - here and the first argument passed in
458:26 - here are different
458:29 - essentially we are passing this monster
458:31 - in here
458:32 - and this monster one in here
458:35 - that way this first parameter is really
458:38 - flexible it can target any kind of
458:40 - object or more specifically any kind of
458:43 - object you are using it with
458:45 - i don't want to do this one right now
458:47 - but what you could also do
458:50 - if i add another line here you could for
458:52 - example print monster dot energy
458:56 - this once again
458:57 - would target
458:59 - this first parameter and then this first
459:01 - parameter targets the object itself
459:05 - which in this case is going to give me
459:08 - the energy here the one i've just drawn
459:10 - over
459:11 - but if i run
459:12 - this we are getting 40 the 40 we have
459:16 - seen from here
459:18 - and this right now is created in a class
459:20 - but later on when we use this class to
459:23 - create an object every single object
459:25 - would have this energy attribute and
459:28 - this is what we are referencing here
459:32 - and what you could also do
459:34 - is increase this amount
459:37 - so monster.energy
459:40 - minus equal 20 and if i print it now we
459:44 - get 20.
459:46 - and i hope you can tell how useful this
459:48 - can be because if you imagine that this
459:51 - monster here is the global scope and
459:53 - these attributes are global variables
459:57 - if this attack was just a normal
460:00 - function then this
460:02 - would not work
460:05 - because you would be creating a local
460:06 - variable that wouldn't work with the
460:08 - global ones but because of this first
460:12 - argument that the method always gets
460:15 - we can influence variables or well
460:17 - attributes outside of this function
460:20 - which is incredibly useful
460:23 - so i hope this kind of method here makes
460:26 - sense
460:27 - as a matter of fact let's practice this
460:29 - one i want you guys to create another
460:32 - method for this monster and this one
460:34 - should be called move
460:36 - and it should accept one parameter
460:38 - besides the reference to itself
460:41 - and that is the speed of the movement
460:43 - and then inside of the method you should
460:45 - just print that the monster has moved at
460:48 - a certain speed it doesn't really matter
460:50 - what you put in here as long as it is
460:52 - working
460:53 - so try to figure this one out yourself
460:59 - alright let's try together now i want to
461:01 - create a method called move
461:05 - and in here i want to have speed as a
461:07 - parameter
461:08 - however what we have learned from the
461:10 - attack method is that we always need a
461:13 - reference to the object as the first
461:14 - parameter
461:16 - meaning
461:17 - the first parameter here should be
461:19 - something for the monster
461:21 - and it really doesn't matter what you
461:23 - call it
461:25 - so i could even write something in here
461:27 - it would still work
461:29 - and now in here i can print
461:32 - the monster
461:34 - has
461:35 - moved
461:37 - and let me add another line with an f
461:40 - string
461:43 - that says it has a speed of
461:47 - and then
461:48 - the speed
461:50 - and let me fix the typo
461:52 - and now i can call monster dot move
461:57 - and add let's say a 10 in here and let
461:59 - me comment out monster.attack and let's
462:02 - see what we get
462:04 - the monster has moved it has a speed of
462:06 - 10.
462:07 - so all of this seems to be working very
462:10 - nicely
462:11 - now obviously calling this first
462:13 - parameter something is a bit confusing
462:18 - and as a consequence in python there is
462:20 - a convention that this first parameter
462:23 - is always called self
462:25 - and this applies to all of the methods
462:28 - meaning this is what you are going to
462:30 - see most of the time and what i am going
462:33 - to use as well
462:35 - you don't have to do it but i think it
462:37 - makes the most sense
462:39 - although i do want to emphasize that
462:41 - this parameter here and this parameter
462:43 - here have no relation whatsoever they
462:47 - are entirely separate
462:50 - but it is totally fine to call self here
462:53 - and self here the names are not in
462:55 - conflict with each
462:56 - other and all right with that we have
463:01 - the very basics of using classes and
463:04 - objects
463:05 - although right now we do have a problem
463:08 - that our monster always has the same
463:10 - health and the same energy
463:12 - so even if we created multiple monsters
463:15 - so what i could be doing
463:17 - is
463:18 - monster 1 monster 2 monster 3
463:22 - and let me get rid of this one here all
463:26 - of these monsters would have the same
463:28 - amount of health and the same amount of
463:30 - energy
463:31 - and they all have the same attack and
463:33 - move method
463:34 - which is fine to an extent but i do want
463:37 - them to have different amounts of health
463:39 - and different amounts of energy
463:41 - and to implement that we need another
463:43 - concept and that is called dunder
463:45 - methods so let's talk about that one and
463:48 - the dunder here just stands for double
463:52 - underscore meaning we are talking about
463:54 - a double underscore at the beginning and
463:57 - at the end of the method
463:59 - but it's important here we are still
464:01 - talking just about methods
464:05 - so essentially we are calling a specific
464:07 - kind of function
464:09 - and let's talk about why it's special
464:12 - a dunder method is just another method
464:16 - the thing that makes it special is that
464:18 - it is not called by the user instead it
464:21 - is called by python when something else
464:23 - is happening
464:24 - for example there is the done therein
464:26 - method and this one is called when the
464:28 - object is being created another example
464:31 - is the lan method and this one is called
464:34 - when the object is passed into the len
464:36 - function
464:37 - and besides that we also have done the
464:39 - apps and this one is called when we are
464:41 - passing the object into the apps
464:42 - function
464:43 - and that is really the entire idea it
464:47 - honestly isn't that complicated the most
464:50 - important dunder method you have to
464:51 - understand is done their init
464:54 - this one you are going to be calling all
464:56 - the time
464:57 - but let's actually do all of this in
464:59 - code that should make the most sense
465:02 - all right here we have the class i
465:04 - created earlier
465:06 - and
465:06 - what we have seen earlier as well i can
465:09 - create monster one
465:11 - and that is just going to be the monster
465:15 - and i can also have monster two
465:18 - and if i now print
465:21 - monster 1
465:23 - dot health
465:24 - and monster 2 dot health
465:27 - we get the same number
465:29 - because we always set health to 90.
465:31 - there's no way to customize it
465:34 - and basically what i want to do is as
465:36 - soon as the class is being created then
465:39 - i want to create these different
465:41 - attributes
465:42 - and instead what i want to do is when
465:44 - this class is being created i want to
465:47 - create this health and this energy with
465:50 - custom values
465:51 - and for that to work
465:53 - we need to define a dunder method and
465:56 - the one we need is called dunder init
466:00 - and this is just going to be another
466:02 - method like attack and move we are just
466:05 - calling a method meaning the first
466:07 - parameter here has to be a reference to
466:09 - the class itself
466:11 - and for now let me just print
466:14 - the monster was
466:16 - created
466:19 - and do pay attention i am never calling
466:22 - the init method myself but if i run this
466:25 - we get the monster was created the
466:26 - monster was created and then 90 and 90.
466:31 - and what that means if i minimize this a
466:33 - bit
466:34 - every time we are creating a monster so
466:36 - first here
466:38 - and then here
466:40 - then we are calling this dunder method
466:44 - and this standard method we can also
466:46 - give some parameters for example we
466:49 - could specify in here the amount of
466:50 - health and the amount of energy we want
466:54 - and well i hope you can see where this
466:57 - is going
466:58 - basically what we can do now is we can
467:00 - set self.health
467:03 - to whatever health parameter we pass in
467:06 - and we can do the same thing for energy
467:09 - and the names here might be a bit
467:11 - confusing so let me add a bit of white
467:13 - space and explain
467:15 - this self.health here
467:17 - is referring to
467:19 - this self.health of the monster class
467:23 - whereas this health here
467:25 - refers to this parameter
467:29 - and the important point here is self
467:31 - because this one specifies where health
467:33 - belongs to
467:34 - i hope this makes sense this is
467:36 - something you see fairly often
467:39 - let me remove the white space again
467:42 - and now when i am calling the monster i
467:45 - can either pass in arguments or named
467:47 - arguments
467:48 - let's say for the first monster i want
467:50 - health 10 and energy 20
467:53 - and for the second monster i could
467:55 - specify health being 50
467:59 - and energy being 100.
468:03 - now if i run all of this we get monster
468:06 - 1 health is 10 and monster 2 health is
468:10 - 50.
468:12 - and this 10 here refers to this 10 and
468:16 - this 50 is referring to this 50 here
468:21 - meaning now we can have custom
468:23 - attributes
468:24 - and what is even better
468:26 - since this self
468:28 - is a reference to the class itself we
468:31 - can just create the attribute in here
468:34 - which means we don't need those lines at
468:37 - all it would still work without them
468:40 - if i run this now this is still working
468:43 - just fine
468:45 - and this is what you see most of the
468:48 - time where the class by itself doesn't
468:51 - have any attributes we only create
468:53 - attributes when we are creating the
468:56 - class with the init method or the done
468:58 - therein method
468:59 - and then inside of the other methods we
469:02 - are calling self all the time to refer
469:04 - to the class and i just realized this
469:06 - should be
469:07 - self instead of monster
469:10 - so we're capturing this self here
469:13 - and what you are going to notice is that
469:15 - you are going to write self all the time
469:18 - it is a little bit annoying but
469:20 - well it is manageable
469:23 - and well with that we have the first
469:25 - init method
469:27 - but there are quite a few more although
469:30 - those you wouldn't use that often
469:32 - and just to keep things simple let me
469:34 - get rid of monster 2
469:38 - and i don't want to print
469:40 - anything at all
469:43 - another danda method i talked about in
469:45 - the introduction is len
469:49 - and this one
469:51 - needs self and no other parameters
469:53 - and in here we just want to return
469:56 - something
469:57 - let me
469:58 - return
469:59 - the number 5
470:02 - and what this one is going to do
470:05 - is if i call len and pass in monster1 in
470:10 - there and this len just as a quick recap
470:14 - if i pass in any kind of string into len
470:18 - let's say test
470:20 - and if i print the result
470:24 - i get 4
470:26 - or the number of characters inside of
470:28 - the string
470:30 - i guess i could also pass a list in here
470:32 - that might make a bit more sense
470:35 - so i have a list with 5 entries and the
470:37 - length of it is 5.
470:40 - but what i can do now if my monster has
470:43 - a len method i can pass monster 1 in
470:45 - here
470:46 - and it would return 5 as well
470:49 - and any number that is being returned
470:52 - here
470:53 - is going to be passed into the length
470:55 - function
470:56 - and i guess for something slightly more
470:58 - relevant
471:00 - instead of returning a number
471:02 - i could return self.health
471:06 - and now if i run this i'm getting 10 or
471:09 - the amount of health my character has
471:10 - which is 10 right now
471:14 - and another example we have seen in the
471:16 - introduction that works in the same way
471:18 - is abs and we need dunder on both sides
471:22 - and in here self
471:24 - and again i have to return something so
471:27 - return
471:28 - and for this case let's say self.energy
471:32 - and if i copy this and pass it into
471:35 - absolute
471:37 - i get 20.
471:39 - now usually absolute is if you have a
471:41 - negative number
471:43 - and you want to make sure it's always
471:44 - positive that's what it does
471:47 - but well you could theoretically do
471:49 - whatever you want with it
471:52 - now what you can also do
471:54 - is one specific function in python and
471:57 - that is called dir short for directory i
472:01 - think or directory listing or something
472:03 - like that
472:04 - basically what it does you pass in
472:07 - an object
472:08 - and then you want to print
472:10 - the result
472:13 - and what you get from that
472:15 - is all of the dunder methods and at the
472:18 - end
472:19 - the attributes and the normal methods
472:23 - and in here you can see
472:25 - a lot of stuff actually
472:28 - and what you have to understand here is
472:30 - every time we are creating an object
472:32 - python already gives it some dunder
472:34 - methods
472:35 - for example here we can see the dir
472:38 - method and this one is necessary for the
472:41 - ear function to work
472:43 - it kind of works like the len method the
472:46 - one we have created ourselves or the abs
472:48 - function
472:50 - and i guess the one we have just created
472:53 - is the init method this is the really
472:55 - important one
472:56 - and most of those you really don't want
472:59 - to worry about because well they're just
473:01 - there to make the class work but we
473:03 - don't really have to worry about them
473:07 - although some dunder methods in here can
473:09 - be very useful
473:10 - for example dander dict
473:13 - is well it's kind of a dictionary but
473:15 - not in the way you would expect
473:17 - basically how you would use that one
473:20 - let me print it right after the monster
473:25 - i want to print monster 1 and then dot
473:29 - dunder
473:30 - dict
473:32 - and in here this is the one exception
473:34 - where this is not a method this is just
473:36 - an attribute so no brackets afterwards
473:39 - and this one gives us all of the
473:41 - attributes of the method inside of one
473:43 - dictionary
473:45 - can be quite useful sometimes although
473:47 - you wouldn't be using it too often
473:50 - now another way to get this dict here is
473:52 - to let me duplicate the entire line you
473:55 - can call the varus function and pass in
473:58 - monster1
474:00 - and this one is giving us the very same
474:03 - thing
474:04 - although i have hardly ever used either
474:08 - of these most of the time you just don't
474:10 - need them
474:12 - and with that you should understand
474:13 - dunder methods reasonably well
474:16 - now there are quite a few dunder methods
474:18 - that get a bit more advanced i only
474:21 - covered the really fundamental one some
474:23 - other examples of thunder methods is for
474:26 - example dunder call
474:29 - and in here we only need one parameter
474:32 - self
474:33 - and in here we can return something else
474:37 - again
474:39 - and let me dissipate dunder on both
474:41 - sides
474:42 - let's say the monster was called
474:46 - and what this dunder call does
474:48 - is it essentially turns our object into
474:51 - a function
474:52 - meaning i can call monster1 and then add
474:56 - brackets afterwards and if i do that
474:59 - we are not getting anything because i
475:01 - would have to print what i get
475:03 - so i have to put brackets around it and
475:06 - call print and now the monster was
475:08 - called
475:10 - i guess a cleaner way of doing this is
475:13 - to return
475:15 - nothing and just
475:18 - print
475:19 - this string
475:21 - so now if i call monster1
475:23 - we get the monster was called and
475:25 - nothing is being returned
475:28 - and when you create a function in python
475:32 - it basically behind the scenes creates
475:34 - an object with this standard method here
475:38 - and this we can just create ourselves it
475:41 - really isn't that complicated
475:42 - and what we can also do is to add and
475:44 - subtract numbers
475:46 - and this you would for example do
475:48 - with dunder add
475:51 - and in here you need two parameters
475:53 - first of all self as always and then you
475:56 - need some other number
475:58 - and what you can do in here is return
476:01 - something
476:02 - let's say i want to self.health
476:06 - and then plus whatever other number i
476:08 - get
476:10 - and now that i have that
476:12 - i can
476:14 - print
476:15 - monster 1
476:17 - plus
476:18 - 10
476:20 - and if i run it i get 20
476:23 - which is if i find it
476:25 - so the health of my monster is 10 and i
476:28 - add 10 towards it so i get 20. and i
476:32 - guess to make this a bit more
476:33 - understandable let's add 55 in here
476:37 - and i get 65 which is 10 plus 55
476:42 - and well that is a couple more dunder
476:46 - methods
476:47 - they can be incredibly useful although
476:49 - most of the time you are only going to
476:51 - use thunder init this is the one you
476:54 - absolutely have to understand
476:56 - but i guess they don't really get that
476:57 - much more complicated so it shouldn't be
477:00 - too hard
477:01 - all right now for the challenge for this
477:04 - part i want you guys to do some research
477:06 - because there's another dunder method
477:08 - that is called
477:10 - str and i want you guys to look up
477:14 - online what it does and how to use it in
477:17 - code
477:21 - alright here we are in the official
477:24 - python documentation and there you can
477:26 - see dunder string or dunder str
477:30 - and basically what it does it's called
477:32 - by the str object built in function
477:35 - format and print to compute the informal
477:37 - or nicely printable string presentation
477:39 - of the object
477:41 - basically what it means is that this
477:42 - object is going to return some text so
477:45 - let's have a look at it
477:47 - here we are back in the code and i only
477:50 - need one parameter and that is
477:53 - and now i have to return some kind of
477:55 - string and the string i want for this
477:58 - one let's say a monster
478:02 - and what i can do with that let me get
478:04 - rid of this print statement and instead
478:07 - i want to print str
478:10 - or monster one
478:12 - and this is going to return a monster
478:16 - and we don't even need this str because
478:20 - print is trying to find a string
478:23 - so let me duplicate this line and remove
478:28 - the str and just have monster 1.
478:31 - if i call this now i still get a monster
478:35 - and this can be a really nice way to
478:37 - look at your objects and see what they
478:39 - are doing
478:41 - because if we didn't have this done
478:43 - their method let me comment it out and
478:46 - run this again
478:47 - all we get is a monster object which
478:50 - really isn't that useful
478:53 - and obviously this str can return a lot
478:57 - more than just a simple string for
479:00 - example we could have an f string
479:04 - with
479:05 - health
479:07 - that says self dot health
479:10 - and
479:11 - energy
479:13 - that says self dot energy
479:16 - and now if i run this
479:18 - we get quite a bit of information by
479:20 - just passing the monster or the object
479:23 - into the print statement so this str can
479:26 - be really really useful
479:29 - and with that we have covered quite a
479:31 - few dunder methods if you look online
479:33 - you can find even more but well most of
479:37 - the time you are not going to need them
479:39 - this is very often a fairly advanced
479:41 - topic
479:43 - except thunder init this is the one you
479:45 - are going to use a lot
479:47 - all right with that we have dunder init
479:50 - methods covered
479:51 - and if you understand all of this so far
479:54 - you can actually understand python
479:56 - itself quite a bit more let's talk about
479:59 - this one in the next part and the one
480:01 - thing i think that confuses beginners
480:04 - quite a bit is that every single thing
480:06 - in python is an object meaning every
480:09 - time you see a string or integers you
480:12 - are going to see an object just like the
480:14 - objects that we have created so our
480:16 - monster
480:18 - and this even includes functions which
480:20 - are just objects with the called under
480:22 - method
480:23 - and i'm going to show you some examples
480:25 - in just a second but most of what i will
480:28 - cover here isn't really important i just
480:30 - want you guys to understand how it works
480:33 - so you don't get confused later on
480:35 - and there's another thing that i believe
480:38 - is very often confusing and that is the
480:40 - difference between a function and a
480:42 - method
480:43 - and the reason why this is confusing is
480:45 - both just execute a block of code
480:48 - so in terms of functionality they
480:50 - basically do the same thing however the
480:53 - difference is that a method always
480:56 - belongs to an object
480:58 - it doesn't matter if the object was
481:00 - created by us or by python
481:03 - and a good example here would be using a
481:04 - string
481:05 - so if we have a function this would be
481:08 - len for example and we can pass a string
481:11 - into it this will return four
481:14 - and a method would be something with dot
481:17 - and then upper for example for string
481:19 - returns uppercase letters for this
481:22 - string
481:23 - and that really is the entire difference
481:26 - that's the main thing you have to
481:27 - understand and it doesn't matter if we
481:29 - create the method ourselves or the
481:31 - function ourselves or if it's created by
481:33 - python
481:35 - and the reason why these are different
481:36 - for example is that the lan method could
481:39 - work for lots of other things as well
481:41 - for example you could pass in a list in
481:44 - here you could pass in a dictionary or a
481:48 - tuple
481:49 - it would still work with different data
481:50 - types whereas upper
481:54 - only works for strings you couldn't add
481:56 - a list with upper that one would not
481:59 - work
482:00 - so it makes sense in this case that
482:02 - upper only exists as a method for
482:05 - strings whereas the ln should be a
482:07 - function so you can pass in different
482:10 - kinds of objects in here and they would
482:12 - all work
482:13 - you could perfectly find create some
482:15 - kind of len method for test and it would
482:18 - work just fine although then you would
482:20 - also have to create a lan method for
482:22 - lists for dictionaries for tuples for
482:25 - all of that stuff and it would be quite
482:27 - labor intensive
482:28 - so all we're doing here is to keep
482:30 - things more efficient
482:32 - but all right let's have a look at some
482:34 - code and let's have a small deep dive
482:37 - into python
482:39 - here i have a completely empty sheet of
482:41 - code and what i want to create for now
482:45 - is create a test variable and this one
482:47 - should have a string let's call it a
482:50 - doesn't really matter what it is
482:53 - and what i can do now i can call my
482:55 - print
482:56 - dir and pass in my test in here
483:01 - and if i run this now
483:02 - i am getting
483:04 - a bunch of dunder methods and after they
483:07 - are over starting from here
483:09 - i get a couple of methods and attributes
483:12 - now the dir method doesn't separate
483:14 - between methods and attributes so we
483:16 - just get one big list
483:18 - but
483:19 - well basically what we get here is an
483:22 - object
483:23 - and anything in here you could just call
483:26 - like upper or title or strip all of
483:29 - these are very simple methods
483:33 - and along with that we have the len
483:35 - dunder method and this is what's being
483:37 - called when we are passing this string
483:39 - into the len function
483:42 - and besides that what you can also do
483:45 - let me get rid of this test and instead
483:47 - create define test
483:50 - and then here
483:51 - i let me just add pass
483:54 - so this is a function with the name test
483:56 - and i'm still printing dir test so if i
483:59 - run this
484:00 - i am getting another object and this
484:03 - object is special
484:05 - because it has a call dunder method
484:09 - meaning when we're adding brackets
484:10 - afterwards it is being executed and
484:13 - that's basically what a function is in
484:15 - python it's just an object with the
484:18 - dunder call method it really isn't much
484:20 - more than that although we do have a
484:22 - couple extra things that make this a bit
484:25 - more special but that's the main idea
484:29 - and if you really wanted to you could
484:32 - even store this function inside of a
484:35 - variable
484:37 - and this works because the function is
484:39 - an object
484:40 - so this is just going to be an object
484:43 - meaning if i now print a
484:46 - we are getting the same outcome
484:49 - although what we can even do now
484:51 - let's call it another attribute that is
484:55 - not how you spell that
484:57 - and this could just be 10
484:59 - and now if i run this
485:01 - our function has another attribute
485:05 - and again this is working because
485:07 - functions are just objects
485:11 - although in practice you wouldn't really
485:13 - do this there's no reason for it
485:16 - but
485:17 - what is much more common is that you are
485:20 - passing functions or methods into other
485:23 - objects
485:25 - so what is much more common let's say
485:27 - for example a simple add function and
485:30 - this one takes a and b
485:32 - and is going to return a plus b
485:36 - obviously this still isn't particularly
485:39 - useful but i just want to illustrate
485:41 - what it does
485:42 - and now i can create a class and let's
485:45 - call it test
485:47 - and in here for the dunder init method
485:52 - i want to have self and i want to add an
485:55 - add function
485:57 - and now inside of this dunder init add
486:00 - function
486:01 - i can set an attribute self dot add
486:04 - function and this should be the argument
486:07 - we get from the parameter add function
486:10 - and now
486:11 - when i create this test
486:14 - i have to pass in
486:16 - one function and i want to have this add
486:19 - function here so i'm going to add it in
486:21 - here
486:23 - and let me use a named argument so it's
486:27 - a bit easier to see what's happening
486:29 - and in here it is really important that
486:31 - you don't add brackets because we don't
486:34 - want to call this function we want to
486:36 - get the function itself so the object of
486:39 - the function not what's being returned
486:42 - and if i run this now this is working
486:44 - just fine
486:46 - and even better what i can do i can call
486:49 - test dot
486:51 - add function
486:52 - and i can pass in let's say one and two
486:56 - and this is not doing anything because
486:58 - we're not printing anything we're just
487:00 - returning something
487:01 - so
487:02 - if i put all of this into a print
487:04 - statement now we are getting free
487:07 - and i hope all of this is making sense
487:10 - this is a really important thing to
487:11 - understand
487:12 - right now this here is creating an
487:15 - object of a function and this object we
487:18 - can pass around
487:20 - for example we could pass it
487:22 - inside of a class and this would work
487:24 - just fine and then inside of the class
487:26 - we can store it inside of an attribute
487:29 - and then call it from outside of the
487:31 - function this is working just fine
487:33 - there's no limitations on this
487:36 - and this is something you really want to
487:39 - practice because passing around
487:40 - functions is a really important thing to
487:42 - understand
487:45 - and i guess since this is really
487:47 - important we should practice this with a
487:51 - slightly larger exercise
487:53 - and let me add some comments that should
487:55 - help quite a bit
487:56 - first of all i want you guys to create a
487:58 - monster class with a parameter called
488:00 - funk and this funk should be stored as a
488:03 - parameter that's the first step
488:06 - after that
488:07 - i want you guys to create another class
488:10 - and this one is called attacks and this
488:12 - has four methods we have let me put it
488:15 - on another line
488:17 - we have byte strike slash and kick and
488:20 - for each method you just print some text
488:23 - basically whatever you want i would
488:25 - recommend to print kick slash strike and
488:27 - byte but it really doesn't matter
488:30 - and let me add proper white space here
488:32 - and then for the final step
488:35 - i want you guys to create a monster
488:37 - object and give it one of the attack
488:39 - methods from the attack class
488:42 - and remember here that methods are
488:45 - basically just functions the only
488:47 - difference is that they are part of an
488:49 - object so this should work kind of
488:52 - similar compared to what you have seen
488:53 - here
488:54 - but well it's going to be slightly
488:56 - different so experiment with this and
488:59 - see how far you get
489:03 - all right let's try together now first
489:05 - of all i want to create a monster class
489:08 - and this i do with class monster
489:11 - and in here i want a dunder init method
489:14 - that needs self and a funk
489:18 - and this funk i want to turn into an
489:20 - attribute so self dot func
489:23 - and i want to capture the parameter or
489:25 - the argument we get here in there
489:29 - and this is covering all of this
489:31 - next up we have to create another class
489:35 - so class and this one is called attacks
489:39 - and in here we don't need a donderended
489:41 - method instead i want to create define
489:45 - let's start with byte
489:47 - and we need self as always and in here i
489:50 - just want to print
489:52 - byte
489:53 - and since we need four attack methods
489:57 - let me copy this
489:59 - a few more
490:00 - times
490:02 - and now besides byte
490:05 - i also want strike
490:08 - then i want
490:11 - slash
490:12 - and finally i want kik
490:16 - and i think you can already tell why
490:18 - this might be useful it's a very neat
490:21 - way to organize all of your different
490:23 - functions
490:24 - if you have a really large game with
490:26 - hundreds of different attack methods
490:28 - this may actually be really nice to
490:30 - organize all of this
490:32 - all right
490:33 - now finally i want to create an object
490:35 - of my monster
490:37 - so monster in lower case and then here i
490:40 - want to have my monster
490:42 - and now we have to define a function
490:46 - now this you could approach in a couple
490:48 - of different ways although there's one
490:51 - way that is definitely wrong and it's
490:53 - very tempting to go this way you could
490:55 - write something like attacks and then
490:57 - dot byte
490:59 - and if i run this code
491:01 - we get a 3 and this 3 comes from up here
491:05 - so let me comment out all of this
491:09 - and if i run this again now we can't see
491:12 - any difference
491:13 - but
491:14 - if i run monster.funk
491:18 - we are getting that attack.byte is
491:20 - missing one required positional argument
491:22 - and that is self
491:24 - and this is a reasonably common error
491:27 - the reason is that this here is not
491:31 - returning an actual object it's
491:32 - returning a class
491:34 - and this is confusing python now an easy
491:37 - way around this is to actually turn this
491:39 - class into an object by calling it so
491:42 - adding brackets afterwards
491:44 - and now if i run this we are getting
491:46 - byte
491:47 - and basically what is happening here
491:49 - think of this in terms of return
491:51 - statements
491:52 - when we are calling this attacks it's
491:55 - returning an object
491:57 - and then inside of this object we are
491:59 - getting the byte method which is this
492:03 - byte method here
492:05 - and if you don't like how this looks
492:07 - what you could also do
492:09 - is create a separate object let's call
492:12 - it attacks
492:13 - and in here i could add this attacks
492:16 - and then call attacks.byte and we will
492:19 - get the same result
492:22 - and this is something we are going to
492:24 - explore quite a bit more that you pass
492:27 - different things around different
492:28 - classes
492:30 - so that in this example
492:32 - we are taking
492:33 - the byte method and passing it into
492:36 - another object
492:38 - and this is getting incredibly powerful
492:41 - and really important to understand if
492:43 - you want to understand more complex code
492:45 - because a key part of object oriented
492:48 - programming is that you work with
492:50 - different objects and make them interact
492:52 - with each other and this example here
492:55 - so this part down here is one example to
492:58 - make classes interact with each other
493:00 - and i would really recommend you to
493:02 - practice this in your own time it's
493:04 - really going to be helpful
493:06 - but all right with that we have covered
493:09 - a really basic deep dive into python
493:13 - although i do want to practice this a
493:15 - bit more and there's one important topic
493:17 - i do want to cover and that is going to
493:19 - be scope in terms of objects and classes
493:22 - let's talk about that one in the next
493:24 - section alright so let's talk about
493:27 - classes and scope and this is one of the
493:30 - really powerful parts of objects that
493:32 - make it really easy to work with this
493:34 - scope but let's talk about it
493:36 - basically every method so every function
493:39 - inside of a class has a reference to
493:42 - that class and because of that it's
493:45 - really easy to get and change class
493:48 - attributes
493:49 - and because of that methods are much
493:52 - easier to work with than normal
493:53 - functions
493:55 - meaning they rely much less on
493:56 - parameters the global keyword and return
493:59 - statements although you can still use
494:01 - them if you really want to and sometimes
494:03 - that does make sense
494:05 - but you are going to do this much less
494:07 - often
494:08 - and what is even better objects can be
494:11 - influenced from outside of the object
494:13 - itself
494:14 - and even from the local scope of a
494:16 - function
494:18 - basically objects you can change
494:20 - wherever you want there is no limitation
494:22 - on the scope for them which makes it
494:24 - even easier to work with them
494:26 - but i guess let's have a look at all of
494:29 - this in code that should illustrate this
494:31 - the best
494:33 - here i have a completely empty sheet of
494:35 - code and first of all i want to
494:37 - illustrate the problem so let's talk
494:39 - about scope again let me add a comment
494:41 - scope problem
494:44 - and let's say i have a game and i have
494:47 - some kind of health that right now is
494:49 - 10.
494:50 - and for this health i want to have a
494:53 - function let's call it update health and
494:56 - this one takes an amount
494:57 - and what it really does is it adds that
495:00 - amount to the health
495:03 - a super simple function just about the
495:06 - simplest function you could write
495:09 - now what i want to do let me say i want
495:11 - to print health
495:13 - then i want to update my health with 20
495:17 - and then i want to print my
495:19 - health again
495:21 - and if i were to run this what do you
495:23 - think is going to happen just think
495:25 - about it
495:26 - and well if i print it we are getting an
495:29 - error and what python is unhappy about
495:32 - is that we have a local variable health
495:34 - referenced before assignment
495:37 - and
495:38 - what is happening here is that this
495:41 - health to python is a local variable
495:44 - let me remove the error messages they
495:46 - are getting a bit annoying that's easier
495:48 - to work with
495:49 - essentially this health only exists in
495:52 - the scope of this function here
495:56 - or in other words
495:57 - this health here
495:59 - and this health here to python are two
496:03 - completely separate things
496:05 - and then when we are trying to update
496:07 - this health with some amount i even
496:10 - cannot find any starting amount for this
496:12 - health as a consequence we are getting
496:14 - an error
496:16 - and there are a couple of ways to get
496:18 - around this for example we could use
496:20 - global health
496:23 - that's probably the easiest one and now
496:25 - this would work although
496:27 - you could also use return statements but
496:30 - it really isn't the cleanest way to work
496:32 - with this so this is not great
496:36 - so let me comment it all out and let's
496:38 - do the same thing with classes
496:41 - so let me create a class monster again
496:44 - and in here i want to create a dander
496:47 - init method that needs self
496:50 - health and energy
496:53 - and then as always i want to set
496:55 - self.health
496:56 - equal to health and self.energy
496:59 - is going to be energy
497:03 - and now let me create an object from
497:06 - this class and let's give it a health
497:10 - of 100 and energy
497:13 - 50. it doesn't really matter what values
497:16 - you put in here
497:18 - so now i can print monster.health
497:22 - and we are getting a hundred
497:24 - so this one works just as expected
497:28 - and now what we can do we can just get
497:30 - monster.health and add let's say 20 to
497:34 - it and if i now print
497:36 - monster.health again we're getting 120
497:40 - ie the sum of 120.
497:44 - and what is even more powerful let me
497:47 - uncomment this function up here
497:50 - and now instead of the health i want to
497:53 - get my monster.health and update the
497:55 - amount
497:56 - and this would still work if you are
497:59 - using an object
498:00 - so let me get rid of these two lines
498:03 - here and instead call the function
498:05 - update health
498:07 - and let's say i want to raise this by 20
498:10 - again
498:11 - and now if i print monster.health
498:15 - after calling this function i get 120
498:19 - meaning even inside of the local scope
498:23 - of a function
498:25 - you can still update anything inside of
498:27 - an object but the simple reason that
498:30 - here python is very clear about what
498:32 - kind of object you are talking about
498:35 - this monster is not going to become a
498:37 - variable in the local scope
498:40 - and this monster could be updated
498:42 - anywhere it could be in the global scope
498:44 - it could be the local scope of a
498:46 - function it could be in the scope of
498:47 - another method it could even be inside
498:50 - of the object itself so this monster
498:53 - python just doesn't care
498:56 - which makes it really easy to work with
499:00 - so i guess one thing
499:02 - you do see fairly often is inside of a
499:05 - class you have something like let's call
499:08 - this one update
499:10 - energy
499:11 - and then here we need self and let's add
499:14 - an amount in here as well
499:17 - and all i really have to do to update
499:20 - this self.energy
499:23 - would be
499:24 - to first target the attribute itself so
499:26 - self dot energy and then plus equal
499:30 - amount
499:33 - and now i could just run monster dot
499:36 - update energy pass in anything i want in
499:39 - here
499:40 - and then print
499:42 - monster.energy
499:44 - and we are getting 70.
499:47 - and again here this is a very easy way
499:51 - to work with scope you don't have to
499:53 - worry about return statements you don't
499:55 - have to worry about global all you do is
499:58 - target the attribute and then you set it
500:00 - to a new value or update whatever you
500:02 - want that's it it's super easy to work
500:05 - with
500:06 - although if you wanted to you could use
500:09 - a return statement as well
500:12 - for example if i wanted to set
500:15 - energy
500:17 - and then here i want self and energy
500:21 - and let's say for this one i want to
500:23 - create a new local variable that i call
500:26 - new energy
500:27 - and this is going to be energy times two
500:31 - and then i want to return
500:33 - this new energy
500:35 - and now in my init method
500:38 - instead of setting energy straight as
500:40 - the attribute i want to call self.set
500:43 - energy and pass in the energy
500:46 - and now let me comment out this line
500:49 - down here to update the energy and just
500:51 - get the energy now we're getting 100
500:54 - which is
500:56 - this 50 here
500:58 - this 50 we are passing inside of this
501:02 - energy here from that energy we are
501:05 - passing it inside of another method
501:07 - inside of the monster class
501:09 - and this
501:11 - method
501:12 - is down here we are getting one
501:14 - parameter and this we are doubling and
501:17 - assigning it to new local variable
501:20 - inside of this method
501:23 - and after that we are returning the new
501:26 - energy and this new energy is going to
501:28 - become
501:30 - the attribute self.energy
501:32 - kind of a roundabout way of doing it but
501:34 - it is possible to do
501:36 - all i really want you to understand is
501:38 - that you can still use return and
501:40 - parameters just like with any other
501:42 - function although most of the time you
501:45 - don't really need it
501:47 - a better way for this one
501:49 - would be
501:50 - to
501:51 - remove this part entirely
501:53 - just call set energy and then
501:57 - self dot energy is going to be new
502:01 - energy this would work in exactly the
502:03 - same way although it is much cleaner to
502:06 - read so if we run this we are still
502:08 - getting a hundred and i hope you
502:10 - understand why self is really really
502:13 - powerful
502:14 - it essentially bypasses all of the scope
502:16 - issues very efficiently all right let me
502:19 - get rid of all of this because i don't
502:21 - really care about it
502:23 - and instead i want to set self.energy
502:26 - back to energy
502:28 - all right now with that let's do an
502:31 - exercise to practice this
502:33 - and what i want you guys to do first of
502:36 - all
502:36 - create a hero
502:38 - class
502:39 - with two parameters
502:42 - one is damage and the second one is a
502:45 - monster
502:46 - which is going to be
502:48 - this object here so this object you want
502:51 - to pass into another class as an
502:53 - argument
502:55 - and second of all
502:58 - the monster class
503:00 - should have a method that lowers the
503:04 - health and i guess you can call it get
503:09 - damage
503:10 - and this one should take an amount
503:13 - and then this amount you would reduce
503:14 - from the health of the monster
503:17 - and finally
503:19 - the hero class should have an
503:23 - attack method
503:25 - that calls the get
503:28 - damage method
503:30 - from the monster
503:32 - and let me put this on a second line
503:34 - and the amount of damage
503:38 - is hero dot damage
503:41 - which is going to be the damage you
503:43 - specified up here which should be an
503:45 - attribute
503:47 - so i hope all of this makes sense try to
503:49 - implement this yourself and see how far
503:51 - you get
503:53 - all right let's try together now first
503:56 - of all i want to create a new class and
503:59 - this is going to be
504:01 - and the hero needs a dunder init method
504:05 - and here we need self and besides that i
504:07 - want damage and i want a monster
504:11 - and let me add a bit more white space
504:13 - there we go
504:14 - now i want self.damage to be damaged and
504:19 - i want self.monster
504:20 - to be monster
504:22 - and let me spell this correctly there we
504:24 - go
504:25 - and this would then be step number one
504:29 - and for step number two let me move it
504:32 - up a bit so it's easier to see what's
504:34 - going on
504:36 - the monster class should have a method
504:39 - that lowers the health and this i want
504:40 - to call get damage
504:42 - so define get
504:45 - underscore damage
504:46 - and then here i need self and i need the
504:49 - amount
504:50 - and all i really want to do in here is
504:52 - self dot health minus equal
504:55 - whatever amount we specify and this get
504:59 - damage i want to call from inside of the
505:02 - hero
505:04 - and this brings us to step number three
505:08 - and this
505:10 - right now we are still inside of the
505:13 - hero class which you can see by the
505:15 - indentation
505:17 - i probably should have actually
505:18 - mentioned that for the class we always
505:21 - define something by one level of
505:23 - indentation
505:24 - a in here i want to now
505:26 - create let's call it an attack method
505:30 - and this one itself and nothing else
505:33 - and all i really want to do in here is
505:35 - get myself dot monster
505:38 - and this self.monster is the monster we
505:41 - specified up here and on this monster we
505:44 - want to call get damage
505:47 - and all we really have to do for that is
505:50 - call get underscored damage
505:53 - and now we have to specify how much
505:55 - damage we want to cause to the monster
505:58 - and for that i want to get the damage of
506:00 - the hero
506:02 - and all we need for that is specify self
506:05 - dot damage and we are done
506:09 - and if you just read through this i hope
506:12 - this really illustrates why this makes a
506:14 - ton of sense
506:15 - it's basically a normal sentence we want
506:18 - to get the monster we want to cause the
506:20 - monster some damage and the amount of
506:22 - damage you want is self-dot damage so
506:24 - the damage of the hero
506:26 - and now with that all we have to do is
506:29 - to actually create the object of the
506:31 - hero
506:32 - meaning i want to create a hero object
506:34 - and this is going to be hero
506:36 - and in here we need damage let's say
506:39 - damage for the hero is 15
506:41 - and then we need a monster
506:44 - and the monster is going to be
506:46 - the monster object we created just a
506:49 - second ago this one here
506:51 - and this we're just passing in here
506:54 - and now let me print monster.health
506:59 - and if i run this we are getting a
507:01 - hundred
507:02 - which is this 100 here
507:06 - but now
507:08 - if i call hero
507:10 - dot attack
507:11 - and this one doesn't need any arguments
507:14 - and afterwards i can print
507:16 - monster.health
507:18 - again
507:18 - and now if i run this we get 85
507:22 - which is 100 minus 15. this is how this
507:26 - 85 comes about
507:29 - and to get to this point to lower the
507:31 - health of the monster we just had to
507:33 - call one method and that's it
507:36 - all we are really doing in here is we
507:38 - are passing different objects around and
507:41 - make them interact with each other and
507:43 - since we don't really have to worry
507:44 - about scope this is very easy to
507:47 - implement
507:48 - and again this is something you really
507:50 - want to practice on your own and try to
507:53 - work on this more to make sure you
507:54 - understand it
507:56 - but right with that we have covered
507:58 - scope and i guess for the next part
508:00 - let's talk about inheritance
508:05 - and inheritance really just means that
508:07 - one class gets the attributes and
508:09 - methods from another class or multiple
508:12 - classes
508:13 - and i have already shown an example
508:15 - earlier and that was we are the monster
508:18 - that we have already seen multiple times
508:21 - with health and energy
508:23 - and this right now is called a parent
508:25 - class
508:27 - and the reason why it is called the
508:28 - parent class is because there's a child
508:31 - class and this one was the shark
508:34 - and this shark by itself only has a
508:36 - speed and a byte method
508:39 - and what i want to happen is that the
508:42 - health and the energy of the monster
508:44 - parent class
508:46 - comes into the child class and the same
508:49 - for the method
508:50 - so attack and move should also be
508:52 - available inside of the shark class
508:56 - so that when i actually use this to
508:58 - create an object
509:01 - the shark object has health energy and
509:03 - speed for the attributes and attack move
509:05 - and bite
509:07 - meaning we are combining the monster and
509:09 - the shark class to create the actual
509:13 - shark object
509:15 - and the reason why we are doing this is
509:17 - this makes it very easy to reuse code
509:21 - let's say this monster here could be the
509:23 - parent class to every monster in our
509:26 - game
509:27 - and if we have this we never have to set
509:30 - the attributes health for energy for any
509:32 - other monster they are always available
509:34 - for every single class because they all
509:36 - inherit from this monster
509:39 - and obviously this is still a very
509:41 - simple example in an actual game the
509:43 - monster class might have a few hundred
509:46 - if not thousands of lines of code
509:48 - and then it really makes sense to reuse
509:51 - code as much as we can
509:53 - because then we don't have to create new
509:56 - classes all the time with all of these
509:59 - methods that we have to type over and
510:01 - over again
510:02 - and then on top of that if we wanted to
510:04 - make changes to how things move in the
510:06 - game so this method here
510:09 - if we didn't use inheritance and we want
510:11 - to make change how things move in the
510:13 - game we would have to change possibly
510:15 - hundreds of different move methods for
510:17 - every single monster but if we use
510:20 - inheritance we don't have to if we
510:22 - change one move method we are changing
510:24 - how every monster in the game moves
510:27 - so i hope that makes sense
510:30 - and one important concept here is that
510:32 - the class can inherit from an unlimited
510:34 - number of other classes this could look
510:37 - like this
510:39 - in here we could have a parent class 1 a
510:42 - parent class 2 and a parent class 3
510:45 - and then the child class would have the
510:48 - attributes and methods of all of these
510:50 - parent classes
510:52 - and you can also turn this around where
510:54 - you have a parent class and this parent
510:56 - class is being inherited from by an
510:58 - unlimited number of other classes
511:00 - and this would look something like this
511:03 - you have one parent class
511:06 - and you have one child class a second
511:08 - child class and a third child class and
511:12 - all three of those would have
511:15 - the methods and attributes of the parent
511:18 - class
511:20 - and this here for example could be the
511:23 - monster class
511:24 - and then this one here maybe the shark
511:27 - class and let's say this one here
511:30 - could be i don't know like a bird class
511:33 - or something
511:35 - now there's one thing you do want to be
511:37 - aware of though and that is that
511:39 - inheritance can get very
511:41 - very complex
511:43 - up to a point where it really doesn't
511:45 - become fun to work with them
511:48 - and this is also the part where
511:49 - beginners really start to struggle
511:52 - because well i'm going to show you an
511:53 - example later on but this can get very
511:56 - very complex and really hard to work
511:58 - with
511:58 - fortunately this is fairly rare most of
512:02 - the time you just need simple
512:04 - inheritance and this one is really easy
512:06 - to implement
512:07 - and this one might be something like
512:09 - this the example we have already seen
512:12 - and this one should be very easy to
512:14 - follow so for this section i just want
512:16 - to focus on implementing this part here
512:20 - and i guess let's actually implement
512:22 - this one in code and let's see how this
512:24 - is going to look like
512:26 - alrighty so here once again we can see
512:30 - our monster class and from this monster
512:33 - class
512:34 - i want to get
512:36 - a shark class
512:38 - and this one should get the health the
512:41 - energy the attack method and the move
512:44 - method of this monster class we want to
512:46 - put all of this inside of the shark
512:50 - now
512:51 - passing in the methods is very simple
512:54 - but the health and the energy are going
512:56 - to be a bit more complicated so for now
512:59 - let me simplify things a tiny bit by
513:02 - commenting out the dander init method
513:04 - and instead
513:06 - setting health to something constant
513:08 - let's say 50
513:10 - and energy to 100.
513:13 - the reason being that init is a bit more
513:16 - complicated for inheritance so i'm going
513:18 - to ignore this part for now just to keep
513:20 - things simple but we will implement this
513:22 - in just a bit
513:24 - all right now for this shark
513:27 - i want to create an
513:30 - init method by itself and this one needs
513:33 - self
513:34 - and in here i want to set this speed
513:38 - and now what i want to do is
513:40 - self.speed
513:42 - is going to be speed
513:45 - and this way we are getting our
513:46 - attribute and besides that i also want
513:48 - one method and that method i have called
513:51 - byte and in here we just need self and
513:55 - let me print
513:57 - the shark
513:58 - has bitten or whatever you want to put
514:01 - in here
514:03 - and this by itself would be a
514:05 - functioning class but also a very
514:07 - limited class because it only has a
514:09 - single attribute and one method it
514:12 - doesn't really do all that much
514:14 - so how can i get all of the monster
514:16 - attributes and methods inside of the
514:18 - shark
514:20 - and
514:21 - to get inheritance what we have to do is
514:23 - add brackets after the shark or the name
514:26 - of the shark class
514:28 - and then here we have to pass in
514:30 - what class we want to inherit from in my
514:33 - case this is monster
514:35 - and for start this is all you need
514:39 - meaning now i can create my shark by
514:42 - calling shark
514:45 - and i have to pass in a speed for the
514:48 - shark and let me just say i don't know
514:50 - 120.
514:52 - and now if i print my shark
514:56 - all of this works just fine and we are
514:58 - getting an object but what i can do now
515:01 - is get my shark dot health
515:04 - and this is the 50 we have set all the
515:07 - way at the top here
515:09 - i can also get my shark speed
515:12 - this is the 120 we set for the shark in
515:15 - here
515:16 - and besides that
515:18 - i can also call shark dot byte
515:21 - we get the shark as bitten and besides
515:24 - that i can also set shark dot
515:27 - attack and this one needs an amount so
515:29 - let's say 20
515:31 - and this is the attack method we have
515:34 - gotten from here so the parent class
515:37 - and if i run this we get the monster has
515:40 - attacked
515:42 - and well with that we already have super
515:45 - simple inheritance
515:47 - just by adding this brackets monster we
515:50 - are getting all of these attributes and
515:53 - these methods
515:54 - here so that's a pretty good start now
515:58 - what you can also do let's say let me
516:00 - remove some white space here
516:02 - let's say for the shark this move method
516:05 - here doesn't really work because for the
516:08 - shark i want something else i want the
516:10 - shark to swim and for the speed i want
516:13 - to set since i have a speed i want to
516:15 - use self.speed meaning i want to
516:18 - overwrite this speed from the parent
516:20 - class
516:21 - and to achieve that all you have to do
516:25 - is define a method with the same name in
516:28 - the child class so in here i want
516:31 - self.move
516:33 - and now i can add a print statement in
516:36 - here
516:37 - the shark has moved
516:40 - and let's say print again
516:43 - the speed of the shark is
516:48 - and then self.speed
516:50 - and this should be an f string
516:54 - and now if i call shark dot move and we
516:57 - don't need any arguments if i call this
516:59 - the shark has moved the speed of the
517:01 - shark is 120.
517:04 - and what happens in here is we are first
517:06 - getting the inheritance from the monster
517:09 - and then this move here is being
517:13 - overwritten by this move here
517:17 - which means you can overwrite what you
517:19 - get from the parent class very easily
517:21 - and this you could also do with
517:23 - attributes although
517:25 - we actually have to talk about
517:27 - attributes let's do it right now the
517:29 - problem we are facing right now
517:31 - is that the monster has an init method
517:34 - let me remove this health and energy and
517:37 - uncomment the init method
517:41 - essentially the problem we have right
517:42 - now to give the monster the attributes
517:46 - this self.health and self.energy
517:49 - we have to first call
517:51 - the init method
517:53 - and if we don't call the init method we
517:56 - don't get these attributes so what we
517:58 - have to figure out inside of the init
518:01 - method how to call the parent init
518:04 - method
518:05 - so this would have to happen in here
518:08 - and for that we have two ways one that
518:11 - is a bit outdated but still works and
518:13 - one you actually want to use and let's
518:16 - cover both but you don't really need the
518:18 - first one anymore
518:20 - but just in case you see it let's cover
518:21 - it now what you can do
518:24 - you can call the parent class so monster
518:27 - and then call the dunder init method
518:30 - and now in here
518:33 - you have to pass all of the arguments so
518:35 - these ones here that you want for the
518:38 - parent class so we need self health and
518:40 - energy
518:42 - and these we have to get from arguments
518:44 - so when i initiate the shark besides
518:47 - speed i also want to get health for the
518:51 - shark and energy for the shark
518:54 - meaning when i actually create the
518:56 - object of the shark
518:58 - besides speed i want to set health to
519:01 - 100
519:02 - and energy to 80.
519:06 - now what i get let's go over this
519:08 - actually
519:10 - the first step happens down here
519:13 - i am calling the shark class and i'm
519:15 - passing in three arguments
519:17 - i have the speed i have the health and i
519:20 - have the energy
519:23 - and these three arguments are being
519:25 - covered in speed
519:27 - health and energy
519:30 - and inside of this init method we are
519:33 - calling the parent init method
519:37 - and into this init method we have to
519:39 - pass in three arguments
519:41 - self
519:42 - health and energy
519:45 - and self originally for the parent class
519:47 - was the class itself so this self here
519:50 - which refers to this monster
519:53 - however now the self is going to refer
519:55 - to this self here which is the shark
519:59 - meaning when we are setting self.health
520:02 - and self.energy we don't talk about the
520:04 - monster
520:05 - we are talking about the shark class
520:08 - and this is why the self here is
520:10 - important
520:11 - and then besides the self we also need
520:13 - health and energy and these are just
520:15 - going to be arguments we have to pass in
520:17 - here so this health and this energy
520:20 - and these two we get from these two
520:23 - parameters here which is health and
520:25 - energy and those are being passed in
520:27 - here
520:28 - and with the left to move method i don't
520:31 - care about this one instead let me print
520:35 - shark dot let's start with speed
520:38 - let's actually print all of them so
520:40 - besides speed i want health and i want
520:44 - energy if i run this we get 120 180
520:49 - the numbers we have specified here
520:52 - and
520:53 - well this can get a bit complicated but
520:57 - look at the init method here and the
520:59 - init method here
521:00 - and
521:02 - if you didn't understand what i talked
521:03 - about in the last part practice this
521:05 - yourself and then go over this a couple
521:07 - of times
521:08 - if you get used to this it's eventually
521:10 - going to become fairly easy although i
521:12 - suppose in the beginning this can be a
521:14 - bit overwhelming
521:15 - the one really important thing you have
521:17 - to understand is that we are calling the
521:19 - init method and we are passing in the
521:21 - arguments that we want to set in this
521:24 - case speed health and energy
521:27 - and then inside of this init method we
521:29 - are right now calling the parent init
521:32 - method
521:33 - and then passing
521:34 - health and energy so these two
521:37 - in there as arguments
521:39 - so for example we first set the health
521:42 - here when we are creating the object
521:44 - this health goes into this health for
521:47 - the parameter and then this parameter
521:49 - goes into
521:51 - the init method of the parent
521:53 - and then the init method
521:55 - sets self.health
521:59 - or the actual class
522:01 - and that way you can connect the init
522:03 - methods of different classes now this is
522:06 - how python used to work and this still
522:09 - works but there are some downsides to
522:11 - using it this way so this isn't really
522:13 - used anymore
522:15 - instead what we use is called super and
522:18 - this is a function
522:20 - and this super all it really does is it
522:22 - gets the parent class
522:24 - so if we have that we can just call the
522:27 - init method on it as well
522:30 - and in here we don't need self all we
522:32 - have to do is pass in health and energy
522:36 - and then we are done if i run this now
522:38 - we are getting the very same outcome
522:42 - meaning those two approaches here are
522:44 - functionally identical at least up to
522:47 - this point
522:48 - when we get to multiple inheritance or
522:50 - let's say more complex inheritance super
522:53 - is the much better method
522:55 - and this is why we don't use this
522:57 - initial approach anymore and i guess
522:59 - this one is also a bit easier to read it
523:02 - kinda is up to you but this is the one
523:04 - you do want to use
523:06 - and super you can actually use for a lot
523:09 - of other things as well
523:11 - for example
523:12 - i could call super
523:14 - and then call the move method of the
523:17 - parent and in here i have to pass in a
523:19 - speed let's say 10
523:21 - so now when i run the code
523:24 - i get the monster has moved at a speed
523:26 - of 10
523:28 - meaning when we are calling the init
523:30 - method of the shark class we are also
523:33 - calling the move method of the parent
523:35 - and this way even if you overwrite a
523:38 - method from the parent class you can
523:40 - still call it with super if you really
523:42 - want to
523:43 - which adds even more flexibility to all
523:46 - of this
523:47 - and this
523:49 - is simple inheritance
523:52 - which is something you definitely want
523:54 - to practice this is the one kind of
523:56 - inheritance you are going to use fairly
523:58 - often and the one you have to understand
524:01 - let's practice this one and let me add
524:04 - comments one more time
524:05 - let's do an exercise
524:08 - i want you guys to create a scorpion
524:11 - class that inherits from the monster
524:16 - and it should get health and energy from
524:20 - the parent
524:22 - and then besides that
524:24 - there should also be a poison
524:27 - damage attribute
524:29 - and i want you guys to overwrite
524:32 - the damage method
524:36 - to show poison
524:39 - damage
524:41 - kinda like what we have done for the
524:43 - move method for the shark
524:46 - pause the video now and try to implement
524:49 - this one yourself and see how far you
524:50 - get
524:54 - i want to start by creating a class
524:57 - called scorpion that is not used for
525:00 - scorpion there we go
525:01 - and this one should inherit from monster
525:05 - and now in here i want to create a
525:08 - dunder init
525:10 - method and this one itself and besides
525:13 - that i want poison
525:16 - dammit
525:18 - and now inside of the scorpion i want to
525:20 - set self poison damage
525:23 - as poison damage so we are getting an
525:25 - attribute
525:27 - and then besides that
525:29 - i want to define or well overwrite the
525:33 - attack method
525:35 - let me minimize the shark class so we
525:37 - can see the code a bit easier and i want
525:40 - to overwrite this attack method here
525:43 - and in my guess what i want i just want
525:45 - self because i already have the poison
525:47 - damage
525:48 - and all i want to do in here is print
525:52 - the
525:53 - scorpion has attacked
525:57 - and
525:58 - print
526:00 - it has
526:02 - dealt
526:03 - and then we want self dot poison damage
526:07 - and poison damage
526:10 - and this should be an f string
526:13 - all right so far this should have been
526:15 - fairly easy
526:16 - what i can do now let me delete all of
526:19 - this and let's delete a shark as well we
526:22 - don't need him for now
526:24 - and what i want to do is to create an
526:27 - instance or an object from my scorpion i
526:29 - am really bad at typing scorpion
526:33 - and here i bought my scorpion and right
526:35 - now we have a poison damage i don't know
526:38 - of 50.
526:40 - and now if i type scorpion.attack
526:44 - this is working the scorpion has
526:46 - attacked it has dealt 50 poison damage
526:48 - this shouldn't have
526:51 - an underscore there we go it has dealt
526:54 - 50 poison damage this looks much better
526:56 - meaning what we have so far we have a
526:59 - scorpion with poison damage and we have
527:02 - overwritten the attack method
527:05 - and since we are inheriting from monster
527:07 - we're also getting this move method here
527:09 - meaning my scorpion can also move at a
527:13 - certain speed let's say 5 if i run this
527:16 - and let's make this a bit larger
527:19 - we have the attack method for the
527:21 - scorpion and we have the move method
527:24 - but what we don't have let me get rid of
527:27 - those two
527:28 - we don't have
527:31 - scorpion.health for example
527:34 - this attribute doesn't exist right now
527:37 - because
527:38 - monster
527:39 - only gets these two attributes once
527:41 - we're running the init method
527:44 - so what we have to do in the scorpion
527:46 - called the init method of the parent
527:48 - class
527:49 - which we get with super and then dunder
527:52 - init in here
527:56 - and if i scroll up
527:58 - the monster class for the init method
528:00 - needs two arguments health and energy
528:05 - so let me comment those two and in the
528:07 - united method i want to pass in health
528:09 - and energy
528:10 - now these numbers have to come from
528:13 - somewhere
528:14 - although they don't necessarily have to
528:16 - i could for example just set static
528:18 - numbers in here let's say 50 and 10.
528:21 - if i run this now we get 50 for health
528:24 - because all we are doing here is calling
528:28 - a function that is under init
528:30 - and we're just giving it different
528:32 - arguments
528:35 - although this lacks a lot of flexibility
528:38 - so i don't want to do it but we could if
528:40 - we wanted to
528:41 - instead i want to get this health and
528:44 - this energy
528:45 - from the init method of the scorpion
528:48 - class
528:49 - and in here just to be specific about
528:51 - what we are doing let me name this
528:54 - scorpion health
528:56 - and scorpion
528:58 - energy and somehow my brain always wants
529:00 - to add a tea to scorpion i have no idea
529:03 - why
529:04 - and now when i call the init method for
529:08 - the monster my health should be my
529:10 - scorpion health and my energy
529:13 - should be my scorpion energy
529:16 - when i am creating the actual object
529:19 - i want to have let me use named
529:21 - arguments that makes it a bit easier to
529:23 - read my poison damage should be 50
529:26 - my scorpion health should be 20
529:31 - and my scorpion energy
529:34 - should be 10.
529:36 - and now if i run this we get 20 for the
529:39 - health of the scorpion because remember
529:42 - we are only calling scorpion health the
529:45 - parameter so this is scorpion health
529:47 - here we don't actually set this
529:49 - parameter as an attribute instead what
529:51 - we do
529:52 - we are using the health attribute of the
529:55 - parent class and this gets the value of
529:57 - the scorpion health
529:58 - so our scorpion doesn't have scorpion
530:00 - health as an attribute it just has
530:02 - health
530:04 - and along those lines we also have
530:06 - energy if i run this we get 10.
530:11 - and i hope this starts to make a bit
530:13 - more sense this is definitely something
530:15 - you want to practice if you only
530:17 - partially followed along this is a
530:19 - really important concept to understand
530:22 - and definitely something you are going
530:24 - to see all the time
530:27 - and this you can actually make quite a
530:29 - bit more complex with well more complex
530:32 - inheritance so let's talk about that one
530:35 - and basically what that means so far we
530:38 - always had one parent class and then a
530:40 - child class so a pretty immediate
530:43 - connection
530:44 - something slightly more complex is you
530:46 - have a child class and two parent
530:48 - classes
530:49 - this is something we are going to build
530:51 - in this section
530:53 - but if you really wanted to you could do
530:56 - something like this and it would still
530:58 - work
530:59 - now maintaining something like this is
531:01 - going to be a ton of work
531:04 - although once you have it this child
531:06 - class is incredibly powerful because it
531:09 - gets information from a lot of parent
531:11 - classes
531:12 - so especially if you create something
531:13 - really large this is something you do
531:16 - want to be able to understand but for
531:18 - now especially if you're a beginner and
531:20 - this is the first time you've really
531:22 - engaged with objects
531:24 - i wouldn't recommend to worry about this
531:26 - too much because it gets overwhelming
531:28 - very fast
531:30 - instead make sure to understand this
531:33 - scheme if you understand that one you
531:35 - should be able to follow along with this
531:37 - one as well but for now just practice
531:40 - objects in the first place and once you
531:42 - have a better grasp of objects engage in
531:44 - this one so let's talk about how we
531:47 - could create something like this
531:50 - and this i think is best done in actual
531:52 - code so let's have a look how we can
531:54 - work with this
531:55 - now here i have some code already
531:59 - i have the monster class we have seen
532:02 - quite often by now this one i hope is
532:05 - familiar at this point besides that i
532:07 - also have a fish class now and this one
532:10 - is a very simple class all we have is an
532:14 - init method and this one sets a speed
532:16 - and has scales
532:18 - and besides that we have a swim method
532:21 - and this one just prints swimming at the
532:23 - speed of whatever the speed of the
532:24 - object is going to be
532:27 - and what i want to do i want to create
532:30 - my shark again
532:32 - but this time the shark is not just
532:35 - going to be inheriting from monster it
532:37 - is also going to be inheriting from fish
532:40 - so the first thing for multiple or
532:42 - complex inheritance
532:44 - is that
532:45 - all the objects you want to inherit from
532:47 - should be here in the brackets after the
532:50 - name of the class and in here you could
532:53 - add as many other classes you want
532:55 - there could be class 3 class 4 class 5
533:00 - as many as you want there isn't really a
533:03 - limit
533:04 - and now inside of this shark i want to
533:06 - set a dunder init method
533:10 - and in here we always need self this one
533:12 - should make sense by now
533:14 - and besides that for the shark let's say
533:16 - i want to set a byte strength
533:20 - and then
533:21 - inside of this init method i want to
533:23 - self dot byte strength is going to be
533:26 - byte strength this one should still make
533:28 - sense it's quite straightforward
533:31 - but the more complex one is if i now
533:34 - want to call super and then dunder init
533:38 - now we have a problem because i have no
533:41 - idea what to put in here
533:44 - and the question here is what arguments
533:47 - should go into this inhibit method
533:49 - should i add the arguments for the
533:51 - monster class or for the fish class or
533:55 - both how would this work
533:57 - and there are a couple of things you
534:00 - have to understand to solve this problem
534:02 - the first one is called the mro or the
534:06 - method resolution order and what this
534:09 - really means is
534:11 - let me add a comment here mro
534:14 - or
534:15 - method
534:17 - resolution
534:18 - order
534:19 - what this basically means is in what
534:22 - order the parent init methods are being
534:24 - called
534:25 - and this you can get
534:28 - by just printing and i want to get the
534:31 - shark class not the object the class
534:34 - itself and call mro on it and this is
534:38 - still going to work and if i call this
534:40 - we are getting invalid syntax because
534:42 - the question mark here is not something
534:44 - python likes so let me comment it out
534:47 - for now and now let's run this again and
534:50 - now we can see the mro or the resolution
534:53 - order and basically what it means is in
534:56 - what order python is going to go through
534:59 - the classes
535:00 - we start with the shark itself this one
535:02 - should make sense this is the class that
535:04 - we actually work in so this is where we
535:06 - want to start
535:08 - next up we are looking at the monster
535:10 - class
535:11 - then we look at the fish and finally we
535:13 - look at a generic object and this
535:16 - generic object you don't have to worry
535:18 - about because this is something inbuilt
535:20 - into python it's the thing that makes
535:22 - all of the objects work you don't have
535:24 - to worry about it
535:26 - so what we have to worry about is the
535:28 - shark the monster and the fish
535:30 - and how this order comes about is from
535:33 - the order of these arguments here
535:36 - and basically how this works is that the
535:38 - leftmost item monster in this case is
535:41 - always going to be the first in line
535:43 - with the class itself being the very
535:45 - first item so shark is going to be 0
535:47 - monster s1 fish is 2 and then every
535:51 - subsequent item is going to be next
535:53 - meaning what i could be doing is turn
535:57 - these two around
535:59 - and call fish first and then monster if
536:01 - i run this now we are still starting on
536:04 - our shark but now fish is the first item
536:06 - of inheritance then we have monster and
536:09 - we still have object finally but in my
536:12 - case i do want to keep monster as the
536:14 - first item
536:15 - so the first thing you do have to
536:17 - understand is if we are calling the
536:20 - super dunder init method
536:22 - we are looking at the first item inside
536:25 - of these arguments here so in this case
536:27 - monster
536:28 - meaning for now i can minimize the fish
536:30 - class and just look at the monster and
536:33 - let me minimize these methods as well so
536:35 - it's a bit easier to see
536:37 - and basically what i can do now let me
536:40 - comment out the mro and i actually want
536:43 - to create a shark object from my shark
536:47 - and this is something you should be
536:50 - familiar with from simple inheritance
536:52 - right now we only have the byte strength
536:54 - so byte strength and this we can set to
536:56 - whatever we want let's say 50.
536:59 - but now for this superintendent method i
537:03 - need the arguments for the init method
537:06 - of the parent class in this case health
537:08 - and energy these two i want to pass in
537:11 - here
537:13 - now for these two i again i am going to
537:15 - need some numbers so for the init method
537:19 - of the shark class i also want health
537:21 - and energy
537:23 - meaning when i create the object i also
537:25 - want health and energy
537:28 - and let's set those to
537:30 - i don't know 200 and energy could be 55
537:34 - and with that we are essentially back to
537:37 - simple inheritance i first call the
537:40 - class itself and the first one we do
537:42 - after calling the class we are calling
537:44 - the init method
537:46 - and inside of the init method python
537:48 - knows
537:49 - that the first item of inheritance is
537:52 - the monster class
537:54 - and then after that python knows we have
537:57 - one
537:58 - parameter for byte strength and this
538:00 - we're just setting as a parameter and
538:03 - then we are done with it so this is as
538:05 - far as this one goes
538:07 - besides that we also have health and
538:10 - energy
538:11 - and these two we want to pass into the
538:14 - init method of the first parent class so
538:16 - the monster
538:18 - and those we are getting up here
538:21 - but now we have another problem and that
538:25 - problem is what happens to the fish
538:29 - let me run the code and let's see what
538:31 - happens
538:33 - are not getting an error that's a pretty
538:35 - good sign
538:37 - now if i run
538:38 - shark
538:40 - and
538:41 - the methods we have here could for
538:44 - example be attack
538:46 - and for attack we need an amount let's
538:48 - say 10.
538:50 - the monster is attacked 10 damage was
538:52 - stealth so this attack method works just
538:56 - fine
538:57 - besides that i can also print
539:00 - shark.health
539:01 - and let me print this
539:03 - this one is working 200
539:06 - we also get shark dot energy with 55 and
539:10 - we are also getting the byte strength
539:14 - so far
539:15 - we have the shark itself and the monster
539:18 - what we don't have is the fish let me
539:20 - minimize the monster class and open the
539:23 - fish
539:24 - in here we have speed and has scales
539:27 - and this
539:28 - our class doesn't have right now
539:31 - so if i type shark and
539:34 - speed
539:35 - and run the code we are getting that the
539:38 - shark object has no attribute speed
539:42 - which means that the inheritance from
539:45 - the fish is not working right now
539:48 - and let me reopen the monster and hide
539:51 - the monster methods so we can see all of
539:53 - the classes quite easily
539:56 - basically what is happening
539:58 - the mro is important here again this one
540:02 - here
540:03 - essentially how you have to think about
540:05 - it
540:07 - we first of all call the shark and then
540:10 - we call the init method of the shark
540:13 - and then python knows the first item of
540:15 - inheritance is the monster
540:17 - and since we are calling super.init
540:20 - we are calling this init method up here
540:23 - and passing the arguments in there
540:26 - the consequence is that we have health
540:29 - and energy for the monster and the
540:31 - normal inheritance still works so we
540:33 - also have attack and move
540:35 - but now the problem is that the init
540:38 - method of the fish
540:40 - is never called
540:42 - and as a consequence speed and has
540:44 - scales doesn't exist inside of the shark
540:47 - and what we have to figure out is how to
540:49 - call this init method
540:53 - and since we still have to worry about
540:55 - the mro we have to figure out how to
540:57 - call this init method
540:59 - with the arguments
541:01 - from inside of the init method of the
541:05 - monster
541:08 - and for that purpose we are still going
541:11 - to need this super
541:13 - and then the dunder
541:15 - init
541:16 - method
541:17 - and this function is very smart because
541:21 - it follows the inheritance that we have
541:23 - set by the shark to begin with
541:26 - meaning if we call the monster from the
541:28 - shark it knows it has to look at the
541:30 - fish next in line
541:32 - however if you call the monster by
541:34 - itself this init method wouldn't really
541:37 - do anything so this is a very
541:39 - intelligent function
541:41 - in the simplest terms basically what
541:43 - this init method has to do is to set the
541:46 - speed and hash scales
541:48 - of the other class which is the fish
541:51 - again
541:52 - let me set some static numbers for the
541:54 - speed let's go with 75 and for scales
541:57 - this should be false
542:00 - and now if i run all of this again
542:04 - i get for speed let's try this again now
542:07 - for speed i get 75 and for hash scales
542:11 - i get false the arguments we have set in
542:15 - here
542:16 - and this is especially if you are
542:18 - starting with objects probably going to
542:21 - be really confusing but the one thing
542:23 - that makes all of this work is the order
542:26 - of the indent methods we are first
542:28 - calling this one here this is number one
542:31 - then we are looking at the monster
542:34 - which is this one here this init method
542:36 - is number two then and then finally
542:39 - we are looking at the second item in the
542:41 - inheritance which is the fish this for
542:44 - shear so this init method is called
542:46 - third
542:48 - and we always need
542:50 - the
542:51 - super init method to go to the next item
542:55 - and what we would want to add in here as
542:57 - well
542:58 - is a super
543:00 - and then dander init method for the fish
543:04 - as well so if there's going to be
543:07 - another item in the list of inheritance
543:09 - or in the mro
543:10 - we would also call that one
543:13 - and for that reason you very often see
543:16 - super init in most classes because it
543:19 - enables inheritance to work across
543:21 - multiple classes
543:23 - and well i hope you can still follow
543:25 - along this is getting quite complicated
543:27 - and it is just going to get worse
543:29 - because right now we do have one problem
543:32 - and that is that this speed here and the
543:35 - hair scales
543:36 - are constant right now
543:39 - but i want to be able to set them
543:41 - dynamically when i am creating the shark
543:44 - meaning what i want to do when i create
543:47 - a shark
543:48 - i want to set this speed
543:51 - let's set it to 120
543:54 - and i want to set has scales to
543:58 - false
543:59 - and this would then be all the stuff i
544:01 - have for the shark and i think it makes
544:04 - sense to put all of this on separate
544:05 - lines to make it a bit easier to read
544:09 - all right but now if i run this
544:12 - we are getting an error that shark init
544:15 - got unexpected keyword argument speed
544:19 - basically what pipeline is complaining
544:20 - about that this speed and this has
544:23 - scales
544:24 - don't exist in the parameters for the
544:26 - init method of the shark class
544:29 - we can fix that by adding a speed
544:32 - and has scales in here
544:35 - if i run this now this is going to work
544:38 - but we're not doing anything with either
544:40 - the speed or the hass scales we are
544:42 - still up here
544:44 - setting the speed and has scales as
544:46 - constant numbers
544:48 - and now we kind of have a problem
544:51 - because if i try to in this
544:53 - superintendent method at this speed and
544:56 - has scales
544:58 - then let me fix the typo first if i run
545:01 - this now
545:02 - we are getting the other problem that
545:04 - monster.init
545:06 - down here is the error we're getting
545:08 - right now
545:09 - monster.init takes three positional
545:11 - arguments but three were given
545:13 - meaning
545:14 - python in the monster class wants three
545:17 - arguments self health and energy
545:21 - and those we do get let minimize the
545:23 - fish for now so we can see what's going
545:25 - on
545:26 - we are getting health and energy and
545:28 - this is what this init method wants
545:31 - but besides that now we are also adding
545:34 - speed and has scales and for this the
545:38 - init method doesn't have any parameters
545:41 - so python is very unhappy because it
545:44 - gets too many arguments and it doesn't
545:46 - know what to do with them
545:49 - but this is a problem for us
545:51 - because we need those two arguments to
545:55 - pass into the init method for the fish
545:58 - but the init method of the monster
546:00 - doesn't have as many parameters so we
546:03 - have a problem here
546:05 - and to overcome this we need one special
546:08 - concept and that in python is called
546:11 - keyword unpacking
546:13 - and basically what it means is in my
546:16 - monster class
546:18 - after i have added all of the parameters
546:21 - i definitely know i need
546:23 - i want to add star star and then keyword
546:26 - arguments
546:28 - and that way any argument i get after
546:32 - the parameters i am going to store those
546:35 - in a separate dictionary
546:38 - let me actually print what we get so i
546:40 - want to print
546:42 - my keyword arguments without the stars
546:44 - for now
546:45 - and for these double stars python is
546:48 - expecting keyword arguments so all of
546:50 - the arguments for the init method here
546:53 - need to be keyword arguments meaning
546:55 - health.health energy is energy
547:00 - speed is speed
547:02 - and has underscore scales is has scales
547:07 - and now if i run this
547:09 - we are getting a dictionary with speed
547:13 - and has scales
547:15 - and this faults here we are getting from
547:18 - printing shark has scales let me remove
547:21 - that and try this again now
547:23 - so now we can focus on just a dictionary
547:27 - and that is something really useful
547:29 - because this we could use in here now
547:33 - and essentially what you have to do is
547:36 - call the unpacking operator again and
547:38 - passing in the keyword arguments
547:42 - and now if i run this again
547:44 - we are still getting the same dictionary
547:47 - so we are getting
547:49 - speed and we're getting hash scales
547:53 - what happens now if we are calling this
547:56 - star again
547:58 - it turns each key value pair inside of
548:01 - this dictionary into a named argument
548:04 - meaning this speed under 20 is going to
548:06 - become a named argument
548:09 - and then this we are passing into the
548:11 - init method of the next class in the
548:13 - method resolution order
548:16 - and with that if i now print
548:21 - shark
548:22 - dot
548:24 - speed
548:25 - and actually display what we get
548:29 - i now get 120 the one we have specified
548:32 - in here
548:34 - and this is how you would work with this
548:37 - now for an actual example you would add
548:40 - a lot more quarks to all of these
548:43 - classes for example the fish would also
548:46 - have
548:48 - double star and keyword arguments and
548:51 - then you would pass this
548:52 - into the init method as well so in here
548:55 - quarks as well
548:56 - now in this case
548:58 - the keyword arguments is going to be
548:59 - empty if i print it keyword arguments
549:03 - and run this
549:04 - we're getting an empty dictionary
549:07 - because we don't have any additional
549:09 - named arguments that we have to worry
549:10 - about so this dictionary here is going
549:13 - to be empty well this dictionary
549:15 - actually
549:17 - but if we had more named arguments they
549:19 - would all go in there
549:21 - and this is then how you would deal with
549:24 - multiple inheritance
549:26 - and if again you are just starting with
549:30 - inheritance
549:31 - this really isn't something you want to
549:33 - worry about too much
549:35 - probably if you're watching this for the
549:37 - first time and you're still struggling
549:39 - with objects in general this is going to
549:41 - be way too much
549:43 - i would recommend just practice objects
549:46 - and simple inheritance for now
549:48 - and once you are more comfortable with
549:50 - them come back to this
549:53 - this sort of inheritance is only really
549:55 - something you are going to see once you
549:57 - get much more advanced
549:59 - especially for making games or for
550:01 - making gui's you probably don't need any
550:04 - of this whatsoever
550:06 - all of the games i have made so far have
550:08 - never used multiple inheritance they all
550:11 - use simple inheritance and they worked
550:13 - just fine
550:15 - but well at this point we have covered
550:18 - all the main parts of classes
550:21 - i guess at this point there is some more
550:24 - smaller things i do want to cover but
550:26 - they're all going to be fairly simple so
550:28 - let's talk about them in the next
550:29 - section
550:30 - alright for this part i want to talk
550:33 - about some extra parts for classes and
550:35 - those are things i couldn't really fit
550:37 - in in any of the other sections but
550:39 - they're all fairly simple but they can
550:42 - be quite useful
550:43 - and
550:44 - well let's do all of this straight in
550:46 - code i think that's going to be the
550:47 - easiest
550:49 - all right once more we have the monster
550:53 - class and this is just something i want
550:56 - to use to illustrate what we are going
550:58 - to do
551:00 - and let me create an instance of this
551:02 - monster with monster and for the health
551:05 - i want 20 for the energy i want 10. it
551:08 - really doesn't matter what number we go
551:10 - with here
551:11 - and now there are three things i want to
551:14 - cover
551:15 - the first one is private attributes
551:19 - the second one is has utter
551:23 - and set utter
551:26 - and the third one is going to be the dog
551:30 - string
551:32 - and once we have those we are basically
551:34 - done with classes
551:36 - and the first one is going to be private
551:38 - attributes which is just going to be an
551:41 - attribute inside of a class that cannot
551:43 - be influenced from outside of the class
551:46 - which may be something like an id number
551:49 - that you really want to make sure of
551:50 - cannot be changed from outside of the
551:52 - class to be sure that it doesn't mess
551:56 - with some other code
551:57 - and this actually isn't possible in
551:59 - python we are always able to change the
552:02 - attribute of a class
552:04 - so python developers came up with
552:06 - something else
552:08 - and this let me copy this comment here
552:11 - and in the init method of the monster
552:14 - class
552:15 - i want to create
552:17 - a private attribute
552:19 - and how you would do this is first add
552:21 - an underscore and then the name of the
552:23 - attribute let's say in this case i want
552:26 - to have an id
552:27 - and the number i want here could be 5
552:29 - but it could be anything it really
552:31 - doesn't matter
552:33 - and now this id by convention is not
552:37 - supposed to be changed
552:39 - but this is just a convention
552:42 - basically what you do with this format
552:44 - is you tell other developers that this
552:47 - attribute should not be worked on but
552:50 - you totally could work on it for example
552:52 - what i can do i can print
552:55 - monster and then underscore id
552:58 - and i get 5
553:01 - meaning you can work with it but there's
553:03 - a very clear indicator that you
553:05 - shouldn't so if you ever work with
553:07 - somebody else and they added something
553:09 - like this
553:10 - you probably should not change it
553:13 - and well that is all you need to know
553:15 - about private attributes you could do
553:17 - the same thing for methods you are
553:19 - essentially following a naming scheme so
553:21 - this works with both attributes and
553:23 - methods
553:25 - all right next up we have has utter and
553:28 - set utter and what those two are doing
553:32 - is they allow us to check if a class has
553:34 - an attribute and we can also use it to
553:36 - set an attribute
553:38 - and the first one is going to be has
553:40 - utter and that is just going to be a
553:43 - normal python function
553:45 - and this one wants two arguments
553:48 - it first of all wants to have an object
553:50 - and besides that it wants a string
553:53 - with an attribute name
553:57 - and let's try this one i want to look at
553:59 - my monster
554:01 - and for my monster i want to check if
554:04 - the monster has health
554:07 - and this is then going to return a
554:09 - boolean that either says true or false
554:13 - meaning i can print all of this and i
554:15 - get true so this monster has the
554:18 - attribute health
554:20 - if i check for something that doesn't
554:21 - exist let's say a weapon i get faults
554:24 - because the monster doesn't have a
554:26 - weapon
554:28 - and
554:29 - this you could then use an if statement
554:31 - for example if has utter monster health
554:35 - and if it has health i want to print
554:38 - the monster has
554:41 - and i guess then we can use an f string
554:43 - monster dot health
554:46 - and that is terrible spelling
554:49 - and let's turn this into an f string
554:51 - and add
554:52 - health at the end
554:54 - and now we run this the monster has 20
554:56 - health and that is what we have set here
555:00 - and this is has utter it's a really
555:03 - useful way to check if a certain class
555:06 - has an attribute you are going to use
555:08 - this fairly often actually it's a really
555:10 - useful function
555:11 - and besides that set utter works in kind
555:15 - of the same way so let me call it set
555:18 - utter
555:20 - and in here we need three arguments
555:22 - first of all we need an object
555:25 - then we need a string of an attribute
555:28 - name let's call it attribute again
555:31 - and then we have to set a new value and
555:33 - this could be a string it could be a
555:35 - number it's really up to you
555:38 - i guess let's say again i want to look
555:40 - at my monster
555:42 - the attribute i want to set is a weapon
555:46 - and for the value let's give the monster
555:48 - a sword
555:50 - and now i can print
555:52 - monster.web
555:54 - pin
555:55 - and i get sword
555:58 - and this set utter is basically the same
556:02 - thing as calling monster dot weapon
556:05 - and setting this to sword
556:08 - these two things essentially do the same
556:11 - thing
556:13 - and now you might be wondering why do we
556:15 - have this kind of redundancy that this
556:18 - is
556:19 - kind of pointless at least seemingly
556:21 - that we have this entire function that
556:23 - does something very obvious
556:25 - but the reason for it that this allows
556:28 - us to very efficiently create new
556:30 - attributes
556:32 - for example what we could be doing let
556:35 - me
556:35 - comment those two out
556:37 - and i could run a for loop
556:40 - and let me add a let's call it new
556:44 - ad reviews
556:48 - and this is going to be a tuple with
556:50 - lists
556:51 - i want to have for example a weapon
556:54 - and there i can have an x
556:56 - besides that i want to have another list
557:00 - with let's say
557:02 - armor
557:04 - and the armor could be a shield
557:07 - and finally i want to have one more list
557:10 - and this could be
557:11 - potion
557:13 - i could set something like mana or
557:15 - whatever you want to go for
557:18 - and now
557:20 - i can use that as a for loop
557:22 - so
557:23 - for
557:24 - attribute and
557:27 - value in new attributes
557:30 - i can call set utter
557:33 - i can pass in my monster in here and
557:36 - then i want my attribute
557:39 - and my value
557:42 - and if i run this
557:44 - we are not getting an error
557:45 - which is a good sign and now i can print
557:50 - my vars
557:52 - for the monster
557:54 - and i get the new weapon the new armor
557:57 - and the new potion
557:59 - and this way
558:01 - you can set a lot of new attributes and
558:04 - values for class by using this
558:07 - if you just used monster.weapon this one
558:09 - here this would not be possible
558:13 - and this is why set utter exists
558:16 - although you probably would want to
558:18 - create all of these attributes when you
558:20 - actually create the object itself so
558:23 - this isn't something you want to do too
558:25 - often although in some situations it can
558:27 - be really useful
558:30 - alright with that we have set utter and
558:33 - has utter
558:35 - and finally
558:36 - we have doc
558:38 - and doc is just there to explain what
558:40 - your object does
558:43 - that's really just about it
558:46 - you are getting doc or the doc's string
558:48 - to be more specific by calling monster
558:50 - and then dunder dock
558:53 - and in this case if i run this we get
558:55 - none
558:56 - for the simple reason that we have to
558:58 - create a dock string for our object
559:02 - and this you do
559:04 - first thing in the object and all you do
559:06 - in here is you set a triple quotation
559:10 - mark like this
559:12 - and then in there you are setting what
559:15 - you want for the monster for example i
559:17 - could write in here a monster that has
559:21 - some
559:22 - attributes
559:23 - and i am really bad at spelling monster
559:25 - for some reason
559:27 - and now if i run this print again
559:30 - and now i get a monster that has some
559:32 - attributes
559:34 - and this you could make significantly
559:36 - longer depending on what kind of class
559:39 - you have but this is usually what you
559:41 - want to set to explain your code to
559:43 - other people
559:45 - and especially if you work in a team
559:47 - with much larger projects it's really
559:50 - helpful to set something like this
559:52 - because well somebody else might have no
559:54 - idea what you're talking about
559:56 - what you can also do
559:58 - is let me comment out this print
560:00 - statement here and instead call help
560:03 - and i want to look at my monster
560:05 - if i run this
560:07 - i am getting a long list of different
560:10 - things
560:11 - and in here i can see lots of useful
560:13 - things
560:15 - for example i can see
560:17 - monster and its parameters i can see the
560:20 - dog string
560:22 - and i can see all of the methods inside
560:25 - of it
560:26 - and if you just find a new object you
560:28 - don't really know much about the help
560:31 - function is really useful
560:33 - as a matter of fact
560:35 - you can also pass
560:37 - normal python code in here for example
560:39 - what i could pass in here is just str
560:42 - for string and now python gives me the
560:45 - help function for strings
560:48 - and if i go all the way to the top
560:51 - there you can see
560:53 - basically that we have another object
560:55 - and the object takes one argument which
560:58 - is going to be a string
561:00 - then we have the dog string and this one
561:02 - explains what this object does
561:05 - and afterwards we have all of the
561:07 - methods and there are quite a few
561:09 - because strings are very complex objects
561:14 - and with that we have covered objects
561:16 - and classes i hope that wasn't too
561:19 - difficult but this is definitely
561:20 - something you do want to practice
561:23 - so hope that was helpful and i will see
561:25 - you around in this part we are going to
561:28 - be talking about modules this is the
561:31 - part where python really becomes
561:34 - powerful so let's talk about it
561:36 - essentially modules are just extra parts
561:39 - that we can attach to our programs
561:41 - for example if we wanted random numbers
561:44 - we would add the random module that's
561:47 - basically what it is
561:48 - there are quite a few modules that we
561:50 - can use that come with python by default
561:52 - and random is the one you are probably
561:55 - going to use the most but i will cover a
561:57 - few more in just a bit
561:59 - besides that we can also create our own
562:02 - modules to make our code more organized
562:05 - and each module would be in a separate
562:07 - file which makes it really easy to
562:09 - organize larger programs which is
562:11 - something we're also going to cover in
562:12 - just a bit
562:14 - but the much more important part is to
562:16 - use modules for extra functionality and
562:19 - let's start with that one
562:21 - and in here we have two different
562:24 - options
562:25 - we can either import from the python
562:27 - standard library all this really means
562:30 - is that these modules come with python
562:32 - when we install python so we can just
562:34 - import them and then work with them it's
562:37 - super easy besides that
562:40 - we can also import additional modules
562:42 - made by other people but those we have
562:45 - to install on our computer first
562:47 - these modules here can become incredibly
562:50 - important for example if we want to make
562:53 - games or work with machine learning or
562:55 - do data analysis or run databases
562:58 - we would basically install additional
563:00 - modules to make all of this work
563:03 - but let's not get ahead of ourselves and
563:06 - let's start with the python standard
563:08 - library and by just talking about basic
563:11 - modules
563:12 - here we once again have a completely
563:14 - empty python file and what i want to
563:17 - create is a random number
563:21 - the problem we have is that there's no
563:23 - way so far to create random numbers but
563:27 - we can do it by importing a module and
563:30 - this we do with the import command and
563:34 - then the name of the module and the
563:36 - module we want here is called random and
563:39 - this one is giving us random numbers i
563:41 - think the name makes sense here and
563:43 - random has lots of different sub modules
563:46 - that we could be using
563:48 - and the way you would access them is
563:50 - first the name of the module and then
563:52 - the methods inside of it and one here
563:56 - is called randint
563:58 - which is standing for random integer and
564:01 - this is just a method we can call it
564:04 - although this one is expecting two
564:06 - arguments a minimum and a maximum number
564:10 - but once i have those two i can print
564:12 - the random number
564:15 - and now if i run this i get different
564:18 - random numbers every time i'm executing
564:20 - this code and now you might be wondering
564:23 - how do you know what else is inside of
564:25 - the random module and that's a really
564:28 - good question
564:29 - usually what you do is you just google
564:31 - the module and then you find lots of
564:33 - information for example for random
564:36 - we have a whole documentation that is
564:39 - actually incredibly extensive so all of
564:42 - the stuff in here would be part of the
564:45 - random module
564:49 - the one we have seen already is
564:51 - random.rentend
564:54 - and all it does is it creates a random
564:56 - integer between two numbers and this is
565:00 - a function you are using all the time it
565:02 - is really popular
565:04 - another one that you are seeing fairly
565:06 - often is choice
565:08 - and this one picks a random item from
565:11 - some kind of sequence this could be a
565:12 - list it could be a dictionary something
565:14 - like that and let's actually implement
565:17 - this one here i'm back in the code
565:19 - and i want to create a test list
565:24 - and for this test list i just want to
565:26 - have a couple of numbers it really
565:28 - doesn't matter
565:29 - i guess let me put the print on top and
565:32 - now i want to select one item from this
565:35 - list
565:36 - and for that i would get my random again
565:40 - and i would add choice
565:42 - and now this choice is expecting one
565:44 - argument and that is the list so test
565:47 - list in here
565:48 - and now all i have to do is print the
565:51 - result
565:53 - and let me comment out this stuff up
565:56 - here so we're not getting confused
565:58 - and if i run this we get different items
566:02 - from this list
566:04 - i guess to make it a bit more visually
566:06 - appealing
566:07 - let's add a few different data types in
566:09 - here
566:12 - this one is looking better so now if i
566:14 - run this
566:15 - we get all of the different values
566:18 - and that is in the most basic sense how
566:21 - you would be using modules
566:24 - and there are a lot of different modules
566:26 - that come with python already
566:29 - if you look this up online you are going
566:31 - to find this list calling the python
566:33 - standard library
566:34 - and those are all of the modules that
566:36 - come with python
566:38 - and in here we have a lot of different
566:41 - options that we could be working with
566:43 - for example the one i'm seeing right now
566:45 - is called tkinter and this is the most
566:48 - common way to create guise or graphical
566:50 - user interface in python it basically
566:53 - gives you buttons
566:54 - besides that we also have a ton of
566:57 - modules that work with the internet
566:59 - and if i go up a bit more
567:02 - we can see i hope i find it there should
567:05 - be random in here somewhere
567:09 - there we go there is random and there
567:12 - are quite a few more modules that we
567:13 - could use with numbers
567:16 - chances are you are only ever going to
567:18 - see a very small part of all of these
567:20 - modules
567:21 - even i have only ever used a very small
567:24 - part of them
567:25 - for example i have no idea what rl
567:28 - completer is i have never used it even
567:31 - once
567:32 - but some modules in here are incredibly
567:35 - useful and you do want to have a basic
567:37 - awareness of them
567:38 - and you basically learn all of them by
567:40 - just using python and then discovering
567:42 - more and more of them now if you want to
567:45 - import multiple modules you can do it in
567:48 - two ways
567:49 - you could either on another line import
567:51 - something again
567:53 - let's say what i could also import is
567:54 - the string module
567:57 - and what this one does let me comment
567:59 - this one out
568:01 - i could for example print string and in
568:04 - here i could print the s key underscore
568:08 - lowercase
568:09 - and be aware this is not a method this
568:11 - is just an attribute and if i run this
568:14 - i get all the lowercase letters of the
568:16 - alphabet that's really it string is a
568:19 - very simple module
568:21 - if you are importing two modules just
568:23 - like that to save a bit of space you can
568:26 - put all of this on the same line like
568:28 - this
568:29 - and
568:30 - then i can get rid of the second line
568:32 - run all of this again and we get the
568:34 - same output the random module would
568:37 - still work just fine
568:38 - i guess one more module that we could be
568:41 - looking at that you do see fairly often
568:43 - is called math and this one is giving us
568:46 - a few more advanced math functions
568:48 - for example what we could do in here is
568:51 - print math dot sign curve
568:54 - and add like a 1 in here and if you have
568:58 - no idea what this means don't worry too
569:00 - much about it it's just a sine curve not
569:02 - something you use too often unless you
569:05 - are doing some fairly specific tasks i
569:07 - suppose a more common operation for math
569:10 - would be floor
569:12 - and this one gives us the floor of an
569:14 - integer
569:15 - meaning if i have
569:17 - 4.9
569:19 - this one is giving me 4.
569:21 - we are basically just rounding down
569:23 - that's all that's happening in here and
569:25 - with that we have a couple more modules
569:28 - now there are a few more things you can
569:30 - do with the import statement and those
569:33 - are mostly to be more specific in terms
569:35 - of what you import for example for my
569:38 - math
569:39 - i only want to import math.floor and
569:42 - nothing else
569:44 - and if that is the case you can just
569:46 - type from math
569:48 - import floor
569:51 - and this way we are only importing floor
569:53 - and we don't have to worry about the
569:55 - math part in front of it
569:57 - meaning now when i'm calling it down
569:59 - here i can remove it and call floor like
570:02 - any other function oh and let me get rid
570:05 - of the comma all the way up here that
570:06 - shouldn't be there
570:08 - now if i run this
570:10 - we get the same outcome and this flow
570:12 - now works like any other python function
570:15 - if you really wanted to
570:17 - you could also rename this floor
570:20 - function and this you would do by adding
570:23 - s and then the name
570:24 - and you could name this any valid python
570:27 - name i could for example call it get
570:30 - floor
570:31 - and then this one here would be get
570:34 - underscore floor and there we go same
570:36 - outcome
570:38 - i guess what you would mostly do in here
570:41 - is to shorten method names if they get
570:43 - too long for example i could shorten
570:45 - this to f
570:47 - and this would then save me quite a bit
570:50 - of writing
570:52 - and some modules do get very long so
570:54 - this isn't actually as rare as you would
570:56 - think it is
570:58 - and finally there's one more thing that
571:00 - we can do
571:02 - let's say for this random here i want to
571:05 - use all of the methods but i don't
571:07 - really want to write this random at the
571:09 - beginning every single time
571:12 - and to achieve that we would use from
571:15 - random again
571:16 - but now when we import individual
571:19 - modules we are typing a star
571:21 - and this tells python we want to import
571:24 - every single method and function from
571:26 - the random module and then use it in our
571:28 - code and this allows us to use all of
571:30 - them without writing random first
571:33 - really now i can run this and i still
571:35 - get the same outcome although this you
571:37 - really don't want to overdo because if
571:40 - you import all of it you are well
571:43 - importing all of it and this could add a
571:45 - ton of functions and methods and
571:47 - variables that you don't want to use and
571:49 - that could clutter up your program but
571:52 - alright with that we have covered the
571:55 - basics of modules and let's do an
571:57 - exercise
571:59 - and this is going to involve a bit of
572:01 - research on your part what i want you
572:03 - guys to do is to get the current time
572:05 - from the date time module
572:07 - so do some google research and try to
572:09 - figure out how to get this it should be
572:12 - doable in a single line of code
572:14 - i guess two lines of code if you include
572:16 - the importing part as well but pause the
572:18 - video now and try this one yourself
572:23 - i suppose the best way to start this is
572:25 - by doing the research ourselves
572:27 - here again we have the website with the
572:29 - python standard library and what i'm
572:32 - looking for it's already in here i am
572:34 - looking for date time the module
572:37 - and this i get here if i click on it
572:41 - i get a lot more information
572:44 - and in here if you scroll down you can
572:47 - find a ton of different things
572:51 - it's actually quite an extensive module
572:53 - but i'm just looking for one specific
572:55 - thing i hope i can find it for example
572:58 - here we would have today
573:00 - that is kind of useful but i want to
573:02 - find the current time
573:05 - and the current time
573:07 - i
573:08 - can find
573:12 - ah in here class method daytime now this
573:15 - is what i was looking for and this gives
573:17 - me the current time
573:19 - now you obviously didn't know that this
573:21 - one even existed so this probably took
573:24 - you a bit more googling but most of the
573:27 - time this is how you discover new
573:28 - modules you just google a problem then
573:31 - you in some form find a new module and
573:33 - this solves most of your issues
573:35 - that's basically how everybody learns
573:37 - python or any programming language in
573:39 - general
573:40 - let's implement it here i'm back in the
573:42 - code i want to import date time
573:46 - although day time is a bit weird because
573:49 - what we have to do is from date time
573:53 - import date time
573:56 - and what that means is
573:59 - inside of the date time module we have
574:02 - one object called datetime
574:05 - they just happen to have the same name
574:06 - which can be kind of confusing but well
574:09 - it is what it is
574:11 - and i guess just to be a bit fancy here
574:13 - let's abbreviate it as dt
574:17 - and now to get the current time i need
574:19 - my datetime dot now
574:23 - and this
574:24 - i can just print
574:26 - and if i run the code now
574:28 - i get lots of stuff let me comment out
574:31 - all of this and now i get
574:33 - my current date and my current time down
574:36 - to some nanoseconds
574:38 - with that we have covered all the basics
574:41 - of modules
574:42 - meaning if you got so far you already
574:44 - have a pretty good understanding
574:46 - although you can do quite a bit more and
574:49 - that is going to be the next part
574:52 - in this part we are going to cover
574:54 - external modules
574:56 - and external modules are just modules
575:00 - that are made by other programmers
575:02 - and this is giving us a ton of extra
575:05 - functionality
575:07 - for example
575:08 - any kind of game development any kind of
575:10 - data analysis machine learning graphical
575:12 - user interface and a lot more is
575:15 - essentially just a module made by
575:16 - somebody else and we are using these
575:18 - functionalities and this is one of the
575:21 - really strong parts of python there is a
575:23 - very active community that makes a lot
575:25 - of extra modules that you can use for
575:27 - your own projects
575:29 - almost all of them are free there are
575:31 - some very select ones that are being
575:33 - paid those are usually more business
575:34 - oriented ones that you don't have to
575:36 - worry about and these modules are
575:39 - imported like the standard modules the
575:42 - only difference is that these modules
575:44 - have to be installed on your computer
575:45 - first and this can be done in a couple
575:48 - of ways the most common one is in the
575:50 - powershell or the terminal
575:53 - now what does that mean
575:56 - the powershell is for windows and the
575:58 - terminal is for mac os and both are
576:01 - command line interfaces
576:03 - and what a command line interface is is
576:06 - simply a way to interact with your
576:08 - computer simply by typing text if you
576:11 - ever watched any kind of old movies
576:13 - those always use command line interfaces
576:16 - where people just write commands into
576:18 - computer there are no buttons no windows
576:20 - you just write text into your computer
576:22 - and this is what we are doing here as
576:24 - well
576:25 - and this is the way python is intended
576:27 - to be used it's honestly the easiest way
576:29 - and sounds way more complicated than it
576:31 - actually is
576:32 - but let's actually have a look at this
576:34 - and let's start with windows both
576:36 - versions are identical bar a very minor
576:39 - difference
576:40 - now for windows you just have to open
576:42 - the start menu and type powershell
576:46 - and if you press enter you can see
576:49 - something like this let me full screen
576:51 - it
576:52 - and this is a command line interface for
576:54 - windows
576:55 - and in here i can type a ton of commands
576:59 - to make windows do
577:02 - something
577:03 - in my case i only want to do some very
577:06 - specific things
577:08 - and what i want to do
577:10 - is to type pip
577:12 - and install and then the module i want
577:14 - to go for
577:17 - and pip is the python package manager
577:20 - meaning this is what we are using to
577:21 - install any kind of external module and
577:24 - the module i want to install now is
577:26 - called pi
577:27 - auto gui
577:29 - and now all you have to do is press
577:31 - enter and python is installing a bunch
577:34 - of different things there really isn't
577:36 - that much we have to do ourselves but at
577:39 - the end you can see successfully
577:41 - installed pi out to gui and then the
577:43 - version name
577:45 - and that is basically all you have to do
577:48 - although i guess there are a few more
577:49 - things i do want to cover in here
577:53 - one command that i found really useful
577:55 - is called clear and this one clears the
577:57 - entire interface so things are a bit
577:59 - cleaner
578:00 - and one more thing that can be useful is
578:02 - called pip list
578:04 - and this one gives you all the modules
578:06 - that are being installed and your list
578:09 - should be a good bit shorter than mine
578:11 - but you can install a ton of different
578:13 - things here and finally if you want to
578:15 - uninstall a module you will just run pip
578:18 - uninstall
578:19 - and in my case i want to uninstall pi or
578:22 - to gui
578:25 - then
578:26 - python would ask us if we want to
578:27 - proceed i want to with yes and now it's
578:30 - uninstalled
578:32 - now i can clear all of this again
578:35 - and since i do want to use pi to gui i
578:37 - want to install it again and this could
578:39 - be a good exercise for you so install pi
578:42 - or to gui yourself again and see how far
578:45 - you get
578:48 - all we need is pip install pi or to gui
578:53 - if i type this we get all of this again
578:56 - and we have installed pi or to gui and
578:58 - that is pretty much all we needed and
579:01 - now that we have that let's do the same
579:03 - thing for mac os
579:06 - you open all of your programs and in
579:08 - there you type terminal
579:11 - once you do that you're getting a new
579:13 - window and let me maximize it
579:16 - in here if you hold the apple key and
579:19 - plus you can increase the font size
579:22 - which i really want to do you might not
579:24 - need it
579:25 - and in here we can work with mac os
579:28 - using commands
579:30 - just like in windows i could type
579:31 - commands here to control
579:34 - mac
579:35 - os
579:36 - obviously not like that but you get the
579:38 - idea
579:39 - for example clear works just in the same
579:43 - way most commands do actually the one
579:46 - minor difference here is we do not type
579:49 - pip install and the module
579:51 - instead we would be writing pip 3
579:55 - install and then the module
579:58 - the only difference here is the free the
580:00 - rest stays identical
580:02 - d3 here is needed because on mac os
580:05 - python comes pre-installed the problem
580:08 - is the python version is really old and
580:11 - when we installed python on the mac we
580:13 - installed a separate version of python
580:15 - and this three is to tell python that we
580:18 - want to use the latest one which is
580:19 - python 3 we do not want to use the
580:22 - original python
580:23 - but that is the only difference so in my
580:26 - case i want to install pi auto gui i
580:29 - press enter
580:31 - now python is doing a thing and at the
580:33 - end
580:34 - we get
580:36 - successfully installed pi auto gui and
580:38 - if you notice here this is the same
580:41 - version we have on windows
580:43 - and with that we are good to go inside
580:46 - of our code editor there's not going to
580:48 - be a single difference
580:50 - so let's have a look at that
580:52 - alright here we are back in my python
580:55 - file and i'm using windows but this is
580:57 - going to work both with mac and with
580:59 - windows the installing part was the only
581:02 - difference between the operating systems
581:04 - but now i have pi out to gui so i want
581:07 - to import it so import pi or to gui and
581:12 - what this module is doing is it
581:14 - automates windows to a certain extent
581:17 - for example what you could be doing is
581:19 - to move the mouse around or to write
581:20 - some text from your computer with python
581:24 - and i guess let's get started with that
581:26 - now that we have pi out gui i just want
581:28 - to call the entire module and then right
581:31 - and now and here i can tell it to write
581:34 - some text for example this is written by
581:38 - a
581:39 - computer
581:41 - and now if i would run this code we
581:44 - would have this typed out although right
581:47 - now this would be kind of awkward
581:49 - because i have no time to switch to
581:51 - another program like a text editor
581:54 - meaning i want to import another module
581:57 - from the python standard library or
581:59 - another part of a module and this is
582:01 - called from time import sleep
582:04 - and all that sleep does is it pauses our
582:07 - code for a certain time interval
582:10 - let's say i want to call sleep and one
582:13 - second
582:14 - and now
582:16 - let me bring in a text editor
582:19 - and let me run the code switch back and
582:21 - now we have this is written by a
582:23 - computer the text you have just seen was
582:26 - just written by python not by me
582:29 - i suppose to make the effect a bit more
582:31 - noticeable
582:33 - is for this method here
582:35 - we can add another argument or a named
582:38 - argument to be more specific and this is
582:40 - called interval
582:42 - and in my case let's go with 0.5
582:45 - probably a bit long let's say 0.25
582:48 - and this is the interval duration
582:50 - between each letter that is being typed
582:52 - out i guess let me write it again
582:56 - and switch back to the text editor and
582:58 - now you can see this is written by a
583:00 - computer just very very slowly
583:03 - i guess what you also could do is run
583:06 - the code itself
583:07 - and now python is writing this code by
583:09 - itself in sublime this is also working
583:12 - just fine
583:13 - prior to gui doesn't care where it's
583:15 - writing it just starts typing these
583:17 - letters
583:18 - let me get rid of them and with that we
583:21 - have one module
583:23 - the only difference to standard modules
583:25 - is we are first installing it via pip
583:27 - and then we're using it like any other
583:29 - module
583:31 - and the main task for you is to
583:32 - understand what each module is doing and
583:36 - for that you usually find documentations
583:38 - online
583:40 - let's actually have a look at the one
583:41 - for pi auto gui
583:43 - it is looking like this
583:45 - and if you scroll around here you can
583:47 - find a ton of different things you could
583:49 - do
583:50 - for example you could move your mouse
583:52 - you could add a click you could add a
583:54 - double click you could write you could
583:56 - press a button
583:58 - there are a ton of things you can do
583:59 - with pi or to gui it's a really fun
584:01 - module
584:02 - and well this is then bringing us to the
584:06 - exercise bit
584:08 - and what i want you guys to do is to do
584:10 - a bit more research
584:12 - and what that means is create a graph
584:18 - from any of the
584:21 - examples below
584:23 - i should type these things out more but
584:26 - essentially here you have a link to a
584:28 - website if i copy this
584:31 - and open the website
584:33 - you can see a tutorial for pipelot in
584:36 - the matplotlib module and this is the
584:40 - standard module you would use for data
584:42 - analysis it basically makes nice looking
584:44 - graphs
584:45 - and i want you guys to look at any of
584:47 - these examples and try to understand
584:50 - what is happening
584:52 - or well you first have to install
584:54 - maploid lib and then you can follow any
584:56 - of these examples
584:57 - so try to do that install the map.lib
585:00 - module and try to copy or understand any
585:03 - of these examples it's entirely up to
585:05 - you which one
585:07 - maybe go for something slightly more
585:08 - complex this could be a really good
585:10 - challenge for you
585:15 - i want to work on the simplest example
585:18 - here because i want to keep the video
585:20 - short
585:21 - and the first thing we have to do is to
585:23 - install matplotlib
585:25 - so once again
585:26 - for windows i want the powershell let me
585:29 - maximize it
585:31 - i guess let me clear this one first so
585:32 - it's a bit easier to read
585:34 - and now what i have to do is pip
585:36 - install matte plot
585:39 - lip
585:40 - and if i run this we have to install
585:43 - quite a few different things this is
585:45 - going to take a second and we have
585:47 - successfully installed map.lib 3.5.2
585:51 - and if you are working on a mac this
585:53 - would be pip 3 install matplotlib
585:58 - now that we have that let's return to
585:59 - the code
586:01 - and in here let's comment out
586:05 - all of this
586:06 - and we have to figure out how to import
586:09 - mapp.lib
586:11 - and let me bring in the reference from
586:13 - the site let's put it here
586:15 - this is good for reference
586:18 - on the first line we have to import
586:20 - map.lib.pipelot
586:22 - as plt when we're importing map.lib we
586:25 - are not importing all of it we're just
586:27 - getting one subpart of it pipelot and we
586:30 - are renaming this to plt because typing
586:33 - is hard
586:35 - so i want import mad plot
586:38 - lib dot
586:40 - pi plot
586:41 - as plt
586:43 - and now after the exercise
586:46 - i have to create a plt dot plot
586:51 - and this one wants a list with a couple
586:53 - of numbers in the example it's one two
586:56 - three and four
586:58 - and once you have that you can already
587:00 - run this program and you're running this
587:02 - with plt dot show
587:05 - meaning if i run this now
587:07 - we are getting a graph the one you can
587:09 - see on the right besides the y labels
587:13 - and in here you can change the numbers
587:14 - quite easily for example i could add 10
587:17 - 0 100 and if i run this again
587:22 - we get a very different looking graph
587:24 - all that the plot method really wants is
587:26 - the list of numbers and then it puts
587:28 - them into a line chart
587:31 - and what we also see in the example is
587:33 - plt dot y
587:36 - label
587:37 - and all this one really does is it adds
587:40 - a label on the y axis so some numbers in
587:43 - this case on the example
587:47 - and i guess let's copy it one to one
587:49 - we have some numbers
587:52 - for the y
587:54 - axis to be a bit more specific
587:56 - now if we run this
587:58 - we have some numbers for the y axis
588:02 - we can also do the same thing for the
588:03 - x-axis if you really want to and this
588:05 - you get with plt dot x-label
588:08 - and then we have some number for the
588:10 - x-axis if i run this
588:12 - we can see at the bottom now we have
588:16 - some numbers for the x-axis
588:18 - and that would be matplotlib or at the
588:22 - very least a really basic introduction
588:24 - to map.lib
588:26 - map.lib is a really complex module that
588:28 - can visualize data in a ton of different
588:30 - ways so if you want to learn it it is
588:33 - going to take you quite some time
588:35 - all right with that we have external
588:37 - modules so the last part for modules is
588:39 - to create our own or at this part we are
588:42 - going to create our own custom modules
588:45 - and the one question you might be having
588:47 - is why would you want to do that
588:49 - and the answer primarily is organization
588:53 - that you are creating modules and each
588:56 - module is in a separate file and that
588:58 - way you just never have too much stuff
589:01 - in one file which really helps
589:03 - organizing your code
589:05 - so far we just never really needed it
589:07 - but later on when we have thousands of
589:09 - lines of code this becomes incredibly
589:12 - useful to not get lost on your own
589:13 - program that being said you don't have
589:16 - to do it but it's a really good idea to
589:18 - do that i guess let's implement all of
589:20 - this and that should explain it the best
589:23 - all right here once again we have a
589:26 - completely empty python file
589:28 - now since we are working with multiple
589:31 - files i want to be able to switch
589:33 - between them and the best way for that
589:35 - is using tabs
589:37 - so in sublime i'm pressing alt and then
589:40 - i can see all of the menu options
589:43 - you could get the same result by
589:44 - pressing f11
589:46 - and then you get this menu item here and
589:48 - you can select different things
589:50 - and in my case i want to in view show
589:53 - tabs
589:55 - and then i can see the different tabs
589:57 - i've opened right now only one
589:59 - and let me return to full screen so it
590:01 - looks a bit cleaner and now this module
590:04 - is only going to import the stuff from
590:06 - another module meaning i have to create
590:08 - another python file with control n and
590:11 - this one i want to save so if i click on
590:14 - save i can save this to whatever i want
590:17 - let's call this one my
590:20 - module and this is still going to be a
590:22 - python file
590:23 - and now i save this and now i have two
590:26 - files open that i can switch between
590:28 - although right now both are completely
590:30 - empty and let's start in mymodule.pi
590:34 - in here for the simplest possible
590:36 - example
590:37 - i just want to create a test variable
590:40 - and this could have any value let's say
590:43 - test
590:44 - and now this module i want to import in
590:47 - my custom modules python file
590:50 - and this happens in the normal way
590:53 - i first have to import
590:55 - my underscore module and this should not
590:59 - be capitalized
591:01 - and if you run this and you don't get an
591:03 - error this is looking pretty good
591:05 - and now that you have that you can use
591:08 - this module like any other module
591:10 - for example in our case i can run my
591:13 - module
591:14 - and then in my module i have a test var
591:17 - let me copy it
591:19 - i can print this and i get test
591:22 - this is also going to work with
591:23 - functions and with classes for example i
591:26 - could create a test underscore function
591:31 - and then here we could even add some
591:32 - parameters
591:34 - and let's say i just want to print
591:37 - this is
591:38 - an imported
591:41 - function
591:42 - with the
591:44 - parameter and then
591:47 - parameter
591:49 - and now this function
591:51 - i can also use inside of my main module
591:56 - meaning i want my module dot test
591:58 - underscore function
592:00 - and the argument i want to pass in here
592:03 - let's say is one two three
592:05 - and if i run this now we are getting an
592:08 - error the name parameter is not defined
592:10 - and oh the reason is that the parameter
592:13 - and this parameter here have different
592:15 - names
592:16 - this one should be content
592:19 - and now if we execute the code we get
592:22 - this is an imported function with the
592:24 - parameter one two and three
592:26 - so this one is working just fine
592:29 - finally what you can also do let me do
592:32 - it below the function
592:34 - i can create a class called my
592:37 - class
592:39 - added here you can run
592:41 - init
592:43 - with self and give it a self.name
592:48 - let's call it my app
592:51 - and we can call self.value
592:54 - i don't know 12.
592:56 - and this can also have a method it's
592:58 - literally like any other class let's
593:01 - call it do something
593:03 - it needs self and nothing else and then
593:05 - here i just want to print hello
593:09 - so once again super simple class
593:12 - that we now are able to import in the
593:15 - main file
593:17 - actually what i can do
593:19 - if i hold ctrl and click on my module
593:21 - i can see both files side by side
593:24 - which is quite handy
593:27 - and while looking at this i realized
593:29 - that this has the wrong naming scheme
593:31 - this should be my class
593:34 - in fact now looking at this this feels
593:37 - like a really bad name let's rename it
593:39 - to test
593:42 - and now i can call test and
593:46 - mymodule.test
593:47 - and don't forget the brackets
593:50 - now i can run test dot do
593:54 - something
593:55 - and if i run this we get hello
593:58 - meaning
594:00 - this
594:01 - module test here
594:02 - refers to
594:04 - this class test and this do something
594:07 - refers to this do something here
594:10 - and later on you are really going to
594:12 - appreciate having more files with less
594:14 - code in each individual file it makes it
594:16 - much easier to work with
594:18 - but i guess let's do an exercise
594:21 - and what i want you guys to do is to
594:23 - create a some
594:26 - calculator function
594:28 - that takes
594:30 - unlimited
594:31 - arguments and returns the sum
594:35 - and create it here and run it
594:39 - in
594:40 - the main file so pause the video now and
594:44 - create this one function
594:46 - import it to the main file and then run
594:48 - it there
594:52 - all we have to do
594:53 - is create another function
594:55 - and let's call this one sum calculator
595:00 - and in here i want to have one parameter
595:02 - that i called nums
595:04 - but i want to be ready for unlimited
595:07 - arguments so this i want to unpack
595:10 - and now inside of the function all i
595:12 - want to do is to return the sum
595:15 - of these nums
595:17 - and that is literally it
595:20 - now that i have that
595:21 - i can i guess we can be a bit more fancy
595:24 - here let's say from my module i want to
595:28 - import the sum cal q later
595:32 - and again this is working exactly the
595:35 - same way compared to what we have seen
595:36 - before with the external or the python
595:38 - standard modules
595:40 - and now that i have that some calculator
595:43 - and i can add one two three four and
595:45 - five
595:46 - run this
595:48 - and we don't get anything because we're
595:50 - just returning something we are not
595:52 - printing it
595:54 - so let's print it and there we go we get
595:57 - 15.
595:59 - and with that we are pretty much good to
596:02 - go for modules although there is one
596:05 - more topic we do have to cover that is
596:07 - going to be quite short though
596:10 - when you are creating your own python
596:12 - modules there's one really important
596:14 - concept you have to understand and that
596:16 - is called thunder main
596:18 - all this one really means is when a
596:20 - python file is called it creates a
596:22 - couple of internal variables
596:24 - and than the main is one of them it is
596:27 - in fact the most used one
596:30 - essentially what it does is it gives a
596:32 - name to the current python file
596:35 - and the one that we are executing is
596:37 - always called thunder main
596:39 - but any imported file is called dunder
596:42 - and then the file name
596:44 - and this is really useful to control
596:47 - what code is being executed and more
596:49 - importantly to avoid executing code by
596:52 - accident here is the example from the
596:55 - last video
596:56 - and in my main file i want to print
597:01 - dunder
597:02 - name
597:04 - both in my main file
597:06 - and
597:07 - in the one i am importing
597:10 - and if i run the code now i get done
597:13 - domain all the way at the end and all
597:15 - the way at the top i get my module
597:18 - i guess let me comment out all of the
597:21 - other print statements that is going to
597:23 - make it easier to read
597:25 - now if i run this we get two print
597:27 - statements we have my module and main
597:32 - and
597:33 - what happens internally is python first
597:36 - runs all of this imported code here
597:40 - and what it gets at the end is print
597:42 - name
597:43 - so it prints my module
597:45 - and this my module is the same as the
597:47 - name my module up here
597:49 - this is the name of the file
597:52 - and after that we are printing in the
597:55 - main file then the name
597:57 - and then we are getting done domain
598:00 - and the reason why this is called main
598:02 - instead of the file name we get up here
598:04 - is that this is the file we are
598:06 - currently executing
598:08 - if i just looked at my module so this
598:10 - one here and run this again
598:12 - and we are getting main here because
598:15 - right now we are executing my module
598:18 - which turns this one into the main file
598:21 - and this is being used usually with an
598:24 - if statement
598:26 - and you're looking for if dunder name
598:30 - is equal to thunder main
598:33 - only if that is the case let's say i
598:36 - want to print the main file
598:39 - this
598:40 - makes sure you're only running this code
598:42 - if this is actually the file you are
598:44 - executing
598:45 - and most of the time when you have
598:47 - multiple files like in this case
598:49 - all of the actual code is inside of this
598:52 - if statement
598:53 - if you have other kinds of code let's
598:55 - say for this one here for my mymodule.pi
598:59 - i would add the same if statement
599:02 - this one here
599:04 - and then the print statement would be
599:06 - inside of it
599:07 - if i executed my custom module i would
599:10 - only get the main file this one here
599:14 - and inside of my module this one here
599:17 - would not be executed
599:19 - and this way if you have this if
599:21 - statement for every single file
599:23 - you have a lot of control about what is
599:25 - getting executed when you are importing
599:28 - the file which can be incredibly handy
599:31 - in this entire section we are going to
599:33 - cover some extra topics now i do want to
599:36 - be clear here
599:38 - basically all of these parts are very
599:40 - useful but not that common especially
599:42 - for beginners the longest video in here
599:45 - are decorators and error handling as a
599:47 - beginner you are not going to encounter
599:49 - them or use them basically at all
599:52 - meaning at least for now it's perfectly
599:55 - fine to skip this entire section and
599:57 - return later
599:58 - it is probably a good idea for you to
600:00 - practice basic python and then explore
600:03 - these areas especially decorators can
600:06 - get really really complicated and if
600:08 - you're just getting started you are not
600:10 - going to use them anyway so you might as
600:11 - well skip them at the very least for the
600:13 - beginning
600:14 - that being said i do want to cover them
600:16 - because i want to cover all of python
600:18 - and first of all i want to cover two
600:21 - very simple topics that i would
600:22 - recommend you to check out and those are
600:24 - called pass and input
600:27 - all that pass really does is it tells
600:29 - python to not do anything
600:31 - this does seem kind of pointless and
600:34 - basically you would only use it if you
600:36 - have a function but no content yet
600:39 - so maybe you have a function with a good
600:41 - name but you don't yet have good content
600:44 - for the function so you have to fill it
600:46 - with something and you would use a pass
600:48 - for that
600:49 - besides that we have input this is
600:51 - another function that can get user input
600:55 - although you are hardly ever going to
600:57 - use it i'll talk about it in just a
600:59 - second but it really isn't as useful as
601:02 - it sounds
601:04 - so inside of a python file let's say i
601:06 - have a function that is really
601:09 - important
601:12 - function
601:13 - name
601:14 - with whatever parameters you have
601:17 - and for this function you don't have
601:20 - content yet you don't really know what
601:22 - to do with it or at least you're
601:23 - prototyping it but you do want to keep
601:26 - the function by itself but if you're
601:28 - doing this without any content and run
601:30 - the code you are going to get an error
601:32 - because python expected an indented
601:34 - block after function defined on line one
601:37 - so python needs to have something in
601:39 - here
601:40 - and for that you could just add pass and
601:43 - now everything works just fine
601:46 - so pass is basically telling python to
601:48 - not do anything
601:50 - and well not doing anything is something
601:52 - you usually don't have to define though
601:54 - this past you hardly ever see anything
601:57 - productive it's pretty much only there
601:59 - to cover some kind of content where you
602:01 - don't have content yet it's a filler
602:03 - essentially
602:05 - now besides that we have input
602:07 - let's say i want to get some kind of
602:10 - user input
602:11 - and for that we would need input and now
602:14 - in here we can use this kind of like
602:17 - print for example i could print to the
602:19 - user
602:21 - press a
602:22 - button
602:23 - and whatever the user is going to press
602:26 - is going to be stored inside of this
602:28 - user input
602:29 - however there is going to be a problem
602:32 - because if i am running all of this we
602:34 - can see press a button however if i keep
602:36 - on pressing a button i keep on typing in
602:38 - subtime
602:40 - the issue here is sublime does not
602:42 - support input
602:44 - for that we would have to run this
602:46 - python script inside of the powershell
602:49 - or the terminal and how this is going to
602:52 - work let me print
602:54 - the user input at the end so we can tell
602:56 - what's going on and really importantly
602:58 - do save the file
603:01 - what i want to do now is to run this
603:03 - script inside of the powershell or the
603:05 - terminal and let me put this on a
603:07 - separate screen
603:09 - so here we have the powershell and here
603:12 - i have the folder with my python file
603:15 - that i have just created
603:17 - and if you want to run this what you
603:20 - have to do is you first have to type
603:22 - hyphen to run a python command
603:24 - and then you need the file path towards
603:27 - this folder here let me show my mouse
603:30 - actually
603:32 - inside of the terminal you can add a ton
603:34 - of commands to navigate to folder
603:36 - structure the thing is that's kind of
603:38 - complicated and you don't need it all
603:41 - you really have to do is to drag the
603:42 - file in there and then you get the rest
603:45 - automatically so this is all you really
603:47 - have to do just drag and drop the file
603:50 - don't forget the python at the beginning
603:51 - but other than that
603:53 - all you have to do is press enter
603:55 - and now you get press a button exactly
603:58 - what we have specified inside of the
604:00 - python file and now i can press this is
604:04 - my
604:05 - input
604:06 - and if i now press enter i get this is
604:08 - my input
604:10 - and after that the code finishes and we
604:12 - can add another kind of input for
604:14 - example we could add clear in here and
604:16 - we are done
604:17 - and that's really how you run files
604:19 - inside of the powershell or in windows
604:21 - in general and welcome back in this part
604:25 - we are going to cover error handling and
604:28 - well for this part we are going to
604:30 - handle some errors
604:32 - which means
604:33 - obviously your code should not contain
604:36 - any errors because that would crash your
604:38 - program and that would be bad
604:40 - the issue is sometimes you can't really
604:44 - avoid having some errors
604:46 - for example you might try to find a file
604:49 - and it just doesn't exist and you don't
604:51 - notice in advance
604:53 - and as a consequence you want to have
604:55 - the ability to anticipate and deal with
604:57 - errors
604:58 - and fortunately python can deal with
605:01 - that quite easily there are quite a few
605:04 - different ways to do it actually
605:06 - and let's jump straight into the code
605:08 - and let's have a look at all of this
605:11 - alrighty here we have an empty python
605:13 - file and let's just create an error just
605:17 - to get started i want to print one
605:20 - divided by zero
605:22 - and if i run this we're going to get an
605:24 - error we have a zero division error that
605:28 - we are dividing by zero and this is not
605:31 - allowed because math doesn't like it so
605:34 - what could we do to overcome this or
605:36 - rather how can we make python try some
605:39 - code snippet and then do something else
605:42 - if we get an error
605:43 - and well the command is literally called
605:46 - try
605:47 - and this works kind of like an if
605:49 - statement except without any arguments
605:52 - we're just telling python try this line
605:55 - of code here if it works cool if not we
605:58 - want to do something else and the else
606:01 - here is called accept
606:04 - and inside of that i can print something
606:07 - else let's literally write something
606:10 - else
606:11 - and now if i run this
606:13 - we get something else
606:15 - what happened here is that python first
606:18 - went with try and the code in there was
606:20 - this print statement
606:22 - and this print statement included the
606:24 - operation
606:25 - 1 divided by 0 which is not possible as
606:28 - a consequence this here gave us an error
606:32 - and because of that
606:34 - we are going to accept and inside of
606:36 - that we are printing something else
606:38 - and this is what we got in the end as
606:40 - well
606:41 - if i had valid code inside of the try
606:43 - statement let's say 1 divided by 1
606:47 - we will get the result of this line of
606:49 - code here and accept would not be run
606:53 - and that is the easiest way to deal with
606:56 - errors in python however we can both be
606:59 - more specific and we can add more things
607:02 - towards this
607:04 - and let's be more specific first
607:06 - and that is for this except statement we
607:09 - can specify specific errors that we are
607:12 - looking for
607:13 - for example what we are looking for
607:15 - right now is a zero division error
607:18 - and if i run this we are getting the
607:20 - same outcome
607:22 - however now if i add another print
607:24 - statement and i print a variable that
607:27 - doesn't exist yet
607:29 - which if i run this
607:31 - is giving us another kind of error
607:33 - specifically a name error
607:35 - and we are right now only dealing with
607:38 - zero division errors so when python sees
607:41 - a name error it doesn't know what to do
607:43 - with it
607:44 - but well we can account for it by adding
607:46 - another except statement
607:48 - and now
607:50 - we want to look for a name error and if
607:53 - that is the case i want to print let's
607:55 - say does not exist
607:59 - and now if we run this we get does not
608:02 - exist
608:03 - and be aware what happens here python
608:07 - starts all the way at the top with try
608:09 - and then it goes through these lines of
608:11 - code here and we are starting with print
608:14 - a
608:14 - and this one doesn't exist and as a
608:17 - consequence none of the stuff below is
608:19 - executed and we jump immediately
608:23 - to this name error and in there we are
608:26 - printing does not exist which is what we
608:28 - are getting down here
608:30 - now one important thing you may have
608:32 - noticed
608:33 - is that let me actually get rid of it
608:36 - this
608:37 - print here which should have given us
608:40 - this accept statement
608:42 - is not being printed down here in the
608:45 - console
608:46 - meaning that this here wasn't even
608:48 - executed it's really important to
608:50 - understand as soon as try finds any
608:53 - error any code after that is not being
608:56 - executed
608:57 - which is why we only ever get one except
609:00 - statement or the result of one except
609:02 - statement to be more specific
609:05 - and if you happen to be interested in
609:07 - all the possible errors that could
609:09 - happen in python there is a whole
609:12 - documentation online and in here you can
609:15 - find for example arithmetic error buffer
609:17 - error lookup error assertion error
609:20 - lots of different things that could be
609:22 - raised
609:23 - so if you are looking for some specific
609:25 - errors that could come up this list here
609:28 - would be really useful what you want to
609:30 - look for is build in exceptions
609:33 - there are two more things that we can do
609:36 - one is else and the other is finally
609:41 - and let's start with else that one is
609:44 - well it's basically an else statement
609:46 - that you should know from the if
609:47 - statement let's say in here i can just
609:50 - print
609:51 - let's say the else statement
609:55 - and if i run this right now this else
609:58 - statement is not run because we do have
610:01 - an error this name error here
610:02 - specifically
610:04 - but
610:05 - if i run some code in here that does
610:07 - exist
610:09 - let's say print
610:10 - try if i run this now
610:13 - we get the code inside of the try
610:16 - statement and we are getting the else
610:19 - statement as well but the else statement
610:22 - is only run
610:23 - if the try statement doesn't have an
610:25 - error
610:26 - the way you have to think about it is
610:28 - that this else is an else to these
610:30 - except statements
610:32 - and finally we have well finally and
610:36 - finally runs
610:38 - whenever all of this stuff finished and
610:40 - it runs either way it doesn't matter if
610:43 - we have an exception or not
610:45 - let me print
610:47 - finally
610:49 - and if i run this now we get finally
610:52 - again and this is going to happen
610:55 - let me run the zero division error again
610:58 - this finally even comes when we have
611:01 - this division error here i guess i
611:04 - should rename these things a bit more
611:07 - properly
611:08 - you cannot divide by
611:11 - zero
611:12 - and now let's run this again this looks
611:14 - better
611:15 - what is happening in the code right now
611:18 - we first number one start with the try
611:21 - part up here
611:23 - and inside of that on
611:25 - this line here we're getting an error
611:28 - and this leads us to the exception error
611:30 - for zero division error
611:32 - and in there we are printing you cannot
611:35 - divide by zero
611:36 - which is this part here number two
611:39 - and finally
611:40 - we are ending on finally which is number
611:44 - three
611:46 - and this finally runs no matter what
611:47 - happens
611:49 - and with that we have covered how to
611:51 - handle exceptions
611:53 - although there's one really interesting
611:55 - topic and that is you can raise your own
611:58 - error
611:59 - let me actually add comments here to
612:01 - make this example a bit clearer
612:04 - this part here what we covered so far is
612:06 - anticipating errors or to be more
612:09 - specific exceptions
612:12 - what we can also do is raising
612:14 - exceptions
612:16 - ourselves and what i want to do in here
612:20 - for the example is i want to create a
612:23 - variable that must be
612:25 - a string
612:27 - and
612:28 - for now let's give it a string let's
612:31 - call it test string it really doesn't
612:34 - matter what the string here is
612:36 - and now what i want to do is to run an
612:38 - if statement that if this variable
612:42 - contains a string i want to continue as
612:44 - normal
612:45 - if that is not the case i want to raise
612:47 - an exception or well call an error same
612:50 - thing
612:51 - and for that we first of all need an if
612:53 - statement
612:54 - and to check the type of a variable we
612:57 - need is instance
613:01 - and in here i want to check my var must
613:04 - be string and the second argument is the
613:07 - string type or the type we want to look
613:09 - for which in my case is string
613:11 - and if that is the case the variable is
613:14 - all good and let's say i want to print
613:17 - must be string
613:20 - and let me comment out the earlier part
613:23 - and run this code and this is working
613:25 - indeed because a var must be string is a
613:28 - string indeed or it contains a string
613:32 - however now if that is not the case i
613:35 - want to raise an error and this you do
613:37 - with raise and then the type of error
613:40 - you want to raise in my case i want a
613:43 - type error
613:44 - and in here i can add a message as well
613:47 - as the argument and in my case i want to
613:49 - write must be a string
613:52 - if i run the code now nothing happens
613:55 - however if i change this string to
613:57 - something else let's say an empty list
614:01 - now i get a type error must be a string
614:05 - and that way with raise you can create
614:09 - your own errors to your heart's content
614:11 - and along those lines there's another
614:14 - thing you can do to raise an exception
614:17 - and that is called assert
614:20 - and assert basically means that you want
614:23 - to make sure that your code only runs if
614:25 - a certain condition is true think of
614:28 - assert as a stronger if statement that
614:31 - if this condition is false your entire
614:33 - code stops with an error
614:35 - for example what you could do in here
614:37 - let's do a simpler variable a is 5
614:41 - and a always has to be 5. if a is not 5
614:45 - i want to end all of the code
614:47 - immediately and this i do with assert
614:51 - and in here i can just look for any kind
614:53 - of boolean statement meaning a is equal
614:56 - to 5
614:58 - and if i let me comment this part out
615:01 - if i run this now we get nothing
615:04 - however if i change the value of a to 6
615:09 - we are getting an assertion error
615:12 - and that is caused by this line here
615:16 - and sometimes in your code you really
615:18 - want to make sure that a certain
615:20 - condition is true
615:21 - especially if you work with something
615:23 - more securely concerned this is
615:25 - something you really want to be using
615:26 - extensively
615:28 - but well with that let me uncomment
615:31 - all of this here as well
615:34 - if you understand these three parts you
615:37 - basically know all you ever need to know
615:40 - about error handling it doesn't get that
615:42 - much more complicated
615:43 - and that means we can do an exercise and
615:46 - then call it a day and what i want you
615:48 - guys to do is to create a list and then
615:51 - try to raise an index error and
615:54 - obviously account for this arrow as well
615:56 - and type some kind of message with the
615:58 - print statement
616:00 - also try to use else and finally and see
616:02 - how far you get
616:04 - you might have to do some research
616:05 - online to find what an index error is
616:08 - although i think it makes sense what it
616:11 - might be just try to guess
616:16 - let me start by creating my list and in
616:19 - here i want to list with one two three
616:22 - four and five the content really doesn't
616:24 - matter
616:26 - and an index error basically means that
616:29 - you are trying to get an index that
616:31 - doesn't exist
616:32 - for example i could get my list
616:36 - and then get the index 99 which does not
616:38 - exist
616:40 - i am getting a type error and the type
616:42 - error comes from here let me comment out
616:45 - all of the earlier stuff so we can focus
616:49 - on one thing
616:51 - now let's try this again
616:53 - and now we're getting an index error
616:56 - and that is what i want to account for
616:59 - let me cut this one out and instead i
617:02 - want to go with try
617:04 - and in here
617:05 - i want to get my list 99 which i know
617:08 - does not exist right now
617:11 - so i want to run and accept and i want
617:14 - to look for my index
617:16 - error
617:18 - and if that is the case i want to print
617:21 - that index does not exist
617:25 - and if i run this now
617:27 - we get that index does not exist and no
617:30 - error message anymore
617:32 - i guess with that we have covered the
617:34 - first two parts of the assignment
617:36 - besides that i also want an else and
617:39 - finally let's start with else
617:43 - and in here i just want to print that
617:46 - index exists
617:49 - let's try it if i run it by itself we
617:52 - are getting that index does not exist
617:54 - meaning this line here and we don't see
617:57 - else because else is only run if there's
618:00 - no index error
618:02 - so
618:03 - let's try to get the first index and let
618:06 - me print this one as well
618:10 - now we get two and that index exists
618:13 - which is this print statement here and
618:16 - this else statement
618:18 - and well finally we need finally and in
618:22 - here i just want to print
618:24 - finished
618:26 - and this one is the easiest it always
618:27 - runs we get finished either way if this
618:30 - is working or if it is
618:33 - not
618:34 - working and with that we have covered
618:37 - error messages it really is a fairly
618:40 - simple topic and quite easy to cover in
618:42 - python
618:43 - the main thing i suppose you have to
618:45 - learn is all the different types of
618:47 - exceptions that you can have
618:49 - but if you play around with this a bit
618:51 - it's getting quite natural
618:54 - so we are done with this one
618:57 - hello there in this tutorial we are
619:00 - going to cover decorators which are is
619:02 - somewhat more advanced topic in python
619:05 - so let's go over some theory first
619:08 - in the most basic sense decorators are
619:11 - functions that decorate other functions
619:13 - which does sound a bit cryptic but
619:16 - essentially what we do is we are
619:17 - wrapping one function around another
619:19 - function
619:21 - and let's do this a bit more visually to
619:23 - illustrate what's happening
619:25 - this is a normal function and usually
619:28 - what you do is you just call it
619:30 - somewhere and then you have something
619:31 - happening
619:33 - what decorators do is we still have the
619:36 - normal function
619:37 - but now we are putting another function
619:40 - around it
619:41 - and then when we are calling all of this
619:44 - we are calling the decorator function
619:46 - and inside of that decorator function we
619:49 - are calling the original function
619:51 - and this is allowing us to execute code
619:53 - before and after the function
619:55 - so when i'm calling this function here i
619:58 - could run code here and i could run code
620:01 - here without making any changes to the
620:04 - original function
620:05 - this function here
620:07 - would stay exactly the same all the
620:09 - actual logic happens inside of the
620:12 - decorator
620:14 - we are literally putting one function
620:15 - inside of another function and this
620:17 - other function executes extra code
620:20 - that's the entire idea of a decorator
620:23 - now why would you want to do this
620:26 - basically this way we can give extra
620:28 - functionality to a function without
620:31 - changing it
620:32 - a simple example here is we could write
620:34 - a decorator for a function and it makes
620:37 - the function execute twice when called
620:40 - not the most useful function but we are
620:42 - going to talk some more useful examples
620:44 - later on i just want to illustrate what
620:46 - is happening now in practice you are
620:49 - seeing decorators in three different
620:51 - circumstances let's go over them
620:54 - the most common one is you want to test
620:56 - your code without changing it let's say
620:59 - you work in a team you have some really
621:00 - complicated code and you want to test
621:03 - your code without making too many
621:04 - changes a decorator would be excellent
621:07 - for that
621:08 - the other example would be you are
621:10 - working in a team and you want to avoid
621:13 - making unnecessary changes
621:15 - now those two points are pretty similar
621:18 - you basically want to do something with
621:19 - your code without making too many
621:21 - changes
621:22 - and both of these are also fairly
621:24 - advanced if you are just learning python
621:27 - you are quite far away from either of
621:29 - these which is why you may be struggling
621:32 - with decorators because you don't really
621:34 - need them
621:36 - however there is a third case that you
621:38 - probably are going to use
621:40 - and that is using a decorator inside of
621:42 - a class because this allows you to run
621:45 - code when an attribute is accessed or
621:48 - changed
621:49 - so for example let's say you have a
621:51 - monster with health and every time that
621:53 - health is changed you want to run some
621:55 - other function inside of the monster
621:57 - with a decorator doing this is fairly
622:00 - easy although that being said decorators
622:04 - can be quite hard especially for
622:06 - beginners because we are going to use
622:08 - some more advanced functionalities in
622:10 - python that may be slightly confusing
622:14 - although i would really recommend you to
622:16 - try to follow along because this is
622:18 - going to be really good practice to
622:20 - understand functions and how to pass
622:22 - them around
622:23 - in fact before we start with decorators
622:26 - we need to recap functions itself so
622:29 - let's have a look at that
622:31 - here we have a completely empty sheet of
622:33 - code
622:34 - and let's just get started with a really
622:36 - basic function
622:38 - i want to define let's call it func
622:41 - there are no arguments and inside of
622:43 - this function i just want to print
622:46 - function
622:47 - just about the easiest function you can
622:49 - write if i call this function
622:52 - i get function
622:54 - so this really doesn't do all that much
622:58 - now there's a really important concept
622:59 - you have to understand that right now we
623:02 - are calling the function here
623:05 - and if we didn't do that so if i remove
623:08 - those brackets i could run this and
623:10 - nothing would happen
623:12 - but what i could do is print the
623:15 - function itself
623:17 - and now i get a function object
623:20 - meaning this
623:23 - function here as the whole function not
623:26 - what's being returned just the function
623:28 - itself and this is just going to be an
623:31 - object
623:32 - if that doesn't tell you anything check
623:34 - out my videos on object-oriented
623:36 - programming they should be quite helpful
623:38 - but basically
623:40 - what this func is giving us is a simple
623:43 - object that we can call and if we don't
623:45 - call it we are just getting a function
623:47 - object still not particularly useful
623:50 - but what we can do with this function
623:52 - object is pass it around like any other
623:55 - object like an integer like a string
623:58 - like basically any other object
624:01 - we can pass it around for example what
624:03 - we can do
624:04 - i can create another function
624:06 - and this let's call it a wrapper
624:09 - because this one is supposed to take the
624:11 - argument of the function
624:14 - and then i want to execute the function
624:16 - itself meaning what i can do now i can
624:19 - call my wrapper function
624:21 - and run this
624:23 - and i get function again
624:25 - and what is happening in here i am
624:28 - calling this wrapper and i'm passing in
624:31 - this function here
624:34 - what happens as a consequence
624:36 - is this function is being passed as a
624:39 - parameter
624:41 - into the wrapper function and inside of
624:43 - that function
624:45 - we are calling this function
624:48 - and when we are calling it we are
624:50 - printing the word function
624:52 - and now that we have that we could also
624:55 - do something like print
624:58 - hello
624:59 - and
625:00 - print
625:01 - goodbye and if i run this now
625:04 - we are running the function inside of
625:07 - another function and before and after we
625:09 - are calling it we are running some other
625:11 - code
625:12 - and this is basically the main idea of a
625:15 - decorator although it does get a bit
625:17 - more complicated
625:19 - but we'll come to that in just a bit now
625:22 - there's one more thing that you can do
625:24 - inside of a function
625:26 - and that is you can create a whole new
625:29 - function
625:30 - so for example let me create another
625:33 - function
625:35 - and let's call this one a function
625:38 - generator
625:40 - and then here we have no arguments to
625:41 - keep it simple
625:43 - and now inside of this function
625:45 - generator i want to create a new
625:48 - function
625:49 - and let's call this one new function i
625:51 - guess it's a good word
625:53 - and in here i just want to print
625:56 - new
625:57 - function
625:58 - and since this new function is just
626:01 - going to be an object we can return
626:04 - the new function and what i can do with
626:07 - that
626:07 - i can create a variable let's call it
626:10 - new function
626:12 - and i want to get my function generator
626:16 - and if i run this we can't see anything
626:19 - but now this new function is going to
626:22 - have this new function in here
626:25 - meaning what i can do i can call my new
626:28 - function execute it and we get new
626:31 - function
626:32 - so just to go over this because it may
626:34 - be a bit confusing
626:36 - this new function
626:38 - executes this one here
626:40 - and what we are getting from this
626:42 - function generator
626:44 - is we are defining a new function this
626:47 - one here
626:48 - and at the end of the function we are
626:51 - returning this new function
626:53 - and this we are capturing inside of this
626:56 - new function variable
626:57 - and this new function variable now is
627:00 - just a function meaning we can call it
627:03 - here
627:04 - and when we are calling it we are
627:06 - getting this print statement that's
627:08 - really all that's happening here
627:10 - the main thing you have to understand is
627:12 - we are basically passing around
627:13 - functions with the return statement with
627:16 - that we have some function basics so now
627:18 - we can actually start working on the
627:20 - decorator
627:21 - and for that let me open up a new file
627:24 - and in here
627:26 - i want to create an actual decorator
627:29 - now first of all for decorator we are
627:32 - going to need a basic function we want
627:34 - to decorate
627:36 - so for my function basics i want to copy
627:39 - this basic function here
627:41 - which is just printing function by
627:44 - itself so if i run this we get function
627:47 - literally the easiest function you can
627:49 - write more or less
627:51 - and now for this function
627:53 - i want to create a decorator and this is
627:56 - going to be another function that you
627:57 - can give whatever name you want let's
627:59 - say i want to call this one decorator to
628:01 - keep things simple
628:03 - and this decorator is going to accept
628:05 - one parameter which is going to be a
628:08 - function so in just a bit we're going to
628:11 - pass this function
628:13 - inside of this decorator
628:15 - what we are going to do with that inside
628:17 - of this function we are going to create
628:20 - another function and let's call this one
628:23 - the wrapper
628:24 - and this one right now doesn't have any
628:27 - arguments
628:28 - but now inside of this function i want
628:30 - to run
628:31 - the original function
628:33 - and besides that i can do quite a few
628:36 - other things for example i could just
628:39 - print
628:41 - the decoration
628:44 - begins and let me write this properly
628:48 - and i can also write the decoration
628:51 - ends and now after i have done that i
628:54 - can return this wrapper
628:57 - and now what i can do
628:59 - i can create my
629:01 - new function
629:04 - and this is going to be my decorator
629:07 - and instead of this decorator i want to
629:09 - pass in my function
629:11 - and once i have that i can just call my
629:14 - new function
629:15 - and i get the decorator begins the
629:17 - function
629:18 - and the decorator ends
629:20 - what is happening here let me go over
629:22 - this this is probably a bit confusing
629:25 - we are starting with our basic function
629:27 - and this function we are passing
629:30 - in here into the
629:33 - decorator function and this is the one
629:35 - we have up here
629:37 - and inside of this decorator function we
629:40 - are creating a whole new function this
629:42 - bit here
629:44 - and inside of this function
629:46 - we are calling the original function
629:50 - meaning this
629:52 - one here
629:54 - and then around this function we are
629:56 - doing some other stuff like we are
629:58 - printing these two statements here
630:02 - and then at the end of all of this we
630:04 - are returning
630:05 - this new function and this new function
630:08 - we are storing in the new function
630:10 - variable
630:12 - and then we can just call it like any
630:15 - other function
630:16 - and now we have extra functionality
630:18 - around our original function
630:21 - now where this becomes really
630:23 - interesting
630:24 - is let's say
630:26 - somewhere later in the course i am
630:28 - running function by itself
630:30 - which would just give me the word
630:32 - function
630:34 - let me comment out these two lines here
630:36 - if i just run fung i get function and
630:39 - nothing else
630:41 - and what i can do with decorators if i
630:44 - uncomment those two lines and get rid of
630:47 - this new func
630:49 - when i create the variable name for this
630:51 - i can just call it the same way like i
630:54 - have called the original function so i
630:56 - can call both func
630:58 - if i do that and run the code again
631:01 - i now have a new functionality for this
631:04 - function
631:06 - because we are essentially overwriting
631:08 - the original function name and that way
631:11 - our function
631:12 - even with the same name has new
631:14 - functionality
631:15 - and this is the basic idea of a
631:17 - decorator if we have this kind of system
631:20 - we can have really complex code and
631:22 - still check our function without making
631:25 - any changes to the code
631:28 - and since this is a reasonable common
631:30 - operation python has a shorthand for it
631:34 - and let me comment out
631:37 - this statement here
631:38 - and the shorthand looks like this i
631:41 - first write an add and then the
631:43 - decorator function so in this case
631:45 - decorator and now if i run all of this
631:47 - again
631:48 - we are seeing the same outcome
631:51 - for the simple reason let me uncomment
631:53 - it
631:55 - that this statement here
631:57 - and this line here they are doing
631:59 - essentially the same thing
632:02 - we are wrapping this function here
632:04 - inside of a decorator this one here
632:08 - and let's go over this a bit more slowly
632:10 - i think that's going to be useful
632:13 - here we have the function you have just
632:15 - seen
632:16 - and you can wrap this in the traditional
632:19 - way by writing the function and then we
632:22 - are putting the function inside of the
632:23 - decorator and then we are calling the
632:25 - function
632:27 - i hope this is making sense if you're
632:29 - confused about this i would recommend to
632:31 - pause the video now and just go over all
632:33 - of these different statements and see
632:35 - how they connect
632:37 - i guess i can go over it as well again
632:39 - we have this decorator here and inside
632:42 - of this decorator we are passing in
632:44 - a function
632:47 - and then we get this function here as a
632:49 - parameter
632:50 - now inside of this function we are
632:53 - creating a whole new function and this
632:56 - one is called wrapper
632:58 - and only inside of this function we are
633:00 - calling the original function this one
633:02 - here and then around this function we
633:05 - can do whatever we want like calling
633:08 - these two print statements here we could
633:10 - also do lots of other things i'm going
633:11 - to cover that in just a second
633:14 - and finally at the end what we are doing
633:16 - is we are returning this wrapper
633:19 - function and this wrapper function we
633:22 - are storing right now in func
633:25 - and then we can call it like any other
633:27 - function
633:29 - and that way we're using the name of the
633:31 - function and overwrite it with this new
633:34 - function that is being wrapped inside of
633:36 - the function
633:37 - which means if i took out this line here
633:40 - the function would come back to its
633:42 - original functionality and just print
633:45 - function
633:46 - now the problem with that approach is
633:48 - that we are writing func three times one
633:51 - two and three and if you want to call it
633:53 - a fourth time which is kind of annoying
633:57 - so what python developers have done is
633:59 - to create a shorthand for this and this
634:01 - is called a decorator and this one is
634:03 - looking like this
634:06 - and
634:07 - basically
634:08 - this line here where we have the name of
634:11 - the function a decorator and then the
634:13 - function as an argument is the same as
634:16 - this add decorator those two lines are
634:19 - doing the exact same thing
634:21 - meaning
634:22 - when you are calling this function you
634:24 - have the same result
634:26 - now obviously just printing two more
634:29 - statements isn't particularly useful so
634:32 - let's actually do something more
634:33 - relevant to see why decorators can be
634:36 - useful
634:37 - here we are back in the code and i want
634:40 - to create another decorator
634:42 - and this one i want to call the duration
634:46 - decorator
634:48 - and then here again as a parameter we
634:50 - need the function
634:52 - and inside of that i want to create a
634:55 - wrapper
634:56 - it doesn't need any arguments
634:58 - and in here first of all i want to
635:00 - execute my function and then return the
635:03 - wrapper
635:04 - and this is essentially a decorator that
635:07 - doesn't do anything right now and what i
635:10 - want to do with it is to measure how
635:12 - long it takes to execute this function
635:15 - here
635:15 - and for that to work we need the time
635:18 - module
635:19 - meaning i want to import time
635:23 - and now what i want to do inside of this
635:25 - decorator
635:26 - i want to get my start time
635:29 - and this i would get with time dot time
635:32 - and this has to run before i call the
635:35 - function
635:36 - and after i have called the function
635:38 - i want to get my duration
635:41 - and my duration is my time.time which is
635:44 - my current time
635:45 - and from that i want to subtract my
635:47 - start time
635:49 - and once i have that i can print
635:52 - let's call it duration and this should
635:55 - be an f string
635:57 - with the duration
636:00 - and now just to get some reasonable
636:02 - numbers in here
636:04 - when i am calling the original function
636:06 - i want to call time dot sleep and make
636:10 - it sleep for one second
636:13 - and now with this duration decorator let
636:16 - me actually call it so duration
636:19 - decorator
636:20 - i can now comment out this line here
636:24 - and now if i run the code we get
636:25 - function and we get the actual duration
636:29 - and from this line we know it took one
636:31 - point a tiny amount of time to execute
636:34 - all of this
636:36 - and this now we could get without making
636:39 - any changes anywhere else in the code
636:42 - we're just calling the function here we
636:44 - have the wrapper up here and then we're
636:46 - adding this one line of code to add some
636:49 - debugging functionality so this is
636:51 - something you could be doing if your
636:52 - code is running very slow and you want
636:54 - to identify what is slowing it down
636:57 - now another thing that i haven't covered
636:59 - yet is that you can combine different
637:02 - decorators and this happens by just
637:04 - adding them with the different add
637:06 - statements on top of each other
637:09 - and we already have another decorator so
637:11 - let me call this original decorator
637:15 - and let's run all of this again
637:17 - and now let me go through them i have
637:20 - decorator begins and decorator ends that
637:24 - is what we are getting up here from this
637:26 - original decorator
637:29 - besides that
637:30 - we have the duration of the decorator
637:32 - and this is what we are getting from
637:34 - this print statement here
637:37 - and the actual function so this print
637:40 - here
637:41 - is this line
637:44 - meaning now even though we have a very
637:46 - simple function by using decorators we
637:49 - can give it a ton more extra
637:50 - functionality without making any changes
637:53 - to it
637:54 - which is well the entire idea of a
637:56 - decorator if you understand this it can
638:00 - be really useful in very specific
638:02 - circumstances although if you are a
638:04 - beginner you probably just are going to
638:06 - add more stuff to this function although
638:09 - well if you know decorators you don't
638:11 - have to
638:13 - and this makes it much cleaner to work
638:14 - with your functions
638:16 - but alright let's do another exercise on
638:18 - this
638:19 - i want you guys to create another
638:21 - decorator that calls a function twice
638:24 - and this decorator should be called with
638:26 - this decorator and this decorator as
638:28 - well so that this function has three
638:31 - decorators in total
638:33 - and let's see how far you get
638:38 - again i have to create another function
638:41 - and let's call it the double
638:44 - decorator
638:46 - and in here once more we need a function
638:49 - and inside of this function i want to
638:51 - create a wrapper
638:53 - it doesn't need any arguments again
638:56 - and now in here i want to call my
638:58 - function twice
638:59 - which i just do by calling my function
639:02 - twice it's very simple once it comes
639:04 - down to it
639:05 - and once i have that i want to return
639:08 - the wrapper once more
639:10 - oh and by the way i'm just calling this
639:12 - wrapper because i think it makes sense
639:14 - you could call this whatever you want
639:16 - there's no naming restriction
639:18 - and all right now what i can do
639:21 - i can add another decorator with the
639:24 - double decorator
639:26 - and now if i run all of this we have to
639:28 - wait a second
639:29 - and if i expand this
639:32 - we have the code being executed
639:34 - once and then twice
639:37 - and well this is working really nicely
639:41 - and here again our actual function is
639:44 - really simple and we are just adding
639:47 - more and more stuff to it and that way
639:49 - it gets more and more complex
639:51 - with that we have some very basic
639:54 - decorators
639:55 - now there are some more things we can do
639:58 - with them
640:00 - and what i want to cover for this part
640:02 - is that you can have functions with
640:03 - parameters being decorated that part is
640:05 - actually really simple
640:07 - and besides that decorators themselves
640:10 - can also have parameters although
640:12 - implementing this gets even more
640:14 - complicated because we are wrapping a
640:16 - function inside of a function inside of
640:18 - another function
640:20 - so this we will have to explore in quite
640:22 - some more detail
640:24 - but let's have a look at all of this
640:26 - here i am back in a completely empty
640:28 - sheet of code and i want to create a new
640:32 - function so define function
640:34 - and now i want to have a function
640:36 - parameter
640:38 - it doesn't really matter what it is and
640:40 - in my case i am just going to print that
640:42 - function parameter
640:44 - and now once we have that i can call
640:47 - this function with whatever i want let's
640:49 - say hello
640:51 - and if i run this i get hello a super
640:54 - simple function
640:56 - and to decorate this
640:58 - we kind of need the same thing we have
641:00 - done here it's not really that much more
641:03 - complicated
641:04 - as a matter of fact let me actually copy
641:06 - this decorator here
641:10 - and paste it in here
641:13 - and now i want to decorate this function
641:17 - with the decorator
641:20 - and just as a reminder
641:23 - this would be the same thing as calling
641:26 - function
641:27 - is the decorator
641:29 - with the function
641:31 - however now if i call this
641:35 - i am getting the decorator takes zero
641:37 - position arguments but one was given
641:41 - and this happens in this one as well as
641:44 - in this one
641:46 - so we're getting the same error message
641:48 - that's usually a good sign at the very
641:50 - least
641:51 - the problem python has is that this
641:53 - function needs this parameter so when we
641:56 - are calling the function up here
641:59 - we again need the parameter but on top
642:03 - of that when we call this function here
642:06 - we are calling this wrapper and right
642:10 - now when we are calling hello we are
642:13 - passing it essentially into this
642:15 - parameter here which doesn't exist yet
642:18 - which is why python is so unhappy
642:21 - and to get around this we just have to
642:23 - create the parameters
642:25 - meaning this wrapper here and this
642:27 - function
642:28 - need the same parameters or well for
642:31 - this wrapper it's a parameter for this
642:33 - function it's an argument
642:35 - and let me name them properly here i
642:37 - want to have a wrapper parameter
642:40 - and now if i run all of this again we
642:42 - should see a different error message
642:45 - and that is that func is missing one
642:47 - required position argument func
642:49 - parameter
642:51 - meaning
642:52 - this one here
642:54 - and well i get this
642:57 - argument from the wrapper parameter so
643:00 - now if i run this
643:02 - we get hello and if i change this
643:04 - argument to something
643:07 - this is still working
643:10 - and we could also do this the other way
643:13 - the more traditional way
643:15 - and we will get the same outcome
643:18 - and let me just go over what is
643:20 - happening here by using the traditional
643:22 - style to make it a bit easier to explain
643:25 - we are again calling this decorator
643:28 - function here and passing in the
643:30 - function itself
643:32 - now inside of this decorator we are
643:35 - creating all of this here
643:39 - and right now the wrapper has one
643:42 - parameter the wrapper parameter
643:45 - and then inside of this wrapper function
643:47 - we are calling whatever code we want and
643:50 - we also have the original function here
643:54 - and then we are passing the wrapper
643:55 - parameter as an argument inside of this
643:58 - function
643:59 - and once we have all of that at the end
644:01 - of the code we can just call the
644:03 - function with something and then this
644:05 - something would be passed into the
644:08 - parameter for the wrapper
644:10 - and then this would be passed into the
644:12 - original function
644:14 - now what you see very often for the
644:17 - rapper you don't have one specific
644:19 - argument instead people very often just
644:22 - add arcs with a star and then double
644:25 - quarks
644:26 - and then this you pass into whatever
644:29 - original function you have so if i run
644:32 - this we get the same outcome and these
644:35 - are very simple unpacking operators this
644:38 - one is for a list and this one is for
644:40 - dictionary or keywords
644:42 - and the reason why these are used is
644:45 - because they allow
644:47 - for this decorator to accept basically
644:50 - any kind of function with any kind of
644:53 - parameter right now we only have one
644:55 - parameter but we could also have more
644:58 - name parameters an unlimited amount of
645:00 - arguments it doesn't really matter if
645:02 - you have this setup you can accept any
645:05 - number of arguments or named arguments
645:08 - which means that this decorator works
645:11 - with literally any function without
645:13 - limitation
645:14 - and all right with that we have basic
645:16 - parameters
645:18 - what we can also do let me uncomment the
645:20 - decorator let's try if this is working
645:22 - it does
645:23 - what we can also do
645:25 - is create a decorator that is accepting
645:27 - other arguments like a 10 for example
645:31 - but for that to work we need something
645:33 - even more complex so let's do this in a
645:36 - separate file
645:39 - all right and here once more we have an
645:42 - incredibly simple function if i call
645:45 - this function we can see function
645:49 - and now what i want to do i want to
645:52 - create another decorator
645:55 - and let's call this one a repetition
645:59 - decorator
646:01 - and this one should accept one argument
646:03 - by how many times i want to repeat this
646:05 - function here for example if i add a
646:08 - five in here i want to repeat this code
646:11 - five times when it's being called or
646:13 - rather i want to call it five times when
646:15 - it is being called
646:18 - now for that to work we need some pretty
646:22 - extensive setup
646:24 - and let me go through what this would
646:25 - look like i am first going to create the
646:28 - actual decorator so repetition decorator
646:31 - but this one is not going to accept a
646:34 - function instead it is going to accept
646:37 - this argument here so in my case i want
646:40 - to call this the repetitions
646:44 - and now inside of this
646:46 - i am creating another function and this
646:48 - is the actual decorator
646:51 - and this decorator is going to accept a
646:53 - function
646:55 - and now inside of this decorator
646:57 - i want to create the actual wrapper
647:00 - and this one in my case has no arguments
647:03 - and what i want to do is for
647:06 - let's call it r in
647:08 - range
647:09 - repetitions
647:11 - i want to run my function
647:15 - and now what i have to do i have to
647:18 - inside of the decorator i want to return
647:21 - the wrapper
647:22 - and then inside of the scope of this
647:25 - repetition decorator
647:27 - i want to return
647:29 - the actual
647:31 - deck curator
647:33 - and now if i run this it is going to
647:36 - work five times and i can change this to
647:38 - a 20
647:40 - and we will call this function 20 times
647:43 - now the question is
647:44 - why does this work so
647:47 - let's go over it and
647:49 - let's do this in a traditional way
647:52 - which i guess i haven't done yet but
647:55 - if we didn't use decorators and still
647:57 - wanted to use this it would look like
647:59 - this
648:00 - i'm still using my func variable name
648:03 - and now i want to call the repetition
648:05 - decorator
648:07 - and now for this repetition decorator i
648:09 - have to specify how many repetitions i
648:11 - want let's say 4 in this case
648:15 - and after i have that
648:17 - i am calling whatever i get from this
648:19 - and passing in my function
648:22 - and if i run this we get function 4
648:25 - times
648:26 - now if you look at this this is probably
648:28 - really confusing
648:30 - but to understand this you basically
648:32 - have to understand the return statement
648:35 - and let's go through it one by one
648:38 - first of all we are calling the
648:39 - repetition decorator and passing in four
648:42 - that is this line of code here
648:46 - and this one by itself doesn't actually
648:48 - do all that much all we are doing is
648:51 - creating a new function and returning it
648:56 - so all we are getting from this
648:57 - repetition decorator with a 4 is this
649:01 - decorator here a new function
649:04 - meaning this decorator here is going to
649:07 - replace the entire decorator we have
649:10 - seen so far
649:11 - and on this new decorator we are calling
649:14 - the new function
649:16 - this one here meaning now we are passing
649:20 - this function
649:21 - inside of here and this function is
649:23 - being captured inside of
649:27 - this
649:28 - parameter
649:30 - and once we have that
649:32 - we are basically back to a normal
649:37 - so inside of this decorator we have a
649:39 - wrapper and this one just loops over the
649:43 - range of repetitions that we get from up
649:45 - here
649:47 - and then inside of that we are calling
649:48 - the function and then we are returning
649:51 - the wrapper
649:53 - and then this wrapper is being stored
649:55 - inside of the function and we can call
649:58 - this function
649:59 - and then we are repeating it by whatever
650:01 - we specified in here
650:04 - and well if i comment this out again and
650:07 - return to my decorator let's add four in
650:09 - here and we still get four repetitions
650:14 - and i would really recommend you to
650:16 - practice this in your own time although
650:19 - if you're just starting don't worry too
650:21 - much about it just get used to functions
650:23 - and classes by themselves and once you
650:25 - are a bit more comfortable start working
650:27 - on decorators they are definitely one of
650:30 - the more advanced topics in python
650:32 - although there is going to be another
650:35 - section and this is where you are
650:37 - probably going to use decorators the
650:39 - most as a beginner and that is to use
650:42 - decorators inside of classes
650:45 - so let's talk about decorators inside of
650:48 - classes and there's one really important
650:51 - one it is called property
650:54 - and what this allows us to do
650:57 - is it allows us to turn methods into
650:59 - attributes and this is something we get
651:02 - from the property function that we can
651:05 - use inside of python it actually comes
651:07 - with python
651:08 - and i'm pretty sure all of this is going
651:10 - to sound really cryptic if i just
651:12 - explain it theoretically
651:14 - so let's do all of this in code that
651:16 - should be better all right here i have a
651:19 - completely empty python file and what i
651:22 - want to do is to create a new class
651:24 - let's call it generic
651:27 - and in here i want to create a dunder
651:31 - init method and this one itself and
651:34 - nothing else
651:35 - and what i want to do in here is create
651:38 - one attribute let's call it x and let's
651:40 - set a value for 10 it really doesn't
651:42 - matter what it is and now i want to
651:46 - create an object from this class let's
651:49 - call it generic and i just want my
651:51 - generic class
651:53 - and now i can print generic
651:56 - dot x and i should get 10 and indeed i
652:00 - do
652:01 - and now what i want to do is i want to
652:04 - observe this x here meaning whenever i
652:08 - look at it so i retrieve the value or
652:10 - when i change the value i want to run
652:13 - some other code and this by itself in
652:16 - python isn't really that easy to do
652:19 - i guess what you could be doing is run
652:21 - some kind of function that let's call it
652:24 - get x in here self
652:27 - and in here i could return self.x
652:31 - and then besides that i could print some
652:33 - other code
652:35 - let's say get x
652:37 - and now inside of this print statement
652:40 - instead of x i want to get x
652:43 - and don't forget to call it if i run
652:45 - this i get get x and the value so when i
652:49 - get x i can run some other code
652:52 - and this is fine by itself but it's not
652:55 - very elegant
652:57 - and again like we have seen with the
652:59 - other decorators
653:01 - what happens if i already have a lot of
653:03 - code let's say i have this generic x 10
653:08 - times in my code and i don't want to
653:11 - change all of these instances here i
653:14 - just want to change my class itself to
653:16 - account for that that whenever we get x
653:19 - i want to run some other code and this
653:22 - we can do
653:24 - but we need some special function in
653:26 - python
653:27 - and this function is called property
653:32 - and into this property function
653:34 - we can pass in a getter a setter and a
653:38 - deleter
653:40 - and then we can assign all of this to
653:44 - one attribute inside of our class let's
653:47 - say x right
653:48 - now and then this x is what we are
653:52 - actually going to work with so now when
653:55 - we are calling generic x this line here
653:58 - this x refers to this x here and then
654:02 - when we are just looking at this x we
654:04 - are calling the getter method
654:06 - when we are changing this x we are
654:08 - calling setter
654:10 - and when we are deleting this x we are
654:12 - calling deleter
654:14 - meaning now what you usually see with
654:16 - this the original attribute we have this
654:19 - x here
654:20 - we are turning into a private method
654:22 - with an underscore before it
654:25 - and now to python this x here and this x
654:28 - are two separate variables
654:31 - but i as a programmer still know that
654:34 - they're the same because of the naming
654:36 - convention here
654:37 - and now basically what i'm going to do
654:40 - for this getter i am going to return
654:42 - underscore x
654:44 - and with that we have a getter so this
654:49 - method here is going to be this getter
654:53 - meaning whenever we are calling
654:55 - this generic x
654:57 - we are calling this get a method
655:00 - which is then returning this underscore
655:03 - x
655:04 - and essentially what we are doing here
655:06 - outside of the class we are working with
655:09 - x and this is what we are accessing but
655:12 - inside of the class we are using
655:14 - underscore x and this is what actually
655:17 - keeps track of the value
655:20 - and now basically what we have to do
655:22 - besides a getter we also need a
655:26 - setter so let me change it and for the
655:29 - setter we need self and a new value
655:32 - and when we are calling this
655:34 - let me run set x
655:37 - and then self underscore x should be the
655:40 - value
655:41 - and this we do not want to return
655:45 - and finally besides that let me copy it
655:48 - one more time
655:50 - i want to have it deleter
655:52 - this one doesn't need a value
655:55 - and what i want to do in here is delete
655:58 - x
655:59 - and all we have to do for this one is to
656:01 - run del and self dot underscore x
656:07 - and now i can run this
656:10 - and let me make this a bit smaller
656:13 - now when i print generic x we get get x
656:17 - and the value of x meaning we have run
656:20 - this method here
656:23 - what i can also do before i'm printing x
656:26 - i can run
656:27 - generic x
656:29 - is equal to 4
656:31 - and now if i run this
656:33 - i am setting x and i'm getting x and
656:36 - then i get the actual value of x
656:40 - and finally what i can do
656:42 - i can also run delete and generic dot x
656:47 - and now if i run this i have set x get x
656:50 - the value of x and delete x
656:54 - meaning now
656:55 - whenever i for example get the value of
656:58 - x i can run
657:00 - whatever other code i want
657:03 - and for example what i could do with
657:05 - that
657:06 - i could import from date time that's not
657:10 - how you spell that from date time import
657:13 - date time
657:14 - and i want to know whenever i get x
657:18 - which i get by just printing
657:21 - the date time dot now
657:24 - and now if i run this
657:26 - i am getting the current time
657:28 - when i'm accessing x
657:30 - and since we're just returning this
657:33 - underscore x you could even make changes
657:35 - to whatever x you get depending on the
657:37 - time of day some other variables some
657:39 - basically anything you want to look at
657:42 - which is why all of this is really
657:44 - powerful
657:45 - and i would recommend to go over this in
657:48 - your own time it's really useful
657:50 - but just to go over it really quickly
657:52 - again i think that's going to be useful
657:55 - when we are initiating this class
657:57 - we have underscore x this one here
658:01 - and this is the variable we actually
658:04 - storing values in
658:06 - right now that is 10 but it really
658:07 - doesn't matter what it is
658:10 - once we have that we are running this
658:13 - line here and this one turns x into a
658:16 - property
658:18 - and this property has a getter
658:20 - a setter and a deleter
658:24 - and those are referring to this getter
658:26 - here this setter here
658:28 - and this deleter
658:31 - and now from outside of the class
658:33 - whenever we are accessing this x here we
658:37 - are running either of these methods
658:39 - and these methods then influence
658:42 - self.x which is where we actually store
658:45 - the value
658:46 - so this one here
658:48 - and that way when we are accessing
658:51 - changing or deleting a value we can run
658:53 - whatever code we want in there
658:56 - and i hope this is making sense this is
658:59 - again something slightly more advanced
659:00 - that you probably want to practice on
659:02 - your own time
659:03 - but what python developers also realized
659:06 - is that this isn't exactly an elegant
659:09 - way of writing all of this
659:11 - which is why this property works really
659:15 - well as a decorator
659:17 - and let me copy the entire class
659:20 - to implement this as a decorator
659:24 - and let me comment out all of this
659:28 - and basically how you would implement
659:31 - all of this as a decorator
659:33 - for the getter
659:35 - you would simply add the add
659:37 - property decorator
659:40 - although then the getter you would
659:42 - rename to the name of the property which
659:45 - in my case is this one here so i just
659:47 - want this to be x
659:50 - now for the setter
659:52 - i want to get another decorator and this
659:55 - one you would call with the name of the
659:57 - property in my case again x and now you
660:00 - would add dot setter
660:02 - and then the actual method would also be
660:05 - called x or the name of the property
660:08 - and finally
660:09 - the same works for deleter so we need x
660:12 - dot deleter
660:15 - and now the name of the method should
660:17 - also be the name of the property
660:19 - so x in my case
660:21 - and now once we have that
660:23 - i can get rid of this property here
660:26 - and now this code
660:28 - does the same as this code up here
660:31 - meaning if i run all of this
660:33 - we get the exact same result except now
660:37 - it's a bit easier to read i suppose
660:40 - and this is something you are going to
660:42 - see reasonably often even as a beginner
660:45 - because running some code when you're
660:48 - just changing a value or even when
660:50 - you're just looking at the value can be
660:51 - really powerful
660:54 - so understanding this here or at least
660:56 - being able to replicate it by yourself
660:58 - is going to be something you do want to
661:00 - practice
661:01 - but again this is all very advanced so
661:04 - if you're just learning python and all
661:06 - of this is too much don't worry about it
661:08 - you are not going to use it for quite
661:10 - some time
661:11 - and it would be much more valuable for
661:14 - you to understand classes and functions
661:16 - by themselves so don't stress yourself
661:19 - if this is too much
661:20 - but anyway this is all you need to know
661:23 - to get started with decorators and i
661:25 - hope that was helpful
661:27 - in this video we are going to cover eval
661:30 - and exec which are two fairly special
661:33 - functions in python let's talk about
661:35 - them
661:37 - both eval and exact are simply functions
661:40 - inside of python
661:41 - the thing that makes them special is
661:43 - that both of them translate strings into
661:46 - python code
661:47 - in practice this would look something
661:49 - like this
661:50 - if i'm running eval
661:52 - 1 plus 1 this would return the operation
661:56 - 1 plus 1 which would give me a 2.
661:59 - and notice here this one plus one
662:02 - originally was just a string nothing
662:05 - else and with eval we are turning this
662:08 - string into an actual python operation
662:11 - which can be incredibly powerful
662:14 - as a matter of fact you could even
662:16 - create new variables from a string
662:19 - which i guess very occasionally can be
662:22 - incredibly useful
662:24 - and while it overall gives you a ton of
662:26 - flexibility
662:27 - however there's something really
662:29 - important and that is
662:32 - you have to be extremely careful when
662:34 - using exact or eval
662:36 - for the simple reason that if you handle
662:39 - these functions badly it allows users to
662:42 - run their own code inside of your code
662:45 - which if you for example run a database
662:48 - might end up with them stealing all of
662:50 - your data
662:51 - for example you might have some kind of
662:54 - input field and this field was
662:56 - originally designed to handle names from
662:59 - users
663:00 - and then you use the eval or exec
663:01 - function to update this kind of name to
663:04 - make sure there are no typos or
663:05 - something like that
663:07 - a user instead of writing a name could
663:09 - just add a ton of code and thereby
663:12 - accessing your database
663:14 - and if that happens you probably are
663:16 - going to be in a lot of trouble
663:18 - so be really careful when you're using
663:20 - these functions
663:21 - they can end up horribly wrong
663:24 - but alright before we jump into code
663:27 - let's talk about the difference between
663:28 - the two
663:29 - eval is the simpler of the two functions
663:32 - it only evaluates code which means you
663:35 - can run functions or simple operations
663:38 - but you cannot create new variables or
663:40 - run if statements or stuff like that for
663:43 - that you would need exac this is the
663:45 - more powerful one
663:46 - and it basically is capable of running
663:49 - any kind of code and let's have a look
663:51 - at both
663:52 - and let me start with eva
663:55 - i need to type eval and now in here i
663:59 - can write any kind of simple statement
664:01 - for example 5 plus 10
664:04 - and if i execute this we don't get
664:06 - anything because this only returns a
664:09 - value it doesn't print it meaning i have
664:12 - to put all of this inside of a print
664:14 - statement if i run this now we are
664:16 - getting 15.
664:18 - and we could even run some kind of code
664:21 - for example what i could be doing
664:23 - is create another string inside of the
664:26 - string
664:27 - with the different quotation marks and
664:29 - let's call this one test
664:31 - and on this test i can call the upper
664:34 - method and run this now and we are
664:37 - getting test essentially what happens is
664:40 - that python just removes these quotation
664:42 - marks and then runs all of this as
664:45 - normal python code
664:46 - however there are limitations especially
664:49 - for eval for example what i couldn't do
664:53 - is print eval if true
664:57 - then print
665:00 - let's say test
665:02 - and if i run this
665:04 - we are getting an error that we have
665:06 - invalid syntax
665:07 - and the invalid syntax we are getting
665:10 - because if true or an if statement in
665:12 - general
665:13 - cannot be run inside of eval
665:16 - for that you would need exec
665:19 - if i run this now this is working just
665:22 - fine and this is a more general theme
665:25 - that in eva we are quite limited in
665:27 - terms of what we can do another example
665:31 - would be
665:32 - i couldn't assign a new value to a
665:34 - variable
665:35 - so in eva i couldn't do something like a
665:38 - equals 10
665:39 - i would be getting a syntax error
665:42 - however if i use exec
665:45 - this would work just fine
665:47 - and after running this code
665:49 - we have a variable a meaning i can print
665:52 - a
665:53 - and we get 10.
665:54 - the value of this 10 here
665:57 - and that is the entire idea behind exec
666:01 - and eval
666:03 - now most of the time especially as a
666:06 - beginner you are not going to use them
666:08 - whatsoever because there are certainly
666:10 - more advanced things
666:12 - however there's one good example that i
666:15 - think can be quite valuable
666:18 - let me copy in four lines of code
666:20 - and i guess i can comment out the
666:22 - earlier stuff what you're looking right
666:24 - now is i have my string and this is just
666:28 - a string and on this string i'm running
666:31 - upper title lower and case fold
666:34 - meaning if i run the code now i get all
666:36 - of these results
666:38 - the issue here now is
666:40 - we have four lines of code for something
666:43 - that is actually really really simple
666:46 - and using eval here could shorten all of
666:49 - this quite substantially and this i
666:52 - think could actually be a really good
666:54 - exercise
666:56 - try to express these four lines here
666:59 - using an eval statement
667:02 - and if you want a tip this should happen
667:05 - inside of a for loop try to figure this
667:08 - one out yourself
667:13 - i first of all have to convert upper
667:16 - tidal lower and case volt into some kind
667:19 - of string and in my case let me just
667:22 - copy it
667:23 - it is looking like this
667:26 - and i want to cycle over this with a for
667:29 - loop meaning i want to do for operation
667:32 - inside of this list
667:35 - and now inside of this i want to run my
667:38 - eval function
667:40 - and in here i need a string of my
667:44 - string
667:46 - and on this i want to run each of these
667:50 - operations
667:51 - and this i would do with an f string and
667:54 - inside of that i want curly brackets and
667:57 - my operation
667:58 - and importantly we do want to call these
668:01 - functions
668:02 - which means i want brackets
668:05 - so for example
668:07 - we are starting with upper and this is
668:09 - going to be inserted in here for the
668:11 - operation
668:12 - which means we are ending up with my
668:14 - string dot upper and then we're adding
668:17 - brackets to actually call this method
668:20 - and eval then basically removes the
668:23 - quotation marks and turns all of this
668:25 - into valid python code
668:28 - and the last thing we have to do is to
668:30 - actually print this so we can see the
668:32 - result
668:34 - let me add the print statement and
668:36 - comment out this earlier stuff
668:39 - and if i execute this now we get the
668:42 - very same result
668:44 - and
668:45 - this may be a bit arguable but i think
668:47 - this is much easier to read than these
668:49 - four lines here
668:51 - but both approaches would be perfectly
668:53 - fine
668:54 - and well with that we have eval and exec

Cleaned transcript:

python is the world's most popular programming language and that is for a reason you can use it to make games and apps run databases build robots and create artificial intelligence with ease the example you see right now is an ai program that tracks my face it took me about five minutes to write and that is a general theme for python it is incredibly easy to learn while also giving you a ton of power for more advanced functionalities and all of this you're going to learn in this video starting from scratch i am assuming that you have never used any kind of programming language before so we are starting all the way from the bottom and over the next 10 or so hours you are going to learn basically everything you need to know about python and after that you can learn pretty much whatever you want in the language and it should be fairly straightforward as a matter of fact this video is part of a larger paid course and this one is going to use all of the stuff you're learning about python and uses it to make four games and that way you are learning in much more detail how to actually use all of this in practice so check this one out if you're interested although this entire video works by itself and you can use it for any other nongaming purpose as well it's a general introduction to python before we start the program we need to cover some fundamentals first of all if you are just getting into programming you are probably overwhelmed by choice besides python you could learn a few hundred other programming languages some have clear names like html5 or java while others are much more difficult to separate like c c sharp and c plus plus so what makes each language different and where should you start also how does python compare to these other languages one good way to separate these languages is by using two axes the first one is about the language being made for a specific purpose or if it is more openended for example sql and r are programming languages for highly specific purposes databases and data analysis respectively on the other side you have languages like python that can also analyze data and run databases but can do a lot more besides that this flexibility is one of the reasons why python is so popular it just can do a ton of different things although this line is not static the best example for that is html initially it was purely a language to make websites it was very much designed for a single purpose however over time people kept on adding more to it and nowadays you can make apps and games with html it became much more flexible and that is the main reason why modern websites are as powerful as they are the other axis is the level of abstraction now when i say a language is more abstract than another i don't mean to say it's more complex instead abstraction refers to how far removed a language is from physical computer hardware let's use html again to see a website written in html5 you first need a browser like chrome or safari that browser in turn runs on an operating system and only that operating system has access to actual physical computer hardware there is a huge distance between the html code and the computer it runs on that means html is a very abstract language this however does not mean that html is more difficult than a less abstract language quite the opposite actually in broad terms the more abstract a language is the easier it is to use that is because a less abstract language needs to work with computer hardware it needs to be very specific about memory management you sometimes have to write for different kinds of computer hardware and generally it is very easy to break things now in this axis python like html is a very abstract language in fact python itself was created using another programming languages that one is called c and this language is much less abstract generally in the bottom right of this graph you have all of the c languages like c c sharp and c plus plus you also have java down there the differences between them are mostly technical and you don't really have to worry about them at least for now that being said csharp was only created because microsoft didn't want to pay license fees to the creators of java these two languages are very similar so there can be a ton of overlap between these different languages they are not entirely unique now when you are just getting started you want to begin in the top right of this graph with more abstract general purpose languages these are easy to learn work everywhere there's a huge community for support and resources and you can use them for a huge variety of projects what you also want to be aware of is that all programming languages are somewhat similar if you know python for example you can learn c or sql much more easily this is actually a really common pattern people start programming in python and then migrate to another language python was actually designed to be a tool to learn programming itself and it just happened to expand over time to become a really popular languages by itself although that doesn't mean that you couldn't stick with python especially for data science think of artificial intelligence databases and data analysis python very often is the default choice and these are fields where you can earn a lot of money it is totally fine to stick with python by itself entirely for your entire career lots of people do that but generally if you are not sure yet what language you want to go for don't worry about it what you're learning in python can very easily be migrated to another language what you want to do is just get started somewhere and work on projects you like and see how far you get and if you feel like changing you can totally do that and not start from scratch a lot of things you are going to learn you can use in other languages as well you are always going to make some progress even if you are switching alright in this video we are going to install python and the main target of this session is to write hello world using python now this task you can approach in two ways number one you can do all of this on your computer and this is going to be the main way if you want to use python normally you want it to be installed on your computer now that being said you can also run python online and for that you don't have to install anything if you just want to have a quick look at python and check if you like it i would recommend to just run python online for now and then if you decide that you do like it you can install it properly so let's start with some websites that let you run python code there are quite a few actually here for example we have one website called programmist.com and this one lets you run python code online besides that you could also use other languages like c c plus javascript and quite a few more but in our case i want to get rid of all the code in here and to print anything in python remember we want to write the word hello world and to print this you have to do a couple of things first of all you have to put this entire phrase into quotation marks could either be single or double quotation marks and for now just follow along i will explain all of this in much more detail later on but now that you have this word it should be green and what you have to do now is write print and then put the quotation mark phrase inside of brackets which means we first of all have the word print then we have a bracket then we have hello world in quotation marks and then we have a closing bracket and if you have all of this you can click on run and now you get hello world if you could follow along so far you have written your first python code and if you don't want to install anything on your computer or register for anything this website here would be really really good so this is definitely something i would recommend you can also make it a bit larger that's a bit easier to read besides that there is also a website called rapple.8 or replit i'm never sure how to pronounce it in here you also have an online editor that you can use for python here we already have print hello world if i run this we get hello world for this one to use it properly you do have to register although it is a bit more powerful but both of these are really good to get started using python although keep in mind you are running all of this in a browser which is somewhat limiting what you ultimately want to do is run python on your own computer that way you have significantly more power and you also have more flexibility so this is what we want to do now for that we have to install python on your computer and the important thing to understand here is that python is just another program that you have to install on your computer it's working basically like word or excel or literally any video game and the file you have to install you get from python.org so let's have a look at this one here we have the python website and what you have to do is click on downloads and in here you want to download python and then the latest version right now this is 3.10.5 by the time you are watching this there's probably a higher number but that isn't going to make much of a difference so click on download and then you get the file downloaded and this is going to work with your specific operating system in my case i have windows but if you have a mac this would also work although you would get a slightly different file and once you have that you click on open file and now you get either install now or customize installation however before you do anything in here there is one incredibly important thing and that you can see down here it says add python 3.10 to path this is an incredibly important option that you absolutely have to take this one you really want to add i will explain later why this is important but do keep in mind this is incredibly important if you don't add this you are going to run into a ton of problems but besides that you can leave everything as it is and then click on install now then you get an installation and this one is going to work like literally any other program so just wait until it finishes and you should be good to go there we go the setup was successful now we can close it and nothing changed however now what you can do if you press the windows key you can type python and you have python 3.10 installed on your computer if you run this you get something like this in here you can write whatever you want for example what you could be writing is what we have already seen you can write print then in quotation marks hello world close the bracket and now if you press enter you get hello world and this was done using python in here you could also write something like one plus two you would get the result and you can do quite a bit more but this is basically valid python so with that we have basic python code although the limitation here is that we can only ever write a single line of code which well isn't great what we need is some kind of code editor and that we are going to cover in the next video because this is a slightly larger section and just to make sure that everybody can follow here i have mac os in there i still have to click on download python and now i'm downloading a pkg file other than that i can click on open file and now we're getting a python installer that messed with my window sorry about that but in here you click on continue you click on continue continue more you click on agree and then you click on install now you need your password as always install software and then you're just installing anything for mac os you don't have to worry about a path and now here you can see all of my programs and i have python 3.10 although just wait a second and there we go now the entire thing finished i can click on close and move this thing to the bin and now i have python installed now to actually use it on macos i need my launcher and you have a program called python launcher although this one does look a bit weird in here you can't do very much although you have a tick box that says run in terminal window or at least i hope you do a terminal is another program inside of mac os if you open the launcher again and type terminal there you have a terminal and let me increase the font size here a bit so this is easier to read now what you want to do in here is you want to type python 3 and then press enter and now you can write python code for example you could write print brackets open then quotation mark hello world and then closing quotation mark closing bracket and now if you print this you get hello world and like we have done on windows you could type one plus two and you're getting free and this is valid python code but once again you're only writing a single line of code but for that again we're going to work on the code editor in this part we are going to install a code editor and let's first talk about why we are going to need that right now we can run python code which is a really good start but we cannot use python comfortably right now we can write single lines of code but later on we want to write hundreds if not thousands of lines of code and right now we just cannot do that for that we are going to need some kind of text editor for our code think of this like word or pages it's simply a text editor except now we are writing code instead of sentences and there are a ton of popular code editors here's the list of the really famous one we have visual studio code pycharm atom and sublime although there are a lot more there basically is no end to code editors the one that i am going to use is called sublime this is a really straightforward and simple code editor that you can also customize quite a bit which i really enjoy but basically all of those would be fine if you have a strong preference although i would recommend just to follow along to also use sublime and this is going to be just another program that we have to install oh i should mention all of them are completely free you don't have to pay anything but let's install it alright here we are on the website of sublime and the url is sublimetext.com the full name of the code editor is sublime text but nobody really calls it that and then here you can go to download and download the entire thing now you can see it already probably there is also a buy option you can purchase sublime it costs about 80 i think but you don't have to do it the free version has exactly the same features and this is what we are going to use basically when you are buying it you are supporting the creators but you don't have to do it so in download you can download the version you need either mac os windows or linux in my case i need windows so i'm clicking on that and now i have a download for my specific version obviously if you have a different operating system this would look a bit different but now you click on open file and then you get this kind of menu in here you just click on next and you install it like anything else and finish there we go now you have installed sublime on mac os the installer might look slightly different but that is minor details but once you have all of that you can type sublime text and now you should be seeing something like this this is our code editor and in here you can write any kind of text whatever you want to write in my case what i want to write in here is print and brackets and now quotation marks hello world and this is going to be the python code we want to execute now to execute all of this we need two major steps number one this is the easy one we have to save our file this we do under file and save or controller command s if i do that i end up somewhere in my file system in my case i have the folder here already you can save it wherever you want it really doesn't make any difference although what does make a difference is the naming of the file let me call this one test but you do have to specify an ending so you want dodge and then add p y short for python this is telling your computer that you have a python file you could compare all of this to word which always needs a docx ending or a text file which always has a txt ending but in our case we want dot pi and now i want to save and what you should be seeing now is that the colors of our text changed if they didn't don't worry too much about it but now what you want to do let me show my mouse and i want to go to tools and in here we have build and build with this basically means you want to execute your code i want to click on build and now i can see hello world down here now you might be seeing something else what you might be seeing is a dialog that looks something like this in here you want to select python so if i click on this one you're getting the same result the reason here is when you're running python for the first time sublime does want to double check that you do indeed want to run python but if you have done that once sublime does remember and most of the time what i am going to do is instead of up here clicking on build i am pressing ctrl or command b this one is going to give you the same result and if you want to close this dialog down here you press on escape although there is a really important topic i do want to cover and that is when we are running any kind of code in sublime what essentially happens is that sublime inserts all of the code into the python app however sublime doesn't know by default where that python app is because remember python is just another program on our computer it's nothing special the only reason sublime right now can find the python app is because of the path files these path files are basically a directory inside of windows that makes it easier for programs to find other programs and because of that sublime can find python very easily if we didn't add python to the path though sublime would not be able to find it and you would have to add quite a bit more yourself to make it all work which fortunately we didn't need because we did add python to the path files if you forgot that for some reason just uninstall python and reinstall it with the pathfire selected that's the easiest way to go on about it but alright what you can do now you could for example copy this line here and paste it multiple times run all of this and you can see hello world multiple times once again how all of this works in detail i will cover in the next well 10 hours or so but in here what you can also do is inside of print add a math operation like 5 10 and now run all of this again under tools and build and you get 15 all the way at the end and with that we can run python code over multiple lines so with this we can basically start the actual python tutorial although before we get started on that there's one more thing i do want to do that you don't necessarily have to follow because i think all of this is looking kind of ugly and a bit hard to read as a consequence i want to change the styling but i am literally only going to change the look of sublime in terms of functionality nothing is going to change so if you want to skip this part you can totally do so let me show my mouse what i want to do most importantly under view i can hide a couple of things that we don't need for example all the way in the bottom you can see a couple of bits of information that we don't need so i want to hide all of this this is the status bar and i want to hide the status bar already looking better besides that up here you can see the tabs if you have multiple python files this can be really useful each tab would be one python file but for a long time we are only ever going to have a single python file later on we are going to use these tabs though but for now i want to go to view and hide tabs already looking much cleaner besides that what you can also do is hide the menu and this is making everything look even cleaner if you want the menu back you are clicking on alt and now you can see it until you click outside of it but then you can bring it back and all of this is already looking significantly cleaner now if you want to get rid of this top bar here you have to click on f11 and now you have a full screen app which i think is much nicer to work in now what you can also do is change the text size what you do with controller command and then either the equal or the minus sign equal makes the text larger minus makes the text smaller and in here just choose whatever you can see best in my case i usually aim for having 30 lines of code on one screen so in my case the font size i usually choose if i copy this a couple of times is something like this i have 30 lines of code on one window but this is entirely subjective you probably want to have something smaller and finally what we can do is change the color scheme and the theming of this and for this you can install external themes this you do with control or command shift and p if you click all of them you get a couple of options that you can use inside of sublime in here you want to click on install package now click on enter now sublime is going to think for a second and now you can install external modules some of these change the functionality of sublime but most of them are just different color schemes and in my case what i want to install is the agila theme so if you type agila this should be the first result and now just press enter and there you can see the nodes for the argila theme but we don't care about that now to get back to our code you want to press alt for the menu and at least for now i do want to show tabs so we can navigate around here although this package control message you can close by clicking on the x here and now we are back in the code but nothing has changed now to actually apply the changes you have to go to preferences and in here you have select a color scheme and select a theme let's start with the theme in here you have a bunch of different themes if you click on down you can see what is changing so if i click on a couple you see what the difference is in my case i just want to use the agile theme so if i click on this we already have a couple of changes what you can also do now if you click on preferences again you can select the color scheme this one changes the actual code in terms of what you see and in here once again you can select a lot of different things i don't want to go over this too fast because it might be a ton of colors and well i don't overwhelm you but in here you can search for different color schemes depending on what you have installed in my case i'm gonna look for agila and then oceanic next if i select this one all of this is looking significantly nicer if i now go to view and hide the tabs this is basically what you're going to see most of the time and i think this is much easier to read although you might be wondering what is this line here on the left and well for now you really don't have to worry about it it's something much more advanced you can entirely ignore it as a consequence since it is not going to be relevant for this entire tutorial i have hidden it which is bringing us to some more optionality inside of sublime so if i go to preferences and here i go to settings we get another window and in here you can see the settings now you might be used to other programs you just have checkboxes in sublime this is working a bit different you are basically having on the left here all of the different options you could be changing for example you could change the margin size to a four and to change this you would have to copy this one here and paste it on the right side like this and now you can change the margin to whatever you want although my case i don't want to do this and i don't want to add too many complications in here because all of this is getting a bit more advanced so what i'm going to do is i have a text file let me increase the size of the right one i have a text file that you can just copy if you want to have the exact same styling that i do you just paste it in here and now if you click on control s to save everything you should see not much of a difference although the yellow bar for example disappeared and all of these options here you can find in the description so with that you can minimize all of this and now all of this looks as clean as it can be at least i think so so with that we have python installed and we can get started i want to start by talking about how code in python or in basically any programming language is being executed and there are a couple of things you have to understand the most important concept is that code will always be executed from the first to the last line for example if we have these three lines of code python is going to start from the top so line one this one here then we do line two line three and then we continue until we reach the end of the code and later on we are going to learn some tools to make this more flexible for example if we want to repeat code or only run code if a certain condition is true but for now i just want to execute some basic code so we can get started and let's have a look at all of this in some actual python file and here we have a completely empty one and something we have seen already is to use the print statement and in here you can just write a random word so a random word and now if i execute the code which again i do with ctrl b or if i press alt i can go to tools and build same thing if i click on it i get a random word and just to be a bit more specific here let me change this word to first line of code and now if i add another print statement let me duplicate this line which i by the way do with ctrl shift and d that way you can duplicate lines and sublime very easily now what i want to do for the second line of code i want to rename this to second line of code and now if i run this we get the second line of code meaning this line here was run first then we have number two and this would then continue forever we are essentially executing code downwards in this direction and this would work with any other data type as well for example i could print some numbers and now we will get one two and three and that is then giving us the most basic thing you have to understand that now we can execute some lines of code and i suppose there's one more important thing when we are talking about words and print and that is let me copy this again a space in here would also show up meaning if i add a ton of white space and run this again we now get this line of code here let me rename it really quick third line of code all of this white space here is still showing up so just keep that in mind and well with that we have covered all of the basics of really basic code execution and i guess with that let's do an exercise i want you guys to use these print statements to print some kind of tree looking shape and for that you want to use basic characters and white space and then combine these two and create that shape so pause the video now and see how far you get the way you have to think about it i want to print again and i want to write five axes and if i run the code now we can see these five axes if i now print these five axes again one two three four five but remove the first two and replace them with a space if i now do this i get the three axis on top of the five axes and before the first x we have a white space so we start to have some kind of pyramid shape i just want to continue i want to print two spaces and an x and if i run the code now we can see we have a proper triangle and this would be the top of my tree and now i can copy this line and at the bottom of the tree i can add it 3 times if i run this now we have a tree this is looking pretty good granted it doesn't look too nice but it is what it is i suppose what we can also do i can just print empty strings with no word inside if i do that we have one line of space between the words we have covered earlier and our tree although one important thing really quick there is one line in here that i left intentionally empty to organize my code for python this line does not exist if i run the code the empty line we have here is because of this empty statement this one comes right below the one two three this one to three this line for python is just being ignored meaning if you don't write a line of code python is just going to ignore it which is really helpful to keep your code organized so alright this is then the most fundamental thing you have to understand and it's pretty simple we are just executing code from the top to the bottom in this part we are going to learn about math operations and those are in python fairly similar because you probably already know them from basic math classes that you learned when you were something like 5 or 6 it's really basic we have plus minus multiply and divide and besides that we also have power floor divide and remainder i guess the letter 3 are a tiny bit more advanced but not that much besides that you can also use brackets perfectly fine like in any kind of computer calculator you ever used there are also comparison operators like smaller than or smaller equal then but those we will cover later because they work ever so slightly differently i guess i can talk about them for a tiny bit but don't worry about those too much yet let's have a look at all of this here again i have a completely empty python file and i want to start by printing a math operation and this i just do by typing the math operation in here for example 10 plus 5 is going to give me 15. and that is literally it it's quite simple if i duplicate this line i can change this to a minus and now we get 5. i could duplicate this again change this to multiply and duplicate it once more and change this to divide and that way we have all the basic operators so if i run this we get 15 5 50 and 2. i guess the one thing you do want to notice here is that when we're using division this operation here python is giving us 2.0 it happens to add a point zero even though we wouldn't need it it's really not a big deal but just keep it in mind besides that we have slightly more advanced math operators let me print 10 star star and 5 and this is giving us a fairly large number because we are taking the power here i guess if i do a 2 we have the equivalent of 10 to the power of 2 which is 10 multiplied by 10 which is 100 and this is what we are getting down here besides that we also have what is called a floor divide and to understand what that means let me divide 10 by 3. if i do this we get 3.333 and it continues basically forever if floor divide essentially gets rid of all of the stuff after the decimal point and this floor divide you get with two divide symbols meaning if i run the code now we are only getting three you are essentially rounding the result of whatever you are getting in here although keep in mind this value is not rounding the result what we're doing is truncating the result which is a fancy word for saying we are cutting off anything after the decimal point i can demonstrate this by dividing 7 over 2. if you do this in your head you are going to get 3.5 with a normal division and if we were to round this number it should be 4 because 0.5 is closer to 4 than it is to 3 but if i run the code again i am getting 3. and just be careful here this can sometimes cause you some errors where you're losing decimal points and then end up thinking you're rounding when you're not actually doing that there's one more math operation we need and that is done with the percentage sign for example this could look like seven percentage two and if i run this let's see what we get we are getting one and this one here is the remainder the best way to think about it is we have seven units in total we have one two three four five six and seven and when we are dividing seven by two we are basically looking for two whole units to get a full number meaning here is one there is two and here is 3. and that is giving us the result we got from this operation and this percentage symbol is giving us whatever remains at the end which is this one here and since this is one the one we're getting down here is well a one you don't see this symbol too often but it can be really useful to figure out if a number is even or odd something you do surprisingly often we're going to have a look at that later there's one more thing i do want to cover and that is brackets for example i could print 5 times 2 and the result is going to be 10 this should be fairly simple but now if i do 5 plus 5 multiplied by 2 think about it for a second and see what you should be getting the result is 15 and it is 15 because we always do multiplication first and then we are doing addition and subtraction meaning this operation is basically 5 plus 10 which gets us 15. if i don't want to do that and add 5 plus 5 first of all i have to put both of those into brackets and now i'm getting 20. what we're doing now is 5 plus 5 is 10 and this we multiply with 2 which is getting us 20. i guess the one thing we can also cover is very simple comparison operators and those do work in the same way that you would expect them to work to be honest for example i could type 10 is greater than 5. the difference here is the result we are getting because the result we're getting is true which i guess doesn't make sense because 10 indeed is greater than 5. if i flip this around that 10 is smaller than 5 and run the code again we are getting false and how we can use these values we will see later on but for now don't worry too much about this one now with that we have covered the basic operations and let's do an exercise what i want you guys to do is to get the average of the numbers from one to seven so one plus two plus three plus four plus five plus six plus seven all divided by seven and see how far you get once again i have to type print and now in here i want one plus two plus three plus four plus five plus six plus seven and all of this has to be inside of brackets because what we're going to do afterwards is divide all of this by 7. and the issue is in terms of math if we left it like this we would first divide seven by seven which would be one and then we are adding all of these numbers but what we want to do instead is do all of this here first and then divide it by seven for this sort of thing sublime is quite intelligent i can just select the entire text create and open brackets and then sublime automatically adds the closing bracket afterwards and with that we are done if i execute the code now we get 4.0 although looking at the result here i realized for this entire part so far i have only ever used full numbers which you don't have to it is perfectly fine to write something like one plus one plus five you would still get the appropriate result any number in here is going to be fine this is working like any math operation you have ever seen in this part we are going to talk about how to connect different lines of code and let me explain the problem let's say we have some kind of math operation and we want to print the result of that map operation on the next line the issue we have now is how can we connect these two lines and the answer here is we are going to need variables and variables are an incredibly important topic in any programming language so let's talk about it all that variables essentially are is a simple container for any kind of data we could for example put a word a number or really anything we have a python in there and once you have created this container you can reuse it over and over again and this variable you create like this we have the variable name then we have the assign operator and that is just an equal sign and then we have the actual data or the value we want to assign and that is basically it this instead of a word could also be a number like one and it could be anything else but how you would solve the earlier problem is you would first store the math operation result in a variable called result and then this result you would print on the next line and i suppose let's actually try all of this once more completely empty python file and in here i want to do a map operation again and so far we always used print and then did some math in here let's say ten plus five but this print we don't need we could just have lines like this although if i execute the code now again by pressing ctrl b nothing would happen although something did happen python did calculate the result here we just didn't tell to print the result so it doesn't print a result and we can't see anything but something did indeed happen instead of printing this result i want to store it in the variable and this variable i called result and this is going to be the name of my variable now and now to assign this value here to this result we are going to need the equals sign which is telling python that the result of this operation should be assigned to this variable and now on the next line we can just print that result and if i run the code now we are getting 15 or the result of this operation here and what is even better we could use this result for further operations and we would use it like the actual value for example what i could be doing i could have another variable let's call it result 2 and the value here should be the original result divided by 2. and if i now print result 2 we can see we get 15 and 7.5 which is this result divided by 2. and this we could do forever this result is basically a stand in for the value we have created here although there's one thing you do want to be careful about and that is variable naming let's talk about this one really quick there are two variable naming parts the first one is the mandatory parts that you have to follow if you do not follow these naming conventions python is going to throw an error and fortunately they are fairly simple the most important one is that variable names can only contain letters numbers and the underscore symbol you couldn't use something like the dollar sign percentage space something like this space in particular should make sense quite intuitively if there's a space in a variable name it's really a python to tell if we have one variable or two variables it just gets messy and if you have a longer variable name and you want to add multiple words together you would use an underscore and that is quite a common thing to do i will show you in a second the second rule is a variable name must start with a letter or an underscore the important thing here is numbers are not allowed a variable name cannot start with a number finally variable names must be different from the inbuilt python tools for example we couldn't name a variable print i hope this one makes sense as well it would just be confusing and i guess let's have a look at all of these rules and see if we can play around with them i want to create a new variable let me call it test and then here we can just add a word test it doesn't really matter if i run this code now we are not getting an error because this variable name here is perfectly fine and i could also add an underscore add some numbers add another underscore and add some capital letters all of this for python totally fine although this name here probably really confusing what python doesn't like let me put this on the next line is if we for example start with a number for the variable let's say to test and the value here could be test again it doesn't matter if i run this now we are getting a syntax error oh well we are getting quite a bit let's actually go through this error message here first of all python is telling me which file has caused the error and also it's telling me on what line the error occurred line 8 in this case which you can see here on the left side besides that i also get the actual line that caused the error so 2 test is equal to test and below that we have the really important information and that is this syntax error invalid decimal literal it sounds somewhat cryptic but what python is complaining about here is that we are starting a variable name with a letter however if i change this to 2 test everything is working just fine again and on top of that adding a number anywhere else inside of the variable name is perfectly fine i could for example add the two at the end this would also work just fine the other thing that you are really not allowed to do is to add spaces in your variable name and if i run this one now we are getting invalid syntax again and here python is giving me a ton more information although it really doesn't tell me all that much this line here is the really important one and i think it does make sense why there's no space allowed if we have something like this it looks like we have two separate variables which obviously would be kind of confusing so what programmers i usually do in basically any programming language is they always add underscore signs to show that we want to add a space but with that we have all of the basics for variable naming or at the very least the mandatory parts there are some more that are more optional let's talk about those the most common rule that you are going to see is that you should use snake case and snake case just means that when you are starting a new word you always start with lowercase and every additional word always is lowercase you basically only use lowercase letters and then to connect words you're using the underscore and this one you have to use anyway since this is a python rule what snare case basically means is you are always going to use lowercase letters and space is replaced with an underscore that's all it means besides that the other rule is that variable names should make sense this sounds very obvious but i can show you a couple of examples in just a second that might get very confusing generally it's fine to have longer variable names but make sure that the variable name expresses its content it's very easy to not do that and end up with code that you do not understand anymore so always write long names that express what the variable actually does and finally variable names should be consistent i suppose this one is pretty obvious and i guess the really important one is this one here because this one is looking terrible if you were working with other people and try to name a variable like this you would have some questions about your mental wellness i suppose something better would be more like test variable and let's call it practice this one here would be a perfectly fine variable name it isn't a snake case because we have lowercase letters and we are connecting the words with an underscore and this one here would also be at least a valid python name but we are kind of inconsistent we are first writing a word with letters and then the actual number so what you might want to do here is write 2 a bit more consistently or don't use any numbers when variable names begin and always stick with numbers whatever you prefer just be consistent it really helps the final thing i really want to mention what i see a lot of beginners do is do something like x equals i don't know some words and this is fine for shorter programs but once you have longer ones it can be really confusing meaning you want to replace this with something that actually means something it is a really common thing that you write a program you don't look at the program for half a year then you come back to the program and you have no idea what you did half a year ago happens to literally every programmer and naming your variables properly makes it a lot easier to read what your code actually does so name your variables properly there's one more thing that i really want to do because now that we have variables we get a few more math operations although those math operations are going to look a bit weird they are looking like this we have plus equal minus equal divide equal and multiply equal i think to explain what they do let's do an example let's say i have num one is equal to one a really basic variable and i want to increase the value of this num by a certain amount for example let's say by 5. to do that i could write some code like this that num1 is itself plus 5. and this would be fine but this also feels kind of clumsy and for that we have these operators here what you would do instead in python is something like this we have num itself then plus equal 5 and those two code snippets here do exactly the same thing they take the original variable and then add a certain value to it let's do this in code actually i think that's going to make more sense i want to create another variable let me call it num1 and by default this one is 10. and now this 10 i want to increase by 5 again and this could look like this i want to get my original num1 and then add 5 to it if i now print num 1 we are getting the value all the way at the end which is 15 again i guess let me use different numbers so we get some different results now we get 20 which is 10 the value of num1 plus 10. but again this here is kind of clumsy and python gets around this biting plus equal and then we are adding 10 meaning now we are taking the original value of num1 and adding 10 towards it and assigning all of this again to num1 and if i run this we are getting the same result so if i spell this out a bit better these two lines here are doing the exact same thing and this is working with the other math operators as well for example we could have minus equal and we are getting zero we could add multiply equal which is getting us a hundred and we have divide equal which is getting us one and if you just want to update a variable this is how you would do it and this is now bringing us to the exercise for this part and what i want you guys to do is to create a variable that has some kind of snake case and try to use a bit of a longer word assign a value to it and on the next line increase this value by 20 and then on the third line print the variable let's get started by creating a really long variable name that is a bit annoying obviously you would never use something like this in practice but i hope you get the idea and the value i want to assign is let's go with 10. on the next line i want to get my really long variable name that is a bit annoying and i realized i do have a typo let me fix it really quick and i want to increase this value so i want plus equal and i think i said 20. and now finally i want to print my really long variable name that is a bit annoying and if i print this we are getting 30. and with that we have variables which is an incredibly important concept in this part we are going to talk about functions and all that functions are are special commands in python we have actually seen one already and that is print which is printing a certain kind of text this one you should be really familiar with at this point but there are quite a few more for example len gives you the amount of characters in a word and another one would be abs or absolute which is giving you the absolute number which in practice just means if we have a negative one and we're using apps this is turning into a one although to understand functions we need one really important concept and that is brackets meaning when we're adding brackets after the name of the function we are calling it and this we have done multiple times already anytime we use print we have called a function by adding brackets afterwards and inside of the brackets we are adding what is called arguments for example for print we can add any kind of argument and this is then what we are going to print in the case of well print and let's have a look at all of this in code i want to once again start with print and this is the name of the function and to call it i need brackets and what we're adding in here is the argument which right now is the word which that's called test and what this function does is it prints the word so we can see it another function that we can use is called len and in here we could add another word if i run the code now we can't see any result because this is only giving us a value but we're not doing anything with that value and to overcome that we have to print the result and now if we run this we are getting 12 and this 12 means that inside of this word we have 12 characters we have 1 2 3 4 5 6 7 8 9 10 11 and 12. notice here that python is counting a space as well and all of this could also be used with variables for example this len i could assign to the variable word length and then on the next line i want to print my word length and i get 12 again and this would be a slightly cleaner way of doing this although the previous one would also be perfectly fine and another function we can also work with is absolute or abs and in here i can add negative 50 and for this once again i have to print the result otherwise we wouldn't see it but now if i run the code we are getting 50 meaning abs removes this negative 50. and there's one more really important thing that you can also do with functions that right now we always only added a single argument but for some functions you could add more than that print is actually one example of that let's put this on a separate line so far for print i always added one argument but what i can do i can add a comma and then add another argument and now i have two arguments if i run the code i get one argument and then print adds the other argument and print accepts an unlimited number of other arguments meaning if i run this now we are getting more and more arguments the important thing here is you always add one argument then a comma and then another argument another comma and so on depending on what the function accepts and some functions only accept a single argument for example absolute only takes one if i added another we will get an error and that is abs takes exactly one argument and we have given two python here is very clear apps only gets one argument but that is essentially the basic concept of calling functions now for the exercise i want you guys to do some research online and i want you guys to look up the function called max and try to figure out what it does and call it inside of this code here i have google open although you could use any search engine and to learn coding you have to do a ton of research so it's a really good idea to start early and what we want to do right now is look at the python function max and let's just see what we get in here we can see a bunch of websites and for python all of them are basically fine w3schools program is are really big ones geeks for geeks is also really big but the one you probably want to use the most is docs.python.org this is the official python documentation if i click on this one we can see all of the builtin functions for python and the one i'm looking for is called max if i click on this i get a ton of information the most important one is right in the beginning it's returning the largest item in an iterable or the largest of two or more arguments what an iterable is we have no idea so far but what we do know is the largest of two or more arguments so let's have a look at that one once again we are in the code and i want to use my max function and in here i want to just add a couple of random numbers now i once again have to print the result and if i run this i get 10. and well we get 10 because max is selecting the largest argument that we are passing into it which right now is 10. and well that is basically what it does if you understand this one you also understand min which is taking the lowest number which in our case is 2. and with that we have covered functions besides functions we also have methods and especially for beginners methods and functions can be very similar so let's compare the two in the most basic sense a method does the same as a function the only difference being that the method is always attached to an object which means we are still calling a method with the name of the method followed by brackets and this is still called calling a method just like a function we can also still pass an argument in here this works in exactly the same way the difference is that methods always are connected to an object and this happens with a dot which in practice looks like this we always start with some kind of object in this case it's a word it could also be a number or any other data type in python this is then followed by a dot and this is really important then we have the method name and then we have brackets with whatever argument you want to put in and then all of this does a certain thing just like a function what this thing could be is for example we can use the upper method and this one takes a word and returns the same word all in uppercase letters and i think this example also illustrates why we have functions and methods sometimes functionality only makes sense for a certain kind of data type or for certain objects with a certain data type and here the upper case really only makes sense for a word there's no uppercase for a number for example and this is why we have methods and i suppose we can implement all of this a bit more practically so let's have a look at all of this in code once again i have a completely empty python file and i want to create a new variable let's call it test and the value for this test is going to be a word to get started i want to print my test variable and if i print it we are getting a word so far all of this should be very familiar and the method we have seen we are calling with a dot after the word and then the name is upper and don't forget the brackets if i run this now we can see a word all in uppercase letters and with that we have called a method what we can also do let me demonstrate it first and then explain i can cut out this upper here and run it on this variable if i run all of this now we are getting the same outcome and why this happened i will explain in the next section but in the most basic sense methods always change a value where you change that value is really up to you in the first example we created the word and then when we are creating the word we are calling the upper method and this is returning the uppercase letters and storing them in the test variable and once we have that we are printing the test variable that's all that's happening here and then the second example looked like this and in here we first created the word and saved the word inside of the test variable after that we are still printing the test variable but now when we are printing it we are modifying it with the upper method which is giving us the uppercase word the result for both of these examples is the same how this works in detail you are going to understand very soon for now i'm going to call the upper method when i create this value now obviously this example really isn't all that useful let's do something more relevant let's say we have some kind of user name and we are expecting something like john smith where we have a first name and a surname but since you are allowing user input this might instead look something like this we have a typo and maybe we have some access at the end and let me add another typo in here this would still be valid user input but obviously it would look terrible which is something we couldn't use for our purposes and methods are really good to clean all of this up and the one method we could start with is called title and let me print the username and see what that one does now we get always let's expand this a tiny bit we are always getting the first letters uppercase and then every other letter is lowercase meaning now we have john smith in the proper spelling at least for names meaning with this we get rid of this o and this i what you can also do is combine different methods what you do by adding another dot after whatever value you want to change and then calling the other method in my case for this one i want to get rid of these two axes and for that i need this strip method and what this one does is it looks at the right and the left side of any word and removes a certain kind of value whatever we specify inside of the arguments and in my case i want to get rid of these two axes which means i want to add the string x in here and if i run this now we can see there is no difference so what went wrong here and i think you can already tell what the problem might be in the original word the two axes were uppercase and this is what we are trying to remove but what this strip method here sees is this string changed by this title meaning strip doesn't see a capital x it sees a lowercase x and for python again remember capitalization really matters an uppercase and the lowercase letter are two completely different things for python to fix that all we need is a lowercase letter and if i run this now we have removed the two values you might be asking yourself what methods are available and there are a couple of ways to achieve that if you want to stay inside of a code editor you would use the dir function and in here you can pass in any value to figure out what methods it has for example i could pass in the user name in here and if i run the code now nothing happens the reason is that this function only returns all of the methods it doesn't print them for that we again need the print function now if we run this we get something that looks a fair bit more technical and you have two main things in here you start with all of this stuff here a lot of names with double underscores before and after the word like this lte here we have two underscores before and two underscores afterwards what these mean we're going to cover much later what you want to focus on for now is all the stuff down here these are the methods that you could be using and we have actually used a couple of them already for example strip we have used title and we have used upper i guess we can do one more method and let's use is alpha what this method does is it checks if the values inside of a word are in the alphabet meaning they are not numbers let me close this one and instead of the dir function i want to print user name and then dot is alpha and don't forget to call it and now if i run this this is saying false the reason for that is that inside of this word we have one value that isn't inside of the alphabet and that is this space here if i remove it and run out of this again now it says true meaning every letter inside of the word is inside of the alphabet if i added any kind of number in here this would go back to false although i don't really want to do that but this would be another way to check something in your word that may become useful especially when you work with something like user input you might want to check if there are numbers inside of the name however if i go back to the dir function run this again this list here still isn't that useful because you have a name but you don't really have an explanation of what the specific method does and well to really understand what a method does you do want to use google and if you want to google for specific things you need to know their names for example in python or in really any programming language a word is always called a string we're going to cover that in much more detail in the next major section just remember for now a word in programming is always called a string and with that let's do some googling in here i want to look for python string methods and then i am getting a ton of different results and again all of these websites here work quite well the one that is the official documentation by python is called docs.python.org and this one says built in types python something something documentation and in here on the left side you can see all of the data types again we're going to cover those in a lot more detail very soon for example here you have numeric types we have sequence types and then we have text sequence type str which stands for string methods this is the one i want to look at and in here you have a very long list let me minimize this part you have a very long list of methods that you could be using along with a fair bit of text explaining what they do for example here is is alpha the one we have just looked at and if you have any kind of problem yourself you would probably read through this list and try to figure out what method works for your purpose and i suppose let's have a look at another website for example w3schools is also really good and in here we also have a long list of all of the methods the list contains the same number of methods and in here let's say if i click on is alpha we get to another website we have an explanation along with an example you honestly can use any of these websites they all cover basically the same thing all right with that we can do an exercise and in my case i want you guys to do some research because i have an exercise string that is saying i like puppies and what i want you guys to do is to find a method that replaces the word puppies with let's say kitties or any other animal that you really like so pause the video now and try to figure this one out yourself in my case i want to look for python a string remember this is just a word and i want to replace a let's say a value if i do this i already get one answer predicted by google that is called replace although if i go down i see replace a bunch more times and well i just had to look at one of them doesn't really matter which one it is let's choose program miss this time this one is really good and then here we have an explanation of what this one does we have an example and then we have the syntax so how we would use it and in here we have a string so any kind of word then the replace method then we have an old value a new value and a count and down here then we can see how we would use these values the old value here means the value we want to replace the new value is what we want to replace it with and then the count basically means if we have the old value multiple times how many times we want to replace it and this one is optional so you could leave it out entirely and with that we can implement all of this back in my code i want to add a dot and then the replace method and in here we first of all need the old word which in my case is puppies after that we need the new word and this in my case is going to be kittens although any kind of word would be fine in here and these two values would be mandatory so we have to have them but once we have them we can print the result and run this now and all the way at the bottom we get i like kittens we have successfully replaced puppies with kittens we could also add a third value and this one determines how many times we would want to replace this value let me actually paste it in a few times here now we have puppies four times by default i am replacing all of them with kittens meaning what i get is i like kittens kittens kittens and kittens but if i add another value in here and this has to be a number let's say i want to add a 2. now if i run this i am only replacing the first two instances of puppies with kittens but after that i keep my puppies around and again there are a lot more methods far too many to cover them in one video what you basically do as a programmer is you keep on working and you learn more and more methods as you go along but that being said even after a few years you are not going to know all of them for that you have google and you just look up different methods i have been programming for years and i still forget them all the time it's really not a major issue and with that we have methods in this part we are going to cover return and return is one of the most important concepts in all of programming so let's talk about it in the most basic sense return is the glue that connects everything in python what that means is that any operation returns a value for example if we calculate 2 plus 2 f4 is being returned we also have functions and methods and those can also return values for example upper returns the uppercase letters of a string and by combining different return values you are creating more complex logic and what you are basically going to do in programming is combining different return values to create something more complex and an example here could look something like this just read through this and try to think of what the outcome here is going to be and let's go through this line step by step we are always starting with the innermost part in this case it is a word and then we are applying right now the first function which is len this is going to return a value and the value it is going to return is 6 or the amount of letters inside of this word and next up this value we are going to multiply with negative 10. this again is going to return another value negative 60. this is then going to return 60 because the absolute function always turns a negative number into a positive number and this would be one example of the return statement where we are taking specific functionalities like the length function here and then use the value they return in another operation like this 6 multiplied by negative 10. what you absolutely have to understand is that every operation in python returns a value and then this value you can combine with other operations like using it in another function or with another method or in a math operation it's really up to you but this is a really powerful system that allows you to add lots of logic on a single line of code let's play around with this i think that is going to be really important once more completely empty python file and let me create a test variable let's use the example from the previous part where we had e word and then we used upper let me print it as well and we are getting a word all in uppercase letters and i think i want to have a bit of white space around it that makes my life a bit easier what happened in here is we have a word and then we're using the upper method to change the word what this combined statement here returns is a word all in uppercase letters and once we have that we can add another method to it and the method we could be using here the one we have already seen let's use replace and what we want to do in here is replace the letter a with the letter let's say x and now if i run this we have x word what happened here is that this first statement returned eword this one should be obvious by itself after that we have used the upper method to turn this eword into e word all in uppercase letters after that we have used the replace method to change this a to an x and we could continue this forever for example what we could do for example what we could be doing is wrap all of this inside of the len function and now if i run this we are getting six we start with a word then we are turning all of this into uppercase letters then we are changing the first letter from an a to an x so what we have inside of these brackets is x word all in uppercase letter and what we do then is use the len method to count how many characters we have inside of this word which right now is 6 and this is what we are storing inside of the variable i hope this makes sense it is a really important concept to understand all it means is every time you perform some kind of operation a different kind of value is being returned and then this value is what you are working with next you really have to be aware that every operation returns some kind of value although this can be kind of weird sometimes one really good example let me remove the white space here and then let's play around with the print function because this one by itself just prints whatever we pass inside so what's going to happen when we print a print function and let's see we are getting 6 and none the 6 we are getting from this inner part and the none is what gets returned by a print statement and none is an actual data type in python you can work with it but it basically denotes the absence of a value but again print is returning something although in this case what it is returning is the data type none i hope you get the idea here now for this part i am not going to do an exercise but i would recommend you to play around with this yourself in your own time and see what you can do yourself throughout this series we are going to do a lot of examples so there's plenty of time for practice a really important thing you have to understand is comments and comments do not influence your code whatsoever they are just explaining it or well they are commenting what your code does and you really want to use comments quite extensively because they are really useful to help how you organize your code and to understand what it does especially if you work in a team you want to add lots of comments because other people would really appreciate it it also works as a really good reminder for your own code it's a really common thing for programmers that you write some code you don't look at it for half a year and then you have no idea what it does anymore and writing comments is a very good way to remind yourself there are two ways to write comments in python the first one is the hashtag symbol anything on that line after the symbol is going to be ignored by python the other way is a triple quotation mark this one will comment out anything inside of these quotation marks this would also work over multiple lines although technically it's not a comment we are going to learn later what this is but you can use it as a comment and let's say i have again a test variable and this one is a really important value i want to add a comment to explain that this is a really important value we are just using the hashtag symbol and anything after that symbol is going to be a comment you can also add multiple if you want to add some specific kind of styling which is fairly common actually what you see fairly often is programmers doing something like this then a comment and then something like this at the end i guess we can close this box as well to make it look a bit prettier with something like this you have a very clear section inside of your code but the important thing here to understand is that anything after hashtag symbol on the line of code is going to be ignored i guess let me actually run the code by printing the test variable run this now and we can only see a really important value anything here and here was ignored by python you could also put this anywhere else in your code for example here and then this line of code is going to be ignored entirely and something that would make more sense is you could comment out the entire line and that is basically it for the easiest kind of commenting although for this type of comment sublime has a very neat trick let me duplicate it a couple of times and imagine all of these are different examples of code and you want to comment out all of them it would be really annoying to write a hashtag in front of every single line of code it just wouldn't be efficient so what you can do is select all of them and then press ctrl and the forward slash the one below the question mark if you do that all of them are being commented out and if you press it again the comment disappears which is what i am using all the time and well with that we have the first type of comment what you can also do i guess let me add something below here let me call it another variable let me just use some numbers and now duplicate this a few more times and again i want to comment out multiple lines of code for that i can use three quotation marks at the start and at the end you can already tell the color was changed to gray and this tells us this is going to be a comment meaning if i run the code now we wouldn't be able to see it okay granted we wouldn't be able to see this at all so let me add a print statement in here with another variable if i run this now we still cannot see the print statement because all of this is a comment now this example here isn't exactly great because it's just lots of individual variables that i copypasted how you would use this kind of comment most of the time is by adding a couple of lines of code that explains something more complex let's say this is a really important section it does a couple of things that we need for the code to work whatever you want to put in here after that you would have the rest of your code this is what you see fairly often and python actually incorporated this into its functionality we're going to see this later on as well i guess for now the really important thing you want to be aware of is this one here the simple kind of comment that you can just put anywhere and that way you can either add explanations or sections to your code which really help with the organization before we are finishing off this section i want to talk a bit more about the lines of execution logic because there are a few things that i haven't covered yet let's go through them the most important part is that how you see lines differs from how python sees them a really good example here is that python does not see empty lines in the code only you do and let me illustrate what i mean if i start typing print and let's call it first line and then duplicate the line and type in second line if i execute this code i get first line and second line this is the stuff we have already seen quite a lot it should be fairly obvious by this point however what happens if i add a space in here now we have a line of code nothing and another line of code if i run all of this now we are still seeing the same result the reason being that python ignores a line without any code if there's nothing on the line python is just going to ignore it meaning what you could be doing is add a huge amount of white space and it would not make any difference to your code which is very often something you do want to work with quite extensively because this is making it much easier to organize your code especially if you add more comments with something like let's say second line and then this could be the first line you could have a setup like this which in your case might make it much easier to read but all that python sees is this line and this line here which is giving you a ton of work to customize whatever explains your code the best but there are quite a few more things that you should be aware of what i have also covered is that python ignores white space within a line meaning you can add as many spaces as you want let's have a look at this one as well for example what i could be doing inside of a string i could add as much white space as i want and this one is going to be reflected in the code i am running what i can also do is add white space between the different parts of the code something like this would still work just fine although granted in this case there isn't much reason to do something like this i suppose something slightly more relevant might be we could add 1 plus 2 plus 4 and so on and for this line python would just ignore the white space meaning if i run this we are just getting the result python doesn't care what you do between these lines which i suppose you could be using for something like 5 multiplied by 5 and then plus 10 so you indicate which operation comes first the 5 multiplied by 5 although still kind of a stretch what you can also do is use tab you can add this as much as you want python doesn't care it trades tabs like white space that being said there's something really important and that is python really cares about the indentation of an entire line let me demonstrate this this is going to become incredibly important later on what we have seen so far is that these annotations do not matter to python however what python does care about is if this entire line is indented if i indent this entire line and run this again python is going to give me an error the error we are getting is called indentation error unexpected indent why that is you are going to learn later what you have to keep in mind for now is that inside of a line you can add as much white space as you want but you couldn't add white space when you start the line like here python is not going to like that but right there's one more topic i do want to cover and that is how to break the line space or at least how to make it a bit more flexible because you can create multiple lines of code in one line the reason here again is what you see as a line and what python sees as a line are two separate things if you want to be a bit more specific about it what you see is a physical line all that really means is whatever is in a single line of code it's as simple as that but what python sees is a logical line and this is what gets executed one step at a time let me demonstrate this one as well actually let me clean all of this up actually so things are a bit easier to read we have two physical lines and two logical lines meaning what we see and what python sees is identical we have this line and we have this line however what i can do now is put both of these print statements on the same line and python isn't going to like this at all and the reason here is that for us this is one physical line and we can i guess read it but to python this is one logical line now that doesn't make sense python can only execute one of these functions at a time it has to execute this line first and then this line second it cannot do them at the same time which is why we are getting an error here although this logic you can break to some extent and there are two ways of doing that the first one is you can use a semicolon and this way you can separate a physical line into logical lines all of this here would be a physical line but because of the semicolon python is going to break this one out into two logical lines and is going to keep happy the opposite operation i suppose you could call it would be a forward slash this one is breaking two physical lines into one logical line this is something you are going to use fairly often if you have a really long operation the example here is we're just adding some numbers and at some point we ran out of monitor space as a consequence we wanted to have all of this on the same line meaning this is two physical lines but because of the forward slash python turn all of this into one logical line and keeps being happy so all is good and let's have a look at those two and then we are done with this entire section and i guess we can start with the semicolon if i put print and print on the same line run this again python is going to be unhappy but if i put a semicolon between the two then python is going to remain happy because this semicolon is breaking a logical line now that being said this semicolon you are probably never going to use or at the very least you are very rarely going to use it it really is very very uncommon what is however much more common is let me create another variable let's call it a what you do see fairly often is some kind of very long math operation let's say one plus two plus three plus four plus five and this could go on forever and you want to break this up and for that you would use forward slash and then on the next line you can continue writing the line as you would normally do meaning i could add a plus 6 plus 7 plus 8 and so on if i now print a and run this we are getting a proper result keeping your code readable is a priority that you want to keep in mind and the forward slash is really useful for that but right with that we have all of the basics covered in this section we are going to cover data types and this is going to be an incredibly important part because understanding data types is one of the most fundamental things you have to understand about programming python does have quite a few different data types we have actually seen some already the one that we have used the most is words which is just a string it really is just a fancy word that programmers use we are just talking about words besides that we have also used different kind of numbers we have seen integers and we have seen floating point numbers the only difference between the two is that floating point numbers has decimal points whereas integers are always full numbers the reason why that is is quite technical and you don't have to worry about it you can work with them very very easily and they are basically interchangeable from your point of view there are only very rare exceptions where that is not the case and those exceptions you probably are not going to come across unless again to some very specific topics besides that there's one more data type that we have seen as well and that is a boolean and boolean data types can only ever have two values they are either true or false and in the context where we have seen them is some kind of math operation for example 10 is greater than 5 was true these boolean values you are going to work quite a lot later with to organize the flow of your code for example you might only want to run some code if a certain condition is true besides those four data types python has quite a few more some are more important some are less important but there are four that you absolutely have to know and let's start with the easiest one a list this is basically just a container to store other data types for example in this list right now we have three values we have one and two and both of those are integers and besides that we have a string which is just a word you could also store boolean or floating point numbers and you could even store a list inside of another list python really is flexible here besides that we have tuples we have sets and we have dictionaries and all four of those data types are just there to store other values the difference between them is that they are storing data slightly differently a list and a tuple differ because a list can be changed whereas a tuple cannot be changed a set would be different because every value inside of it has to be unique and there are a lot of ways to compare different sets to filter out data and finally a dictionary is a much more organized way to store your data in here we always have a name and then a data type i am going to go through all of those in detail throughout this section and then we are going to go in quite some detail into all of them besides those there are also some data types that are much less common i will cover those at the end of this section they really aren't that important but you do want to be aware of where they appear and why they matter but generally python is incredibly relaxed about different data types most of the time you are actually not even going to notice for example if you have an integer and a floating point number for example this could be 1 plus 1.2 and python here would automatically convert these two numbers into a floating point number with 2.2 you have essentially combined different data types but because python is so flexible about it you didn't even notice which is one of the main reasons why integers and floating point numbers especially for beginners are basically identical and you never have to worry about them on top of that python also has a ton of functionality to change different data types i'm going to cover that very soon as well let's get started by talking about integers and floats or well just numbers and i just covered them but just as a recap we are creating numbers either with integers or with floating point numbers and again the only difference between the two is decimal points for floating point numbers and integers are always full numbers again the difference is because of how computers work but you really don't have to worry about it the most important thing for you is that all math operators work just as normal meaning if you add an integer and a floating point number you are getting a floating point number let's have a look at some examples and a really useful function to understand what data type you're working with is called type if i write type and then add an integer so a one in here python is going to tell me what data type i am working with and again we have to print the result so we can see something if i run the code now we're getting class and integer what a class is you're going to learn much later in this series but the important thing for now is the integer this is the kind of data type we are working with if i change this 1 to a 1.1 then we are getting a float or a floating point value which means you are working with different data types you could also add a string in here so a word let's say a word that is horrible spelling but you get the idea and we have sdr for string let's stick to a1 actually we don't need to type at all anymore instead what we can look at is the conversion between different data types and for numbers this is all automatic and here i could just type 1 plus 1 plus 1 and we get 2.1 since this does have a decimal point we have a floating point value although if you didn't know this specifically you would never notice although i guess sometimes this can be slightly weird we have actually seen this very early on in this entire series if you divide any number by another number let's say 10 divided by 5 i am going to get a floating point number even though i wouldn't necessarily need it and this always happens in python you can't really get around it but that is basically all you have to know about numbers in python in terms of data types python here is really flexible and makes all of this very easy which does make it much easier than most other programming languages i guess one thing we can cover as well is let me add this on the next line you can use functions to convert different data types for example let me print something again and i have a integer let's say 2 and i really want to convert this integer into a floating point number one way of doing this is to add 0.0 to it if i run this now we get 2.0 although this isn't exactly elegant so we're not going to use it a better way would be to use a function that is called float and float converts any kind of integer into a floating point value if i run this now we're getting the same result you can see it's a float because we have a decimal this would also work the other way around let me put this on the next line if i print a number like let's use something else 5.1 if i want to convert this 5.1 into an integer i could use the int function or int for integer if i run this i am only getting 5 because remember integers are always 4 numbers we do not have values after decimal so we are losing some data also keep in mind when you are using int you are not rounding the operation you are doing is truncating and truncating means we are getting rid of anything after the decimal point which means if i had 5.9 and run all of this again we are still getting 5. if you wanted to round you would use round and then you were getting 6. it would also return an integer because again we don't have any decimal point now there's one thing that you do want to be really careful about and that is that floating point numbers sometimes can get really weird especially if you combine integers and floating point numbers for example if i print 1.1 times 3 what we would be expecting here is 3.3 however if i run the code we are getting something really weird three point three and then zero a lot and then a three at the end technically this result is wrong it resulted because floating point numbers are kind of weird in computers now that being said in most cases this error here makes absolutely no difference because it's such a small deviation you are never going to notice it but do keep it in mind you generally want to avoid floating point numbers because they can add some arithmetic errors once in a while generally integers are much easier and much cleaner to work with but obviously sometimes you just have to use floating point numbers and then you can just use them they work just fine in basically all circumstances the next data type i want to talk about are strings and this is the one we have seen a lot by now all we're talking here are words and this is something we do have to talk quite a lot about because we are going to use them extensively strings are created either with single or with double quotation marks you could either write word with single quotation marks this one and this one or you could use double quotation marks this one and this one python really doesn't care the only limitation is that you have to stick to the same kind of quotation mark you couldn't add a single quotation mark and then end with a double quotation mark and strings have a ton of methods to manipulate them i guess some examples we have seen are upper is numeric and strip what we haven't seen yet is you can also use strings with math operations for example if you add hello plus world you are combining these two strings we are going to explore that functionality a bit more in this section besides that you can also add values into strings in quite a few different ways the most important concept here that you have to understand are f strings you will see in a second what that means it's basically another kind of method and finally we can also cover how to write over multiple lines and how to add quotation marks inside of a string and that's a ton of stuff to cover so let's have a look at all of this let's start by creating some test variable and in here to create a string we can either use single quotation marks or double quotation marks i guess let's start with single quotation marks let's call it test 1 and then for test variable 2 we can have double quotation marks with test 2. if i run the code now all of this is going to work just fine as a matter of fact if i print testvar1 and testvar2 both of them are going to give the same result python does not care if we use double or single quotation marks the one thing python does care about is that we do not mix quotation marks meaning something like this wouldn't work if i run it we are getting a syntax error undetermined string literal i think the reason here should be quite obvious it would be very strange what i also want to do starting from well now is to comment my code so it's going to be a bit easier to read when you read through it and this section here is about quotes for strings along with that there's one important thing that we do have to cover and that is quotes inside of strings what that means let me create another test variable let's call it testvar3 and let's do an example let's say i have the case that he said and then i want other quotation marks this was great and let me add a bit of white space here so this is easier to understand we are using quotation marks here and here and that way we are creating a string inside of this string though we have another quote and you can already see by the colors here python is not exactly happy about it if i run out of this we are getting an error invalid syntax python just doesn't know what to make of it as far as python is concerned we are starting a string here and we are ending the string here then we are adding some random words and then we are creating another string the reason now where python is confused is because these three words are neither variables nor inbuilt functions so python just doesn't know what to do with them and it gives us an error so how can we get around it and there are two ways of doing this the first one that you are probably going to use the most is to mix the quotation marks now we have single quotation marks to create a string and inside of the string we have double quotation marks to explain that we have a quote this python is completely fine with let me print it actually testvar free if i run this now we are getting he said this was great python has no problem with that and let me remove the white space that should make all of this a bit easier to read while we add it i also want to comment out this stuff here at the top so things are a bit easier to see now if i run this we can see we have quotes inside of a string this would also work the other way around if i start with double quotation marks and end with double quotation marks then inside of here i can add single quotation marks like this run it again and we would also see the result now we have single quotation marks this would be one way to approach this although this system has its limitation for example if i add a test var4 and in here we want to have for whatever reason a single quotation mark a double quotation mark and then a single quotation mark as well and this would just not work python would just get very confused not exactly something you would do all the time but it might come up once every year and then you have a problem to overcome this you need what is called an escape character let me add a comment and escape character an escape character is again a forward slash and this you need in front of every character you want python to just interpret as a string and this you need in front of every character you want python to interpret as a normal character so in my case i want this escape character in front of my double quotation mark and my single quotation mark and now you can see the comment appears as a proper comment if i print it i can see the two quotation marks this way you can literally add any kind of character without disturbing your code as a matter of fact let me rename this to simple escape character because escaped characters can do quite a bit which means i want to add another comment for escape characters what we can do in here let me comment out the earlier part and now i want to have a test var five and for this one i want to print some text over multiple lines let's say i want to have line 1 some text and then i want to have line 2 some more text and i want to tell python that this should be over multiple lines of code for example if you want to build some kind of text editor you want to store all of the text inside of one string but when you present a string you want to have line breaks between them how could you do that i guess let me print the test bar first if i run this we get all of this on one line and to create a line break in here we need once again the forward slash and then the letter n if i run this now we are getting those two lines on well different lines forward slash n tells python that we want to add a line break between these two different parts of the string there are actually quite a few more for example forward slash t is adding a tab inside of your string there's also forward slash r this one adds another kind of line break you don't really have to know the difference here for your purposes work essentially the same forward slash n though is the most common one so that way you can write text over multiple lines besides that let me add multiple lines as a comment here there's another way to write multiple lines and this is one way we have actually already seen what you need here are triple quotation marks something that python by default considers a comment however if you assign this comment here to a variable let's call this one test var six all of a sudden it changes the color and it becomes a string and this string is kind of special because for this one python does respect the white space which means now i can press space end up on another physical line write some more text do the same thing again and then write on another line if i print this test var 6 python is going to preserve all of the line breaks for example what we could be doing in here let me actually copy it that should save some time i could copy something like this in here if i run this now we have the tree we created in one of the very first section of this entire series and this is a much easier way to see what's going on although granted because of the first line here this is a bit difficult to understand but with all of this covered we have quite a bit more understanding about strings now there are two more things that i do want to cover the first one is math and strings and before we start that let me comment out the earlier stuff so it doesn't get confusing what you can do let's call this testvar7 you can add something like one string hello and then plus a world and python when it sees this plus it is just going to combine these two strings if i print test bar 7 now we are getting hello world keep in mind here there's no space between the two because neither hello nor world have any white space one way to add them would be to just add them here and then combine all of these with another plus you can add as many pluses here as you want there's no limit on it this would also work with different types of quotation marks python literally does not care another math operation that we can use let me create a test var eight i can let me write a word like copy i can multiply it for example times ten if i now print the result i get the word copy copied ten times but again i think this concept here should be fairly straightforward let me comment it out and now we come to the most important section of this entire video and that is how to get values into strings and let's do this by example i have a name and in here i have bob and i have an h and let's go i don't know 40. now i want to create another let's call it a greeting string and this greeting string i want to say hello bob you are 40 years old let me add the print statement as well so we can see what's going on i want to have the greeting string and let's run this i can see hello bob you are 40 years old right now the two values are matching we have bob here and bob here and we have 40 here and 40 here but this is only the case because i have written bob if i change this bob to tom and run all of this again we wouldn't see a difference so what i want to do is to somehow get this name variable into here and this h variable into here and python has quite a few ways of achieving that the one people tend to learn first is called format this is just another method this one works by adding curly brackets inside of your string where you want to add a variable in my case i want to replace the name with a curly bracket and the age with another curly bracket and now i can add values into this format this could for example be a one and a two if i run all of this now i can see hello one you are two years old what python has done here is it looked at the first curly brackets and then it looked inside of format and found the first value after that it saw another curly bracket and looked for the second value inside of format and then inserted it into the string granted just adding one and two in this example isn't particularly helpful but what we can do is add variables in here as well like name and age if i run this now we get hello tom you are 40 years old and this now means we can change these variables let's say a hundred and something it really doesn't matter what it is although you do have to be careful about the order if i switch them around with h coming first and then name now we have hello100 you are something years old the order here being wrong messed all of this up which can be kind of annoying especially if you have longer strings where you want to add more variables this can become very confusing and as a consequence python has a way to make all of this more organized you can inside of the curly brackets add something like variable names let me call them one and two and now you can assign one to name and two to the age if i run this now we are getting the same outcome although now we know very specifically which value is being assigned to which curly bracket one gets this one here and two is getting this value here meaning now we're going to sign h to 1 and i guess we could keep h for 2 as well if i run this now we get hello 100 you are 100 years old the reason is we are assigning h to both 1 and 2 which is putting this age into here and into here and that way you can be much more deliberate about where you put the variables that being said very few people use this kind of method because when you look at it it's kind of inefficient why do we have to add a whole method with arguments why couldn't we just add variables straight inside of these curly brackets that would be much better and python developers agree and to achieve that they have created what is called an f string let me create another variable let's call it greeting string better for this one i want to copy this entire string and paste it in here and now i'm going to add the variables i want straight into the curly brackets we have name for hello and h4 years old although now if i print greeting strings better i am getting hello name you are 8 years old python interprets this and this as a simple part of the string which isn't ideal to tell python that these are supposed to be variables we have to add an f at the beginning of the string and that is all we need if i run this now we're getting hello something you are 100 years old and you can see it by the colors the name and the age are not green anymore which in our case means they are not a string anymore although your colors may vary depending on what color scheme you have we can let me return to bob who is 40 years old this is still going to work and this version here is much more readable than this one up here i guess let me fix it this is better but still this one here is very annoying to read whereas this one is really clear and f strings can actually do quite a bit more inside of these curly brackets you could even do basic math operations for example we could add h plus 10 all of this would also still work with that we have covered a lot of stuff for strings and i think this part is getting quite long so let's do an exercise and then finish it off and what i want you guys to do is this one here i want you guys to create an f string that says hello my name is x and my hobby is y x and y should both be separate variables and the second half of the sentence should be on a separate line and by second half i mean and my hobby is y this should be on a separate line when it is being printed pause the video now and try this one yourself let me comment out all of this here so we're not getting confused and now let's go for this step by step first of all i want to start by creating an f string here let me copy it and let's call this the exercise string in here i want hello my name is x my hobby is y since we want x and y to be in separate variables x should be in curly brackets and y should also be in curly brackets and since we want python to interpret these as variables we need an f at the beginning of the string so now we have to tell python the values for x and y let me put x here and y here let's say for x a value we haven't used yet is lisa and i like i don't know programming with that i can print the exercise string and we have hello my name is lisa my hobby is programming this is already covering the first two parts of the exercise next up is the second half of the sentence should be on a separate line and this we could approach in two different ways the first one is we could use an escape character meaning forward slash n and now if i run this we get hello my name is lisa and my hobby is programming on two different lines another way of approaching this let me copy it you could use triple quotation marks so i add two at the beginning and two more at the end now i get rid of the line break and put all of this on separate lines i guess let me call this exercise string two and now print two and we're getting the same result these two lines here and this line here both do practically the same thing although i guess this one is a bit more readable well i guess it's debatable you could choose here whichever you like although be aware the first one is much more common also keep in mind here the variable naming i used capital x and capital y is quite bad this should rather be called name and hobby in this part we are going to learn two more data types lists and tuples both are very similar and both are simply data containers for other data types which means they are storing other kinds of data that's what a container does and they can contain any kind of data this could be a string a number it could also be a boolean other lists and tuple and a lot more there's no limitation on what they can store a tuple would look something like this we are starting with normal brackets and we're also ending with normal brackets and inside of that we have values that are being separated by a comma for example in this case we are starting with an integer and then we're adding a comma then we have a string another comma then we have a boolean value another comma and then we have a tuple inside of this original tuple which python is totally fine with and inside of this tuple we have another string and that is the only value for this tuple so it really doesn't make too much sense i just wanted to illustrate that you can do it besides a tuple we have a list and a list is looking very similar the only difference now is that to create a list we need square brackets but other than that we are still adding values inside like integers strings booleans and other lists and we are separating each value with a comma like here here and here on the surface those two would look identical and you would be kind of correct the two are very similar but there's one incredibly important difference tuples are what is called immutable which just means that they cannot be changed for example you could use something like list append and this would work because list can be changed but a tuple and depending a value would not work because we cannot change a tuple under any circumstance if you really wanted to add a new value to a tuple you would have to create a whole new tuple and combine the old values with a new value which you can do fairly easily but if you are going to do that you could just use a list it would be much easier that being said because of this immutability tuples process a tiny bit faster in python although the difference is so small you are hardly ever going to notice i guess let's have a look at all of this and see how far we get let's get started by creating some lists and a list let me store it in the variable again you are always creating with square brackets and in here you're adding values that are separated by a comma for example you could be adding numbers like 1 2 and 3 you could add floating point values like 4.5 and you could be adding words like let's say word those are the data types we have already seen but any data type would be valid in here now if i print my list we can see the output we have entered into this list it does work pretty seamlessly what you can also do is to use the functions we have already seen for example len is now going to give us the amount of items we have inside of this list which right now is 5. finally you could also use the list with methods and lists do have quite a lot of methods i suppose a simple one would be clear this one removes every value from the list meaning if i print my list after running this method i am getting 5 items from this line here and this line now is going to print an empty list i suppose if you want to look this up in google all you would have to do is look for something like python list methods once again you are going to find a lot of different websites that talk about it the official python documentation this one here is probably the one you want to use and in here let me hide this one we have append extend insert remove and a lot more the one we have just seen was called clear this one is removing all items from a list and it is equivalent to something else what this part here means we are actually going to learn in a couple of minutes it's super useful for now just keep in mind there are a lot of different methods in here that you could be using another easy one would be reverse this one reverses the list let's have a look at this one i suppose we could change clear to reverse and now if i run the code we are getting the entire list in the reverse order compared to this list here just like with words or well with strings the main way you are going to learn the different methods is by just using python and encountering different problems and finding the solutions to them and most of the time the solution is going to involve some kind of method at some point you are going to get used to different methods for a list that being said also you don't need to know all of them by hard i myself completely forgot about reverse until i saw it when i prepared for this video but well with that we have lists and i guess we have functions and we have methods at least in a very basic outline although there's one really important method that i do want to talk about and that one is called append and this one appends a value i think the name makes sense here basically anything you add in here as an argument will be added at the end of the list for example if i added let's say it 10 at the end run all of this now we can see all the way at the end we have this 10. this would be one of the ways you add an item to a list there are quite a few more but this is a really basic one that i just want to cover for now with that we can look at the other kind of container and that is called a tuple and the tuple you let me save it in a variable that i called my tuple you would be creating with brackets and in here again you can add any kind of value you want could be a number could be a floating point number it could be a word or it could be a list as well that itself contains other values let's say 7 8 and 9. let me comment out the earlier stuff and print my tuple and there we go now we can see all the values we have added in here a tuple and a list work in very similar ways at least up to a point because there is a major difference that difference being that tuples cannot be changed under any circumstances this means i couldn't run something like my tuple append and then let's use a 10 again the method we have used up here if i run this line of code we're getting an error that tuple object has no attribute append we also couldn't delete a value and we couldn't reverse the order of this tuple let me demonstrate the reverse one this one here this one also would not work on a tuple most of the time when you are using tuples you generally only want to use tuples when you know you are not going to change the values but most of the time let's say 70 80 you are going to use a list this one is the much more common data type because it is more flexible with that covered we have to cover a really important topic and that is how to pick elements from a tuple or a list what that means is for example i might want to get this floating point value here from the list and then work with it so how could i get this value and for that we need a specific process that in python is called either indexing or slicing the two are very much related let's talk about it actually let me actually go for this a bit more properly to restate the problem we want to pick one element from a list this could also be a tuple they both work in exactly the same way for us to do that we need to cover two important concepts the first one is that python assigns each value in a list on a tuple and index number if this is our list python would give each of these numbers an index the first number is always going to be a zero and then every successive number is going to be plus one of that number meaning the second value is one the third value is two and then so on and a really important point to notice here is that we always start counting from zero not one and this can be a very annoying concept to deal with i think for beginners forgetting about this covers about half of all of your errors just be ready for that but anyway the concept we have for now is that every item inside of a list has an index and this index we can use to pick an element and this works by adding square brackets after the list or tuple in practice this would look something like this right now we have our list and then after the list we have another set of square brackets with an integer and this integer is going to pick one specific index right now the index one which is going to be the second element this one here meaning this operation would return the value 2 and since we are using an index this entire operation is called indexing it works on quite a few data types lists and tuples should be fairly obvious we could also be using it with strings because they are basically another kind of container we can have a look at this one as well however indexing does not work on dictionaries and sets dictionaries work in a slightly different way and sets work in a very different way we are going to see that later on and i guess let's play around with all of this here i am back in my code and i want to comment out the two methods for the tuple and i want to uncomment my list meaning now i have a list and a tuple to work with and i want to just pick some random elements from them i guess we can start with my list and in here i am using square brackets and now i need an integer i'm going to pick 0 just to pick the first element this zero now is going to refer to the first element inside of my list or the one with the index zero if we added a one we will get the next element two three four and so on to show all of this we have to print it again now if i run this we are getting one indeed the value up here if i added it 2 in here and run this again we are getting the integer 3 which is this item here we have 0 1 and 2. all of this would also work with a tuple meaning if i use my tuple this tuple here and now pick let's say the item number 5. run this again we are now getting the list this one here at the end of the tuple because this one is the element with the index five we have zero one two three four and five what we can do now as well is to add another square brackets afterwards because remember what we are getting from this one here is going to return one item from this tuple in this case this list here which means that this operation here stands in for this tuple so when we add the square brackets afterwards these ones here we are basically adding the square brackets after here and then we can take other elements from that if i add a zero in here we should be getting seven my tuple five gets us this list here and then the zero gets us the first element inside of it these operations are fairly common right now i assume they do seem quite confusing but if you play around with them for a while they should become fairly familiar just remember what is getting returned and how you can work with that there's one more thing that you could be doing in here let me duplicate the line i only want to use one indexing operation what you can also do is go in the negative direction for example if i use negative one we are getting the list again what this negative one means is we are always starting at zero and if we go in the positive direction we are basically going to the right however if we are choosing a negative number we are going all the way to the back of the list and then going in the opposite direction meaning this list here would be negative 1 word would be negative 2 and the 1.45 would be negative 3 which means that negative 3 and 4 should have the same result unless i made an error let's try if i enter negative 3 we get 1.45 if i add 4 we are getting word and i just realized i can't count um sorry about that this should be a 3 and this is a 4. talking and writing can be kind of challenging i guess you noticed this one already but now what you should be able to see is if i add a 3 in here we are getting 1.45 and if i add a negative 3 we are also getting 1.45 all right with that we have basically all we need to get started with indexing this is a very simple operation when it comes down to it although this video is getting kind of long so let's do an exercise and then we finish this section and what i want you guys to do let me paste it in here's the exercise we have a long string and of the string i want you guys to pick one word or string and that is hello that is going to be this element here although do notice here that this is a list inside of a list inside of another list so you have to pick elements that are quite a bit nested but if you paid attention so far this should be doable so pause the video now and try this one yourself alrighty let's get started and just to illustrate what is happening here let me save all of this in a separate variable that i'm going to call solution var and this is going to be we always have to start with the exercise list now we need square brackets and we want to pick one item from here with the index we have item number zero we have item number one and we have item number two and item number one covers this entire list here this is what we want meaning in here i want item number one which means if i print the solution variable and comment out all of the stuff above and run all of this now we can see we have the list with one two three four five and then the other list inside and from this we want to get another index now we have let me clean this one up a tiny bit purely inside of this list here we have a few more elements we have 0 we have 1 and then we have 2 2 being this entire thing this is all we want right now which means we now want the index number 2. now if i print my solution i get another list with zero and hello we are getting very close now inside of this final list this list alone here we have two entries we have zero and we have 1 and 1 is our solution which means at the end of this i want to add a 1 and then we should be done so let's try and there we go we get hello obviously you would very rarely see something like this this is very poor data management because it's a very messy list that is really hard to work with but i guess it's a very good exercise this video is going to be part 2 on lists and tuples and this is primarily going to be about picking multiple elements so the main problem we have to cover is how to pick multiple elements from a list let's say we have a list with the numbers one two four and we want to get the second and the third element how could we do that right now we can only pick a single element fortunately python can do this with something that is very similar compared to indexing and that is slicing how this works is you are still going to need square brackets like with indexing but now instead of adding one number you are adding two numbers separated by a colon the first number is the start and the second number is the end value for example it could look something like this for example in here we have the indexes from zero to three one right now is going to refer to this two here and 2 is going to refer to the index number 2 which right now is going to be a 3. this is how we are picking the start and the end value however there is going to be a really important concept you have to understand and that is python only goes up to the end but it does not include it which means in this case we would only get one number we would be starting on this 2 here that is our start value however we are only going up to index number two we are not including it so in practice our list indexing ends here right before our end index as a consequence this operation here is only going to return this two and nothing else that is going to be a fairly common issue but you will get used to it let's practice this one once again here i have a completely empty python file and i want to create a test list and that is the list we have just seen this one has the values one two three and four and just to demonstrate what i've just talked about i want to print my test list and in here i want the values from 1 colon 2. if i now run this i am getting another list with 2. that means that list slicing always returns a list even if there's only a single value inside for example what we could even do is go from index 1 to index 1 which would get us if i run this an empty list and this is something you always have to keep in mind if you want in this case for example the second and the third element you have to go to the index after that in this case this is going to be one two three if i run this now we are getting the numbers 2 and 3. and that for start is all you have to know about slicing although you can do quite a bit more but let's talk about this inside of my slides besides the start and the end value you can also add a third number for the direction by default this one is going to be zero meaning we are always moving plus one in the positive direction it might look something like this we again have the same list and we have our indexes 0 1 2 and 3. and this one here at the end means that we are moving in the positive direction in a step size of 1 which right now will get us the next element but we could have a larger or smaller value you could also have negative values to go into the other direction here we are back in the code and i want to add a few more values to this list so it's a bit easier to visualize what's happening now we have the values from 1 to 10. although if i run this one here it is going to give us the same result but now let's say i want to have the values from 0 to 8. if i run this we are getting the first eight values although now what i can do i can add another set of colons and then for example add a two in here and now if i run this i am only getting every second value so we are starting at the index number zero and we are only ever picking every second value which is the three the five and then the seven and since our last index is going to be here we're not including this 9 anymore and then we're getting the values 1 3 5 and 7 the values down here and this step size can also be negative for example you could in here add a negative one although right now this wouldn't do very much so the issue here is we are starting at this value as our starting point and our end value is eight which i believe is this value here and since we are now moving in this direction there simply isn't any value so this entire operation doesn't give us anything however what we can do is flip those two around so our start value is 8 and our n value is 0. if i now run out of this we get all of these values reversed and negative values you can add actually everywhere in here so for example you could have the start value of negative one and the end value let's say at four this is going to work just like normal indexing this would mean you are starting here all the way at the end that is the negative one and then we're going to the fourth element which is going to be zero one two three and four this one here is index number four so we are expecting to get the numbers from ten to six let's see if that's the case and it is we get numbers from 10 to 6 and that is basically all you have to understand about the basics here although there's one more thing that you can do and that is you can also leave values entirely empty when using slicing this might look something like this this does look a bit strange but it does work what it means is let me talk through it every number in the slicing operation has a default value so we have a start and end and a step value for start the default value is always the very first item inside of the list in the example here it would be a 1. the end value by default is always going to be the last item inside of the list in this case here that would be a 4 and for the step size the default value is a 1 which means we are always moving plus one in the positive direction by default this one should make sense it's quite straightforward and let's play around with all of that let's see how far we get so here we are back in the code and let me actually add all of this inside of a variable let's call it negative slicing i should probably add more variables so it's easier to follow in the notes but let's start working on leaving values empty this i want to save in a variable let me call it default slicing in here as always i need my test list and in here i want to go from my start to the end of the list and i only want to get every second value now the start is going to be easy because this one is always going to be one but you could also leave it completely empty it would have the same result and here we could also leave empty that would get us the very last item inside of a list 10 right now and this is actually really useful because by default we don't know what the last index is going to be finally i want to have every second element this would be a 2 in here and now let me print the default slicing variable let's run this and we're only getting every second value we could also add every third value in here and there we go if you left all three of them empty and run this again you will get all of the numbers so this is looking a bit strange but it certainly is working and this system can be incredibly useful as a consequence let's do an exercise and what i want you guys to do is this exercise here i want you guys to start from 8 and go to 2 and only pick every second element and when i say 8 and 2 i mean actual number not indexes so you want to start at this 8 here and then go to this to here at the end these are the values you are going to cover except only every second element meaning the 7 shouldn't be in here this 5 shouldn't be in here and so on so pause the video now and try to figure this one out let me save all of this inside of a variable and as always we need the test list in here we need square brackets for slicing and now we need a start an end and a step size since we do have to go negative remember we are starting from 8 and we are going to 2 this has to be a negative number let's say negative 1 now just to have a start value while i do this let me show the solution right now what we are going to get is the entire list in reverse although in my case i don't want to start at 10 i want to start at 8 meaning we have to figure out how we can get this 8 here that would be our start value and one mistake you could be making in here is simply add an 8 because this would not work right now we are starting at 9. the problem here is remember when we're using indexing we are starting at zero meaning this is zero one two three four five six seven eight and nine meaning if we are adding the index eight we are adding on the nine here which isn't helpful instead what we could do is add a 7 in here and now if i run this again we are starting at 8. alternatively what you could also do is add a negative 3 in here if i run this one we are also starting at 8. and i guess remember we could also go negatively so this 9 would be negative 1 then we have negative 2 and negative 3 that would be our 7. both would be fine it's really up to you what you prefer i guess the 7 here is a bit more expressive but well it's basically subjective but now we have to find the end value and in here you might be very tempted to pick one for the index let me actually do that if i add a one in here run this again we are ending on three as our final element the reason is that python always only goes up to the final element but it doesn't include it as a consequence three is going to be our final element the way around that one is this should be a zero now our final element is this zero so we're going up to that element but we're not including it so two is our final number the final thing we need is we only want to pick every second element this is quite easy all we need is a negative two if i now run out of this again we get eight six four and two and with that we are done this is basically all you need for slicing and this would also work for a tuple i guess let me demonstrate this one really quick let's call it tuple slicing and then here we have a test pupil and this one would just have the values one two three four five six seven 8 9 and 10 and in here i could for example print test pupil with the values 0 5 and let's say 3 it should be a colon and let me comment out the exercise here and there we go we get 1 and 4. once again a list and a tuple are incredibly similar the only difference is is that a list can be modified whereas a tuple cannot there is one more topic that i want to cover with lists and tuples and that is unpacking basically what that means is both lists and tuples can be unpacked in a way like this we have a and b and we are assigning a tuple to them what this is doing we are taking the first value and assigning it to the first variable a and 10 in this case and the second value gets assigned to the second value and that way you are unpacking a tuple on two variables this would also work with a list you would have the exact same result and let's have a look at all of this in code so for example what we can do i have a variable called a and a variable called b and i want to assign them to the values 10 and 5 inside of a list and this is well all we need if i now print a and print b we are getting an n5 we have unpacked this tuple on these two variables although keep in mind this only works if you have the same number of items as you have variables if for example i added a third item to this tuple let's say a 1. if i run this now we're getting an error that we have too many values to unpack and python expected 2 which we don't have but if you have the same number of variables as you have in the tuple you are good to go and this would also work inside of a list but let me add two more variables let's say c and d and now we have a list with i know 20 and this also works with strings let's say hello if i now print c and i print d we are getting 20 and hello and this you can also make more powerful because when you are creating a tuple you don't actually need brackets for example you can have a list like this or you could create a list like this without the brackets just having values separated by a comma automatically creates a tuple although most of the time when you want to create a tuple it makes more sense to write the brackets because it's clearer what you are doing but you don't actually have to do it now where all of this becomes really interesting is when you combine these two approaches because by doing that you can assign multiple values to multiple variables on a single line of code which is super powerful for example we have the variables a b and c and we are assigning the values 1 hello and 4.5 we have assigned values to three variables inside of a single line of code so let's have a look at this one in practice and then we can do an exercise for example for video game you could have health you could have energy and you could have a weapon and this you could all assign inside of a single line for the health we could have 100 for the energy we could have 50 and for the weapon we could have a sword and now i could print weapon for example and all the way at the end we are getting sword and i hope you see the value of this if you have to assign multiple variables this is really really useful to keep your code a bit more organized and all right this video is going to be a bit shorter we can do the exercise right away and what i want you guys to do is this we have a variable 1 with the value 10 and variable 2 with the value test and i want you guys to switch the values of these two variables meaning value 1 should have the value test and value 2 should have the value 10. so pause the video now and try to figure this one out alright the solution here is actually incredibly simple all you have to do is you want to assign value 1 and value 2 and what you want to assign them to is value 2 and value 1. basically what we're doing now is for value 2 we are assigning it to value 1 and value 1 gets assigned to value 2. this is basically how you would switch around different values across different variables meaning now if i print value one let me run this we are getting test the value the value that used to be in the second variable before we're getting to the next section i want to do a short intermission and this one is strings lists and tuples because those are surprisingly similar all three of them are basically just containers they just happen to have different formats and as a consequence you can move between them very easily and also use indexing on strings let me demonstrate all of this actually i already have two variables a test string and a test list i suppose we can start by turning a string into a list or a tubal the two are very similar we don't really have to worry about the difference here and to convert a string to a list or tuple you have a couple of different ways the first one we can use to test string and then use the method split and this one splits the string at a certain point if you don't specify anything in here and print a result we are using a space to separate the values if you enter a value in here let's say a t and run this again we now separate this wherever we have a t we start at the beginning here and the t in there disappears meaning now in the string this t disappears and we have an empty string at the beginning of the list then we have all of this stuff here up to the next t which is his is a and then a space then we have the next t here and this one then gets us to the next point the e s bit this one here and then finally we have another t and this one disappears and we are just left with an empty string most of the time you are just going to use the space here this one does make a whole lot more sense another thing you could do is to use the list function and this one turns any kind of data type into some kind of list or at least it tries to it doesn't work with every data type but a string definitely does work if i run this we are now turning every single character into one element inside of a list this would also work with a tuple this is another function here we can add test string once again and now we have the same thing except now it's a tuple instead of a list the other way also works just fine we can turn a list or a tuple into a string although the process here can be a bit weird basically what you would be doing is you first get a string and right now i'm going to leave it empty intentionally then i need a dot and then i need a specific method and this method is called join and into this method as an argument i have to pass in some kind of list and as an argument here we are going to need a list or a tuple although it has to be a special kind of tuple because this one has to contain some kind of string let's say one and two just to keep it simple and now for run this these two elements here have been merged together what we are specifying inside of the string is going to be what determines the gap between the two right now it's empty so there's no gap between 1 and 2. i guess i could just add the gap in here if i run this now we get one gap two if we added more values in here let's say three and four we would always have a gap between each of these values most of the time you are just going to leave it empty and now you have one space between the values what you really have to be careful here though is that all of these values have to be a string i guess let me copy it and replace this with the test list we have up here if i run this now we are getting an error that python has a type error sequence item 0 expected is string instance in found which is python's way of saying it wanted a word or a string but it found a number and it's really not happy about it finally what you can do is to let me print it again you can use the str function and pass in a list in here to turn this list into a string if i run this now we are getting what looks like a list but this is actually a word or a string to demonstrate this let me put all of this inside of the type function if i run this now we get class string this one here is going to be a string it just looks like a list but i hope you get the idea one more thing really quick and that is indexing on strings this one works like it would work for a list for example i could have my test string and in here i want the first element which right now should be a t if i print all of this i am indeed getting a t just like with a list in the string the first element is going to be 0 then we have 1 2 3 and so on you could even use slicing here and for example at the 5 and now we're getting this the first word and i think it is quite valuable here to compare these two data types because when you think about words they really are just containers for individual characters and for python it made a lot of sense to make these interchangeable with a list or a tuple because well it does make kind of sense one of the major operations you are going to do as a programmer is to work between different data types so understanding how you can change one data type to another data type is a really valuable experience but okay there's one exercise i do want you guys to do and that is going to be connected to this operation here let me copy it and add an exercise here at the end what i want you guys to do on this string test list i want you guys to use string methods to remove all of the stuff so you only get one two three and four let me comment out all of the other parts to see what we get right now we're getting square brackets then 1 comma 2 comma 3 comma 4 and square brackets again and i only want to have 1 2 3 and 4. try to use some methods to get rid of all of the other values besides the numbers and see how far you get to make this a bit easier let me save the result in a separate variable let's call it exercise this is also what i want to print right now we have to get rid of a couple of different things let's start with the square brackets for those we need the method we have already seen much earlier called strip and this one we want to start with one of the square brackets doesn't really matter which one you start with if i run this now we got rid of one square bracket and remember we can combine different methods meaning i can call strip again and now add the other square brackets the closing one we now have all the numbers and the commas in between them and to get rid of the commas we want to replace them meaning i want to target my comma and then replace it with an empty string so nothing now if we run this we are only getting the numbers 1 2 3 and 4 and we are done if you wanted to you could even get rid of the spaces here as well and this you would achieve with another replace method and now i want to target the empty space and replace this with nothing now if i run this we have all of the numbers right next to each other whichever you prefer at this point this is hopefully at least manageable the next important data type is a dictionary and this one is a more complex container but still just a container for other variables this one always has a key and a value pair the example 4 that i have is this one in here we have a key and we have a value the key right now is an integer the one but it could also be any other data type python is fairly flexible here and then we have a value this one here a list but again it could also be any other data type what you ultimately have to understand about dictionaries is that they are a container but a more organized one where every value has a key associated and you would use the key to access the value that way you wouldn't go by indexing you would instead have specific values we're going to cover that in more detail later on but let's start playing around with that let me start by creating a test dictionary and a dictionary you always create with curly brackets and inside of the curly brackets you need a key then a colon and then a value both of those have to be valid python data types for example for the key let me call it capital a and the value could just be an integer let's say one two three this would now be one key value pair if you want to add a second one you would add a comma and then the second key value pair let's say i want to call this one b and now i need a colon again and for the value now i want a list with the values i guess one two and three again i guess let me print this one so we can see the result if i run this we can see we have a dictionary with two key value pairs right now the key is always a string but this doesn't have to be the case you could also use a number like 1 and then give it the value of i guess we haven't used the boolean yet so i can just add true in here if i now run this we get another key value pair the one limitation you do want to be aware of here is you cannot duplicate keys for example if i added another a with i don't know let's say another value and if i now run this this first value has disappeared the reason being that once we add the same key we are overwriting the original key value pair although most of the time that really isn't an issue you are too concerned about and once again you also have a ton of methods you could be using for dictionaries to go through all of them here is w3schools with a list of all of the methods you have available some that you are going to use fairly often are values keys and items this one here because those return specific parts of the dictionary let's play around with a couple actually right now if i run this we are getting the entire dictionary but if i add another method here and add values don't forget the brackets run this again now i am getting some kind of list looking thing with just the values from this dictionary keep in mind this is a different kind of data type if i put this into the type function run this again we're getting class dictionary values this is a completely separate data type in and of itself although you don't have to worry about it too much there are specific use cases for it and they all work basically automatically and you never think about the data type here the other method would be keys and this one gives you all of the keys again in the dig keys data type finally what we could also be looking at is items and this one is going to return the list but now it has two builds inside and those we could also access we are going to learn how this works later on and if you go for the list of the different methods this one should be fairly straightforward besides that you can also use once again the lan method is incredibly versatile in here we can add the test dictionary and we would get three meaning we have three key value pairs inside of this dictionary we have one two and three and that's kind of it for the basics of a dictionary it really isn't that complicated i guess let me add a comment here at the top for basics of a dictionary one topic i do want to cover really quick is converting a dictionary for example what we could be doing i guess let me print the results straight away i could get my test dictionary and convert it to a list for example if i run this we are now getting an actual list with all of the keys meaning the list contains a b and 1. something you really want to keep in mind when you are converting the data type here tuple would result in the very same outcome i guess finally you could also convert all of this to a string and then you would get the entire dictionary as a string probably not the most useful thing you could do but well you can do it i do want to cover one more important thing and that is indexing with dictionaries and here we have a problem because indexing the way we have learned it so far does not work and i think this makes sense if you have a dictionary like that and you want to add some kind of indexing operation at the end let's say with the number zero this to python would be kind of confusing this could for python mean you want to have the first item inside of the index or it could mean you are supposed to look for a key with the value 0. in this dictionary this doesn't exist but python doesn't know it when it sees this number here as a consequence the normal indexing does not work but there is another way actually there are two other ways you would do something like this instead of an integer you would add the name of the key in this case we have square brackets with an a and the a refers to this key here what is then being returned is the value associated with the key which is the one another way of doing this is the method get this one works in the same way you are passing in a key this key looks for a specific key value pair in the dictionary and we are getting the value associated returned back in my code i want to print test dictionary and now i want to get the value for capital a if i run this now we get 1 2 3 which is the value we have gotten all the way up here along the same lines instead of using square brackets you could use the method get and in here pass in the key you are looking for and you will get the value associated with it one two three again you may be wondering now what is the difference between these two approaches and generally get is slightly better because if you're looking for a key that doesn't exist let's say x in this case if you use square brackets you are going to get an error meaning your entire code is going to crash which usually is not a good sign but if you use the get method you don't get an error instead you get none returned which means let me add comments doesn't crash when it cannot find a key and i guess the comment here would be does crash when it doesn't find the key or e besides that the two approaches are pretty much identical and with that we have covered all of the basic things for this part so let's do an exercise what i want you guys to do is to do some research and look up the update method for a dictionary and via this method add another key value pair to this dictionary once again i am on a website that looks at all of the different methods that we could be using with a dictionary and the one we want to look for right now is called update if i click on it we have an example a definition syntax and quite a few different things that we could be doing usually what i'm looking at is the example in here we have one dictionary and then we're using the update method and we are passing in as an argument in another dictionary and this dictionary has a key and a value pair and this is going to insert all of this into the other dictionary so let's have a look at this i want to get my test dictionary and i want to use the update method and what we have seen so far is to insert another dictionary and in here we can just add some values let's say i want another key that's not how you spell that then a colon and then some other values i guess what we haven't used yet is a tuple with i don't know some other values in here if i run this we're not going to see any difference because we are not printing our new dictionary meaning now if i print my task dictionary i can now see another key and one two three at the end although you could be using this method in another way as well let me get rid of the argument we had so far and what you could be doing as well is specify some kind of name for a key in my case c and then specify a value let's say let me call it test if i run this now we get a string c and then test as another value and you could even add multiple values in here let's say d is going to be i know one two three it doesn't really matter and with that we have well another value i suppose while we are here there's one more way to add a value inside of a dictionary or a key value pair to be more specific and that is by using test dictionary and then using brackets and specifying a new key here this is very similar to using the key here except now we are creating a whole new key value pair a value we haven't used yet would be e and now you can just assign a new value to it let's say a hundred if i now run this we have all the way at the end the key e with the value 100 the thing we have specified here and that is basically all you have to know about dictionaries it really is a fairly simple data type but one that gives a lot of order to your code the final major data type is a set and these are also simple containers just like the other containers we have seen but this one is kind of different and special in some way it would look like this we still have curly brackets like in the dictionary at the start and at the end and inside we have values separated by a comma so far all of this is really straightforward the only difference compared to dictionary is we don't have keys we just have values where a set becomes unique is that every single value inside of a set has to be unique and any kind of duplicate will be deleted once more i have a completely empty python file and i want to create a variable let's call it my set and here i need curly brackets and inside of those i want to have some values i want to have separated by commas once i have that i can print this variable run the code and we can see we have some kind of set you know it's a set because we have values surrounded by curly brackets without any kind of keys if they had keys it would be a dictionary the one crucial thing you have to understand is that if i have a duplicate value in here let's say i have two fours if i run this again the second four is going to disappear because every value in here has to be unique and python is going to get rid of any value that is duplicated let's say duplicate values will be exterminated all right but other than that we can do quite a few normal things with a set for example we could print the len of my set that is not a bracket let's run this now and we know this set has a length of 4 because we have 4 elements inside of it because we get rid of the duplicate values what you can also do is to use methods and sets do have quite a few one that is fairly popular is you can add another value and in here you just add as an argument the value you want to add and if you run out of this now we have a 5 added at the end of the set along the same lines you can also remove a value and let's say i want to remove the 2 in here if i run this now we don't have a 2 in the set anymore for the full list of all the methods you have available let's use a different website this time i'm using a website called geeksforgeeks this one is also quite good for python and i do want you guys to get used to looking at different websites they all do very similar things but slightly different so it is a really good idea to understand different ones all i really did was i typed python set methods into google and there we have w3schools we have programmers we have geeks for geeks and we have the python documentation these are the four that usually come up in google that tell you all you need to know about specific parts of python in here if you scroll down you have a whole list of all the methods you could be using the one you have just seen was add and this one adds another value and in here well you have a lot of different stuff you can work with and the list really isn't that long it should be fairly easy to work with now there's one thing that is quite limiting for sets and that is that indexing and slicing does not work i guess let me put these two print statements at the top and now i want to print my set and then the one with the index 0. if i run this we are getting an error and the type error we are getting is set object is not subscriptable which is a pythonic way of saying that you cannot use indexing for a set as a matter of fact there actually isn't a really easy way to pick one element from a set the one that gets closest to it is to use the pop method let me comment this one out and instead i want to have my set and then use the pop method if i run the code now we are getting a 1 or the first item inside of the set however what this one is doing if i print this set after this operation the one has now disappeared the reason being that this pop takes the first item from the set returns it and then removes it from the set if you call this multiple times at some point your set is going to run out of items which again very often is not what you want to do sets are not designed for indexing or generate to pick items from them the actual use case is something entirely different i'll cover that in a second but first of all we could actually do a really interesting exercise just in the middle of this and the exercise i want you guys to try is to use type conversion to get one item from the set by index basically what that means is you should try to convert this set into another data type and then on this data type get the index the main thing i want you guys to take away from this is that you can very easily change the data type of something in python and then use different methods or different operations so see if you can figure this one out we know that we cannot take the index of a set this one just doesn't work however what we can do is get the index of a list so what i can do is convert my set to a list and then from this list i want to take the index meaning if i run this now this one is going to work i get the first index i could get the index at one or any other index this is now going to be a list that we can work with if i remove the indexing and show the entire thing that we are getting is well it's just a list that came from the set and this is also nondestructible we are just doing this for this one print statement outside of it the set is going to remain a set we are not changing the entire variable just for this one line we are changing the data type for a very specific purpose which is what you are going to do very often as a programmer meaning this is something you definitely want to get used to and that way you would select different values from a set although that really isn't the idea of a set but i guess let's talk about what the actual purpose of a set is in python and what they are supposed to do is being used for comparison operators sets are incredibly good at that there are a lot of ways to check if two sets have values in common or if they have different values for example what we could be doing is set one and check if there's a union with a set two and that way we are getting all of the shared elements another way we'll be looking at the intersection between two elements and now we only get the values that are present in both data sets there are actually quite a few more let's go through a couple of them let me add another comment for another section and let's call this comparison operators and in here to keep things a bit cleaner i want to have two more sets set one and set two that do share some values and everything else i want to comment out so we are not going to get confused what you can do for example the one we have seen already i can print set 1 and then union and set 2. if i run this now we essentially merged these two sets i suppose an operation that is a bit easier to see in terms of what's going on is the intersection method if i run this one we are now only getting 4 because 4 is the only value that is shared with set 1 and set 2. any other value disappears because they are not shared by the two sets a really good way to think about it is to use venn diagrams this one is set one this one is set to and let me draw two circles and set two would be the other circle what intersection is doing this one here is it only finds the shared values between the two union got all of the values and the third operation we could go we can have set one and the one here is difference again i want to check with set two and this looks like a typo difference this fits better let's run this now and there we go now we only get the values one two and three these three here we are getting this area here now where we only get the values that are not present in set 2 which specifically here means that 4 is disappearing and those are the main comparison operators that being said there are a few more there's a different way to use these methods and those are going to look slightly weird for the union instead of writing union we could do set one then i think this is called a pipe operator and then set two let me comment out the other two lines so we're not getting confused if i run this now we get the exact same outcome along the same lines in this section we could replace with the and character so set one and set two if i run these two i am getting four we are only getting the values shared by both sets and finally difference we could access with set one minus set two and if i run this we are again getting the same values this one may look weird but it actually makes a lot of sense we are basically taking set one and we are subtracting all of the values from set 2. if they exist they are going to remove the value for in this case if they don't we're just going to ignore them now that being said these operators or sets in general you are not going to see all that often they are very rarely used list tuples and dictionaries are the really common one and sets you only really use when you do some more data oriented stuff all right now with that we are nearly done i just want you guys to do an exercise and for the exercise i have a long list i'm not even sure how many numbers are in here but there are a lot and what i want you guys to do is to use a set to figure out if this list has duplicate values try to figure this one out yourself it's a really common operation that is incredibly useful i have added a comment to explain what the exercise is going to be but it actually isn't all that difficult the function you want to use here is len and right now if i pass the list in here i know we have 34 items in there in total let me comment out the earlier stuff so we're not getting confused we have 34 items inside of this list how we can use this is we know if we are creating a set so i want to create a set from this test list since a set cannot have any duplicate values if the length of this set is shorter than the length of this original list then we know there are going to be duplicates inside of this list which means if i run the lan method on this run both we are getting 26 which means we have quite a few duplicate values in the original list if you want to do this a bit more fancy you could also do i guess let me put this on a separate line you could print len of the test list then the comparison operator i don't think we have seen this one yet but this checks if two values are equal to each other and then we have len of the set of the test list and if i run this now we are getting false and if this is false we know there are duplicate values with that we have all the important stuff for a set although keep in mind sets are fairly rare in python you would only really use them when you run something that requires a lot of data work like running a database or doing data analysis for anything else like making a gui or making games they really aren't used that often so don't worry too much about them for now when you actually need them you can learn about them in more detail the next incredibly important data type is a boolean all a boolean is is either true or false and usually we are creating booleans with comparison operators for example if we are running something like 5 smaller than 10 we are getting the boolean value true and this is incredibly useful to control the flow of our code something we are going to talk about a lot in the next section for example if a condition is true then you want to do something and booleans can be created in a lot of different ways the one way we have seen already is we're using either integers or floats and then we use comparison operators we can also use some string methods like is num to check if there's a number inside of a string i think we have seen is alpha to check if there are only letters inside of a string another way is we can check if there are values inside of a list instead of tuples or a set or a dictionary this would also work we could also compare different sets to create booleans and finally we can also create booleans by themselves although that's something you really aren't going to do too often i guess let's go through this entire list and we're going to start with comparison operators and there are quite a few the one we have just used in the last part is the equal sign so we are checking if two values are equal with two equal signs and we are using two because a single equal sign is reserved to assign a data type to a variable meaning we couldn't use it and to check if two numbers are not equal we have the exclamation mark equal and that checks if two numbers are different and finally we have smaller or smaller equal to check if something is smaller than or smaller or equal than and greater and greater equal would work in the same way those are the main comparison operators in my code let me start by printing and i want to print if 1 is equal to 1. if i run this we are getting true if i use a different number let's say 10 run out of this again i am getting false because 1 is different from 10 this should be quite obvious the next operator would be exclamation mark equal and let me add comments is not equal whereas the double equal sign looks for is equal if i run those two we get false and true false here because those two are not equal and we get true from this operation because they are indeed different i suppose a better way of writing the comment here would be true if is equal or is not equal or besides not equal is different we can also print if 1 is smaller than 10 and this one gives us the obvious result because 1 is indeed smaller than 10 and we could also use smaller or equal than and this one in this case would also be true i guess where this one matters if we have a 10 smaller equal here is going to be true but 10 is not going to be smaller than 10 meaning this operation would return false this also works with greater than again this would be false because 10 is not greater than 10. and those are all the major comparison operators for integers for the next part we could look at lists and booleans and in here we can check if a value is in a list or if a value is not in the list and this by the way also works with strings an important point here is that not reverses a boolean if we have not false it is going to be true if we have not true it is going to be false python here works very similar compared to what you would use in a sentence and i am trying to be better with comments let's do this booleans and numbers i think it's a good name here next up we have booleans and lists and strings what you could do for example here is you could check if one is in the list one two and three if i run this we're getting true because one is indeed in the list of one two and three let me comment out this part here so we're not getting confused and run this again now we are only getting true and this is also going to work with different data types if i for example had a tuple and run this again we would have the very same outcome if i duplicate all of this i can also check if e is in the word hello and run this again and we will be getting true again because e is indeed in the word hello finally what you can also do is to use the not operator for example you could be checking if 4 is not in the list of 1 2 and 3. if i run this one now we're getting true again because 4 is indeed not in this list generally not reverses all of these operations i could for example uncomment this print 10 is greater than 10 and this one let me keep it the only one without a comment if i just had this one line by default this one is going to be false but if i put a not in front of it and run this again we are now getting true not reverses any kind of boolean so if you have not true you are going to get false you can actually do this by itself let me add another comment and let's call it booleans by themselves and comment out everything else what you could do you could just create a boolean by just writing true or false if you wanted to and this one would get you true which is its own data type and if you write not true you would get false this i think is going to make sense and i guess while we are here we can do another data conversion exercise so data conversion exercise and what i want you guys to do here are the notes i have an e and this one contains three key value pairs it's always the integer of a number and then the word of the number as well although honestly it really doesn't matter what the specific value here is and i want you guys to do two things number one check if one of these keys exists specifically if this key one exists just assume you don't know what's inside of the dictionary and you want to check if this key exists in the first place and number two i want you guys to check if the value not the key the value for exists inside of the dictionary and again assume you don't know the actual content of the dictionary so try to figure out these two problems the first problem i guess let me put it right below is the easier one we want to check for a specific key and in here we can use the same thing we have used up here it works in the same way i can just check if one exists inside of the edictionary and let me comment out this print statement down here so we're not getting confused if i run this now we're getting true because we can see it right here this one does exist inside of the dictionary as a key if you want to be more specific about it you could also use the method dot keys and you would get the same result this edict.keys would now return something that looks like a list with only the keys inside of it although this is what you get by default anyway so you don't really have to use it the second part is we want to check if the value 4 is in the e dictionary although this right now is not going to work because this edict is checking for keys not for values which wouldn't help us all that much to access the values we would need the values method the one we learned about earlier and now we're getting something that is basically a list and it only contains all of the values of the dictionary if i run this now we're getting false because we know this 4 does not exist as a value inside of this e dictionary although if we had a 3 this one would be true so we know it is working all right with that there's one more really important topic i want to cover and that is the bool function let's talk about this one bool is a function that creates a boolean data type and this one can accept basically any kind of other data type it's really flexible here we could pass a number a string any type of container and we would still get a value as a matter of fact bool accepts so many different values that are actually different rules that determine how the values are going to be converted and just think about the problem here you have some really complex data set let's say a really long word and you pass this into the boolean function to ever get true or false how is python going to determine what values count is true and what values count as false and the logic here is actually so common that python has dedicated words for it we have the words truthy and fault c truffy means all the values that will be converted to true and false c is all the values that will be converted to false the way you have to think about it is that some values will always be converted to false and those are fairly specific and anything else will always be true and faulty values are 0 or 0.0 so integers or floats that have the value 0 any positive or negative number will become true any kind of empty string so a string without any content not even a space any kind of empty list tuple set or dictionary is also going to become false and finally none so the absence of a value and literally any other value is going to become true meaning you don't actually have to learn that much now this is something we definitely want to play around with so let's have a look at all of this in code let me comment out all of the stuff we have written earlier so things are not getting confusing right the bull function is another function that creates a boolean data type and i do want to print the result we could for example add in a number any kind of number and we will get true what python basically does is it looks at a number and then determines if the value is truthy or falsey if it is truthy we get true if it is falsy we're getting false and what i talked about just now is that any number besides zero will be true this one here indeed has become true this would also work with negative numbers let's say negative one is also true the only time a number becomes false is when you have zero this one is false or 0.0 this one is also false as soon as you have any other value besides zero let's say zero point a lot of zeros and one you are getting true again but if you have any floating point with just zeros it is going to be false and this was the first rule besides that for strings if you have any kind of word even if it's just a space it is going to be true however if you have an empty string this one is going to be false finally if you have an empty list this one is also going to be false but if you have any kind of value inside it is going to be true the way you want to think about it is that if any kind of data type has an actual value then it is going to be converted to true if it doesn't have any content it is going to be false there's one more data type we haven't really covered yet in detail and that is the absence of a value so none and this by itself is also data type in python and this one obviously is also going to become false i think this one makes sense we are actually going to talk about this in just a second in a bit more detail but it's not something you have to worry about too much but well with that we have boolean data types that's kind of all you need to know and in the next section we are going to use this a lot more before we are finishing off this entire section i want to cover some other data types because python does have a lot what we have seen so far is that python is really flexible with data types sometimes data is even converted automatically like with integers and floating point numbers but other than that we also have functions to change data types and this is the entire list for the major data types you would most of the time actually need and these are very forgiving python here again is super flexible now besides those we do have a couple of data types you see once in a while but not very often or in other words data types you don't specifically use the most common one here is none or the absence of a value this could for example happen if a certain kind of value got deleted or if you didn't get value from some kind of input field but besides that we also have a sequence like a range of numbers bytes complex numbers memory view frozen sets lots of really specific data types that you sometimes see in very specific circumstances you usually have to look them up and they are very rare so i am not going to cover them i will however cover later on none and sequence those you do see reasonably often but values like bytes complex numbers memory view frozen sets you would only ever use in highly specific circumstances and i'm not going to cover them because we don't really need them almost the entire time you are going to be perfectly happy with these data types here and they are what i am going to focus on so right with that we can come to the next major section and welcome back in this section we are going to work with the flow of our code now what does that mean basically so far we always executed code from the start to the finish meaning if these are different lines of code we are starting all the way at the top and we are going down line by line which works fine by itself but it is fairly limiting because sometimes we want to do something else for example we might only want to run code if a certain condition is true or we might want to run code multiple times or we might want to run code for every item inside of a list or a tuple or something like that and all of these things can be done quite easily python has a lot of ways to control the flow of your code although to understand how it is going to work we need to understand one really important concept and that is how python groups chunks of code together you're going to see in a second why that is important but the way python groups code together is by using indentation let's say we only want to run some code if the condition is true and this white line here is the left side of our code editor just to better illustrate how we are using indentation the basic problem we have now is if we have code below this condition how do we tell python that it belongs to the condition and isn't something that's independent of the condition for that we need indentation anything that is indented by one indentation after this line belongs to this if condition meaning these three lines here all belong to this if condition i think i actually added a bit more text here yeah there we go indentation determines where the code belongs to if we added some other code in here like line three and line four those would be independent of each other they would run no matter what happens whereas line 1 line 2 and line 3 would only run if this condition is true if it was false then none of this would be run but line 4 and line 5 would still run meaning lines that are not indented do not belong to that if statement i hope this makes sense once you understand the system it makes a lot of sense and indentations indentations in general and python are incredibly important you are going to see them all the time but first of all once we understand indentation there are four major ways to determine the flow of the code the first one is if l if and else these are different kind of if conditions to run code if certain conditions are true we are going to talk about this one in the next part besides that we have match this one is kind of like if but it's more designed for specific value to find one very specific condition then we have while and this one just repeats code as long as the certain condition is true and finally we have four and this one is about running some code for every item inside of a container let's say you have a list with one two and three and you want to run some code for every item inside of the list a for loop for that would be perfect and those are the four major concepts that we are going to learn there are also a few more extra tools you can use like breaking a certain kind of statement or skipping to a next part in a while loop i will talk about those at the appropriate point so i guess with that let's start with the first major part possibly the most important concept to determine the flow of your code is the if statement all this one does is it tells python to only run some code if a certain condition is true note here we are always looking for a boolean value they are crucial to make all of this work and an if statement can also be extended with l if and else and you can also add different conditions together we're gonna cover all of this in quite a bit more detail over the next two videos let's have a look at all of this in code let's do a super quick recap of boolean values all i really do is if i have something like 10 is greater than 5 i print it i'm getting true because this condition is indeed true and if i do the other way around that 10 is smaller than 5 this would get me false because this condition is not correct and these boolean values we can now use to control the flow of our code for example we could run some code if a value in a variable is greater than let's say 10. for that let me first of all create a variable let me call it x and let's start with five and now i want to run some code only if this value is greater than 10. and for that i would need the word if and then the condition i want to check which in my case is x is greater than 10. after that i need a colon and now if i press enter sublime is very intelligent here and already creates one level of indentation so we are here if i write some code and this is really important let me write some code here actually let's say print the if statement was true because of this indentation we know that this print statement belongs to this if statement here if i execute all of this we can see nothing the reason why we can't see anything is that this condition here was not true 5 is not greater than 10 but if i change this 5 to a 15 run all of this again now we can see this print statement here the main thing that you have to understand here is this condition if it becomes true then we are running all the indented parts below the if statement and if it is false we're not running any of the indented parts this would also work over multiple lines of code i could for example print another line if i run this again we get another line as well i could also create another variable in here let me call it y is equal to 10 and i could print y all of this works just fine we can write any kind of code in here as long as it's indented it always belongs to this if statement however if i write now some other line of code after the if statement that is not indented let me call it some other code this one is always going to run regardless of what the if statement does because it's not indented if i run the entire code right now we can see some other code the line we get here and if i return x back to 5 run this again we now can still see some other code because this line is not affected by the if statement because again of the indentation indentation is really important to python you absolutely have to understand it although that being said this is the core part of an if statement it really isn't that complex although you can extend the logic here in two different ways a very easy one would be an else statement this one again is going to need a colon and now if i press enter again we have another indentation and in here i can write the code that was run if the statement was false how does this work basically this else statement always has to be connected to an if statement and what it does is if this condition here is false then we are not running any of this but we are running anything inside of the else statement since x is 5 this condition is going to be false meaning none of this will run but this one here should be run and this line is going to run no matter what happens so if i run the code i should be seeing the output of this line and of this line let's try it and there indeed we can see these two lines and there's one more thing that you can do and that is called an l if statement and again this elf statement has to be connected to an if statement basically what it means is shorthand for else if it's kind of similar to the else statement except now we are adding a condition which means if this condition here is false then we want to run this statement here but we only want to run this one if another condition is true and this condition is just going to be another boolean value let's say i want to check x again and i want to check if x is different from 0. if that is the case i once more need some indented code and for this one let me print the l if statement was correct and now we have a much more complex if statement we first check if this condition here is true which in our case right now is going to be false because 5 is smaller than 10 meaning this would be a false statement then we are coming to the al if statement and now we are checking if let me use a different color if x is different from zero and since five is different from zero this one is going to be true as a consequence we are going to run or expect this code here to be run let me add it properly here so we can see what's inside of the line and once any of these lf statement has run we are stopping this if statement meaning this else statement here would not be run at all and once again this print statement here is going to be happy either way because it does not care what happens in this entire thing let's try all of this now and we can see the al if statement was correct which is this line here and then we have some other code this bit here i suppose we could be doing another example and now let me add a zero in here and i would really recommend you to go over this one yourself and see which line you would expect to run here once again we are starting at the first line and we know 0 greater than 10 is going to be false that can never be true next up we are looking at x being different from 0 which in this case is also going to be false which means at the end we are left with this else statement which means the code we are expecting is the code that was run in the if statement was false and we're also expecting this one at the end although that's getting repetitive let me run the code now and we get the code that was run if the if statement was false and some other code with that we have all the basics for an if statement if you understand if l if and else you already understand what you need i guess one more thing that i haven't covered yet is if and else can only occur once inside of this if statement but l if you can multiply as many times as you want for example i could add x is greater than negative 20 for example and then add something else i know print something else and you could add as many if statements as you want or as you need but else and if can only occur once although what you could be doing is add another if statement afterwards i guess we could add if one in the list one two and three and then we want to print another if statement when i said an if statement or an else statement can only occur once i was always referring to this block here where we are starting with an if and inside of that we can only have one else we couldn't have a second else however python is totally happy to have a completely separate if statement but with that we can do an exercise and what i want you guys to do is this one here we have one variable that determines how much money we have and from this amount of money i want you guys to figure out what we are going to eat if we have greater or equal than 80 units of money i want you guys to print eat something fancy if the money is greater than 45 eat something nice if it is greater than 15 eat something okay and else eat something cheap and obviously there should only ever be one print statement running at any point in time so pause the video now and try this one yourself before we start i want to comment out all of this because it would otherwise get kind of confusing first of all we need an if statement and now i want to check the money available and i want to work on the first line here and what we are being asked to do is greater or equal than 80 which we get with greater or equal and we want to check for 80. if you want a reminder on boolean values check out the last section on boolean data types this is going to be really important for this entire section but in here i now need a colon and now i want to print eat something fancy i guess let's add an exclamation mark because why not the really important part here this print statement has to be indented but with that we have covered the first line of the exercise next up we want to check if the money is greater than 45 which means we want to first check if the money is greater than 80 but if that is not the case and the money is still greater than 45 we want to do something else which means we need an l if statement else because we want something else in the if statement and if because we have another condition what i want to check in here if the money available is greater than 45 after that again i need a colon i need an indented line and now i want to print eat something nice and with that we have covered this line here next up we have a very similar line meaning now we again need l if and what i want to check now if the money available is greater than 15. if that is the case this is getting a bit repetitive i want to print it something okay that covers this line and finally we have an else statement that if all of these conditions are false we want to do something else anything else we want to do is to print eat something cheap and there we go this is going to cover all of the four if statements if i run this now we get each something fancy because the first if statement this one here is true however if i change this 100 to let's say 50 we get eat something nice if i change it to 20 we get eat something okay and if i change it to 5 we get eat something cheap and with that we have basic if statements now that we have learned about basic if statements we can work on the more complex ones because if statements can be extended number one is you can combine different conditions inside of one if statement on the same line and number two is you can nest one if statement inside of another if statement which lets you create really complex systems that check different values let's start with combining conditions and in here the two keywords we need are and and or kind of confusing to say but you get the idea how this would look like is we have if 5 is smaller than 1 and e in hello or 10 is different from 4. this may look confusing but let's go through it one by one to understand how this works we have to understand and and or and means that all the parts have to be true meaning when we are talking about this and here this bit in particular both of these conditions five is more than one and e and hello have to be true individually for this entire statement here to return true as a whole whereas or works in the opposite way where only one or a statement has to be true which means if this or statement here is true then it wouldn't matter if all of this is false because as long as one or statement is true then the entire if statement is going to return true as a whole and this is probably going to sound very confusing so let's do this a bit more practically let's do this actually in the simplest possible way let's say i have if true and i want to print true this if statement here really doesn't make too much sense but to illustrate the point it's really useful but since we're adding the boolean value true in this if statement this is always going to run meaning if i execute the code we are getting true and now what we can do is use and in here and if i add false now and run this again nothing is going to happen this line will not be executed because of and both the first one this one here and the second one have to be true for this entire condition to be true as a whole which there aren't right now but if it was true then this would run again the way you have to think about and is i'm only going to run this if statement if this is true and this is true and anything else is true and if any single statement is false then the entire thing is not going to be run i hope that makes sense it does take some time to get used to it let me go back to false and the other word we can use is or now we want to run this line of code if this is true or this is true meaning if either of these is true then the entire if statement is going to run if i run this now this is going to be true because for or only one of them has to be true and once you get so far you can combine and and or for example what i can do is true and true and true or true now this would obviously return true as a whole because we only have true values in here but now if i set this to false this would still run and the reason is let me add a bit of white space around it so i have more space to draw on i am assuming that this is kind of confusing right now still python essentially combines all of the n statements into one block inside of the if statement and this entire block can either be true or false for and every single value has to be true and if a single value is false then the entire thing is going to be false in our case since there is one fault statement the entire block here is going to be false once we have that python is looking at the or statement this bit here and as a consequence of this we now have false from all of the and statements and then we are checking false or true and if either of these are true then the entire if statement is going to be true which in this case it is just to make sure let's do one exercise for this one already and what i want you guys to do is here we have three variables and the exercise is going to be fairly similar compared to what we have done in the last video what you should be working on is another if statement that checks if the money available is greater than 80 and if you are hungry if those two conditions are true print eat something fancy or whatever you want however this should also run if board is true and for that to work you have to combine end and or statements so pause the video now and try to figure this one out to get started i need an if statement once again and now i want to check if money available is greater than 80. this covers this first bit on top of that i also want to check the end if hungry is equal to true with that i have covered this entire bit now that i have that i can print eat something fancy if i run this now this is going to return eat something fancy let me comment out this stuff at the top so we're not getting confused eat something fancy if i change hungry to false run this again we are not getting anything the simple reason being that both of these statements have to be true because of the end statement here if either of these is false then the entire thing is going to return false which it does right now so none of this is going to be run however now what we can do is use an or statement as well to cover the last bit or if bored and now i want to check our board equals to true as well if we run all of this now we get eat something fancy and what happened here is python first checks the two statements connected by and and it sees that money available is 100 which indeed is greater than 80 meaning this part here is going to be true but then for hungary equals true it looks at the hungry variable and this one is false meaning this one is going to return false as a consequence the entire bit here is going to give us a big false the difference now is we are also checking this or statement which means we want to check if anything in here is true or if this condition is true which it actually is right now and as a consequence the entire thing combined is going to return true consequence being we are going to run this line of code and i hope this makes sense using these and or keywords can be a bit confusing definitely play around with this in your own time if you're struggling that being said most of the time you are going to keep this fairly simple you usually only have a single and statement in here and then you are good to go don't overthink this the other way to make if statements more complex is by nesting them and let me do an example we could have an if statement if a is inside of the list a and b right now this one would be true but inside of this we can add another if statement that is indented by one line and inside of that we could even add another if statement and this system we could continue forever as long as we keep on adding more indentation levels let's have a look at this one in a bit more detail i'm going to comment out the stuff we have done earlier i guess i could organize it a tiny bit better there we go and now i will look at nested if statements and to keep comments a bit more consistent let me add one for the first part let's call it combining conditions the example we have just seen is we want to check if the letter a is in the list a and b if that is the case i let's say i want to print a is in the list executing the code is going to print this line this one should be fairly straightforward and again remember we are on one level of indentation on this line of indentation though we could add another if statement we could for example check if a and then use the method then i need a colon again and now i need another indentation line or another level of indentation and then here let me print it is a letter if i run this now i get a is in the list and it is a letter now this example really doesn't make too much sense but we can make it quite a bit more interesting for example what you could be doing is create a variable and in this right now i want to have let's say the string a and now i want to check if x is inside of this list and i want to check x is alpha if i run this again we are going to get the same result we essentially just replaced the string a with a variable that contains the same string but once we have that i could add another string in here that contains a 1 which is not in the alphabet so if i check this one here what i expect now to happen is that this is still going to be inside of the list so this entire condition should be true as a consequence this print statement should run however the number one even if it's inside of a string is not in the alphabet so this condition should not be true and if i run this we can indeed only see this line here was run but this was false and as a consequence this line here was not executed if you wanted to you could even add another level of indentation i don't know let me just add true so we always execute it and inside of that you could keep on adding more if statements there's absolutely no limitation on how many if statements you can add the only thing you really have to consider here is that each if statement has to be on a separate level of indentation at the very least if you want them to be part of the other if statement if you added an if statement here let me get rid of this one you would check those two individually the way you want to think about it is that each if statement is one block of code this if statement here is one block inside of this if statement we have one block for this if statement and another block for this if statement and these two here are independent of each other but they both depend on this if statement to run if this if statement does not run neither of those will run just to have something in here let me print something and let me add some purple white space so this looks a bit cleaner all right with that we can do another exercise and then finish this part what i want you guys to do let me copy it from up here i want you guys to check these three conditions but now instead of using this system here i want you guys to create a nested if statement and if all three conditions are true so you have enough money you are hungry and you are bored then i want you guys to print eat something fancy or really whatever you want it doesn't matter that much let me actually uncomment them and add a comment for the exercise and now pause the video and do this one yourself let's start with money available is greater than 80. that's the one we have already used and i guess while we are here i can also print something to check on what if statement we are for this one i want to print i have enough money after that i want to check the next if statement and i just want to check if hungary is equal to true and if that the case i can print and i am hungry inside of that i want to check if board is equal to true and if that the case i want to print the final thing eat something fancy before i run it i do want to comment out this part here so we keep things a bit cleaner if i run this now we only get up to i have enough money this line here we are not getting to if hungry because hungry is false if i said this hungry too true we get let me expand this a tiny bit i have enough money i am hungry and eat something fancy all three conditions here are true and with that we have if statements obviously you could also add else statements in here if you really wanted to and make this even more complex now there's one more thing that i want to cover really quick writing something like this is a bit redundant all you really need is hungry by itself if i run this it would still work what happens here is that python looks at the hungry variable and the value for hungry is true meaning this if statement here is essentially if true and keeping like this is much more readable if a value is truthy you could just add it in here and then python would take care of the rest for you but being more explicit about it would also still work perfectly fine but alright with that we have if statements covered in this part we're going to cover the match case statement and this one is kind of similar to an if statement the major difference is you still run some code if a certain condition is true but match case is more designed to check for one specific value out of a long list of possible values that probably doesn't mean too much let's do an example let's say you want to check the mood of something if you used an if statement it might look something like this we have if hungry you want to run some code and else if you're tired or bored you want to run some other code all of this would be just fine but it also feels kind of inefficient having one l if statement for each mood seems kind of annoying to write every single time and as a consequence python has a slightly different way to approach this kind of case and this is a match case you would use the match keyboard and then you would look at the variable in this case i am looking at the mood and then you can specify different kinds of cases for example case for hungary and if that is the case we have colons again and we are running some code inside of it and then we can check for different cases and run some code for all the different possibilities it is very very similar to an if statement if you compare the two match case is actually a tiny bit longer if that makes a difference to you although the main thing you want to look at here is readability all of these l if statements here eventually get kind of annoying to read whereas case this case that gets much better and is a much easier way to check the value of this mood both approaches here would be perfectly fine though as a matter of fact match case is a reasonably recent addition to python which is the reason why very few people actually use it most of the time you are going to see some kind of if statement which is still perfectly fine but in some cases match is the more appropriate way to go on but well let's have a look at all of this in code once again i have a completely empty python file and i want to create a new variable let's call it mood and right now my mood is going to be hungry if that is the case i want to run some code what we have seen so far you could use an if statement if mood is equal to hungry then let me print get some food or something like that running this will get me indeed get some food this one is working just as intended the difference now is if we have lots of options here for our mood we could be hungry bored thirsty tired and whatever else you want for each of these conditions we would have to add another l if statement to check for all of the possibilities which does eventually get kind of cumbersome to write and because of that we have match and then we want to look at the variable mood in my case now you need a colon and if i press enter we are again indented by one line and now i have to specify a case that could be one scenario for this mood for example the case could be hungry if i add a color now and press enter we are once again on a separate line and now i can print get some food if i run all of this we are again back to get some food this result here is basically a simple if statement the difference now is that we can specify other cases for example a case first d and then let me copy this one get some water i could specify a case for tired and continue like this forever there really isn't any limitation how many cases you can have let me just write it out get some sleep with that established i can now change the variable and get different outcomes i suppose there's one more thing that you could include here and that would be case underscore still needs a colon and now you can print in here any other mood because an underscore is run when none of the other cases are correct for example right now if i write in here something like board a case we haven't accounted for yet if i run this we get any other mood if python doesn't find any of these it is going to run the underscore one and with that we have match case covered and i am fully aware this is about as efficient as an ifelse statement it really isn't that much of a difference match case really is not something you absolutely have to use if you want to stick to if else statements this would also be perfectly fine but all right let's do an exercise what i want you guys to do is this one here create a variable with an integer between 1 and 5 and this should be a great a grade you could be getting at school and then create a match case statement for all of the values that this grade could have one would be very good and five would be very bad and print something like this for each of these cases and i mean all of them from one to five also don't forget to include some default behavior if you get the value you didn't expect like a 10 for example pause the video now and try this one yourself let's get started and i want to comment out all of this and then we can start by creating the great variable and let's start with number one i want to start by writing my match and what i want to look for is the great variable then i need a double colon and now on an indented line i want to check for one case and the case right now could be a one now i need a colon again and once again on an indented line i want to print very good i can now run this and we get very good indeed with that we have one case now we can do case 2 print let's say still good case 3 would be print ok case 4 would then be print needs improvement and finally case five i want to print very bad i think i said yeah very bad up here and this would already be a working match case statement i can run this again we get very good the same we had earlier let's say if i use a 3 we get ok and if i use 5 we get very bad the one thing we haven't done yet is if i have a 7 a value we don't have accounted for nothing is running in here i guess i haven't specifically mentioned that but if the match case doesn't find a value it just doesn't run we do not get an error message just keep that in mind it's a specific behavior of it all right but i want to add case underscore for all the other values i haven't accounted for and for this one i can print let's say great not recognized if i run this now we get great not recognized this would also work with i don't know something else python doesn't really care what the value here is all right with that we have match case something fairly similar to an if else statement but it could be useful in very specific scenarios a really important concept in python is the while loop and this one is actually quite simple all it does is it repeats some code as long as the condition is true for example this could look like while true i want to print an infinite loop this infinite loop here would run forever unless we manually break the code not exactly the most realistic scenario but something we could be doing i suppose something slightly more realistic would be something like this we are starting with x being 0. then we are checking if x keeps on being smaller than 10 and inside of this while loop we want to print a certain thing and we are also going to increase the value of x on this line here this condition now is only going to run 10 times and this is how often we are going to print this loop here and with that we have some basic theory out of the way let's actually have a look at all of this in code i guess we can start with the examples i just talked about we always start with the while keyword once we have that we need some kind of boolean statement this could either be true or false although if you have false this while loop is not going to run it will only run if the value is true if that is the case in here you can print i think i called it infinite loop if i run this now we get an infinite loop that keeps on running forever it's not particularly exciting but it definitely does work the way you would exit this one is by just pressing escape and it would stop although you really want to be careful with while loops it can not crash your code but it can make your code not work anymore let's say if you have some kind of game and you end up in a while loop that you can't escape from anymore your game might just stop because your computer is stuck in this while loop and it doesn't continue from it let me get rid of this one and let's do something a bit more reasonable instead i want to create a variable x and by default this one is going to be 0. and now i want to check while x is smaller than i want to print x look at this code if i run it what do you think is going to happen what we get is if i run this we have a whole bunch of zeros that keep on running forever and the reason here should be fairly clear this boolean condition x smaller than 10 is always going to be true because x is always zero and we are never changing it the consequence being that this print statement is going to run forever it is never going to stop to overcome that we would have to do something like x plus equals 1. and now if i run this we get the values from 0 to 9. i suppose what you could also be doing is combine this with an if statement for example if x is equal to 5 and this has to be indented really important to tell python that this if belongs to this while loop here but once we have that i want to colon again and on another level of indentation i want to print x is 5. if i run this now we get the values from 1 to 9 and at the value 5 we have x is 5. and this way you can repeat code quite easily that being said there are two ways to make all of this a bit more complex let's talk about it you can break an entire while loop and you can also skip one iteration of the while loop and let's do this by example this is a bit difficult to explain here's the example i've shown you earlier and this one would just print the word loop 10 times on the screen but what you can do let's say with one if statement you could for example add the break keyword and just a keyword no brackets just break and if you write this the entire while loop is going to end whenever x is equal to 5 you would never get to this 10 here at the end besides that you also have continue continue doesn't break the while loop instead it just skips to the next iteration of the while loop meaning in this case if x is 5 this print down here would be skipped over because after continuing this line here we would go back to the while loop and then continue with the next iteration i think i added a bit more text here there we go so break ends an entire while loop while continue skips to the next iteration of the while loop and that's basically all you have to understand about it let's play around with it i already have an if statement inside of the while loop and this one i want to use let's start with the break keyword and you can already tell sublime is coloring it differently so we know that it has some kind of special functionality if i run the code now we get only the numbers from 0 to 4 and this happens because of this break here it ends the entire while loop as soon as xs5 the other keyboard we have seen is continue and this one right now is not going to work and maybe you can figure out why let me run it actually in this case we are getting all of the numbers and try to think of why we didn't skip over one of them after we are running continue we are skipping the rest of the current while loop in our case though we don't have anything after continue continue is on the last line of this while loop which means it doesn't actually do anything we could change this though by putting the print statement after continue and let me add a bit more white space here this looks a bit cleaner if i run this now we would expect this print statement to be skipped if x is equal 5 meaning we shouldn't see 5 in the output let's try it and indeed after 4 we skip straight to 6. we do not have 5 because of this continue here and with that we have a while loop let's do an exercise and then we are done that is horrible spelling there we go what i want you guys to do is to use a while loop to create a list with only even values from 0 to 100 i guess as a tip here create an empty list first and then from the while loop append more values i haven't covered yet how to only get even or odd values maybe try to do some research it should be fairly doable but let's see if you can figure this one out i guess this one was a slightly more challenging exercise but let's try it together i first need some kind of list let me call it my list and this is just empty brackets for an empty list and there's one more thing that i am going to need and that is some kind of counter by default i want to set this one to zero this is what we are going to use to control the while loop like the x we have used up here actually let me comment out this earlier stuff so we are not getting confused what i want to do with that is run my while loop again with counter is smaller or equal than 100 because this is the maximum number we want to go to and we are starting from zero which is the value here and let's start by adding every single value to the list for that we need my list append and then the counter once we have that i can just print my list and let's see what we get and we are getting nothing the reason here look at this again i have actually made the mistake i warned you about earlier right now the code is stuck inside of the while loop let me end it with the escape button this if this was an actual code example would have been really bad the reason here is this counter doesn't increase it always stays at 0 and as a consequence this condition will always be true and as a consequence we keep on adding the value 0 to this list and besides that we would do pretty much nothing else i would spend my entire processing time just adding zeros to a list which not only would break my code it would also be a waste of resources the way around it is i want to increase the value of the counter by 1. and now if i run this we are very quickly getting the values from 0 to 100 already a pretty good start but now i don't want every single value i only want the even ones meaning i want 0 2 4 6 and so on for that we are going to need an if statement inside of the while loop all you really need is the percentage sign and this we want to use with the number 2. if this is 0 we know we are getting an even number if i run this now i am getting only the even numbers this operation here if you forgot about it is the remainder for example if the counter was at three i think early on i used dots and that's a really good system to explain it let's say we have three dots here representing this three and if we're dividing this number by 2 we have one full block and this would be 1 unit after division and what this percentage sign here gives us is the remainder so this one here and if this is any value besides zero we know we have an odd value on the same line if there is any value so if i use different from zero we are only getting the odd values and this is the most common use case for this remainder operation it's a really easy way to get even or odd values i guess while we are here we should also practice skipping one while loop so let me extend the exercise i also want you guys to do not add the value 58. for some reason i really do not like this one try to add this one as well all right this is turning kind of into extra practice for the if operator but i suppose that can't hurt we can approach this in two different ways we could either add another if statement in here or add an end keyword after the original if condition i guess let's start with this one i want to check if my counter has a remainder of 0 and my counter is different from 58 this is the number i want to avoid if i run the code now i get let me find the value we have 54 56 and then we skip to 60. we do not have 58. this would be one way to add it here a different approach could be another if statement inside of this counter i could check in here if counter is different from 58 and then this append here has to be on one more level of indentation to tell python it belongs to this if statement here and if i run this now we are getting the same outcome here with the 58 being skipped all things considered while and if work really well together and all right with that we have while loops something fairly similar to a while loop is a for loop and this one works in a somewhat similar way we are still running code a certain amount of time so we are basically repeating code the difference now is that we are running code for every item inside of a container this could for example look something like this we want to run a for loop for every item inside of the list that contains one two and three the way this works is that python goes through this entire list and picks every single value one two and three here and then for each cycle it assigns the value to the x in this case but you could name it whatever you want meaning if you added something like a print inside of this for loop you would print 1 2 and three four cycles over every single item in the list and then it stores the value inside of x and you can treat it like a variable and just like with while you can also use break and continue and that is basically it let's have a look at it i want to create let me call it a basic list and here let's use the example i have a list with the numbers 1 2 and 3. and i want to run a for loop to access every single item of this list the example we have used is for x in basic list and then inside of it we have printed x if i run this now we're getting one two and three so what happened here i think it actually makes kind of sense python is going to run this block of code here for every item inside of this list and on every cycle it picks one of the values starting from one then two and then three and it always assigns this item to the variable we have specified here but you could use any python variable name and then inside of the for loop we are doing something with that value right now we're just printing it we could also add it to a list or doing some math operations or really do whatever we want and that way we can run code for every item inside of a list and this would also work with the other types of containers like a tuple a dictionary or a set as a matter of fact there are lots of different things you could be cycling over for example a string would also work inside of a for loop and there's one particular case i do want to cover if you want to cycle over a number this would also work but it does need some adjustment let's actually play around with all of this and i have prewritten some values these ones here we have a basic tuple a basic dictionary a basic set a basic string and a basic number tuples and sets work exactly like the list if i replace the basic list with a basic tuple we get the very same outcome and we would also get the same thing with a set there we go we always get one two and three python just really doesn't care what kind of container you have it's fine cycling over any of them the basic dictionary also works but it looks a bit different in terms of what you get let me paste it in here basic dict and now we are still getting one two and three we are getting all of the keys which if you cycle over a dictionary is probably not what you want to do the way around it is you would use either values to get the values now get one two and three the strings attach to each key or we would use items and that way you're getting a tuple returned with the key and the value we are going to learn later on how to work with dictionaries in a bit more detail but for now i think this is all we are going to need for a basic string we can just paste it in here and now python takes the string apart and gives us every individual letter including the space finally we have a basic number and this right now is not going to work if i run it we get a type error into object is not iterable let's talk about why this one didn't work to loop over a number so the operation we have seen was for x and three and this one didn't work the reason it didn't work is because python needs some kind of iterable and integers cannot be iterated over that being said iterating from zero to a certain number is such a common operation that there's a specific python function for it it is called range how you would use that is you would add a number in it and then it creates a range object if you use something like range 3 we would get a range object from 0 and then all the way to 3. and this we can iterate over it's fairly similar to a list although it is its own data type meaning if you want to iterate over a number you would use for x in range and then the number and i guess let's implement this one as well here we are back in the example and instead of using the number i have to put the number inside of the range function if i print this now we are getting the numbers 0 1 and 2 which if you pay close attention is kind of different from these numbers here we are not even getting 3 we are again starting at 0 and then going all the way to 3 but we are not including 3 and this is why we are getting two a better way of illustrating this let me copy this and comment out this entire for loop and just print the range object running this gets me a range object from 0 to 3. it very much is its own data type and this one simply gives us something we can loop over and it starts from 0 and goes all the way to a number we specified but it doesn't include it which granted is a bit confusing to read the range function actually works very similar compared to slicing because inside of range right now we only specified one value which was the end point but you could specify up to three values in here you could have the start the end and the step size for the values start by default is going to be zero and the step size is always going to be one meaning if we don't specify them we are getting those values most of the time you are only specifying the end value which is what we have done ourselves but in here you could specify something like 10 let's say 20 and 2. if i run this now we are getting range object from 10 20 and a step size of 2 which by itself isn't particularly useful but if i cut all of this out get rid of this print statement and uncomment this for loop and now i want my range object to look like this if i run it now we get only the even values from 10 to 20 and again we are not including 20. but that is essentially the for loop it is very often used alongside the range function they are very much connected to each other and i guess with that let's do an exercise once more and what i want you guys to do is this one here and this list contains other lists these are nested lists you are supposed to cycle through this entire list using a for loop and then only print the numbers below 50. although skip the values below 10. as a tip here you will need one for loop to go through this list and then another nested for loop to go through each individual list inside of this list finally i want you guys to break this for loop if any value is above 100 which is the case here for this one you are going to need a for loop inside of a for loop and also throw an if statement in there somewhere see if you can figure this one out yourself alright let's do it together now first of all i need for and now i need a good name and since i know that each of these lists here are nested inside of this practice list i want something like for a nested list inside of my practice list meaning i'm looking at this practice list here and i'm cycling over this entire list what i'm getting from that is going to be let me print the nested list i am getting these three lists here we still get the earlier results let me comment out all of this to make all of this a bit cleaner there we go now we have a couple of lists with numbers inside of them problem is this still doesn't help us figure out individual values for example i want to print this 10 here but right now i can't access it because it's inside of a list to overcome that we are going to need another for loop with for let me call it value inside of the nested list and now if i print this value and let me comment out printing the nested list that's going to get confusing if i run this now i am getting all of the numbers basically what happens here let me use different colors for this the first for loop this one here is going to go through this entire list and it is looking at every item and an item is counted at anything separated by a comma meaning this is one item this is another item and this is the final item python doesn't care if the item is a list or a number it treats all of them the same and to access every value inside of this nested list we have this second for loop here and this one is going to go for every individual list it starts with this one then it does this one and then this one and via this for loop we are going through every individual value inside of the list or the nested list to be more specific the result being that this value here is going to be every individual value from all of the lists and this is what we are printing that is a really good start so now we have to cover that we only want to print the numbers below 50 and we want to skip values that are below 10. i guess we can start with if the value is below 50 only then do we want to print the entire value let me run this now and we are only getting values below 50. this is going to cover the entire first line now we have to cover the part to skip if a value is below 10. and this again we could either do by adding an end here or we could add another if statement inside of here i guess i'm going to stick with the if statement inside of here although it really doesn't matter i want to skip the values if we are below 10 meaning if the value is below 10 then i want to use continue if this is the case we are stopping this entire cycle and we are not getting to the print value so let's try this and indeed we are only getting values that are at least 10 and the values two and 4 we have skipped now finally we have to cover the last part that i want to end this entire for loop if we get a value above 100 which is going to be this one here and now you might be very tempted to add something like if value is greater than 100 then i want to break this entire code or at the very least the for loop however now this is not going to work i guess to demonstrate it the last value after 101 is going to be this 10 here and since this is not below 10 we do expect this to run although i just realized that since we have a 10 here enter 10 here it might be a bit hard to see let me change the name here to a 12 so we have a specific number if we run the code now we still can't see the 12 and i would recommend you to look over this and see why we can still see a 12. the error here is because of one of the if statements try to have a look for it the error happened on this line here this if statement checks if the value is below 50 meaning we are never getting a value above that 50. as a consequence when we are getting to this line here if value is above 100 this line doesn't even run because we never get to it after this line here we are only getting values below 50. so this line here is essentially pointless we can however cut it out and paste it at the top of of the inner for loop let me fix this one now when we are looking inside of this for loop if we find any value above 100 we are breaking the entire thing and none of this would run i guess let me run it and now the last value is 10 this 10 here this does look confusing especially if you're just starting to program but if you get used to indentation here this should eventually make more and more sense this is definitely something you want to practice in your own time even more when it comes to python and the flow of the code understanding indentation is really important to understand what's going on there's one more topic i do want to cover before finishing this section and that is flow and line breaks so far we always wrote code with a colon and then with an annotation on the next line you don't have to do that you could just write straight after the colon for example for a for loop instead of the line break after the colon and the indentation here you could simply continue writing the print statement here this would also work with an if statement it would also work with a while loop as a matter of fact you could even use a semicolon to add multiple lines of code all of these here would be counted as indented python is totally fine with that that being said most of the time you do want to indent your code because having multiple lines is easier to read but that's not always the case sometimes if you have a very simple statement it might make more sense to have it on the same line for example match case very often has each case on an individual line without a line break between the case and the actual code because the idea here is each case should be fairly simple we're gonna have a look at that in a second but much more important for the if statement python does have a special operation here to have a one line if statement and this is called a ternary operator this one works like this let's say we have x equals 5 and we want to check something like if the value is below 5 we want color equals blue and else the color should be red a really simple if statement the problem is that we have four lines of code for something that really is very simple we could make this more space efficient by skipping the line break here this way we only have two lines and this i think is more readable but this may be debatable here however there is an even more efficient way of doing all of this and this would look like this this by the way is called the ternary operator this entire line would be this bit here then we have the if statement as always but now the if statement this bit here with the condition is this part here from the original if statement we also have an else and then we have the else condition so this red here would be assigned to the color if the condition this one here was false and the way you would understand this ternary statement here is if you read it like a sentence i want the color blue if the value of x is below 5 if that is not the case so else i want the color red and that way if you have a simple if statement you can cover all of this on a single line of code once again we have a completely empty python file and i want to start with the match case statement and here is the exercise we have done earlier if you see this now with the understanding that we don't have to do these line breaks i think all of this starts to make a whole lot more sense this one we could write like this let me get rid of all of the line breaks this here is something incredibly readable especially if you have some kind of statement where you would expect a lot of specific values you want to check for this would be a very readable way to organize all of it although granted using ifelse statement wouldn't look all that different the much more important operator is the ternary operator and let me comment out the match case stuff because we don't need it the example i've used earlier was x equal 5. from this value i want to assign some kind of color and in here you first of all need the value in my case red if the condition you want to check for is true i want to have red if the value of x is i think smaller than 5 i said doesn't really matter what it is if that is not the case so else i want to assign a different value which in my case is blue and that is all we need if i now print my color run this we are getting blue because 5 is well this condition here is false but if i change x to 1 run this again we are getting red and this way if you have a very simple if statement you can cover it on a single line i guess let me go over this a bit more theoretically a ternary operator always looks like this we have a true value if an expression results in true if the expression is false let me add a cross here then we are getting the else value so the false value and then either the true or the false value will be assigned to whatever kind of variable we are assigning all of this to that way you can cover an if statement on a single line of code and this is really readable and very efficient if you have a simple if statement if the if statement gets more complex obviously you want to use a normal if statement the ones we have already seen i guess one thing i haven't covered yet is that this sort of operation here this ternary operator works in a lot of different tools as well for example you can use it inside of an fstring or when you are creating a list let's have a look at those two examples let me get rid of this print statement and instead i want to print an f string and in here i want to write something like the color is and then i want to have an operation and in here i could copy this entire thing instead of the variable and it would still work so i can copy it although there's one thing that we do have to take care of and that is that right now the quotation signs are going to confuse python so it doesn't know where the string ends and where it begins the way around it is to use double quotation marks at the end and at the start and this should be working now let's try it and there we go the color is red and in here we have a fairly complex statement inside of a string this way we don't have to assign variables before or after we can keep everything nice and neat inside of one line finally we could also do something like a is equal to some kind of value in the list and in here i could once again copy all of this paste it inside of the list and then have some other values like i know yellow and green if i now print the entire list we're getting red yellow and green all i really want you guys to take away from this is that this sort of operation works basically anywhere in python you could also put it inside of a function or a method python really doesn't mind and this can give you a ton of power and avoid you having to write extra code that you wouldn't need in this section we are going to cover functions and let's talk about what functions are and what purpose they serve so far we covered some basic data types like integers and strings and we also learned how to change them using functions and methods on top of that we also learned how to change the flow of the code using if else match well for statements and stuff like that so we are basically able to create simple programs that work just fine but all of this only gets us so far and to understand why let's do a metaphor and let's say we want to build a car and the tools we have learned about so far are the basic parts that you would need for a car like screws pipes wires plastics and all the most basic parts you can have for a car the problem is these parts don't really make a car we don't build a car out of plastics and wires instead we build a car out of an engine out of steering systems out of control systems batteries and stuff like that meaning what we want to do in our code is to take these simple parts here and use them to create more complex systems like a control system or like an engine and once we have these more complex systems we actually create the entire car and in this analogy a function is one of these more complex systems like the engine the control the battery they are just more complex parts but they're still made out of these simple bits here and the main purpose of this is to make our code more reusable and more organized so what we are going to focus on for this section is to combine these simple tools to create more complex parts and that is the main purpose of functions later on we are going to learn even more powerful ways to organize your code using classes but that comes later for now we are just going to look at functions and the one really important thing i already want you guys to understand is that a function is simply a block of code that can be reused we're not really learning anything fundamentally new instead we are just putting our preexisting code into a simple block or container and then we are using this container to execute that code that's basically it although to use functions we need a twostep process let's talk about that one and then we actually create some functions for function we first of all have to create the function and this is where we are adding all of the code to the function or while we are creating the code inside of the function once we have that we have to do what is called calling the code this is a very common word calling a function means you are executing the function or you're telling the function to run and execute the code inside of it and you can also add information into the function when you called it we will see that in just a second but with all of that covered let's actually create some basic functions and this we should do in our code so let's have a look at that and to create a function we need a special keyword and this is called def short for define and now we need a name for a function and in here we have the same naming convention that we have for variable naming so for example a name for function could be test underscore function and this would be perfectly fine and once we have the name we need a pair of brackets and those you always need i will explain in a second what they actually do i am going to leave them empty for now though and now we need a colon and if i now press enter i am going to be in one level of indentation this space here tells python or while this indentation that any code we have inside of here belongs to this function really important to understand it works like a for loop or an if statement same principle and now in here we can write any code we have already seen for example i could print hello i could create a new variable let me call it test and test could just be one plus two and then i could print test we can write the very same code in here that we can write in normal code and once i have this i have created a function so this is the first step and now to call it i need my test function so the name of it and then add brackets afterwards and this entire process here is called calling a function essentially every time you're adding brackets after the name of a function you are calling that function and what that essentially means is you're telling python you want to execute all of this code here if i run the code we can see hello and free so this hello here and the result of oneplus 2 printed in this line and what i can also do now i can duplicate this call of the function and run this again and we can see this code run or executed multiple times and i hope you can already see why this is useful you can basically create some specific functionality in here and then execute it wherever you need so if you had some really complex code and you wanted to organize it better this is one of the main ways you would be doing it and let's actually do another example and for this one let's do something more specific i want to create a calculator and again i need brackets and all i really want to do in here i want to create a variable result and this result should be the result of number one plus number two and once i have that i want to print my result meaning this would be an incredibly simple calculator that just adds two numbers together but for this to work we kind of have a problem and that is how can we get this and this number here and for that we're going to need these brackets here and those brackets are called parameters and what they mean is let me add them actually i can add a parameter for number one and a parameter for number two and let's actually do the entire function now when i call this calculator and execute it with brackets i have to add arguments in here let's say two and three if i run this now i can see five which is the result of two plus three now why did this happen essentially this number one here and this number two are both parameters and a parameter is essentially a variable that you can only use inside of the function meaning this number one here we can use as a variable inside of this function same for this number two here and then the value for these two parameters or these two variables inside of the function come from the information that we pass into the function when we call it meaning this number two here is going to be the value for number one and number three is going to become the value for number two let's actually do this the other way around when we are calling the calculator by calling the name of the function and adding brackets afterwards python is looking what happens inside of the bracket and right now we are adding two numbers two and three and next up python looks at the actual function and the parameters and right now it has number one and number two and now what happens is that python is going to add the first argument which right now is this 2 it is going to assign the value of this 2 to the first parameter and then the second argument so this 3 here is going to be passed into the second parameter and that way num1 becomes 2 and num2 becomes 3. and once we have that we can use those two numbers like variables inside of the function although one thing you do have to be aware of is that both of these parameters only exist inside of the function meaning if i try to print num1 outside of the function i would get an error and that error is name 1 is not defined because this name 1 here only exists inside of this function so in the code besides coding the calculator once i could also call it twice and add different numbers let's say 10 and 20 and i would get the result again so again this function here we can call multiple times and well with that we already have the basics of functions so let's do an exercise and what i want you guys to do is to work on this calculator and give it some more functionality it should still accept num1 and num2 for two numbers you can add but besides that the user should also be able to add an operation so a third parameter and i want you guys to add a plus and a minus operation here so for example if the user adds let's call it the better calculator in here we can add one two and then we can add minus or we can add plus and obviously if the user does that we get either plus or minus operations now first of all i have to create a new function by writing better calculator the name of our function and now in here i need three parameters i want num1 and num2 again and besides that i need an operation or operator doesn't really matter what you call it and one important thing really quick since these parameters are always relevant only to the function we can reuse names here quite easily meaning to python these num1 and num2 parameters and these up here have no relation whatsoever so don't worry about naming here now what i want to do inside of this function is to add an if statement and in here i want to check if the operation is plus and if that is the case my result should be num1 plus num2 and once i have that i want to print let's do this a bit more fancy i want to add an f string and in here i want num1 plus num2 is equal to the result and we can actually try this so i already call the function with 1 2 and plus and the plus we have in this if statement here meaning if i run this i get 1 plus 2 is 3. and let me comment out these two lines here so it's a bit cleaner and one important thing here the indentations continue on each additional level i guess we haven't talked about this too much yet but inside of this function all of the code has to be on one level of indentation and now if we use more code inside of this like an if statement for example we have to add the code for this if statement inside of another level of indentation and that way python knows that this code here belongs to the if statement and all of this code here belongs to the function it's really important to understand indentation early on python uses it extensively to organize the code if i add a minus to this calculator we get nothing because we have no if statement or any of this but we can add it quite easily because i want to add an l if statement and in here operation i want to check for minus and now for this one i can just copy all of this and now the result should be num1 minus num2 and then for printing all of this there should be num1 minus num2 and now if i run all of this again i get 1 minus 2 is negative 1. that seems right and now i can copy this line change the numbers let's say i don't know some larger numbers let's add a plus here this is not how you spell that let's run this now and we are getting something that looks pretty good and i hope now that we have some better examples you can see the value of functions this is a really good way to organize your code because when we actually execute the code we just have one line but this one line executes a whole bunch of code and in actual programming examples you might have hundreds of lines inside of one function and what you see most of the time is that programmers create all of the functions at the top of the file and then a bit further down the actual code logic is written and that way you create some pretty good logic that is quite easy to follow and you can just change some functions here if you wanted to now with that we have basic functions although you can do quite a bit more with functions and the next part we have to talk about is arguments and parameters so let's talk about that in the next section so let's talk about parameters and arguments and let's do a quick recap because it's really important to understand these names when we are creating a function we are setting some parameters this would look like this for this function we are creating parameter one and we are creating parameter two and these parameters we can use like variables inside of the function so for example inside of the function we could print perimeter one and parameter 2. and again remember these parameters only exist inside of the function and now the next important step is when we are calling the function we are adding an argument to give the parameter a value which means when i call the function and i pass in hello and 42 then the first argument is going to be assigned as the value to the first parameter and the second argument will become the value for the second parameter and after that we are using those two parameters like variables inside of the function and the output we would get in this example would be hello and 42 and the basic thing you have to take away from this is that a parameter is basically a slot for an argument we are only using arguments when we are calling the function here and the parameters are the slots that we add the arguments to now there's one thing that we also have to talk about and that is how this ordering happens so how do we assign this hello to parameter one and by default arguments are being assigned to parameters via their position meaning the first argument is going to be assigned to the first parameter and the second argument to the second parameter and so on but there is another options and that is called keyword arguments and for this one you specified the specific parameter you want to add an argument to and let's have a look at this in practice that should explain this the best here again we have a completely empty sheet of code and i want to create another function that i called test function and right now i want to have argument 1 argument 2 argument 3 and argument 4. and then inside of the function i just want to print all of these arguments so let me copy it a few times three and four and now when we are calling this test function i can add for example one i can add hello i could add true and let's say for a list i could add one to and test you can essentially pass anything you want as an argument inside of a function if i execute this function we get one hello true and a list now the problem we have here when we are using position to assign this argument to this parameter for example is that this can get messy really fast and i think you can already see this one here where it's kind of hard to tell where things belong to it's really starting to look messy and for arguments still is a fairly low amount imagine we had 20 arguments in here which isn't impossible so we want to have something to organize this a bit better and for that we have keyword arguments and what those are is well we're adding the name of the parameter in this case arg1 and then we are assigning it a value like we are assigning values to a variable this in this case i want to do for all of these different arguments this would be argument 3 and this would be argument 4. and if i run this now we can see the very same result although here when we're using keyword arguments python does not care about the order for example i could assign argument 4 here and at the end i assign argument 1. if i run this now the first item so argument 1 that we are printing here is going to be this list and this would then be a clearer way to call your function what you can also do is to add this over multiple lines so i can do something like this and call all of this again and it would still work python here is quite smart and it understands that all of this is one function and this one here is actually fairly readable so even if we had more arguments this would be workable quite easily now what you can also do is combine positional and keyword arguments although you do have to be careful here and let me do one example let's say i want to assign argument 1 argument 2 and argument 3 via keyword arguments and then the final argument should just be a positional argument if i run the code now python is going to complain and the complaint here is positional argument follows keyword argument and this is a general rule you have to follow that positional arguments always have to come before keyboard arguments meaning this positional argument here would have to be before all of the keyword arguments let's say now i only want to have argument 1 as a positional argument and all of the other arguments this one is arg4 i want to have as keyword arguments if i run the code now this is working just fine and the basic reason why we have this is let's say i want to assign this argument here via position and right now this would be the fourth argument because this is the fourth item when we are calling the function problem is if i change this argument to to argument four then this keyword argument would also be referencing this argument for here and as a consequence python would get confused and if we have positional arguments before the keyword arguments this is somewhat mitigated although you could still mess this up for example if this first argument here is argument 1 and then the first keyword argument also references this arg1 and i run the code we are getting an error the test function got multiple values for arc 1. so you do have to be careful here but it's generally quite doable now with that we have positional and keyword arguments there's one more concept that i do want to cover and that is default arguments and the concept here is really simple let's say for this argument 4 if we don't get a value i want to assign a default value and this i do by simply adding an equal sign and now adding a value let's say for argument 4 i want argument 4. if i have this set up here i can get rid theoretically of this argument 4 comma function and now argument 4 is going to be argument for here or the parameter value is going to be this string and what you could even do if you really wanted to you could assign a default argument to all of your parameters that would look like this i hope i didn't forget anything and now you could call the function without a single argument and it would still work just fine although this again becomes kind of hard to read but sometimes this can be quite useful now let's do an exercise and let me copy in what i want you guys to do it's getting a bit long so i want you guys to create a greeter function with free arguments oh well free parameters we have person greet and weekday person and greed should have default arguments person for the person parameter and hello for greet and inside of the function use an f string to print the greet and the person and also print the weekday and when you're calling the function use at least one positional argument and one keyword argument and pause the video now and implement all of this yourself i want to create my function all the way at the top below my test function and the function name is greater and in here i want three parameters let me actually fix this one three parameters i want to have person i want to have greed and i want to have the weekday and with that we have covered the entire first line now next up for person and greed we want to have default arguments for person this should be person and for greed this should be hello and now inside of the function i want to print an f string and that is the third line of the exercise and in here i want to print the person and i want to print the greet and i guess on top of that we can print another f string and in here let's say it is the weekday and now with that we only have to call the function and let me comment out the test function and instead i want to call my greed turf and now we need one positional and one keyword argument let's say the first argument has to be positional because remember position arguments come before keyword arguments and let's say the person then is going to be bob for me now next up we need a keyword argument and for this one i want to go with weekday and let's say it's tuesday and now since greed has a default value this should be all we need so if i run this we are getting an error and the error here is that nondefault argument follows a default argument meaning python is unhappy that we have a default argument a default argument and then no default argument and this again can cause confusion in terms of what argument we are assigning to what parameter and i guess in our case to fix it for the weekday we can also assign a default argument let's say monday is our default weekday so now if i run this this function is working just fine and i can assign arguments via keyword arguments so i have person weekday and for greed let's say i can say welcome this would also work and i can also use positional arguments to assign the values like so and if i run this we would get something slightly weird because now we are assigning this tuesday here to this greet so you do have to be careful but at the very least this is working and i guess let me put this exercise on top of the greeter so it's a bit easier to read and right with that we have some default arguments and keyword and positional arguments the main thing you should be taking away from this video is how you assign arguments to parameters understanding that is really important to use functions we can actually do some more things with arguments so let's put this in the next section okay so let's talk a bit more about parameters and arguments and the main question we have to answer for this part is what if you don't know the number of arguments can you still make a function and the answer for that is absolutely yes although we do have to learn some new things and let's do this trading code here i have a completely empty file and i want to create a new function that i want to call print all and this function should take an unlimited number of arguments and then inside of the function i want to print all arguments but the problem is i don't know how many arguments i am going to get now one thing that you might have already figured out you could add some parameter called arguments and this arguments would be a list meaning if i run print all and add a list in here with let's say one two three four five and hello now inside of the function i could run for argument that is not how you spell that in arguments and i want to print the argument and this is indeed working via the list we can basically add as many arguments as we want and this would still be working just fine there's no limit on this although this is kind of annoying to work with and because of that python has a special way to work with unlimited arguments and this is called let me add a comment here it is called list unpacking and how this works is we are adding a star before the parameter that we want to unpack and now what i can do when i'm calling the function i can remove this list here and just have unlimited values and if i run this now we are getting the same result so what is happening here and i think the best way to understand this is just to print what we get so let me print the arguments and run the code again and now you can see we have a tuple with all of these values here and then later on inside of the function we are just looping over this tuple and printing each item inside of it that's all that's happening in here and that is essentially all the unpacking operator does it looks at all of the arguments we potentially have and then return all of them as a tuple and we can use it along with other parameters for example if i added another parameter here let's call it first i want to print my arguments and i want to print first and let's see what we get we get one and then we get all of the other items meaning what happened in this function call here python sees that this one here is the first position argument and we have one parameter so python is putting this one in there and then it sees we have a list unpacking arguments and we have a ton of arguments here so all of these are being stored in this arguments as a tuple and once we have that we can work with them inside of the function and this would also work with a parameter after the list unpacking although for this one here we would need keyword arguments so let me print the extra parameter here the one that comes after the list unpacking if i run this now we have print all is missing one required keyword only argument extra and python here is quite specific we want a keyboard argument for extra and this extra here since it comes after the unpacking has to be a keyboard argument the reason for that is that python by default doesn't know when this list unpacking ends and when this parameter starts but well we can fix that quite easily let me remove the error message i can assign extra another value let's say 12 and remove this 12 here if i run this now this would be working again and here are the values we are getting and with that we have simple list unpacking and now we can essentially add unlimited numbers of arguments inside of our functions now this you can actually make even more powerful and how this would be working is with keyword unpacking and for that let's create another function and this let's call it print more and here i again want to have my arguments and those i want to unpack but now i want to unpack them again and those i want to unpack but now i want to use two stars and you see in a second why and i guess inside of this function let's just print the arguments of what we are going to get and let me comment out print all and let's call print more what this double star arguments does is it looks for keyword arguments and then unpacks all of them inside of a dictionary so we have arg1 could be one then we have arc 2 is going to be test and finally we have arg3 is going to be let's say a list with 1 2 and 3. if i run this now we get a dictionary with three key value pairs we have arc one with the value one arc two with test and arc three with a list and those are the three arguments we passed in here or keyword arguments to be more specific and we're getting this dictionary because of this double star here now so far we haven't really learned how to work with dictionaries so we don't really know how to use this dictionary but we're going to learn about that in the next major section so for now don't worry too much about this but we are going to work with this quite a bit more later on when we learn more about dictionaries for now all you have to understand is if we're using double star and arguments then we get all of our keyword arguments as a dictionary returned in our function and what you can also do finally is combine these arguments or the list unpacking arguments and the keyword unpacking arguments inside of one function and for that let's create a final function let's call this one print even more and in here i want to have my arguments and i want to have my keyword arguments and these arcs and quarks is what you see quite often it's just a shorthand for arguments and keyword arguments and now inside of this function we could basically pass in whatever we want it would all be captured by these two parameters let me print the arcs and the quarks and now i can comment out this function call and add print even more and now in here i can just add whatever i want let me add hello and true and then besides that i can also add i know test is going to be one test two is going to be five whatever you want in here and now if i execute the code we get a tuple from the arcs parameter and the dictionary from the quarks parameter and even if you didn't add anything in here so if i didn't have any keyword arguments it would still work i would just get an empty dictionary and that means if you have this kind of setup as long as you add any kind of parameter that is valid python code into the function you are going to execute that function or at least you're not going to get an error in this stage of the code and well with that we have covered some really powerful stuff and let's practice it actually and what i want you guys to do let me add an exercise down here and what i want you guys to do let me paste it in here i want you guys to create a calculator function that prints the sum of an unlimited number of numbers or what a limited amount of numbers so pause the video now and try to figure this one out yourself all right let me paste this exercise here so we have all of our function at the top of the code and i want to create a new function that i'm going to call calculator and in here we want to have an unlimited number of numbers so i want the tuple or the list unpacking operator and let's call it args and now essentially what i am going to get in here is a list let's actually print it so i want to print my arguments and now let me comment out this function here and i want to have my calculator and add a random amount of numbers if i run this now we are getting a tuple with the numbers we are passing into it that's a really good start what we have to figure out now is to get the sum of all of these numbers and this we can actually do quite easily but let me do it over two lines so it's a bit easier to read i first of all want to create a new variable let's call this one the result and the result is going to be the sum of my arguments remember here this argument or these arcs is going to be a tuple and tuples can be used with the sum function and the sum function is just going to return the sum of all the numbers inside of that list this list here in our case and once i have that i want to print the result so now if i run this and we are getting 21 this seems accurate if you wanted to be more efficient with your code you wouldn't actually need this result here so you could just print some of the arguments and not the result at all let me comment it out this one would also work just fine although the earlier one was a bit easier to read so let's stick with this one and with that we have a function that uses list unpacking alrighty welcome back in this part we are going to talk about functions and scope which can be a really annoying but very important topic basically what it means is that variables created inside of a function are only available inside of that function and this is called a local scope and if we are creating variables outside of a function we are creating a variable in the global scope and the problem a lot of beginners have is to combine the local and the global scope and i think all of this is going to sound a bit cryptic so let's do this in a bit more of a practical way here we have a completely empty python file and i want to create a variable i called a and assigned a value 10. it doesn't really matter what it is and after that i want to create a function let's call it test func we don't need any parameters and in here i want to print a and this is going to work if i print test func i can run this we get 10 all of this is working perfectly fine and there are no problems whatsoever however now we can do something weird let's say i want to get a and add some kind of value to it let's say 2. if i now run the code we are getting an error and the error we get is a local variable a was referenced before the assignment now to understand that we have to understand the local and the global scope and this a here is a global variable and we know it is a global variable because it was not created inside of a function it is just there by itself however this test function has a local scope and the reason why we got an error is because when we are creating a variable like this a inside of the function we are creating a new variable inside of the scope of this function only here and since we are now adding a value to it when we are creating it python gets confused because there is no original value at least according to python what we could be doing is set this a just to 2 and now run this again and this is going to work and now this might be even more confusing because now we have an a inside of the function and an a outside of it and to python those two are completely separate variables there are no connections for python and the reason why there is no connection is again because this is a local scope of the test function and all the variables we are creating inside of it only exist inside of this function meaning what i could also do now is create another function let's call it test func 2 and in here again i can create variable a again let's give it another value 200 and print a again and now i can run test func 2 and run all of this and now the value for this a here is going to be 200 the one we are getting down here and again the reason why this works is that each of these functions have their own local scope and on top of that we have this global variable here and understanding scope does take some time but there's one really important thing i do want to cover and that is that functions are supposed to be separate from the rest of the code this scope isn't a necessity it's by design and the reason is that once the code becomes more complex it is really easy to run out of variable names which can be very annoying for example for the car we have we could have one function for the battery and one function for the tank and both might have some kind of capacity variable and because of the local scope this is perfectly fine we can reuse that word if we didn't have functions we would have to play around with that like capacity battery capacity tank but then if we have more more capacities this gets really annoying and this is one of the main reasons for scope inside of functions that we want functions to be separate from each other so we can focus on one function at the time so let me put it in red local scopes inside of a function help us keep things organized especially later on when we are writing more complex code this is becoming incredibly important and incredibly useful as well but right still when you get started with this it's very very annoying so let's talk about the rules of scope they are not that complicated the first one is that every function has its own local scope and every local scope is separate and let's play around with that one and this we have actually already seen in practice we have test func here and testfund2 and both of those have the variable a inside of them and this variable a is completely separate for each function and i guess just to keep with the example from earlier this could be something like capacity and i could print that capacity as well and we will get different numbers and i am probably repeating myself but this capacity here for example only exists inside of this function here and this also means i couldn't print capacity or well i could but python would give me an error that name capacity is not defined and the problem here is that this capacity we are trying to print in the global scope but capacity does not exist in the global scope so i can't do that i can only print capacity inside of the local scope of the test function because in there it does exist and well that is the first rule of scope inside of a function for number two we have global variables and those can be accessed in the local scope but they cannot be changed or created at least not by default and let's have a look at this one and practice a bit more this one is really important and let me comment out all of this so we have an easier example and this is actually what we have seen earlier so let me run test func let's call it test function to keep things a bit more organized when we started this part i just printed a and this did work meaning now if i run test func 3 we get 10. and what happened here is we are creating a variable inside of the global scope and then inside of the local scope of the test function we are printing this and if we are running all of this we don't get an error and we are printing the global variable this is working just fine and the reason why it is working is because we can access global variables inside of a function however what we cannot do is update the value meaning we couldn't do something like a plus equals two because then we are updating the value which python doesn't like now with that we have the problem of scope the question now is how can we solve it and for that we can use parameters global and return and parameters we have already seen it's just normal function parameters and those allow us to pass global variables inside of the local scope of a function the more interesting ones are global and return and i do want to emphasize straight away that global is a very easy solution to scope but not a good one you will see in a second why but the one you want to use the most is return this one is much better and global you generally want to avoid but let's actually have a look at how they work the first way to overcome the local scope of a function is by declaring a variable to be global and this you do by just typing global and then the name of the variable you want to declare as global in my case a and now if i run this this is working just fine the reason why it is working just fine is because when python now sees this a plus equal to we are telling it that this a is a global variable which means python is now looking in our global scope for the variable a and then we're using that value and if you really wanted to you could declare global all of your local variables inside of every function you ever write and then never worry about scope ever again which i guess would be possible but a really bad solution you are supposed to be using a local scope and keep variables inside of that which is why global is not really used that often and when it's used it's not really looked at favorably upon you generally want to avoid it a better way would be using parameters and return and parameters we have already seen so for this test function we can just create a parameter let's call it a as well and now when i'm calling this test function free i want to pass in my and if i run this now we are getting 12 again meaning if you want to update a global variable inside of a function you would want to use a parameter that is generally how you get global variables inside of a function and then work with them and to get values outside of a function you usually want to use the return value and in my case for this function i want to return the value a and this return is the same return that basically anything in python does it's just a custom implementation of that principle meaning if i have that i can comment out my print a and now when i run this function it is going to return the value of this a i could for example print it and if i run this i get 12 again or 10 plus 2. and just to go over what's happening here i first declare a 10 inside of the variable a inside of the global scope then this a i pass into the function so we have a parameter inside of the function that is local to this function only and to this value we are adding the integer 2. and after we are doing this we are returning this new value and then this value is being printed with the print function and we are getting 12 and all of this is working really well and if you wanted to update this value here you could even do something like a equals the test function with a and now we could print a and get the same result and this is then how you would actually want to work with functions that you're using parameters and a return statement to keep everything inside of the function organized and separate from the rest of the code and especially for beginners this is generally something kind of confusing so i guess when you are just getting started using global can be okay sometimes but you generally want to rather use return it is a much cleaner way all right let's do an exercise on all of this and let's see how well you understand it and basically what i want you guys to do let me copy all of it i want you guys to create two global variables called multiplier and has calculated multiplier should have an integer and has calculated should be set to the boolean false what integer you set is entirely up to you i really don't care after you have done that create a function called multiply calculator in this one should take one argument and then calculate the multiplication let me put this on another line it simply multiplies that number that's just about it all you really have to do is inside of the function multiply the parameter with the global variable multiplier and once the calculation is done set has calculated to true and that is this global variable has calculated then store the new number in a variable called result and return it from the function and finally print a return value of the function after it was called with the number okay um probably read for this a couple of times it's a tiny bit longer but pause the video now and try this one yourself alrighty let's do it together now and let me comment out all of this at the beginning so we don't get confused first of all i have to create two global variables one is called multiply and this one i want to set to an integer let's say 5. and after i have that i want another variable called has calculated and this one by default is going to be false and with that we have these two parts already covered next up i want to create a function called mold supply calculator and this one takes one argument so it needs one parameter let's call it number meaning now we are basically here so next up i want to do this step here i want to multiply my number with my multiplier and this is perfectly fine for python because remember we can use global variables inside of the local scope so this multiplier here is from the global scope so we can use it but we couldn't update it but next up we have to take care of the has calculated and set it to true this part here and for that i want to set has calculated to true but here now we have the problem this is the local scope so we cannot update this global variable here and i guess for now the easiest way of doing this would be to set global has calculated and well with that we have this part covered here now next up we have to store the new number generated inside of a variable called result and return it and all i really want to do in here is the result is the result of well this operation here and let me put this below has calculated that feels a bit cleaner and now what i want to do is to return that result meaning whenever we call this multiplication function we are returning this value here and this i want to use with print and i want to multiply calculator and in here i can add any number i want let's say 10 and let's see what we get 50 which is 10 times 5. so this is working just fine and what i can also do now i can print as calculated and this is now true so as soon as we're calling this function this is being updated although there's one really important thing about the return statement that i forgot to mention earlier and that is that return ends the execution of the function for example if has calculated is after return and i run this again has calculated is still false because this has calculated is equal to true is not being executed and that happens because return ends this function call the function essentially ends here this is something you do want to be careful about but right with that we have scope and again scope very early on can be kind of a tricky topic so i hope all of that makes sense but for now don't worry too much about it just play around with different examples of code and come back to this video when you get to something more complex it will become more important and i hope eventually starts to make more sense for this part we are going to cover lambda functions and lambda functions are fortunately fairly simple all they really are are single line very simple functions and the syntax for them looks like this we have the lambda keyword then we get whatever parameters we want to use and then we have a colon and at the end we have an expression and this is the actual code that's really all it does it's a single line function if you have some very simple functions you want to work with and you don't really want to write a whole function this for example could look like this where we have lambda then we have an x parameter and inside of the function we are just adding x plus 1. and an important thing about lambdas is that the result of this expression this one here is returned automatically meaning when we are passing 10 in here this lambda function returns 11 automatically and i guess let's have a look at this in practice this shouldn't be too hard all right once more we have a completely empty python file and i want to create a lambda function and let's use the example i've just mentioned so i have a lambda function and the one parameter i want to use is x and what i want to return is x plus one and this is then the entire function how you would use this is by assigning it to a variable and this variable now contains a function meaning we can call it by using brackets again and passing in any number we want let's say a 10 and if i run the code now we don't get anything because we have to print this value let me print it and we get 11. and that is the main idea of lambda functions it's basically very very simple functions that only consist of one line of code i guess a slightly more useful one could be let me copy this one here let's call this one simple calculator and for this lambda i want a and b and all i really want to do is return a plus b meaning now i can call my simple calculator and pass in let's say two and three if i run this we get five obviously right now these examples are so simple that you wouldn't even create a function for it in the first place i guess instead of this simple calculator you just write 2 plus 3 and you would get the same result if you can type properly so why would you ever use these kind of lambda functions and there are two main reasons that we don't really are going to cover in too much detail the first one is that some functions want our functions as argument and this is something we are going to see later for example python has a sort function and this one sorts any kind of list for example a list like one two three four and five and we could sort this if it was unordered let me mess it up a bit to something like this to order this function python is expecting another function to tell it how to order this list and this function would usually be a lambda because we don't want anything too complicated we are going to cover this later on the other examples where you see lambdas fairly often is with graphical user interfaces and essentially what happens in there is that every button gets one lambda function because a button would only return a value like 5 for example so you don't really want a full function you just want some very simple line of code that executes some basic thing when a button is being pressed so this could be really useful but for this introduction to python we are not going to cover it but alright with that let's do an exercise and then we should be done with it and for the exercise i want you guys to create a lambda function that accepts one argument that should be an integer and if the integer is greater than 5 return hello and otherwise return by and then obviously when you have created this call this function and print the result let me comment out these lambda functions here and i want to create a new lambda function that accepts one argument let's call this one x for the parameter name and now i want to return hello if this x is greater than 5 and by if it is below 5 and for that i want hello if x is greater than 5 and if that is not the case so else i want to print by and this lambda function i now want to assign to a variable let's call it x but it doesn't really matter what it is and now i can print my x and pass in a free we get by and if i pass in a 10 we get hello and with that we have covered lambdas they honestly aren't that difficult and you really aren't going to use them that often so don't worry too much about them all right next up we have one final topic for functions that is actually really important although it might not seem that much for this part we are going to talk about documenting functions and this is incredibly important although we are not adding more functionality all we are doing in here is explaining what our function does and this might not seem important but it really is because functions can get really complicated so you want to explain them and this is something you are going to notice when you are starting to code where you are writing a function and then don't look at it for a couple of weeks you probably have absolutely no idea what you did and when you look at other people's code it might be even worse and well explaining what your function does is just good form and really helps you when you work with other people and there are two things you can do to your functions to explain what they do the most common one is you just add some explainer text and this is called a docs string and besides that you can also add what is called type hinting and all that really means is you indicate what you expect for the parameters and for the return value of the function and if you have all of that your function should make quite a bit more sense so let's implement all of this all right here we have a very simple example of a function if i run this we are just printing two arguments so obviously this isn't complicated but i just want to keep it simple and to explain what your function does you can add what is called a dog string at the beginning of a function and a dog string you create with quotation marks like any other string and for a dog string you always want three quotation marks on each side it looks like this and sublime essentially turns this into a comment by default and now for this dock string you can write whatever you want or well whatever explains your function the best let's say i could call this one a simple function that prints two parameters and if i run the function we don't see any difference however now what you can do you can print the name of the function test in my case then dodge underscore underscore dock and underscore underscore again and if i run this i get the docs string of the function or a simple function that prints two parameters now why we're using two underscores before and after this dog you are going to understand later on for now just write it like this it really isn't too important for you right now just remember how it looks like i suppose another way you could be accessing this is by writing help and then test and if i run this we get some more information about the function and in here we also can see the docs string a simple function that prints two parameters and it is fairly common to use either of those to understand what a function does meaning if you write code with a team you really want to use this but well that's basically it it isn't that complicated now besides that what you can also do is to hint what you are expecting for these parameters and what the function should return and right now this function doesn't return anything so let's add return a plus b and now i want to indicate that for these parameters i am expecting integers all you have to do for that is to add a colon after the parameter and then add integer if you wanted to you could also set a default parameter for this and this you do in a normal way by just adding an equal sign and let's say 10 for this value and all this really means i am telling other programmers that for this a parameter i am expecting an integer and by default this parameter is going to be 10. and for b i also want an integer but i don't have a default value and with that we have some default parameters where we are indicating that we are looking for integers and let's say for b i want the default value of 0. and with that we are indicating to other programmers that we want two integer values that both have a default parameter meaning if i run the code now we can't see well not much of a difference because this isn't supposed to influence what the function actually does and besides that we can also indicate what is being returned from this function so this line here and this could do by adding an arrow after the function but before the colon that's really important and then here you again add the name of the type and here again use the name of the type you want to return for an integer this would be int i guess other data types could be str for string bool for a boolean list for well a list and dictionary for a dictionary but in my case i want to stick with an integer and now i can run this again and we again don't see any kind of difference and a really important thing you have to understand about type hinting is that all of this is optional and it can be ignored so for example what i could be doing is add a string in here and also a string in here i know let's say test if i run this now the function is still going to work let me comment out those two lines here to make it a bit more readable so now we have indicated for the function we are expecting an integer but when we actually call the function we are adding two strings and python doesn't really mind it still works just fine so you don't have to follow it it's mostly indication of what is being expected but alright with that we have covered all you need to know about functions in this section we are going to cover more advanced data operators and this is one of the parts where python is incredibly powerful there are lots of ways to manipulate data and get a certain kind of outcome there is a reason why python is really popular for data science and machine learning it is because there are lots of different ways to work with data so let's have a look what we can do what we are going to cover in this section is more advanced ways to loop over data we are going to sort data we are going to learn list comprehension a really important topic even though the name here is probably a bit weird and finally data handling if we want to import or export data let's get started by looking at more advanced ways to loop over data so in this part we are going to manipulate lists to get stronger for loops and this is a super powerful topic because very often python you want to merge a list and then loop over this merged list and for this for example python has a zip function that zips together two lists and you could also get the index for each of the lists when you use a for loop and i suppose all of this is going to sound a bit abstract so let's do all of this a bit more practically here we have a nearly empty python file and i already have two lists we have inventory names and inventory numbers and the scenario we have here is you are running some kind of warehouse and people gave you two lists one with the things in your inventory and then how much of that thing you have and for the order here you are looking at the index meaning the first item and the first number belong together then we have the second item and the second number then the third one and so on we are sorting things here by their order this could for example happen if somebody copies a column from excel it's very easy to get the problem for you is if you want to write a for loop and you have two lists you kind of have a problem if you want to access both of these lists at the same time so the scenario here might be you have some kind of website and on this website you want to display all of this information for customers so you want to loop over both of these lists but this you can't do right now you can either do for name in inventory names or you could do for let's call it num in inventory numbers but both of these for loops are going to be independent of each other so you have no way to connect the two python in this case has one specific function and that is called zip what zip does is it wants two lists we want inventory names in our case and inventory numbers if i print the result we are getting a zip object some point in our memory not particularly useful we're going to see how to use this in just a second but for now what you can do is to convert all of this into a list with the list function if i run this now we can see something much more useful we have a list with tuples inside and each tuple is right now the combination in this case of screws and of the number and these are again sorted by the index which is what i want in this case that being said this zip you hardly ever use in the list and inside of a print statement instead you would usually use it inside of a for loop and the followup here could be let's say for thing in and now i want to have the zip of inventory names and inventory numbers and this i can now print as the thing and let's see what we get there we go this is looking not too bad we have a tuple with our screws and how many of these we have but the issue still is we want to have each individual value to work with we don't want to have an entire list i guess what you could be doing here is use indexing to get one value from this tuple 0 would give you the items and one would give you the inventory number and you could access both like this and you would get the name of the item and how many you have this would work but it's kind of hard to read thing here really isn't too specific for that python has some really interesting functionality basically what we have seen earlier when we assign two values to two variable name instead of writing thing we could write for example name and number and now when python goes through this list and it sees a tuple let's say for the first example we have screws and we have 43 so this screws here and this 43 this would be the first item we get inside of this zip operation here it's kind of hard to read if you have a tuple and you write more than one variable name here python is going to unpack this tuple into these separate variables meaning in this case screws would be stored in name and the 43 would be stored in number and that way we can access them much easier inside of the for loop so name and number if i run this now this is still giving us the same result except now this is much easier to read and this is an operation you do surprisingly often i guess what we can do here to make all of this a bit easier to read we could use an f string and then i want to write something like let's say name and current index with the number if i run this now we get screws current index 43. i guess index isn't ideal let's use inventory that's better so we have screws current inventory 43 and this information if you give it to somebody designing a website would be very easy to work with another thing that you could be using here is called the enumerate function and this one is basically used to get the current index inside of the for loop i guess an example here could be if you are cycling over this list and when you get halfway into this list somewhere here you want to run some other code the question then would be how do you know when you are halfway into the list and for that you would have to know the current index i guess let me demonstrate how this actually works that should make much more sense we need enumerate and this is a function what it wants is some kind of list or something you can iterate over in my case i want to go with my inventory names and now if i print what this is giving us we are getting once again an enumerate object doesn't help us too much but if i convert all of this into a list i am getting the index and the item from the list this zero here is the index of this screws inside of the list wheels would be number one metal parts would be number two rubber bits number three and these are the numbers we are getting down here and again this enumerate you would basically always use inside of a for loop let's say again for thing in and now i want to have the enumerate function and inside of this let me print the thing if i run this now we are getting again a tuple with the index and with the name of the item and just like we have done up here we can unpack this again what you usually see is index and then the name of the item or whatever you want to call it this is entirely up to you but index here is the common name for what enumerator returns once i have that i could do something let me print an f string again and here index with the name of the thing and there we have the current index and the screws and this i could for example use if the index is let's say the example i had earlier if we are halfway into this list i want to run some other code maybe i want to notify my boss that my operation here is halfway done something like that i want to check if the length of my inventory names is equal to the index and this will give me the whole list but i only want half of that and then here you do want a flow operator so you're getting an integer or a whole number because the index is always going to be a whole number in and of itself and if that is the case i can print something like half way done now if i run this i am getting the first half and then the second half although you might have to tinker around with this to get exactly to the halfway point the most important part here is that enumerate gives you the current index where you are inside of the list when you are using a for loop and with that we have two functions you see very often alongside four loops the other one we have seen earlier was the range function which also is almost always used alongside the for loop we can do an exercise and then finish this part and what i want you guys to do is to combine zip and enumerate to get some kind of string like screws then in square brackets id 0 and then inventory and then the number of inventory items for each of these numbers from this list here so pause the video now and try to figure this one out yourself let's go through it step by step first of all we need some kind of for loop and let me start by just writing thing we can refine this in a bit and i want for thing in let's start with inventory names in here i can already print something we definitely didn't have string and i want to have my thing this should be in curly brackets let me run this now i forgot we got lots of stuff because i have to comment out all of this if i run this now we get the different items from this list not a bad start we have the first word but well we're getting there i suppose next up i can put all of this inside of the zip function and then combine inventory names and the inventory numbers i called it if i run this now we're getting a tuple we essentially create a new list full of tuples and each tuple will be captured by the variable thing and this is what we are pasting inside of here this we can unpack i want to have my name and i want to have the number this is basically what we have done up here i want to have a name and then i can add my inventory with a colon now i need curly brackets and the number running this now gets me screws inventory 43. we are definitely making progress finally we need to get the current id of each of these objects and for that we need enumerate what that means is i want to wrap the entire zip function inside of a numerit i find this one very hard to write you might struggle as well and before we work more on this i want to check out what we actually get returned from this thing here it's quite a complex one so let's see if i print thing in here we have one tuple and inside of this tuple we have two values the first one is the index the second one is another tuple that we got from this zip operation here unfortunately now this thing is kind of annoying to unpack we can't do this easily what you might be very tempted to do here is something like index name and number but if you run this python is not going to be happy because we have not enough values to unpack what that means is that python here returned two items inside of some kind of data structure in our case this is a tuple with the index let's say 1 and then the other value is a tuple with the let me call it the name and let's say 43 for the number and don't let me forget the closing brackets that is important now python looks at this tuple and it's these two items this one and this one but we are telling python inside of the for loop down here that we want to unpack all of this into three parts but python doesn't know how to do this because it only sees two items as a consequence we are getting an error what is most efficient here is to only use two unpacking variables we have index and then we have let's call it the inventory to pill let me print the index here and the inventory tuple now we're getting all of this not ideal but definitely something you can work with let me get rid of this one here and uncomment all of this now what we want the name is going to be part of the inventory tuple and it is the one with the index zero because remember this one is just a tuple nothing else after we have that i want something like this square brackets with id and then the current id meaning i need square brackets inside of that the word id a colon and then curly brackets with my index finally i want to have my inventory tuple and now i need the first item inside of this tuple and with that let me run it we get all of the different items properly formatted i suppose the most important part here is to understand this and what different values are being returned definitely play around with this one and understand how these things interlock with each other zip first of all returns a new list with tuples inside that are zip values from names and numbers and then enumerate creates a whole new tuple by adding an index and then adding the original tuple it got from the zip operation for this part we are going to cover one of the most powerful parts of python and that is called list comprehension a very strange name but it is for a super powerful concept basically what a list comprehension is is a way to create a list on one line of code and this can get surprisingly powerful you can either use it to create a list or to manipulate existing lists like to filter out values for example but let's keep it simple for now and let's say you want to create a list with the numbers from 0 to 99 for that right now you will probably write something like this you start with an empty list then use before loop so for num in range from 0 to 100 because remember we only go up to this number we don't include it and we want to end at 99 and then inside of this for loop we are getting our list and we are appending the number we are getting from this for loop fairly simple operation and since it is so simple wasting three lines of code on it feels kind of pointless as a consequence we would use list comprehension this one would look like this it's kind of comparable to a ternary operator actually we still keep most of the words here so we have four the same four we had here then we have num we still have the num here then we have the in in both of them and also the range stays the same as well we pretty much put the whole line here after the number the major difference now is instead of writing my list dot append we only need num inside of this this one automatically gets appended to the list you are assigning it to and that way you can write all of this much more efficiently and this is only a very simple example this can get significantly more powerful but let's have a look at some easy examples here is the operation i have just shown you in the slides and this if i print my list we are getting the values from 0 to 100 inside of a list and again here this is three lines of code for something that ultimately is kind of simple so let's do all of this in one line and let me call it my list comprehension or just comp and in here we always need square brackets this always has to come in there and then we again need this entire line here as a matter of fact let me actually copy it so we have four num in range 100. the difference now is we don't add a colon and then the operation we want to do like my list dot append none of this is going to happen instead the value we want to return to this list comes as the first word inside of it and this will automatically be appended to this list as a consequence we would just need this we need num for num in range 0 to 100 if i print this now we are getting exactly the same outcome all we really have done is condensed this entire line here into a single word with the entire rest of the for loop staying identical that being said now you can make more changes to this part here for example you could multiply all of this by two run this again and now you have every value multiplied you could also put all of this inside of let's say a tuple and then add num num and num and now python would automatically assign each value inside of the number basically what we are doing is this num looks at the range and gets the values from 0 to 99 and then it assigns each of these numbers to one of the values inside of the tuple and this is then what we're getting here so we'll get 0 0 0 1 1 1 2 2 and so on and this is only the most basic kind of list comprehension you can do and there's one way to make this significantly more powerful you can combine list comprehension with the ternary operator which is just a fancy way of saying you can add if to a list comprehension there are actually two ways of doing it the first one would be at the end so num for num in range 0 to 100 if a certain condition is true although an important thing here is else does not work i don't actually know why but you just get an error if you add an else after this however the other way would look like this where you first add the value you want to return and then the conditional statement so if num is 10 else 0 and then the for loop we have seen up here and choose whichever works better for you both are totally fine just keep in mind the second one is a tiny bit more powerful i honestly have no idea why the first one doesn't work with else statements it might be something internal and this is something really powerful because you could be using it to filter other lists let's have a look at this in practice actually and let's do some basic examples first i can add an if statement here at the end and i only want to get these values here if the number is let's say below 20. if i run this now my list comprehension stops at 19. although again keep in mind else 0 for example would not work i would get an error that says invalid syntax so this is not good but what i have to do to get around that i would have to cut all of this out and paste it here now if i run this this is working just fine we get all of the two bits from 0 to 19 and then for any other value we are getting 0. and that is basically a trade if statements in here one example how you could be using this here are the two lists you have seen from the last part and i want to clean them up let's say i want to create a list with all of the parts that have less than 25 items so i want to select wheels because they only have 12 items and i want to select the screwdrivers because they only have 23 items and for that list comprehension could be really really powerful along with the other stuff we have already seen let me call it the replenish that's not how you spell that replenish list and now in here we want to look through all of these items and for that first of all we again need square brackets and let's start with thing for thing in and i want to again use my zip list because i want to access both of these lists and here i need inventory not numbers but names and now inventory numbers if i print now my replenish list i get the entire list inside of the square brackets so far this isn't helpful at all but now what i can do first of all this thing here instead of thing i want to name let's call it name and number and to get the same outcome again i would need my name and my number so far again we are still going to get the same outcome but now i only want to do all of this if a certain condition is true and in my case the condition is if the number is below 25. if i run this now we are only getting two items with the name and the number attached to it which is a very nice way to get data out of this list here and this is a kind of operation you would actually do fairly often in python and list comprehension for that is what you would use very very often now what you can also do is to combine different list comprehensions let me add a comment here let's call it combine list comprehension although this one is going to get a little bit more complex but let's go through it in a really simple example let me create a new variable combined comprehension and in here first of all i want to have something really simple let's say x for x in range 5 then i'm going to comment out all the stuff we have done so far and print what we are getting from the combined comprehension we are getting the numbers from 0 to 4. this should make sense it is fairly simple at least i hope it is but now what we can do is put all of this inside of another list comprehension so all of the stuff we have seen so far for y in range let's say 10. if i now run this we're getting something that possibly looks a bit weird i think there's a better way of presenting this instead of printing the list by itself i want for row in combined comp print row and now if i run this we can see the entire output like this much easier to read and let's go through what happened here that is probably kind of confusing right now i think the best way to go over this is to separate these two lists we have an inner list this x for x in range five and then we have an outer range the entire list comprehension that's a terrible line let's do it like that's still a terrible line let's do it like this the yellow part is always this inner part here and this we now got multiple times we have one here one here one here and so on they are all x for x and range five the reason why we got this multiple times is because of this part here we basically created this list 10 times and that way you can create a list that contains other lists although still not particularly useful but where this system becomes incredibly powerful is you can put this yq for example into the original list let me actually demonstrate instead of just having the x as the value for this list i want to have instead a tuple with x and y if i run this now we are getting let me use different colors for this we have a tuple this tuple here and this tuple is inside of a list this list here that is the list we are getting from this inner list comprehension finally then we have a list of lists and this is the entire list comprehension and i suppose inside of the tuple we have the x and we have the y value x increases on every column and y is increasing on every single row e is y0 y1 y2 and so on with the system you can create incredibly complex data structures you could theoretically even add a third and a fourth list comprehension but by that point things are a bit overkill i think i would not recommend overthinking this it can get really complex and it doesn't have to be as complex if you really wanted to make something more complex you probably want to use a for loop but alright with that we can do an exercise and then we are basically good to go and what i want you guys to do is to create the fields for a chess board and just in case you had actually fun hobbies at school a chessboard has the fields a b c d e f g and h which is eight letters in total and then we also have the fields from one let's say one two three four five six seven and eight which basically means the first field you are going to get is a one and then you keep on creating more fields and at some point all the way at the bottom you should have h8 and if you want an extra challenge this is not actually a chess board because a real chess board would have the a1 at the bottom and the h8 in the top right i guess i can cover both see how far you get but pause the video now and try this one yourself let's get started by commenting out all of this and then i want to start let me call it chess board and in here i want to start with the square brackets for my list comprehension and i guess we can start with the numbers so num for num in and now we want range and let's start with 8 and let's see what we get i want to print my chessboard and i get the numbers from zero to seven which is not a chess board we need the numbers from one to eight for that i'm going to specify a start value here and now the end value is going to be 9. if i run this now we get the numbers from 0 to 8. we have the inner list comprehension now for the outer and now this might have been the one part where you struggled that was how to get each individual letter here and the solution is actually really simple all you need is to type the string a b c d e f g and h if you have this and i run this again we get this entire list except it's very hard to read so let me do it again for row in chessboard print the row there we go this is much easier to read the problem now is that we want to have the letter and the number this happens inside of this part here i want to have the letter and then the number if i run this now we have a 1 in the top left and h8 in the bottom right that's a good start although i guess doing this as a tuple isn't ideal but you don't have to you could totally create an f string here and in there i want to have the letter and i want to have the number now running this gets me something like this i think that looks a bit more appropriate the difference here really doesn't matter all that much and now if you wanted to invert all of this meaning that instead of the a1 here you would want this top part to be h1 and then this part down here would be a1 in a chess board the bottom left field is always a1 and the top right one this one here would be h8 to achieve that you could just type out this string here in reverse but that would be kind of annoying and not exactly scalable if you wanted to make something larger but here we can do something really clever we can use slicing remember this from quite a few videos ago we are specifying a start an end and a step size now the start and the end if we leave them empty is giving us the entire string but now if we specify for the step size negative one then we are going to go backwards over the string now to understand this part you have to understand return statements basically what happens here is originally we just returned this string but now because of this slicing operation the four letter in is looking at the entire operation here because this is what gets returned this is really something you eventually understand when you play around more with python it does take some time but now if i run this we are starting with h1 in the top left and a8 in the bottom right and with that we have a proper chest field i hope that wasn't too bad list comprehension especially early on can get very confusing besides a list comprehension we have other types of comprehension as well one for each type of container at least kind of and before i cover them i really want to emphasize that list comprehension are by far the most common comprehension you are going to do i am going to include these mostly for completion sake but you probably aren't going to use them very much comprehensions work quite easily with dictionaries and sets this would look like this for a dictionary and like this for a set set is actually super easy all we are doing here is we are replacing the square brackets with curly brackets and then we are done that is literally the only difference for a dictionary the one thing you really have to keep in mind is that we always need the key then a colon and then a value in this case both of them would be num meaning we would create a dictionary that would have key value pairs like 1 and 1. then 2 and 2 three and three and so on not exactly useful but it's something you can refine and that brings us to the final type of comprehension a tuple comprehension this one works a bit differently in here you are still using num for num in range 10. the problem is for python this kind of operation was already covered using the normal brackets as a consequence this operation gets a bit weird to create a proper tuple out of it you would need the tuple function but after you have done that you are back to a normal tuple with whatever operation you have in here so not that much of a change and that is basically it let's have a look at all of this in code and let's get started with a set comprehension this one we are creating with curly brackets and now in here we can just do the normal comprehension stuff for example num for num in range let's say 100 and if i print the set comprehension i am getting all the numbers from 0 to 99 this is basically all you have to know and well let's get to the next one the much more interesting one the dictionary comprehension for this one we again need curly brackets but now the important thing is we need a key and we need a value but once you have those two you would still continue with four x in some kind of list in my case let's go with num in range 100 and now i have to define values for key and for value i guess from the example i could name both num and then print the entire dictionary comprehension and now we are getting a dictionary although i do want to fix the typo that is annoying me there we go now what we are getting in here is a dictionary with lots of key value pairs this is one this is another this is the third and so on and in here we have set the key and the value to the same number as a consequence they both have the same number which really is not useful to make this a bit more interesting we could for example get the power of num and run this again now we can see a bit more of a difference the key is 2 for this one and the value is 4. 3 gets us 9 and so on this way you can at least see different values that is basically it for dictionary comprehensions finally we have tuple comprehensions and in here you would use normal brackets and now you would still write something like num for a num in range 100. if i print this tuple comprehension we are getting a generator object at some location in our memory which well is really not useful that being said you could work with this super comprehension for example in a for loop i could write for let's say value in tuple comprehension and i want to print the value if i run this now we are getting all of the values inside of it meaning this object is working as intended we just can't really see the result to actually see it we would have to convert it to a tuple and then we are done if i print the tuple comprehension run this again now we can see the result we would expect the reason for this is that these normal brackets are used quite often in python and in this case they are in conflict with the tuple comprehension but that's not something you have to worry about too much i have never ever seen anybody use a tupel comprehension to be honest the one thing you see once in a while is a dictionary comprehension but most of the time you see a list comprehension and nothing else and i guess with that we can do an exercise what i want you guys to do is to create a dictionary with the keys a b c d and e and each key should have a list as a value with the values one two three four and five that should be one list for each of these keys pause the video now and try to figure this one out yourself all right let me start by creating an exercise comprehension or whatever you want to name it since we are creating a dictionary i want to have my curly brackets now in here let's get started by creating the keys we need to format key and value then for x in some kind of iterable and since these are the values that change the iterable here should be a string with a b c d and e for proper naming here let me rename this x to a letter and now my key should be this letter and since the value doesn't change it is always one two three four and five i can just type the value in here and now all i have to do is to print the exercise comprehension run all of this and we can see we have the dictionary here this one worked pretty well let me comment out the earlier part there we go this looks much cleaner in this part we are going to cover functions that take functions as argument which is probably going to sound a bit weird but let's talk about it when you pass arguments into a function it is perfectly fine to pass a function as an argument into another function and let's do this by example to actually illustrate what i mean and for that i want to use the sorted function this one sorts some kind of iterable in some kind of way it looks like this the name of the function is sorted we have to pass in some kind of iterable most of the time it's going to be a list but it doesn't have to be and then we need some kind of function to tell python how it needs to sort this list for example do you want to sort the list from the smallest to the largest number do you want the opposite of that or if you have for example a list that contains strings how do you want to sort that do you want to go by the character in the alphabet do you want to go by the amount of characters inside of each string it really depends here python doesn't know by itself meaning you have to write a function to tell how to sort this iterable and this is the function we have to create ourselves which well isn't that difficult but you do have to understand the system so let's have a look at this straight in code in my code i already have one list and this list right now is kind of unsorted it's a bit random and to sort it i need the sorted function and in here at the very least i have to pass in one argument and that is the list i want to sort what i get returned from this let me print it i am getting the list sorted and this you usually do with a list as a matter of fact a list even has a sword method that sorts the entire list if i run this and let me comment out this line here list.sort after i run this i can print my list1 and now the list was sorted as well this method and this function they are basically doing the same thing but this is not what we are here for we want to look at sorted via the other arguments and there are two you can pass in here one is really easy and one is the function i just talked about but let's start with the easier one the one argument you can use here and let me use a keyboard argument we want to specify a reverse and then here python expects a boolean if i set this to true it reverses the entire list now we go from the highest to lowest instead of the lowest to the highest that's basically it what is much more interesting is the key argument or parameter because in here python is expecting some kind of function and let me actually demonstrate a use case where you would need it for that i have another list that i want to store in let's call it list 2. in here i have a list that contains two builds in each tuple we have for example a and 3 we have b and 10 c and 6 and so on and this would be really difficult to sort if i print sorted and list 2 let me comment out the first part and run this again we now get well no change in the list python just doesn't know what to do with this list but in my case i want to sort this list by the integer inside of each tuple meaning this one here should be first then the second then this third and then this last and for that behavior i have to tell python which value to access and for that we have to create a function let me do it straight below the list although most of the time you would do it straight at the top of the code but in my case i'm going to keep this a bit more readable i want to create let me call it a sort function and this is always going to need one argument let me call it item and now how this is going to work inside of my sorted function i have to specify a key and for this key i want to have my sort function and really important now you do not call this function there should not be any brackets after the sort function except to close sorted and print you are only passing in the function you are not calling the function python or well sorted does this one internally so you don't have to do it and basically what is happening is that sorted goes through each of these tuples in this example and passes each tuple inside of the sort function as an argument and then this function has to return some kind of integer let me write i n t and the size of this integer is going to determine how we are ordering this list so in my case all i want to do inside of the function i want to return item and then 1. for example if i'm getting this tuple here as an argument all i really want to do is to pick this integer and return it and then python knows what to look for inside of this list for the sorting algorithm and that is literally it if i run this now we can see the list is sorted now via the integer inside of the tuple so we have 3 5 6 and 10. and of course inside of this function you can be really fancy and add a whole bunch of stuff the thing is most of the time you are not going to do that in almost all cases you simply want to tell python a bit more in detail what kind of value you are looking for this is very rarely becoming complicated as a consequence you hardly ever write a dedicated function instead you use lambdas let me actually copy this line and now i want to have my list 2 and for the key now i don't want a function instead i want a lambda function and for this one we again as the first argument here we have to specify what kind of parameter we want that is this item here this one would be equivalent to this item here inside of this we have to tell python what to do with this item in this case all i want to do is get the item and then pick the first index and since this item here will be returned automatically this is equivalent to all of this and with that we are done i can run this now and we get the same result so this is working just fine and that is essentially it now with that we can do an exercise and for the exercise i want to stick with the same data we have used earlier this one here we have inventory names inventory numbers and i already used zip to zip these two together meaning now let me comment out all of this i want to print my combined list run this one now and we have a list with tuples inside and inside of each tuple we have the name of the item and the amount of how much we have of that item and i want you guys to do two operations actually number one is sort this list by inventory numbers for this list the first item should be this 12 year with wheels next up should be 23 with screwdrivers and so on and number two sort this list by length of the inventory name this means that the longer the word gets the later it should be in the list i guess what should be first and screwdrivers should be last we are looking at the length of each string here and well pause the video now and try this one yourself let's start let me call the first one sorted comp by numbers and here i want to have the sorted function and inside of list i have to first of all pass my combined list now i have to specify a key and for this one i want to have a lambda function let me use a num here as the parameter name since the argument we are expecting is some kind of tuple let's call this one the inventory tuple all we want to do with this one is to get the inventory tuple inventory tuple and get the item with index number one we should be done let me print this sorted comp by num and there we go the first tuple is now with 12 then 23 43 43 95 and 421 this is working just fine so next one we get the sorted comprehension by name once again we are going to need sorted i want the combined list and now we have to specify a key i guess here again we are still going to get the inventory tuple inside of this we still want to look at the inventory tuple but now we want to have the index 0 because we want to look at the strings and we don't want to return the strings we want to return the length of the string meaning we want to have the length function and then the result of that is going to get returned i can now print the sorted comp name and we get the first item is wood there are four letters in here then we have screws this is six characters wheels is also six and metal parts is definitely more than six meaning this seems to be working just fine and with that we have the sorted function but there are two more functions like it that i would like to cover for this part we are going to look at two more functions that take functions as arguments besides sorted we also have map and filter at least for basic python now that being said you probably are very rarely going to actually use or see them they have basically been replaced by list comprehension which is a more elegant way to do all of this but let's have a look at all of this in practice once again i have an empty python file except now i have my list that contains a list with the numbers from 1 to 5. the two functions let's start with map all that this one really does is it changes values with a function inside of a iterable just like we've sorted we have to start by using the map function name and in here we need two arguments we need some kind of key and then we need an iterable in my case the iterable is going to be my list for the key i want to create some kind of function and in my case i want to create a power function so basically what map does is it cycles through this list which in our case is going to give us one two three four and five every single one of these values will be passed into the power function as an argument and then whatever the power function returns will be used to create a new list instead of sorting it we are just changing every single value map in a way is simpler than sorted i want to create a power function and this one again is going to need some kind of parameter in my case i'm going to call it num and now we have to return what we want this new value to be in my case i just want to take the power of this num and that is all we needed now i can print all of this and let's see what we get we are getting a map object cool completely useless but we can convert this to a list and then we can actually read it if i run this now you can see we have taken the power of every single value inside of this original list one remained a one but the two became a four and the three became a nine and so on we went through this list and we applied this function to every single value and that is literally all that happened here once again since it's kind of annoying to write a whole function for something so simple we are usually going to use a lambda function we need the lambda keyword and now the name of the parameter in my case i want to go with num all i want to return here is num and the power of that if i run this now we get the same outcome if you compare this to list comprehension it really should look kind of familiar we're going to talk about this in a bit more detail but first of all i want to look at the filter function and this one filters out values from a condition for example let's say in this list here i only want to get the values that are smaller than four one two and three we would need the filter function and in here again we are going to need some kind of key and then an iterable we want to change the iterable in my case is going to be my list and for the key i guess we can create another function let me call it get below 4 that is not an underscore and for this function we are going to need another parameter once again i'm going to stick with num i want to check if this number is below 4 so if num is below 4 i want to return true and if that is not the case i want to return false and this is the function i want to pass in here and this let me comment out all of the stuff we have seen earlier now i can print my filter and you might already expect what we are going to see we are getting a filter object which is useless for us but we can convert it to a list and then we can see now we only have values smaller than four essentially what happened in here is that filter looks for every item inside of this list we are again looking at 1 2 3 4 and 5. each of these numbers is going to be passed into this get below 4 as an argument and depending on what python gets returned here this item either stays inside of a list or it gets filtered out if python is getting true from this function the number is going to stay inside of the list one two and three all have the function returning true however four and five had the function return false as a consequence they were filtered out out of the list that is literally all that filter does i guess once again i can duplicate the entire line because we don't have to create a whole function we can use lambdas for that which is kind of how this was intended to be used i want a lambda in here i want my number and in here i want to run num is smaller than 4 and this works because python is going to convert all of this into a boolean value so if i run all of this now we are getting the same outcome except this line here is much easier and shorter than all of this and with that we have filter and map basically two functions you very rarely see nowadays why that is we can actually see from the exercise what i want you guys to do is to convert both of the power and the filter function so this one and this one here let me uncomment all of this i want you guys to convert this one and this one to a list comprehension and see how much you remember let me copy the two functions first and now i can comment out all of this here so we are not getting confused the first one is the map function and for this one let me do it straight inside of a print statement in here i need to square brackets for the list comprehension and now i want num for num in my list this is the list we have gotten all the way up here all we want to do is to get the power of it and with that we are actually already done if i run this now we're getting the same result except i think it's pretty obvious this is much easier to read than all of this which is why map is very rarely used nowadays if you really wanted to you could even use a function in here as well and this would imitate map even more so there's very rarely a reason nowadays to use map the main reason why you are still learning it is because some older code examples might use it and you know what they mean but chances are that you aren't going to use it yourself all right now besides that we can do the same thing for filter and let me comment out those two for this one again i want to have my list comprehension and i want num for num in my list which if i run this is giving me the entire list but now i only want this number if the number is smaller than four and running this is giving me the exact same result and again this is much easier to read than this one here which again is why filter is very very rarely used nowadays in this part we are going to cover file handling meaning we are going to open a file and we are going to write into that file which is surprisingly simple python is very capable of opening simple file formats the one we are going to see in this video is dot txt which is the simplest form of storing text on windows computers also works on a mac they are kind of universal besides that you could also open a picture and there are a couple of other basic file formats you could be working with but i'm going to stick to txt now that being said python could at least in theory open basically any kind of file let's say a blender file an excel file a word file a pdf document python can open all of them but most of the time you are going to need external modules to do that what those are and how to use them we are going to cover later in this series i guess as a good example here for some selfpromotion a while back i made a video on how to create a snake game in excel using python totally doable kind of fun although very strange but anyway let's have a look at all of this in code before we start coding i want to look at my folder this one is looking like this let me extend it a tiny bit inside of the code i have the python file itself and i have a txt file called test if i open this one i am getting a simple txt file with a bit of text inside nothing complicated but well we don't want to over complicate things this is the file i want to open and this is also the file i want to write in keep in mind here both the python file and the text file are in the same folder that is important to open it you have two ways you could either open and close it manually this means i want to create a new variable let me call it file and the function you're looking for here is called open and this open wants a file path and the name of the file in my case this is going to be test.txt let me actually print what we get so i want to print the file we are once again get some random thing that we can't read but this we could convert to a list and now we have the document as a list with all of the text inside notice here at the end of each line we have a line break the one we have seen all the way at the beginning this way the document knows where to end one line the one thing you want to be aware of right now is that we only need the file name because both files are in the same folder if that wasn't the case you would have to specify in what folder you are for example if the text was inside of a folder you would need folder then a slash and then the name of the file and if you want to go up one folder you would need two dots and that's basically it this way you can create file paths and find specific documents you want to open besides that there's one more thing that you do want to keep in mind and that is we have to close the file again if we had a longer code example and kept it like this we would keep this file in memory which wouldn't be necessary to do that you would need file.close if you run this again now you are not going to see any difference but this line removes the file out of the memory which is more efficient and with that you can open and close a file that being said this approach isn't really used that often because the better way is let me call it open and close it automatically the way you would most of the time import a file is with the with statement in here we need with open and then the file name this is still going to be test dot txt and now you have to write s and give this a name in my case i am going to go with file what's happened here is basically the same that we have done up here we opened a file just like we have done here and this file we are storing in a variable called file the same thing we have done up here the difference now is we have to write some indented code in here and as soon as this indentation is over then we are closing the file automatically that way we are not going to need this line here this is also more deliberate and possibly easier to read it's basically up to you both approaches are fine but this is the one you are going to see more often in here we could for example print and let me use the same line i want to print the list of my file and we get exactly the same outcome let me comment out the earlier part because this is the one i want to work with the most now python has a few functions that you can use to read documents especially txt files the one you're probably going to use the most is file.read don't forget the brackets if you're calling this you get a proper output from all of the stuff read basically converts this into something that you can work with more easily although keep in mind this read is going to return if i use the type function it is going to give me a string which means if i convert all of this to a list i would get a whole bunch of individual characters that don't help me that much the way you want to use this read function is just to get an overview of what you have it's kind of difficult to cycle through this but for that you could use something like for line and then i want the list of the file and now i can print the line and i want to comment out this part here and now i get basically the same thing since i'm not going to use this too much i'm going to keep it short but this is kind of all you need to know about it if you had other kind of data you could work more with this but that's beyond this video what is not beyond this video is write some file let me comment all of this out and to write a file we again need with open and in here i again want to open my document but now i have to specify another argument and this has to be a string most of the time this could be r it could be a or it could be w r stands for read a stands for append and w stands for write the default one is r meaning we are just going to read the document but the one that we could also use is a for append and now i want to keep this as a file and in here now i could use file dot write as an argument in here i can now write some more text and just to make it a bit more visible let me add a whole bunch of axes so we know what we're doing if i run the code now we cannot see any kind of difference that being said if i now open the folder again open the document we can now see the end the one we already had and then write some more text with axes around it the kind of annoying thing here is at the end we don't have a line break this one you would get by adding a line break character manually and now if i run this again and open the folder with the document we now have all of this on a whole new line and you do want to be careful here because this a means append if you write w you're going to write a whole new file with this content here let me run it if i open the folder again test file is still there but if i open it we only have write some text with a line break on the first line the reason here is that this w tells python to create a whole new file if there already is a file python is going to write over it and this you could also use to create new files for example if i renamed this test to new file that is terrible spelling if i run this now with proper spelling and open the folder we now have new file python has created a text document and that is basically all you need to get started with reading and writing into text files let's do an exercise i want you guys to create a new text file and draw a tree in it kind of like the tree we have seen all the way at the beginning of this entire series so pause the video now and try to figure this one out yourself i first of all want to comment out all the stuff i had earlier and now i want with open and let me call this tree dot txt for this one to work i need w as an argument and i want to call this one as let me call it the tree file inside of here let me save the tree inside of a string and this i want to do with the triple quotation marks that are going to be assigned to the tree string i have to work with white space and access to create a tree so three axis i hope i can still get it just right something like this should be good and i realized i have one quotation mark too much now that i have that i want to have my tree file and i want to write in it what i want to write is the tree string now i can run this we don't have an error that's a good start and if i open my folder once again we now have a tree file and inside of that we have a tree although i messed up here a tiny bit i think if i put this x on the next line run this again and open my folder run this now and there we go now we have a tree or an arrow but you get the idea and all right with that we have file writing and file opening for this part we are going to look at deleting stuff which is something you can do but you rarely need to let's talk about it the way you can delete something in python is with the del keyword this one here all you have to do is specify what you want to delete and python gets rid of it this would even work with variables if you delete them they are going to be gone thing is you basically never need it that way it hardly ever happens that you absolutely have to get rid of a variable instead most of the time you only need to delete values from a list and this is what i am going to focus on for this part let's have a look at it i want to start by just creating a basic variable let me call it a and give it a value of 1. inside of my python file i want to create one variable let me call it a it really doesn't matter because we are going to delete a if i print a now hyphen is going to be unhappy because a is not defined which is python's way of saying a does not exist which makes sense because we just deleted a that's kind of all you need here the thing is this kind of operation you basically never do there just isn't a need for it although if you are going to learn other languages they are much more aggressive about clearing memory after you used something so you might see something there but in python all you ever really are going to do is remove items from a list i guess let me reuse a and i want to assign it one two and three and i want to delete individual values from this one here delete is where you are going to see it the most it removes an item by index so for example i could write delete a and then the index 1. if i now print a we are getting an error message because up here we still have the problem if i comment this one out run this again we now can see one and three the reason we can't see two anymore is because we deleted the item with the index 1. inside of a we have index 0 index 1 and index 2 and we have told python to delete the 1 with the index 1. that's all that happened here what you could also do let me comment this one out you can remove an item by value and this should be a comment so let's say in this list you want to get rid of any value that has a free but you don't know what index that three is on for that python or while a list has to remove method all you need is a dot remove and then specify what you want to get rid of in my case a free if i now print the list we only get one and two the three has disappeared besides that let me comment this one out you can also use the pop method what this one does is it removes an item again by index although the default value here is negative one after i have run this i can print my list again and we again get rid of the three all the way at the end the difference between pop and remove is that pop pops out the value we have deleted meaning we could print this one as well so if i run all of this i get free the value that was deleted and then the list itself with this line here and finally you can just clear the entire list and this i think we have actually already seen all you need is a dot clear and if you then print the list it is going to be empty most of the time this is kind of overkill but well it is something you can do and with that you have a couple of operations to get values out of a list or well remove items from a list in this tutorial we talk about objects and classes and well more specifically i will talk about what objects and classes are i will cover how to create and use them we will cover dunder methods and also simple and complex inheritance and finally i will cover how to use classes in practice and well let's get started by talking about what objects are in the first place and well an object is just a container for variables and functions for example we could make a video game with lots of monsters and i think video games are really good way to explain objects so i will stick with that for this entire video but basically for the monster we are going to create we want to have variables and functions and in this case i want the monster to have some health some energy stamina and damage and you could add whatever else you want in here it's really up to you and then besides that the monster should also be able to attack to move to animate and again you could add whatever else you want in here and what you have to understand here is that these variables and functions only exist inside of this monster object it's very similar compared to the local scope of a function if we tried to get this health outside of the container it wouldn't exist because this health exists only inside of a monster object although in terms of naming there's one minor complication and that is special names all that really means is that variables inside of an object are called attributes and functions in an object are called methods and that is more or less the only difference the only reason why this exists is so that we are a bit more specific with our language for example when you talk about health with somebody else for your game you really want to emphasize that you don't talk about a global variable you talk about the specific attribute of one object and one more thing methods should actually be familiar to you because you are using methods very very often in python anyway for example when you call the upper method on any kind of string you are turning every letter inside of that string to an uppercase letter and that is also a method and that is the same kind of method we are seeing here essentially a string in python is just another object with functions inside of it or methods to be more specific this also applies to integers floating point numbers booleans all of that stuff is basically just other kinds of objects that python creates but that's something we don't have to worry about for now now another thing that is really important to understand is that it is possible to have multiple objects for example i could create three different monsters and each of these monsters could have customized attributes these red pieces of text here so my first monster has 90 health 20 energy the next monster has 60 and 40 and the final monster has 40 and 10. so when you create an object you can give it custom attributes however this does not apply to methods and as you can see here monster 1 monster 2 and monster 3 all have the same methods and these can be customized to an extent but not nearly as much as the attributes that's something you do want to keep in mind but still each object has its own attributes and methods meaning that this attack here and this attack are not the same function or well the same method they always apply to their respective object and what you can also do is have objects interact with each other for example if monster 3 attacks one stat 2 we could run some code to reduce the health of monster 2 from 60 to let's say 20. and that actually brings us to a really important topic and that is object oriented programming or oop in short and all that really means is that you are organizing your code via different objects and then you make these objects interact with each other and this approach is basically how almost all large projects are made in any programming language or at the very least any modern programming language meaning if you don't understand classes you will be very much lost and well you will have no idea what you see when you look at larger examples of code here we have a couple more objects we still have monster 1 and monster two but now we also have a player we have an obstacle and we have a menu and all of these have slightly different attributes and slightly different methods and just to talk about how these different objects can interact with each other the one we have already seen is that monster 2 could for example attack monster 1 and then monster 1's health be reduced from 90 to 60. and if monster 2 is attacking it might reduce its own energy from 40 to 20. so attacking isn't free for the monster what we can also do is have an object without any methods like the obstacle here and all the obstacle is is well an object with a position and a size and this we could use for example with the move method of any of the other classes so the player and the monsters all have a move method and this could interact with the obstacle and let me clean this up something even more interesting if you look at the player this one here and the menu those two do look very much connected because the player has one method called menu and what this one would do is to create or the very least open a menu and then when we create the menu we are passing in the player itself so this player here is going to be passed in as one attribute of the menu object and this is totally fine to do you can totally add a function or an object inside of another object as an attribute and then this select could for example change the weapon of the player and we could close the menu as well and i hope this makes sense the main thing you have to understand is that objects can interact with each other and this is how you want to organize code it makes it very easy to work with and especially for larger bits of code this approach is essentially mandatory or at the very least it's the easiest way to organize it and let's actually do a practical example here is zelda like game that i made a while ago and basically everything you see on the screen is an object for example right in the middle we have the player and that's one object and we also have this raccoon here and this spirit and each of those are one object and beyond that each of these flames here is its own object and these are only created when the player is attacking with some magic and finally in the top left the bottom left and the bottom right you can see some ui elements and they are all part of the same object and this object is very much related to the player so those two work together very closely and besides that each of these pillars and trees and rocks and statues they are all objects that i created just for this game so i hope that illustrates how useful objects are that make it really easy to group together code chunks that should belong together and for a bit more detail the raccoon for example has three attributes health speed and damage and the methods attack and move and all the other objects would have similar attributes and methods and with that we have objects now the next question is what are classes and this is fairly easy to explain as well the class is basically a blueprint for an object meaning whenever we create an object we first have to create a class and a class can also accept arguments to customize the object we are creating for example this would be a class we have a class and this class has two attributes health and energy and right now the value for both of these is not being set this we do when we actually use this class to create an object but this class also has two methods attack and move and those do not change and basically what we're doing is use this class to create the object and in the process we are giving it the specific values for health and energy so in this case the monster is going to have 90 health and 20 energy and this process we could do as many times as we want for example earlier you have seen monster 1 we had monster 2 monster 3 and we could continue with monster 4 5 up to an unlimited number of monsters and that is essentially the main idea all you really have to understand is that we always need a class to create an object now what we can also do with classes is that one class can inherit from another class and the resulting objects will have attributes and methods from both classes for example let's say we want to create a shark class and this one right now only has speed for the attribute and byte for the method and this class will be fairly limited because we well don't have any attribute for health or for energy and we also don't have any kind of method for move or attack but we don't need to because what we can do is have this shark class inherit from the monster class and this means this shark is going to get the health and the energy from the monster parent class and that is also going to get the attack and the move from this class as well meaning when we actually use the shark class to create a shark object we are going to get health energy and speed for the attributes and attack move and byte for the methods and i think i should use better colors here in the shark class health and energy are coming from the monster class same with attack and move those two are coming from the monster class and then speed and byte are from the shark class and this would allow us to reuse code quite extensively for example we could have a lot of different monsters we could have a shark some flying enemy some armored enemies lots more and they all inherit from this one monster class and with this approach we would save a ton of writing in terms of code and on top of that if we change the move method for example it would affect every single other class as well which is very useful if you want to make some changes and make it affect every single other class and especially with larger projects this is just about the only way to manage them and let's do an example again here is the screenshot from earlier and we have a monster class we have another monster class and those two have the same attributes and methods although with different values and besides that we also have the player and what is really important to understand here is that all of these inherit from the entity parent class and this for example contains the method for movement because all of the monsters and the player move in the same way so they could share this method quite easily and just to emphasize it i do want to go over the advantages of classes and objects and the first point here is that classes and objects help you organize complex code and the second point is related classes and objects also help you to create a reusable code and just from these two points i hope it becomes obvious that if you want to create some really large projects let's say a really good looking game you need objects and classes without them it's still possible but significantly more difficult besides that classes are also used everywhere meaning if you don't understand them you will be very much lost as a matter of fact in python there are quite a few modules that require you to use classes for example pygame tkinter and matplotlib respectively the model you use for games for guise and for data analysis they all work with classes primarily so if you don't know how to use it you pretty much cannot use these modules or at least you could only use a very small part of them and there's one more point that i haven't mentioned yet and that is that classes make it much easier to work with scope i will talk about this in more detail later but if you struggled so far with getting information in and outside of functions you will really like classes that make it very easy to work with different levels of scope so these are the arguments where you would want to use classes and objects however you can write code without using objects at all and this is very common especially for beginners and let me illustrate the problem here the yellow line is the need for classes and especially when you start writing code let's say you are somewhere here and your average program is something like 50 lines of code in this case there really isn't any need for classes because well your code is very simple and there isn't any need to organize complexity however the longer and more complex your code is becoming the more you will need classes and this ramps up really really fast but as long as you are in this area here it well it's very tempting to never use a class and ignore them entirely and this especially as a beginner you really want to avoid so even though when you are here i would really recommend you to use classes even though it's not strictly necessary in your example just to practice for more complex code because when you are an actual software developer you are never going to write just 50 lines of code most of the programs you are going to work are somewhere here with a few thousand lines of code let's say 2000 and if you are up here and you don't use classes you are going to be in a lot of trouble but all right with that we have the theory of objects and classes and for the next part we are actually going to create and use objects so let's have a look at some code here i have a completely empty sheet of code and the first way i want to do is to create a class and this you do with class and then the name of the class in my case i want to go with monster and here already we have to cover something important and that is the naming scheme so far in python what you probably have written is something like monster and generally you always used the snake case styling for any kind of text so why is this different here and well in python by convention last names are always written in the camel case so camelcase looks like this where you don't have any spaces between words or well any underscores but any word starts with an uppercase letter and this is different from normalpython where variables are written in snake case where everything is lowercase and a space is an underscore and this isn't strictly necessary you can call a class monster with a lowercase m just fine this is purely convention but all the other python requirements for naming still apply for example a class couldn't start with a number and we also couldn't have a space in between so we don't have to learn any new naming scheme now next up what you have to do is a colon and now in here we can work on the attributes and methods of our class and for now i just want to create some basic attributes let's say i want to give this monster some health and for now i want to have specific numbers let's say 90 i want to have energy and this one should be 40. so now we have a class and what we have to do now is turn this class into an object and this we do by typing the name of the class and then calling it by using brackets again very similar compared to functions and this is going to return the object so we have to capture that in a variable and this very often is written like this and here i hope you can see why we have the different naming schemes to python this name here and this name here are two completely different things because one starts with a lowercase the other with an upper case although to us as the programmer we can tell that those two are related because they basically have the same name and for that reason we are usually writing class names in camel case and variable names in snake case it makes it very easy to connect these two and clearly indicate that they are connected although you don't have to do any of this you could totally call this i don't know hamster and this could be lowercase it's totally fine all of this is just convention although you should follow conventions they are there for a reason but i can run the code now and i am not getting an error that's a good sign and now what i can do i can use print and monster dot let's say health and now if i run this we are getting 90. and this knight here is coming from this health and the same would also work for energy in just the same way so we get 90 and 40. now just to emphasize that both this health and this energy only exist inside of this class let me print health by itself that is horrible spelling health and if i run this python is going to give me an error and we have name health is not defined meaning python cannot find this health anywhere in the global scope which makes sense because there is no health in the global scope we only have health in the scope of this monster class and let me add some comments here to make this a bit more readable we have attributes and besides that i also want to create methods and those work kind of like functions we again need the define keyword or def and now we need a name for our function and for that we have the exact same naming scheme for normal functions for example attack would be a perfectly fine name and after that you need a colon and then let's say for this attack method i want to keep it simple and just print the monster has attacked and now i can call monster dot attack and don't forget the brackets and now if i run this we are getting an error and this error says that monster.attack takes zero position arguments but one was given and this is probably very confusing because when we called this method here we didn't pass anything inside of it and the method itself doesn't have any parameters so why is python being so weird here now the reason why this is happening is that whenever we call a method so a function inside of a class what is going to happen is that python automatically passes a reference to the object created by the class as the first argument into the method in this first argument we always have to capture with some kind of parameter meaning a method always needs at very least one parameter for example i could just write monster in here and if i run this now we get the monster has attacked and let me just print what we actually get so i want to print the monster we get as an argument in here and what we get is main monster object at somewhere in our memory and well in my case i don't really care about this monster so let me remove the print statement but i do have to keep this first parameter however once we have the first parameter i can add as many custom parameters as i want for example i could add the amount of damage here and i could let's say print the amount with an f string and i want to say the amount of damage was dealt and now when i call this method down here i can pass in any number i want and i get the monster as attacked 40 of damage was dealt that does not make sense in terms of grammar let's try this again but the damage was dealt that feels much better what is really important to understand here is that this monster or more specifically the first parameter of any method always references the object created by the class so this class up here creates an object and then this monster is a reference to that object the monster is not a reference to the class itself and this is really important because that way you can create multiple objects that always work with the first parameter here for example i could have monster 1 that i'm creating from the same class and now call monster 1 dot attack let's say with 10 in here and now the first argument passed in here and the first argument passed in here are different essentially we are passing this monster in here and this monster one in here that way this first parameter is really flexible it can target any kind of object or more specifically any kind of object you are using it with i don't want to do this one right now but what you could also do if i add another line here you could for example print monster dot energy this once again would target this first parameter and then this first parameter targets the object itself which in this case is going to give me the energy here the one i've just drawn over but if i run this we are getting 40 the 40 we have seen from here and this right now is created in a class but later on when we use this class to create an object every single object would have this energy attribute and this is what we are referencing here and what you could also do is increase this amount so monster.energy minus equal 20 and if i print it now we get 20. and i hope you can tell how useful this can be because if you imagine that this monster here is the global scope and these attributes are global variables if this attack was just a normal function then this would not work because you would be creating a local variable that wouldn't work with the global ones but because of this first argument that the method always gets we can influence variables or well attributes outside of this function which is incredibly useful so i hope this kind of method here makes sense as a matter of fact let's practice this one i want you guys to create another method for this monster and this one should be called move and it should accept one parameter besides the reference to itself and that is the speed of the movement and then inside of the method you should just print that the monster has moved at a certain speed it doesn't really matter what you put in here as long as it is working so try to figure this one out yourself alright let's try together now i want to create a method called move and in here i want to have speed as a parameter however what we have learned from the attack method is that we always need a reference to the object as the first parameter meaning the first parameter here should be something for the monster and it really doesn't matter what you call it so i could even write something in here it would still work and now in here i can print the monster has moved and let me add another line with an f string that says it has a speed of and then the speed and let me fix the typo and now i can call monster dot move and add let's say a 10 in here and let me comment out monster.attack and let's see what we get the monster has moved it has a speed of 10. so all of this seems to be working very nicely now obviously calling this first parameter something is a bit confusing and as a consequence in python there is a convention that this first parameter is always called self and this applies to all of the methods meaning this is what you are going to see most of the time and what i am going to use as well you don't have to do it but i think it makes the most sense although i do want to emphasize that this parameter here and this parameter here have no relation whatsoever they are entirely separate but it is totally fine to call self here and self here the names are not in conflict with each other and all right with that we have the very basics of using classes and objects although right now we do have a problem that our monster always has the same health and the same energy so even if we created multiple monsters so what i could be doing is monster 1 monster 2 monster 3 and let me get rid of this one here all of these monsters would have the same amount of health and the same amount of energy and they all have the same attack and move method which is fine to an extent but i do want them to have different amounts of health and different amounts of energy and to implement that we need another concept and that is called dunder methods so let's talk about that one and the dunder here just stands for double underscore meaning we are talking about a double underscore at the beginning and at the end of the method but it's important here we are still talking just about methods so essentially we are calling a specific kind of function and let's talk about why it's special a dunder method is just another method the thing that makes it special is that it is not called by the user instead it is called by python when something else is happening for example there is the done therein method and this one is called when the object is being created another example is the lan method and this one is called when the object is passed into the len function and besides that we also have done the apps and this one is called when we are passing the object into the apps function and that is really the entire idea it honestly isn't that complicated the most important dunder method you have to understand is done their init this one you are going to be calling all the time but let's actually do all of this in code that should make the most sense all right here we have the class i created earlier and what we have seen earlier as well i can create monster one and that is just going to be the monster and i can also have monster two and if i now print monster 1 dot health and monster 2 dot health we get the same number because we always set health to 90. there's no way to customize it and basically what i want to do is as soon as the class is being created then i want to create these different attributes and instead what i want to do is when this class is being created i want to create this health and this energy with custom values and for that to work we need to define a dunder method and the one we need is called dunder init and this is just going to be another method like attack and move we are just calling a method meaning the first parameter here has to be a reference to the class itself and for now let me just print the monster was created and do pay attention i am never calling the init method myself but if i run this we get the monster was created the monster was created and then 90 and 90. and what that means if i minimize this a bit every time we are creating a monster so first here and then here then we are calling this dunder method and this standard method we can also give some parameters for example we could specify in here the amount of health and the amount of energy we want and well i hope you can see where this is going basically what we can do now is we can set self.health to whatever health parameter we pass in and we can do the same thing for energy and the names here might be a bit confusing so let me add a bit of white space and explain this self.health here is referring to this self.health of the monster class whereas this health here refers to this parameter and the important point here is self because this one specifies where health belongs to i hope this makes sense this is something you see fairly often let me remove the white space again and now when i am calling the monster i can either pass in arguments or named arguments let's say for the first monster i want health 10 and energy 20 and for the second monster i could specify health being 50 and energy being 100. now if i run all of this we get monster 1 health is 10 and monster 2 health is 50. and this 10 here refers to this 10 and this 50 is referring to this 50 here meaning now we can have custom attributes and what is even better since this self is a reference to the class itself we can just create the attribute in here which means we don't need those lines at all it would still work without them if i run this now this is still working just fine and this is what you see most of the time where the class by itself doesn't have any attributes we only create attributes when we are creating the class with the init method or the done therein method and then inside of the other methods we are calling self all the time to refer to the class and i just realized this should be self instead of monster so we're capturing this self here and what you are going to notice is that you are going to write self all the time it is a little bit annoying but well it is manageable and well with that we have the first init method but there are quite a few more although those you wouldn't use that often and just to keep things simple let me get rid of monster 2 and i don't want to print anything at all another danda method i talked about in the introduction is len and this one needs self and no other parameters and in here we just want to return something let me return the number 5 and what this one is going to do is if i call len and pass in monster1 in there and this len just as a quick recap if i pass in any kind of string into len let's say test and if i print the result i get 4 or the number of characters inside of the string i guess i could also pass a list in here that might make a bit more sense so i have a list with 5 entries and the length of it is 5. but what i can do now if my monster has a len method i can pass monster 1 in here and it would return 5 as well and any number that is being returned here is going to be passed into the length function and i guess for something slightly more relevant instead of returning a number i could return self.health and now if i run this i'm getting 10 or the amount of health my character has which is 10 right now and another example we have seen in the introduction that works in the same way is abs and we need dunder on both sides and in here self and again i have to return something so return and for this case let's say self.energy and if i copy this and pass it into absolute i get 20. now usually absolute is if you have a negative number and you want to make sure it's always positive that's what it does but well you could theoretically do whatever you want with it now what you can also do is one specific function in python and that is called dir short for directory i think or directory listing or something like that basically what it does you pass in an object and then you want to print the result and what you get from that is all of the dunder methods and at the end the attributes and the normal methods and in here you can see a lot of stuff actually and what you have to understand here is every time we are creating an object python already gives it some dunder methods for example here we can see the dir method and this one is necessary for the ear function to work it kind of works like the len method the one we have created ourselves or the abs function and i guess the one we have just created is the init method this is the really important one and most of those you really don't want to worry about because well they're just there to make the class work but we don't really have to worry about them although some dunder methods in here can be very useful for example dander dict is well it's kind of a dictionary but not in the way you would expect basically how you would use that one let me print it right after the monster i want to print monster 1 and then dot dunder dict and in here this is the one exception where this is not a method this is just an attribute so no brackets afterwards and this one gives us all of the attributes of the method inside of one dictionary can be quite useful sometimes although you wouldn't be using it too often now another way to get this dict here is to let me duplicate the entire line you can call the varus function and pass in monster1 and this one is giving us the very same thing although i have hardly ever used either of these most of the time you just don't need them and with that you should understand dunder methods reasonably well now there are quite a few dunder methods that get a bit more advanced i only covered the really fundamental one some other examples of thunder methods is for example dunder call and in here we only need one parameter self and in here we can return something else again and let me dissipate dunder on both sides let's say the monster was called and what this dunder call does is it essentially turns our object into a function meaning i can call monster1 and then add brackets afterwards and if i do that we are not getting anything because i would have to print what i get so i have to put brackets around it and call print and now the monster was called i guess a cleaner way of doing this is to return nothing and just print this string so now if i call monster1 we get the monster was called and nothing is being returned and when you create a function in python it basically behind the scenes creates an object with this standard method here and this we can just create ourselves it really isn't that complicated and what we can also do is to add and subtract numbers and this you would for example do with dunder add and in here you need two parameters first of all self as always and then you need some other number and what you can do in here is return something let's say i want to self.health and then plus whatever other number i get and now that i have that i can print monster 1 plus 10 and if i run it i get 20 which is if i find it so the health of my monster is 10 and i add 10 towards it so i get 20. and i guess to make this a bit more understandable let's add 55 in here and i get 65 which is 10 plus 55 and well that is a couple more dunder methods they can be incredibly useful although most of the time you are only going to use thunder init this is the one you absolutely have to understand but i guess they don't really get that much more complicated so it shouldn't be too hard all right now for the challenge for this part i want you guys to do some research because there's another dunder method that is called str and i want you guys to look up online what it does and how to use it in code alright here we are in the official python documentation and there you can see dunder string or dunder str and basically what it does it's called by the str object built in function format and print to compute the informal or nicely printable string presentation of the object basically what it means is that this object is going to return some text so let's have a look at it here we are back in the code and i only need one parameter and that is and now i have to return some kind of string and the string i want for this one let's say a monster and what i can do with that let me get rid of this print statement and instead i want to print str or monster one and this is going to return a monster and we don't even need this str because print is trying to find a string so let me duplicate this line and remove the str and just have monster 1. if i call this now i still get a monster and this can be a really nice way to look at your objects and see what they are doing because if we didn't have this done their method let me comment it out and run this again all we get is a monster object which really isn't that useful and obviously this str can return a lot more than just a simple string for example we could have an f string with health that says self dot health and energy that says self dot energy and now if i run this we get quite a bit of information by just passing the monster or the object into the print statement so this str can be really really useful and with that we have covered quite a few dunder methods if you look online you can find even more but well most of the time you are not going to need them this is very often a fairly advanced topic except thunder init this is the one you are going to use a lot all right with that we have dunder init methods covered and if you understand all of this so far you can actually understand python itself quite a bit more let's talk about this one in the next part and the one thing i think that confuses beginners quite a bit is that every single thing in python is an object meaning every time you see a string or integers you are going to see an object just like the objects that we have created so our monster and this even includes functions which are just objects with the called under method and i'm going to show you some examples in just a second but most of what i will cover here isn't really important i just want you guys to understand how it works so you don't get confused later on and there's another thing that i believe is very often confusing and that is the difference between a function and a method and the reason why this is confusing is both just execute a block of code so in terms of functionality they basically do the same thing however the difference is that a method always belongs to an object it doesn't matter if the object was created by us or by python and a good example here would be using a string so if we have a function this would be len for example and we can pass a string into it this will return four and a method would be something with dot and then upper for example for string returns uppercase letters for this string and that really is the entire difference that's the main thing you have to understand and it doesn't matter if we create the method ourselves or the function ourselves or if it's created by python and the reason why these are different for example is that the lan method could work for lots of other things as well for example you could pass in a list in here you could pass in a dictionary or a tuple it would still work with different data types whereas upper only works for strings you couldn't add a list with upper that one would not work so it makes sense in this case that upper only exists as a method for strings whereas the ln should be a function so you can pass in different kinds of objects in here and they would all work you could perfectly find create some kind of len method for test and it would work just fine although then you would also have to create a lan method for lists for dictionaries for tuples for all of that stuff and it would be quite labor intensive so all we're doing here is to keep things more efficient but all right let's have a look at some code and let's have a small deep dive into python here i have a completely empty sheet of code and what i want to create for now is create a test variable and this one should have a string let's call it a doesn't really matter what it is and what i can do now i can call my print dir and pass in my test in here and if i run this now i am getting a bunch of dunder methods and after they are over starting from here i get a couple of methods and attributes now the dir method doesn't separate between methods and attributes so we just get one big list but well basically what we get here is an object and anything in here you could just call like upper or title or strip all of these are very simple methods and along with that we have the len dunder method and this is what's being called when we are passing this string into the len function and besides that what you can also do let me get rid of this test and instead create define test and then here i let me just add pass so this is a function with the name test and i'm still printing dir test so if i run this i am getting another object and this object is special because it has a call dunder method meaning when we're adding brackets afterwards it is being executed and that's basically what a function is in python it's just an object with the dunder call method it really isn't much more than that although we do have a couple extra things that make this a bit more special but that's the main idea and if you really wanted to you could even store this function inside of a variable and this works because the function is an object so this is just going to be an object meaning if i now print a we are getting the same outcome although what we can even do now let's call it another attribute that is not how you spell that and this could just be 10 and now if i run this our function has another attribute and again this is working because functions are just objects although in practice you wouldn't really do this there's no reason for it but what is much more common is that you are passing functions or methods into other objects so what is much more common let's say for example a simple add function and this one takes a and b and is going to return a plus b obviously this still isn't particularly useful but i just want to illustrate what it does and now i can create a class and let's call it test and in here for the dunder init method i want to have self and i want to add an add function and now inside of this dunder init add function i can set an attribute self dot add function and this should be the argument we get from the parameter add function and now when i create this test i have to pass in one function and i want to have this add function here so i'm going to add it in here and let me use a named argument so it's a bit easier to see what's happening and in here it is really important that you don't add brackets because we don't want to call this function we want to get the function itself so the object of the function not what's being returned and if i run this now this is working just fine and even better what i can do i can call test dot add function and i can pass in let's say one and two and this is not doing anything because we're not printing anything we're just returning something so if i put all of this into a print statement now we are getting free and i hope all of this is making sense this is a really important thing to understand right now this here is creating an object of a function and this object we can pass around for example we could pass it inside of a class and this would work just fine and then inside of the class we can store it inside of an attribute and then call it from outside of the function this is working just fine there's no limitations on this and this is something you really want to practice because passing around functions is a really important thing to understand and i guess since this is really important we should practice this with a slightly larger exercise and let me add some comments that should help quite a bit first of all i want you guys to create a monster class with a parameter called funk and this funk should be stored as a parameter that's the first step after that i want you guys to create another class and this one is called attacks and this has four methods we have let me put it on another line we have byte strike slash and kick and for each method you just print some text basically whatever you want i would recommend to print kick slash strike and byte but it really doesn't matter and let me add proper white space here and then for the final step i want you guys to create a monster object and give it one of the attack methods from the attack class and remember here that methods are basically just functions the only difference is that they are part of an object so this should work kind of similar compared to what you have seen here but well it's going to be slightly different so experiment with this and see how far you get all right let's try together now first of all i want to create a monster class and this i do with class monster and in here i want a dunder init method that needs self and a funk and this funk i want to turn into an attribute so self dot func and i want to capture the parameter or the argument we get here in there and this is covering all of this next up we have to create another class so class and this one is called attacks and in here we don't need a donderended method instead i want to create define let's start with byte and we need self as always and in here i just want to print byte and since we need four attack methods let me copy this a few more times and now besides byte i also want strike then i want slash and finally i want kik and i think you can already tell why this might be useful it's a very neat way to organize all of your different functions if you have a really large game with hundreds of different attack methods this may actually be really nice to organize all of this all right now finally i want to create an object of my monster so monster in lower case and then here i want to have my monster and now we have to define a function now this you could approach in a couple of different ways although there's one way that is definitely wrong and it's very tempting to go this way you could write something like attacks and then dot byte and if i run this code we get a 3 and this 3 comes from up here so let me comment out all of this and if i run this again now we can't see any difference but if i run monster.funk we are getting that attack.byte is missing one required positional argument and that is self and this is a reasonably common error the reason is that this here is not returning an actual object it's returning a class and this is confusing python now an easy way around this is to actually turn this class into an object by calling it so adding brackets afterwards and now if i run this we are getting byte and basically what is happening here think of this in terms of return statements when we are calling this attacks it's returning an object and then inside of this object we are getting the byte method which is this byte method here and if you don't like how this looks what you could also do is create a separate object let's call it attacks and in here i could add this attacks and then call attacks.byte and we will get the same result and this is something we are going to explore quite a bit more that you pass different things around different classes so that in this example we are taking the byte method and passing it into another object and this is getting incredibly powerful and really important to understand if you want to understand more complex code because a key part of object oriented programming is that you work with different objects and make them interact with each other and this example here so this part down here is one example to make classes interact with each other and i would really recommend you to practice this in your own time it's really going to be helpful but all right with that we have covered a really basic deep dive into python although i do want to practice this a bit more and there's one important topic i do want to cover and that is going to be scope in terms of objects and classes let's talk about that one in the next section alright so let's talk about classes and scope and this is one of the really powerful parts of objects that make it really easy to work with this scope but let's talk about it basically every method so every function inside of a class has a reference to that class and because of that it's really easy to get and change class attributes and because of that methods are much easier to work with than normal functions meaning they rely much less on parameters the global keyword and return statements although you can still use them if you really want to and sometimes that does make sense but you are going to do this much less often and what is even better objects can be influenced from outside of the object itself and even from the local scope of a function basically objects you can change wherever you want there is no limitation on the scope for them which makes it even easier to work with them but i guess let's have a look at all of this in code that should illustrate this the best here i have a completely empty sheet of code and first of all i want to illustrate the problem so let's talk about scope again let me add a comment scope problem and let's say i have a game and i have some kind of health that right now is 10. and for this health i want to have a function let's call it update health and this one takes an amount and what it really does is it adds that amount to the health a super simple function just about the simplest function you could write now what i want to do let me say i want to print health then i want to update my health with 20 and then i want to print my health again and if i were to run this what do you think is going to happen just think about it and well if i print it we are getting an error and what python is unhappy about is that we have a local variable health referenced before assignment and what is happening here is that this health to python is a local variable let me remove the error messages they are getting a bit annoying that's easier to work with essentially this health only exists in the scope of this function here or in other words this health here and this health here to python are two completely separate things and then when we are trying to update this health with some amount i even cannot find any starting amount for this health as a consequence we are getting an error and there are a couple of ways to get around this for example we could use global health that's probably the easiest one and now this would work although you could also use return statements but it really isn't the cleanest way to work with this so this is not great so let me comment it all out and let's do the same thing with classes so let me create a class monster again and in here i want to create a dander init method that needs self health and energy and then as always i want to set self.health equal to health and self.energy is going to be energy and now let me create an object from this class and let's give it a health of 100 and energy 50. it doesn't really matter what values you put in here so now i can print monster.health and we are getting a hundred so this one works just as expected and now what we can do we can just get monster.health and add let's say 20 to it and if i now print monster.health again we're getting 120 ie the sum of 120. and what is even more powerful let me uncomment this function up here and now instead of the health i want to get my monster.health and update the amount and this would still work if you are using an object so let me get rid of these two lines here and instead call the function update health and let's say i want to raise this by 20 again and now if i print monster.health after calling this function i get 120 meaning even inside of the local scope of a function you can still update anything inside of an object but the simple reason that here python is very clear about what kind of object you are talking about this monster is not going to become a variable in the local scope and this monster could be updated anywhere it could be in the global scope it could be the local scope of a function it could be in the scope of another method it could even be inside of the object itself so this monster python just doesn't care which makes it really easy to work with so i guess one thing you do see fairly often is inside of a class you have something like let's call this one update energy and then here we need self and let's add an amount in here as well and all i really have to do to update this self.energy would be to first target the attribute itself so self dot energy and then plus equal amount and now i could just run monster dot update energy pass in anything i want in here and then print monster.energy and we are getting 70. and again here this is a very easy way to work with scope you don't have to worry about return statements you don't have to worry about global all you do is target the attribute and then you set it to a new value or update whatever you want that's it it's super easy to work with although if you wanted to you could use a return statement as well for example if i wanted to set energy and then here i want self and energy and let's say for this one i want to create a new local variable that i call new energy and this is going to be energy times two and then i want to return this new energy and now in my init method instead of setting energy straight as the attribute i want to call self.set energy and pass in the energy and now let me comment out this line down here to update the energy and just get the energy now we're getting 100 which is this 50 here this 50 we are passing inside of this energy here from that energy we are passing it inside of another method inside of the monster class and this method is down here we are getting one parameter and this we are doubling and assigning it to new local variable inside of this method and after that we are returning the new energy and this new energy is going to become the attribute self.energy kind of a roundabout way of doing it but it is possible to do all i really want you to understand is that you can still use return and parameters just like with any other function although most of the time you don't really need it a better way for this one would be to remove this part entirely just call set energy and then self dot energy is going to be new energy this would work in exactly the same way although it is much cleaner to read so if we run this we are still getting a hundred and i hope you understand why self is really really powerful it essentially bypasses all of the scope issues very efficiently all right let me get rid of all of this because i don't really care about it and instead i want to set self.energy back to energy all right now with that let's do an exercise to practice this and what i want you guys to do first of all create a hero class with two parameters one is damage and the second one is a monster which is going to be this object here so this object you want to pass into another class as an argument and second of all the monster class should have a method that lowers the health and i guess you can call it get damage and this one should take an amount and then this amount you would reduce from the health of the monster and finally the hero class should have an attack method that calls the get damage method from the monster and let me put this on a second line and the amount of damage is hero dot damage which is going to be the damage you specified up here which should be an attribute so i hope all of this makes sense try to implement this yourself and see how far you get all right let's try together now first of all i want to create a new class and this is going to be and the hero needs a dunder init method and here we need self and besides that i want damage and i want a monster and let me add a bit more white space there we go now i want self.damage to be damaged and i want self.monster to be monster and let me spell this correctly there we go and this would then be step number one and for step number two let me move it up a bit so it's easier to see what's going on the monster class should have a method that lowers the health and this i want to call get damage so define get underscore damage and then here i need self and i need the amount and all i really want to do in here is self dot health minus equal whatever amount we specify and this get damage i want to call from inside of the hero and this brings us to step number three and this right now we are still inside of the hero class which you can see by the indentation i probably should have actually mentioned that for the class we always define something by one level of indentation a in here i want to now create let's call it an attack method and this one itself and nothing else and all i really want to do in here is get myself dot monster and this self.monster is the monster we specified up here and on this monster we want to call get damage and all we really have to do for that is call get underscored damage and now we have to specify how much damage we want to cause to the monster and for that i want to get the damage of the hero and all we need for that is specify self dot damage and we are done and if you just read through this i hope this really illustrates why this makes a ton of sense it's basically a normal sentence we want to get the monster we want to cause the monster some damage and the amount of damage you want is selfdot damage so the damage of the hero and now with that all we have to do is to actually create the object of the hero meaning i want to create a hero object and this is going to be hero and in here we need damage let's say damage for the hero is 15 and then we need a monster and the monster is going to be the monster object we created just a second ago this one here and this we're just passing in here and now let me print monster.health and if i run this we are getting a hundred which is this 100 here but now if i call hero dot attack and this one doesn't need any arguments and afterwards i can print monster.health again and now if i run this we get 85 which is 100 minus 15. this is how this 85 comes about and to get to this point to lower the health of the monster we just had to call one method and that's it all we are really doing in here is we are passing different objects around and make them interact with each other and since we don't really have to worry about scope this is very easy to implement and again this is something you really want to practice on your own and try to work on this more to make sure you understand it but right with that we have covered scope and i guess for the next part let's talk about inheritance and inheritance really just means that one class gets the attributes and methods from another class or multiple classes and i have already shown an example earlier and that was we are the monster that we have already seen multiple times with health and energy and this right now is called a parent class and the reason why it is called the parent class is because there's a child class and this one was the shark and this shark by itself only has a speed and a byte method and what i want to happen is that the health and the energy of the monster parent class comes into the child class and the same for the method so attack and move should also be available inside of the shark class so that when i actually use this to create an object the shark object has health energy and speed for the attributes and attack move and bite meaning we are combining the monster and the shark class to create the actual shark object and the reason why we are doing this is this makes it very easy to reuse code let's say this monster here could be the parent class to every monster in our game and if we have this we never have to set the attributes health for energy for any other monster they are always available for every single class because they all inherit from this monster and obviously this is still a very simple example in an actual game the monster class might have a few hundred if not thousands of lines of code and then it really makes sense to reuse code as much as we can because then we don't have to create new classes all the time with all of these methods that we have to type over and over again and then on top of that if we wanted to make changes to how things move in the game so this method here if we didn't use inheritance and we want to make change how things move in the game we would have to change possibly hundreds of different move methods for every single monster but if we use inheritance we don't have to if we change one move method we are changing how every monster in the game moves so i hope that makes sense and one important concept here is that the class can inherit from an unlimited number of other classes this could look like this in here we could have a parent class 1 a parent class 2 and a parent class 3 and then the child class would have the attributes and methods of all of these parent classes and you can also turn this around where you have a parent class and this parent class is being inherited from by an unlimited number of other classes and this would look something like this you have one parent class and you have one child class a second child class and a third child class and all three of those would have the methods and attributes of the parent class and this here for example could be the monster class and then this one here maybe the shark class and let's say this one here could be i don't know like a bird class or something now there's one thing you do want to be aware of though and that is that inheritance can get very very complex up to a point where it really doesn't become fun to work with them and this is also the part where beginners really start to struggle because well i'm going to show you an example later on but this can get very very complex and really hard to work with fortunately this is fairly rare most of the time you just need simple inheritance and this one is really easy to implement and this one might be something like this the example we have already seen and this one should be very easy to follow so for this section i just want to focus on implementing this part here and i guess let's actually implement this one in code and let's see how this is going to look like alrighty so here once again we can see our monster class and from this monster class i want to get a shark class and this one should get the health the energy the attack method and the move method of this monster class we want to put all of this inside of the shark now passing in the methods is very simple but the health and the energy are going to be a bit more complicated so for now let me simplify things a tiny bit by commenting out the dander init method and instead setting health to something constant let's say 50 and energy to 100. the reason being that init is a bit more complicated for inheritance so i'm going to ignore this part for now just to keep things simple but we will implement this in just a bit all right now for this shark i want to create an init method by itself and this one needs self and in here i want to set this speed and now what i want to do is self.speed is going to be speed and this way we are getting our attribute and besides that i also want one method and that method i have called byte and in here we just need self and let me print the shark has bitten or whatever you want to put in here and this by itself would be a functioning class but also a very limited class because it only has a single attribute and one method it doesn't really do all that much so how can i get all of the monster attributes and methods inside of the shark and to get inheritance what we have to do is add brackets after the shark or the name of the shark class and then here we have to pass in what class we want to inherit from in my case this is monster and for start this is all you need meaning now i can create my shark by calling shark and i have to pass in a speed for the shark and let me just say i don't know 120. and now if i print my shark all of this works just fine and we are getting an object but what i can do now is get my shark dot health and this is the 50 we have set all the way at the top here i can also get my shark speed this is the 120 we set for the shark in here and besides that i can also call shark dot byte we get the shark as bitten and besides that i can also set shark dot attack and this one needs an amount so let's say 20 and this is the attack method we have gotten from here so the parent class and if i run this we get the monster has attacked and well with that we already have super simple inheritance just by adding this brackets monster we are getting all of these attributes and these methods here so that's a pretty good start now what you can also do let's say let me remove some white space here let's say for the shark this move method here doesn't really work because for the shark i want something else i want the shark to swim and for the speed i want to set since i have a speed i want to use self.speed meaning i want to overwrite this speed from the parent class and to achieve that all you have to do is define a method with the same name in the child class so in here i want self.move and now i can add a print statement in here the shark has moved and let's say print again the speed of the shark is and then self.speed and this should be an f string and now if i call shark dot move and we don't need any arguments if i call this the shark has moved the speed of the shark is 120. and what happens in here is we are first getting the inheritance from the monster and then this move here is being overwritten by this move here which means you can overwrite what you get from the parent class very easily and this you could also do with attributes although we actually have to talk about attributes let's do it right now the problem we are facing right now is that the monster has an init method let me remove this health and energy and uncomment the init method essentially the problem we have right now to give the monster the attributes this self.health and self.energy we have to first call the init method and if we don't call the init method we don't get these attributes so what we have to figure out inside of the init method how to call the parent init method so this would have to happen in here and for that we have two ways one that is a bit outdated but still works and one you actually want to use and let's cover both but you don't really need the first one anymore but just in case you see it let's cover it now what you can do you can call the parent class so monster and then call the dunder init method and now in here you have to pass all of the arguments so these ones here that you want for the parent class so we need self health and energy and these we have to get from arguments so when i initiate the shark besides speed i also want to get health for the shark and energy for the shark meaning when i actually create the object of the shark besides speed i want to set health to 100 and energy to 80. now what i get let's go over this actually the first step happens down here i am calling the shark class and i'm passing in three arguments i have the speed i have the health and i have the energy and these three arguments are being covered in speed health and energy and inside of this init method we are calling the parent init method and into this init method we have to pass in three arguments self health and energy and self originally for the parent class was the class itself so this self here which refers to this monster however now the self is going to refer to this self here which is the shark meaning when we are setting self.health and self.energy we don't talk about the monster we are talking about the shark class and this is why the self here is important and then besides the self we also need health and energy and these are just going to be arguments we have to pass in here so this health and this energy and these two we get from these two parameters here which is health and energy and those are being passed in here and with the left to move method i don't care about this one instead let me print shark dot let's start with speed let's actually print all of them so besides speed i want health and i want energy if i run this we get 120 180 the numbers we have specified here and well this can get a bit complicated but look at the init method here and the init method here and if you didn't understand what i talked about in the last part practice this yourself and then go over this a couple of times if you get used to this it's eventually going to become fairly easy although i suppose in the beginning this can be a bit overwhelming the one really important thing you have to understand is that we are calling the init method and we are passing in the arguments that we want to set in this case speed health and energy and then inside of this init method we are right now calling the parent init method and then passing health and energy so these two in there as arguments so for example we first set the health here when we are creating the object this health goes into this health for the parameter and then this parameter goes into the init method of the parent and then the init method sets self.health or the actual class and that way you can connect the init methods of different classes now this is how python used to work and this still works but there are some downsides to using it this way so this isn't really used anymore instead what we use is called super and this is a function and this super all it really does is it gets the parent class so if we have that we can just call the init method on it as well and in here we don't need self all we have to do is pass in health and energy and then we are done if i run this now we are getting the very same outcome meaning those two approaches here are functionally identical at least up to this point when we get to multiple inheritance or let's say more complex inheritance super is the much better method and this is why we don't use this initial approach anymore and i guess this one is also a bit easier to read it kinda is up to you but this is the one you do want to use and super you can actually use for a lot of other things as well for example i could call super and then call the move method of the parent and in here i have to pass in a speed let's say 10 so now when i run the code i get the monster has moved at a speed of 10 meaning when we are calling the init method of the shark class we are also calling the move method of the parent and this way even if you overwrite a method from the parent class you can still call it with super if you really want to which adds even more flexibility to all of this and this is simple inheritance which is something you definitely want to practice this is the one kind of inheritance you are going to use fairly often and the one you have to understand let's practice this one and let me add comments one more time let's do an exercise i want you guys to create a scorpion class that inherits from the monster and it should get health and energy from the parent and then besides that there should also be a poison damage attribute and i want you guys to overwrite the damage method to show poison damage kinda like what we have done for the move method for the shark pause the video now and try to implement this one yourself and see how far you get i want to start by creating a class called scorpion that is not used for scorpion there we go and this one should inherit from monster and now in here i want to create a dunder init method and this one itself and besides that i want poison dammit and now inside of the scorpion i want to set self poison damage as poison damage so we are getting an attribute and then besides that i want to define or well overwrite the attack method let me minimize the shark class so we can see the code a bit easier and i want to overwrite this attack method here and in my guess what i want i just want self because i already have the poison damage and all i want to do in here is print the scorpion has attacked and print it has dealt and then we want self dot poison damage and poison damage and this should be an f string all right so far this should have been fairly easy what i can do now let me delete all of this and let's delete a shark as well we don't need him for now and what i want to do is to create an instance or an object from my scorpion i am really bad at typing scorpion and here i bought my scorpion and right now we have a poison damage i don't know of 50. and now if i type scorpion.attack this is working the scorpion has attacked it has dealt 50 poison damage this shouldn't have an underscore there we go it has dealt 50 poison damage this looks much better meaning what we have so far we have a scorpion with poison damage and we have overwritten the attack method and since we are inheriting from monster we're also getting this move method here meaning my scorpion can also move at a certain speed let's say 5 if i run this and let's make this a bit larger we have the attack method for the scorpion and we have the move method but what we don't have let me get rid of those two we don't have scorpion.health for example this attribute doesn't exist right now because monster only gets these two attributes once we're running the init method so what we have to do in the scorpion called the init method of the parent class which we get with super and then dunder init in here and if i scroll up the monster class for the init method needs two arguments health and energy so let me comment those two and in the united method i want to pass in health and energy now these numbers have to come from somewhere although they don't necessarily have to i could for example just set static numbers in here let's say 50 and 10. if i run this now we get 50 for health because all we are doing here is calling a function that is under init and we're just giving it different arguments although this lacks a lot of flexibility so i don't want to do it but we could if we wanted to instead i want to get this health and this energy from the init method of the scorpion class and in here just to be specific about what we are doing let me name this scorpion health and scorpion energy and somehow my brain always wants to add a tea to scorpion i have no idea why and now when i call the init method for the monster my health should be my scorpion health and my energy should be my scorpion energy when i am creating the actual object i want to have let me use named arguments that makes it a bit easier to read my poison damage should be 50 my scorpion health should be 20 and my scorpion energy should be 10. and now if i run this we get 20 for the health of the scorpion because remember we are only calling scorpion health the parameter so this is scorpion health here we don't actually set this parameter as an attribute instead what we do we are using the health attribute of the parent class and this gets the value of the scorpion health so our scorpion doesn't have scorpion health as an attribute it just has health and along those lines we also have energy if i run this we get 10. and i hope this starts to make a bit more sense this is definitely something you want to practice if you only partially followed along this is a really important concept to understand and definitely something you are going to see all the time and this you can actually make quite a bit more complex with well more complex inheritance so let's talk about that one and basically what that means so far we always had one parent class and then a child class so a pretty immediate connection something slightly more complex is you have a child class and two parent classes this is something we are going to build in this section but if you really wanted to you could do something like this and it would still work now maintaining something like this is going to be a ton of work although once you have it this child class is incredibly powerful because it gets information from a lot of parent classes so especially if you create something really large this is something you do want to be able to understand but for now especially if you're a beginner and this is the first time you've really engaged with objects i wouldn't recommend to worry about this too much because it gets overwhelming very fast instead make sure to understand this scheme if you understand that one you should be able to follow along with this one as well but for now just practice objects in the first place and once you have a better grasp of objects engage in this one so let's talk about how we could create something like this and this i think is best done in actual code so let's have a look how we can work with this now here i have some code already i have the monster class we have seen quite often by now this one i hope is familiar at this point besides that i also have a fish class now and this one is a very simple class all we have is an init method and this one sets a speed and has scales and besides that we have a swim method and this one just prints swimming at the speed of whatever the speed of the object is going to be and what i want to do i want to create my shark again but this time the shark is not just going to be inheriting from monster it is also going to be inheriting from fish so the first thing for multiple or complex inheritance is that all the objects you want to inherit from should be here in the brackets after the name of the class and in here you could add as many other classes you want there could be class 3 class 4 class 5 as many as you want there isn't really a limit and now inside of this shark i want to set a dunder init method and in here we always need self this one should make sense by now and besides that for the shark let's say i want to set a byte strength and then inside of this init method i want to self dot byte strength is going to be byte strength this one should still make sense it's quite straightforward but the more complex one is if i now want to call super and then dunder init now we have a problem because i have no idea what to put in here and the question here is what arguments should go into this inhibit method should i add the arguments for the monster class or for the fish class or both how would this work and there are a couple of things you have to understand to solve this problem the first one is called the mro or the method resolution order and what this really means is let me add a comment here mro or method resolution order what this basically means is in what order the parent init methods are being called and this you can get by just printing and i want to get the shark class not the object the class itself and call mro on it and this is still going to work and if i call this we are getting invalid syntax because the question mark here is not something python likes so let me comment it out for now and now let's run this again and now we can see the mro or the resolution order and basically what it means is in what order python is going to go through the classes we start with the shark itself this one should make sense this is the class that we actually work in so this is where we want to start next up we are looking at the monster class then we look at the fish and finally we look at a generic object and this generic object you don't have to worry about because this is something inbuilt into python it's the thing that makes all of the objects work you don't have to worry about it so what we have to worry about is the shark the monster and the fish and how this order comes about is from the order of these arguments here and basically how this works is that the leftmost item monster in this case is always going to be the first in line with the class itself being the very first item so shark is going to be 0 monster s1 fish is 2 and then every subsequent item is going to be next meaning what i could be doing is turn these two around and call fish first and then monster if i run this now we are still starting on our shark but now fish is the first item of inheritance then we have monster and we still have object finally but in my case i do want to keep monster as the first item so the first thing you do have to understand is if we are calling the super dunder init method we are looking at the first item inside of these arguments here so in this case monster meaning for now i can minimize the fish class and just look at the monster and let me minimize these methods as well so it's a bit easier to see and basically what i can do now let me comment out the mro and i actually want to create a shark object from my shark and this is something you should be familiar with from simple inheritance right now we only have the byte strength so byte strength and this we can set to whatever we want let's say 50. but now for this superintendent method i need the arguments for the init method of the parent class in this case health and energy these two i want to pass in here now for these two i again i am going to need some numbers so for the init method of the shark class i also want health and energy meaning when i create the object i also want health and energy and let's set those to i don't know 200 and energy could be 55 and with that we are essentially back to simple inheritance i first call the class itself and the first one we do after calling the class we are calling the init method and inside of the init method python knows that the first item of inheritance is the monster class and then after that python knows we have one parameter for byte strength and this we're just setting as a parameter and then we are done with it so this is as far as this one goes besides that we also have health and energy and these two we want to pass into the init method of the first parent class so the monster and those we are getting up here but now we have another problem and that problem is what happens to the fish let me run the code and let's see what happens are not getting an error that's a pretty good sign now if i run shark and the methods we have here could for example be attack and for attack we need an amount let's say 10. the monster is attacked 10 damage was stealth so this attack method works just fine besides that i can also print shark.health and let me print this this one is working 200 we also get shark dot energy with 55 and we are also getting the byte strength so far we have the shark itself and the monster what we don't have is the fish let me minimize the monster class and open the fish in here we have speed and has scales and this our class doesn't have right now so if i type shark and speed and run the code we are getting that the shark object has no attribute speed which means that the inheritance from the fish is not working right now and let me reopen the monster and hide the monster methods so we can see all of the classes quite easily basically what is happening the mro is important here again this one here essentially how you have to think about it we first of all call the shark and then we call the init method of the shark and then python knows the first item of inheritance is the monster and since we are calling super.init we are calling this init method up here and passing the arguments in there the consequence is that we have health and energy for the monster and the normal inheritance still works so we also have attack and move but now the problem is that the init method of the fish is never called and as a consequence speed and has scales doesn't exist inside of the shark and what we have to figure out is how to call this init method and since we still have to worry about the mro we have to figure out how to call this init method with the arguments from inside of the init method of the monster and for that purpose we are still going to need this super and then the dunder init method and this function is very smart because it follows the inheritance that we have set by the shark to begin with meaning if we call the monster from the shark it knows it has to look at the fish next in line however if you call the monster by itself this init method wouldn't really do anything so this is a very intelligent function in the simplest terms basically what this init method has to do is to set the speed and hash scales of the other class which is the fish again let me set some static numbers for the speed let's go with 75 and for scales this should be false and now if i run all of this again i get for speed let's try this again now for speed i get 75 and for hash scales i get false the arguments we have set in here and this is especially if you are starting with objects probably going to be really confusing but the one thing that makes all of this work is the order of the indent methods we are first calling this one here this is number one then we are looking at the monster which is this one here this init method is number two then and then finally we are looking at the second item in the inheritance which is the fish this for shear so this init method is called third and we always need the super init method to go to the next item and what we would want to add in here as well is a super and then dander init method for the fish as well so if there's going to be another item in the list of inheritance or in the mro we would also call that one and for that reason you very often see super init in most classes because it enables inheritance to work across multiple classes and well i hope you can still follow along this is getting quite complicated and it is just going to get worse because right now we do have one problem and that is that this speed here and the hair scales are constant right now but i want to be able to set them dynamically when i am creating the shark meaning what i want to do when i create a shark i want to set this speed let's set it to 120 and i want to set has scales to false and this would then be all the stuff i have for the shark and i think it makes sense to put all of this on separate lines to make it a bit easier to read all right but now if i run this we are getting an error that shark init got unexpected keyword argument speed basically what pipeline is complaining about that this speed and this has scales don't exist in the parameters for the init method of the shark class we can fix that by adding a speed and has scales in here if i run this now this is going to work but we're not doing anything with either the speed or the hass scales we are still up here setting the speed and has scales as constant numbers and now we kind of have a problem because if i try to in this superintendent method at this speed and has scales then let me fix the typo first if i run this now we are getting the other problem that monster.init down here is the error we're getting right now monster.init takes three positional arguments but three were given meaning python in the monster class wants three arguments self health and energy and those we do get let minimize the fish for now so we can see what's going on we are getting health and energy and this is what this init method wants but besides that now we are also adding speed and has scales and for this the init method doesn't have any parameters so python is very unhappy because it gets too many arguments and it doesn't know what to do with them but this is a problem for us because we need those two arguments to pass into the init method for the fish but the init method of the monster doesn't have as many parameters so we have a problem here and to overcome this we need one special concept and that in python is called keyword unpacking and basically what it means is in my monster class after i have added all of the parameters i definitely know i need i want to add star star and then keyword arguments and that way any argument i get after the parameters i am going to store those in a separate dictionary let me actually print what we get so i want to print my keyword arguments without the stars for now and for these double stars python is expecting keyword arguments so all of the arguments for the init method here need to be keyword arguments meaning health.health energy is energy speed is speed and has underscore scales is has scales and now if i run this we are getting a dictionary with speed and has scales and this faults here we are getting from printing shark has scales let me remove that and try this again now so now we can focus on just a dictionary and that is something really useful because this we could use in here now and essentially what you have to do is call the unpacking operator again and passing in the keyword arguments and now if i run this again we are still getting the same dictionary so we are getting speed and we're getting hash scales what happens now if we are calling this star again it turns each key value pair inside of this dictionary into a named argument meaning this speed under 20 is going to become a named argument and then this we are passing into the init method of the next class in the method resolution order and with that if i now print shark dot speed and actually display what we get i now get 120 the one we have specified in here and this is how you would work with this now for an actual example you would add a lot more quarks to all of these classes for example the fish would also have double star and keyword arguments and then you would pass this into the init method as well so in here quarks as well now in this case the keyword arguments is going to be empty if i print it keyword arguments and run this we're getting an empty dictionary because we don't have any additional named arguments that we have to worry about so this dictionary here is going to be empty well this dictionary actually but if we had more named arguments they would all go in there and this is then how you would deal with multiple inheritance and if again you are just starting with inheritance this really isn't something you want to worry about too much probably if you're watching this for the first time and you're still struggling with objects in general this is going to be way too much i would recommend just practice objects and simple inheritance for now and once you are more comfortable with them come back to this this sort of inheritance is only really something you are going to see once you get much more advanced especially for making games or for making gui's you probably don't need any of this whatsoever all of the games i have made so far have never used multiple inheritance they all use simple inheritance and they worked just fine but well at this point we have covered all the main parts of classes i guess at this point there is some more smaller things i do want to cover but they're all going to be fairly simple so let's talk about them in the next section alright for this part i want to talk about some extra parts for classes and those are things i couldn't really fit in in any of the other sections but they're all fairly simple but they can be quite useful and well let's do all of this straight in code i think that's going to be the easiest all right once more we have the monster class and this is just something i want to use to illustrate what we are going to do and let me create an instance of this monster with monster and for the health i want 20 for the energy i want 10. it really doesn't matter what number we go with here and now there are three things i want to cover the first one is private attributes the second one is has utter and set utter and the third one is going to be the dog string and once we have those we are basically done with classes and the first one is going to be private attributes which is just going to be an attribute inside of a class that cannot be influenced from outside of the class which may be something like an id number that you really want to make sure of cannot be changed from outside of the class to be sure that it doesn't mess with some other code and this actually isn't possible in python we are always able to change the attribute of a class so python developers came up with something else and this let me copy this comment here and in the init method of the monster class i want to create a private attribute and how you would do this is first add an underscore and then the name of the attribute let's say in this case i want to have an id and the number i want here could be 5 but it could be anything it really doesn't matter and now this id by convention is not supposed to be changed but this is just a convention basically what you do with this format is you tell other developers that this attribute should not be worked on but you totally could work on it for example what i can do i can print monster and then underscore id and i get 5 meaning you can work with it but there's a very clear indicator that you shouldn't so if you ever work with somebody else and they added something like this you probably should not change it and well that is all you need to know about private attributes you could do the same thing for methods you are essentially following a naming scheme so this works with both attributes and methods all right next up we have has utter and set utter and what those two are doing is they allow us to check if a class has an attribute and we can also use it to set an attribute and the first one is going to be has utter and that is just going to be a normal python function and this one wants two arguments it first of all wants to have an object and besides that it wants a string with an attribute name and let's try this one i want to look at my monster and for my monster i want to check if the monster has health and this is then going to return a boolean that either says true or false meaning i can print all of this and i get true so this monster has the attribute health if i check for something that doesn't exist let's say a weapon i get faults because the monster doesn't have a weapon and this you could then use an if statement for example if has utter monster health and if it has health i want to print the monster has and i guess then we can use an f string monster dot health and that is terrible spelling and let's turn this into an f string and add health at the end and now we run this the monster has 20 health and that is what we have set here and this is has utter it's a really useful way to check if a certain class has an attribute you are going to use this fairly often actually it's a really useful function and besides that set utter works in kind of the same way so let me call it set utter and in here we need three arguments first of all we need an object then we need a string of an attribute name let's call it attribute again and then we have to set a new value and this could be a string it could be a number it's really up to you i guess let's say again i want to look at my monster the attribute i want to set is a weapon and for the value let's give the monster a sword and now i can print monster.web pin and i get sword and this set utter is basically the same thing as calling monster dot weapon and setting this to sword these two things essentially do the same thing and now you might be wondering why do we have this kind of redundancy that this is kind of pointless at least seemingly that we have this entire function that does something very obvious but the reason for it that this allows us to very efficiently create new attributes for example what we could be doing let me comment those two out and i could run a for loop and let me add a let's call it new ad reviews and this is going to be a tuple with lists i want to have for example a weapon and there i can have an x besides that i want to have another list with let's say armor and the armor could be a shield and finally i want to have one more list and this could be potion i could set something like mana or whatever you want to go for and now i can use that as a for loop so for attribute and value in new attributes i can call set utter i can pass in my monster in here and then i want my attribute and my value and if i run this we are not getting an error which is a good sign and now i can print my vars for the monster and i get the new weapon the new armor and the new potion and this way you can set a lot of new attributes and values for class by using this if you just used monster.weapon this one here this would not be possible and this is why set utter exists although you probably would want to create all of these attributes when you actually create the object itself so this isn't something you want to do too often although in some situations it can be really useful alright with that we have set utter and has utter and finally we have doc and doc is just there to explain what your object does that's really just about it you are getting doc or the doc's string to be more specific by calling monster and then dunder dock and in this case if i run this we get none for the simple reason that we have to create a dock string for our object and this you do first thing in the object and all you do in here is you set a triple quotation mark like this and then in there you are setting what you want for the monster for example i could write in here a monster that has some attributes and i am really bad at spelling monster for some reason and now if i run this print again and now i get a monster that has some attributes and this you could make significantly longer depending on what kind of class you have but this is usually what you want to set to explain your code to other people and especially if you work in a team with much larger projects it's really helpful to set something like this because well somebody else might have no idea what you're talking about what you can also do is let me comment out this print statement here and instead call help and i want to look at my monster if i run this i am getting a long list of different things and in here i can see lots of useful things for example i can see monster and its parameters i can see the dog string and i can see all of the methods inside of it and if you just find a new object you don't really know much about the help function is really useful as a matter of fact you can also pass normal python code in here for example what i could pass in here is just str for string and now python gives me the help function for strings and if i go all the way to the top there you can see basically that we have another object and the object takes one argument which is going to be a string then we have the dog string and this one explains what this object does and afterwards we have all of the methods and there are quite a few because strings are very complex objects and with that we have covered objects and classes i hope that wasn't too difficult but this is definitely something you do want to practice so hope that was helpful and i will see you around in this part we are going to be talking about modules this is the part where python really becomes powerful so let's talk about it essentially modules are just extra parts that we can attach to our programs for example if we wanted random numbers we would add the random module that's basically what it is there are quite a few modules that we can use that come with python by default and random is the one you are probably going to use the most but i will cover a few more in just a bit besides that we can also create our own modules to make our code more organized and each module would be in a separate file which makes it really easy to organize larger programs which is something we're also going to cover in just a bit but the much more important part is to use modules for extra functionality and let's start with that one and in here we have two different options we can either import from the python standard library all this really means is that these modules come with python when we install python so we can just import them and then work with them it's super easy besides that we can also import additional modules made by other people but those we have to install on our computer first these modules here can become incredibly important for example if we want to make games or work with machine learning or do data analysis or run databases we would basically install additional modules to make all of this work but let's not get ahead of ourselves and let's start with the python standard library and by just talking about basic modules here we once again have a completely empty python file and what i want to create is a random number the problem we have is that there's no way so far to create random numbers but we can do it by importing a module and this we do with the import command and then the name of the module and the module we want here is called random and this one is giving us random numbers i think the name makes sense here and random has lots of different sub modules that we could be using and the way you would access them is first the name of the module and then the methods inside of it and one here is called randint which is standing for random integer and this is just a method we can call it although this one is expecting two arguments a minimum and a maximum number but once i have those two i can print the random number and now if i run this i get different random numbers every time i'm executing this code and now you might be wondering how do you know what else is inside of the random module and that's a really good question usually what you do is you just google the module and then you find lots of information for example for random we have a whole documentation that is actually incredibly extensive so all of the stuff in here would be part of the random module the one we have seen already is random.rentend and all it does is it creates a random integer between two numbers and this is a function you are using all the time it is really popular another one that you are seeing fairly often is choice and this one picks a random item from some kind of sequence this could be a list it could be a dictionary something like that and let's actually implement this one here i'm back in the code and i want to create a test list and for this test list i just want to have a couple of numbers it really doesn't matter i guess let me put the print on top and now i want to select one item from this list and for that i would get my random again and i would add choice and now this choice is expecting one argument and that is the list so test list in here and now all i have to do is print the result and let me comment out this stuff up here so we're not getting confused and if i run this we get different items from this list i guess to make it a bit more visually appealing let's add a few different data types in here this one is looking better so now if i run this we get all of the different values and that is in the most basic sense how you would be using modules and there are a lot of different modules that come with python already if you look this up online you are going to find this list calling the python standard library and those are all of the modules that come with python and in here we have a lot of different options that we could be working with for example the one i'm seeing right now is called tkinter and this is the most common way to create guise or graphical user interface in python it basically gives you buttons besides that we also have a ton of modules that work with the internet and if i go up a bit more we can see i hope i find it there should be random in here somewhere there we go there is random and there are quite a few more modules that we could use with numbers chances are you are only ever going to see a very small part of all of these modules even i have only ever used a very small part of them for example i have no idea what rl completer is i have never used it even once but some modules in here are incredibly useful and you do want to have a basic awareness of them and you basically learn all of them by just using python and then discovering more and more of them now if you want to import multiple modules you can do it in two ways you could either on another line import something again let's say what i could also import is the string module and what this one does let me comment this one out i could for example print string and in here i could print the s key underscore lowercase and be aware this is not a method this is just an attribute and if i run this i get all the lowercase letters of the alphabet that's really it string is a very simple module if you are importing two modules just like that to save a bit of space you can put all of this on the same line like this and then i can get rid of the second line run all of this again and we get the same output the random module would still work just fine i guess one more module that we could be looking at that you do see fairly often is called math and this one is giving us a few more advanced math functions for example what we could do in here is print math dot sign curve and add like a 1 in here and if you have no idea what this means don't worry too much about it it's just a sine curve not something you use too often unless you are doing some fairly specific tasks i suppose a more common operation for math would be floor and this one gives us the floor of an integer meaning if i have 4.9 this one is giving me 4. we are basically just rounding down that's all that's happening in here and with that we have a couple more modules now there are a few more things you can do with the import statement and those are mostly to be more specific in terms of what you import for example for my math i only want to import math.floor and nothing else and if that is the case you can just type from math import floor and this way we are only importing floor and we don't have to worry about the math part in front of it meaning now when i'm calling it down here i can remove it and call floor like any other function oh and let me get rid of the comma all the way up here that shouldn't be there now if i run this we get the same outcome and this flow now works like any other python function if you really wanted to you could also rename this floor function and this you would do by adding s and then the name and you could name this any valid python name i could for example call it get floor and then this one here would be get underscore floor and there we go same outcome i guess what you would mostly do in here is to shorten method names if they get too long for example i could shorten this to f and this would then save me quite a bit of writing and some modules do get very long so this isn't actually as rare as you would think it is and finally there's one more thing that we can do let's say for this random here i want to use all of the methods but i don't really want to write this random at the beginning every single time and to achieve that we would use from random again but now when we import individual modules we are typing a star and this tells python we want to import every single method and function from the random module and then use it in our code and this allows us to use all of them without writing random first really now i can run this and i still get the same outcome although this you really don't want to overdo because if you import all of it you are well importing all of it and this could add a ton of functions and methods and variables that you don't want to use and that could clutter up your program but alright with that we have covered the basics of modules and let's do an exercise and this is going to involve a bit of research on your part what i want you guys to do is to get the current time from the date time module so do some google research and try to figure out how to get this it should be doable in a single line of code i guess two lines of code if you include the importing part as well but pause the video now and try this one yourself i suppose the best way to start this is by doing the research ourselves here again we have the website with the python standard library and what i'm looking for it's already in here i am looking for date time the module and this i get here if i click on it i get a lot more information and in here if you scroll down you can find a ton of different things it's actually quite an extensive module but i'm just looking for one specific thing i hope i can find it for example here we would have today that is kind of useful but i want to find the current time and the current time i can find ah in here class method daytime now this is what i was looking for and this gives me the current time now you obviously didn't know that this one even existed so this probably took you a bit more googling but most of the time this is how you discover new modules you just google a problem then you in some form find a new module and this solves most of your issues that's basically how everybody learns python or any programming language in general let's implement it here i'm back in the code i want to import date time although day time is a bit weird because what we have to do is from date time import date time and what that means is inside of the date time module we have one object called datetime they just happen to have the same name which can be kind of confusing but well it is what it is and i guess just to be a bit fancy here let's abbreviate it as dt and now to get the current time i need my datetime dot now and this i can just print and if i run the code now i get lots of stuff let me comment out all of this and now i get my current date and my current time down to some nanoseconds with that we have covered all the basics of modules meaning if you got so far you already have a pretty good understanding although you can do quite a bit more and that is going to be the next part in this part we are going to cover external modules and external modules are just modules that are made by other programmers and this is giving us a ton of extra functionality for example any kind of game development any kind of data analysis machine learning graphical user interface and a lot more is essentially just a module made by somebody else and we are using these functionalities and this is one of the really strong parts of python there is a very active community that makes a lot of extra modules that you can use for your own projects almost all of them are free there are some very select ones that are being paid those are usually more business oriented ones that you don't have to worry about and these modules are imported like the standard modules the only difference is that these modules have to be installed on your computer first and this can be done in a couple of ways the most common one is in the powershell or the terminal now what does that mean the powershell is for windows and the terminal is for mac os and both are command line interfaces and what a command line interface is is simply a way to interact with your computer simply by typing text if you ever watched any kind of old movies those always use command line interfaces where people just write commands into computer there are no buttons no windows you just write text into your computer and this is what we are doing here as well and this is the way python is intended to be used it's honestly the easiest way and sounds way more complicated than it actually is but let's actually have a look at this and let's start with windows both versions are identical bar a very minor difference now for windows you just have to open the start menu and type powershell and if you press enter you can see something like this let me full screen it and this is a command line interface for windows and in here i can type a ton of commands to make windows do something in my case i only want to do some very specific things and what i want to do is to type pip and install and then the module i want to go for and pip is the python package manager meaning this is what we are using to install any kind of external module and the module i want to install now is called pi auto gui and now all you have to do is press enter and python is installing a bunch of different things there really isn't that much we have to do ourselves but at the end you can see successfully installed pi out to gui and then the version name and that is basically all you have to do although i guess there are a few more things i do want to cover in here one command that i found really useful is called clear and this one clears the entire interface so things are a bit cleaner and one more thing that can be useful is called pip list and this one gives you all the modules that are being installed and your list should be a good bit shorter than mine but you can install a ton of different things here and finally if you want to uninstall a module you will just run pip uninstall and in my case i want to uninstall pi or to gui then python would ask us if we want to proceed i want to with yes and now it's uninstalled now i can clear all of this again and since i do want to use pi to gui i want to install it again and this could be a good exercise for you so install pi or to gui yourself again and see how far you get all we need is pip install pi or to gui if i type this we get all of this again and we have installed pi or to gui and that is pretty much all we needed and now that we have that let's do the same thing for mac os you open all of your programs and in there you type terminal once you do that you're getting a new window and let me maximize it in here if you hold the apple key and plus you can increase the font size which i really want to do you might not need it and in here we can work with mac os using commands just like in windows i could type commands here to control mac os obviously not like that but you get the idea for example clear works just in the same way most commands do actually the one minor difference here is we do not type pip install and the module instead we would be writing pip 3 install and then the module the only difference here is the free the rest stays identical d3 here is needed because on mac os python comes preinstalled the problem is the python version is really old and when we installed python on the mac we installed a separate version of python and this three is to tell python that we want to use the latest one which is python 3 we do not want to use the original python but that is the only difference so in my case i want to install pi auto gui i press enter now python is doing a thing and at the end we get successfully installed pi auto gui and if you notice here this is the same version we have on windows and with that we are good to go inside of our code editor there's not going to be a single difference so let's have a look at that alright here we are back in my python file and i'm using windows but this is going to work both with mac and with windows the installing part was the only difference between the operating systems but now i have pi out to gui so i want to import it so import pi or to gui and what this module is doing is it automates windows to a certain extent for example what you could be doing is to move the mouse around or to write some text from your computer with python and i guess let's get started with that now that we have pi out gui i just want to call the entire module and then right and now and here i can tell it to write some text for example this is written by a computer and now if i would run this code we would have this typed out although right now this would be kind of awkward because i have no time to switch to another program like a text editor meaning i want to import another module from the python standard library or another part of a module and this is called from time import sleep and all that sleep does is it pauses our code for a certain time interval let's say i want to call sleep and one second and now let me bring in a text editor and let me run the code switch back and now we have this is written by a computer the text you have just seen was just written by python not by me i suppose to make the effect a bit more noticeable is for this method here we can add another argument or a named argument to be more specific and this is called interval and in my case let's go with 0.5 probably a bit long let's say 0.25 and this is the interval duration between each letter that is being typed out i guess let me write it again and switch back to the text editor and now you can see this is written by a computer just very very slowly i guess what you also could do is run the code itself and now python is writing this code by itself in sublime this is also working just fine prior to gui doesn't care where it's writing it just starts typing these letters let me get rid of them and with that we have one module the only difference to standard modules is we are first installing it via pip and then we're using it like any other module and the main task for you is to understand what each module is doing and for that you usually find documentations online let's actually have a look at the one for pi auto gui it is looking like this and if you scroll around here you can find a ton of different things you could do for example you could move your mouse you could add a click you could add a double click you could write you could press a button there are a ton of things you can do with pi or to gui it's a really fun module and well this is then bringing us to the exercise bit and what i want you guys to do is to do a bit more research and what that means is create a graph from any of the examples below i should type these things out more but essentially here you have a link to a website if i copy this and open the website you can see a tutorial for pipelot in the matplotlib module and this is the standard module you would use for data analysis it basically makes nice looking graphs and i want you guys to look at any of these examples and try to understand what is happening or well you first have to install maploid lib and then you can follow any of these examples so try to do that install the map.lib module and try to copy or understand any of these examples it's entirely up to you which one maybe go for something slightly more complex this could be a really good challenge for you i want to work on the simplest example here because i want to keep the video short and the first thing we have to do is to install matplotlib so once again for windows i want the powershell let me maximize it i guess let me clear this one first so it's a bit easier to read and now what i have to do is pip install matte plot lip and if i run this we have to install quite a few different things this is going to take a second and we have successfully installed map.lib 3.5.2 and if you are working on a mac this would be pip 3 install matplotlib now that we have that let's return to the code and in here let's comment out all of this and we have to figure out how to import mapp.lib and let me bring in the reference from the site let's put it here this is good for reference on the first line we have to import map.lib.pipelot as plt when we're importing map.lib we are not importing all of it we're just getting one subpart of it pipelot and we are renaming this to plt because typing is hard so i want import mad plot lib dot pi plot as plt and now after the exercise i have to create a plt dot plot and this one wants a list with a couple of numbers in the example it's one two three and four and once you have that you can already run this program and you're running this with plt dot show meaning if i run this now we are getting a graph the one you can see on the right besides the y labels and in here you can change the numbers quite easily for example i could add 10 0 100 and if i run this again we get a very different looking graph all that the plot method really wants is the list of numbers and then it puts them into a line chart and what we also see in the example is plt dot y label and all this one really does is it adds a label on the y axis so some numbers in this case on the example and i guess let's copy it one to one we have some numbers for the y axis to be a bit more specific now if we run this we have some numbers for the y axis we can also do the same thing for the xaxis if you really want to and this you get with plt dot xlabel and then we have some number for the xaxis if i run this we can see at the bottom now we have some numbers for the xaxis and that would be matplotlib or at the very least a really basic introduction to map.lib map.lib is a really complex module that can visualize data in a ton of different ways so if you want to learn it it is going to take you quite some time all right with that we have external modules so the last part for modules is to create our own or at this part we are going to create our own custom modules and the one question you might be having is why would you want to do that and the answer primarily is organization that you are creating modules and each module is in a separate file and that way you just never have too much stuff in one file which really helps organizing your code so far we just never really needed it but later on when we have thousands of lines of code this becomes incredibly useful to not get lost on your own program that being said you don't have to do it but it's a really good idea to do that i guess let's implement all of this and that should explain it the best all right here once again we have a completely empty python file now since we are working with multiple files i want to be able to switch between them and the best way for that is using tabs so in sublime i'm pressing alt and then i can see all of the menu options you could get the same result by pressing f11 and then you get this menu item here and you can select different things and in my case i want to in view show tabs and then i can see the different tabs i've opened right now only one and let me return to full screen so it looks a bit cleaner and now this module is only going to import the stuff from another module meaning i have to create another python file with control n and this one i want to save so if i click on save i can save this to whatever i want let's call this one my module and this is still going to be a python file and now i save this and now i have two files open that i can switch between although right now both are completely empty and let's start in mymodule.pi in here for the simplest possible example i just want to create a test variable and this could have any value let's say test and now this module i want to import in my custom modules python file and this happens in the normal way i first have to import my underscore module and this should not be capitalized and if you run this and you don't get an error this is looking pretty good and now that you have that you can use this module like any other module for example in our case i can run my module and then in my module i have a test var let me copy it i can print this and i get test this is also going to work with functions and with classes for example i could create a test underscore function and then here we could even add some parameters and let's say i just want to print this is an imported function with the parameter and then parameter and now this function i can also use inside of my main module meaning i want my module dot test underscore function and the argument i want to pass in here let's say is one two three and if i run this now we are getting an error the name parameter is not defined and oh the reason is that the parameter and this parameter here have different names this one should be content and now if we execute the code we get this is an imported function with the parameter one two and three so this one is working just fine finally what you can also do let me do it below the function i can create a class called my class added here you can run init with self and give it a self.name let's call it my app and we can call self.value i don't know 12. and this can also have a method it's literally like any other class let's call it do something it needs self and nothing else and then here i just want to print hello so once again super simple class that we now are able to import in the main file actually what i can do if i hold ctrl and click on my module i can see both files side by side which is quite handy and while looking at this i realized that this has the wrong naming scheme this should be my class in fact now looking at this this feels like a really bad name let's rename it to test and now i can call test and mymodule.test and don't forget the brackets now i can run test dot do something and if i run this we get hello meaning this module test here refers to this class test and this do something refers to this do something here and later on you are really going to appreciate having more files with less code in each individual file it makes it much easier to work with but i guess let's do an exercise and what i want you guys to do is to create a some calculator function that takes unlimited arguments and returns the sum and create it here and run it in the main file so pause the video now and create this one function import it to the main file and then run it there all we have to do is create another function and let's call this one sum calculator and in here i want to have one parameter that i called nums but i want to be ready for unlimited arguments so this i want to unpack and now inside of the function all i want to do is to return the sum of these nums and that is literally it now that i have that i can i guess we can be a bit more fancy here let's say from my module i want to import the sum cal q later and again this is working exactly the same way compared to what we have seen before with the external or the python standard modules and now that i have that some calculator and i can add one two three four and five run this and we don't get anything because we're just returning something we are not printing it so let's print it and there we go we get 15. and with that we are pretty much good to go for modules although there is one more topic we do have to cover that is going to be quite short though when you are creating your own python modules there's one really important concept you have to understand and that is called thunder main all this one really means is when a python file is called it creates a couple of internal variables and than the main is one of them it is in fact the most used one essentially what it does is it gives a name to the current python file and the one that we are executing is always called thunder main but any imported file is called dunder and then the file name and this is really useful to control what code is being executed and more importantly to avoid executing code by accident here is the example from the last video and in my main file i want to print dunder name both in my main file and in the one i am importing and if i run the code now i get done domain all the way at the end and all the way at the top i get my module i guess let me comment out all of the other print statements that is going to make it easier to read now if i run this we get two print statements we have my module and main and what happens internally is python first runs all of this imported code here and what it gets at the end is print name so it prints my module and this my module is the same as the name my module up here this is the name of the file and after that we are printing in the main file then the name and then we are getting done domain and the reason why this is called main instead of the file name we get up here is that this is the file we are currently executing if i just looked at my module so this one here and run this again and we are getting main here because right now we are executing my module which turns this one into the main file and this is being used usually with an if statement and you're looking for if dunder name is equal to thunder main only if that is the case let's say i want to print the main file this makes sure you're only running this code if this is actually the file you are executing and most of the time when you have multiple files like in this case all of the actual code is inside of this if statement if you have other kinds of code let's say for this one here for my mymodule.pi i would add the same if statement this one here and then the print statement would be inside of it if i executed my custom module i would only get the main file this one here and inside of my module this one here would not be executed and this way if you have this if statement for every single file you have a lot of control about what is getting executed when you are importing the file which can be incredibly handy in this entire section we are going to cover some extra topics now i do want to be clear here basically all of these parts are very useful but not that common especially for beginners the longest video in here are decorators and error handling as a beginner you are not going to encounter them or use them basically at all meaning at least for now it's perfectly fine to skip this entire section and return later it is probably a good idea for you to practice basic python and then explore these areas especially decorators can get really really complicated and if you're just getting started you are not going to use them anyway so you might as well skip them at the very least for the beginning that being said i do want to cover them because i want to cover all of python and first of all i want to cover two very simple topics that i would recommend you to check out and those are called pass and input all that pass really does is it tells python to not do anything this does seem kind of pointless and basically you would only use it if you have a function but no content yet so maybe you have a function with a good name but you don't yet have good content for the function so you have to fill it with something and you would use a pass for that besides that we have input this is another function that can get user input although you are hardly ever going to use it i'll talk about it in just a second but it really isn't as useful as it sounds so inside of a python file let's say i have a function that is really important function name with whatever parameters you have and for this function you don't have content yet you don't really know what to do with it or at least you're prototyping it but you do want to keep the function by itself but if you're doing this without any content and run the code you are going to get an error because python expected an indented block after function defined on line one so python needs to have something in here and for that you could just add pass and now everything works just fine so pass is basically telling python to not do anything and well not doing anything is something you usually don't have to define though this past you hardly ever see anything productive it's pretty much only there to cover some kind of content where you don't have content yet it's a filler essentially now besides that we have input let's say i want to get some kind of user input and for that we would need input and now in here we can use this kind of like print for example i could print to the user press a button and whatever the user is going to press is going to be stored inside of this user input however there is going to be a problem because if i am running all of this we can see press a button however if i keep on pressing a button i keep on typing in subtime the issue here is sublime does not support input for that we would have to run this python script inside of the powershell or the terminal and how this is going to work let me print the user input at the end so we can tell what's going on and really importantly do save the file what i want to do now is to run this script inside of the powershell or the terminal and let me put this on a separate screen so here we have the powershell and here i have the folder with my python file that i have just created and if you want to run this what you have to do is you first have to type hyphen to run a python command and then you need the file path towards this folder here let me show my mouse actually inside of the terminal you can add a ton of commands to navigate to folder structure the thing is that's kind of complicated and you don't need it all you really have to do is to drag the file in there and then you get the rest automatically so this is all you really have to do just drag and drop the file don't forget the python at the beginning but other than that all you have to do is press enter and now you get press a button exactly what we have specified inside of the python file and now i can press this is my input and if i now press enter i get this is my input and after that the code finishes and we can add another kind of input for example we could add clear in here and we are done and that's really how you run files inside of the powershell or in windows in general and welcome back in this part we are going to cover error handling and well for this part we are going to handle some errors which means obviously your code should not contain any errors because that would crash your program and that would be bad the issue is sometimes you can't really avoid having some errors for example you might try to find a file and it just doesn't exist and you don't notice in advance and as a consequence you want to have the ability to anticipate and deal with errors and fortunately python can deal with that quite easily there are quite a few different ways to do it actually and let's jump straight into the code and let's have a look at all of this alrighty here we have an empty python file and let's just create an error just to get started i want to print one divided by zero and if i run this we're going to get an error we have a zero division error that we are dividing by zero and this is not allowed because math doesn't like it so what could we do to overcome this or rather how can we make python try some code snippet and then do something else if we get an error and well the command is literally called try and this works kind of like an if statement except without any arguments we're just telling python try this line of code here if it works cool if not we want to do something else and the else here is called accept and inside of that i can print something else let's literally write something else and now if i run this we get something else what happened here is that python first went with try and the code in there was this print statement and this print statement included the operation 1 divided by 0 which is not possible as a consequence this here gave us an error and because of that we are going to accept and inside of that we are printing something else and this is what we got in the end as well if i had valid code inside of the try statement let's say 1 divided by 1 we will get the result of this line of code here and accept would not be run and that is the easiest way to deal with errors in python however we can both be more specific and we can add more things towards this and let's be more specific first and that is for this except statement we can specify specific errors that we are looking for for example what we are looking for right now is a zero division error and if i run this we are getting the same outcome however now if i add another print statement and i print a variable that doesn't exist yet which if i run this is giving us another kind of error specifically a name error and we are right now only dealing with zero division errors so when python sees a name error it doesn't know what to do with it but well we can account for it by adding another except statement and now we want to look for a name error and if that is the case i want to print let's say does not exist and now if we run this we get does not exist and be aware what happens here python starts all the way at the top with try and then it goes through these lines of code here and we are starting with print a and this one doesn't exist and as a consequence none of the stuff below is executed and we jump immediately to this name error and in there we are printing does not exist which is what we are getting down here now one important thing you may have noticed is that let me actually get rid of it this print here which should have given us this accept statement is not being printed down here in the console meaning that this here wasn't even executed it's really important to understand as soon as try finds any error any code after that is not being executed which is why we only ever get one except statement or the result of one except statement to be more specific and if you happen to be interested in all the possible errors that could happen in python there is a whole documentation online and in here you can find for example arithmetic error buffer error lookup error assertion error lots of different things that could be raised so if you are looking for some specific errors that could come up this list here would be really useful what you want to look for is build in exceptions there are two more things that we can do one is else and the other is finally and let's start with else that one is well it's basically an else statement that you should know from the if statement let's say in here i can just print let's say the else statement and if i run this right now this else statement is not run because we do have an error this name error here specifically but if i run some code in here that does exist let's say print try if i run this now we get the code inside of the try statement and we are getting the else statement as well but the else statement is only run if the try statement doesn't have an error the way you have to think about it is that this else is an else to these except statements and finally we have well finally and finally runs whenever all of this stuff finished and it runs either way it doesn't matter if we have an exception or not let me print finally and if i run this now we get finally again and this is going to happen let me run the zero division error again this finally even comes when we have this division error here i guess i should rename these things a bit more properly you cannot divide by zero and now let's run this again this looks better what is happening in the code right now we first number one start with the try part up here and inside of that on this line here we're getting an error and this leads us to the exception error for zero division error and in there we are printing you cannot divide by zero which is this part here number two and finally we are ending on finally which is number three and this finally runs no matter what happens and with that we have covered how to handle exceptions although there's one really interesting topic and that is you can raise your own error let me actually add comments here to make this example a bit clearer this part here what we covered so far is anticipating errors or to be more specific exceptions what we can also do is raising exceptions ourselves and what i want to do in here for the example is i want to create a variable that must be a string and for now let's give it a string let's call it test string it really doesn't matter what the string here is and now what i want to do is to run an if statement that if this variable contains a string i want to continue as normal if that is not the case i want to raise an exception or well call an error same thing and for that we first of all need an if statement and to check the type of a variable we need is instance and in here i want to check my var must be string and the second argument is the string type or the type we want to look for which in my case is string and if that is the case the variable is all good and let's say i want to print must be string and let me comment out the earlier part and run this code and this is working indeed because a var must be string is a string indeed or it contains a string however now if that is not the case i want to raise an error and this you do with raise and then the type of error you want to raise in my case i want a type error and in here i can add a message as well as the argument and in my case i want to write must be a string if i run the code now nothing happens however if i change this string to something else let's say an empty list now i get a type error must be a string and that way with raise you can create your own errors to your heart's content and along those lines there's another thing you can do to raise an exception and that is called assert and assert basically means that you want to make sure that your code only runs if a certain condition is true think of assert as a stronger if statement that if this condition is false your entire code stops with an error for example what you could do in here let's do a simpler variable a is 5 and a always has to be 5. if a is not 5 i want to end all of the code immediately and this i do with assert and in here i can just look for any kind of boolean statement meaning a is equal to 5 and if i let me comment this part out if i run this now we get nothing however if i change the value of a to 6 we are getting an assertion error and that is caused by this line here and sometimes in your code you really want to make sure that a certain condition is true especially if you work with something more securely concerned this is something you really want to be using extensively but well with that let me uncomment all of this here as well if you understand these three parts you basically know all you ever need to know about error handling it doesn't get that much more complicated and that means we can do an exercise and then call it a day and what i want you guys to do is to create a list and then try to raise an index error and obviously account for this arrow as well and type some kind of message with the print statement also try to use else and finally and see how far you get you might have to do some research online to find what an index error is although i think it makes sense what it might be just try to guess let me start by creating my list and in here i want to list with one two three four and five the content really doesn't matter and an index error basically means that you are trying to get an index that doesn't exist for example i could get my list and then get the index 99 which does not exist i am getting a type error and the type error comes from here let me comment out all of the earlier stuff so we can focus on one thing now let's try this again and now we're getting an index error and that is what i want to account for let me cut this one out and instead i want to go with try and in here i want to get my list 99 which i know does not exist right now so i want to run and accept and i want to look for my index error and if that is the case i want to print that index does not exist and if i run this now we get that index does not exist and no error message anymore i guess with that we have covered the first two parts of the assignment besides that i also want an else and finally let's start with else and in here i just want to print that index exists let's try it if i run it by itself we are getting that index does not exist meaning this line here and we don't see else because else is only run if there's no index error so let's try to get the first index and let me print this one as well now we get two and that index exists which is this print statement here and this else statement and well finally we need finally and in here i just want to print finished and this one is the easiest it always runs we get finished either way if this is working or if it is not working and with that we have covered error messages it really is a fairly simple topic and quite easy to cover in python the main thing i suppose you have to learn is all the different types of exceptions that you can have but if you play around with this a bit it's getting quite natural so we are done with this one hello there in this tutorial we are going to cover decorators which are is somewhat more advanced topic in python so let's go over some theory first in the most basic sense decorators are functions that decorate other functions which does sound a bit cryptic but essentially what we do is we are wrapping one function around another function and let's do this a bit more visually to illustrate what's happening this is a normal function and usually what you do is you just call it somewhere and then you have something happening what decorators do is we still have the normal function but now we are putting another function around it and then when we are calling all of this we are calling the decorator function and inside of that decorator function we are calling the original function and this is allowing us to execute code before and after the function so when i'm calling this function here i could run code here and i could run code here without making any changes to the original function this function here would stay exactly the same all the actual logic happens inside of the decorator we are literally putting one function inside of another function and this other function executes extra code that's the entire idea of a decorator now why would you want to do this basically this way we can give extra functionality to a function without changing it a simple example here is we could write a decorator for a function and it makes the function execute twice when called not the most useful function but we are going to talk some more useful examples later on i just want to illustrate what is happening now in practice you are seeing decorators in three different circumstances let's go over them the most common one is you want to test your code without changing it let's say you work in a team you have some really complicated code and you want to test your code without making too many changes a decorator would be excellent for that the other example would be you are working in a team and you want to avoid making unnecessary changes now those two points are pretty similar you basically want to do something with your code without making too many changes and both of these are also fairly advanced if you are just learning python you are quite far away from either of these which is why you may be struggling with decorators because you don't really need them however there is a third case that you probably are going to use and that is using a decorator inside of a class because this allows you to run code when an attribute is accessed or changed so for example let's say you have a monster with health and every time that health is changed you want to run some other function inside of the monster with a decorator doing this is fairly easy although that being said decorators can be quite hard especially for beginners because we are going to use some more advanced functionalities in python that may be slightly confusing although i would really recommend you to try to follow along because this is going to be really good practice to understand functions and how to pass them around in fact before we start with decorators we need to recap functions itself so let's have a look at that here we have a completely empty sheet of code and let's just get started with a really basic function i want to define let's call it func there are no arguments and inside of this function i just want to print function just about the easiest function you can write if i call this function i get function so this really doesn't do all that much now there's a really important concept you have to understand that right now we are calling the function here and if we didn't do that so if i remove those brackets i could run this and nothing would happen but what i could do is print the function itself and now i get a function object meaning this function here as the whole function not what's being returned just the function itself and this is just going to be an object if that doesn't tell you anything check out my videos on objectoriented programming they should be quite helpful but basically what this func is giving us is a simple object that we can call and if we don't call it we are just getting a function object still not particularly useful but what we can do with this function object is pass it around like any other object like an integer like a string like basically any other object we can pass it around for example what we can do i can create another function and this let's call it a wrapper because this one is supposed to take the argument of the function and then i want to execute the function itself meaning what i can do now i can call my wrapper function and run this and i get function again and what is happening in here i am calling this wrapper and i'm passing in this function here what happens as a consequence is this function is being passed as a parameter into the wrapper function and inside of that function we are calling this function and when we are calling it we are printing the word function and now that we have that we could also do something like print hello and print goodbye and if i run this now we are running the function inside of another function and before and after we are calling it we are running some other code and this is basically the main idea of a decorator although it does get a bit more complicated but we'll come to that in just a bit now there's one more thing that you can do inside of a function and that is you can create a whole new function so for example let me create another function and let's call this one a function generator and then here we have no arguments to keep it simple and now inside of this function generator i want to create a new function and let's call this one new function i guess it's a good word and in here i just want to print new function and since this new function is just going to be an object we can return the new function and what i can do with that i can create a variable let's call it new function and i want to get my function generator and if i run this we can't see anything but now this new function is going to have this new function in here meaning what i can do i can call my new function execute it and we get new function so just to go over this because it may be a bit confusing this new function executes this one here and what we are getting from this function generator is we are defining a new function this one here and at the end of the function we are returning this new function and this we are capturing inside of this new function variable and this new function variable now is just a function meaning we can call it here and when we are calling it we are getting this print statement that's really all that's happening here the main thing you have to understand is we are basically passing around functions with the return statement with that we have some function basics so now we can actually start working on the decorator and for that let me open up a new file and in here i want to create an actual decorator now first of all for decorator we are going to need a basic function we want to decorate so for my function basics i want to copy this basic function here which is just printing function by itself so if i run this we get function literally the easiest function you can write more or less and now for this function i want to create a decorator and this is going to be another function that you can give whatever name you want let's say i want to call this one decorator to keep things simple and this decorator is going to accept one parameter which is going to be a function so in just a bit we're going to pass this function inside of this decorator what we are going to do with that inside of this function we are going to create another function and let's call this one the wrapper and this one right now doesn't have any arguments but now inside of this function i want to run the original function and besides that i can do quite a few other things for example i could just print the decoration begins and let me write this properly and i can also write the decoration ends and now after i have done that i can return this wrapper and now what i can do i can create my new function and this is going to be my decorator and instead of this decorator i want to pass in my function and once i have that i can just call my new function and i get the decorator begins the function and the decorator ends what is happening here let me go over this this is probably a bit confusing we are starting with our basic function and this function we are passing in here into the decorator function and this is the one we have up here and inside of this decorator function we are creating a whole new function this bit here and inside of this function we are calling the original function meaning this one here and then around this function we are doing some other stuff like we are printing these two statements here and then at the end of all of this we are returning this new function and this new function we are storing in the new function variable and then we can just call it like any other function and now we have extra functionality around our original function now where this becomes really interesting is let's say somewhere later in the course i am running function by itself which would just give me the word function let me comment out these two lines here if i just run fung i get function and nothing else and what i can do with decorators if i uncomment those two lines and get rid of this new func when i create the variable name for this i can just call it the same way like i have called the original function so i can call both func if i do that and run the code again i now have a new functionality for this function because we are essentially overwriting the original function name and that way our function even with the same name has new functionality and this is the basic idea of a decorator if we have this kind of system we can have really complex code and still check our function without making any changes to the code and since this is a reasonable common operation python has a shorthand for it and let me comment out this statement here and the shorthand looks like this i first write an add and then the decorator function so in this case decorator and now if i run all of this again we are seeing the same outcome for the simple reason let me uncomment it that this statement here and this line here they are doing essentially the same thing we are wrapping this function here inside of a decorator this one here and let's go over this a bit more slowly i think that's going to be useful here we have the function you have just seen and you can wrap this in the traditional way by writing the function and then we are putting the function inside of the decorator and then we are calling the function i hope this is making sense if you're confused about this i would recommend to pause the video now and just go over all of these different statements and see how they connect i guess i can go over it as well again we have this decorator here and inside of this decorator we are passing in a function and then we get this function here as a parameter now inside of this function we are creating a whole new function and this one is called wrapper and only inside of this function we are calling the original function this one here and then around this function we can do whatever we want like calling these two print statements here we could also do lots of other things i'm going to cover that in just a second and finally at the end what we are doing is we are returning this wrapper function and this wrapper function we are storing right now in func and then we can call it like any other function and that way we're using the name of the function and overwrite it with this new function that is being wrapped inside of the function which means if i took out this line here the function would come back to its original functionality and just print function now the problem with that approach is that we are writing func three times one two and three and if you want to call it a fourth time which is kind of annoying so what python developers have done is to create a shorthand for this and this is called a decorator and this one is looking like this and basically this line here where we have the name of the function a decorator and then the function as an argument is the same as this add decorator those two lines are doing the exact same thing meaning when you are calling this function you have the same result now obviously just printing two more statements isn't particularly useful so let's actually do something more relevant to see why decorators can be useful here we are back in the code and i want to create another decorator and this one i want to call the duration decorator and then here again as a parameter we need the function and inside of that i want to create a wrapper it doesn't need any arguments and in here first of all i want to execute my function and then return the wrapper and this is essentially a decorator that doesn't do anything right now and what i want to do with it is to measure how long it takes to execute this function here and for that to work we need the time module meaning i want to import time and now what i want to do inside of this decorator i want to get my start time and this i would get with time dot time and this has to run before i call the function and after i have called the function i want to get my duration and my duration is my time.time which is my current time and from that i want to subtract my start time and once i have that i can print let's call it duration and this should be an f string with the duration and now just to get some reasonable numbers in here when i am calling the original function i want to call time dot sleep and make it sleep for one second and now with this duration decorator let me actually call it so duration decorator i can now comment out this line here and now if i run the code we get function and we get the actual duration and from this line we know it took one point a tiny amount of time to execute all of this and this now we could get without making any changes anywhere else in the code we're just calling the function here we have the wrapper up here and then we're adding this one line of code to add some debugging functionality so this is something you could be doing if your code is running very slow and you want to identify what is slowing it down now another thing that i haven't covered yet is that you can combine different decorators and this happens by just adding them with the different add statements on top of each other and we already have another decorator so let me call this original decorator and let's run all of this again and now let me go through them i have decorator begins and decorator ends that is what we are getting up here from this original decorator besides that we have the duration of the decorator and this is what we are getting from this print statement here and the actual function so this print here is this line meaning now even though we have a very simple function by using decorators we can give it a ton more extra functionality without making any changes to it which is well the entire idea of a decorator if you understand this it can be really useful in very specific circumstances although if you are a beginner you probably just are going to add more stuff to this function although well if you know decorators you don't have to and this makes it much cleaner to work with your functions but alright let's do another exercise on this i want you guys to create another decorator that calls a function twice and this decorator should be called with this decorator and this decorator as well so that this function has three decorators in total and let's see how far you get again i have to create another function and let's call it the double decorator and in here once more we need a function and inside of this function i want to create a wrapper it doesn't need any arguments again and now in here i want to call my function twice which i just do by calling my function twice it's very simple once it comes down to it and once i have that i want to return the wrapper once more oh and by the way i'm just calling this wrapper because i think it makes sense you could call this whatever you want there's no naming restriction and all right now what i can do i can add another decorator with the double decorator and now if i run all of this we have to wait a second and if i expand this we have the code being executed once and then twice and well this is working really nicely and here again our actual function is really simple and we are just adding more and more stuff to it and that way it gets more and more complex with that we have some very basic decorators now there are some more things we can do with them and what i want to cover for this part is that you can have functions with parameters being decorated that part is actually really simple and besides that decorators themselves can also have parameters although implementing this gets even more complicated because we are wrapping a function inside of a function inside of another function so this we will have to explore in quite some more detail but let's have a look at all of this here i am back in a completely empty sheet of code and i want to create a new function so define function and now i want to have a function parameter it doesn't really matter what it is and in my case i am just going to print that function parameter and now once we have that i can call this function with whatever i want let's say hello and if i run this i get hello a super simple function and to decorate this we kind of need the same thing we have done here it's not really that much more complicated as a matter of fact let me actually copy this decorator here and paste it in here and now i want to decorate this function with the decorator and just as a reminder this would be the same thing as calling function is the decorator with the function however now if i call this i am getting the decorator takes zero position arguments but one was given and this happens in this one as well as in this one so we're getting the same error message that's usually a good sign at the very least the problem python has is that this function needs this parameter so when we are calling the function up here we again need the parameter but on top of that when we call this function here we are calling this wrapper and right now when we are calling hello we are passing it essentially into this parameter here which doesn't exist yet which is why python is so unhappy and to get around this we just have to create the parameters meaning this wrapper here and this function need the same parameters or well for this wrapper it's a parameter for this function it's an argument and let me name them properly here i want to have a wrapper parameter and now if i run all of this again we should see a different error message and that is that func is missing one required position argument func parameter meaning this one here and well i get this argument from the wrapper parameter so now if i run this we get hello and if i change this argument to something this is still working and we could also do this the other way the more traditional way and we will get the same outcome and let me just go over what is happening here by using the traditional style to make it a bit easier to explain we are again calling this decorator function here and passing in the function itself now inside of this decorator we are creating all of this here and right now the wrapper has one parameter the wrapper parameter and then inside of this wrapper function we are calling whatever code we want and we also have the original function here and then we are passing the wrapper parameter as an argument inside of this function and once we have all of that at the end of the code we can just call the function with something and then this something would be passed into the parameter for the wrapper and then this would be passed into the original function now what you see very often for the rapper you don't have one specific argument instead people very often just add arcs with a star and then double quarks and then this you pass into whatever original function you have so if i run this we get the same outcome and these are very simple unpacking operators this one is for a list and this one is for dictionary or keywords and the reason why these are used is because they allow for this decorator to accept basically any kind of function with any kind of parameter right now we only have one parameter but we could also have more name parameters an unlimited amount of arguments it doesn't really matter if you have this setup you can accept any number of arguments or named arguments which means that this decorator works with literally any function without limitation and all right with that we have basic parameters what we can also do let me uncomment the decorator let's try if this is working it does what we can also do is create a decorator that is accepting other arguments like a 10 for example but for that to work we need something even more complex so let's do this in a separate file all right and here once more we have an incredibly simple function if i call this function we can see function and now what i want to do i want to create another decorator and let's call this one a repetition decorator and this one should accept one argument by how many times i want to repeat this function here for example if i add a five in here i want to repeat this code five times when it's being called or rather i want to call it five times when it is being called now for that to work we need some pretty extensive setup and let me go through what this would look like i am first going to create the actual decorator so repetition decorator but this one is not going to accept a function instead it is going to accept this argument here so in my case i want to call this the repetitions and now inside of this i am creating another function and this is the actual decorator and this decorator is going to accept a function and now inside of this decorator i want to create the actual wrapper and this one in my case has no arguments and what i want to do is for let's call it r in range repetitions i want to run my function and now what i have to do i have to inside of the decorator i want to return the wrapper and then inside of the scope of this repetition decorator i want to return the actual deck curator and now if i run this it is going to work five times and i can change this to a 20 and we will call this function 20 times now the question is why does this work so let's go over it and let's do this in a traditional way which i guess i haven't done yet but if we didn't use decorators and still wanted to use this it would look like this i'm still using my func variable name and now i want to call the repetition decorator and now for this repetition decorator i have to specify how many repetitions i want let's say 4 in this case and after i have that i am calling whatever i get from this and passing in my function and if i run this we get function 4 times now if you look at this this is probably really confusing but to understand this you basically have to understand the return statement and let's go through it one by one first of all we are calling the repetition decorator and passing in four that is this line of code here and this one by itself doesn't actually do all that much all we are doing is creating a new function and returning it so all we are getting from this repetition decorator with a 4 is this decorator here a new function meaning this decorator here is going to replace the entire decorator we have seen so far and on this new decorator we are calling the new function this one here meaning now we are passing this function inside of here and this function is being captured inside of this parameter and once we have that we are basically back to a normal so inside of this decorator we have a wrapper and this one just loops over the range of repetitions that we get from up here and then inside of that we are calling the function and then we are returning the wrapper and then this wrapper is being stored inside of the function and we can call this function and then we are repeating it by whatever we specified in here and well if i comment this out again and return to my decorator let's add four in here and we still get four repetitions and i would really recommend you to practice this in your own time although if you're just starting don't worry too much about it just get used to functions and classes by themselves and once you are a bit more comfortable start working on decorators they are definitely one of the more advanced topics in python although there is going to be another section and this is where you are probably going to use decorators the most as a beginner and that is to use decorators inside of classes so let's talk about decorators inside of classes and there's one really important one it is called property and what this allows us to do is it allows us to turn methods into attributes and this is something we get from the property function that we can use inside of python it actually comes with python and i'm pretty sure all of this is going to sound really cryptic if i just explain it theoretically so let's do all of this in code that should be better all right here i have a completely empty python file and what i want to do is to create a new class let's call it generic and in here i want to create a dunder init method and this one itself and nothing else and what i want to do in here is create one attribute let's call it x and let's set a value for 10 it really doesn't matter what it is and now i want to create an object from this class let's call it generic and i just want my generic class and now i can print generic dot x and i should get 10 and indeed i do and now what i want to do is i want to observe this x here meaning whenever i look at it so i retrieve the value or when i change the value i want to run some other code and this by itself in python isn't really that easy to do i guess what you could be doing is run some kind of function that let's call it get x in here self and in here i could return self.x and then besides that i could print some other code let's say get x and now inside of this print statement instead of x i want to get x and don't forget to call it if i run this i get get x and the value so when i get x i can run some other code and this is fine by itself but it's not very elegant and again like we have seen with the other decorators what happens if i already have a lot of code let's say i have this generic x 10 times in my code and i don't want to change all of these instances here i just want to change my class itself to account for that that whenever we get x i want to run some other code and this we can do but we need some special function in python and this function is called property and into this property function we can pass in a getter a setter and a deleter and then we can assign all of this to one attribute inside of our class let's say x right now and then this x is what we are actually going to work with so now when we are calling generic x this line here this x refers to this x here and then when we are just looking at this x we are calling the getter method when we are changing this x we are calling setter and when we are deleting this x we are calling deleter meaning now what you usually see with this the original attribute we have this x here we are turning into a private method with an underscore before it and now to python this x here and this x are two separate variables but i as a programmer still know that they're the same because of the naming convention here and now basically what i'm going to do for this getter i am going to return underscore x and with that we have a getter so this method here is going to be this getter meaning whenever we are calling this generic x we are calling this get a method which is then returning this underscore x and essentially what we are doing here outside of the class we are working with x and this is what we are accessing but inside of the class we are using underscore x and this is what actually keeps track of the value and now basically what we have to do besides a getter we also need a setter so let me change it and for the setter we need self and a new value and when we are calling this let me run set x and then self underscore x should be the value and this we do not want to return and finally besides that let me copy it one more time i want to have it deleter this one doesn't need a value and what i want to do in here is delete x and all we have to do for this one is to run del and self dot underscore x and now i can run this and let me make this a bit smaller now when i print generic x we get get x and the value of x meaning we have run this method here what i can also do before i'm printing x i can run generic x is equal to 4 and now if i run this i am setting x and i'm getting x and then i get the actual value of x and finally what i can do i can also run delete and generic dot x and now if i run this i have set x get x the value of x and delete x meaning now whenever i for example get the value of x i can run whatever other code i want and for example what i could do with that i could import from date time that's not how you spell that from date time import date time and i want to know whenever i get x which i get by just printing the date time dot now and now if i run this i am getting the current time when i'm accessing x and since we're just returning this underscore x you could even make changes to whatever x you get depending on the time of day some other variables some basically anything you want to look at which is why all of this is really powerful and i would recommend to go over this in your own time it's really useful but just to go over it really quickly again i think that's going to be useful when we are initiating this class we have underscore x this one here and this is the variable we actually storing values in right now that is 10 but it really doesn't matter what it is once we have that we are running this line here and this one turns x into a property and this property has a getter a setter and a deleter and those are referring to this getter here this setter here and this deleter and now from outside of the class whenever we are accessing this x here we are running either of these methods and these methods then influence self.x which is where we actually store the value so this one here and that way when we are accessing changing or deleting a value we can run whatever code we want in there and i hope this is making sense this is again something slightly more advanced that you probably want to practice on your own time but what python developers also realized is that this isn't exactly an elegant way of writing all of this which is why this property works really well as a decorator and let me copy the entire class to implement this as a decorator and let me comment out all of this and basically how you would implement all of this as a decorator for the getter you would simply add the add property decorator although then the getter you would rename to the name of the property which in my case is this one here so i just want this to be x now for the setter i want to get another decorator and this one you would call with the name of the property in my case again x and now you would add dot setter and then the actual method would also be called x or the name of the property and finally the same works for deleter so we need x dot deleter and now the name of the method should also be the name of the property so x in my case and now once we have that i can get rid of this property here and now this code does the same as this code up here meaning if i run all of this we get the exact same result except now it's a bit easier to read i suppose and this is something you are going to see reasonably often even as a beginner because running some code when you're just changing a value or even when you're just looking at the value can be really powerful so understanding this here or at least being able to replicate it by yourself is going to be something you do want to practice but again this is all very advanced so if you're just learning python and all of this is too much don't worry about it you are not going to use it for quite some time and it would be much more valuable for you to understand classes and functions by themselves so don't stress yourself if this is too much but anyway this is all you need to know to get started with decorators and i hope that was helpful in this video we are going to cover eval and exec which are two fairly special functions in python let's talk about them both eval and exact are simply functions inside of python the thing that makes them special is that both of them translate strings into python code in practice this would look something like this if i'm running eval 1 plus 1 this would return the operation 1 plus 1 which would give me a 2. and notice here this one plus one originally was just a string nothing else and with eval we are turning this string into an actual python operation which can be incredibly powerful as a matter of fact you could even create new variables from a string which i guess very occasionally can be incredibly useful and while it overall gives you a ton of flexibility however there's something really important and that is you have to be extremely careful when using exact or eval for the simple reason that if you handle these functions badly it allows users to run their own code inside of your code which if you for example run a database might end up with them stealing all of your data for example you might have some kind of input field and this field was originally designed to handle names from users and then you use the eval or exec function to update this kind of name to make sure there are no typos or something like that a user instead of writing a name could just add a ton of code and thereby accessing your database and if that happens you probably are going to be in a lot of trouble so be really careful when you're using these functions they can end up horribly wrong but alright before we jump into code let's talk about the difference between the two eval is the simpler of the two functions it only evaluates code which means you can run functions or simple operations but you cannot create new variables or run if statements or stuff like that for that you would need exac this is the more powerful one and it basically is capable of running any kind of code and let's have a look at both and let me start with eva i need to type eval and now in here i can write any kind of simple statement for example 5 plus 10 and if i execute this we don't get anything because this only returns a value it doesn't print it meaning i have to put all of this inside of a print statement if i run this now we are getting 15. and we could even run some kind of code for example what i could be doing is create another string inside of the string with the different quotation marks and let's call this one test and on this test i can call the upper method and run this now and we are getting test essentially what happens is that python just removes these quotation marks and then runs all of this as normal python code however there are limitations especially for eval for example what i couldn't do is print eval if true then print let's say test and if i run this we are getting an error that we have invalid syntax and the invalid syntax we are getting because if true or an if statement in general cannot be run inside of eval for that you would need exec if i run this now this is working just fine and this is a more general theme that in eva we are quite limited in terms of what we can do another example would be i couldn't assign a new value to a variable so in eva i couldn't do something like a equals 10 i would be getting a syntax error however if i use exec this would work just fine and after running this code we have a variable a meaning i can print a and we get 10. the value of this 10 here and that is the entire idea behind exec and eval now most of the time especially as a beginner you are not going to use them whatsoever because there are certainly more advanced things however there's one good example that i think can be quite valuable let me copy in four lines of code and i guess i can comment out the earlier stuff what you're looking right now is i have my string and this is just a string and on this string i'm running upper title lower and case fold meaning if i run the code now i get all of these results the issue here now is we have four lines of code for something that is actually really really simple and using eval here could shorten all of this quite substantially and this i think could actually be a really good exercise try to express these four lines here using an eval statement and if you want a tip this should happen inside of a for loop try to figure this one out yourself i first of all have to convert upper tidal lower and case volt into some kind of string and in my case let me just copy it it is looking like this and i want to cycle over this with a for loop meaning i want to do for operation inside of this list and now inside of this i want to run my eval function and in here i need a string of my string and on this i want to run each of these operations and this i would do with an f string and inside of that i want curly brackets and my operation and importantly we do want to call these functions which means i want brackets so for example we are starting with upper and this is going to be inserted in here for the operation which means we are ending up with my string dot upper and then we're adding brackets to actually call this method and eval then basically removes the quotation marks and turns all of this into valid python code and the last thing we have to do is to actually print this so we can see the result let me add the print statement and comment out this earlier stuff and if i execute this now we get the very same result and this may be a bit arguable but i think this is much easier to read than these four lines here but both approaches would be perfectly fine and well with that we have eval and exec
