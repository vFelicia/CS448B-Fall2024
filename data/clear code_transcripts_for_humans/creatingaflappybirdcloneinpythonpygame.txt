With timestamps:

00:03 - [Music]
00:09 - hello there in this tutorial we are
00:11 - going to be creating this flappy bird
00:13 - clone in pie game
00:15 - it's ultimately a fairly simple project
00:17 - there really isn't too much to explain
00:19 - before we start i guess the one thing i
00:22 - do want to talk about is the folder
00:24 - setup here is our game folder and we
00:27 - have three subfolders we have code
00:29 - graphics and sounds and sounds is the
00:31 - easiest one it's just two sounds for
00:33 - jumping into background music
00:35 - then for graphics we have the
00:37 - environment font obstacles plane and ui
00:41 - all of these i think are fairly
00:43 - straightforward
00:45 - and then finally we have the code
00:47 - section and then here right now we have
00:49 - two files we have main and we have
00:51 - settings
00:52 - and we are going to add quite a bit more
00:54 - in here but let's go into the code and
00:58 - let's have a look at this
00:59 - and that's actually bringing us to the
01:01 - very first part of this project the
01:03 - basic setup so i'm just going to go over
01:06 - the parts we already have and once we
01:08 - have that part covered we can actually
01:09 - start adding stuff to it so let's have a
01:12 - look
01:13 - so here we are in the files we have
01:17 - main.pi and settings.pi and settings.pi
01:20 - is the easier one in here we just have a
01:23 - couple of constants so we have the width
01:25 - and height of the window and our frame
01:27 - rate and besides that well nothing else
01:30 - is happening in here so we can more or
01:32 - less ignore this file
01:34 - the main.pi file is the much more
01:36 - interesting one
01:37 - and if i run this one we can see a black
01:41 - window that doesn't really do anything
01:43 - right now
01:45 - but let's talk about the code really
01:46 - quick before we do anything else
01:49 - at the top i am importing a couple of
01:51 - basic things for pygame so we have pie
01:53 - game itself sys and time
01:56 - and then besides that i am importing
01:58 - settings and all the constants so that's
02:01 - the stuff we have created up here
02:03 - and we are using all of this to create a
02:05 - game class i will explain this one in
02:08 - just a second but what we are
02:10 - essentially doing is we are checking if
02:12 - our current file is the main file
02:15 - and if that is the case we are creating
02:17 - one instance of the game class and then
02:19 - we are calling game.run so this really
02:22 - isn't anything complicated
02:24 - so let's have a look at the game class
02:26 - itself it's not too difficult i think
02:30 - we first of all have a setup part in the
02:33 - init method and then here we are calling
02:35 - init on python we're creating a display
02:37 - surface
02:39 - then we are giving it a title and we are
02:41 - creating a clock so all of this is
02:43 - really basic pie game
02:45 - if you have no idea what any of this
02:47 - does check out my introduction to pygame
02:49 - it explains all of this in quite some
02:51 - detail
02:52 - now besides that
02:54 - we also have a run method all of this
02:57 - here
02:58 - and all we really have in here is a
03:00 - while loop and in this while loop we are
03:03 - updating pi game and we are calling the
03:04 - frame rate
03:06 - besides that we also have an event loop
03:08 - and we are using delta time
03:11 - if you have no idea what delta time is
03:13 - check out this video i have explained
03:15 - all of it there it's basically there to
03:17 - account for different frame rates
03:20 - and there's one more thing i would like
03:22 - to do to set up this project i want to
03:24 - create two pi game sprite groups
03:27 - one is going to be called all sprites
03:29 - and this one is going to contain well
03:31 - all the sprites and it's going to draw
03:34 - and update them
03:35 - and besides that i want another group
03:38 - that is called collision sprites
03:40 - and this one is later going to contain
03:41 - all of the things our player can collide
03:43 - with so the floor and the obstacles
03:47 - and as a challenge try to create these
03:49 - two groups yourself
03:54 - all i need to do let me add another
03:56 - section let's call it sprite groups and
04:00 - here i want to have self.all
04:02 - sprites and this is just going to be
04:05 - pygame.sprite.group
04:08 - and then i can copy the entire thing and
04:11 - let's call the second one collision
04:14 - sprites
04:15 - we are not going to do anything special
04:17 - with either of them they are just going
04:19 - to contain some sprites
04:22 - and all right with that we have the
04:24 - first part covered so now we have a
04:26 - basic setup
04:27 - next up i want to work on the background
04:30 - and this one i want to be moving
04:32 - continuously in the background
04:35 - and that isn't too much of a difficulty
04:37 - although there are a couple of things we
04:39 - have to take care of
04:40 - but i guess let's jump straight into it
04:42 - and let's have a look at it here i am
04:44 - back in the project and i want to create
04:47 - a new file that i'm going to save as
04:51 - sprites.pi
04:52 - because this one is going to contain all
04:54 - of our sprites
04:56 - and first of all i have to import pygame
04:59 - itself
05:00 - and besides that i also want from
05:02 - settings import star so all of this
05:07 - stuff here
05:09 - once we have that i want to create a
05:11 - class that i called bg for background
05:14 - and this one is going to be
05:14 - pygame.sprite.sprite
05:17 - a basic sprite
05:19 - and for this one when we called the
05:21 - dander init method
05:23 - i want to have self and for now i want
05:25 - to have groups although we are going to
05:27 - need one later on but don't worry about
05:30 - that for now
05:32 - now the first thing we always have to do
05:34 - is call this super that's not how you
05:36 - spell that the super and the dander init
05:39 - method and pass into groups so whatever
05:42 - group we pass in here for example our
05:45 - all spreads group
05:47 - then this sprite is going to be
05:48 - allocated to these groups which is
05:51 - exactly what we want
05:53 - now besides that
05:54 - we need to set self.image and we need
05:58 - self.rect
06:00 - and we do have an image this one we can
06:03 - just import with pygame.image.org
06:07 - and for the folder we have to go one
06:09 - fold up and we have to go to graphics
06:12 - there we have environment
06:14 - and inside of environment we have
06:16 - background.png
06:18 - and as always don't forget to convert
06:20 - this thing for this one though we don't
06:22 - need convert alpha because there are no
06:24 - alpha values
06:26 - and once we have that for the rectangle
06:29 - i just want to get self.image dot get
06:31 - underscore rect and the top left should
06:34 - be at position 0 and 0.
06:36 - so we essentially create an image that
06:39 - we are placing in the top left of the
06:40 - window so far this really isn't anything
06:43 - difficult
06:44 - and i realized i have a typo in there
06:48 - so back in my main file
06:50 - i want from sprites import bg
06:55 - and then
06:56 - after i've created
06:58 - sprite groups let's add another section
07:01 - and let's call this one
07:03 - i guess sprite setup doesn't sound too
07:06 - bad
07:07 - and what i want to do in here
07:09 - is to create my background
07:11 - and i have to pass in the sprite groups
07:14 - and in my case this is just going to be
07:16 - self.all sprites so this argument is for
07:20 - this parameter here
07:22 - and now around all of this we can see
07:25 - nothing for the simple reason that we
07:27 - are not drawing this spread group that's
07:30 - the one i forgot just now so in my game
07:32 - logic
07:34 - i want self dot all sprites dot draw on
07:38 - self dot display
07:40 - surface
07:42 - and now let's try this
07:44 - but now we can see a problem that this
07:46 - thing is way too small and it needs to
07:48 - be much bigger nearly twice as big
07:51 - actually
07:52 - so this image here should scale all the
07:54 - way down to the bottom of the window
07:57 - and for that we have to scale method but
08:00 - there's a bit of a problem
08:01 - so essentially what i want to do
08:04 - when i import this image i don't want to
08:07 - set it straight as the image of the
08:09 - window so let me first import it as
08:12 - another variable
08:14 - and let's call this one bg underscore
08:17 - image
08:20 - and for now this is going to be the same
08:22 - image
08:23 - and what i could be doing now is
08:27 - when i create the image i could call
08:28 - pygame.transform.scale
08:33 - what scale essentially does is it takes
08:36 - a surface
08:37 - and a scale and this scale is going to
08:42 - determine how big the surface is going
08:43 - to be
08:44 - for example
08:46 - if i pass in
08:48 - our window width and our window height
08:50 - let's actually copy those from settings
08:52 - so window width and window
08:56 - height
08:57 - and for the surface i just want my bg
09:00 - underscore image
09:03 - if i run this now
09:05 - we get an image that covers the entire
09:08 - background
09:09 - the problem now is that all of this is
09:12 - kind of weirdly stretched you can see it
09:15 - especially at the clouds so this bit
09:17 - here looks kind of weird
09:20 - and that's what i want to avoid
09:22 - and i guess the best way to think about
09:24 - it is to open all of this in photoshop
09:26 - and explain what we have to do instead
09:31 - alrighty here you can see the entire
09:33 - thing in photoshop
09:35 - the black frame is our pie game window
09:37 - and the blue thing is our background and
09:39 - you can already see the initial problem
09:41 - that our background doesn't cover the
09:43 - entire frame of pie game
09:45 - and what we have done just now of the
09:47 - scale method
09:48 - is to change the scale of this thing to
09:51 - something like this
09:53 - which does work but stretches the
09:56 - background image quite a bit so i don't
09:59 - really like that one so let's undo it
10:01 - and essentially what i want to do is i
10:03 - want to keep the aspect ratio of this
10:05 - thing constant
10:07 - meaning that the width of this thing
10:10 - and the height of this thing
10:13 - should keep the same ratio towards each
10:15 - other
10:16 - so i guess right now the image is always
10:19 - about 1.5 times as wide as it is high
10:24 - and when i scale it i want to keep the
10:26 - same ratio
10:28 - which in practice means i want to do
10:30 - something like this
10:33 - and once we're doing that the entire
10:35 - thing is going to look significantly
10:37 - better
10:38 - but to achieve it we are going to need a
10:41 - bit of math
10:43 - but let's do this once trading code i
10:45 - think that's going to make more sense
10:47 - here i'm back in the project and the
10:50 - first thing i want to do is to get rid
10:52 - of the scaling method
10:54 - so let me copy this thing back to what
10:57 - it used to be
10:58 - and copy this one out
11:00 - and now i've run this again
11:03 - we can see the thing we had earlier
11:06 - so let's talk about what we have to do
11:08 - essentially i want to get this image
11:11 - here so let me just make a square and i
11:14 - want to multiply this
11:16 - by a certain size so this is what we
11:19 - need to find out
11:20 - and
11:21 - the result
11:23 - of that multiplication should be an
11:25 - image large enough to cover this
11:29 - entire height of the window which in my
11:31 - case right now is 800 pixels on the
11:34 - y-axis
11:36 - so let's say for simplicity in here this
11:38 - one should become
11:40 - 800. for
11:43 - y
11:44 - and this means we have to find this y
11:47 - here
11:48 - and how can we do that let me actually
11:50 - get rid of all of this text here to
11:54 - figure out what we have and how we can
11:56 - use it
11:58 - so we still know our entire window is
12:01 - 800 pixels high and we also know how
12:05 - high
12:06 - this surface here is that's something pi
12:08 - game can give us
12:10 - let's say for simplicity here this is
12:12 - 400 pixels high
12:15 - so what we essentially want to know
12:17 - is by how much do we have to multiply
12:21 - 400 to get to
12:23 - 800.
12:25 - now obviously this by itself is a very
12:27 - simple calculation but we want to make
12:29 - this a bit more flexible so at the
12:31 - height of this surface could be
12:33 - basically anything and the formula would
12:35 - still work
12:37 - but really all we have to do to get this
12:40 - y here
12:41 - is to multiply
12:43 - the height
12:44 - of the entire window
12:46 - divided by
12:48 - the height of the background
12:51 - this number simply came from moving this
12:53 - 400
12:55 - down here and then using it as a divider
12:57 - for 800. so very simple math
13:01 - all right let's actually implement this
13:04 - this number i do want to reuse later on
13:08 - so i am going to get this number in my
13:10 - init method you're going to see later on
13:12 - why this is going to become important
13:14 - and essentially i want to create
13:18 - another section and let's call this one
13:22 - the scale
13:24 - vector
13:26 - and the first we have to do in here is
13:28 - to actually get my bg
13:30 - height
13:32 - and for this one i want to get my pie
13:34 - game.image.load
13:37 - and the image i already have it's this
13:40 - path here now for this one we don't
13:43 - really care about the image we just want
13:45 - to know how tall it is or how high it is
13:47 - so all i want to do is get underscore
13:50 - height
13:52 - and let's actually print it to see if
13:54 - this is working so bg height and if i
13:56 - run this we get 480.
14:00 - so this entire thing is 480 pixels high
14:04 - and we want to know by what number do we
14:07 - have to multiply this to get to 800
14:11 - so x is just going to be 800 divided by
14:16 - 480
14:18 - and that is a number we can get quite
14:20 - easily
14:22 - and i want to store this number in
14:24 - self.scale underscore vector
14:27 - and all i really want to do here is to
14:29 - get my window height
14:31 - and divide this by bg
14:33 - height
14:35 - and let's print this one just to see
14:37 - what we are getting
14:38 - so self.scale vector
14:41 - is i need to use self as soon as now
14:45 - it's 1.66
14:48 - and this is the number we can now use
14:51 - to create this bg so i want to pass in
14:55 - self.scale vector in here
14:59 - now in my sprite class i can create
15:02 - another parameter that i'm going to call
15:04 - the scale vector as well
15:06 - now the first thing i want to do is to
15:08 - uncomment bg dot image
15:10 - and first of all i want to get my full
15:15 - height and my full
15:18 - width
15:21 - and
15:22 - only once i have those
15:24 - i
15:25 - want to use pygame.transform.scale
15:30 - and in here i again want to use my bg
15:32 - image
15:33 - but now for the scaling part i want to
15:36 - get my full width
15:38 - and my full height
15:42 - and now let's do an exercise
15:45 - try to figure out for yourself how to
15:47 - get the full width and the full height
15:49 - of the bg image that we are going to
15:51 - need
15:52 - and here again the important part is you
15:55 - should scale both of these sides by the
15:57 - same number so the same scale factor
16:03 - all i have to do is to get my bg image
16:06 - and then get for the height get the
16:09 - height
16:10 - and this number i then want to multiply
16:13 - with the scale
16:16 - vector
16:17 - and once i have that i can do the same
16:19 - thing for the width so bg image except
16:22 - now i need to get the width of this
16:25 - thing
16:25 - and multiply this one by the scale
16:27 - factor as well
16:29 - and now we should be good to go
16:33 - let's try this now
16:34 - and there we go this is looking
16:36 - significantly better so now our
16:39 - background does cover the entire image
16:40 - but it's not stretched in a weird way so
16:43 - this is working quite nicely and let me
16:45 - get rid of this print statement here it
16:48 - doesn't seem necessary so now that we
16:50 - have that let's animate it and this also
16:53 - happens in the sprite class
16:55 - all i really want to do in here is to
16:56 - give this one an update method it needs
16:59 - self and it also needs delta time
17:01 - because whenever we move anything with
17:03 - the other time it has to be multiplied
17:05 - with delta time
17:06 - and on top of that i also have to create
17:10 - self dot position and this is something
17:13 - i've explained in my delta time video
17:15 - that when we're using delta time to move
17:18 - we can't really store the position in
17:20 - direct attribute anymore because this
17:23 - one only stores integers but when we use
17:25 - delta time we get lots of floating point
17:28 - numbers and if we start of them as
17:30 - integers we would get inconsistent
17:32 - movement so i want to store all of this
17:34 - in a position that is just going to be a
17:37 - vector so pygm.math.vector2
17:41 - and
17:42 - self.rect.top
17:44 - left so by default we're getting a
17:46 - vector in position 0 and 0.
17:49 - and now all i want to do is self.pause
17:53 - dot x
17:54 - minus equal some kind of speed let's say
17:57 - in my case 300 seems like a good number
18:01 - and this i want to multiply with delta
18:04 - time
18:05 - and once we have done that
18:07 - i want to get myself.rect.x
18:10 - is going to be round self.x
18:14 - and if you're used to normal pi game
18:16 - this does seem kind of annoying but it's
18:18 - the only way to get consistent movement
18:20 - with delta time although grounded it is
18:23 - a bit tedious
18:25 - but alright so now we should be having
18:28 - some basic movement once we're coding
18:30 - the update method
18:33 - so before i am drawing all of my sprites
18:35 - i also want self.osprites.update
18:41 - and now for run this
18:43 - we are getting an error that i forgot
18:45 - delta time
18:46 - now let's try this again and there we go
18:48 - we have some decent looking movement
18:52 - although there we have a problem that at
18:54 - the end we get something weird
18:57 - and the problem here is that i didn't
18:59 - fill the screen with any kind of color
19:02 - so self dot display surface dot fill
19:05 - and let's just fill it with a black
19:07 - color and now let's try this again now
19:09 - you can see what's going on
19:11 - so the image is moving just fine but now
19:13 - the image is moving too far to the left
19:16 - the problem essentially being that this
19:19 - thing keeps on moving left perpetually
19:21 - but we never stop it so at some point it
19:25 - is going to leave the screen
19:27 - and this is kind of easy to change all i
19:30 - really want to do is if self.rect.write
19:35 - is smaller or equal to zero
19:39 - actually let's look at this in photoshop
19:41 - so here you can see the entire thing
19:42 - again and what we're doing right now is
19:45 - once this background is here
19:49 - i want to set it back to
19:51 - this position here
19:53 - so in the if statement we are
19:54 - essentially checking if we are on this
19:57 - position then i want to set the position
19:59 - of this background back to 0 and 0.
20:03 - so once right is small or equal to 0
20:06 - then i want to set self.pause.x
20:10 - back to 0.
20:12 - and now this self.react.x has to be all
20:15 - the way at the end of this
20:16 - so now if we run this again
20:18 - we can see this is kind of working with
20:20 - one exception there we go
20:24 - that we always can see the black
20:25 - background for a while which isn't ideal
20:29 - as a matter of fact it's unacceptable
20:31 - so let's talk about how we can change it
20:34 - and this i guess is best again explained
20:36 - in photoshop
20:37 - so here's what we have just done we have
20:40 - the background image and we're moving it
20:42 - further to the left
20:44 - but once it is all the way to your left
20:46 - you basically can see the background
20:48 - which well looks terrible
20:51 - now the way to overcome this is to
20:53 - simply copy the background
20:55 - and paste it twice like this
20:59 - so we have the same background exactly
21:01 - on the right of the original background
21:03 - and we're always moving them together
21:06 - so now if i move these two things
21:07 - together
21:09 - and i just keep on moving until i hit
21:12 - the right side of the original one
21:15 - then you can see the second background
21:18 - but now if i again move this thing to
21:20 - position 0 and 0
21:22 - then you can see the original background
21:25 - and since both of these are identical
21:28 - this image is going to be the same so
21:30 - the player shouldn't be seeing a
21:31 - difference
21:33 - in practice all we really have to do is
21:35 - to duplicate our background image and
21:37 - make it twice as wide by copying the
21:39 - original image
21:40 - which is honestly a very simple thing to
21:43 - achieve
21:44 - here i'm back in my code
21:46 - and in my sprite i want to create
21:50 - a new self.image that is twice as wide
21:53 - as the original background image and
21:55 - then place this background image on that
21:57 - twice one on the left side and one on
22:00 - the right side
22:01 - and for that
22:02 - this self.image i'm going to rename to
22:05 - full
22:06 - sized
22:08 - image
22:09 - so this is the fully sized image that i
22:11 - want
22:12 - to create twice
22:15 - and now my self dot image
22:19 - is just going to be a pygame dot surface
22:23 - and in here i have to get a width and a
22:25 - height
22:27 - and the height is very easy to get i
22:29 - just want to get my full height
22:32 - which is essentially the number i get
22:34 - from here
22:35 - but for my weft i want to get my full
22:39 - width and multiply this by two
22:42 - which is this number here multiplied by
22:45 - two
22:45 - and this way this self.image is going to
22:48 - be twice as wide as this background
22:51 - image or well rather this background
22:53 - image at its full size
22:55 - and once i have that
22:57 - i want to get self dot image dot blit
23:02 - and i want to paste the full
23:05 - sized image at position 0 and 0 and then
23:09 - i want to do this again
23:11 - but now i want to paste this on the left
23:13 - side being the full
23:16 - width
23:17 - so essentially what we have done is we
23:20 - have created
23:22 - a surface that is twice as wide as the
23:25 - original background image
23:27 - and into this we have pasted
23:30 - background image once at position
23:34 - zero and zero so this point here is
23:36 - essentially
23:37 - this point here
23:39 - once we have that we have blitted the
23:41 - same surface
23:43 - on the right side of this original
23:45 - surface so this point here is this full
23:49 - width
23:50 - and with that we have a double
23:52 - background and now what i want to do i
23:54 - don't want to check anymore if the right
23:56 - side
23:57 - of this rectangle is to the left of the
23:59 - screen instead i want to check if the
24:02 - center x is to the left of the screen
24:05 - actually let me reopen the image we just
24:08 - had so this is our new surface and we
24:12 - now know that these
24:14 - two surfaces are identical
24:18 - so we don't want to check this right
24:20 - side instead we want to check the center
24:23 - x
24:23 - because we know that this is the end of
24:26 - the original surface
24:28 - so
24:29 - this is now what should be working let's
24:32 - try all of this
24:35 - and now let's just keep it running for a
24:37 - couple of seconds
24:39 - and
24:40 - i think this is looking really good
24:48 - and yeah i am quite happy with this so
24:51 - this is looking just fine
24:55 - and all right with that we have a
24:58 - background now next up we can work on
25:02 - the ground and the ground is going to
25:03 - work in basically the same way as the
25:06 - background it's actually a tiny bit
25:08 - easier
25:09 - the reason for that is that i already
25:11 - doubled it in photoshop before this
25:13 - tutorial
25:14 - i am going to explain in a second why
25:17 - that is let's first implement it and
25:20 - then i'm going to explain what's going
25:22 - to go different
25:23 - here we are back in main.pi and
25:27 - in my sprites i want to create another
25:30 - class this one i called ground
25:34 - so let's import it straight away and in
25:36 - my sprites class let's minimize class.bg
25:40 - and i want to create class
25:43 - ground
25:44 - and this one is going to be
25:45 - pygame.sprite.sprite
25:48 - and in here i want to create an
25:50 - init method
25:53 - that again is going to need self
25:55 - groups and the scale factor again
25:59 - oh yeah and this is also something i
26:00 - didn't really explain yet that we need
26:02 - to use the scale factor here again and
26:05 - let me explain right now why
26:07 - so when we scaled the background we also
26:10 - want to scale the ground by the same
26:12 - number so that those two stay relative
26:14 - to each other
26:16 - and the bg is what determines how big
26:19 - the scale factor is going to be which is
26:21 - why we get the scale factor essentially
26:23 - from this number
26:25 - but later on we're also going to scale
26:27 - the plane and all of the obstacles by
26:29 - the same number and this is important to
26:31 - keep the game consistent
26:34 - so i hope that makes sense all right now
26:37 - we have those numbers
26:38 - i again need super
26:41 - and under init
26:44 - and we pass in the groups in here
26:46 - now once we have that i want to get my
26:49 - ground let's call it ground surface
26:53 - and this one is going to be pygame dot
26:55 - image dot load
26:57 - and in here we need a string that goes
27:00 - up a folder to graphics
27:02 - then we have environment
27:05 - and there we have ground dot
27:07 - png
27:09 - and for this one
27:10 - we need to convert
27:13 - alpha that's actually really important
27:16 - and now this ground surface we want to
27:18 - use for self.image
27:21 - and from self.image we are going to get
27:22 - self.rect
27:24 - all we have to do for the image is to
27:27 - get this ground surface and scale it by
27:30 - the scale vector
27:32 - and we could do this in the same way we
27:34 - have done for the bg class so we have a
27:37 - full height a full width and a full
27:38 - sized image although that's three lines
27:41 - of code it's a bit much so instead what
27:44 - i usually do is pygame dot transform dot
27:49 - scale
27:51 - and here we do need our ground surface
27:54 - but for the scaling
27:56 - what you can also do is to get the
27:59 - ground surface and get underscore size
28:04 - and this i just want to multiply with
28:05 - the scale factor
28:07 - now this by itself wouldn't work because
28:10 - we can't multiply a tuple with a number
28:13 - but we can multiply a vector with a
28:16 - number so i'm going to turn this
28:19 - tuple here into a vector so
28:21 - pygame.math.vector2
28:23 - and now this would be working just fine
28:27 - and this puts the entire logic into a
28:29 - single line which i think is much
28:31 - cleaner
28:32 - now for the rectangle all i really want
28:34 - to do is self.image.getrekt
28:38 - and for the position we now have to
28:41 - think about what we are doing because i
28:44 - can't just put top left at 0 and 0.
28:47 - actually i can but it wouldn't really
28:50 - work let's actually try and see what
28:52 - happens
28:54 - so in my main.pi
28:56 - i also want to get the ground
28:58 - so let's create the ground
29:01 - and the ground for now is just going to
29:03 - be in self dot all sprites and self dot
29:06 - scale vector
29:08 - and i've heard of this
29:10 - we can see why this isn't working the
29:11 - ground is way too high up
29:14 - so this is
29:16 - no good
29:17 - and fixing this shouldn't be too hard
29:20 - and i think this could actually be a fun
29:22 - challenge so try to change this argument
29:25 - here in such a way that our ground is
29:27 - always at the bottom of the window
29:32 - all right all i have to do is get the
29:35 - bottom left and that's the position i
29:37 - want to place
29:38 - and now for this one the x is going to
29:41 - be zero by default
29:43 - but for the bottom height i want to get
29:46 - my window
29:49 - i believe i called it so right now this
29:51 - is this number
29:52 - 800. and with that we're placing the
29:55 - bottom left at the bottom left of the
29:59 - window itself
30:00 - and now let's try this again
30:02 - and that is feeling much better cool
30:05 - and let me just clean this thing up a
30:07 - tiny bit
30:09 - so let's call this the image and then
30:12 - for the rect let's call it the position
30:17 - and i guess while we are at the position
30:19 - we can also animate this thing and for
30:21 - that we again are going to need
30:23 - self.pause
30:24 - and just like we have done before i want
30:26 - to get pygame.math.vector2
30:31 - spelled correctly
30:34 - and in here self.direct dot top left
30:38 - and now
30:40 - i want to create an update map again
30:42 - that is going to be self and delta time
30:45 - and really all i want to do in here is
30:48 - self.post.
30:50 - and then minus equals some kind of
30:52 - number that ideally should be different
30:56 - from this 300 so that those two move at
30:59 - different speeds which look a bit better
31:03 - and i went with 360.
31:07 - and don't forget multiplying this by
31:09 - delta time is really important
31:11 - and now if
31:14 - self.rect.center x is smaller or equal
31:17 - to zero
31:18 - then self.post.x
31:20 - is going back to zero
31:23 - and then finally self.rect.x
31:27 - is going to be rounded
31:29 - self dot pos dot
31:33 - and that is essentially all we needed
31:37 - now what you could have done is use
31:39 - inheritance because those two numbers
31:42 - are nearly identical
31:44 - that would have cleaned this thing up a
31:46 - tiny bit but well do it in your own time
31:49 - if you really want to it's not that much
31:51 - that it would really justify that much
31:53 - extra work
31:54 - all right let's try this now
31:57 - and there we go now all of this thing is
32:00 - moving and it never stops moving
32:05 - that looks good
32:08 - now you might be asking yourself why did
32:10 - i double the size of this ground surface
32:12 - in photoshop and for this background
32:16 - image we're doing all of this in pygame
32:18 - so this line here
32:20 - and the answer is later on for the
32:23 - ground
32:24 - i want to use a mask to check the
32:26 - collision between the plane and the
32:28 - ground
32:29 - and if i created
32:31 - this self.image this kind of interfered
32:34 - with the mask which was kind of annoying
32:37 - and broke the entire game
32:39 - so this is kind of a workaround it's not
32:42 - ideal but it does work so i hope that
32:44 - makes sense
32:45 - but alright so with that we have our
32:48 - background and our ground
32:50 - so next up we can actually start working
32:53 - on the plane itself then the game is
32:55 - going to look much nicer
32:58 - so
32:59 - let's talk about the plane and this one
33:02 - needs to do a couple of different things
33:04 - it first of all has to animate so that
33:07 - we can see different frames after a
33:09 - certain amount of time besides that it
33:11 - also needs to fall down and be able to
33:13 - jump and the jump is going to be
33:15 - determined by player input
33:18 - and finally we also need some kind of
33:20 - rotation mechanic
33:22 - and later on we also need collision but
33:25 - that well we are not going to worry
33:27 - about right now so what we're going to
33:29 - do for now is create a basic plane that
33:31 - doesn't collide with anything just yet
33:34 - and let's do all of this straight in the
33:36 - game i think that is the easiest
33:39 - so here i'm back in my main file and i
33:42 - want to go to my sprites and create a
33:45 - new class
33:46 - that i have called plain
33:49 - and this one again is going to be a
33:51 - sprite dot sprite dot sprite spelled
33:54 - correctly ideally
33:56 - and in here for the init method i again
34:00 - want self my groups and the scale factor
34:05 - and the first we need in here is super
34:10 - and then the dunder
34:12 - init method
34:15 - and passing in the groups to allocate
34:17 - the sprite
34:19 - now what we are going to need we have to
34:22 - figure out some kind of image and later
34:25 - on some kind of rect for the positioning
34:28 - and for the image
34:30 - we want this to be animated so i have to
34:33 - import a couple of frames first and this
34:35 - i want to put in its separate method so
34:38 - self dot import underscore frames
34:41 - and in here every time i import a
34:43 - surface i want to scale it immediately
34:46 - so i want to pass my scale factor in
34:48 - there
34:49 - now besides that i also want to have
34:52 - self.frame
34:55 - index and this by default is going to be
34:57 - 0.
34:58 - so essentially what's going to happen is
35:00 - that this import frames is going to
35:03 - import a list of surfaces
35:05 - and this frame.index we are going to use
35:07 - to pick one of these surfaces
35:09 - and then for myself.image
35:12 - is just going to be
35:14 - self dot
35:15 - frames and we're going to pick self dot
35:18 - frame index
35:20 - and later on this frame.index we are
35:22 - going to increase to pick another frame
35:25 - and that way we are going to animate
35:27 - this thing
35:30 - and once we have the image we can create
35:33 - self.wrecked and this is just going to
35:35 - be self.image.getunderscorerect
35:39 - and this shouldn't be capitalized
35:42 - and in here we have to think about where
35:45 - we are going to place it and let me draw
35:47 - this out actually
35:50 - let's say this is going to be
35:52 - our entire window and i want to play a
35:56 - starting position to be here
35:59 - ish
36:00 - where the center of the thing is roughly
36:03 - in the middle or well exactly in the
36:05 - middle
36:06 - and the x position has some kind of
36:08 - offset to the left so we're not right at
36:11 - the left edge of the window but there
36:13 - should be quite some space to the right
36:16 - of the plane so we have to figure out
36:19 - this positioning here
36:20 - and basically what i have done
36:23 - i am placing the mid left so i am
36:27 - placing
36:29 - this point here
36:31 - and for this point
36:32 - let me actually get rid of all of this
36:36 - we need an x and a y position
36:39 - now the x is the easier one i just want
36:42 - to get my window height and divide it by
36:45 - two
36:46 - for the x position i essentially get my
36:50 - window
36:53 - and i divided this by 20.
36:58 - if this here again
37:00 - is our entire game window
37:03 - right now we have this entire distance
37:06 - is our width and i think right now this
37:08 - was 480
37:10 - and if i divide this by 20 we get to 24
37:16 - which is roughly
37:18 - this distance here or 1 20th of the
37:21 - entire width of the window and
37:23 - this distance then
37:25 - is going to be the left side of my plane
37:27 - which does give it a nice offset from
37:30 - the left side
37:31 - and that's also relative to the entire
37:33 - window so if the window gets very large
37:35 - this still works
37:38 - and now that we have that the last thing
37:40 - we have to do to get started is to
37:43 - actually create the import frames method
37:47 - and itself and the scale factor
37:51 - and essentially what i want to do in
37:53 - here first of all i want to create the
37:55 - attribute self.frames and that's just
37:57 - going to be an empty list
38:00 - now once we have that let's actually
38:02 - look at our folder and that one is this
38:05 - one and in my graphics i have a plane
38:09 - and in the app we have red 0 red 1 and
38:12 - red 2.
38:14 - so essentially what i want to do is
38:16 - create a for loop that runs three times
38:18 - and imports all of these three images
38:21 - and places them inside of this frames as
38:23 - the scaled surface
38:26 - and this i think could be a pretty fun
38:28 - exercise so try to import these three
38:31 - images of the plane scale them and put
38:34 - them in the surface in the self.frames
38:36 - list and see how far you get
38:41 - first of all i need for let's say i
38:44 - in range
38:46 - three so we're running the code three
38:48 - times
38:49 - then i want to get a surface and this is
38:52 - just going to be pygame.image.load
38:56 - and in here
38:58 - i first of all want to get the string
39:00 - itself
39:01 - and we go up one folder then graphics
39:04 - then plane
39:05 - and inside of that folder we have a red
39:08 - and this could either be zero one or two
39:11 - and this is the same information i get
39:13 - from my eye here so i'm going to turn
39:16 - this string into an f string
39:19 - and place in the i in here
39:22 - now after that don't forget this is a
39:24 - png file and also i want to convert
39:28 - alpha all of this
39:30 - so now we have a surface
39:33 - next up i want to create a scaled
39:36 - surface
39:38 - and this is going to happen in kind of
39:40 - the same way that i have done
39:44 - up here
39:45 - so i'm going to use transform.scale get
39:48 - the surface and then use a vector to
39:49 - scale it up
39:51 - and
39:52 - we want pygame dot transform dot again
39:57 - i want to place in my surface
39:59 - and then for the scale i want
40:01 - pygame.math.vector2
40:05 - and
40:06 - mysurface.get underscore size and then
40:10 - this number i am going to multiply with
40:14 - the scale vector
40:16 - and then just realize this scale factor
40:18 - should be outside of that
40:20 - that is looking better
40:23 - all right and now that we have that
40:25 - self.frames.append
40:28 - and the scaled
40:31 - surface
40:32 - so now that we have all of that back in
40:34 - my main file all the way at the top
40:37 - i can also import the plane and let me
40:40 - spell it properly
40:42 - and then i can create
40:44 - lane
40:45 - and all the parameters we need are the
40:48 - groups and the scale factor so i can
40:50 - just copy them from the ground they
40:52 - didn't change very much so far
40:55 - and now if we are running all of this
40:58 - we can see a plane although
41:00 - you might see that this is way too large
41:04 - so the problem here is that the scaling
41:07 - behavior of some of these images are a
41:09 - bit well if they scale too much it looks
41:12 - a bit weird
41:13 - but that's not that difficult to fix
41:15 - all you really have to do is divide this
41:17 - scale factor by a certain number in my
41:19 - case i divided it by 1.6 and if i run it
41:23 - now
41:24 - this feels much better it would even be
41:26 - a little bit smaller let's say 1.7
41:30 - yeah i guess that even feels better
41:32 - and i guess depending on your resolution
41:35 - play around with this number and see
41:36 - what looks best this is partly
41:38 - subjective and partly depends on what
41:40 - you feel is best for the game
41:42 - so just see what feels good and i'm sure
41:45 - you'll be fine
41:46 - but all right so now
41:48 - we have a plane
41:50 - and i guess now we can start working on
41:52 - the gravity and on the jumping mechanic
41:56 - and for that since we are going to move
41:57 - the plane i want to give it a
41:59 - self.position again
42:01 - that is going to be pygm.math.vector2
42:06 - and
42:07 - self.rect.top left
42:10 - and now we are going to need two more
42:12 - things for the movement and let me put
42:14 - those in a separate part let's call it
42:17 - movement
42:18 - and first of all we need some kind of
42:20 - gravity
42:22 - and in my case gravity is 20.
42:26 - and then besides that i also want to get
42:28 - self.direct
42:30 - and this by default is going to be zero
42:34 - and the reason why we need direction is
42:36 - because our plane can go up and down
42:40 - whereas for the ground and for the
42:41 - background they always went in the same
42:43 - direction but for this one it's slightly
42:45 - different which is why we have a
42:47 - direction
42:49 - but now that we have that
42:50 - we have to create a couple of methods
42:54 - i guess the first one we can start with
42:56 - is define update we need self and delta
42:59 - time in here again
43:01 - and in here ultimately i want to create
43:04 - three different methods they're called
43:06 - self dot gravity
43:08 - then i have self dot animate and finally
43:12 - self.rotate
43:15 - and what is important is that all three
43:17 - of those are going to need delta time
43:21 - and for now i am only going to work on
43:24 - gravity so let me comment out the other
43:26 - ones so let's create the method
43:30 - gravity
43:32 - and we need self and delta time
43:35 - and the really important thing you
43:37 - always have to understand about gravity
43:39 - is that gravity is not linear
43:43 - and all this really means is let's say
43:45 - you're standing on a cliff and you're
43:47 - here and you're jumping down you don't
43:49 - fall like this you fall something like
43:52 - this
43:53 - where the longer you fall the faster you
43:55 - fall and this is also what we want to
43:57 - include in here if we didn't it would
43:59 - look very weird
44:01 - and the way this is usually implemented
44:04 - is we first got our self dot
44:06 - self.direction
44:08 - and we add towards it
44:11 - our
44:13 - self.gravity and remember this needs to
44:15 - be multiplied with delta time
44:18 - and now this direction
44:20 - we are going to also add towards our
44:22 - position dot y and this also has to be
44:25 - plus equal and in here we are going to
44:27 - add our self dot direction and this one
44:30 - is also going to be multiplied with
44:32 - delta time and now
44:34 - finally
44:35 - self.rect.y
44:39 - is going to be the rounded version of
44:41 - self.post.y
44:43 - and i guess let's try all of this so now
44:47 - things are not working let's have a look
44:50 - ah the problem i have made right now is
44:53 - that we have a method called gravity and
44:55 - we have an attribute called gravity
44:58 - which is not great so let me rename
45:01 - gravity to
45:02 - apply gravity that even makes a bit more
45:05 - sense
45:07 - and now our plane is going down ever so
45:10 - slightly
45:12 - i guess the amount is a bit low
45:15 - and i guess 20 is a below let's set this
45:18 - to something like 250 i think that's
45:20 - gonna be better
45:22 - and there we go that is more appropriate
45:25 - all right
45:26 - so with that
45:27 - we have a plane that is falling down
45:30 - now to counteract we have to give it the
45:33 - ability to jump so that's going to be
45:35 - the opposite of gravity
45:37 - and this is just going to be another
45:39 - method
45:40 - that i called jump that only needs self
45:44 - and all we really need in here is set
45:46 - our self dot direction
45:49 - to
45:50 - something like let's say negative
45:52 - 400
45:55 - and let's see how far that gets us
45:57 - now the only thing we have to figure out
45:59 - is how to call this kind of method and
46:02 - this we could do in two different ways
46:04 - we could either run a method inside of
46:07 - here that would be perfectly fine
46:09 - although in my case since we're only
46:10 - checking for one simple thing
46:13 - i am going to look at my event loop
46:15 - and in here i am going to check for if
46:18 - event dot type
46:21 - is going to be equal to pygame dot mouse
46:24 - button down
46:26 - so whenever we click the mouse button
46:28 - i want to run
46:30 - this jump method here
46:32 - now for that to work
46:34 - we need to figure out where our plane is
46:37 - and right now we can't it's just one
46:40 - sprite inside of all sprites but we can
46:43 - just assign this after plane to an
46:46 - attribute
46:47 - and now we can target it right away
46:50 - so all we have to do now is self.plane
46:53 - dot
46:54 - jump and that is all we needed now let's
46:58 - run the code
47:00 - and we're getting an error because this
47:02 - needs to be a comparison operator
47:04 - and now if i run this
47:07 - this is kind of working although
47:11 - i think the gravity is still a bit too
47:12 - weak
47:14 - so let me change this 250 to something
47:17 - like 600.
47:20 - and now
47:21 - this
47:22 - feels much more responsive
47:31 - okay um you can play around with the
47:33 - numbers here so the gravity and the jump
47:36 - speed
47:37 - just play around with those and see how
47:40 - far you get and what feels best there
47:41 - isn't really an objective answer it
47:43 - really depends on how you want your game
47:45 - to feel
47:47 - but alright with that we have our player
47:51 - movement
47:52 - now next up we have an animation and a
47:55 - rotation
47:56 - and i guess let's work on the animation
47:59 - and this is just going to be
48:02 - another method with self and delta time
48:06 - and the basic idea how this is going to
48:09 - work
48:10 - is we are going to do the same thing we
48:12 - have done up here
48:14 - that we have a frame index
48:16 - and we are going to use that frame index
48:18 - to pick one frame from our frames so
48:21 - this is a list of surfaces
48:24 - and pretty much what we are going to do
48:26 - we are going to always increase on every
48:29 - single frame our frame index by a very
48:31 - small number let's say by
48:33 - 0.5
48:35 - now if you do this only once you would
48:37 - get to 0.5 and you couldn't use that
48:40 - number for an index
48:42 - so what we are going to do is we are
48:44 - going to take the integer of this number
48:46 - which in practice means we're going to
48:48 - get rid of anything after the period so
48:51 - we are going to get to a zero
48:54 - so on the first frame if we add 0.5
48:56 - we're going to stick to a zero but if
48:58 - we're doing this twice this 0.5 would
49:00 - become 1 and then our frame index would
49:03 - take the next surface that's the basic
49:06 - idea
49:07 - and how this is being implemented is we
49:10 - are first going to get our self.frame
49:13 - index
49:14 - and we're going to add some animation
49:16 - speed
49:17 - just to get some number let's go with
49:20 - five and remember this also needs to be
49:22 - multiplied with delta time
49:24 - and basically now what i want to do is
49:26 - self dot image is going to be self dot
49:29 - frames
49:30 - and in here we want to get the integer
49:33 - of self dot frame
49:36 - index
49:38 - and this would work but we would run
49:40 - into an error really fast and let me
49:42 - explain why right now we have a folder
49:45 - with three surfaces we have zero one and
49:49 - two or red zero one and two
49:51 - and by default
49:53 - we are starting with our index of zero
49:57 - so we keep on increasing this number at
49:59 - some point we get to one
50:01 - at some point we get to two
50:03 - now the problem we have
50:05 - is that we keep on going so our frame
50:09 - index would sometimes reach free then we
50:11 - will get to 4 then to 5 and so on
50:15 - and these numbers don't exist in our
50:17 - list so python would be very unhappy and
50:20 - give us an error message
50:22 - which means in practice what we have to
50:24 - do is after we have crossed a two we
50:27 - want to go back to zero so we are
50:29 - looping back to the first item in this
50:31 - list
50:32 - and that is also fairly easily done
50:35 - all we really have to do is if our
50:37 - self.frame
50:40 - index
50:41 - is greater or equal than the length of
50:44 - our self dot frames
50:46 - and if that is the case self dot frame
50:49 - index
50:50 - is going to be zero
50:52 - and that is all we needed so now back in
50:56 - the file
50:58 - now we have an animation it's a bit slow
51:01 - i guess we can make it a touch faster
51:04 - let's change this 5 to
51:07 - a 10 let's see how that looks
51:12 - and yeah i think this is alright
51:14 - possibly still a bit slow but again play
51:16 - around with this and see what you like
51:18 - the most
51:21 - so all right let me minimize all of
51:23 - these methods so they don't get in the
51:25 - way
51:27 - actually let's do this one here as well
51:30 - and now finally we have to work on the
51:33 - rotation
51:35 - and again another method with rotate and
51:39 - self and dt
51:41 - and the first thing i want to do is to
51:44 - create a new variable with rotated plane
51:49 - and this one is going to be pygame dot
51:51 - transform dot roto
51:54 - zoom
51:56 - now in pygame you have a couple of
51:58 - different methods that can rotate
52:00 - row to zoom i think is the one that
52:02 - tends to look the best because this one
52:04 - applies a certain kind of filter that
52:06 - makes things look a bit better
52:08 - and this method needs three different
52:11 - arguments we first need a surface then a
52:14 - rotation and then a scale
52:16 - now in our case the scale we don't care
52:18 - about so this is just going to be a 1
52:21 - meaning that we don't want to scale
52:23 - anything
52:24 - now for the surface
52:26 - i just want to get myself dot image
52:30 - and finally for the rotation
52:32 - i just want to get my negative self dot
52:35 - direction
52:37 - so
52:38 - the idea here is that the faster we are
52:40 - falling down the more we want to rotate
52:43 - clockwise let me actually draw this i
52:45 - think it's going to make more sense
52:47 - let's say this one here is our plane
52:50 - and if we are going down
52:53 - i want this thing to rotate this way so
52:56 - clockwise
52:57 - and if we are going up then i want to
53:00 - rotate counterclockwise
53:03 - and because of that i want to link my
53:06 - rotation to my direction
53:10 - and what you might have noticed here as
53:11 - well
53:12 - is there is in all of this not a single
53:16 - delta time
53:17 - for the simple reason that we don't
53:19 - actually move anything here at least not
53:22 - directly we're just setting the rotation
53:24 - relative to the direction but we don't
53:25 - rotate anything by itself but with that
53:29 - we can remove delta time from the
53:32 - rotation because we don't need it
53:34 - and now all i have to do is self.image
53:37 - is going to be the rotated plane
53:41 - and well let's try this
53:45 - and
53:48 - well
53:50 - it's a bit high
53:52 - now the problem here is
53:55 - that this self.direction is quite a
53:58 - large number
54:00 - so we want to reduce it by
54:03 - let's say i want to multiply it with
54:05 - 0.06
54:08 - and now if i run this this is feeling
54:11 - much better
54:14 - and that is looking quite good so now we
54:18 - have the rotation the animation and the
54:20 - movement
54:21 - and there's one important thing you
54:23 - really have to understand here
54:26 - that
54:26 - the order of these three methods really
54:30 - matters
54:31 - at the very least the animate method
54:33 - should come before the rotation
54:35 - and i guess let me rotate them around to
54:38 - see what happens
54:40 - we don't get any kind of rotation at all
54:43 - anymore
54:44 - the reason being here is
54:47 - when we rotate something we are setting
54:49 - the image
54:50 - and whenever we animate something we are
54:53 - creating a new image
54:55 - which effectively means we are
54:56 - overwriting anything inside of the
54:59 - rotate method
55:00 - and as a consequence rotate would become
55:03 - basically pointless so just keep rotate
55:06 - after animate and you should be good to
55:08 - go
55:09 - but alright with that we have our plane
55:13 - and let me run it again and this isn't
55:16 - looking bad at all
55:18 - cool
55:19 - so now we can start working on the
55:21 - obstacles and here again the obstacles
55:24 - really aren't that difficult so let's
55:27 - jump straight into the code and let's
55:29 - have a look at this
55:31 - we are back in the main file and i again
55:33 - want to go to my sprites and create a
55:35 - new class
55:37 - that i called obstacle
55:39 - it's also sprite so pygame.sprite.sprite
55:43 - and again we need it under indeed method
55:48 - that needs self groups
55:50 - and let me spell it properly
55:52 - and the scale factor
55:55 - and first of all in here we again need
55:57 - the dander
55:59 - init method and pass in the groups in
56:01 - there
56:02 - and now in here we have to get as always
56:05 - self.image and self.rect
56:08 - but now we have kind of a problem let me
56:11 - actually open the folder to illustrate
56:13 - what's going on so here's the folder
56:15 - with the obstacles and we have two
56:18 - different kinds of obstacles first of
56:19 - all we have zero and one and i want to
56:22 - pick a random one of those two
56:25 - but besides that
56:27 - i also want to randomly make those two
56:30 - either pointing upwards or pointing
56:32 - downwards
56:33 - and all of this i have to create in the
56:35 - init method
56:38 - so
56:39 - the first thing i want to do
56:41 - is figure out or randomly allocate the
56:44 - orientation
56:45 - and since we now need random numbers i
56:48 - want from random import
56:52 - choice
56:54 - and my orientation is just going to be
56:56 - choice between up
57:00 - and
57:01 - down
57:02 - now for the image itself
57:05 - we are still going to import the image
57:09 - but i guess first of all let's
57:12 - move this one down
57:14 - and i
57:16 - want to import the surface by itself so
57:19 - pygame dot image dot load and let me fix
57:22 - the typo and in here we are looking at
57:25 - the folder
57:26 - that goes one folder up then graphics
57:31 - then obstacles
57:33 - and in here we have either the image
57:36 - zero or the image one and i want to pick
57:39 - one of those at random
57:41 - so
57:42 - i have to turn this into an f string
57:45 - and then in here i want to get choice
57:49 - and in choice there should either be 0
57:51 - or 1. and now again don't forget this
57:54 - has to be png
57:56 - and at the end of this we want to
57:58 - convert
57:59 - alpha all of this
58:00 - and now we have to do the same thing
58:02 - again with pygame.transform.scale
58:06 - i want to get my surface
58:08 - then pygame.math.vector2
58:11 - [Music]
58:13 - this surface dot get underscore size
58:17 - and then multiply all of this with the
58:19 - scale vector and all right with that we
58:23 - have our scaled surface but now let me
58:26 - move the rectangle a bit further down
58:30 - i want to check if my orientation
58:33 - is equal to up
58:36 - then i want to leave my surface as it is
58:39 - so let's say for now i want to add a
58:40 - pattern here
58:41 - but if that is not the case so if the
58:44 - orientation is down
58:46 - i want to create self.image
58:48 - and the new image should be this image
58:50 - but flipped around
58:52 - and this we can do with pygame dot
58:54 - transform
58:55 - dot flip and in here we need three
58:59 - different arguments we need the surface
59:02 - we need a horizontal flip and we need a
59:05 - vertical flip and both of these are
59:08 - going to be boolean statements
59:10 - now in my case for the surface it's just
59:12 - going to be self.image
59:14 - for the horizontal flip i want to set
59:17 - this to false because i don't want to
59:20 - flip it in this direction but for
59:22 - vertical this should be true
59:24 - so with that there's a 50 chance that we
59:27 - are flipping the entire image so
59:29 - with that we have to figure out the
59:32 - rectangle
59:33 - and now we kind of have a problem and
59:35 - let me draw this really quick
59:37 - if this again
59:39 - is our entire window
59:41 - if our orientation is downward we want
59:44 - to spawn
59:45 - the mountain somewhere here
59:47 - but if the orientation is upward we want
59:49 - to spawn the mountain at the bottom of
59:51 - the window
59:53 - so we have different kinds of origin
59:55 - points depending on our orientation
59:58 - hence we can't just create a rectangle
60:00 - for every orientation
60:02 - so instead we need one rectangle for up
60:05 - and one rectangle for down
60:07 - so i want to have self.wrecked in here
60:10 - and i also want to have a self.direct in
60:12 - the else statement
60:15 - and in either case i want to get
60:17 - self.image.getrekt
60:20 - so that part stays the same
60:22 - but now we have to figure out which
60:24 - point to place
60:26 - and in my case i think what makes the
60:29 - most sense
60:30 - is if the orientation is up i want to
60:33 - place the mid bottom
60:35 - and if the orientation is down i want to
60:38 - place the mid top
60:40 - so
60:40 - back in my drawing essentially what i'm
60:42 - going to do is if the orientation is up
60:45 - so we're in the bottom one then i want
60:47 - to place this point here
60:50 - and if the orientation is down i want to
60:52 - place this point that way i can just use
60:55 - zero or this green height
60:58 - but now
60:59 - i have to figure out for both of these
61:02 - an x and a y position
61:04 - and this i think could be a fun exercise
61:07 - for you so try to figure out the x and
61:10 - the y position for both orientations and
61:13 - see how far you get
61:17 - the x position for both orientations is
61:20 - going to be the same so i'm going to
61:22 - create that before the if statement
61:26 - and basically what i want to do in here
61:28 - is i want to get my window width
61:32 - and then add a random amount of space
61:35 - so i want to get a random integer let's
61:37 - say between 40 and 100
61:42 - and since we're using rent ind we have
61:44 - to import that one as well and the
61:47 - entire idea for this one is if this is
61:49 - our entire window we are getting
61:52 - this entire width
61:54 - which brings us to this point here and
61:57 - then i want to have some kind of offset
62:00 - here that is a bit random and that way
62:02 - our game looks a bit more organic but
62:04 - that's all it is now for the y position
62:08 - we have to do this for each orientation
62:11 - so the y if we are looking up
62:15 - is just going to be the window
62:18 - height
62:19 - and here again i also want to add some
62:21 - random amount let's say between 10 and
62:25 - 50.
62:27 - and this is going to be the same logic
62:29 - that you have just seen
62:30 - let me move this a bit up
62:33 - so what we want to do is to get to this
62:36 - point down here and wiggle around that
62:39 - point so we want to be in this area here
62:41 - and to get there we essentially need to
62:43 - get the entire height of the window and
62:45 - then add some random amount to it which
62:48 - is exactly what we have done
62:50 - down here
62:52 - and now finally
62:56 - for the downward facing orientation
62:59 - y can just be
63:01 - rand int
63:03 - and in here let's go with negative 50
63:06 - and negative 10.
63:09 - so technically to make this
63:11 - in the same style as this one we could
63:13 - say zero
63:15 - plus rent end so zero is the top of the
63:17 - window and from that we are adding some
63:20 - negative numbers so we're going up by a
63:22 - tiny bit
63:24 - but well we don't need the zero
63:26 - i hope this makes sense
63:28 - and all right with that we have an
63:32 - obstacle
63:33 - what we can do now is give this thing an
63:36 - update method straight away
63:38 - this should be here
63:41 - this one itself and delta time is always
63:44 - oh and what i just forgot
63:46 - we have to set
63:48 - self.position again
63:50 - and this again is going to be
63:51 - pygame.math.vector2
63:54 - and
63:55 - self.rect.top left
63:58 - and now basically all i really want to
64:00 - do
64:01 - self dot pos dot x
64:04 - minus equal let's say 400 times delta
64:07 - times
64:08 - and then self.rect.x
64:12 - going to be rounded self.x
64:16 - and that way this object is going to
64:19 - continuously move to the left now
64:21 - there's one thing i do want to implement
64:23 - straight away
64:24 - and that is if this entire sprite goes
64:27 - too far to left i want to destroy it and
64:30 - if we don't do that at some point we are
64:32 - spawning too many objects and the game
64:34 - will slow down
64:35 - so all we need for that is if self dot
64:38 - wrecked dot right
64:41 - is smaller or equal to let's say
64:43 - negative 100
64:45 - and this means that the right side of
64:47 - the sprite is 100 pixels to the left of
64:50 - the left side of the window the player
64:52 - will definitely never see it again
64:55 - and if that is the case
64:57 - we can run self.kill
64:59 - now i guess technically this number
65:01 - could be zero but i do want to have a
65:04 - bit of a wiggle room here
65:06 - but all right with that we have the
65:09 - entire obscure class that's kind of all
65:11 - we needed but now what we have to figure
65:14 - out is how to spawn this obstacle
65:17 - because we want to spawn this one
65:19 - continuously and for that we are going
65:23 - to need a timer so let me add another
65:25 - section here that i call timer and first
65:28 - of all we need to create an obstacle
65:30 - timer
65:32 - and this one is going to be
65:33 - pygame.userevent
65:36 - don't forget this always wants a plus
65:38 - number by some integer
65:40 - so in my case just plus one and once we
65:43 - have that i want to start this timer so
65:45 - pygam the time dot set underscore timer
65:48 - then self the obstacle timer and now we
65:52 - need to figure out how often this timer
65:54 - should run in my case 1400 milliseconds
65:57 - so 1.4 seconds felt like a good number
66:01 - and now with that one
66:03 - in our event loop
66:05 - we can actually check for
66:07 - this sort of event
66:10 - so in here if event dot
66:13 - type
66:14 - is equal to
66:16 - self dot obstacle timer
66:20 - and if that is the case i want to create
66:23 - an obstacle that's
66:25 - shouldn't be all capitalized
66:27 - so i want to create one instance of this
66:29 - class
66:30 - and i guess for that to work we first of
66:33 - all have to import it so obstacle
66:38 - and now in here we again need two
66:41 - different arguments
66:43 - we need the groups and we need a scale
66:45 - factor so
66:47 - self dot all sprites and self dot scale
66:51 - factor
66:52 - and that should be all we needed for now
66:55 - so let's try this
66:57 - and there we can see one mountain
66:59 - another and there we can see some
67:01 - downward facing ones
67:02 - this is working just fine
67:07 - cool i am quite happy with that
67:11 - now if you want to make the game harder
67:13 - here
67:14 - you could make this scale factor
67:16 - actually a bit larger
67:18 - so for example if you multiply this
67:20 - scale factor with 1.2 i think the game
67:22 - becomes really hard
67:24 - so now the mountains are 20 larger which
67:28 - makes the whole game
67:30 - quite a bit difficult
67:33 - so let's leave it at let's say 1.1
67:36 - but again here play around with the
67:37 - numbers
67:39 - but all right with that we have our
67:42 - mountains we have our plane we have all
67:44 - of the background
67:45 - so what we can start working on now
67:48 - is the actual interaction between the
67:50 - plane and the mountains
67:53 - and the one important thing we have to
67:55 - consider here is that we are going to
67:57 - need a mask but i guess this we are
68:00 - going to talk about when i actually
68:02 - implement it so let's go straight to the
68:04 - code and let's have a look at this
68:07 - here i am back in my main file
68:09 - now there's one thing i first have to do
68:12 - that right now
68:14 - i have all of my sprites so all of my
68:16 - obstacles all of my oh well my plane my
68:20 - ground and my background they're all in
68:23 - all sprites
68:24 - but for the collisions to work properly
68:26 - i need to have first of all one sprite
68:29 - my plane this one i already have
68:31 - but now i need to group with all of the
68:33 - obstacles my plane can collide with
68:36 - and this i don't have right now oh well
68:38 - i have it it's my collision sprites but
68:41 - this collision sprite is empty right now
68:43 - because for now
68:45 - i always put all of my sprites inside of
68:48 - all sprites
68:50 - but this we can change fairly easily
68:52 - so the ground should be in all sprites
68:55 - and self dot collision sprites
68:58 - and this thing i want to copy now
69:01 - and also the obstacles should be both in
69:04 - the old sprites and in the collision
69:06 - sprites
69:08 - and these collision sprites i will use
69:10 - only for the collisions they don't
69:11 - really do anything else
69:14 - so now that i have that
69:16 - i can create another method
69:19 - that i just call collisions
69:22 - in here we need self and nothing else
69:26 - and for now i just want to check if
69:28 - there's any kind of collision between my
69:29 - plane and my obstacles and this happens
69:32 - with pie game dot sprite dot sprite
69:36 - collide
69:37 - and in here we need one sprite we need a
69:40 - group and we need what is called do kill
69:43 - the sprite is the one sprite we want to
69:45 - look at in my case this is myself dot
69:48 - plane
69:50 - the group we want to look at is self
69:53 - dot collision sprites i think i called
69:56 - it yeah
69:57 - and do kill means if
70:00 - this sprite here collides with any
70:02 - sprite inside of this group do we want
70:04 - to destroy that sprite inside of this
70:06 - group
70:07 - now in my case it actually doesn't
70:10 - matter because we want to crash the game
70:12 - as soon as there's any kind of collision
70:14 - so my case i went with false but it
70:17 - really doesn't matter and i guess just
70:19 - to test this let's put this entire thing
70:22 - inside of an if statement
70:24 - and if that is the case let's say pygame
70:27 - dot quit
70:29 - and sys dot exit
70:32 - and now we can call it let's say after
70:35 - the update method so self dot collisions
70:40 - and let's see what's going to happen
70:42 - so the game doesn't throw an error and
70:45 - that looks pretty good i can also just
70:47 - fall on the ground and this also looks
70:49 - pretty good
70:51 - so this is working pretty well
70:54 - however it's not actually working well
70:56 - and let me actually play it again
70:58 - and if i play this for a while so they
71:01 - could see we didn't really touch any of
71:02 - the obstacles but the game still ended
71:05 - and the reason for that is this
71:08 - let me give a bit of space
71:10 - our obstacles look something like this
71:13 - they are some kind of mountain but if we
71:16 - just use this kind of collision mechanic
71:18 - here
71:19 - we are using rectangle collisions so
71:21 - pygame essentially draws a rectangle
71:24 - around this mountain
71:26 - and that is going to be the collision
71:28 - which in our case is a pretty
71:30 - substantial problem because these areas
71:33 - here
71:35 - shouldn't count as a collision but right
71:37 - now they do which makes the game
71:39 - basically impossible
71:41 - also our ground looks something like
71:44 - this
71:46 - so technically if the player is here for
71:48 - example the game shouldn't end
71:50 - but since we are using rectangles
71:54 - our actual rectangle box to check the
71:56 - collision is something like this
71:59 - so even if the player is in some kind of
72:01 - valley the game would still consider
72:03 - this a collision right now
72:05 - so all of this combined this isn't
72:08 - really working right now
72:10 - and the workaround we have to go with is
72:12 - mask collisions now i have made a whole
72:15 - tutorial exclusively on how to use a
72:17 - mask for collisions and for basically
72:19 - anything else in pygame so check this
72:22 - tutorial if you want to get an in-depth
72:24 - look at this
72:26 - but in the most basic sense a mask just
72:29 - collects all of the pixel positions of
72:31 - each of our sprites and then checks the
72:33 - collisions between them it's really easy
72:35 - to implement
72:37 - and well let's do it right now
72:39 - so
72:40 - i want to get a mask for my plane my
72:42 - obstacle and my ground and i guess the
72:45 - ground is the easiest one let's start
72:46 - with this one
72:48 - we actually only need a single line of
72:50 - code and let me add another comment here
72:52 - mask
72:53 - and we have to add self.mask
72:56 - and this has to be called mask you
72:59 - cannot give this any other name
73:01 - and now to get our mask we need pygame
73:05 - dot mask dot from underscore surface
73:10 - and then here we just need a surface and
73:12 - in my case this is going to be self dot
73:15 - image
73:16 - and now we have a mask for our ground
73:20 - and this line i can actually just copy
73:23 - and minimize the ground and for the
73:25 - obstacle
73:26 - i can just add a mask in here at the end
73:29 - that's basically all we needed
73:33 - so we can minimize this one as well now
73:35 - for the plane things get a bit more
73:37 - complicated but first of all
73:39 - when we call the init method
73:41 - we need our mask so it has to be in
73:44 - there as well
73:45 - the problem for the plane
73:47 - is that we are updating this surface so
73:52 - this surface here
73:53 - quite a bit before we are actually
73:55 - drawing it
73:57 - so this animate here and this rotate
74:00 - here in particular change the actual
74:02 - surface
74:04 - and in practice think of it like this
74:07 - if this is
74:10 - our surface for the plane when we are
74:12 - finishing the animate method
74:15 - then we have a mask that's going to look
74:17 - basically identical to this but now when
74:19 - we call the rotate method so the one all
74:21 - the way at the end here
74:23 - we might get something that looks like
74:26 - this
74:27 - and as a consequence if we didn't
74:29 - account for this new surface
74:31 - we might get a collision here for
74:33 - example or all the way up here which
74:35 - might be frustrating
74:37 - so after we are doing a rotation we want
74:40 - to set a new mask and this is done by
74:43 - just creating a new mask here or while
74:46 - updating the attribute
74:48 - and well that is actually all we needed
74:52 - so now each of our main sprite our
74:55 - ground our plane and our obstacle each
74:57 - have a mask
74:58 - the only sprite that doesn't need a mask
75:00 - is the background because this one
75:01 - doesn't have any collisions
75:03 - but now if we run all of this again
75:06 - we still can't see any kind of
75:07 - difference so the collision still breaks
75:11 - the reason for that is that sprite
75:13 - collide is going to need one more
75:15 - argument
75:16 - and that is going to come right at the
75:18 - end and what we have to add in here is
75:22 - dot pygame.sprite.com
75:24 - underscore mask
75:26 - and now this should be working so now
75:29 - okay terrible example
75:31 - now let me move down here now you can
75:33 - already see it there so now i was
75:36 - definitely in the bounding rectangle box
75:38 - of
75:39 - these obstacles but the game didn't
75:41 - crash
75:42 - only when i actually flew into an
75:44 - obstacle the game did crash so this
75:46 - seems to be working just fine
75:48 - now i guess while we are doing the
75:50 - collisions there's one bug in our game
75:52 - it's not really a bug but if i just go
75:55 - all the way up
75:57 - and keep on clicking
75:59 - the game basically well we never collide
76:02 - with anything because we're on top of
76:03 - the entire game
76:05 - so this isn't exactly helpful
76:08 - and to account for that all i really
76:10 - have to do
76:11 - is extend this if statement
76:14 - and add or
76:19 - wrecked self.plane.rect. top
76:21 - is smaller or equal to zero
76:23 - so we want to trigger a collision
76:25 - if the plane collides with an obstacle
76:28 - or if the plane goes too high
76:30 - and now let's try this again
76:32 - if i go all the way to the top the game
76:34 - crashes
76:35 - that way the player can not circumvent
76:38 - all of the obstacles
76:40 - now with that we can actually work on
76:41 - the final part that we want to display a
76:43 - score and if the player has been
76:46 - crashing into something we want to get
76:48 - some kind of game over or restart menu
76:50 - that also shows the score oh and i
76:52 - forget after this section we're also
76:54 - going to add some sound but that is
76:55 - really easy to implement so let's work
76:58 - on the score and the game over screen
77:00 - here we are back in our main.pi file and
77:03 - i want to start working on displaying a
77:05 - score
77:06 - and for that we need a couple of things
77:09 - to get started most importantly we need
77:11 - some kind of font and this i'm going to
77:14 - do in the init method so in here i'm
77:16 - going to add another section
77:19 - let's call it text i think makes the
77:21 - most sense
77:23 - and in here i want to create a self.font
77:26 - and this we get with highgame.phone
77:32 - and in here we need two bits of
77:34 - information we need a font itself and a
77:37 - font size
77:39 - now the font size is just an integer in
77:42 - my case i went with 30. and for the font
77:45 - itself we will need a file and in my
77:48 - case this one looks like this
77:51 - and if you open up the project files you
77:53 - have to go to graphics let me move it
77:55 - down a bit and there we have font and
77:58 - there we have bd cartoon shout and
78:00 - that's the true type font file or ttf
78:03 - and that is what we're importing in here
78:06 - now besides that
78:08 - we also need a score
78:11 - attribute to save the font which in my
78:13 - case is just score that starts at zero
78:17 - and that is basically all we need for
78:19 - now to get started with the score
78:21 - now to display it i want to keep all of
78:24 - this in a separate method so let's call
78:26 - this one display score
78:29 - and then here we need self and nothing
78:31 - else
78:32 - and now we have to figure out how to get
78:34 - a score
78:35 - and there are different ways of getting
78:36 - the score so one method could be that we
78:39 - get a plus one in our score whenever the
78:41 - player crosses an obstacle
78:43 - another way would be to just measure the
78:45 - time since the game started and that's
78:48 - the one i went with but honestly all of
78:50 - these methods are fairly easy to
78:52 - implement so choose whichever one you
78:54 - prefer but in my case i am just going to
78:57 - go with time
78:58 - and well all we really have to do is get
79:01 - our self.score
79:03 - and then here to get the time since our
79:05 - game has started is pi games spelled
79:07 - correctly dot time dot get
79:10 - underscore ticks
79:13 - and this is going to give us
79:14 - milliseconds but for now let's just keep
79:17 - it so you see what we actually get
79:19 - now once we have that information we
79:21 - want to create a score surface
79:24 - and we want to get a score
79:27 - rectangle
79:29 - and then basically all i want to do is
79:31 - self dot display surface
79:34 - dot blit and then the score
79:36 - surface
79:37 - and the score rectangle
79:40 - so we have to figure out the score
79:42 - surface
79:43 - and the score rectangle
79:45 - and i think this could be a pretty good
79:46 - exercise for you so the score we have
79:49 - right now is a text turn this text into
79:51 - a surface and from that surface get a
79:53 - rectangle and then blit both of those on
79:56 - the display surface and see how far you
79:58 - get
80:02 - to turn a string into a surface
80:04 - we first of all need our self.font so
80:07 - the font we have created up here
80:10 - and then we need
80:11 - render
80:12 - and in render we have three bits of
80:14 - information we need a string we need
80:17 - anti-aliasing
80:18 - and we need a color
80:21 - and let's go through them i guess from
80:23 - the start
80:24 - our string is just our self.score
80:28 - the problem is i actually misspoke this
80:30 - isn't a string it's an integer right now
80:32 - that gives us the milliseconds since the
80:33 - game has started so we have to turn this
80:36 - into a string
80:37 - which isn't very difficult
80:40 - i am just using the string method you
80:42 - could also use an f string it really
80:44 - doesn't matter next up we have
80:47 - anti-aliasing and this basically means
80:50 - if we want to apply a filter to the text
80:52 - to make it a bit more smooth
80:54 - which in my case i do want to do
80:57 - and the only time you don't want to use
80:59 - this is if you have picks a lot because
81:00 - then it makes it kind of weird but if
81:02 - you have anything else you do want this
81:04 - to be true
81:05 - and finally for the color i kept it
81:07 - simple and went with black
81:09 - and with that we have a surface
81:12 - now next up to get the rectangle
81:14 - we want the score surface dot get
81:16 - underscore rect
81:18 - and in here we have to figure out a
81:20 - position
81:21 - and let me illustrate what i want to
81:23 - achieve
81:25 - let's say this here again is our entire
81:28 - display
81:30 - and i want the score to be up here while
81:32 - the game is active
81:34 - which specifically means that i want the
81:36 - middle
81:37 - of the window in the middle of
81:40 - the entire window so this is the width
81:43 - of the window divided by two
81:45 - and then i also want some kind of offset
81:47 - from the top
81:49 - and this is some reasonably large number
81:50 - it doesn't really matter specifically
81:52 - what it is the middle part here is much
81:55 - more important
81:56 - to get to that point
81:58 - i have placed the mid top
82:01 - and for the mid top we need x and y
82:04 - and x is the easier part for this one i
82:07 - just got the window width
82:09 - and divide it that one by two
82:11 - and for the height i just went to window
82:13 - height divided by ten
82:16 - so that the top of the text is ten
82:18 - percent from the top of the window
82:19 - that's kind of all that means here
82:22 - and that is all we needed for the basic
82:25 - thing so now we just have to call this
82:27 - method
82:29 - let's do it after we're drawing all of
82:31 - the other sprites
82:32 - so
82:33 - self.display
82:35 - score
82:37 - and let me add a bit of white space
82:39 - and it's actually really important that
82:41 - this display score comes after all of
82:43 - the sprites drawing because this one
82:46 - draws on a display surface if we are
82:49 - calling this before this method here
82:52 - we wouldn't see it because the draw
82:54 - method draws the background on top of it
82:55 - so the order here does matter
82:57 - but right let's run this
83:00 - and we can see we have a score except
83:03 - one that gets way too high way too fast
83:06 - so this is not ideal
83:10 - and the reason here is that this number
83:13 - is giving us milliseconds instead of
83:14 - seconds
83:16 - and well
83:17 - to change that all we have to do is to
83:20 - floor divide this by 1000
83:22 - and now let's try this again
83:25 - and this is feeling much better except i
83:27 - am terrible at this game
83:30 - so this is feeling well it is working
83:35 - cool so with that we have a score
83:39 - now next up i want to work on the game
83:42 - closing down as soon as we have any kind
83:44 - of collision
83:46 - and instead i would rather have some
83:48 - kind of game over screen and then if the
83:50 - player clicks again the game restarts
83:53 - and that is also fairly easy to
83:55 - implement
83:56 - now basically
83:59 - in my game i want to have a attribute
84:02 - that i called self.active
84:05 - and this is essentially going to attract
84:06 - the status of the game so if we have
84:09 - crashed into something it's going to be
84:11 - false and once we're restarting
84:12 - self.active is going to be true again
84:17 - so essentially once we have a collision
84:19 - we want to make some changes to this
84:22 - and specifically in here
84:24 - i want to have self dot
84:26 - active
84:28 - is going to be false
84:31 - so now instead of closing down the game
84:33 - we're getting to a different state
84:35 - and now for this state to work properly
84:37 - i need a few more graphics and this is
84:39 - going to work in the init method so in
84:41 - here i'm going to add one final section
84:43 - that i call menu
84:45 - and in here we get self dot menu
84:48 - underscore surface
84:50 - and i want self dot menu underscore rect
84:55 - and really all i'm going to do in here
84:56 - is pygame.image.load
84:59 - and for this one we just need another
85:01 - string to graphics
85:03 - dot ui
85:06 - menu dot
85:08 - eng
85:11 - and don't forget we need convert
85:13 - underscore alpha as always
85:16 - and just to demonstrate what we are
85:17 - getting here is again the game folder we
85:20 - go to graphics we go to ui and there we
85:23 - have this menu thing
85:25 - so that's what we're importing
85:28 - all right and next up for the menu
85:30 - rectangle we are just going to get
85:33 - self.menu surface dot get underscore
85:36 - rect
85:38 - and this i want to place square in the
85:40 - center of the window so center
85:44 - is going to be
85:45 - my window width over 2
85:49 - and my window height
85:51 - over 2.
85:53 - and the basic idea is if self.active is
85:56 - equal to false i want to display this
85:58 - menu here
85:59 - and i guess what i haven't done for this
86:01 - project is
86:02 - this thing doesn't have any scaling
86:04 - right now so if the game gets really
86:06 - large this might look very very small
86:09 - but that's something you can work on
86:11 - yourself
86:12 - all you would really need to do is get
86:15 - this scale factor and apply it to this
86:17 - menu surface as well it should be fairly
86:19 - easy to implement
86:22 - okay now the basic idea of what i want
86:24 - to do
86:25 - is further down here
86:28 - that if self dot
86:30 - active
86:32 - then i want to check for self dot
86:36 - collisions
86:39 - and this is what i have done so far
86:42 - up
86:43 - here
86:44 - but this i only want to do if the game
86:45 - is active so i want to remove this one
86:49 - which really just means that i am going
86:50 - to delete this line
86:52 - and let me put it on another line so it
86:55 - looks a bit cleaner
86:56 - now if that is not the case
86:59 - i want to
87:00 - self dot
87:02 - display surface dot split
87:06 - and self dot menu surface and self dot
87:10 - menu
87:12 - rectangle
87:13 - so the basic idea is if the game is
87:15 - active we're checking for collisions if
87:17 - not
87:18 - we are blitting the menu
87:20 - and if we run out of this
87:23 - the game is still working but now if i
87:24 - crash
87:25 - we can see our logo
87:28 - and this is working quite well we can't
87:30 - do anything with it right now but it
87:31 - does work at the very least also the
87:33 - score keeps on running so that's stuff
87:35 - we have to work on
87:36 - but i guess step by step let's start
87:39 - working on the score i guess that's the
87:40 - most important one and this is going to
87:42 - happen in the display score again here
87:45 - and basically what i want to do
87:47 - this score should only update if the
87:50 - game is active so all of this should be
87:53 - in if self dot
87:56 - active
87:57 - and only if that is the case we want to
88:00 - get a new score
88:02 - and i guess while we are here we can
88:04 - also implement something else that while
88:06 - the game is active i want the score to
88:08 - be on top of the window but if the game
88:10 - is not active i want the score to be
88:13 - below the menu and that we can also work
88:16 - in this method here
88:17 - and basically all we have to work with
88:20 - is right now with our window height
88:22 - divided by 10
88:24 - and this is the top middle part of the
88:26 - window i want to cut this thing out and
88:28 - change it to a y
88:30 - and now if the game is active i'm going
88:32 - to set this y
88:34 - to the same number so far this wouldn't
88:37 - really be a difference
88:39 - but what i can do now i can set an else
88:41 - statement
88:43 - and in here y
88:46 - should be a different position and what
88:48 - i went with is window height
88:51 - divided by two and this is right now the
88:54 - exact middle of the window and i want an
88:57 - offset to be a bit below that
88:59 - and to get this offset i want my menu
89:03 - rectangle
89:04 - and the height
89:07 - of that
89:09 - and well basically what we are doing
89:12 - is this here again is our entire window
89:16 - this would be the center of the window
89:19 - and we want to go down by
89:22 - the height of the menu so the height of
89:24 - the menu rectangle
89:26 - that's basically all we're going to do
89:28 - here
89:29 - and i guess let's try if this is working
89:32 - so if we run the code now
89:34 - the game is still working and if i crash
89:36 - into something we can see a number below
89:38 - the menu now and it's well not counting
89:42 - anymore although i guess the number is a
89:44 - bit too far down so i want to move it up
89:46 - a tiny bit
89:48 - and to achieve that i'm going to divide
89:50 - this number by
89:52 - let's say 1.5
89:54 - and let's put it
89:56 - in brackets
89:57 - that should look a bit better so now
89:59 - let's try this again
90:01 - game is still working just fine if i now
90:03 - crash into something
90:05 - this is looking much better cool so now
90:07 - we have the score almost working
90:09 - properly there's going to be one more
90:11 - thing we do have to work on but for now
90:13 - i'm happy with this
90:15 - now i guess next up we can work on
90:17 - restarting the game because right now we
90:19 - can't really do anything
90:23 - and for that
90:24 - we have to look
90:25 - at the event loop so all of this stuff
90:29 - here
90:30 - and basically what i want to achieve is
90:33 - when the player presses the mouse button
90:35 - i want to restart the game
90:37 - so inside of this if statement i need
90:40 - another if statement that if self dot
90:44 - active
90:45 - so if the game is active and i press the
90:47 - mouse button
90:48 - i want the plane to jump
90:50 - but if that is not the case so else
90:56 - i want set self active
90:59 - to true
91:01 - let's actually see what we get so if i
91:03 - run the game it's still working but if i
91:05 - crash now
91:06 - we well get nothing
91:09 - and the game continues after i press and
91:11 - i think if i press fast enough there you
91:13 - can see if i think press fast enough
91:17 - you can kind of tell the idea
91:19 - okay now what is the problem basically
91:22 - let me draw it
91:24 - this here is our game window and the
91:26 - problem we have right now is if we stop
91:29 - the game the plane continues to exist
91:32 - and keeps on going downwards
91:34 - and once we are restarting the game the
91:37 - plane is still down here somewhere and
91:40 - since all of our obstacles are here and
91:43 - here and here
91:45 - the plane doesn't reach them
91:48 - whatsoever
91:49 - and as a consequence the game keeps on
91:51 - running but we can't see the plane
91:54 - so that is something we have to work on
91:57 - and in my case here's how i approach
92:00 - this
92:00 - in my collision method
92:02 - after we have a collision i am
92:04 - destroying the plane so self.plane.kill
92:09 - and then when we are clicking to create
92:13 - a new game so down here
92:15 - i am creating a whole new instance of
92:17 - the plane so self dot plane
92:21 - is equal to plane
92:23 - and let me actually copy this from
92:25 - earlier we just need this line here
92:31 - and with that let's try this again so
92:34 - the game is still working
92:35 - now crash into something and now my
92:38 - plane is well at least in the right
92:39 - position back
92:41 - the problem we have now is that we keep
92:43 - on having all of the obstacles in the
92:44 - game which is kind of unfair if you are
92:47 - just spawning a new game also the score
92:50 - doesn't
92:51 - start at zero it starts at the previous
92:53 - score so the score keeps on rising so
92:55 - there are two things we have to work on
92:58 - i guess we can start working on the
92:59 - obstacles that's the easier well both
93:02 - are really easy but let's work on the
93:03 - obstacles first
93:04 - so essentially what i want to do once we
93:08 - have a collision i want to destroy all
93:11 - of the obstacles
93:12 - and this happens again in the obstacle
93:14 - class and really all i want to do here
93:17 - is for sprite in self dot collision
93:20 - sprites dot sprites
93:24 - i want to sprite dot kill
93:28 - and also in my timer so in this timer
93:31 - here i only want to spawn new obstacles
93:35 - if the timer is running out and
93:37 - self.active
93:39 - is true
93:40 - so that way we are not spawning any new
93:43 - obstacles and we are destroying all the
93:46 - existing obstacles
93:48 - although right now there's a bit of a
93:50 - problem if we are doing that let me run
93:51 - the code to demonstrate so the game is
93:53 - still working but now if i crash into
93:54 - something we are also losing the ground
93:57 - and if i now click again
93:59 - it well doesn't come back which isn't
94:01 - ideal
94:03 - and the problem here is that in my
94:05 - sprites let me minimize all of those
94:09 - my ground and my obstacle are all in the
94:12 - same sprite group which is causing the
94:14 - problem here
94:16 - and i think the easiest way to fix this
94:19 - is
94:21 - i
94:21 - want to give each of these sprites a
94:24 - sprite type
94:25 - and then in here if sprite dot sprite
94:29 - underscore type
94:30 - is equal to
94:32 - obstacle
94:33 - that is horrible spelling stick kill
94:37 - only then do i want to kill the sprite
94:40 - so now in my sprites
94:42 - i have to give them different sprite
94:44 - types and this we can do straight at the
94:46 - top
94:47 - so in here
94:48 - self dot sprite underscore type
94:52 - is going to be let's call this one
94:54 - ground
94:56 - and then for the obstacle
94:58 - this could be self.sprite
95:01 - underscore type
95:03 - is going to be obstacle
95:08 - and now we should be good to go let's
95:12 - try this again now and now if i crash
95:15 - into something the obstacles disappear
95:17 - but the ground remains and now if i
95:18 - restart the game
95:20 - this is looking much better cool so this
95:23 - seems to be working quite well if i
95:25 - crash again
95:26 - this same thing happens again cool this
95:28 - is working
95:29 - now the final problem we have is the
95:31 - score because this one doesn't go back
95:33 - to zero instead it keeps on updating
95:37 - and the problem here happens
95:40 - in this line
95:42 - pygame.time.getticks
95:44 - gets the time since the program or our
95:47 - game has started it doesn't really care
95:49 - what we are doing in the game it's
95:51 - always starting from zero whenever we
95:53 - start our program
95:55 - so we have to account for that
95:58 - and to account for that here's what i
96:00 - have done
96:01 - is this score is always going to be
96:03 - offset by
96:06 - self. i call this the start
96:09 - offset that is i'm getting worse at
96:11 - spelling
96:12 - and this start offset is just another
96:15 - time
96:16 - when the game became active again
96:18 - so if we're starting the game at 2
96:20 - seconds start offset is going to be 2000
96:23 - so 2 seconds in milliseconds
96:25 - and this start offset we get
96:28 - down here
96:30 - so all i want to do is self dot start
96:32 - offset is going to be
96:34 - pygame.time.getunderscore
96:37 - ticks
96:39 - and obviously we also need the same
96:42 - number
96:43 - up here
96:44 - up here
96:46 - we need self dot start
96:48 - offset and by default it's going to be
96:50 - zero
96:52 - and now let's try all of this
96:55 - and now the time keeps on working i get
96:58 - 2 for the score and now if we start
97:00 - again we start again at 0. so this is
97:03 - working pretty well
97:06 - cool i'm quite happy with this
97:09 - and i can crash again
97:11 - and this keeps on working really well
97:13 - cool
97:14 - so with that we have our score and our
97:17 - game over screen
97:18 - so the last thing we are going to need
97:21 - are two sound effects and those are
97:23 - incredibly simple let's go straight into
97:26 - our code and let's work on them
97:29 - here we are back in main.pi and we want
97:32 - to add some sound and let me just
97:34 - demonstrate what we have
97:35 - so in our third folder we have sounds
97:38 - and in here we have jump and we have
97:40 - music
97:41 - and that's kind of all we need
97:44 - let's start with the jump sound although
97:48 - it doesn't really matter which one you
97:49 - start with
97:50 - and i can minimize everything else in
97:52 - here
97:53 - and in the init method of the plane
97:56 - i want to add some sound
97:58 - so all the way at the end i want to add
98:01 - some sound here and all we really need
98:04 - is self dot let's call it jump
98:07 - sound
98:08 - and to import music we need pygame dot
98:11 - mixer dot sound
98:14 - and now we need a path to the sound file
98:16 - which in my case is going one fold up
98:19 - then we have sounds and then we have
98:21 - jump.wav
98:23 - and now before we are going to use that
98:25 - sound by itself it's kind of loud
98:28 - so i want to set self.jumpsound.set
98:32 - underscore volume
98:34 - to 0.3
98:37 - in this set volume 1 would be the
98:39 - maximum and 0 would be well 0. and in
98:43 - this case 0.3 means 30 percent of the
98:45 - original volume
98:47 - and now i just have to play this sound
98:49 - whenever we jump
98:51 - and we know we jump when we are running
98:54 - the jump method that kind of makes sense
98:57 - so in here i just want to run
98:59 - self.jumpsound.play
99:02 - and that should be all we need it
99:04 - although i just realized this should be
99:07 - jump.wav not slash
99:10 - and now let's try this and let's see
99:12 - what we get
99:13 - [Music]
99:18 - and well that is working except it feels
99:21 - absolutely horrible
99:23 - but that's only because we don't have
99:25 - any kind of background music right now
99:26 - but that we can fix quite easily and
99:29 - that's gonna happen in the main file
99:31 - and this could be a pretty good exercise
99:33 - for you as well so add the background
99:35 - music yourself and see how far you get
99:40 - all we need is first of all i want to
99:43 - add another section in here i think this
99:46 - one is going to be the final one now and
99:48 - in here i want self. let's just call it
99:50 - music
99:52 - and this is going to be again
99:53 - pygame.mixer.sound
99:56 - and the path here is again a string we
99:58 - go up
100:00 - sounds
100:01 - and then here we have music.wav
100:04 - and i'm happy with the volume here and
100:06 - to play this one i just want
100:08 - straightaway self.music.play
100:12 - and the really important thing for this
100:14 - one is we need to add one argument in
100:16 - here and that is loops that should be
100:19 - negative one
100:20 - and this one tells pygame to play this
100:23 - music perpetually so we never stop and
100:25 - we played in a loop so if we run the
100:27 - game now
100:33 - [Music]
100:51 - okay that works really well so i hope
100:54 - this tutorial was useful and i will see
100:56 - you around

Cleaned transcript:

hello there in this tutorial we are going to be creating this flappy bird clone in pie game it's ultimately a fairly simple project there really isn't too much to explain before we start i guess the one thing i do want to talk about is the folder setup here is our game folder and we have three subfolders we have code graphics and sounds and sounds is the easiest one it's just two sounds for jumping into background music then for graphics we have the environment font obstacles plane and ui all of these i think are fairly straightforward and then finally we have the code section and then here right now we have two files we have main and we have settings and we are going to add quite a bit more in here but let's go into the code and let's have a look at this and that's actually bringing us to the very first part of this project the basic setup so i'm just going to go over the parts we already have and once we have that part covered we can actually start adding stuff to it so let's have a look so here we are in the files we have main.pi and settings.pi and settings.pi is the easier one in here we just have a couple of constants so we have the width and height of the window and our frame rate and besides that well nothing else is happening in here so we can more or less ignore this file the main.pi file is the much more interesting one and if i run this one we can see a black window that doesn't really do anything right now but let's talk about the code really quick before we do anything else at the top i am importing a couple of basic things for pygame so we have pie game itself sys and time and then besides that i am importing settings and all the constants so that's the stuff we have created up here and we are using all of this to create a game class i will explain this one in just a second but what we are essentially doing is we are checking if our current file is the main file and if that is the case we are creating one instance of the game class and then we are calling game.run so this really isn't anything complicated so let's have a look at the game class itself it's not too difficult i think we first of all have a setup part in the init method and then here we are calling init on python we're creating a display surface then we are giving it a title and we are creating a clock so all of this is really basic pie game if you have no idea what any of this does check out my introduction to pygame it explains all of this in quite some detail now besides that we also have a run method all of this here and all we really have in here is a while loop and in this while loop we are updating pi game and we are calling the frame rate besides that we also have an event loop and we are using delta time if you have no idea what delta time is check out this video i have explained all of it there it's basically there to account for different frame rates and there's one more thing i would like to do to set up this project i want to create two pi game sprite groups one is going to be called all sprites and this one is going to contain well all the sprites and it's going to draw and update them and besides that i want another group that is called collision sprites and this one is later going to contain all of the things our player can collide with so the floor and the obstacles and as a challenge try to create these two groups yourself all i need to do let me add another section let's call it sprite groups and here i want to have self.all sprites and this is just going to be pygame.sprite.group and then i can copy the entire thing and let's call the second one collision sprites we are not going to do anything special with either of them they are just going to contain some sprites and all right with that we have the first part covered so now we have a basic setup next up i want to work on the background and this one i want to be moving continuously in the background and that isn't too much of a difficulty although there are a couple of things we have to take care of but i guess let's jump straight into it and let's have a look at it here i am back in the project and i want to create a new file that i'm going to save as sprites.pi because this one is going to contain all of our sprites and first of all i have to import pygame itself and besides that i also want from settings import star so all of this stuff here once we have that i want to create a class that i called bg for background and this one is going to be pygame.sprite.sprite a basic sprite and for this one when we called the dander init method i want to have self and for now i want to have groups although we are going to need one later on but don't worry about that for now now the first thing we always have to do is call this super that's not how you spell that the super and the dander init method and pass into groups so whatever group we pass in here for example our all spreads group then this sprite is going to be allocated to these groups which is exactly what we want now besides that we need to set self.image and we need self.rect and we do have an image this one we can just import with pygame.image.org and for the folder we have to go one fold up and we have to go to graphics there we have environment and inside of environment we have background.png and as always don't forget to convert this thing for this one though we don't need convert alpha because there are no alpha values and once we have that for the rectangle i just want to get self.image dot get underscore rect and the top left should be at position 0 and 0. so we essentially create an image that we are placing in the top left of the window so far this really isn't anything difficult and i realized i have a typo in there so back in my main file i want from sprites import bg and then after i've created sprite groups let's add another section and let's call this one i guess sprite setup doesn't sound too bad and what i want to do in here is to create my background and i have to pass in the sprite groups and in my case this is just going to be self.all sprites so this argument is for this parameter here and now around all of this we can see nothing for the simple reason that we are not drawing this spread group that's the one i forgot just now so in my game logic i want self dot all sprites dot draw on self dot display surface and now let's try this but now we can see a problem that this thing is way too small and it needs to be much bigger nearly twice as big actually so this image here should scale all the way down to the bottom of the window and for that we have to scale method but there's a bit of a problem so essentially what i want to do when i import this image i don't want to set it straight as the image of the window so let me first import it as another variable and let's call this one bg underscore image and for now this is going to be the same image and what i could be doing now is when i create the image i could call pygame.transform.scale what scale essentially does is it takes a surface and a scale and this scale is going to determine how big the surface is going to be for example if i pass in our window width and our window height let's actually copy those from settings so window width and window height and for the surface i just want my bg underscore image if i run this now we get an image that covers the entire background the problem now is that all of this is kind of weirdly stretched you can see it especially at the clouds so this bit here looks kind of weird and that's what i want to avoid and i guess the best way to think about it is to open all of this in photoshop and explain what we have to do instead alrighty here you can see the entire thing in photoshop the black frame is our pie game window and the blue thing is our background and you can already see the initial problem that our background doesn't cover the entire frame of pie game and what we have done just now of the scale method is to change the scale of this thing to something like this which does work but stretches the background image quite a bit so i don't really like that one so let's undo it and essentially what i want to do is i want to keep the aspect ratio of this thing constant meaning that the width of this thing and the height of this thing should keep the same ratio towards each other so i guess right now the image is always about 1.5 times as wide as it is high and when i scale it i want to keep the same ratio which in practice means i want to do something like this and once we're doing that the entire thing is going to look significantly better but to achieve it we are going to need a bit of math but let's do this once trading code i think that's going to make more sense here i'm back in the project and the first thing i want to do is to get rid of the scaling method so let me copy this thing back to what it used to be and copy this one out and now i've run this again we can see the thing we had earlier so let's talk about what we have to do essentially i want to get this image here so let me just make a square and i want to multiply this by a certain size so this is what we need to find out and the result of that multiplication should be an image large enough to cover this entire height of the window which in my case right now is 800 pixels on the yaxis so let's say for simplicity in here this one should become 800. for y and this means we have to find this y here and how can we do that let me actually get rid of all of this text here to figure out what we have and how we can use it so we still know our entire window is 800 pixels high and we also know how high this surface here is that's something pi game can give us let's say for simplicity here this is 400 pixels high so what we essentially want to know is by how much do we have to multiply 400 to get to 800. now obviously this by itself is a very simple calculation but we want to make this a bit more flexible so at the height of this surface could be basically anything and the formula would still work but really all we have to do to get this y here is to multiply the height of the entire window divided by the height of the background this number simply came from moving this 400 down here and then using it as a divider for 800. so very simple math all right let's actually implement this this number i do want to reuse later on so i am going to get this number in my init method you're going to see later on why this is going to become important and essentially i want to create another section and let's call this one the scale vector and the first we have to do in here is to actually get my bg height and for this one i want to get my pie game.image.load and the image i already have it's this path here now for this one we don't really care about the image we just want to know how tall it is or how high it is so all i want to do is get underscore height and let's actually print it to see if this is working so bg height and if i run this we get 480. so this entire thing is 480 pixels high and we want to know by what number do we have to multiply this to get to 800 so x is just going to be 800 divided by 480 and that is a number we can get quite easily and i want to store this number in self.scale underscore vector and all i really want to do here is to get my window height and divide this by bg height and let's print this one just to see what we are getting so self.scale vector is i need to use self as soon as now it's 1.66 and this is the number we can now use to create this bg so i want to pass in self.scale vector in here now in my sprite class i can create another parameter that i'm going to call the scale vector as well now the first thing i want to do is to uncomment bg dot image and first of all i want to get my full height and my full width and only once i have those i want to use pygame.transform.scale and in here i again want to use my bg image but now for the scaling part i want to get my full width and my full height and now let's do an exercise try to figure out for yourself how to get the full width and the full height of the bg image that we are going to need and here again the important part is you should scale both of these sides by the same number so the same scale factor all i have to do is to get my bg image and then get for the height get the height and this number i then want to multiply with the scale vector and once i have that i can do the same thing for the width so bg image except now i need to get the width of this thing and multiply this one by the scale factor as well and now we should be good to go let's try this now and there we go this is looking significantly better so now our background does cover the entire image but it's not stretched in a weird way so this is working quite nicely and let me get rid of this print statement here it doesn't seem necessary so now that we have that let's animate it and this also happens in the sprite class all i really want to do in here is to give this one an update method it needs self and it also needs delta time because whenever we move anything with the other time it has to be multiplied with delta time and on top of that i also have to create self dot position and this is something i've explained in my delta time video that when we're using delta time to move we can't really store the position in direct attribute anymore because this one only stores integers but when we use delta time we get lots of floating point numbers and if we start of them as integers we would get inconsistent movement so i want to store all of this in a position that is just going to be a vector so pygm.math.vector2 and self.rect.top left so by default we're getting a vector in position 0 and 0. and now all i want to do is self.pause dot x minus equal some kind of speed let's say in my case 300 seems like a good number and this i want to multiply with delta time and once we have done that i want to get myself.rect.x is going to be round self.x and if you're used to normal pi game this does seem kind of annoying but it's the only way to get consistent movement with delta time although grounded it is a bit tedious but alright so now we should be having some basic movement once we're coding the update method so before i am drawing all of my sprites i also want self.osprites.update and now for run this we are getting an error that i forgot delta time now let's try this again and there we go we have some decent looking movement although there we have a problem that at the end we get something weird and the problem here is that i didn't fill the screen with any kind of color so self dot display surface dot fill and let's just fill it with a black color and now let's try this again now you can see what's going on so the image is moving just fine but now the image is moving too far to the left the problem essentially being that this thing keeps on moving left perpetually but we never stop it so at some point it is going to leave the screen and this is kind of easy to change all i really want to do is if self.rect.write is smaller or equal to zero actually let's look at this in photoshop so here you can see the entire thing again and what we're doing right now is once this background is here i want to set it back to this position here so in the if statement we are essentially checking if we are on this position then i want to set the position of this background back to 0 and 0. so once right is small or equal to 0 then i want to set self.pause.x back to 0. and now this self.react.x has to be all the way at the end of this so now if we run this again we can see this is kind of working with one exception there we go that we always can see the black background for a while which isn't ideal as a matter of fact it's unacceptable so let's talk about how we can change it and this i guess is best again explained in photoshop so here's what we have just done we have the background image and we're moving it further to the left but once it is all the way to your left you basically can see the background which well looks terrible now the way to overcome this is to simply copy the background and paste it twice like this so we have the same background exactly on the right of the original background and we're always moving them together so now if i move these two things together and i just keep on moving until i hit the right side of the original one then you can see the second background but now if i again move this thing to position 0 and 0 then you can see the original background and since both of these are identical this image is going to be the same so the player shouldn't be seeing a difference in practice all we really have to do is to duplicate our background image and make it twice as wide by copying the original image which is honestly a very simple thing to achieve here i'm back in my code and in my sprite i want to create a new self.image that is twice as wide as the original background image and then place this background image on that twice one on the left side and one on the right side and for that this self.image i'm going to rename to full sized image so this is the fully sized image that i want to create twice and now my self dot image is just going to be a pygame dot surface and in here i have to get a width and a height and the height is very easy to get i just want to get my full height which is essentially the number i get from here but for my weft i want to get my full width and multiply this by two which is this number here multiplied by two and this way this self.image is going to be twice as wide as this background image or well rather this background image at its full size and once i have that i want to get self dot image dot blit and i want to paste the full sized image at position 0 and 0 and then i want to do this again but now i want to paste this on the left side being the full width so essentially what we have done is we have created a surface that is twice as wide as the original background image and into this we have pasted background image once at position zero and zero so this point here is essentially this point here once we have that we have blitted the same surface on the right side of this original surface so this point here is this full width and with that we have a double background and now what i want to do i don't want to check anymore if the right side of this rectangle is to the left of the screen instead i want to check if the center x is to the left of the screen actually let me reopen the image we just had so this is our new surface and we now know that these two surfaces are identical so we don't want to check this right side instead we want to check the center x because we know that this is the end of the original surface so this is now what should be working let's try all of this and now let's just keep it running for a couple of seconds and i think this is looking really good and yeah i am quite happy with this so this is looking just fine and all right with that we have a background now next up we can work on the ground and the ground is going to work in basically the same way as the background it's actually a tiny bit easier the reason for that is that i already doubled it in photoshop before this tutorial i am going to explain in a second why that is let's first implement it and then i'm going to explain what's going to go different here we are back in main.pi and in my sprites i want to create another class this one i called ground so let's import it straight away and in my sprites class let's minimize class.bg and i want to create class ground and this one is going to be pygame.sprite.sprite and in here i want to create an init method that again is going to need self groups and the scale factor again oh yeah and this is also something i didn't really explain yet that we need to use the scale factor here again and let me explain right now why so when we scaled the background we also want to scale the ground by the same number so that those two stay relative to each other and the bg is what determines how big the scale factor is going to be which is why we get the scale factor essentially from this number but later on we're also going to scale the plane and all of the obstacles by the same number and this is important to keep the game consistent so i hope that makes sense all right now we have those numbers i again need super and under init and we pass in the groups in here now once we have that i want to get my ground let's call it ground surface and this one is going to be pygame dot image dot load and in here we need a string that goes up a folder to graphics then we have environment and there we have ground dot png and for this one we need to convert alpha that's actually really important and now this ground surface we want to use for self.image and from self.image we are going to get self.rect all we have to do for the image is to get this ground surface and scale it by the scale vector and we could do this in the same way we have done for the bg class so we have a full height a full width and a full sized image although that's three lines of code it's a bit much so instead what i usually do is pygame dot transform dot scale and here we do need our ground surface but for the scaling what you can also do is to get the ground surface and get underscore size and this i just want to multiply with the scale factor now this by itself wouldn't work because we can't multiply a tuple with a number but we can multiply a vector with a number so i'm going to turn this tuple here into a vector so pygame.math.vector2 and now this would be working just fine and this puts the entire logic into a single line which i think is much cleaner now for the rectangle all i really want to do is self.image.getrekt and for the position we now have to think about what we are doing because i can't just put top left at 0 and 0. actually i can but it wouldn't really work let's actually try and see what happens so in my main.pi i also want to get the ground so let's create the ground and the ground for now is just going to be in self dot all sprites and self dot scale vector and i've heard of this we can see why this isn't working the ground is way too high up so this is no good and fixing this shouldn't be too hard and i think this could actually be a fun challenge so try to change this argument here in such a way that our ground is always at the bottom of the window all right all i have to do is get the bottom left and that's the position i want to place and now for this one the x is going to be zero by default but for the bottom height i want to get my window i believe i called it so right now this is this number 800. and with that we're placing the bottom left at the bottom left of the window itself and now let's try this again and that is feeling much better cool and let me just clean this thing up a tiny bit so let's call this the image and then for the rect let's call it the position and i guess while we are at the position we can also animate this thing and for that we again are going to need self.pause and just like we have done before i want to get pygame.math.vector2 spelled correctly and in here self.direct dot top left and now i want to create an update map again that is going to be self and delta time and really all i want to do in here is self.post. and then minus equals some kind of number that ideally should be different from this 300 so that those two move at different speeds which look a bit better and i went with 360. and don't forget multiplying this by delta time is really important and now if self.rect.center x is smaller or equal to zero then self.post.x is going back to zero and then finally self.rect.x is going to be rounded self dot pos dot and that is essentially all we needed now what you could have done is use inheritance because those two numbers are nearly identical that would have cleaned this thing up a tiny bit but well do it in your own time if you really want to it's not that much that it would really justify that much extra work all right let's try this now and there we go now all of this thing is moving and it never stops moving that looks good now you might be asking yourself why did i double the size of this ground surface in photoshop and for this background image we're doing all of this in pygame so this line here and the answer is later on for the ground i want to use a mask to check the collision between the plane and the ground and if i created this self.image this kind of interfered with the mask which was kind of annoying and broke the entire game so this is kind of a workaround it's not ideal but it does work so i hope that makes sense but alright so with that we have our background and our ground so next up we can actually start working on the plane itself then the game is going to look much nicer so let's talk about the plane and this one needs to do a couple of different things it first of all has to animate so that we can see different frames after a certain amount of time besides that it also needs to fall down and be able to jump and the jump is going to be determined by player input and finally we also need some kind of rotation mechanic and later on we also need collision but that well we are not going to worry about right now so what we're going to do for now is create a basic plane that doesn't collide with anything just yet and let's do all of this straight in the game i think that is the easiest so here i'm back in my main file and i want to go to my sprites and create a new class that i have called plain and this one again is going to be a sprite dot sprite dot sprite spelled correctly ideally and in here for the init method i again want self my groups and the scale factor and the first we need in here is super and then the dunder init method and passing in the groups to allocate the sprite now what we are going to need we have to figure out some kind of image and later on some kind of rect for the positioning and for the image we want this to be animated so i have to import a couple of frames first and this i want to put in its separate method so self dot import underscore frames and in here every time i import a surface i want to scale it immediately so i want to pass my scale factor in there now besides that i also want to have self.frame index and this by default is going to be 0. so essentially what's going to happen is that this import frames is going to import a list of surfaces and this frame.index we are going to use to pick one of these surfaces and then for myself.image is just going to be self dot frames and we're going to pick self dot frame index and later on this frame.index we are going to increase to pick another frame and that way we are going to animate this thing and once we have the image we can create self.wrecked and this is just going to be self.image.getunderscorerect and this shouldn't be capitalized and in here we have to think about where we are going to place it and let me draw this out actually let's say this is going to be our entire window and i want to play a starting position to be here ish where the center of the thing is roughly in the middle or well exactly in the middle and the x position has some kind of offset to the left so we're not right at the left edge of the window but there should be quite some space to the right of the plane so we have to figure out this positioning here and basically what i have done i am placing the mid left so i am placing this point here and for this point let me actually get rid of all of this we need an x and a y position now the x is the easier one i just want to get my window height and divide it by two for the x position i essentially get my window and i divided this by 20. if this here again is our entire game window right now we have this entire distance is our width and i think right now this was 480 and if i divide this by 20 we get to 24 which is roughly this distance here or 1 20th of the entire width of the window and this distance then is going to be the left side of my plane which does give it a nice offset from the left side and that's also relative to the entire window so if the window gets very large this still works and now that we have that the last thing we have to do to get started is to actually create the import frames method and itself and the scale factor and essentially what i want to do in here first of all i want to create the attribute self.frames and that's just going to be an empty list now once we have that let's actually look at our folder and that one is this one and in my graphics i have a plane and in the app we have red 0 red 1 and red 2. so essentially what i want to do is create a for loop that runs three times and imports all of these three images and places them inside of this frames as the scaled surface and this i think could be a pretty fun exercise so try to import these three images of the plane scale them and put them in the surface in the self.frames list and see how far you get first of all i need for let's say i in range three so we're running the code three times then i want to get a surface and this is just going to be pygame.image.load and in here i first of all want to get the string itself and we go up one folder then graphics then plane and inside of that folder we have a red and this could either be zero one or two and this is the same information i get from my eye here so i'm going to turn this string into an f string and place in the i in here now after that don't forget this is a png file and also i want to convert alpha all of this so now we have a surface next up i want to create a scaled surface and this is going to happen in kind of the same way that i have done up here so i'm going to use transform.scale get the surface and then use a vector to scale it up and we want pygame dot transform dot again i want to place in my surface and then for the scale i want pygame.math.vector2 and mysurface.get underscore size and then this number i am going to multiply with the scale vector and then just realize this scale factor should be outside of that that is looking better all right and now that we have that self.frames.append and the scaled surface so now that we have all of that back in my main file all the way at the top i can also import the plane and let me spell it properly and then i can create lane and all the parameters we need are the groups and the scale factor so i can just copy them from the ground they didn't change very much so far and now if we are running all of this we can see a plane although you might see that this is way too large so the problem here is that the scaling behavior of some of these images are a bit well if they scale too much it looks a bit weird but that's not that difficult to fix all you really have to do is divide this scale factor by a certain number in my case i divided it by 1.6 and if i run it now this feels much better it would even be a little bit smaller let's say 1.7 yeah i guess that even feels better and i guess depending on your resolution play around with this number and see what looks best this is partly subjective and partly depends on what you feel is best for the game so just see what feels good and i'm sure you'll be fine but all right so now we have a plane and i guess now we can start working on the gravity and on the jumping mechanic and for that since we are going to move the plane i want to give it a self.position again that is going to be pygm.math.vector2 and self.rect.top left and now we are going to need two more things for the movement and let me put those in a separate part let's call it movement and first of all we need some kind of gravity and in my case gravity is 20. and then besides that i also want to get self.direct and this by default is going to be zero and the reason why we need direction is because our plane can go up and down whereas for the ground and for the background they always went in the same direction but for this one it's slightly different which is why we have a direction but now that we have that we have to create a couple of methods i guess the first one we can start with is define update we need self and delta time in here again and in here ultimately i want to create three different methods they're called self dot gravity then i have self dot animate and finally self.rotate and what is important is that all three of those are going to need delta time and for now i am only going to work on gravity so let me comment out the other ones so let's create the method gravity and we need self and delta time and the really important thing you always have to understand about gravity is that gravity is not linear and all this really means is let's say you're standing on a cliff and you're here and you're jumping down you don't fall like this you fall something like this where the longer you fall the faster you fall and this is also what we want to include in here if we didn't it would look very weird and the way this is usually implemented is we first got our self dot self.direction and we add towards it our self.gravity and remember this needs to be multiplied with delta time and now this direction we are going to also add towards our position dot y and this also has to be plus equal and in here we are going to add our self dot direction and this one is also going to be multiplied with delta time and now finally self.rect.y is going to be the rounded version of self.post.y and i guess let's try all of this so now things are not working let's have a look ah the problem i have made right now is that we have a method called gravity and we have an attribute called gravity which is not great so let me rename gravity to apply gravity that even makes a bit more sense and now our plane is going down ever so slightly i guess the amount is a bit low and i guess 20 is a below let's set this to something like 250 i think that's gonna be better and there we go that is more appropriate all right so with that we have a plane that is falling down now to counteract we have to give it the ability to jump so that's going to be the opposite of gravity and this is just going to be another method that i called jump that only needs self and all we really need in here is set our self dot direction to something like let's say negative 400 and let's see how far that gets us now the only thing we have to figure out is how to call this kind of method and this we could do in two different ways we could either run a method inside of here that would be perfectly fine although in my case since we're only checking for one simple thing i am going to look at my event loop and in here i am going to check for if event dot type is going to be equal to pygame dot mouse button down so whenever we click the mouse button i want to run this jump method here now for that to work we need to figure out where our plane is and right now we can't it's just one sprite inside of all sprites but we can just assign this after plane to an attribute and now we can target it right away so all we have to do now is self.plane dot jump and that is all we needed now let's run the code and we're getting an error because this needs to be a comparison operator and now if i run this this is kind of working although i think the gravity is still a bit too weak so let me change this 250 to something like 600. and now this feels much more responsive okay um you can play around with the numbers here so the gravity and the jump speed just play around with those and see how far you get and what feels best there isn't really an objective answer it really depends on how you want your game to feel but alright with that we have our player movement now next up we have an animation and a rotation and i guess let's work on the animation and this is just going to be another method with self and delta time and the basic idea how this is going to work is we are going to do the same thing we have done up here that we have a frame index and we are going to use that frame index to pick one frame from our frames so this is a list of surfaces and pretty much what we are going to do we are going to always increase on every single frame our frame index by a very small number let's say by 0.5 now if you do this only once you would get to 0.5 and you couldn't use that number for an index so what we are going to do is we are going to take the integer of this number which in practice means we're going to get rid of anything after the period so we are going to get to a zero so on the first frame if we add 0.5 we're going to stick to a zero but if we're doing this twice this 0.5 would become 1 and then our frame index would take the next surface that's the basic idea and how this is being implemented is we are first going to get our self.frame index and we're going to add some animation speed just to get some number let's go with five and remember this also needs to be multiplied with delta time and basically now what i want to do is self dot image is going to be self dot frames and in here we want to get the integer of self dot frame index and this would work but we would run into an error really fast and let me explain why right now we have a folder with three surfaces we have zero one and two or red zero one and two and by default we are starting with our index of zero so we keep on increasing this number at some point we get to one at some point we get to two now the problem we have is that we keep on going so our frame index would sometimes reach free then we will get to 4 then to 5 and so on and these numbers don't exist in our list so python would be very unhappy and give us an error message which means in practice what we have to do is after we have crossed a two we want to go back to zero so we are looping back to the first item in this list and that is also fairly easily done all we really have to do is if our self.frame index is greater or equal than the length of our self dot frames and if that is the case self dot frame index is going to be zero and that is all we needed so now back in the file now we have an animation it's a bit slow i guess we can make it a touch faster let's change this 5 to a 10 let's see how that looks and yeah i think this is alright possibly still a bit slow but again play around with this and see what you like the most so all right let me minimize all of these methods so they don't get in the way actually let's do this one here as well and now finally we have to work on the rotation and again another method with rotate and self and dt and the first thing i want to do is to create a new variable with rotated plane and this one is going to be pygame dot transform dot roto zoom now in pygame you have a couple of different methods that can rotate row to zoom i think is the one that tends to look the best because this one applies a certain kind of filter that makes things look a bit better and this method needs three different arguments we first need a surface then a rotation and then a scale now in our case the scale we don't care about so this is just going to be a 1 meaning that we don't want to scale anything now for the surface i just want to get myself dot image and finally for the rotation i just want to get my negative self dot direction so the idea here is that the faster we are falling down the more we want to rotate clockwise let me actually draw this i think it's going to make more sense let's say this one here is our plane and if we are going down i want this thing to rotate this way so clockwise and if we are going up then i want to rotate counterclockwise and because of that i want to link my rotation to my direction and what you might have noticed here as well is there is in all of this not a single delta time for the simple reason that we don't actually move anything here at least not directly we're just setting the rotation relative to the direction but we don't rotate anything by itself but with that we can remove delta time from the rotation because we don't need it and now all i have to do is self.image is going to be the rotated plane and well let's try this and well it's a bit high now the problem here is that this self.direction is quite a large number so we want to reduce it by let's say i want to multiply it with 0.06 and now if i run this this is feeling much better and that is looking quite good so now we have the rotation the animation and the movement and there's one important thing you really have to understand here that the order of these three methods really matters at the very least the animate method should come before the rotation and i guess let me rotate them around to see what happens we don't get any kind of rotation at all anymore the reason being here is when we rotate something we are setting the image and whenever we animate something we are creating a new image which effectively means we are overwriting anything inside of the rotate method and as a consequence rotate would become basically pointless so just keep rotate after animate and you should be good to go but alright with that we have our plane and let me run it again and this isn't looking bad at all cool so now we can start working on the obstacles and here again the obstacles really aren't that difficult so let's jump straight into the code and let's have a look at this we are back in the main file and i again want to go to my sprites and create a new class that i called obstacle it's also sprite so pygame.sprite.sprite and again we need it under indeed method that needs self groups and let me spell it properly and the scale factor and first of all in here we again need the dander init method and pass in the groups in there and now in here we have to get as always self.image and self.rect but now we have kind of a problem let me actually open the folder to illustrate what's going on so here's the folder with the obstacles and we have two different kinds of obstacles first of all we have zero and one and i want to pick a random one of those two but besides that i also want to randomly make those two either pointing upwards or pointing downwards and all of this i have to create in the init method so the first thing i want to do is figure out or randomly allocate the orientation and since we now need random numbers i want from random import choice and my orientation is just going to be choice between up and down now for the image itself we are still going to import the image but i guess first of all let's move this one down and i want to import the surface by itself so pygame dot image dot load and let me fix the typo and in here we are looking at the folder that goes one folder up then graphics then obstacles and in here we have either the image zero or the image one and i want to pick one of those at random so i have to turn this into an f string and then in here i want to get choice and in choice there should either be 0 or 1. and now again don't forget this has to be png and at the end of this we want to convert alpha all of this and now we have to do the same thing again with pygame.transform.scale i want to get my surface then pygame.math.vector2 this surface dot get underscore size and then multiply all of this with the scale vector and all right with that we have our scaled surface but now let me move the rectangle a bit further down i want to check if my orientation is equal to up then i want to leave my surface as it is so let's say for now i want to add a pattern here but if that is not the case so if the orientation is down i want to create self.image and the new image should be this image but flipped around and this we can do with pygame dot transform dot flip and in here we need three different arguments we need the surface we need a horizontal flip and we need a vertical flip and both of these are going to be boolean statements now in my case for the surface it's just going to be self.image for the horizontal flip i want to set this to false because i don't want to flip it in this direction but for vertical this should be true so with that there's a 50 chance that we are flipping the entire image so with that we have to figure out the rectangle and now we kind of have a problem and let me draw this really quick if this again is our entire window if our orientation is downward we want to spawn the mountain somewhere here but if the orientation is upward we want to spawn the mountain at the bottom of the window so we have different kinds of origin points depending on our orientation hence we can't just create a rectangle for every orientation so instead we need one rectangle for up and one rectangle for down so i want to have self.wrecked in here and i also want to have a self.direct in the else statement and in either case i want to get self.image.getrekt so that part stays the same but now we have to figure out which point to place and in my case i think what makes the most sense is if the orientation is up i want to place the mid bottom and if the orientation is down i want to place the mid top so back in my drawing essentially what i'm going to do is if the orientation is up so we're in the bottom one then i want to place this point here and if the orientation is down i want to place this point that way i can just use zero or this green height but now i have to figure out for both of these an x and a y position and this i think could be a fun exercise for you so try to figure out the x and the y position for both orientations and see how far you get the x position for both orientations is going to be the same so i'm going to create that before the if statement and basically what i want to do in here is i want to get my window width and then add a random amount of space so i want to get a random integer let's say between 40 and 100 and since we're using rent ind we have to import that one as well and the entire idea for this one is if this is our entire window we are getting this entire width which brings us to this point here and then i want to have some kind of offset here that is a bit random and that way our game looks a bit more organic but that's all it is now for the y position we have to do this for each orientation so the y if we are looking up is just going to be the window height and here again i also want to add some random amount let's say between 10 and 50. and this is going to be the same logic that you have just seen let me move this a bit up so what we want to do is to get to this point down here and wiggle around that point so we want to be in this area here and to get there we essentially need to get the entire height of the window and then add some random amount to it which is exactly what we have done down here and now finally for the downward facing orientation y can just be rand int and in here let's go with negative 50 and negative 10. so technically to make this in the same style as this one we could say zero plus rent end so zero is the top of the window and from that we are adding some negative numbers so we're going up by a tiny bit but well we don't need the zero i hope this makes sense and all right with that we have an obstacle what we can do now is give this thing an update method straight away this should be here this one itself and delta time is always oh and what i just forgot we have to set self.position again and this again is going to be pygame.math.vector2 and self.rect.top left and now basically all i really want to do self dot pos dot x minus equal let's say 400 times delta times and then self.rect.x going to be rounded self.x and that way this object is going to continuously move to the left now there's one thing i do want to implement straight away and that is if this entire sprite goes too far to left i want to destroy it and if we don't do that at some point we are spawning too many objects and the game will slow down so all we need for that is if self dot wrecked dot right is smaller or equal to let's say negative 100 and this means that the right side of the sprite is 100 pixels to the left of the left side of the window the player will definitely never see it again and if that is the case we can run self.kill now i guess technically this number could be zero but i do want to have a bit of a wiggle room here but all right with that we have the entire obscure class that's kind of all we needed but now what we have to figure out is how to spawn this obstacle because we want to spawn this one continuously and for that we are going to need a timer so let me add another section here that i call timer and first of all we need to create an obstacle timer and this one is going to be pygame.userevent don't forget this always wants a plus number by some integer so in my case just plus one and once we have that i want to start this timer so pygam the time dot set underscore timer then self the obstacle timer and now we need to figure out how often this timer should run in my case 1400 milliseconds so 1.4 seconds felt like a good number and now with that one in our event loop we can actually check for this sort of event so in here if event dot type is equal to self dot obstacle timer and if that is the case i want to create an obstacle that's shouldn't be all capitalized so i want to create one instance of this class and i guess for that to work we first of all have to import it so obstacle and now in here we again need two different arguments we need the groups and we need a scale factor so self dot all sprites and self dot scale factor and that should be all we needed for now so let's try this and there we can see one mountain another and there we can see some downward facing ones this is working just fine cool i am quite happy with that now if you want to make the game harder here you could make this scale factor actually a bit larger so for example if you multiply this scale factor with 1.2 i think the game becomes really hard so now the mountains are 20 larger which makes the whole game quite a bit difficult so let's leave it at let's say 1.1 but again here play around with the numbers but all right with that we have our mountains we have our plane we have all of the background so what we can start working on now is the actual interaction between the plane and the mountains and the one important thing we have to consider here is that we are going to need a mask but i guess this we are going to talk about when i actually implement it so let's go straight to the code and let's have a look at this here i am back in my main file now there's one thing i first have to do that right now i have all of my sprites so all of my obstacles all of my oh well my plane my ground and my background they're all in all sprites but for the collisions to work properly i need to have first of all one sprite my plane this one i already have but now i need to group with all of the obstacles my plane can collide with and this i don't have right now oh well i have it it's my collision sprites but this collision sprite is empty right now because for now i always put all of my sprites inside of all sprites but this we can change fairly easily so the ground should be in all sprites and self dot collision sprites and this thing i want to copy now and also the obstacles should be both in the old sprites and in the collision sprites and these collision sprites i will use only for the collisions they don't really do anything else so now that i have that i can create another method that i just call collisions in here we need self and nothing else and for now i just want to check if there's any kind of collision between my plane and my obstacles and this happens with pie game dot sprite dot sprite collide and in here we need one sprite we need a group and we need what is called do kill the sprite is the one sprite we want to look at in my case this is myself dot plane the group we want to look at is self dot collision sprites i think i called it yeah and do kill means if this sprite here collides with any sprite inside of this group do we want to destroy that sprite inside of this group now in my case it actually doesn't matter because we want to crash the game as soon as there's any kind of collision so my case i went with false but it really doesn't matter and i guess just to test this let's put this entire thing inside of an if statement and if that is the case let's say pygame dot quit and sys dot exit and now we can call it let's say after the update method so self dot collisions and let's see what's going to happen so the game doesn't throw an error and that looks pretty good i can also just fall on the ground and this also looks pretty good so this is working pretty well however it's not actually working well and let me actually play it again and if i play this for a while so they could see we didn't really touch any of the obstacles but the game still ended and the reason for that is this let me give a bit of space our obstacles look something like this they are some kind of mountain but if we just use this kind of collision mechanic here we are using rectangle collisions so pygame essentially draws a rectangle around this mountain and that is going to be the collision which in our case is a pretty substantial problem because these areas here shouldn't count as a collision but right now they do which makes the game basically impossible also our ground looks something like this so technically if the player is here for example the game shouldn't end but since we are using rectangles our actual rectangle box to check the collision is something like this so even if the player is in some kind of valley the game would still consider this a collision right now so all of this combined this isn't really working right now and the workaround we have to go with is mask collisions now i have made a whole tutorial exclusively on how to use a mask for collisions and for basically anything else in pygame so check this tutorial if you want to get an indepth look at this but in the most basic sense a mask just collects all of the pixel positions of each of our sprites and then checks the collisions between them it's really easy to implement and well let's do it right now so i want to get a mask for my plane my obstacle and my ground and i guess the ground is the easiest one let's start with this one we actually only need a single line of code and let me add another comment here mask and we have to add self.mask and this has to be called mask you cannot give this any other name and now to get our mask we need pygame dot mask dot from underscore surface and then here we just need a surface and in my case this is going to be self dot image and now we have a mask for our ground and this line i can actually just copy and minimize the ground and for the obstacle i can just add a mask in here at the end that's basically all we needed so we can minimize this one as well now for the plane things get a bit more complicated but first of all when we call the init method we need our mask so it has to be in there as well the problem for the plane is that we are updating this surface so this surface here quite a bit before we are actually drawing it so this animate here and this rotate here in particular change the actual surface and in practice think of it like this if this is our surface for the plane when we are finishing the animate method then we have a mask that's going to look basically identical to this but now when we call the rotate method so the one all the way at the end here we might get something that looks like this and as a consequence if we didn't account for this new surface we might get a collision here for example or all the way up here which might be frustrating so after we are doing a rotation we want to set a new mask and this is done by just creating a new mask here or while updating the attribute and well that is actually all we needed so now each of our main sprite our ground our plane and our obstacle each have a mask the only sprite that doesn't need a mask is the background because this one doesn't have any collisions but now if we run all of this again we still can't see any kind of difference so the collision still breaks the reason for that is that sprite collide is going to need one more argument and that is going to come right at the end and what we have to add in here is dot pygame.sprite.com underscore mask and now this should be working so now okay terrible example now let me move down here now you can already see it there so now i was definitely in the bounding rectangle box of these obstacles but the game didn't crash only when i actually flew into an obstacle the game did crash so this seems to be working just fine now i guess while we are doing the collisions there's one bug in our game it's not really a bug but if i just go all the way up and keep on clicking the game basically well we never collide with anything because we're on top of the entire game so this isn't exactly helpful and to account for that all i really have to do is extend this if statement and add or wrecked self.plane.rect. top is smaller or equal to zero so we want to trigger a collision if the plane collides with an obstacle or if the plane goes too high and now let's try this again if i go all the way to the top the game crashes that way the player can not circumvent all of the obstacles now with that we can actually work on the final part that we want to display a score and if the player has been crashing into something we want to get some kind of game over or restart menu that also shows the score oh and i forget after this section we're also going to add some sound but that is really easy to implement so let's work on the score and the game over screen here we are back in our main.pi file and i want to start working on displaying a score and for that we need a couple of things to get started most importantly we need some kind of font and this i'm going to do in the init method so in here i'm going to add another section let's call it text i think makes the most sense and in here i want to create a self.font and this we get with highgame.phone and in here we need two bits of information we need a font itself and a font size now the font size is just an integer in my case i went with 30. and for the font itself we will need a file and in my case this one looks like this and if you open up the project files you have to go to graphics let me move it down a bit and there we have font and there we have bd cartoon shout and that's the true type font file or ttf and that is what we're importing in here now besides that we also need a score attribute to save the font which in my case is just score that starts at zero and that is basically all we need for now to get started with the score now to display it i want to keep all of this in a separate method so let's call this one display score and then here we need self and nothing else and now we have to figure out how to get a score and there are different ways of getting the score so one method could be that we get a plus one in our score whenever the player crosses an obstacle another way would be to just measure the time since the game started and that's the one i went with but honestly all of these methods are fairly easy to implement so choose whichever one you prefer but in my case i am just going to go with time and well all we really have to do is get our self.score and then here to get the time since our game has started is pi games spelled correctly dot time dot get underscore ticks and this is going to give us milliseconds but for now let's just keep it so you see what we actually get now once we have that information we want to create a score surface and we want to get a score rectangle and then basically all i want to do is self dot display surface dot blit and then the score surface and the score rectangle so we have to figure out the score surface and the score rectangle and i think this could be a pretty good exercise for you so the score we have right now is a text turn this text into a surface and from that surface get a rectangle and then blit both of those on the display surface and see how far you get to turn a string into a surface we first of all need our self.font so the font we have created up here and then we need render and in render we have three bits of information we need a string we need antialiasing and we need a color and let's go through them i guess from the start our string is just our self.score the problem is i actually misspoke this isn't a string it's an integer right now that gives us the milliseconds since the game has started so we have to turn this into a string which isn't very difficult i am just using the string method you could also use an f string it really doesn't matter next up we have antialiasing and this basically means if we want to apply a filter to the text to make it a bit more smooth which in my case i do want to do and the only time you don't want to use this is if you have picks a lot because then it makes it kind of weird but if you have anything else you do want this to be true and finally for the color i kept it simple and went with black and with that we have a surface now next up to get the rectangle we want the score surface dot get underscore rect and in here we have to figure out a position and let me illustrate what i want to achieve let's say this here again is our entire display and i want the score to be up here while the game is active which specifically means that i want the middle of the window in the middle of the entire window so this is the width of the window divided by two and then i also want some kind of offset from the top and this is some reasonably large number it doesn't really matter specifically what it is the middle part here is much more important to get to that point i have placed the mid top and for the mid top we need x and y and x is the easier part for this one i just got the window width and divide it that one by two and for the height i just went to window height divided by ten so that the top of the text is ten percent from the top of the window that's kind of all that means here and that is all we needed for the basic thing so now we just have to call this method let's do it after we're drawing all of the other sprites so self.display score and let me add a bit of white space and it's actually really important that this display score comes after all of the sprites drawing because this one draws on a display surface if we are calling this before this method here we wouldn't see it because the draw method draws the background on top of it so the order here does matter but right let's run this and we can see we have a score except one that gets way too high way too fast so this is not ideal and the reason here is that this number is giving us milliseconds instead of seconds and well to change that all we have to do is to floor divide this by 1000 and now let's try this again and this is feeling much better except i am terrible at this game so this is feeling well it is working cool so with that we have a score now next up i want to work on the game closing down as soon as we have any kind of collision and instead i would rather have some kind of game over screen and then if the player clicks again the game restarts and that is also fairly easy to implement now basically in my game i want to have a attribute that i called self.active and this is essentially going to attract the status of the game so if we have crashed into something it's going to be false and once we're restarting self.active is going to be true again so essentially once we have a collision we want to make some changes to this and specifically in here i want to have self dot active is going to be false so now instead of closing down the game we're getting to a different state and now for this state to work properly i need a few more graphics and this is going to work in the init method so in here i'm going to add one final section that i call menu and in here we get self dot menu underscore surface and i want self dot menu underscore rect and really all i'm going to do in here is pygame.image.load and for this one we just need another string to graphics dot ui menu dot eng and don't forget we need convert underscore alpha as always and just to demonstrate what we are getting here is again the game folder we go to graphics we go to ui and there we have this menu thing so that's what we're importing all right and next up for the menu rectangle we are just going to get self.menu surface dot get underscore rect and this i want to place square in the center of the window so center is going to be my window width over 2 and my window height over 2. and the basic idea is if self.active is equal to false i want to display this menu here and i guess what i haven't done for this project is this thing doesn't have any scaling right now so if the game gets really large this might look very very small but that's something you can work on yourself all you would really need to do is get this scale factor and apply it to this menu surface as well it should be fairly easy to implement okay now the basic idea of what i want to do is further down here that if self dot active then i want to check for self dot collisions and this is what i have done so far up here but this i only want to do if the game is active so i want to remove this one which really just means that i am going to delete this line and let me put it on another line so it looks a bit cleaner now if that is not the case i want to self dot display surface dot split and self dot menu surface and self dot menu rectangle so the basic idea is if the game is active we're checking for collisions if not we are blitting the menu and if we run out of this the game is still working but now if i crash we can see our logo and this is working quite well we can't do anything with it right now but it does work at the very least also the score keeps on running so that's stuff we have to work on but i guess step by step let's start working on the score i guess that's the most important one and this is going to happen in the display score again here and basically what i want to do this score should only update if the game is active so all of this should be in if self dot active and only if that is the case we want to get a new score and i guess while we are here we can also implement something else that while the game is active i want the score to be on top of the window but if the game is not active i want the score to be below the menu and that we can also work in this method here and basically all we have to work with is right now with our window height divided by 10 and this is the top middle part of the window i want to cut this thing out and change it to a y and now if the game is active i'm going to set this y to the same number so far this wouldn't really be a difference but what i can do now i can set an else statement and in here y should be a different position and what i went with is window height divided by two and this is right now the exact middle of the window and i want an offset to be a bit below that and to get this offset i want my menu rectangle and the height of that and well basically what we are doing is this here again is our entire window this would be the center of the window and we want to go down by the height of the menu so the height of the menu rectangle that's basically all we're going to do here and i guess let's try if this is working so if we run the code now the game is still working and if i crash into something we can see a number below the menu now and it's well not counting anymore although i guess the number is a bit too far down so i want to move it up a tiny bit and to achieve that i'm going to divide this number by let's say 1.5 and let's put it in brackets that should look a bit better so now let's try this again game is still working just fine if i now crash into something this is looking much better cool so now we have the score almost working properly there's going to be one more thing we do have to work on but for now i'm happy with this now i guess next up we can work on restarting the game because right now we can't really do anything and for that we have to look at the event loop so all of this stuff here and basically what i want to achieve is when the player presses the mouse button i want to restart the game so inside of this if statement i need another if statement that if self dot active so if the game is active and i press the mouse button i want the plane to jump but if that is not the case so else i want set self active to true let's actually see what we get so if i run the game it's still working but if i crash now we well get nothing and the game continues after i press and i think if i press fast enough there you can see if i think press fast enough you can kind of tell the idea okay now what is the problem basically let me draw it this here is our game window and the problem we have right now is if we stop the game the plane continues to exist and keeps on going downwards and once we are restarting the game the plane is still down here somewhere and since all of our obstacles are here and here and here the plane doesn't reach them whatsoever and as a consequence the game keeps on running but we can't see the plane so that is something we have to work on and in my case here's how i approach this in my collision method after we have a collision i am destroying the plane so self.plane.kill and then when we are clicking to create a new game so down here i am creating a whole new instance of the plane so self dot plane is equal to plane and let me actually copy this from earlier we just need this line here and with that let's try this again so the game is still working now crash into something and now my plane is well at least in the right position back the problem we have now is that we keep on having all of the obstacles in the game which is kind of unfair if you are just spawning a new game also the score doesn't start at zero it starts at the previous score so the score keeps on rising so there are two things we have to work on i guess we can start working on the obstacles that's the easier well both are really easy but let's work on the obstacles first so essentially what i want to do once we have a collision i want to destroy all of the obstacles and this happens again in the obstacle class and really all i want to do here is for sprite in self dot collision sprites dot sprites i want to sprite dot kill and also in my timer so in this timer here i only want to spawn new obstacles if the timer is running out and self.active is true so that way we are not spawning any new obstacles and we are destroying all the existing obstacles although right now there's a bit of a problem if we are doing that let me run the code to demonstrate so the game is still working but now if i crash into something we are also losing the ground and if i now click again it well doesn't come back which isn't ideal and the problem here is that in my sprites let me minimize all of those my ground and my obstacle are all in the same sprite group which is causing the problem here and i think the easiest way to fix this is i want to give each of these sprites a sprite type and then in here if sprite dot sprite underscore type is equal to obstacle that is horrible spelling stick kill only then do i want to kill the sprite so now in my sprites i have to give them different sprite types and this we can do straight at the top so in here self dot sprite underscore type is going to be let's call this one ground and then for the obstacle this could be self.sprite underscore type is going to be obstacle and now we should be good to go let's try this again now and now if i crash into something the obstacles disappear but the ground remains and now if i restart the game this is looking much better cool so this seems to be working quite well if i crash again this same thing happens again cool this is working now the final problem we have is the score because this one doesn't go back to zero instead it keeps on updating and the problem here happens in this line pygame.time.getticks gets the time since the program or our game has started it doesn't really care what we are doing in the game it's always starting from zero whenever we start our program so we have to account for that and to account for that here's what i have done is this score is always going to be offset by self. i call this the start offset that is i'm getting worse at spelling and this start offset is just another time when the game became active again so if we're starting the game at 2 seconds start offset is going to be 2000 so 2 seconds in milliseconds and this start offset we get down here so all i want to do is self dot start offset is going to be pygame.time.getunderscore ticks and obviously we also need the same number up here up here we need self dot start offset and by default it's going to be zero and now let's try all of this and now the time keeps on working i get 2 for the score and now if we start again we start again at 0. so this is working pretty well cool i'm quite happy with this and i can crash again and this keeps on working really well cool so with that we have our score and our game over screen so the last thing we are going to need are two sound effects and those are incredibly simple let's go straight into our code and let's work on them here we are back in main.pi and we want to add some sound and let me just demonstrate what we have so in our third folder we have sounds and in here we have jump and we have music and that's kind of all we need let's start with the jump sound although it doesn't really matter which one you start with and i can minimize everything else in here and in the init method of the plane i want to add some sound so all the way at the end i want to add some sound here and all we really need is self dot let's call it jump sound and to import music we need pygame dot mixer dot sound and now we need a path to the sound file which in my case is going one fold up then we have sounds and then we have jump.wav and now before we are going to use that sound by itself it's kind of loud so i want to set self.jumpsound.set underscore volume to 0.3 in this set volume 1 would be the maximum and 0 would be well 0. and in this case 0.3 means 30 percent of the original volume and now i just have to play this sound whenever we jump and we know we jump when we are running the jump method that kind of makes sense so in here i just want to run self.jumpsound.play and that should be all we need it although i just realized this should be jump.wav not slash and now let's try this and let's see what we get and well that is working except it feels absolutely horrible but that's only because we don't have any kind of background music right now but that we can fix quite easily and that's gonna happen in the main file and this could be a pretty good exercise for you as well so add the background music yourself and see how far you get all we need is first of all i want to add another section in here i think this one is going to be the final one now and in here i want self. let's just call it music and this is going to be again pygame.mixer.sound and the path here is again a string we go up sounds and then here we have music.wav and i'm happy with the volume here and to play this one i just want straightaway self.music.play and the really important thing for this one is we need to add one argument in here and that is loops that should be negative one and this one tells pygame to play this music perpetually so we never stop and we played in a loop so if we run the game now okay that works really well so i hope this tutorial was useful and i will see you around
