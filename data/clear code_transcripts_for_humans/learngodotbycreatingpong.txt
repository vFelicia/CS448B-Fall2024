With timestamps:

00:00 - hello in this tutorial we are going to
00:03 - be creating this pong game
00:04 - and since pong is a fairly simple game
00:06 - this isn't going to be too difficult
00:08 - so if this is your first game in godot
00:10 - or your first game in general this
00:12 - tutorial should be quite easy to follow
00:14 - but if you're looking for specific
00:16 - things here are all the steps i will be
00:18 - going through
00:19 - and if you already know some godot it's
00:21 - probably safe to start in this stage
00:23 - and if you happen to like this tutorial
00:25 - check out my python game development
00:27 - course
00:28 - in there you'll be learning much more
00:30 - sophisticated games in python and good
00:32 - dough
00:32 - including a first-person shooter but
00:35 - with all of that covered
00:36 - let's talk about godot so what is godot
00:39 - well godot is a game engine and all that
00:42 - really means is that godot
00:44 - is a program that helps you make video
00:45 - games so when you make your game in
00:47 - godot
00:48 - you see immediately how your game would
00:49 - look like and you can drag and drop
00:51 - elements on the screen and see changes
00:53 - instantly
00:54 - which is a much better way to create
00:56 - video games than just looking at
00:57 - hundreds of lines of code
00:59 - and godot is by no means the only video
01:01 - game engine there are loads of
01:03 - alternatives
01:04 - but the one thing special about godot is
01:06 - that it uses gdscript
01:08 - which is essentially python so if you
01:10 - know python and you want to make video
01:12 - games
01:13 - then godot is the best option by far
01:16 - but to use it we first have to install
01:18 - it which is actually super easy
01:20 - all you have to do is to go to
01:22 - godotengine.org then go to download
01:25 - and then download the version of godot
01:26 - that is appropriate for your operating
01:28 - system
01:29 - in my case that's windows and once you
01:31 - finish the download and unzip the file
01:33 - you should see a folder like this and in
01:36 - there all you have to do is click on
01:37 - godot
01:38 - and then you can see the project manager
01:42 - and in here you could either open an
01:44 - existing project or create a new project
01:46 - in this case it's empty because we
01:48 - haven't created any projects yet
01:50 - but to do that we have to click on new
01:51 - project and then godot was asking us for
01:54 - a name and a project path in my case i'm
01:57 - going to call this file
01:59 - pong i already have a file path that i
02:02 - can paste
02:02 - in right now and godot needs to have an
02:06 - empty folder so this is what i'm going
02:07 - to create here
02:09 - and then we have a few more options for
02:10 - the renderer but this one is not going
02:12 - to matter for this tutorial
02:13 - so i leave it to the default option but
02:16 - that is
02:17 - all we needed so now we can click on
02:18 - create an edit
02:20 - and then we are getting into our game so
02:23 - with that let's talk about how godot
02:24 - works
02:27 - all right now that we have our basic
02:29 - project here's what we can see
02:31 - and there are quite a few elements on
02:33 - the screen right now and i am going to
02:35 - explain them when we get to them
02:37 - but for now don't worry too much about
02:39 - them and before we are getting into
02:41 - anything in godot
02:42 - i would really like to start explaining
02:44 - how godot works on a more fundamental
02:46 - level
02:47 - because that is really going to help us
02:48 - understand later on what we are doing
02:51 - so the door relies on two fundamental
02:53 - concepts to function
02:55 - the first one is called nodes and nodes
02:58 - are the really basic building blocks
02:59 - that actually create your game
03:01 - so for example a node could be a picture
03:04 - a note could be a timer
03:05 - a note could also be a 3d object it
03:08 - could be lots of different things
03:09 - godot has a few hundred of them and they
03:12 - effectively create your game
03:14 - so when you see for example a player
03:15 - character this one would be created out
03:17 - of
03:18 - different notes coming together for
03:20 - example one note would be the picture
03:22 - another note would be the physics
03:23 - calculation another note might be a
03:25 - skeleton animation
03:27 - but what you essentially do in godot is
03:29 - that you put different notes together
03:31 - and move them around on the screen and
03:33 - that creates your game
03:36 - and that's really it you have a couple
03:37 - of notes on the screen
03:39 - and you can influence the attributes and
03:41 - via that you can move them around
03:43 - and that's really all you need to create
03:44 - a game they can do quite a few more
03:47 - things like communicate with each other
03:48 - or have specific code but what you
03:51 - really have to understand
03:52 - is that nodes create your game they are
03:54 - the most fundamental concept
03:56 - in godot and what we are going to work
03:58 - with the most
03:59 - by far but here's one problem by default
04:02 - nodes are not visible which is kind of a
04:05 - problem for a video game
04:07 - so we need a second concept and that
04:09 - second concept is called a scene
04:11 - and scenes in godot serve two purposes
04:14 - number one
04:15 - is that they are canvas for your notes
04:17 - so what you effectively do with your
04:19 - notes is that you put them on a canvas
04:21 - and what the player later on perceives
04:22 - as a game is the scene with all the
04:25 - notes in it
04:26 - so a scene basically displays your game
04:29 - and besides that
04:30 - scenes are also really powerful to
04:32 - organize your game
04:33 - and the reason for that is that we
04:35 - really easily end up with
04:36 - quite a few different notes to organize
04:38 - our game so if you have any even
04:40 - slightly more complex game
04:42 - you will end up with hundreds of
04:43 - different notes which by itself would
04:46 - get
04:46 - really unreally and complex to work with
04:49 - so instead what we can do
04:50 - is have different parts of our game as
04:52 - individual scenes
04:54 - so for example a player could be its own
04:56 - scene and then you put this player scene
04:58 - into the level scene
05:00 - and via that you can work on each of
05:02 - these elements independently
05:04 - and focus on one specific thing and with
05:07 - that your game remains much more modular
05:09 - and much easier to work with and that's
05:12 - basically it
05:13 - if you understand these two concepts you
05:15 - already have a really good starting
05:16 - point for godot
05:17 - so let's actually have a look at how
05:19 - this works in practice
05:21 - so here we are back in our godot editor
05:24 - and what we can see
05:25 - right in the middle of the screen is
05:26 - called the viewport and this viewport
05:28 - shows our open scene right now and what
05:31 - we have at the moment
05:32 - is a 3d scene and if you hold the middle
05:34 - mouse button in here and move the mouse
05:36 - around
05:37 - you can move around in space and if you
05:40 - look at the top of this window
05:41 - you can see a tab right now it says
05:43 - empty and you could save it and give it
05:45 - a name
05:46 - and you could save all the notes you
05:47 - want in there but we don't want a 3d
05:50 - scene right now because our game is 2d
05:52 - and to change between a 2d and the 3d
05:55 - scene you have to look all the way at
05:56 - the top
05:57 - and there you can see 3d and 2d and if
06:01 - you just click on 2d
06:02 - now we can see a 2d workspace and
06:05 - in here you can see this blue rectangle
06:09 - and this is the actual size of our game
06:12 - so if you want to put anything on the
06:13 - screen
06:14 - it has to be inside of this blue
06:15 - rectangle for the player to see it
06:17 - so this is really important so this
06:20 - would be a very basic thing to look at
06:21 - the different scenes in your game
06:23 - and if you want to create a new scene
06:24 - you just click on the plus icon
06:26 - and then you would have a new scene and
06:28 - you can create more it's
06:29 - really up to you but right now i only
06:32 - want to keep this one scene
06:34 - and i want to keep it in 2d so
06:37 - now we have a scene but obviously you
06:40 - can't really see anything on the scene
06:41 - right now
06:42 - and to actually display something we
06:44 - need a node
06:45 - and to get notes you have to look at the
06:47 - top left of the screen
06:48 - and there you can see what's called a
06:50 - scene tree and right now we can choose
06:53 - different nodes
06:54 - we can choose a 2d scene a 3d scene a
06:57 - user interface or
06:58 - another node and if you click on other
07:00 - node
07:01 - you can see a fairly long list let me
07:04 - open up
07:04 - all the different subfolders these are
07:07 - all
07:08 - the different notes that you can have in
07:10 - godot
07:11 - and here you see lots of different
07:12 - things for example you have a skeleton
07:15 - you have a visibility notifier you have
07:17 - a touch screen button
07:18 - you have a polygon 2d you have particles
07:22 - and you have something called a sprite
07:24 - and a sprite is what i'm going to start
07:26 - with for now
07:27 - and this is really just a picture and
07:31 - you might be asking right now there are
07:33 - so many different notes in here how do
07:34 - you find anything
07:36 - and for that you use the search function
07:39 - and in here you can just type sprite and
07:41 - then get the sprite node that you want
07:44 - and it will take you some time to learn
07:46 - about all the different notes
07:47 - but once you get even a little bit of
07:49 - practice this will come very natural to
07:51 - you
07:52 - but okay so with the sprite selected i
07:54 - click on create
07:56 - and now we can see in our same tree that
07:58 - we have a sprite node
08:00 - but in the viewport we can only see this
08:03 - red cross here so how do we add a
08:06 - picture to this node
08:08 - and for that you have to look all the
08:10 - way to the right and there we have the
08:12 - inspector
08:13 - and in the inspector you can set the
08:15 - attributes of this node
08:17 - and right at the top we have what's
08:19 - called a texture attribute
08:21 - and if you hover over it godot gives you
08:23 - a description of this property
08:25 - and it says texture object to draw and
08:28 - what this one effectively does
08:29 - is it takes a file of a picture and it
08:31 - displays it
08:33 - so now what we need is a picture and we
08:36 - do have that
08:37 - if you look in the bottom left there we
08:39 - have a file system
08:40 - and by default every good old project
08:43 - always has one default file
08:44 - that's called eigen.png which is the
08:47 - godot logo
08:49 - and all you really have to do is to drag
08:51 - and drop
08:52 - this icon into the texture slot
08:56 - and you can already see when you drag
08:57 - the file there's this blue
08:59 - line around the file so let me drop it
09:01 - in and
09:02 - now we can see our picture so this one
09:05 - works quite well
09:07 - and if i zoom out a bit we can also
09:10 - move this picture around and place this
09:12 - wherever you want to have it on the
09:14 - screen
09:14 - and let me put it roughly in the middle
09:17 - so this would be one
09:18 - attribute of the sprite node you could
09:21 - also look under transform
09:23 - here you can see position rotation and
09:25 - scale
09:26 - so in here you could for example rotate
09:28 - this image
09:30 - or you could scale it up in different
09:32 - axes which i don't want to do right now
09:36 - but this is really what you have to
09:37 - understand for godot that what you
09:39 - effectively do
09:40 - is you take different notes and you
09:42 - affect their properties
09:44 - and this can be done either by using the
09:46 - inspector
09:47 - or it could be done in code which is
09:49 - what we are going to see in just a
09:50 - little bit
09:52 - but for now let me save this scene
09:55 - and to save a scene you can either press
09:57 - ctrl or command s
09:58 - or go to scene and save scene and if i
10:01 - click on it
10:02 - we can see the folder again we created
10:04 - earlier
10:05 - and in here i want to create a new
10:07 - folder that i call
10:09 - player let me just spell it correctly
10:13 - and now in this folder i want to save
10:15 - the scene also with the name
10:19 - player and gudu's scenes are always
10:22 - saved with the file ending tscn
10:24 - which i guess is short for scene
10:28 - no idea but it doesn't really matter so
10:30 - click on save
10:32 - and now at the top of our scene we can
10:34 - see player
10:35 - and what we can do now is actually run
10:38 - the scene
10:38 - and see how our game would look like and
10:40 - to do that
10:41 - you have to look all the way at the top
10:43 - right and there we can see
10:45 - play we can see play scene and we can
10:48 - see play custom scene
10:50 - what really matters for now is play
10:52 - scene or f6
10:54 - and let me click on it then go to loads
10:56 - for a bit and here we can see our game
10:58 - or well not really a game but the
11:00 - picture
11:02 - and you can't do anything right now but
11:05 - you can see your game
11:06 - and if we add a bit more code this could
11:09 - be interactive
11:10 - so we could have user input here we
11:12 - could have enemies in here we could have
11:13 - a moving ball in here
11:15 - this works just like a game but for now
11:18 - let me close it
11:21 - so this is really the most fundamental
11:24 - concept
11:24 - in godot that you work with seeds and
11:26 - with notes
11:28 - there's one more concept i do want to
11:29 - cover before we are getting into the
11:31 - actual player character
11:33 - and that is that in the century the
11:35 - notes are always in relation to each
11:37 - other
11:38 - and let me illustrate what this means so
11:41 - with the sprite selected
11:42 - i want to add another node to this that
11:44 - is also going to be a picture
11:46 - and to add another node you have to go
11:48 - either click on this plus icon
11:50 - or press ctrl a and let me add another
11:54 - sprite node
11:55 - so we have another picture and what we
11:57 - can see right now
11:58 - is that we have one sprite at the root
12:01 - of our same tree
12:02 - and another sprite connected to it and
12:06 - what this means is that this bright is a
12:08 - child
12:08 - of this node and they're usually called
12:10 - parent node and child nodes
12:13 - and this has direct implications for
12:15 - your game
12:16 - and let me actually add an image to this
12:18 - second sprite node
12:20 - so again i just drag and drop this icon
12:22 - and then there
12:23 - and we can't see any change right now
12:25 - because the images are on top of each
12:27 - other
12:27 - so let me move this image a bit to the
12:31 - side
12:32 - so we can see our sprite node selected
12:34 - here the one to the bottom right
12:36 - and our parent node the one right in the
12:38 - middle
12:40 - now here's the really important thing if
12:42 - we make any changes to the parent node
12:45 - we are also going to affect the child
12:47 - node however when we move the child node
12:49 - we are not going to affect the parent
12:50 - node and let me demonstrate what this
12:52 - specifically means
12:54 - so if the parent node selected i just
12:56 - move it around
12:57 - and while we're doing that we also move
12:59 - the child node
13:00 - and this would also apply if i go back
13:02 - to transform if i rotated it
13:04 - it would also rotate the child node and
13:07 - if i scaled it
13:08 - same thing whatever we do to the parent
13:10 - node we are also going to do to the
13:12 - child node
13:13 - and this is going to become really
13:15 - important to create our player character
13:17 - in a little bit
13:18 - because we want to have one note that
13:20 - controls the entire player character
13:22 - and all the other notes on the player
13:23 - character always move in the same
13:25 - direction as this note that actually
13:27 - controls the player
13:29 - but i'm getting ahead of myself i think
13:32 - we have made some good progress for now
13:33 - so let's actually start talking about
13:35 - our player character
13:38 - so let's talk about creating a player
13:40 - character
13:41 - which in our case is going to be a
13:43 - paddle that has a couple of
13:44 - functionalities
13:45 - and let me go through what we want our
13:47 - player pedal to be able to do
13:49 - the first and most important thing is
13:52 - that we have to be able to see it
13:53 - so there has to be some kind of picture
13:55 - on our pedal
13:56 - and this one should be straightforward
13:58 - if you can't see your player character
13:59 - you don't really have a player character
14:02 - number two is that we have to be able to
14:05 - control this player character
14:07 - so if you're pressing a button on our
14:09 - keyboard this thing is actually moving
14:11 - so this is another really important
14:13 - thing and besides that
14:15 - our player character also needs to have
14:17 - the ability to react to physics
14:19 - and this is actually a really important
14:21 - part that we want a ball to bounce off
14:24 - this player character later on
14:26 - and this is a physics calculation and
14:29 - this is going to require a specific node
14:31 - in godot
14:32 - that can actually work with physics and
14:34 - in total
14:35 - the dough has four different nodes that
14:37 - can work directly with physics
14:40 - at least in 2d space and these are
14:42 - called kinematic body2d
14:44 - rigidbody2d static body2d and area2d
14:49 - and they all work with physics in
14:51 - slightly different ways
14:52 - and i'm going to go through all of them
14:54 - bar 1 in this tutorial
14:56 - so i will explain every single one of
14:58 - them when we get to it
15:00 - but for now the one we are going to work
15:01 - with is called the kinematic body 2d
15:04 - which is the most powerful kind of
15:06 - physics body in godot
15:08 - and this one is usually the note used
15:09 - for a player character
15:11 - because this one can influence other
15:13 - physics bodies
15:14 - and it can also be influenced itself by
15:16 - other physical bodies
15:18 - and we can move it in code so this one
15:20 - is really powerful and really useful for
15:22 - us
15:23 - and this node is actually going to be
15:24 - the foundation of our player character
15:27 - but there's one problem that's going to
15:28 - sound a bit weird that the kinematic
15:30 - body by itself doesn't have a physical
15:32 - body
15:33 - and this is going to need another note
15:35 - that's called a collision
15:36 - shape and think of it like this a
15:38 - kinematic body 2d
15:40 - by itself is essentially an atom in
15:43 - space
15:43 - it can be influenced by physics but it's
15:46 - so small you can't see it
15:48 - and it's also so small that it can't
15:50 - really collide with anything
15:52 - so we have to give it a physical shape
15:54 - which is an entirely new note
15:56 - but this is basically all we're going to
15:58 - use for our player so let's actually
16:00 - implement all of this
16:01 - so here i'm back in my player scene and
16:04 - what i want to start with is to get rid
16:06 - of some notes
16:06 - so this child sprite note i don't need
16:09 - so i'm going to delete it
16:10 - so deleting it you can either go to
16:12 - right click and delete node
16:14 - or press on delete and then godot is
16:17 - going to double check
16:17 - and i do want to delete it now our
16:20 - sprite node i don't want to get rid of i
16:23 - want to change it
16:24 - which you can also do and all you need
16:27 - to do is to right click on the node
16:29 - and change type and then godot brings us
16:32 - back to the menu
16:33 - and here we can choose a different note
16:36 - and what i want to start with
16:38 - is called a kinematic body 2d and do be
16:41 - aware
16:41 - it has to be a 2d one there's also a
16:44 - kinematic body
16:45 - this one is three-dimensional so make
16:48 - sure to not use that one we want a
16:50 - kinematic body 2d
16:52 - and really easy way to tell between 2d
16:55 - and 3d notes
16:56 - is that 2d notes are always blue 3d
16:58 - notes are always red
17:00 - so that makes it kind of easy but ok we
17:02 - want a kinematic body 2d
17:05 - and if you double click on this you can
17:07 - also rename it so i want to rename mine
17:09 - to player
17:11 - and here already godot was giving us a
17:13 - warning
17:14 - that this note has no shape so it can't
17:16 - collide or interact with other objects
17:18 - consider adding a collision shape to d
17:20 - or collision polygon 2d as a child to
17:23 - define its shape
17:24 - and let's do that so i click on the plus
17:27 - icon again
17:28 - and let me get rid of this and i want to
17:31 - add a collision
17:34 - shape 2d and you could also use a
17:37 - collision polygon
17:38 - we're going to see this one later it
17:40 - works in very similar ways
17:42 - but for now i'm going to use a collision
17:44 - shape 2d
17:45 - so click on create and now we have our
17:48 - player parent node
17:49 - and a collision shape 2d as its child
17:51 - node
17:52 - and here we get another warning that a
17:55 - shape must be provided for the collision
17:56 - shape 2d to function
17:58 - and to give it a shape you have to look
18:00 - back into the inspector
18:02 - and there we can see shape and there we
18:04 - have a drop down menu
18:06 - and here we can select a couple of
18:07 - different shapes
18:09 - and this is going to be the physical
18:11 - body of your player character
18:13 - so you want to select a shape that
18:14 - resembles the player's shape as closely
18:16 - as possible
18:17 - which in my case i think is going to be
18:19 - a rectangle shape 2d
18:21 - which is well a rectangle and once you
18:25 - have clicked on that
18:26 - you can see this bluish icon with a
18:28 - couple of red dots
18:30 - and these red dots you can use
18:33 - to change the scaling of this rectangle
18:37 - and let me zoom out again so what we
18:39 - want is to resemble
18:41 - our player shape which is going to be a
18:42 - paddle somewhat reasonably well
18:44 - which is going to look something like
18:46 - this and this would be the shape that
18:48 - the ball
18:49 - is actually colliding with later on and
18:52 - what i also want to do
18:53 - is that right now our player pedal is in
18:55 - the middle of the screen
18:56 - because i moved the sprite there earlier
18:59 - and i want to change this back to 0 and
19:01 - 0. and for that
19:03 - i went to the inspector to transform and
19:05 - here we have the position
19:07 - you can either type in 0 0 in here or we
19:10 - could just use this icon
19:11 - and then we go back to position 0 and 0.
19:14 - and ok i can close this again and
19:17 - now we have to collision shape for our
19:19 - player but
19:21 - let me save this scene now if i were to
19:23 - run this game now
19:24 - by pressing f6 again or the icon we
19:27 - can't see anything
19:29 - because a collision shape is invisible
19:31 - to the player
19:32 - which makes sense you don't want to see
19:34 - the actual collision box that the player
19:36 - has around
19:37 - itself so we have to give an actual
19:40 - image to our player
19:41 - and the problem for that right now is
19:43 - that in our file system we only have the
19:45 - default godot icon
19:47 - which well doesn't really work for us so
19:50 - we have to import a couple of
19:51 - images and that is super easy to do in
19:54 - godot
19:56 - and all you have to do let me open my
19:58 - file so this pong folder
20:00 - is the point folder we used earlier to
20:02 - create our game
20:03 - and above that i have an assets folder
20:07 - and all i have to do is to drag this
20:09 - assets folder into the profile
20:11 - and then go back to godot and then it
20:13 - loads for a bit
20:14 - and now we have an assets folder and in
20:17 - the assets folder we have a ball
20:19 - a pedal a couple of sounds and a font so
20:22 - how our text would look like
20:23 - so these are all the things we need for
20:25 - our game it's actually very simple
20:27 - so let me close this folder again and
20:30 - i'm not going to use the icon psg
20:31 - anymore
20:32 - so i'm going to delete it and to delete
20:34 - it i
20:35 - right click on it and click on delete
20:37 - and then godot
20:39 - is going to remove the file from the
20:41 - project and can't be restored and i'm
20:43 - fine with that
20:45 - so okay now our game looks a bit cleaner
20:48 - and with that
20:49 - let's actually add the image to our
20:51 - player and if you want to challenge
20:53 - yourself for this tutorial
20:54 - now try to add the picture yourself to
20:57 - this player note
20:58 - so you could just pause the video now
21:00 - and try to do it yourself and continue
21:02 - after you're done and i would really
21:03 - recommend this it helps you to learn
21:05 - so much
21:07 - [Music]
21:09 - but let's do it together so with the
21:11 - player selected
21:12 - i'm going to click on the icon again and
21:14 - i'm going to add a sprite and you can
21:16 - also see our sprite note in the recent
21:18 - tab
21:18 - so i click on create and now we have a
21:21 - sprite
21:22 - and i just need to drag and drop the
21:24 - image of the pedal into it
21:26 - so i drag and drop the pedal into it
21:29 - and now we can see our pedal
21:32 - or the image of our pedal but there's
21:35 - one obvious problem right now
21:37 - that the shape of the pedal and the
21:39 - image of the pedal have different sizes
21:41 - so we have to resize the pedal a little
21:44 - bit
21:45 - to properly be above the pedal image
21:51 - and there's one thing you also have to
21:52 - realize that in the note 3
21:54 - the order really matters so right now
21:57 - the collision shape 2d
21:59 - is below the sprite and this you can
22:01 - also see
22:02 - in the viewport and let me reverse the
22:04 - order by just dragging it below
22:07 - now our sprite or the image is below the
22:10 - collision shape
22:11 - and this kind of thing is becoming
22:12 - important later on quite a bit
22:14 - where you want to control what elements
22:16 - are on top of each other
22:17 - so always be aware if something is
22:19 - further down in the century
22:21 - it's usually above the other nodes in
22:23 - the actual viewport
22:25 - but in here i want to make sure i drag
22:28 - all of
22:28 - the white part of the paddle inside of
22:31 - our collision shape
22:32 - and if you click on the blue part you
22:34 - can also move the entire shape around
22:36 - and if you hold shift then you move it
22:38 - only in one axis
22:40 - which can make things a lot easier and
22:43 - i want to make sure i only cover
22:47 - the whitish part and
22:52 - let me yeah okay i think this looks good
22:56 - if you want to be more precise with this
22:58 - you can also click on the rectangle
22:59 - in the inspector and in here you can
23:02 - give it very specific coordinates
23:04 - so you could for example let me go with
23:06 - 14 and 60
23:08 - so we have cleaner numbers although that
23:09 - doesn't really matter
23:11 - but okay now we have our player
23:14 - character
23:15 - this is really all our player character
23:16 - is ever going to be it consists of a
23:18 - kinematic body
23:20 - an image and a collision shape this is
23:22 - literally all you need to create a
23:23 - player
23:24 - so let me save the scene by pressing
23:27 - ctrl s
23:28 - and run the scene and now we can see our
23:31 - player in the top left
23:33 - which isn't too good so let me drag
23:36 - the entire thing a bit more to the
23:38 - middle and i can do that either by
23:40 - having player selected
23:42 - and going to transform and moving it
23:44 - here so i could press
23:46 - something like 100 and 500.
23:50 - let's say more like 300
23:53 - or you could just drag and drop it but
23:55 - there's one more problem before i finish
23:56 - this part
23:57 - if you were to just select this thing
23:59 - and try to drag it
24:01 - you would only select the node furthest
24:03 - down in the scene tree so the collision
24:04 - shape in this case
24:06 - which would be a problem because our
24:08 - play would collide in this shape
24:09 - but we would see the player here so this
24:12 - is no good
24:13 - so what we have to make sure is that
24:15 - when we have this player selected
24:16 - that we can't move the sprite or the
24:18 - collision shape
24:19 - and for that you have at the top here an
24:22 - icon
24:23 - that looks like this it's very hard to
24:25 - explain
24:26 - all it does is make sure that you cannot
24:28 - select children nodes
24:29 - and if you click on it you can see this
24:31 - icon here
24:32 - and if that's the case you can only
24:34 - select the parent node not the children
24:36 - nodes
24:37 - and this makes sure that all of these
24:38 - nodes always stay in the same place
24:40 - so now i can move it roughly let's say
24:43 - to left side of the screen
24:45 - and this is a really important part i do
24:47 - want to talk about
24:48 - that to create our game we are basically
24:51 - creating an allusion to the player
24:53 - that what the player is actually going
24:55 - to control later on is the kinematic
24:57 - body 2d
24:59 - so one specific point in space it just
25:02 - happens to be that attached to this note
25:04 - we have an image of a pedal and a shape
25:06 - with the size of this pedal
25:08 - so the player assumes all of this is one
25:10 - object but in reality
25:12 - it really isn't but uh but okay i think
25:15 - this part is getting quite long
25:16 - so let's get to the next stage and that
25:18 - is to actually give our player the
25:20 - ability to move
25:21 - which is what we are going to do with
25:23 - code so let's have a look at that
25:26 - so let's talk about how our player can
25:28 - move and for that we have to talk about
25:30 - programming in godot
25:31 - and there are different languages you
25:33 - can use to code in godot the language we
25:35 - are going to use is called gdscript
25:37 - which is insanely similar to python i
25:40 - talked about this earlier in this video
25:42 - but it's also a really simple language
25:44 - so even if you never code it before
25:46 - this should still work for you or at
25:48 - least i hope it will
25:50 - but before we're getting into specific
25:52 - code there's one important concept
25:54 - that in goodu code is always connected
25:56 - to a node
25:58 - and what you effectively do is you take
26:01 - a node and take all its attributes
26:03 - and you create additional capabilities
26:06 - and each node can be expanded in
26:08 - different ways
26:09 - so for example a kinematic body 2d can
26:12 - get different functionalities compared
26:14 - to a sprite note for example
26:16 - but you don't have to worry about this
26:18 - too much for now
26:19 - let's actually start creating some code
26:21 - so here we're back in our player scene
26:24 - and i have our player notes selected and
26:27 - to create a script
26:28 - you have to use this icon here which
26:30 - says attach a new or existing script to
26:32 - the selected note
26:33 - so i click on it and now we have a
26:36 - couple of options
26:37 - the first one is the language we want to
26:38 - use and we want to use gdscript
26:41 - then we have inherit and this is the
26:43 - node we are starting from that we are
26:45 - going to use to expand its capabilities
26:47 - so kinematic body2d node is fine then we
26:50 - have a template as default empty and no
26:53 - comments
26:54 - i will leave it now at default but later
26:56 - on you definitely want to start with
26:57 - empty
26:59 - then we have built-in script which is
27:01 - just asking you if you want to save the
27:02 - script as its own file
27:03 - or as part of the note it's usually left
27:06 - off but it really doesn't matter
27:08 - and then we have the name of the file so
27:10 - player in my case
27:11 - and what we want to store it also in the
27:13 - player folder so all of this is fine by
27:15 - default usually
27:16 - so i click on create and now at the top
27:19 - we can see script
27:20 - and we can see our script and if you
27:23 - want to go back to your viewport
27:24 - you can just click on 2d at the top or
27:26 - go back to script
27:28 - and you can also use the f keys to
27:29 - switch between them
27:31 - where f1 is 2d f2 is 3d and f3 is the
27:35 - script view
27:36 - and this does make it quite a bit easier
27:38 - to switch between the different views
27:40 - and i'm going to use that quite a bit
27:42 - but alright
27:43 - in here we can see a couple of examples
27:46 - godot provides
27:48 - and let me actually get rid of this part
27:50 - down here but we are going to come to
27:52 - that later on
27:53 - so what you see here right now is that
27:55 - you can declare a member variable
27:58 - and a variable in essentially any
27:59 - programming language is a box that you
28:01 - can store information in
28:04 - and this can be either a number like the
28:05 - number two or it could be text
28:08 - and text is usually called a string and
28:10 - a number without a decimal is called an
28:12 - integer so these are different data
28:14 - types although that really isn't too
28:17 - much at this stage if you're new to
28:18 - programming
28:19 - but okay let me get rid of all of this
28:21 - because we don't need it
28:23 - so just to get it started i want to
28:25 - create one variable
28:26 - so i use the keyboard var and now i have
28:30 - to give the variable
28:31 - a name and i want to go with speed
28:34 - because i want to use this variable to
28:35 - determine how fast our player can go
28:38 - and i need to assign it a value and this
28:40 - is done with the equal sign
28:42 - and now i have to type a number how fast
28:44 - i want my player to be
28:45 - and i want to go with 400 and i've
28:48 - chosen this number by just trial and
28:50 - error
28:50 - so if you play around with this later on
28:52 - there are lots of different options
28:53 - there's no universal one just choose
28:55 - whichever one looks best
28:57 - but all of this is still just a number
29:00 - it doesn't actually do anything in our
29:01 - game
29:02 - and to actually do stuff in our game we
29:04 - need a function
29:06 - and a function is really just a
29:08 - collection of different lines of code
29:10 - that you all execute as one block and
29:13 - usually for a function you have two
29:15 - steps you first have to create a
29:16 - function
29:17 - and then you have to call the function
29:19 - and this basically means that you first
29:20 - have to create your code of block
29:22 - and then you have to use the code of
29:24 - block in specific spots where you want
29:26 - to use it
29:27 - in godot this is slightly different that
29:29 - you have two different kinds of
29:31 - functions
29:32 - you still have the normal functions that
29:33 - you have to create and call yourself
29:36 - but you also have inbuilt functions and
29:39 - these functions you only have to create
29:41 - you don't have to call them yourself
29:43 - because godot is going to call them at
29:44 - specific points in your game
29:46 - so for example we have a ready function
29:49 - and this function is always going to be
29:50 - executed
29:51 - when our scene is ready or there would
29:53 - be an input function
29:55 - that is always executed when we get
29:56 - player input so for these functions
29:59 - godot determines when they are being
30:00 - executed
30:01 - which is really useful for your game and
30:04 - for our player
30:05 - we actually do want to start with an
30:07 - inbuilt function and really what we want
30:09 - is to have a function that is being
30:11 - executed on every single frame of our
30:13 - game
30:14 - so essentially a function that runs
30:15 - constantly
30:17 - and godot has two of them they are
30:19 - called process
30:20 - and physics process and those two
30:23 - functions
30:24 - are incredibly similar and you don't
30:26 - have to worry about the differences in
30:27 - too much detail
30:28 - yet at least for this stage just keep it
30:31 - at
30:32 - process is usually used when you don't
30:34 - care about physics and physics process
30:36 - is being used when you really want to
30:37 - calculate physics calculations
30:40 - which in our case we do want to do so we
30:42 - are going to use that function
30:44 - but again lots of theory let's actually
30:47 - get back into our code editor and let's
30:48 - implement this so here i'm back in my
30:50 - code editor
30:51 - and let me go to a new line and to
30:54 - create a function
30:55 - we need to func keyword and now we need
30:57 - the name of our function
30:59 - and in my case this is physics process
31:04 - and into this function you can pass what
31:06 - is called an
31:07 - argument and godot by default passes in
31:09 - an argument in here that's called delta
31:12 - and all an argument really does is when
31:14 - you're executing a function
31:15 - is that you can tweak the parameters so
31:17 - this one can be useful to find tweak
31:19 - what the function is doing
31:21 - and what delta does in godot is that it
31:23 - makes sure that the game always runs at
31:25 - a consistent speed
31:26 - which isn't something you have to worry
31:28 - at this stage in too much detail
31:30 - so i would recommend to just ignore it
31:32 - at least for now all right
31:34 - if you press enter now godot is going to
31:36 - go to the next line and it's going to
31:37 - indent the next line
31:39 - and this indentation is really important
31:41 - it means that whatever code is below
31:43 - and indented in this function belongs to
31:45 - the function
31:46 - so further down the line if you created
31:48 - more code below this function that is
31:50 - not indented it would mean it doesn't
31:51 - belong to the function
31:53 - but now in this function we have to give
31:55 - our player the ability to move around
31:58 - and to move around we are going to need
32:00 - three different steps
32:02 - number one is that we actually need
32:03 - player input so that we check if the
32:05 - player is pressing up or down in my case
32:07 - but could be any kind of input
32:09 - number two is that we are storing this
32:11 - input and number three
32:13 - is that we're actually applying this
32:15 - input to our player
32:16 - and let's go through this step by step
32:18 - and before getting to the input
32:20 - i do want to start with some kind of
32:22 - variable that can store the user input
32:24 - and i'm going to use a vector and if you
32:27 - paid attention in high school you
32:29 - might remember a vector but vectors are
32:31 - generally useful
32:32 - in game development and really important
32:35 - and fortunately they're also
32:36 - quite easy a vector is essentially an
32:39 - arrow that can point in different
32:40 - directions and
32:42 - what we want is that by default we have
32:44 - a vector that doesn't point in any
32:45 - direction
32:46 - but if we're pressing the up key we want
32:48 - it to point upwards and if we're
32:49 - pressing the down key we want to point
32:51 - downwards
32:53 - and that's really all we need so let's
32:55 - actually create
32:56 - this so here i'm back in my code and i
32:59 - want to create a new variable
33:00 - so again i need the var keyword and now
33:03 - i have to give this variable
33:04 - a name and usually this one is called
33:07 - velocity
33:09 - which i am remarkably bad at spelling
33:12 - for some reason my brain just can't get
33:13 - around it
33:14 - all right now we want to create a vector
33:16 - and for that we just need the vector
33:18 - keyword
33:19 - and godot now asks us do we want a 2d
33:21 - vector or a 3d vector
33:23 - and since we have a 2d game we want a 2d
33:25 - vector
33:26 - and now when you press a dot you can
33:28 - access its attributes
33:30 - so what the arrow is pointing at by
33:32 - default and what i want to go with
33:34 - is 0 all in uppercase letters
33:37 - and this means that by default this
33:39 - vector is 0
33:40 - 0 so it doesn't point in any direction
33:43 - it's just the point in space
33:45 - although we can influence this and that
33:47 - actually comes now because now we're
33:49 - getting keyboard input
33:50 - and for keyboard input we need a
33:52 - specific keyword that is called
33:54 - input and here again we need a dot sign
33:58 - to use a specific part of this input so
34:01 - the input
34:02 - is essentially a large object it has
34:04 - lots of different functions that you can
34:05 - all access with a dodge
34:07 - and the one we want to access is called
34:10 - is
34:11 - action pressed
34:14 - and all this does is it checks for
34:16 - specific keys
34:17 - and here you have a list that i
34:18 - predefined but you could create your own
34:21 - and what i want to look for is ui up
34:23 - which is the up key on your keyboard
34:25 - so if i click on this we have it as an
34:28 - argument inside of this function and
34:31 - this is actually bringing us to a new
34:32 - data type
34:33 - and that is a boolean and booleans can
34:35 - either be true
34:36 - or false so in our case if we were to
34:39 - run this game and we press the up key
34:41 - this entire line would signal that
34:43 - something is true and if we don't press
34:45 - the up key it would be false
34:47 - and to actually use this in code we need
34:49 - an if statement
34:51 - so that if all of this is true we want
34:53 - to do something
34:54 - and else we don't want to do that and
34:57 - then to finish this line
34:58 - we need a double colon and now when i
35:00 - press enter again
35:02 - we again start on an indented line so
35:04 - this means that anything that comes
35:05 - below
35:06 - is only being executed if this line is
35:09 - true
35:09 - so if we are pressing the up key and if
35:12 - that is the case
35:13 - we want to target our velocity again so
35:16 - here be aware
35:17 - in here we are creating velocity and
35:20 - here we are using velocity
35:22 - so you only have to create a variable
35:23 - once once you have done that
35:25 - you can just use the keyword and work
35:27 - with it and
35:28 - a velocity has an x and a y attribute
35:31 - that you can influence
35:32 - with x being the horizontal one and y
35:34 - being the vertical one
35:35 - so we want y because we want to go up
35:37 - and down and all we have to do in here
35:40 - is to change this number to a different
35:42 - number so it's pointing in a certain
35:44 - direction
35:45 - so i want to take this value and
35:46 - subtract one from it which happens with
35:48 - minus equal and one
35:51 - so this kind of operation is really
35:53 - common in programming languages
35:55 - it basically means we're taking this
35:56 - value and subtracting one from it
36:00 - so this would be the same as velocity
36:02 - dot y
36:03 - equals velocity
36:07 - dot y minus one these two lines
36:10 - do exactly the same thing except this
36:13 - one is quite a bit faster to write
36:16 - okay and this is all we need for this
36:19 - one line to move the player upwards
36:20 - but obviously we also want to go
36:22 - downwards
36:24 - and here again if you want to challenge
36:25 - yourself pause the video now and try to
36:27 - implement the code for the down movement
36:30 - but to do it all you have to do is to
36:31 - copy this line
36:34 - or really type it yourself it doesn't
36:35 - matter and now instead of looking for ui
36:38 - up we want to go for ui
36:41 - down and in here instead of subtracting
36:44 - 1 we want to
36:45 - add one and this is something that might
36:47 - be weird to you right now
36:49 - that if you want to go up we have to
36:51 - subtract from y
36:52 - and if you want to go down we have to
36:54 - increase y
36:56 - which is going to be really strange if
36:58 - you paid attention in high school
36:59 - so let me explain in high school when
37:02 - you saw a coordinate system
37:04 - it always started in the bottom left so
37:06 - if you went to the right you have to
37:08 - increase
37:08 - x if you want to go up you have to
37:10 - increase y which
37:11 - tends to make sense in most video game
37:14 - developments this is slightly different
37:16 - because the origin point is in the top
37:18 - left meaning that if you want to go to
37:20 - the right
37:21 - you still have to increase x this one
37:23 - stays the same however
37:25 - if you want to go down you have to
37:27 - increase y and if you want to go up you
37:29 - have to decrease y
37:31 - which is honestly really
37:33 - counter-intuitive and is going to take
37:34 - you some time to get used to
37:36 - but it just became the standard in quite
37:38 - a lot of engines i have no idea why but
37:41 - you will get used to it eventually
37:42 - so don't worry about it too much but
37:45 - with all of that covered
37:46 - we have the two first steps to get input
37:49 - we have code to get input from the
37:51 - player
37:51 - and we can store the input now we just
37:54 - have to apply this input to our player
37:57 - and this happens with the move and slide
37:59 - function
38:00 - so i type move and slide
38:04 - and in here godot already gives us some
38:06 - hints in terms of what it needs
38:07 - and the first argument it wants in here
38:10 - is a linear velocity
38:12 - which we have it's our velocity
38:16 - and well that's all we needed so let me
38:19 - save this entire thing now
38:20 - and let me run this scene by clicking
38:22 - again on this icon at the top or
38:24 - pressing f6
38:26 - and now we can see our player and let me
38:28 - move up
38:30 - and we can see that our player is moving
38:32 - up just very very slowly
38:35 - and that's for a good reason let me
38:37 - close this again
38:38 - because we are only moving it by one
38:40 - unit but we want to move it by this
38:43 - 400 and so all we really need to do
38:46 - is to multiply this one by 400
38:49 - so when we call this move and slide
38:52 - function we just multiply velocity
38:54 - by our speed and now if i run this again
38:57 - by pressing f6
38:59 - now we can move up and down this feels
39:01 - so much better
39:04 - okay and there was a ton of theory in
39:06 - this part of the video
39:08 - so i think it's good for this section so
39:11 - let's talk about creating our level
39:14 - for now our entire game consists of a
39:16 - single scene and that's the player scene
39:19 - but obviously this is quite limited
39:21 - because we want to have other elements
39:23 - in our game as well we want to have a
39:25 - ball and the opponent at the very least
39:27 - and each of them is going to be their
39:29 - own scene but we have to bring all of
39:31 - them together into one big scene
39:33 - and this is going to be the level scene
39:35 - where we actually going to create our
39:37 - game logic
39:38 - and our level doesn't actually have to
39:40 - do all that much it's quite a simple
39:42 - thing
39:43 - it really only has to carry all the
39:44 - other scenes and have
39:46 - a bit of extra code to reset the ball
39:48 - for example or to limit the movement of
39:50 - the player
39:51 - so let's actually go right in and let's
39:53 - create this so
39:55 - here i'm back in my game and what i want
39:57 - to do is to click on this plus icon
39:59 - and create a new scene and
40:02 - we are still in the code view so i go
40:04 - back to 2d and here we can again
40:06 - see our 2d space and now we have to
40:10 - determine what kind of node do we want
40:13 - and in this case you could go with a 2d
40:15 - scene
40:16 - but you don't really need it so i'm
40:18 - going to go on other node
40:20 - and i'm going to just click on node
40:22 - which is the base class for all scene
40:24 - objects
40:25 - which is a fancy way of saying this node
40:27 - is a really basic node that can't really
40:29 - do anything by itself
40:30 - and let's click on create so now we have
40:34 - a node
40:35 - and let me rename it to level right away
40:38 - and if you look into the inspector you
40:41 - can't really see anything
40:42 - so we have pause and script but they
40:44 - don't do much
40:46 - so this note is so basic it doesn't
40:49 - really have any attributes
40:51 - so it can't do all that much but it is
40:54 - really useful to organize your code so
40:56 - you can put other nodes connected to it
40:58 - and this is what i want to do i want to
41:00 - connect our player scene
41:01 - to this level node and for that we have
41:04 - to instance
41:05 - our player into this new scene
41:08 - and let me actually save it before we do
41:10 - anything so right now when you look at
41:12 - the tab it says unsaved
41:13 - so i press on control or command s and
41:16 - here again we can see our folder
41:18 - and i want to create a new folder that
41:21 - i'm going to call
41:22 - level and in here i want to save
41:26 - this scene as level scene because our
41:28 - root node
41:29 - is called level so click on save and now
41:32 - we have our level scene
41:34 - and now with this level selected click
41:36 - on this
41:37 - chain icon and this is the instancing
41:40 - icon
41:41 - and if you click on this you can see all
41:43 - of our scenes we have a level scene
41:45 - and we have a player scene and we want
41:46 - to play a scene so i click on open
41:49 - and now we can see our player scene
41:51 - inside of our level
41:54 - and it is still going to have the same
41:55 - capabilities so if we were to run this
41:58 - scene now
41:59 - our player character would still work in
42:01 - exactly the same way
42:02 - and let's actually try this so again i
42:05 - press on f6
42:07 - and now we have the very same thing even
42:09 - though we have a different scene
42:11 - so now we're running the level scene not
42:13 - the player scene but the player scene is
42:15 - part of the level scene
42:18 - okay cool so this works quite well
42:21 - and now we can actually add more useful
42:23 - stuff to this
42:25 - and the very first thing i want to add
42:27 - is that let me run the game again
42:30 - if i go up and down we can move outside
42:33 - of the screen
42:34 - which well is unintentional
42:37 - so we want to add something that the
42:39 - player can't go outside of the screen
42:41 - and there are different ways to achieve
42:42 - this but before work on this
42:44 - i do want to work on how large our game
42:46 - is supposed to be
42:48 - so let me close this so right now here
42:50 - our game has the size of this blue
42:52 - rectangle
42:53 - and we can influence how large this is
42:55 - going to be
42:56 - and to influence this you have to go all
42:58 - the way to the top to project
43:00 - and project settings and in here you
43:03 - have all the settings for the project
43:05 - and if i go down a little bit there we
43:08 - have display
43:10 - and window and in here we can change the
43:12 - width
43:13 - and the height of our window and by
43:15 - default this is always 1024 by 600
43:19 - and you can't leave it at that it's
43:20 - perfectly fine but i feel like 1280 by
43:24 - 720 tends to feel a bit better
43:27 - but it's really up to you you can also
43:30 - change if it's resizable or borderless
43:32 - or full screen
43:32 - it's really up to you play around with
43:34 - this but for now i'm not going to worry
43:36 - about screen scaling in any meaningful
43:38 - way
43:39 - so i'm just going to close it and now we
43:42 - can see that our blue box has increased
43:44 - in size by quite a bit
43:47 - and if we were to run this game we'd
43:49 - also see it is quite a bit larger now
43:53 - so we know this is working good start
43:57 - but now the actual important part we
43:59 - want to limit our player from moving
44:01 - outside of the screen
44:03 - and we can approach this in two
44:04 - different ways
44:06 - one is that we can give our players some
44:08 - code that it can't move outside of the
44:10 - screen
44:11 - or number two we could use another
44:13 - physics body to limit the movement
44:15 - so so far we have seen a kinematic body
44:17 - we can use another physics body at the
44:19 - border of our screen that the player
44:21 - would collide
44:22 - with and those would basically be walls
44:24 - and since for our ball
44:25 - we also want to use walls i am going to
44:28 - go with the second approach
44:29 - so we have walls that limit our player
44:31 - our opponent and also make our ball
44:33 - bounce
44:34 - so we have lots of functionality and one
44:36 - object which is really nice
44:37 - and for that we have to talk about
44:38 - another physics object in godot
44:41 - which is called the static body 2d and i
44:44 - think the name already explains it
44:45 - quite well it's well a static body that
44:48 - can't move by itself
44:50 - so it is essentially a wall and that is
44:54 - really it it's just a physics body that
44:55 - can't move by itself
44:57 - but if other objects move against it
44:59 - they will be influenced by its physics
45:01 - and static body 2ds also work like a
45:04 - kinematic body 2d
45:05 - that you start with a single note that
45:07 - has the physics and then you have to
45:08 - give this note a shape
45:10 - so let's actually create all of this so
45:12 - here i'm back in my level scene
45:14 - and with the level note selected i want
45:16 - to add another node
45:18 - that is going to be a static body and
45:20 - here again you have a static body in 3d
45:23 - and a static body in 2d and i want to go
45:25 - with 2d
45:26 - so i click on create and here again we
45:29 - have a static body 2d
45:31 - and we are getting an error message that
45:33 - this note has no
45:34 - shape so let's give it one so with this
45:37 - note selected
45:39 - and not the text i'm going to click on
45:41 - the plus icon
45:42 - and i want to give it a collision
45:46 - shape this one down here
45:50 - so click on create and still we can't
45:53 - see anything we get another error
45:54 - message again
45:55 - that we have to provide a shape and this
45:58 - happens again
45:59 - in the inspector and here i just click
46:02 - on whatever shape i want
46:03 - and i think again we want to go with a
46:05 - rectangle shape 2d
46:07 - because well the wall doesn't need any
46:09 - fancy shape a rectangle is fine
46:11 - so i click on this and now we have
46:15 - a wall that the player couldn't collide
46:17 - with and let me actually demonstrate
46:19 - this
46:20 - so i'm going to drag this out a bit and
46:23 - move it
46:23 - let's say here so when we run our game
46:27 - we should not be able to move past this
46:29 - point
46:31 - so i save the game and press f6 again
46:34 - to launch it and let's move up and
46:37 - indeed i can't move
46:38 - further up than this point so this is
46:41 - working
46:42 - but obviously we want to be limited by
46:44 - the top of the screen
46:45 - so we have to change all of this and
46:48 - move this entire shape
46:50 - to the top of this blue line and let me
46:53 - zoom in
46:53 - quite a bit if we want to be right on
46:56 - this
46:57 - blue or red line and to be more
47:00 - fine-grained you can also use the arrow
47:01 - keys
47:02 - and move it up or down or you could use
47:04 - transform
47:05 - and use it here let's actually go with
47:07 - that so i have transform open
47:10 - and i also click on rectangle again so
47:12 - now we can see the dimension
47:13 - and the position and all we need to do
47:15 - is to change this to
47:17 - -10 and this is going to bring us
47:19 - exactly 10 units from the top of the
47:21 - screen
47:22 - and now we want to have this static body
47:24 - cover the entire top part of the screen
47:26 - so i'm just dragging it out and this
47:29 - would be fine
47:30 - or if you want to be a bit better
47:33 - looking for the game
47:34 - you can also move it to the middle and
47:37 - have the size
47:38 - a bit more appropriate for it
47:42 - so it doesn't move massively outside of
47:44 - it and
47:46 - yeah i think this looks about right and
47:49 - here
47:49 - if you look at our scene tree now we
47:51 - have a bit more of a complex structure
47:54 - we have a root note the level we have
47:56 - one child that's the player
47:57 - and we have a static body that's also
47:59 - child of the level node
48:00 - but now this static body 2d has its own
48:04 - child which is the collision shape 2d so
48:06 - if we were to move this static body
48:08 - we would move the collision shape 2d but
48:11 - if we move the level
48:12 - we would move both the static body 2d
48:14 - and the collision shape because they are
48:15 - both children of the level node
48:18 - ok let me rename this one to wall
48:21 - top and then you can minimize it which
48:24 - makes it easier to work within your game
48:27 - and this is giving us our turbo so let's
48:30 - try this by running our game
48:32 - and i can move all the way to the top of
48:34 - the screen but not further
48:35 - so this is working quite well cool
48:39 - so now we have to create a wall at the
48:40 - bottom of our screen
48:42 - and here again if you want to challenge
48:43 - yourself pause the video now and try to
48:45 - do this yourself
48:48 - but effectively all you have to do is to
48:50 - copy
48:51 - this entire wall top by pressing ctrl d
48:55 - and let me rename it right away toward
48:58 - the bottom and then you can just drag
49:02 - the entire thing down and here again you
49:05 - can see that i'm moving the collision
49:06 - shape
49:07 - not the static body although in this
49:09 - case it wouldn't matter too much because
49:12 - this collision shape is what actually
49:13 - matters
49:14 - but it doesn't feel good so with the
49:16 - wall bottom selected
49:18 - i'm going to click on this icon again
49:20 - that we cannot select the children
49:22 - and now i can move the static body down
49:26 - and let me zoom in again and i want to
49:29 - roughly move it at the bottom of the
49:31 - screen
49:32 - or if you want to be really precise
49:34 - about this you could also move it
49:36 - to 740
49:44 - and okay this is all we needed
49:48 - and let me change the same thing so it's
49:50 - all consistent
49:51 - and let's run the game now and i can't
49:54 - move to the top and i can't leave the
49:56 - screen from the bottom so this is
49:58 - working quite well
50:00 - cool and we
50:03 - are making some decent progress
50:06 - and with that one done let's start by
50:09 - creating our opponent
50:10 - and the opponent is actually done in a
50:12 - really similar way compared to our
50:14 - player
50:15 - as a matter of fact it is going to have
50:16 - the same notes it is just going to have
50:18 - some slightly different code
50:20 - so instead of using keyboard import to
50:22 - move this one we are going to make this
50:24 - one
50:24 - move to wherever the ball happens to be
50:27 - but this part will come later when we
50:29 - actually have a ball
50:30 - for now let's just create a basic
50:32 - opponent
50:33 - so here again we are in our level scene
50:36 - and i want to create a new scene for the
50:38 - opponent
50:39 - so i click on the plus icon at the top
50:41 - to add a new scene
50:42 - and here we have the scene and what we
50:45 - want to do
50:46 - is to basically copy this player scene
50:49 - and do the same thing except for the
50:51 - code and this again could be a challenge
50:53 - if you want to code along
50:54 - pause the video now and try to recreate
50:56 - our player but let me go through it
50:59 - i want to start with another note that
51:01 - is going to be a
51:02 - kinematic body 2d
51:06 - and this time i guess that's one
51:07 - difference i want to name this
51:10 - opponent and again we're getting the
51:13 - warning
51:13 - but i'm going to ignore it for now
51:15 - because i want to start by adding the
51:16 - picture
51:17 - so i click on this plus icon and i type
51:19 - in sprite
51:21 - and i'm going to add the sprite and here
51:24 - again we're going to use our assets
51:26 - and the pedal it is the same as the
51:27 - player has
51:29 - and here now we have an opponent that is
51:32 - a kinematic body
51:33 - and a sprite now i want to add our
51:36 - collision shape
51:38 - so here you could add a collision shape
51:40 - 2d
51:41 - and this works just like for the player
51:44 - you can add a rectangle shape 2d
51:46 - and move it roughly in place to where
51:49 - this needs to be
51:50 - [Music]
51:52 - something like this
51:56 - so yeah i think this looks good and just
51:59 - for completion's sake
52:00 - what he could also do so let me just
52:03 - hide this one for
52:04 - now you could also use a collision
52:07 - polygon 2d
52:08 - this one works in basically the same way
52:11 - except now
52:12 - you cannot select a pre-built shape
52:14 - instead at the top of the screen you can
52:16 - see
52:16 - these three icons that says create
52:19 - points
52:20 - edit points and delete points or erase
52:22 - points
52:23 - and what you basically do with a
52:24 - collision polygon is you are creating
52:27 - your own
52:27 - shape so when i click on create points
52:30 - i can literally just put points on the
52:34 - screen
52:35 - so if you have a more complex shape this
52:37 - one would be quite easy
52:38 - and then if you're at the last point
52:40 - just click on enter and then it finishes
52:42 - the shape
52:42 - so now we also have a square shape but
52:45 - this shape could be any point
52:47 - so if you added points you could create
52:50 - something
52:50 - much more complex but in my case
52:53 - i well don't need to so i'm happy
52:58 - by just using a collision shape because
52:59 - this one is much easier and we don't
53:01 - have any fancy shapes
53:03 - and yeah that's literally all we needed
53:07 - so now i'm going to save this entire
53:09 - scene in its own folder
53:11 - that i'm going to call opponent and
53:14 - again it's already named appropriately
53:16 - so i click on save
53:18 - and this is our opponent so now this i
53:21 - can also put into our level scene
53:23 - and here again i have the level note
53:25 - selected i click on the chain icon to
53:27 - instance it
53:29 - and put an opponent and now
53:32 - move opponent roughly in place
53:36 - okay this looks good so now let me save
53:39 - this level scene
53:40 - and run the entire thing we can see
53:43 - that we have two pedals and we can only
53:45 - move our player our opponent is not
53:47 - moving and we don't have a ball but that
53:48 - comes later
53:50 - but i think we're making decent progress
53:52 - there's two more things i would like to
53:54 - add though
53:55 - number 1 is to make this level scene our
53:58 - default scene
54:00 - so right now we have always only played
54:02 - a single scene
54:03 - and this happened with f6 but what we
54:05 - can also do
54:06 - is run the entire game as a whole and
54:09 - our game consists of different scenes
54:11 - but by default godot does not know which
54:13 - is the default scene it needs to start
54:15 - for the game
54:16 - and this we have to define ourselves
54:20 - and all this really means is when you
54:21 - click on f5
54:23 - udo is going to ask you that no main
54:25 - scene has been defined do you want to
54:27 - select one
54:27 - and we do so click on select and
54:31 - here we would have all of our folders
54:33 - and i want the level scene to be the
54:34 - main scene
54:35 - so i click on level scene and now we can
54:39 - see our level again
54:41 - and now even if we were in our player
54:43 - scene
54:44 - i could press f5 and i could start the
54:47 - actual game
54:47 - how it's supposed to be looking when
54:49 - it's actually being played so this one
54:51 - makes it easier to launch games
54:53 - but okay let me close the player and the
54:55 - opponent scene
54:57 - closing them doesn't mean you delete
54:58 - them you can still open them from the
55:00 - file system
55:01 - so down here so down here you can just
55:05 - double click on the player
55:06 - scene and reopen it
55:09 - all right the last thing for the level
55:11 - is that this gray background looks
55:13 - absolutely hideous so i want to change
55:15 - it
55:16 - and to change it we have to add another
55:18 - note so with level selected
55:20 - i'm going to click on the plus icon
55:22 - again and i want to add
55:24 - a color rect
55:28 - which is well it's a colored rectangle
55:31 - kind of like the name implies
55:32 - so i click on create so now we have
55:35 - this colored rectangle in the top of our
55:37 - screen and let me zoom in a little bit
55:40 - so here you can see the color and you
55:43 - can influence the color here
55:45 - and i will talk about this in just a
55:46 - second but
55:48 - for now what you do have to be aware is
55:50 - that when you look at the color of this
55:52 - note
55:52 - it's green and this means that it's a ui
55:55 - note
55:55 - so godot essentially has four different
55:57 - kinds of notes we have the blue ones
55:59 - those are 2d notes then we have the red
56:01 - ones those are 3d nodes
56:03 - then we have the green ones those are ui
56:05 - nodes and then we have all the other
56:06 - nodes
56:07 - like the plane node for example is just
56:09 - another node it doesn't really have a
56:10 - specific group
56:13 - and ui nodes have a couple of specific
56:16 - parts that are really powerful
56:18 - and effectively what they can do is be
56:20 - really responsive to the size of the
56:21 - window
56:22 - so you can always make sure they're for
56:24 - example in the middle of the screen
56:25 - always cover the entirety of the screen
56:28 - which in our case isn't going to matter
56:30 - too much because the game isn't designed
56:32 - to be resizable
56:33 - although we could add that later on but
56:35 - we could for example make it cover the
56:37 - entire screen
56:38 - really easily let's actually do this so
56:40 - here we are back in our editor
56:42 - and with the color rect selected at the
56:45 - top you can see
56:46 - these two green icons that say layout
56:48 - and then you have this
56:49 - anchor kind of icon and if you click on
56:51 - layout
56:52 - you have lots of different options and
56:55 - what you can click
56:56 - is full rect and then this rectangle is
56:58 - immediately covering the entire screen
57:01 - and right now it's covering everything
57:03 - even our players which we don't want
57:05 - so i'm going to move this color direct
57:08 - above
57:08 - all the other elements so it's below
57:10 - them
57:12 - so now we can see our player and our
57:13 - opponent again
57:16 - and here you would have a couple more
57:18 - elements that we are going to see in a
57:19 - bit more detail later on
57:21 - but for now just be aware that ui
57:23 - elements have lots of options to arrange
57:26 - elements on the screen but okay now
57:29 - the white color doesn't look too good so
57:32 - we have to give it a different color
57:35 - and here we have quite a few different
57:37 - options in terms of how we are going to
57:39 - work with color
57:40 - we have rgba numbers we have hsv we have
57:43 - raw
57:43 - and we have hexadecimal numbers and
57:46 - every single one of them
57:47 - are a different way to create a color
57:49 - what we are going to use
57:51 - is the hexadecimal number which is the
57:53 - one down here
57:54 - and the number i want is 14
57:58 - 21 and 26 and now if i press enter
58:02 - we get a dark color and let me explain
58:05 - how this works
58:06 - hexadecimal number always consists of
58:08 - six different numbers that follow a
58:10 - hashtag
58:11 - and the first two ditches define the
58:12 - amount of red the third and the fourth
58:14 - digit determine the amount of green
58:16 - and the last two digits determine the
58:18 - amount of blue so the higher the number
58:20 - gets
58:20 - the more amount of this color we have
58:23 - and
58:24 - the way we are counting a hexadecimal
58:25 - number is going to look a little bit
58:27 - weird
58:28 - because we're counting from zero to one
58:30 - and then from
58:31 - a to f so basically goes one two three
58:34 - four five six seven eight nine ten
58:36 - a b c d e and f so there are 16
58:39 - different stages that you can have
58:41 - and then you have three different colors
58:42 - and you essentially mix them
58:45 - and i hope that makes sense okay
58:48 - with that we have our background color
58:51 - so now when i press f5
58:53 - this does start to come together and
58:55 - look quite decently
58:56 - so with all of these parts covered let's
58:59 - actually start talking about how to
59:00 - create our ball
59:02 - so our ball is going to be the most
59:04 - complex object
59:05 - in the entire game which basically means
59:08 - it's going to be the object with the
59:09 - most amount of code
59:10 - but in terms of notes our ball is
59:13 - actually going to be remarkably similar
59:14 - compared to the player and the opponent
59:16 - we will still start with a kinematic
59:18 - body2d add an image
59:20 - and add a collision shape and i think
59:23 - you really start to notice that there is
59:24 - a pattern
59:25 - that most objects in godot work in
59:28 - really similar ways
59:29 - that you always have some kind of
59:30 - physics node then you add a picture
59:33 - and then you add a collision shape and
59:35 - this can be more complex for example the
59:37 - image could be an animation
59:39 - or the collision shape could be more
59:40 - complex but really at the most basic
59:43 - level
59:43 - most objects in godot work really
59:45 - similarly so it's really easy to create
59:47 - them
59:49 - so let's start to create our ball so
59:52 - here we're back in our editor
59:53 - and i want to create a new scene
59:57 - and again i'm going to pick another note
59:59 - and here again i'm going to pick
60:01 - kinematic body 2d and i'm going to
60:04 - rename this one to ball
60:07 - and i'm going to add the sprite
60:10 - and i am going to add a collision
60:13 - shape 2d and for the sprite
60:17 - this time i'm going to go to my assets
60:20 - and add the ball
60:22 - and then for the collision shape let me
60:24 - zoom in a bit
60:27 - i am going to pick a circle shape 2d
60:31 - this time
60:32 - because now we have a circle we don't
60:33 - have a rectangle anymore
60:35 - and in here now we only have one red dot
60:38 - because a circle is a bit of an easier
60:39 - shape
60:40 - and i'm just going to drag out this red
60:42 - dot to make sure
60:43 - this circle roughly matches our ball
60:47 - and that's all we needed so now let me
60:50 - save this
60:51 - in a new folder that i call ball
60:56 - and save this as ball dot scene cool
61:01 - and now i go back to my level scene
61:04 - and instance the ball into it
61:07 - now we can see the ball on the top of
61:09 - the screen and let me move it roughly in
61:10 - the middle of the screen
61:12 - at least for now and that's all we need
61:16 - for the basic ball so if we run the game
61:17 - now by pressing f5
61:19 - we can see all the very basic elements
61:21 - of our game
61:22 - so that's a pretty decent start
61:25 - so now we can close this game for now
61:28 - and
61:29 - now we actually have to make our ball
61:30 - move and that's going to be the more
61:32 - complex part
61:34 - so let's go through it step by step with
61:36 - the ball selected i'm going to create a
61:38 - new script
61:39 - and here again we have all the same
61:40 - options except this time i want to start
61:42 - with an
61:43 - empty template but the folder is still
61:46 - fine so i click on create
61:48 - and here now we're starting with
61:50 - completely empty code
61:51 - except that our code extends a kinematic
61:53 - body to d so this one is fine
61:56 - and here again i want to create a couple
61:58 - of basic variables that are going to be
62:00 - important for our ball
62:01 - and the first one is going to be the
62:02 - speed of the ball so speed
62:06 - equal to let's say
62:09 - 600. again you can play around with this
62:11 - value it just determines how fast the
62:13 - ball is going to be
62:15 - and another important thing let me open
62:18 - my player script again so on the left
62:21 - you can see all the open scripts and if
62:22 - you go to the file system and click on
62:24 - player.gd for example
62:26 - you could open the old script and right
62:28 - now what we have is that our player
62:30 - has a speed variable and our ball has a
62:33 - speed variable
62:34 - and that's fine each of these nodes has
62:36 - its own scope
62:37 - meaning that you can have a variable
62:39 - name speed for the ball and the variable
62:41 - name speed for the player and even the
62:42 - variable name speed for the opponent
62:44 - that's perfectly fine it doesn't matter
62:46 - if they have the same name
62:48 - so this was a good start and then
62:51 - this time i want to create a velocity
62:55 - vector again
62:57 - and this one again is going to be a
62:59 - vector
63:00 - 2 dot zero so an arrow that doesn't
63:03 - point in any particular direction
63:06 - and here do know the difference that for
63:08 - our player
63:10 - we created this velocity inside of the
63:11 - physics process
63:13 - whereas for the ball we are creating it
63:15 - outside of it
63:16 - and there's a specific reason that you
63:18 - are going to see in just a second
63:20 - actually right now so the reason we have
63:23 - to define velocity outside of a function
63:25 - is because we want to use it in lots of
63:27 - different functions
63:28 - so what i effectively want to do is when
63:31 - our ball is ready
63:32 - i want to change this vector 2.0 to a
63:35 - specific direction
63:36 - and then i want to use this direction in
63:38 - the actual game in the physics process
63:40 - so we couldn't define this velocity
63:42 - inside of a function
63:44 - because we want to use it across
63:45 - multiple functions
63:47 - oh yeah and this is something i haven't
63:48 - mentioned before so let's say open the
63:50 - player again
63:51 - if you create a variable inside of a
63:52 - function this variable is only available
63:55 - inside of this function
63:57 - so this velocity here is only going to
63:59 - be available
64:00 - inside of this physics process function
64:03 - so we couldn't use it outside of it
64:05 - but in this case it's fine because we
64:07 - don't need it outside of it
64:08 - and helps to keep our code clean but in
64:11 - case of this ball velocity
64:13 - we do need to use it in different
64:15 - functions so it's important to define it
64:17 - outside of a function
64:19 - okay cool so now when our ball is ready
64:23 - we want to give it a random direction so
64:26 - we first have to run a function that
64:28 - only runs when our ball is ready
64:30 - and i talked about this a tiny bit
64:32 - earlier it's called the ready function
64:34 - and remember the underscore that one is
64:36 - quite important
64:38 - and use the double colon again and now
64:40 - we are indented in the line
64:43 - so any code we put in here is only going
64:45 - to run once when the ball
64:47 - scene is ready and what i want to do
64:50 - is to target velocity and now target
64:53 - the x attribute of it and now i want to
64:56 - give it a random number
64:58 - and this is a topic we haven't covered
65:00 - yet in godot how to create
65:01 - random numbers and there are a couple of
65:04 - different ways
65:05 - and to get to a random number we
65:07 - actually have to cover a couple of
65:09 - different concepts
65:10 - so i think the best way to go on about
65:12 - this is to first write the line and then
65:14 - explain how the line works
65:16 - so let me write the entire thing
65:24 - [Music]
65:27 - okay so this line is probably going to
65:30 - look
65:30 - really confusing so let me go through it
65:32 - step by step
65:34 - and there's actually going to be a new
65:35 - kind of data type we have to talk about
65:37 - so we are starting the entire thing with
65:40 - square brackets where we have minus one
65:42 - and one and this is called an array and
65:45 - an array is basically just a list
65:47 - so in this array we have two numbers
65:49 - that are minus one and
65:51 - one you store different numbers inside
65:53 - of a list
65:54 - so it's kind of comparable to a shopping
65:56 - list and this allows us to store
65:58 - different values inside of a single data
66:00 - type so this can be quite useful
66:02 - so basically what we have right now is a
66:04 - box with two values inside
66:05 - minus one and one and essentially what
66:09 - we are doing with the other square
66:10 - brackets is to pick one of these numbers
66:12 - at random and this process is called
66:15 - indexing
66:16 - that after you're putting square
66:17 - brackets after an array and put an
66:19 - integer inside of it
66:20 - you are picking a specific value from
66:22 - this array with a number zero picking
66:24 - the first element
66:25 - and number one picking the second
66:27 - element and so on
66:29 - and be aware here that the first element
66:31 - in an array is always the number
66:32 - zero but we want to pick a random
66:35 - integer
66:36 - and for that we have the function rand i
66:39 - and
66:40 - rand i generates a random integer but by
66:43 - default it generates a random integer
66:44 - across an infinite range
66:46 - so that's not good so we have to add the
66:48 - modifier 2
66:49 - after it and this is what this entire
66:52 - part does
66:53 - it generates a random number that's
66:54 - either 0 or 1.
66:56 - and then this random number 001 is being
66:58 - used to pick either the minus one or the
67:00 - one
67:01 - and i hope that makes sense it's a tiny
67:03 - bit more complex
67:05 - i will put a link into the description
67:06 - of this video to explain this in more
67:08 - detail if you are interested
67:10 - but okay this covers our x speed
67:13 - so our horizontal speed now we need to
67:16 - talk about the vertical speed
67:17 - and this happens in exactly the same way
67:20 - so instead of x i change this to y and
67:23 - we are
67:24 - almost good to go the one thing i do
67:26 - want to change
67:27 - is that -1 and 1 feels a bit
67:30 - too steep so if we were to leave it at
67:33 - this
67:34 - our ball would start moving in a 45
67:36 - degree line
67:37 - which i think would look quite slow so
67:40 - instead i want to lower the degree so
67:42 - this one could be 0.8 and
67:45 - or minus 0.8 and 0.8 so what this
67:48 - effectively means
67:50 - is that our ball is going to move to
67:51 - left and to the right by the unit of 1
67:53 - but it's only going to move up and down
67:55 - by unit of 0.8 or negative 0.8
67:58 - so it is moving faster in the horizontal
68:00 - direction than it is moving in the
68:01 - vertical direction
68:03 - and for now that's all we needed for the
68:05 - direction of the ball
68:07 - now just like for the player we can go
68:09 - with funk
68:11 - physics process and all we have to do
68:13 - now is to use the move and slide
68:15 - function and add in our velocity
68:19 - and let me actually try this and see if
68:21 - this is working
68:23 - so i press f5
68:27 - and we can see that our ball is moving
68:29 - very very very slowly
68:32 - and again the reason for that is that we
68:33 - have to multiply it
68:36 - by our speed so now let's try this again
68:39 - and there we go there is you can see at
68:42 - the top the ball doesn't bounce but
68:44 - that's okay we can work on that
68:45 - in just a bit for now i think this seems
68:48 - okay
68:48 - but there's one more thing i do want to
68:50 - add before finishing this
68:52 - part that let me run the game again
68:55 - our ball is again moving to the top
68:56 - right and if i press it again
68:59 - our ball is again going to move to the
69:00 - top right
69:02 - and the reason for that is that these
69:03 - random numbers are not perfectly
69:06 - random and let me explain what godot
69:08 - does
69:09 - whenever you use a random number in
69:10 - godot what godot effectively does
69:12 - is it creates what's called a seed and
69:15 - the seed is really just a long list of
69:17 - numbers
69:18 - that godot picks from but godot always
69:20 - uses the same
69:21 - seed which always gives us the same
69:24 - number so these numbers are not
69:25 - actually random but we can change that
69:28 - by using
69:28 - the random mice function
69:32 - so now whenever our scene is ready godot
69:34 - is going to pick a random c to pick
69:36 - numbers from
69:38 - meaning that now when we run our game
69:40 - the ball doesn't start
69:41 - to the top right every time it can move
69:43 - in random directions
69:45 - and i hope at some point it moves to the
69:47 - left there we go
69:49 - okay so this is also working as well
69:51 - cool
69:52 - obviously the ball needs to bounce so
69:54 - let's talk about that
70:00 - so bouncing something off in godot with
70:02 - a kinematic body
70:03 - is actually really easy because there's
70:05 - a specific function
70:06 - for it and it's called move and collide
70:09 - and
70:09 - move and collide works kind of similar
70:12 - compared to move and slide
70:13 - they are both moving a specific
70:15 - kinematic body in a certain direction
70:16 - given the vector you put into it but
70:19 - when they are colliding with something
70:20 - they are doing different things when
70:22 - move in slide collides with an object
70:24 - it slides along the surface of this
70:26 - object whereas move and collide by
70:28 - default doesn't do anything
70:30 - but it returns what's called the
70:31 - collision object and you can use this
70:33 - collision object to make the object
70:35 - bounce off whatever we have hit so this
70:38 - is what we're going to do
70:39 - instead of using move and slide we're
70:41 - going to use move and collide and use
70:43 - that to calculate the angle we have to
70:44 - bounce off
70:46 - and i think it is best to just write in
70:47 - code so here we are back in godot and we
70:50 - have the code for our ball open right
70:52 - now
70:53 - and i don't want to use move and slide
70:55 - so i'm going to delete it
70:57 - and i want to use move and collide
71:00 - and again moving collide needs a vector
71:02 - so we need velocity
71:04 - so far this is exactly the same and
71:06 - again i also want to multiply it by
71:08 - speed
71:08 - but now there's one difference already
71:10 - that we have to multiply
71:12 - move and collide by delta
71:15 - and now with that let me explain what
71:16 - delta does delta is the amount of time
71:19 - that has passed
71:20 - since the last frame of the game was
71:21 - called so let's say if our game runs at
71:23 - 60 frames per second
71:25 - then the difference between each frame
71:26 - is about 17 milliseconds
71:29 - and godot is using that number to
71:31 - calculate how fast the game is going to
71:32 - run
71:33 - and let me illustrate why this matters
71:35 - imagine you have a game on two different
71:37 - computers
71:38 - one computer being really fast the other
71:40 - computer being really slow
71:42 - now the fast computer is going to be
71:44 - able to run a computer really fast
71:46 - so you might have frame rates like 200
71:48 - whereas the slow computer might only get
71:50 - something like 20 frames per second
71:53 - now if we didn't account for the faster
71:55 - frame rate the game on the fast computer
71:57 - would run about 10 times as fast as
71:59 - compared to the slow computer which
72:02 - should make it really weird to play the
72:03 - game on different computers
72:04 - also within the same game if you come to
72:07 - the scene that is more complex
72:08 - the game might slow down and feel
72:10 - inconsistent so we have to account for
72:12 - different frame rates
72:14 - and that is what delta is for and really
72:16 - delta is just a very very small number
72:18 - that measures the time since the last
72:20 - frame and really what happens if you
72:22 - have a fast computer
72:24 - delta is going to be really small but
72:25 - applied very often
72:27 - whereas if you have a slow computer
72:29 - delta is going to be comparatively
72:30 - larger
72:31 - but it is going to be applied less often
72:34 - but both of these are going to equal
72:36 - out so the game is going to run at the
72:37 - same speed so the movements and side of
72:40 - the game
72:40 - are at the same speed and move and slide
72:43 - applies delta automatically whereas move
72:44 - in collide does not
72:46 - and the reason for that is that movement
72:47 - collide does more with physics
72:49 - so we need more control over it now the
72:51 - important thing is that moving collide
72:53 - whenever it hits something it is going
72:55 - to return what's called the collision
72:57 - object
72:57 - and this we can store in a variable so
73:00 - let me create a new variable
73:01 - that i call collision object
73:06 - and this will just assign with the equal
73:07 - sign
73:09 - so whenever we come to this line here
73:11 - udo
73:12 - is going to run this function and
73:15 - move our ball but then when this
73:17 - function is colliding with an object
73:18 - like our wall
73:19 - it is going to return a value this
73:21 - collision object
73:23 - and this collision object we can use to
73:25 - change the velocity of our player
73:27 - so the direction it is moving in and
73:29 - this we do
73:30 - we first check if this collision object
73:32 - exists in the first place
73:34 - which we can just do by typing if
73:37 - collision
73:38 - object and that's all we need so if this
73:41 - kind of object
73:42 - exists then this line is going to
73:44 - evaluate to true
73:45 - and then this if statement is going to
73:47 - trigger so we can use it like that
73:49 - and if that is the case we want to
73:51 - change our velocity because that is the
73:53 - direction we are moving in
73:54 - so we have to assign it a new value so
73:57 - use the equal sign
73:58 - and here we have to use velocity again
74:01 - and then use the bounce keyword
74:03 - and this one bounces a vector and into
74:06 - response vector
74:07 - we have to pass in the collision object
74:11 - and not just that but we also need a
74:12 - normal of this collision object
74:14 - so this line is going to look quite
74:16 - weird so let me explain what's happening
74:19 - here
74:19 - and let me illustrate this actually so
74:22 - here you can see a ball colliding with a
74:23 - wall
74:24 - and we want to bounce this spot off this
74:26 - wall and to do that we are going to need
74:28 - what's called a normal
74:30 - and the normal is just the direction a
74:32 - specific surface is facing
74:34 - so our wall right now is facing upwards
74:36 - for example
74:37 - and this normal we then can use to
74:39 - bounce the wall off in the right
74:40 - direction so the correct one for the
74:41 - bounce direction
74:43 - and all of this is done with the bounce
74:44 - method but well
74:46 - that's all we needed so let's actually
74:49 - try to run this game and see what
74:50 - happens
74:51 - so yeah there we go so the ball goes
74:54 - right outside of the screen
74:55 - let me run it again and we can even
74:58 - bounce off the pedal
74:59 - and oh it's actually working nice so
75:02 - here we have
75:03 - a bouncing ball so this works quite well
75:05 - actually
75:06 - and with that we almost have a working
75:09 - game there's one more thing we need and
75:11 - that is to have an opponent that can
75:12 - actually move along with the ball
75:14 - and that's going to come in the next
75:15 - section so what this means is that we
75:18 - have to talk about artificial
75:19 - intelligence
75:20 - at least on a very very very basic level
75:24 - but effectively this is what we are
75:26 - doing we are giving our opponent
75:27 - some kind of basic intelligence so they
75:30 - can follow the ball
75:31 - and we have an actual game but obviously
75:33 - we are not going to create anything
75:35 - sophisticated
75:36 - so all i really want to do is if the
75:38 - ball is above the opponent i want to
75:40 - move the opponent up
75:41 - if the ball is below the opponent i want
75:43 - to move the opponent down
75:44 - and then the strength of the opponent is
75:46 - going to be determined by the speed of
75:48 - the opponent
75:49 - and i think this is best explained while
75:50 - i'm actually doing it so let's jump
75:53 - right into our game and let's do this so
75:55 - here i'm back in my game
75:57 - and right now i only have the level
75:58 - scene open and if you look to the right
76:01 - you can see our opponent and if you want
76:03 - to open a scene really fast you can just
76:05 - click on this
76:06 - editor icon i guess and now we have
76:10 - opened our opponent scene
76:12 - and i want to give my opponent a script
76:14 - so i click on the script like again
76:16 - and here all the usual stuff i want an
76:18 - empty script let's say let's go with no
76:19 - comments
76:20 - so you can see what it looks like and i
76:22 - click on create
76:24 - so now we just have the function ready
76:26 - and we're actually going to use it in
76:27 - just a bit so i leave it here for now
76:30 - and as always i want to start with a
76:32 - speed variable
76:33 - just like for the player and the
76:34 - opponent and this one i'm going to set
76:36 - to 250
76:38 - but now we do need another thing for the
76:40 - opponent to function properly
76:42 - it needs to know where the ball happens
76:44 - to be on the screen so i want to create
76:46 - another variable that i call ball and
76:49 - you don't actually have to assign any
76:50 - value by default this one is fine
76:52 - so this one doesn't have any value by
76:54 - now and i want to pass a value into it
76:57 - once the scene is ready which is going
76:58 - to be the ball so once the ball scene is
77:00 - ready
77:01 - i want to work with this variable and
77:04 - let me first type what i'm doing and
77:05 - then explain
77:06 - so i want to get parent
77:10 - and then find note
77:14 - so what happens here so whenever the
77:17 - ball scene is ready
77:18 - it looks for its parent which is in this
77:22 - case
77:23 - our ball scene's parent is the level
77:25 - node
77:26 - and then from this level node we are
77:28 - looking for a specific note
77:30 - which is the ball which is really all
77:32 - we're doing here
77:33 - that whenever our level scene is ready
77:36 - we are looking for the main level node
77:38 - and then from this node we are trying to
77:39 - find a node called ball
77:41 - and then we are storing whatever the
77:42 - result is inside of this ball variable
77:45 - so now we can work very easily with this
77:47 - node and now just as before
77:50 - we have to add some more functions to
77:52 - move this thing
77:53 - which again is going to be physics
77:56 - process delta
77:57 - and here we just need move and slide
78:00 - and pass in the vector and now here
78:04 - we don't have a vector just yet
78:07 - so for now let me just pass in vector2.0
78:11 - so this thing is not going to move at
78:12 - all because this arrow doesn't point in
78:14 - any direction
78:15 - instead we have to add some more code to
78:18 - figure out where this ball is
78:20 - in relation to our opponent and for this
78:23 - i'm going to create our first
78:24 - regular function so i'm going to call
78:27 - this
78:27 - func get opponent
78:31 - direction it doesn't need any arguments
78:35 - and here note there's no underscore
78:38 - before it
78:38 - meaning that this function has to be
78:41 - called for it to be run at all
78:43 - which is different compared to this and
78:45 - this function but i'm going to explain
78:47 - this when we get to it
78:49 - so in here we have to create some logic
78:51 - to figure out when the player has to
78:52 - move up and when the player has to move
78:54 - down
78:55 - and we can work with that actually quite
78:57 - easily because we can get the position
78:59 - of both the ball and the opponent very
79:01 - easily
79:02 - and let me explain what we are going to
79:04 - do in here in the most basic sense
79:07 - we are going to check is the ball above
79:09 - the opponent then we move the opponent
79:11 - up
79:11 - is the ball below the opponent then we
79:13 - move the opponent down
79:14 - however we are going to give a little
79:17 - bit of a wiggle room
79:18 - so that we are only going to move the
79:20 - player up if the ball is slightly above
79:22 - the player
79:23 - so if the ball on the opponent are
79:24 - roughly on the same height we are not
79:26 - going to move the opponent
79:27 - because if we did the opponent would
79:29 - adjust all the time and would look
79:31 - incredibly wiggly
79:32 - so we have to create what's called a
79:34 - nested if statement
79:36 - so we first have to check if there is
79:37 - enough distance between the ball and the
79:39 - opponent
79:40 - and then inside of this if statement we
79:42 - check if the ball is above or below the
79:43 - opponent
79:44 - so let's get to it i first want to do
79:47 - the outer if statement
79:48 - that if there is enough vertical
79:51 - distance between the two
79:52 - and for that let me write the entire
79:54 - line first and then explain
79:56 - so we want apps ball dot position
80:01 - dot y minus
80:05 - position dot y is greater than
80:09 - 25. so what does any of that mean
80:13 - i think ballposition.y and position.y
80:16 - are fairly clear
80:18 - baller position at y is the y position
80:20 - of the ball
80:21 - and position note y is the position of
80:24 - this note here
80:25 - so we are essentially subtracting one
80:27 - from the other
80:29 - but we are putting this inside of an abs
80:31 - function
80:32 - and absolute numbers are just always
80:34 - positive numbers
80:36 - so let's say if we're getting something
80:37 - like -50 out of here
80:39 - the absolute function would turn into a
80:41 - positive number and this is there to
80:43 - ensure that it doesn't matter if the
80:44 - ball is above
80:45 - or below the opponent so we're just
80:48 - looking for the distance between the two
80:50 - not if it's above or below this comes on
80:52 - the next line
80:53 - and what we want to check in here is if
80:56 - ball dot position dot y
81:00 - is greater than position dot y
81:04 - and if that is the case we want to
81:05 - return one
81:07 - and i'm going to explain what this means
81:09 - in just a bit for now just stick with me
81:12 - and all what we are checking right now
81:13 - is if the ball position
81:15 - is if the ball is below the player so if
81:18 - it has a greater y
81:19 - value and if that is not the case so
81:22 - else we want to return
81:27 - a minus one and again don't worry about
81:29 - return right now
81:30 - i'm going to cover this in just a bit
81:32 - and now we have our two possibilities
81:34 - that either the ball is below the
81:36 - opponent or it is above the opponent so
81:38 - the else statement here
81:40 - so if this entire if statement doesn't
81:42 - come to true then we want to
81:44 - else return zero
81:48 - and this is the entire logic to move the
81:50 - opponent so
81:51 - let me explain what the return means so
81:54 - every time a function is running it
81:56 - returns a value
81:58 - and let me actually open the code for
82:00 - our ball so here we can see this line
82:03 - we have move and collide and this is
82:05 - returning a value into this collision
82:07 - object
82:08 - so whenever this function is running it
82:10 - returns a value
82:12 - and when you create your own functions
82:14 - you can set what the function is
82:16 - returning
82:17 - so in this case if this is true our
82:20 - function is going to return
82:21 - 1 or it might return a negative one or
82:23 - it might return a zero
82:25 - so really all this function does is if
82:27 - the ball is below the opponent it
82:29 - returns a one
82:30 - if the ball is above the opponent it
82:31 - returns a minus one and
82:33 - if neither of these are true then it
82:34 - returns a zero whereas for the ball
82:37 - this move in collide returned a
82:39 - collision object so something much more
82:41 - complex
82:42 - but this number we can use immediately
82:44 - in here
82:46 - so our vector 2 when we add brackets to
82:48 - it we can specify
82:50 - what directions we are looking at when
82:51 - we create this
82:53 - and for the x we just want it to be zero
82:55 - because we don't want to move the
82:57 - opponent left or right
82:58 - we only want to move it up or down and
83:01 - for up or down we want to use this value
83:03 - here so we can just call this function
83:05 - inside of this vector
83:06 - so get i called it opponent direction
83:12 - so now whenever godot runs this function
83:15 - it creates a vector inside it that
83:17 - doesn't move on the x
83:18 - but for the y it looks at this entire
83:20 - function what is being returned
83:23 - and then again we have to multiply the
83:26 - entire thing
83:27 - by our speed and this is a slightly more
83:31 - complex example
83:32 - so it's probably making sense to go over
83:34 - this a couple of times if you're new to
83:35 - programming or good dough
83:37 - but let me run all of this and let's see
83:38 - if this is working and
83:40 - yeah it is and really
83:43 - nothing complex happens here all that's
83:46 - really happening
83:47 - is that we check if the ball is above or
83:49 - below the opponent
83:50 - and then we move the opponent up or down
83:52 - depending on where the ball is
83:55 - so we have almost a workable game
83:57 - there's one thing left to do that we
83:59 - have to reset the ball
84:00 - once it moves outside of the screen so
84:02 - that's going to come in the next part
84:04 - and again to achieve that we have a
84:06 - couple of different options
84:08 - we could just calculate something in
84:09 - code to check the position of the ball
84:12 - but i'm not going to do that instead i'm
84:14 - going to use a node for this approach
84:16 - and this is bringing us to the third
84:17 - kind of physics node it's called an area
84:19 - 2d node
84:20 - and an area to danio doesn't really
84:22 - calculate physics
84:24 - instead it just checks if the physics
84:26 - body is inside of it
84:28 - so what i'm going to do is to put area
84:30 - 2d notes to the left and to the right of
84:32 - the screen
84:32 - and whenever the ball is inside of them
84:34 - i'm going to put the ball back to the
84:36 - middle of the screen
84:37 - so really something very simple so let's
84:40 - jump right into godot and let's do this
84:42 - so here we're back in our level scene
84:44 - and i want to add a few more notes
84:46 - so with the level selected i click on
84:48 - the plus icon
84:49 - and now i want an area to denote
84:53 - i add it and here again the door wants
84:56 - it to have a shape
84:57 - so i press ctrl a and i add a collision
85:00 - shape 2d
85:04 - and here as always i want to add a new
85:06 - rectangle shape
85:08 - and here we can see our rectangle shape
85:11 - and move it roughly into place
85:17 - and here's one thing you do want to be
85:18 - aware of that both of the wall
85:20 - top and the wall bottom they are also
85:23 - physical shapes
85:24 - so if the wall is colliding with the
85:26 - area to d this area to d would also be
85:28 - triggered
85:29 - so the area 2d at least by default only
85:32 - cares if
85:33 - any physical body comes inside of it
85:35 - this could be a wall it could be a
85:36 - player this could be a ball
85:38 - it doesn't matter so at least in our
85:40 - case
85:41 - we have to make sure that it doesn't
85:42 - collide with either of the walls
85:46 - and granted this isn't the best approach
85:48 - to do this kind of thing
85:49 - but i think for our game at least it's
85:51 - serviceable so i'm not going to worry
85:53 - about it too much
85:54 - ok now we have an area to the side of
85:58 - the screen
85:59 - and the ball wouldn't bounce off this
86:00 - shape it would go through it but then
86:02 - this area to denote could tell us that
86:04 - it's colliding with the ball
86:06 - but step by step before that i want to
86:09 - copy this area to d
86:11 - and again select it so you can't select
86:13 - the children and move it all the way to
86:15 - the left behind the opponent
86:17 - and this doesn't have to be too precise
86:20 - okay
86:21 - now we have area nodes to the left and
86:24 - to the right side of the screen
86:26 - and they are going to know that the
86:28 - borders collided with them
86:29 - but by default they're not going to tell
86:31 - us and we have to add some specific
86:33 - functionality that they're actually
86:34 - telling us that the ball is colliding
86:36 - with them
86:37 - and to do that we have to cover a new
86:38 - concept that is called signals
86:40 - and all a signal does is it helps us to
86:42 - make nodes communicate with each other
86:44 - so in our case what we want to do is if
86:47 - the ball is colliding with the
86:49 - to denote we want the area to linear to
86:51 - tell us that it's colliding with the
86:52 - ball
86:53 - and that's really all there is to it in
86:56 - a bit more detail though
86:57 - when you're creating a signal you always
86:59 - have to connect the signal to
87:01 - a node with some code because the signal
87:03 - is effectively creating a new function
87:06 - that works like an inbuilt function that
87:07 - is only being called at specific
87:09 - instances
87:10 - so for our area to denote for example
87:12 - it's only being called when it's
87:13 - colliding with physical body
87:16 - but okay lots of theory let's actually
87:17 - implement this
87:19 - so here we are back in our good old
87:20 - editor and i'm going to start worrying
87:23 - about
87:24 - our left side and let me actually rename
87:27 - them to
87:27 - left and right
87:32 - and yeah i got the right side so i want
87:34 - this left side
87:36 - to tell this level scene when the ball
87:39 - is colliding with it
87:40 - so with left selected i go to the right
87:43 - and there's inspector
87:44 - and there's also node and if i click on
87:46 - that we have signals and groups
87:48 - for now we only look at signals groups
87:50 - come later
87:51 - but here let me explain this
87:55 - we have all the different options that
87:58 - could be signals
87:59 - and what we are looking for is body
88:01 - android so this signal is only being
88:03 - triggered
88:04 - when a body like the ball is entering
88:06 - this area to the node
88:08 - so i double click on it and now we have
88:11 - a problem
88:12 - that we can only connect this signal to
88:14 - a node with some code
88:16 - and it doesn't really make sense to
88:17 - connect it to the player the opponent
88:19 - or the ball well maybe the ball but i
88:21 - want to connect it to the level itself
88:24 - so what i have to do is to give this
88:26 - level its own script
88:29 - so again i click on the icon and i just
88:31 - click on
88:32 - empty and create a new script
88:36 - and let me minimize this again because
88:38 - we don't need it so now our level scene
88:40 - has a script as well
88:42 - that doesn't really do too much at least
88:44 - just yet but again
88:45 - i go to left and click on body edit
88:48 - again
88:49 - and now if i double click on it i can
88:51 - connect it to the level
88:53 - and i could also give it a specific name
88:55 - but usually the default names are fine
88:58 - so i click on connect and now inside of
89:01 - the script for our level scene
89:03 - we have a new function and this function
89:06 - is going to be triggered every time
89:08 - a body enters this area 2d and we also
89:11 - have an argument with the body
89:13 - and this is the body that entered the
89:14 - area 2d so we could use this to
89:16 - influence the ball itself
89:18 - and let's first try if this is working
89:21 - and there's a really useful tool to
89:22 - check if something is working is called
89:24 - the print function
89:26 - and let me just call it collision for
89:29 - now
89:30 - so what we're doing in this line that if
89:32 - this function is being executed
89:34 - we want to print this text so collision
89:38 - and we will be able to see this at the
89:40 - bottom in the output tab
89:42 - so with this one open let me run the
89:44 - game
89:46 - and the ball goes outside and
89:49 - unfortunately we can't see anything
89:51 - because we're only checking the left
89:52 - side right now we're not checking the
89:53 - right side
89:55 - so let's try this again okay
89:59 - see when i get lucky there we go okay
90:01 - now it's on the left side
90:02 - now we can see collision so we know that
90:05 - this function here works and it only
90:07 - works
90:07 - if the ball is colliding with it so
90:10 - print is really useful to test your code
90:12 - but in my case i don't really care about
90:15 - it for now
90:16 - so what i want to do now is whenever
90:19 - this function is being triggered i want
90:20 - to reset the ball
90:22 - and that brings us to a new concept that
90:25 - we have to select different nodes
90:27 - from a starting node so right now
90:30 - let me open the opponent for example all
90:33 - of these
90:33 - methods they always apply to the
90:36 - opponent node itself
90:37 - we never tried to influence the sprite
90:39 - node or the collision shape 2d
90:41 - we always worked directly with the
90:43 - opponent node but now this is slightly
90:46 - different
90:46 - because we want to go from the level
90:48 - note and influence the ball
90:51 - so what we have to do in our code is
90:53 - first select the ball
90:54 - and then influence the ball and we can
90:57 - do this very easily
90:59 - and there are actually different ways of
91:00 - doing this the easiest one
91:02 - is use the dollar sign and then the name
91:05 - of the note you want to target
91:06 - so my case ball so if we have this line
91:09 - here
91:09 - we would only target the ball and if i
91:12 - now for example change the position
91:13 - we would only change the position of the
91:15 - ball not the position of the level note
91:19 - and that is actually what i want to do
91:21 - and the position has to be
91:22 - a vector 2 and now we have to put in the
91:26 - x and the y position
91:28 - and i want to go right in the middle of
91:30 - the screen
91:32 - so it's 640 by 360. so
91:35 - when i open our screen dimensions again
91:39 - so i just halved both of these numbers
91:42 - which brings our ball right in the
91:43 - middle of the screen
91:45 - and at least for now that is all we
91:47 - needed
91:49 - but obviously this is just the left side
91:52 - so we also have to connect the right
91:54 - side
91:54 - and this could be a challenge again if
91:56 - you want to code along so pause the
91:58 - video now and try to connect the right
91:59 - side with a signal and also
92:01 - reset the ball if the ball collides with
92:03 - the right side
92:04 - but let me do it so with the right side
92:06 - selected
92:07 - i am going to click on body entered
92:11 - and with body entered i again connect
92:13 - the signal to the level scene
92:14 - and i don't change the name but you
92:15 - could if you wanted to
92:17 - and now i'm just going to copy this line
92:20 - here
92:21 - and that's basically all we needed so
92:24 - let's try all of this
92:26 - and let me actually lose and there we go
92:30 - we have the ball starting again in the
92:32 - middle
92:35 - and with that we actually have a really
92:38 - basic game
92:39 - all that's left to do now is to add some
92:41 - more refinements to make the game look a
92:43 - bit prettier
92:44 - and that's going to come in the next
92:46 - part
92:48 - and i'm going to start by adding a score
92:50 - which is actually super easy to add
92:53 - but it is going to require us to work
92:54 - with text which is something we haven't
92:56 - done
92:56 - so far but text is actually really easy
93:00 - so let's actually jump right in and i
93:02 - will explain it while we are
93:03 - implementing it
93:04 - so here again we are in our level scene
93:07 - and i want to add some text
93:09 - and text in godot is called a label
93:14 - and you have also a rich text label but
93:16 - for now i just want a label
93:18 - which is a really really simple text but
93:20 - it could be more complex but i don't
93:21 - need that
93:22 - so now we have a label and if you look
93:24 - at the inspector
93:26 - we can write for example test in there
93:29 - and if i zoom in we can see test
93:32 - so this is working quite well obviously
93:34 - we don't want it to be
93:36 - in the top left of the screen instead i
93:38 - want it to be roughly in the middle
93:39 - a bit further to the left so we can see
93:41 - it's the player score
93:43 - and actually let me rename it to player
93:46 - score
93:48 - and here again you can see it's a green
93:50 - node just like our color rect and i can
93:52 - actually put them together
93:53 - that makes sense and here
93:56 - we can use the layout again and what i
93:58 - first want to do is to check for the
94:00 - full rectangle
94:01 - so this node is looking at the entire
94:03 - screen
94:04 - but our note is still in the top left
94:07 - so effectively what we have created is a
94:10 - really large text box with some text in
94:12 - the top left
94:13 - so we have to change this text box to
94:15 - move the text right into the middle
94:17 - which we can do if you look at the
94:18 - inspector you have a line and via line
94:21 - which is short for vertical align
94:23 - and right now it's left and top but if i
94:25 - change it to center
94:26 - and center and now we have it right in
94:29 - the middle
94:30 - it might look a bit deceptive because of
94:31 - the ball but i just put the ball
94:33 - randomly
94:34 - on the screen so the test is actually in
94:36 - the middle of the screen
94:39 - and obviously we don't want it to be
94:41 - right in the middle
94:42 - so i want to add a margin to it that
94:44 - it's moved slightly further to the left
94:46 - and this we can do under margin and here
94:49 - we have
94:49 - left and right and you can just move
94:52 - either of them
94:53 - so let's go with negative 200
94:57 - and this is going to move the text a bit
94:59 - further to the left
95:02 - and alright this looks fine
95:06 - so now i can copy the entire thing so i
95:09 - also have an opponent score
95:13 - opponent score and this opponent score
95:16 - i just moved the margin to 200 so it's a
95:19 - bit further to the right
95:20 - and let me trial of this in the game now
95:23 - and yeah we can see
95:24 - test and it looks roughly in the middle
95:27 - cool
95:29 - so now we have two things to do the
95:31 - first one is we have to update the score
95:33 - and the second one is that this text
95:35 - doesn't look very good so we have to
95:37 - update that as well
95:39 - and let me start with the actual score
95:41 - and this one is
95:43 - not that difficult to do so i go back to
95:45 - our code
95:47 - and in our code i'm going to create two
95:50 - new variables
95:51 - the first one is called player score
95:55 - it's going to be zero by default and
95:56 - then we also have an opponent
95:58 - score which is also going to be zero
96:01 - and now on every single frame of the
96:03 - game i want to set
96:05 - these scores as the text for our player
96:08 - score and opponent score labels
96:10 - and for this this time we are going to
96:13 - just use the process
96:14 - function so let me type func
96:17 - underscore process
96:20 - so this process works kind of like the
96:22 - physics process
96:24 - except in this case we are not
96:25 - calculating anything physical we're just
96:27 - setting some text
96:28 - hence we're only using process not
96:30 - physics process
96:32 - and what i want to do in here is to
96:34 - first target
96:35 - our player not player sprite
96:39 - player score
96:42 - and to change the text i need text
96:46 - and if you want to find out what the
96:48 - attributes are of a certain note
96:50 - you can just look at the node itself so
96:53 - players go in this case
96:54 - and hover over what you want to
96:56 - influence so if you hover over
96:58 - text you can see property text and this
97:00 - is what you have to use in the code to
97:02 - target this attribute
97:05 - and then for this text i want to set
97:09 - player score but this would not be
97:12 - working by default because of the data
97:14 - type
97:15 - that this kind of text is looking for a
97:17 - string so a certain kind of words
97:20 - but this player score is a number so we
97:23 - have to change this player score from a
97:24 - number to a text
97:26 - which we can do very easily with the str
97:28 - method which is called string
97:30 - and all it really does is it takes a
97:32 - number and turns it into a string
97:34 - so exactly what we need so let me try
97:37 - this now so now player score should be
97:38 - zero
97:39 - and it is cool but it doesn't update yet
97:42 - so
97:42 - we have to work on that but before that
97:45 - i'm going to copy this entire line
97:48 - and change it to opponent score
97:53 - and up
97:56 - opponent score and now we run this they
98:00 - should both be zero
98:01 - and they are cool now what we have to do
98:04 - is to update these two scores to reflect
98:07 - the actual score
98:08 - and this we can actually do very easily
98:10 - because we already know if the ball is
98:12 - leaving on the left side of the screen
98:13 - or the right side of the screen so if
98:16 - the ball is leaving on the left side of
98:17 - the screen
98:18 - we know the player's score is increasing
98:22 - by one and if the ball is leaving on the
98:25 - right side
98:26 - we have player
98:31 - score plus equal one
98:35 - and this is all we needed for the score
98:37 - so let me try this now
98:39 - and let me get score there we have one
98:43 - two oh yeah i messed up the sides
98:46 - so i just have to change this one around
98:50 - oh no it's player score and player score
98:52 - right
98:53 - so on the left this would be opponent
98:57 - score
98:59 - opponent score let's try this now
99:03 - and yep this looks better
99:08 - and yep this also works and there we can
99:11 - actually see
99:11 - one more problem that we're going to
99:12 - cover later
99:14 - that either the opponent or the ball
99:16 - could be moved by the ball
99:18 - in terms of physics but don't worry
99:20 - about this for now we're going to fix
99:21 - this in just a bit
99:23 - but for now we have a working score
99:25 - system
99:26 - so what's left to do for now is to
99:28 - change the style of these fonts because
99:30 - they look pretty bad right now
99:32 - and again this is quite easy to do so
99:34 - with the player score selected
99:37 - we have custom fonts and custom colors
99:40 - i'm going to start with custom fonts
99:41 - if you open this tab you have a drop
99:45 - down menu
99:45 - and you can type new bitmap font and new
99:47 - dynamic font
99:48 - we want a dynamic font so i click on it
99:51 - and now i have to type on dynamic font
99:54 - and don't worry about the text
99:55 - disappearing that's normal
99:57 - so i click on dynamic font and now we
99:59 - have settings extra spacing font and
100:01 - resource
100:02 - and in font we can set our custom font
100:05 - and in our assets folder
100:07 - there actually is a custom font it's
100:09 - called poets and one
100:10 - regular and if i drag it into we can see
100:14 - a custom font and here we can also
100:18 - change the size of it
100:19 - and make it smaller i think i went with
100:23 - 50 possibly a bit large let's go with
100:27 - 40.
100:30 - and this would be a custom font so if i
100:31 - run the game now
100:33 - this one would look drastically better
100:36 - cool and we can also change the color of
100:40 - this
100:40 - so custom colors and by default it's
100:43 - black
100:44 - and here you can change again the color
100:46 - around
100:47 - and in my case i'm going to use a
100:49 - hexadecimal number again
100:51 - that is b9 d8
100:55 - and d7 which is a fairly whitish color
100:58 - but not perfect white and
101:02 - all right that's really all we need to
101:03 - make the text look prettier
101:05 - now we have to do the same thing for the
101:06 - opponent score and again if you want to
101:08 - challenge yourself pause the video now
101:10 - and try this yourself
101:12 - but all you really have to do is go
101:14 - again to custom fonts
101:17 - create a dynamic font click on dynamic
101:19 - font again
101:20 - click to font and now drag and drop the
101:23 - font in there from the asset folder
101:25 - and then for settings i went with a font
101:28 - size of 40 if i remember correctly
101:31 - and now under custom colors enable font
101:34 - color
101:35 - and click on it and it was d9 d8 and d7
101:39 - click on enter and you're good to go
101:42 - so let me run all of this again now and
101:47 - we have our scoring system
101:50 - so seems fine and with that we're
101:53 - actually making pretty good progress
101:55 - in the next part i'm going to add a
101:57 - countdown timer so there's a bit of a
101:58 - delay before the ball restarts
102:01 - okay then it timer and timers in godot
102:04 - are actually
102:05 - fairly straightforward because again we
102:07 - have a specific note for that that we
102:09 - can use actually quite easily
102:10 - and more specifically what i'm trying to
102:12 - achieve are two things
102:14 - number one is that we're having a count
102:16 - on timer before the ball restarts after
102:17 - we have fit a goal
102:19 - and number two is that i also want to
102:21 - display this count on timer
102:22 - so that we can see two one and zero on
102:24 - the screen or something like that
102:26 - and some short number that counts down
102:28 - from a certain number to zero
102:30 - how long that is going to be is up to
102:31 - you but i found
102:33 - two is a good starting point because
102:35 - three actually felt a bit too long
102:37 - but the specific number really doesn't
102:38 - matter let's have a look at this
102:40 - so here we are back in the code and the
102:42 - first thing i have to add
102:44 - is a timer node so with our level
102:46 - selected
102:47 - i click on the plus sign again and i
102:49 - want a timer node
102:50 - and it literally says a countdown timer
102:52 - so create
102:54 - and again i'm going to rename it to
102:56 - count
102:58 - down timer and
103:01 - if you look to the right at the
103:02 - inspector you can see a couple of
103:03 - attributes
103:04 - number one is the wait time so this is
103:06 - the length of the timer
103:07 - then we have one shot so is this time
103:09 - we're going to run just once or multiple
103:11 - times
103:11 - in our case this is going to be true and
103:14 - then we have autostart so if it starts
103:16 - by itself or if we have to trigger it
103:18 - quite straightforward so in my case i
103:20 - want wait time to be 2
103:23 - and one shot to be on and that's all we
103:26 - need for the attributes
103:28 - but now obviously if this timer were to
103:30 - run out
103:31 - we would again need a signal to tell
103:33 - other nodes that the time has run out
103:36 - kind of like for the signals for the
103:38 - area to denote for the left and right
103:40 - areas
103:41 - so here same principle this timer right
103:43 - now
103:44 - would be running however we have to tell
103:46 - another node that it has triggered
103:48 - so for this again we need a signal and
103:51 - for that i go to the top to node
103:53 - and here we only have one really big
103:55 - signal that's timeout
103:56 - and this is when the timer reaches zero
103:58 - so seems appropriate
104:00 - so i double click on it and i'm going to
104:02 - connect it to our level
104:05 - and here again besides our signal for
104:08 - the right body entered and left body
104:10 - entered
104:10 - now we also have a count on timer
104:12 - timeout
104:14 - and now here's the logic i'm trying to
104:16 - achieve with this
104:17 - that once we have scored a goal i want
104:19 - the ball to return to the middle of the
104:21 - screen
104:22 - and i also want our countdown timer to
104:23 - start ticking down
104:25 - and only once the countdown timer has
104:26 - reached zero then i want the ball to
104:29 - restart
104:30 - so for now we are not going to worry
104:31 - about the text displaying all of this we
104:33 - are just going to worry about the timer
104:34 - functionality
104:36 - and this is bringing us to kind of a
104:38 - problem that
104:39 - right now we're controlling our level
104:41 - scene but we do want to influence the
104:44 - ball
104:44 - which is in its own scene so we need to
104:47 - work across different scenes
104:48 - but from our level node we want to tell
104:50 - our ball not to move anymore
104:52 - at least for a certain amount of time
104:55 - and there are a couple of ways to
104:56 - achieve this
104:58 - the one i'm going to use is called a
104:59 - group which is fairly similar to a
105:02 - signal but with a slight difference
105:04 - so let me illustrate so far we have seen
105:06 - a signal
105:07 - where let's say for a timer where you
105:09 - send a signal from one node to the other
105:11 - so let's say from our count on timer
105:13 - node to our level node
105:14 - or from our area to denote to our level
105:17 - node so we always start from one node
105:19 - and go to the other node
105:20 - and for a group we are still starting at
105:22 - a single node however now
105:24 - we can target as many nodes as we want
105:27 - so any node that is inside of a specific
105:29 - group can
105:30 - be targeted and what this is really
105:32 - useful is that it doesn't matter where
105:33 - the node is
105:34 - so it could be in a different scene it
105:36 - could be inside of a scene of another
105:38 - scene
105:38 - it doesn't matter as long as the node is
105:40 - inside of a specific group
105:42 - we can always target it no matter where
105:44 - it is so what i'm going to do
105:47 - is to put our ball inside of a group and
105:49 - then from our level scene i'm going to
105:51 - target that group
105:52 - and then this group is going to tell the
105:54 - ball to execute certain functions
105:56 - so let's actually implement this so here
105:59 - i'm back in my code and let me just
106:00 - quickly save
106:01 - okay and now i want to open my ball
106:03 - scene so i click on ball and click on
106:05 - the little film icon
106:07 - and here we have our ball again and i
106:10 - still have the notes section open that
106:12 - is next to the inspector
106:13 - so far we looked at signals now i want
106:15 - to click on groups
106:17 - and then here all we can see is manage
106:19 - groups we can type some text in here and
106:21 - click on add
106:22 - and if you have a node selected in here
106:24 - like i have for ball
106:25 - and i can type in a name in here let's
106:27 - say ball
106:30 - group i can click on add and now our
106:33 - ball is inside of the ball group
106:36 - which you can see from this icon next to
106:38 - the note it's
106:39 - a circle inside of a square bit of a
106:41 - random icon but who cares
106:44 - so now what this means is that this node
106:46 - is inside of a group
106:48 - and whenever we target this group we
106:50 - could also target the node itself
106:52 - and how this most specifically works is
106:54 - that we're going to give
106:55 - this node a specific function let's say
106:58 - we're going to give it a function
107:00 - that i'm going to call stop ball
107:05 - and all that this function does is it
107:07 - sets this speed to zero
107:09 - so all we need is speed equal
107:12 - zero and then inside of our move and
107:15 - collide function
107:16 - if we multiply velocity and delta by
107:18 - zero it is going to be zero
107:20 - so the ball would stop moving so exactly
107:22 - what we want
107:24 - so now we have to figure out how to call
107:26 - this double function
107:28 - from our level script so i go back to
107:30 - our level script
107:31 - actually let me save the script first
107:33 - just to be sure
107:35 - so what i want to do is when either of
107:37 - these two areas are being hit
107:39 - i want to call the stop function and for
107:41 - that we need two commands
107:43 - the first one is get three
107:47 - and the second one is call
107:50 - group and in here we could pass in the
107:53 - name of the group and the method we want
107:54 - to call
107:55 - so in my case this is ball group
107:59 - and stop how do i call it
108:04 - stop ball stop
108:07 - ball so i think this entire part
108:11 - kind of makes sense we are calling a
108:13 - group and we have the name of the group
108:15 - and the method we want to call inside of
108:17 - this group so why do we need
108:19 - get tree and this i can actually
108:21 - illustrate
108:22 - so let me run the game right now and
108:24 - let's hope it doesn't crash
108:25 - yeah okay so the ball actually stops in
108:27 - the middle so we know it's working
108:29 - but while the game is running if you
108:31 - look to our scene 3
108:33 - you can right now see local and remote
108:35 - and you can click on this
108:36 - still while the game is running and it
108:38 - shows our game
108:39 - and all the notes inside of our game in
108:41 - real time so you can see all the notes
108:44 - inside of the game while the game is
108:45 - running
108:46 - and here you can see a root note and
108:48 - only then our level note
108:50 - and this entire thing is our scene tree
108:52 - for the entire game
108:55 - and obviously it's still a fairly simple
108:57 - one but what we actually want to get
108:59 - is this root node that will get access
109:01 - to the entire tree while the game is
109:03 - running
109:04 - and this is what get tree is doing that
109:06 - it gets us the entire tree
109:08 - and from there we can access specific
109:10 - functions like calling a group
109:13 - which we couldn't do just from a
109:14 - specific note by itself
109:17 - so i hope that makes sense but we're
109:19 - making progress because the ball is
109:20 - stopping indeed
109:21 - so that's quite nice this has to be
109:24 - called
109:26 - on both sides of the field
109:30 - and with that we can start talking about
109:32 - restarting the ball
109:34 - and this works in basically the same way
109:36 - so i go back to my ball
109:38 - and in here i want to create another
109:41 - function
109:41 - that i'm going to call let's call it
109:43 - restart
109:45 - all and in here
109:49 - we could just set speed back
109:52 - to 600 but i don't think this would be
109:56 - enough
109:57 - and the reason for that is quite simple
110:00 - that if we were to restart the ball like
110:02 - this
110:02 - it would still point in the same
110:03 - direction so if the ball is going to top
110:06 - right
110:06 - and then hits the end of the field it
110:08 - will restart to the top right
110:10 - which would get really predictable so
110:13 - not only do i want to set the speed
110:14 - again to 600
110:16 - i also want to restart the velocity and
110:18 - get different random values
110:20 - and i can literally just copy and paste
110:21 - them and now i would get new values when
110:23 - i restart the ball
110:25 - so quite straightforward and now again
110:28 - we have to call the group to restart
110:30 - this function
110:32 - and if you want to challenge yourself
110:34 - this should be doable if you got this
110:36 - far
110:36 - so try this for yourself but really all
110:39 - you have to do
110:40 - let me save this one again we
110:43 - need to call this function
110:46 - in a very similar way compared to this
110:49 - but i only want to do this
110:50 - once the timer has run out so this has
110:52 - to be inside of this countdown timer
110:54 - and now instead of stop ball i want to
110:57 - have
110:58 - start ball i think restart what i called
111:01 - it i'm
111:01 - terrible with naming functions but okay
111:04 - so now whenever this time has run out
111:06 - we're going to call this group and
111:09 - called the restart ball function
111:11 - so there's one more thing we need that
111:13 - we have to start
111:14 - this timer so whenever the ball has set
111:17 - either of the fields
111:18 - we want to start the timer and once the
111:20 - timer has finished we want to call this
111:22 - group
111:23 - so we have to figure out how to start
111:24 - this timer and that is
111:27 - actually super easy so all we need
111:30 - is to first target the node of the timer
111:33 - which again you do with the dollar sign
111:35 - and what you can also do is just drag
111:37 - and drop the node next to dollar sign
111:39 - and there you would get the name of the
111:41 - node this time
111:43 - in quotation marks but that is the same
111:45 - outcome
111:47 - so if you typed it with quotation marks
111:49 - or without
111:50 - it's the same thing they both result in
111:51 - the same thing that you are getting the
111:53 - note
111:54 - and now to start the timer all we need
111:56 - is start
111:58 - and let me copy this to both sides
112:02 - and now this should be working so let's
112:04 - try
112:07 - so we have the ball here and let me
112:12 - and there we go this is working so let
112:14 - me lose again
112:16 - and wait a bit and there we go so the
112:19 - ball is restarting after about two
112:21 - seconds
112:22 - over however long it takes so cool
112:26 - seems quite all right there's one thing
112:29 - we could be doing that right now we're
112:30 - duplicating code here
112:32 - quite substantially so instead what i'm
112:35 - going to do
112:36 - is create a new function um let me put
112:39 - it
112:40 - all the way at the bottom and that is to
112:43 - create a new function
112:44 - let's call it
112:48 - score achieved
112:52 - and in here all we have to do is copy
112:54 - this entire line
112:56 - or even cut it and then inside of
112:59 - each of these signals i just want to
113:01 - call this
113:02 - so score
113:05 - achieved
113:08 - and score achieved
113:12 - so now if you want to influence either
113:13 - of these we just have to work with this
113:15 - function
113:16 - and this doesn't duplicate code so quite
113:18 - a bit nicer
113:20 - but all right now we have a basic timer
113:23 - and all we need now is to display this
113:25 - timer
113:26 - and this is going to be another label
113:29 - so i have a player score right now and
113:31 - an opponent score i want to add another
113:33 - label
113:35 - so i select the level note and add
113:38 - another label
113:40 - that i'm going to call countdown
113:44 - timer alright i already have one um
113:47 - let's call it count down
113:50 - label that feels better and i'm gonna
113:53 - put it right to the other labels
113:55 - and the really important part here is
113:56 - that all of these labels
113:58 - are above all of the other notes in the
114:01 - scene tree
114:01 - especially the ball so i want the ball
114:04 - to be above
114:05 - the countdown label in the actual game
114:08 - otherwise i think it would look quite a
114:10 - bit weird that we have text over the
114:12 - ball
114:13 - okay now we have our countdown label and
114:16 - for now
114:17 - let me just write in here countdown
114:20 - and move it to the middle of the screen
114:23 - so again
114:23 - i click on layout i click on full rect
114:26 - to select the entire viewport
114:28 - and now i align it to the center and
114:31 - to the center and now with the margin i
114:35 - just move it up a tiny bit
114:38 - um i guess here seems fine it's fairly
114:42 - subjective whatever you feel like it
114:43 - looks good could also be at the bottom
114:45 - could be anywhere whatever you fancy
114:48 - and again we have to give this a custom
114:50 - font to match it with the other two
114:51 - pieces of text we have
114:53 - so i go to custom font get to dynamic
114:56 - font
114:58 - then get to font again it's quite click
115:01 - intensive
115:03 - and then drag and drop our font in there
115:06 - and i'm going to make this
115:10 - um let's go with 50.
115:14 - um yeah i think that seems fine
115:17 - and now this one got a slightly
115:19 - different color
115:19 - [Music]
115:21 - so again under custom colors i click on
115:24 - font color
115:25 - and this time let me demonstrate another
115:26 - way to pick a color
115:28 - and that is this color picker here so if
115:30 - you click on this
115:32 - godot lets you just pick another color
115:34 - maybe not the background
115:35 - let me use the white color here so if
115:37 - you just use this you can literally
115:39 - select any color on the screen
115:41 - and what i want to do is i want to
115:43 - select the color of the ball
115:45 - which right now we can't do because
115:46 - there's the collision shape above the
115:48 - ball
115:49 - so i go to the ball scene and just make
115:51 - this invisible
115:53 - and here's an important thing just
115:55 - because the shape is invisible
115:56 - does not mean it's not there anymore you
115:58 - just can't see it
116:00 - but for collision shape you can never
116:02 - see it anyway so it doesn't matter
116:04 - if you actually wanted to disable it you
116:06 - would have to go to disabled and click
116:08 - this on on
116:09 - but just because it's invisible doesn't
116:11 - mean it's not there so be aware of that
116:13 - but now with this one disabled we can
116:15 - actually see the color of our ball
116:18 - and now i can just go back to font color
116:21 - and just pick the color of the ball
116:23 - which is this orange
116:25 - red-ish color and all right
116:28 - this seems alright but now we have to
116:31 - figure out how to display this text
116:34 - only if the countdown timer is running
116:36 - and how to get the text of the count on
116:37 - time
116:38 - and for that we have to go back to our
116:40 - code and
116:41 - in here there are two things we need to
116:43 - work on number one
116:45 - is that we actually displayed the time
116:47 - left within
116:48 - our countdown label and this happens in
116:50 - the process function
116:52 - because we want to continuously do this
116:54 - on every single frame of our game
116:56 - so in here i want to target our
116:59 - countdown label
117:01 - and i want to set the text now what i
117:03 - want for the text
117:05 - is how much time is left for the timer
117:07 - and this we can target quite easily
117:10 - all we need is the countdown timer
117:12 - itself
117:13 - and it has an attribute called time left
117:16 - so this is how much time is left
117:17 - after the timer has started but there
117:20 - are two problems with this right now
117:22 - number one is that this is a number so
117:26 - as always we have to use the string
117:27 - method just like
117:29 - with the other labels oh and let me do
117:32 - this properly there we go
117:34 - but there is going to be another problem
117:36 - and i think if i run
117:38 - this code this should demonstrate it
117:39 - quite well meaning that we have a lot of
117:42 - numbers
117:42 - after the digit which well isn't great
117:45 - and this is another thing with data
117:47 - types that so far we have only seen
117:49 - integers which is numbers without a
117:52 - decimal point
117:54 - numbers with a decimal point are called
117:56 - floating point numbers or floats in
117:58 - short
117:59 - and while floats can be generally quite
118:01 - useful in this case we really don't want
118:03 - them so we want to convert the float of
118:06 - our count on time at time left to an
118:08 - integer
118:09 - which we can do really easily by using
118:10 - the in method which just takes a float
118:13 - and turns it into an integer
118:15 - so that's all we have to do in our code
118:17 - editor so before count on timer
118:19 - i type int and then i just copy and
118:22 - paste
118:22 - or cut the entire thing in there and now
118:26 - if i'm running this
118:28 - we can see let me lose one
118:31 - there we go and all of this is starting
118:34 - again
118:35 - but now right now it starts at one and
118:37 - goes to zero
118:39 - and this seems quite weird so i'm going
118:41 - to add
118:42 - one to this so just plus one
118:46 - and now two one and then we start
118:52 - and yeah i think that seems okay so
118:55 - there's one more thing we need to do
118:57 - that now when the timer is not running
118:59 - or when a timer has finished we want to
119:01 - hide
119:02 - this text because we don't need it
119:04 - anymore and this we can also do really
119:06 - easily
119:08 - so once the timer has run out i want to
119:10 - target the note again
119:12 - so count on timer and i want to target
119:15 - the visibility which you can see down
119:17 - here
119:18 - and there's visible and you can switch
119:20 - it on and off
119:22 - so i can go visible and this is going to
119:26 - be
119:27 - false false
119:30 - and here again this is directly using a
119:32 - boolean so far whenever we used an if
119:35 - statement we implicitly used a boolean
119:38 - so let me go with this one here if this
119:42 - value existed
119:43 - this line would be true
119:46 - but we can use boolean values
119:48 - immediately so you can use false and
119:50 - true
119:51 - in cases like this so if something is on
119:53 - it's true something is off it's false
119:56 - and what i want to do for our timer is
119:58 - that when the timer is running out we
119:59 - want to set this to false
120:01 - however when we are scoring a goal i
120:03 - want to set this to be true again
120:06 - so once the score is achieved i also
120:07 - want to set
120:09 - the countdown timer dot
120:12 - visible is equal to
120:16 - true and then by default i want this to
120:19 - be off so we can't see it when the scene
120:21 - is starting
120:22 - and let's try all of this so we are in
120:24 - our game again we can't see it by
120:26 - default
120:26 - and let me lose and the game crashes
120:30 - and the game crashes for a very simple
120:32 - reason targeting the count on timer
120:34 - i need to target the countdown label and
120:37 - the countdown timer
120:38 - is always invisible so this one wouldn't
120:40 - make sense
120:42 - so count on label and now this should be
120:44 - working
120:45 - so now let's start off this again and
120:48 - two
120:49 - one and go and there we go we have our
120:52 - countdown label
120:55 - so seems quite good now
120:58 - we are basically done with the entire
121:00 - game and we already have
121:01 - the really basic setup all that's really
121:04 - left to do
121:04 - is a couple of fine tuning things and
121:06 - adding the sound and that's going to be
121:08 - coming in the next part
121:11 - so adding the sounds is a really simple
121:12 - thing to do we just have to add a couple
121:14 - of notes and
121:15 - then it's basically done it's as easy as
121:17 - that
121:18 - but besides that we have to add another
121:20 - thing and this is something you have
121:22 - seen earlier a tiny bit
121:23 - that because we are moving with physics
121:26 - it can happen if the ball hits a pedal
121:28 - at a certain angle
121:29 - that the pedal is moving which i want to
121:32 - avoid
121:33 - and my fix for this is going to be the
121:35 - simplest one i can think of
121:36 - and all i'm really going to do is to
121:39 - reset the pedals on each side
121:41 - every time a score is being achieved so
121:43 - if a pedal is being moved to his side
121:45 - during the game
121:46 - it is going to be reset once the game
121:47 - restarts
121:49 - and that is just a couple of lines of
121:51 - code nothing fancy
121:53 - so let's start with the sound that's the
121:55 - much easier part
121:57 - and let's actually jump right in so here
121:58 - we're back in our level scene
122:00 - and what i want to add is a couple of
122:03 - sounds
122:04 - i want to add a sound to the ball that
122:06 - if the ball hits either of the pedal
122:08 - or with either of the walls then i want
122:10 - to play one sound
122:12 - and if a score is being achieved then i
122:13 - want to play another sound
122:15 - so let's start with the sound of
122:16 - achieving a score
122:18 - so with our level selected i'm going to
122:20 - add another note
122:22 - and the note we need is called an audio
122:24 - stream player
122:26 - and when you type just audio stream
122:28 - audio stream player you can see we have
122:29 - an audio stream player
122:31 - an audio stream player 2d and an audio
122:33 - stream player 3d
122:35 - and now you might be wondering why do we
122:37 - need spatial awareness for our sound
122:40 - and the answer is quite simple think of
122:42 - if you have a 3d scene
122:43 - you might have sound behind a wall or
122:45 - really far away
122:46 - and if that's the case you want the
122:48 - sound to be less loud
122:50 - same for 2d if the sound is really far
122:51 - away you want it to be less loud
122:53 - whereas for audio stream player this one
122:55 - doesn't care about space it will always
122:56 - have the same volume
122:58 - so this is what we need so i click on
123:00 - create
123:02 - and i want this to be score it's called
123:05 - score sound
123:07 - and in our asset folder we have a couple
123:10 - of sounds
123:11 - we have 8 bit beep and 8-bit blob
123:14 - let me drag this up a bit so beep and
123:17 - blob
123:18 - the score sound had to plop sound so all
123:20 - i have to do is to drag and drop this
123:22 - file
123:23 - into the stream and here you can preview
123:26 - this thing you have playing
123:27 - and auto play playing means it is
123:29 - literally playing all the time
123:31 - auto play means it's starting when the
123:33 - game is starting
123:34 - so if you want to click on play you can
123:36 - hear the sound right now and let me
123:38 - click on it
123:40 - and you should be able to hear a very
123:43 - long and monotonous sound
123:45 - which well is not intended and what is
123:48 - happening here
123:49 - is that godot is repeating the sound all
123:51 - the time
123:52 - whereas we only want to play it once and
123:55 - this we can achieve very easily
123:57 - all we have to do is to go to the import
123:59 - setting next to rsc3
124:00 - something we haven't seen so far
124:02 - actually but in here you can set
124:04 - specific variables on how something is
124:05 - being imported
124:07 - and for otg files that's a sound format
124:10 - you can click on loop
124:12 - so is this file being imported as a loop
124:13 - or just as one specific sound
124:16 - and i want this to be one specific sound
124:18 - so i deselect loop
124:19 - and click on re-import and now we have
124:22 - only one sound
124:23 - so if i click on playing
124:26 - you can hear it only for a very brief
124:29 - period of time
124:31 - so exactly what we want and while we're
124:34 - added
124:34 - i also want to do the same thing for the
124:36 - other sound
124:37 - just so we have it all ready and now we
124:41 - have our sound
124:42 - all we have to do now is to play this
124:44 - whenever we achieve a score
124:46 - so for that i am going back to my code
124:50 - by pressing f3 and here we already have
124:52 - a score hd function
124:54 - so all we have to do in here
124:57 - is target our
125:00 - score sound and we just wanted to play
125:05 - so then it's going to play the sound
125:06 - once and let's try this
125:11 - and yeah i hope you can hear it it's
125:14 - quite short
125:15 - but it's definitely there
125:18 - cool so now we have the score sound the
125:20 - one thing left is we need to do the same
125:21 - thing for our ball
125:23 - so i open the bald script and
125:26 - in here what i want to do is whenever we
125:28 - have a collision i want to play the plop
125:30 - sound
125:31 - or the beep sound this one and we
125:34 - actually already have that
125:35 - so we know if this one is true we have a
125:38 - collision
125:39 - so in here we could execute the function
125:42 - for this but obviously we first need a
125:44 - node
125:44 - let me open the entire ball scene again
125:47 - and in here i'm going to add another
125:49 - note that is also going to be an audio
125:50 - string player
125:52 - and this one is going to be collision
125:56 - sound and now i want to add
126:00 - the beep sound and let me preview it
126:05 - and yeah sounds like a collision
126:08 - and it only plays once so now in here we
126:11 - can just
126:12 - play it so collision sound
126:15 - dot play
126:18 - and now let me run the entire game by
126:20 - pressing f5
126:21 - [Music]
126:23 - and yeah this looks good um
126:26 - you might want to work on the sound
126:27 - design a bit but those
126:29 - i think are fine for a test game okay
126:32 - and we are almost done the one thing
126:36 - left to do
126:36 - is now a level scene let me open it
126:40 - is that whenever a score is being
126:41 - achieved i want to reset both of the
126:43 - players with a certain distance to their
126:45 - respective side
126:47 - and for this let me open the code we
126:49 - just have to work in this function
126:52 - and set the x position of each of the
126:54 - players
126:55 - so i want to target my player
126:59 - the position of the player and then the
127:01 - x position of the player
127:04 - and in here let me put it at 35 so it's
127:07 - 35 pixels from the left side of the
127:09 - screen
127:11 - and now the same for the opponent dot
127:15 - position dot x and we know our entire
127:18 - screen
127:18 - is 1280 pixels wide and from that i want
127:22 - to subtract
127:22 - 35 pixels and that is really
127:26 - all we need to do so let me run the code
127:28 - now
127:30 - and this is probably going to be a bit
127:31 - difficult to see you can see it
127:33 - very slowly but
127:36 - this would if we have any kind of
127:38 - physics
127:40 - mistake this is going to fix it quite
127:41 - drastically
127:43 - so with that we have a finished game

Cleaned transcript:

hello in this tutorial we are going to be creating this pong game and since pong is a fairly simple game this isn't going to be too difficult so if this is your first game in godot or your first game in general this tutorial should be quite easy to follow but if you're looking for specific things here are all the steps i will be going through and if you already know some godot it's probably safe to start in this stage and if you happen to like this tutorial check out my python game development course in there you'll be learning much more sophisticated games in python and good dough including a firstperson shooter but with all of that covered let's talk about godot so what is godot well godot is a game engine and all that really means is that godot is a program that helps you make video games so when you make your game in godot you see immediately how your game would look like and you can drag and drop elements on the screen and see changes instantly which is a much better way to create video games than just looking at hundreds of lines of code and godot is by no means the only video game engine there are loads of alternatives but the one thing special about godot is that it uses gdscript which is essentially python so if you know python and you want to make video games then godot is the best option by far but to use it we first have to install it which is actually super easy all you have to do is to go to godotengine.org then go to download and then download the version of godot that is appropriate for your operating system in my case that's windows and once you finish the download and unzip the file you should see a folder like this and in there all you have to do is click on godot and then you can see the project manager and in here you could either open an existing project or create a new project in this case it's empty because we haven't created any projects yet but to do that we have to click on new project and then godot was asking us for a name and a project path in my case i'm going to call this file pong i already have a file path that i can paste in right now and godot needs to have an empty folder so this is what i'm going to create here and then we have a few more options for the renderer but this one is not going to matter for this tutorial so i leave it to the default option but that is all we needed so now we can click on create an edit and then we are getting into our game so with that let's talk about how godot works all right now that we have our basic project here's what we can see and there are quite a few elements on the screen right now and i am going to explain them when we get to them but for now don't worry too much about them and before we are getting into anything in godot i would really like to start explaining how godot works on a more fundamental level because that is really going to help us understand later on what we are doing so the door relies on two fundamental concepts to function the first one is called nodes and nodes are the really basic building blocks that actually create your game so for example a node could be a picture a note could be a timer a note could also be a 3d object it could be lots of different things godot has a few hundred of them and they effectively create your game so when you see for example a player character this one would be created out of different notes coming together for example one note would be the picture another note would be the physics calculation another note might be a skeleton animation but what you essentially do in godot is that you put different notes together and move them around on the screen and that creates your game and that's really it you have a couple of notes on the screen and you can influence the attributes and via that you can move them around and that's really all you need to create a game they can do quite a few more things like communicate with each other or have specific code but what you really have to understand is that nodes create your game they are the most fundamental concept in godot and what we are going to work with the most by far but here's one problem by default nodes are not visible which is kind of a problem for a video game so we need a second concept and that second concept is called a scene and scenes in godot serve two purposes number one is that they are canvas for your notes so what you effectively do with your notes is that you put them on a canvas and what the player later on perceives as a game is the scene with all the notes in it so a scene basically displays your game and besides that scenes are also really powerful to organize your game and the reason for that is that we really easily end up with quite a few different notes to organize our game so if you have any even slightly more complex game you will end up with hundreds of different notes which by itself would get really unreally and complex to work with so instead what we can do is have different parts of our game as individual scenes so for example a player could be its own scene and then you put this player scene into the level scene and via that you can work on each of these elements independently and focus on one specific thing and with that your game remains much more modular and much easier to work with and that's basically it if you understand these two concepts you already have a really good starting point for godot so let's actually have a look at how this works in practice so here we are back in our godot editor and what we can see right in the middle of the screen is called the viewport and this viewport shows our open scene right now and what we have at the moment is a 3d scene and if you hold the middle mouse button in here and move the mouse around you can move around in space and if you look at the top of this window you can see a tab right now it says empty and you could save it and give it a name and you could save all the notes you want in there but we don't want a 3d scene right now because our game is 2d and to change between a 2d and the 3d scene you have to look all the way at the top and there you can see 3d and 2d and if you just click on 2d now we can see a 2d workspace and in here you can see this blue rectangle and this is the actual size of our game so if you want to put anything on the screen it has to be inside of this blue rectangle for the player to see it so this is really important so this would be a very basic thing to look at the different scenes in your game and if you want to create a new scene you just click on the plus icon and then you would have a new scene and you can create more it's really up to you but right now i only want to keep this one scene and i want to keep it in 2d so now we have a scene but obviously you can't really see anything on the scene right now and to actually display something we need a node and to get notes you have to look at the top left of the screen and there you can see what's called a scene tree and right now we can choose different nodes we can choose a 2d scene a 3d scene a user interface or another node and if you click on other node you can see a fairly long list let me open up all the different subfolders these are all the different notes that you can have in godot and here you see lots of different things for example you have a skeleton you have a visibility notifier you have a touch screen button you have a polygon 2d you have particles and you have something called a sprite and a sprite is what i'm going to start with for now and this is really just a picture and you might be asking right now there are so many different notes in here how do you find anything and for that you use the search function and in here you can just type sprite and then get the sprite node that you want and it will take you some time to learn about all the different notes but once you get even a little bit of practice this will come very natural to you but okay so with the sprite selected i click on create and now we can see in our same tree that we have a sprite node but in the viewport we can only see this red cross here so how do we add a picture to this node and for that you have to look all the way to the right and there we have the inspector and in the inspector you can set the attributes of this node and right at the top we have what's called a texture attribute and if you hover over it godot gives you a description of this property and it says texture object to draw and what this one effectively does is it takes a file of a picture and it displays it so now what we need is a picture and we do have that if you look in the bottom left there we have a file system and by default every good old project always has one default file that's called eigen.png which is the godot logo and all you really have to do is to drag and drop this icon into the texture slot and you can already see when you drag the file there's this blue line around the file so let me drop it in and now we can see our picture so this one works quite well and if i zoom out a bit we can also move this picture around and place this wherever you want to have it on the screen and let me put it roughly in the middle so this would be one attribute of the sprite node you could also look under transform here you can see position rotation and scale so in here you could for example rotate this image or you could scale it up in different axes which i don't want to do right now but this is really what you have to understand for godot that what you effectively do is you take different notes and you affect their properties and this can be done either by using the inspector or it could be done in code which is what we are going to see in just a little bit but for now let me save this scene and to save a scene you can either press ctrl or command s or go to scene and save scene and if i click on it we can see the folder again we created earlier and in here i want to create a new folder that i call player let me just spell it correctly and now in this folder i want to save the scene also with the name player and gudu's scenes are always saved with the file ending tscn which i guess is short for scene no idea but it doesn't really matter so click on save and now at the top of our scene we can see player and what we can do now is actually run the scene and see how our game would look like and to do that you have to look all the way at the top right and there we can see play we can see play scene and we can see play custom scene what really matters for now is play scene or f6 and let me click on it then go to loads for a bit and here we can see our game or well not really a game but the picture and you can't do anything right now but you can see your game and if we add a bit more code this could be interactive so we could have user input here we could have enemies in here we could have a moving ball in here this works just like a game but for now let me close it so this is really the most fundamental concept in godot that you work with seeds and with notes there's one more concept i do want to cover before we are getting into the actual player character and that is that in the century the notes are always in relation to each other and let me illustrate what this means so with the sprite selected i want to add another node to this that is also going to be a picture and to add another node you have to go either click on this plus icon or press ctrl a and let me add another sprite node so we have another picture and what we can see right now is that we have one sprite at the root of our same tree and another sprite connected to it and what this means is that this bright is a child of this node and they're usually called parent node and child nodes and this has direct implications for your game and let me actually add an image to this second sprite node so again i just drag and drop this icon and then there and we can't see any change right now because the images are on top of each other so let me move this image a bit to the side so we can see our sprite node selected here the one to the bottom right and our parent node the one right in the middle now here's the really important thing if we make any changes to the parent node we are also going to affect the child node however when we move the child node we are not going to affect the parent node and let me demonstrate what this specifically means so if the parent node selected i just move it around and while we're doing that we also move the child node and this would also apply if i go back to transform if i rotated it it would also rotate the child node and if i scaled it same thing whatever we do to the parent node we are also going to do to the child node and this is going to become really important to create our player character in a little bit because we want to have one note that controls the entire player character and all the other notes on the player character always move in the same direction as this note that actually controls the player but i'm getting ahead of myself i think we have made some good progress for now so let's actually start talking about our player character so let's talk about creating a player character which in our case is going to be a paddle that has a couple of functionalities and let me go through what we want our player pedal to be able to do the first and most important thing is that we have to be able to see it so there has to be some kind of picture on our pedal and this one should be straightforward if you can't see your player character you don't really have a player character number two is that we have to be able to control this player character so if you're pressing a button on our keyboard this thing is actually moving so this is another really important thing and besides that our player character also needs to have the ability to react to physics and this is actually a really important part that we want a ball to bounce off this player character later on and this is a physics calculation and this is going to require a specific node in godot that can actually work with physics and in total the dough has four different nodes that can work directly with physics at least in 2d space and these are called kinematic body2d rigidbody2d static body2d and area2d and they all work with physics in slightly different ways and i'm going to go through all of them bar 1 in this tutorial so i will explain every single one of them when we get to it but for now the one we are going to work with is called the kinematic body 2d which is the most powerful kind of physics body in godot and this one is usually the note used for a player character because this one can influence other physics bodies and it can also be influenced itself by other physical bodies and we can move it in code so this one is really powerful and really useful for us and this node is actually going to be the foundation of our player character but there's one problem that's going to sound a bit weird that the kinematic body by itself doesn't have a physical body and this is going to need another note that's called a collision shape and think of it like this a kinematic body 2d by itself is essentially an atom in space it can be influenced by physics but it's so small you can't see it and it's also so small that it can't really collide with anything so we have to give it a physical shape which is an entirely new note but this is basically all we're going to use for our player so let's actually implement all of this so here i'm back in my player scene and what i want to start with is to get rid of some notes so this child sprite note i don't need so i'm going to delete it so deleting it you can either go to right click and delete node or press on delete and then godot is going to double check and i do want to delete it now our sprite node i don't want to get rid of i want to change it which you can also do and all you need to do is to right click on the node and change type and then godot brings us back to the menu and here we can choose a different note and what i want to start with is called a kinematic body 2d and do be aware it has to be a 2d one there's also a kinematic body this one is threedimensional so make sure to not use that one we want a kinematic body 2d and really easy way to tell between 2d and 3d notes is that 2d notes are always blue 3d notes are always red so that makes it kind of easy but ok we want a kinematic body 2d and if you double click on this you can also rename it so i want to rename mine to player and here already godot was giving us a warning that this note has no shape so it can't collide or interact with other objects consider adding a collision shape to d or collision polygon 2d as a child to define its shape and let's do that so i click on the plus icon again and let me get rid of this and i want to add a collision shape 2d and you could also use a collision polygon we're going to see this one later it works in very similar ways but for now i'm going to use a collision shape 2d so click on create and now we have our player parent node and a collision shape 2d as its child node and here we get another warning that a shape must be provided for the collision shape 2d to function and to give it a shape you have to look back into the inspector and there we can see shape and there we have a drop down menu and here we can select a couple of different shapes and this is going to be the physical body of your player character so you want to select a shape that resembles the player's shape as closely as possible which in my case i think is going to be a rectangle shape 2d which is well a rectangle and once you have clicked on that you can see this bluish icon with a couple of red dots and these red dots you can use to change the scaling of this rectangle and let me zoom out again so what we want is to resemble our player shape which is going to be a paddle somewhat reasonably well which is going to look something like this and this would be the shape that the ball is actually colliding with later on and what i also want to do is that right now our player pedal is in the middle of the screen because i moved the sprite there earlier and i want to change this back to 0 and 0. and for that i went to the inspector to transform and here we have the position you can either type in 0 0 in here or we could just use this icon and then we go back to position 0 and 0. and ok i can close this again and now we have to collision shape for our player but let me save this scene now if i were to run this game now by pressing f6 again or the icon we can't see anything because a collision shape is invisible to the player which makes sense you don't want to see the actual collision box that the player has around itself so we have to give an actual image to our player and the problem for that right now is that in our file system we only have the default godot icon which well doesn't really work for us so we have to import a couple of images and that is super easy to do in godot and all you have to do let me open my file so this pong folder is the point folder we used earlier to create our game and above that i have an assets folder and all i have to do is to drag this assets folder into the profile and then go back to godot and then it loads for a bit and now we have an assets folder and in the assets folder we have a ball a pedal a couple of sounds and a font so how our text would look like so these are all the things we need for our game it's actually very simple so let me close this folder again and i'm not going to use the icon psg anymore so i'm going to delete it and to delete it i right click on it and click on delete and then godot is going to remove the file from the project and can't be restored and i'm fine with that so okay now our game looks a bit cleaner and with that let's actually add the image to our player and if you want to challenge yourself for this tutorial now try to add the picture yourself to this player note so you could just pause the video now and try to do it yourself and continue after you're done and i would really recommend this it helps you to learn so much but let's do it together so with the player selected i'm going to click on the icon again and i'm going to add a sprite and you can also see our sprite note in the recent tab so i click on create and now we have a sprite and i just need to drag and drop the image of the pedal into it so i drag and drop the pedal into it and now we can see our pedal or the image of our pedal but there's one obvious problem right now that the shape of the pedal and the image of the pedal have different sizes so we have to resize the pedal a little bit to properly be above the pedal image and there's one thing you also have to realize that in the note 3 the order really matters so right now the collision shape 2d is below the sprite and this you can also see in the viewport and let me reverse the order by just dragging it below now our sprite or the image is below the collision shape and this kind of thing is becoming important later on quite a bit where you want to control what elements are on top of each other so always be aware if something is further down in the century it's usually above the other nodes in the actual viewport but in here i want to make sure i drag all of the white part of the paddle inside of our collision shape and if you click on the blue part you can also move the entire shape around and if you hold shift then you move it only in one axis which can make things a lot easier and i want to make sure i only cover the whitish part and let me yeah okay i think this looks good if you want to be more precise with this you can also click on the rectangle in the inspector and in here you can give it very specific coordinates so you could for example let me go with 14 and 60 so we have cleaner numbers although that doesn't really matter but okay now we have our player character this is really all our player character is ever going to be it consists of a kinematic body an image and a collision shape this is literally all you need to create a player so let me save the scene by pressing ctrl s and run the scene and now we can see our player in the top left which isn't too good so let me drag the entire thing a bit more to the middle and i can do that either by having player selected and going to transform and moving it here so i could press something like 100 and 500. let's say more like 300 or you could just drag and drop it but there's one more problem before i finish this part if you were to just select this thing and try to drag it you would only select the node furthest down in the scene tree so the collision shape in this case which would be a problem because our play would collide in this shape but we would see the player here so this is no good so what we have to make sure is that when we have this player selected that we can't move the sprite or the collision shape and for that you have at the top here an icon that looks like this it's very hard to explain all it does is make sure that you cannot select children nodes and if you click on it you can see this icon here and if that's the case you can only select the parent node not the children nodes and this makes sure that all of these nodes always stay in the same place so now i can move it roughly let's say to left side of the screen and this is a really important part i do want to talk about that to create our game we are basically creating an allusion to the player that what the player is actually going to control later on is the kinematic body 2d so one specific point in space it just happens to be that attached to this note we have an image of a pedal and a shape with the size of this pedal so the player assumes all of this is one object but in reality it really isn't but uh but okay i think this part is getting quite long so let's get to the next stage and that is to actually give our player the ability to move which is what we are going to do with code so let's have a look at that so let's talk about how our player can move and for that we have to talk about programming in godot and there are different languages you can use to code in godot the language we are going to use is called gdscript which is insanely similar to python i talked about this earlier in this video but it's also a really simple language so even if you never code it before this should still work for you or at least i hope it will but before we're getting into specific code there's one important concept that in goodu code is always connected to a node and what you effectively do is you take a node and take all its attributes and you create additional capabilities and each node can be expanded in different ways so for example a kinematic body 2d can get different functionalities compared to a sprite note for example but you don't have to worry about this too much for now let's actually start creating some code so here we're back in our player scene and i have our player notes selected and to create a script you have to use this icon here which says attach a new or existing script to the selected note so i click on it and now we have a couple of options the first one is the language we want to use and we want to use gdscript then we have inherit and this is the node we are starting from that we are going to use to expand its capabilities so kinematic body2d node is fine then we have a template as default empty and no comments i will leave it now at default but later on you definitely want to start with empty then we have builtin script which is just asking you if you want to save the script as its own file or as part of the note it's usually left off but it really doesn't matter and then we have the name of the file so player in my case and what we want to store it also in the player folder so all of this is fine by default usually so i click on create and now at the top we can see script and we can see our script and if you want to go back to your viewport you can just click on 2d at the top or go back to script and you can also use the f keys to switch between them where f1 is 2d f2 is 3d and f3 is the script view and this does make it quite a bit easier to switch between the different views and i'm going to use that quite a bit but alright in here we can see a couple of examples godot provides and let me actually get rid of this part down here but we are going to come to that later on so what you see here right now is that you can declare a member variable and a variable in essentially any programming language is a box that you can store information in and this can be either a number like the number two or it could be text and text is usually called a string and a number without a decimal is called an integer so these are different data types although that really isn't too much at this stage if you're new to programming but okay let me get rid of all of this because we don't need it so just to get it started i want to create one variable so i use the keyboard var and now i have to give the variable a name and i want to go with speed because i want to use this variable to determine how fast our player can go and i need to assign it a value and this is done with the equal sign and now i have to type a number how fast i want my player to be and i want to go with 400 and i've chosen this number by just trial and error so if you play around with this later on there are lots of different options there's no universal one just choose whichever one looks best but all of this is still just a number it doesn't actually do anything in our game and to actually do stuff in our game we need a function and a function is really just a collection of different lines of code that you all execute as one block and usually for a function you have two steps you first have to create a function and then you have to call the function and this basically means that you first have to create your code of block and then you have to use the code of block in specific spots where you want to use it in godot this is slightly different that you have two different kinds of functions you still have the normal functions that you have to create and call yourself but you also have inbuilt functions and these functions you only have to create you don't have to call them yourself because godot is going to call them at specific points in your game so for example we have a ready function and this function is always going to be executed when our scene is ready or there would be an input function that is always executed when we get player input so for these functions godot determines when they are being executed which is really useful for your game and for our player we actually do want to start with an inbuilt function and really what we want is to have a function that is being executed on every single frame of our game so essentially a function that runs constantly and godot has two of them they are called process and physics process and those two functions are incredibly similar and you don't have to worry about the differences in too much detail yet at least for this stage just keep it at process is usually used when you don't care about physics and physics process is being used when you really want to calculate physics calculations which in our case we do want to do so we are going to use that function but again lots of theory let's actually get back into our code editor and let's implement this so here i'm back in my code editor and let me go to a new line and to create a function we need to func keyword and now we need the name of our function and in my case this is physics process and into this function you can pass what is called an argument and godot by default passes in an argument in here that's called delta and all an argument really does is when you're executing a function is that you can tweak the parameters so this one can be useful to find tweak what the function is doing and what delta does in godot is that it makes sure that the game always runs at a consistent speed which isn't something you have to worry at this stage in too much detail so i would recommend to just ignore it at least for now all right if you press enter now godot is going to go to the next line and it's going to indent the next line and this indentation is really important it means that whatever code is below and indented in this function belongs to the function so further down the line if you created more code below this function that is not indented it would mean it doesn't belong to the function but now in this function we have to give our player the ability to move around and to move around we are going to need three different steps number one is that we actually need player input so that we check if the player is pressing up or down in my case but could be any kind of input number two is that we are storing this input and number three is that we're actually applying this input to our player and let's go through this step by step and before getting to the input i do want to start with some kind of variable that can store the user input and i'm going to use a vector and if you paid attention in high school you might remember a vector but vectors are generally useful in game development and really important and fortunately they're also quite easy a vector is essentially an arrow that can point in different directions and what we want is that by default we have a vector that doesn't point in any direction but if we're pressing the up key we want it to point upwards and if we're pressing the down key we want to point downwards and that's really all we need so let's actually create this so here i'm back in my code and i want to create a new variable so again i need the var keyword and now i have to give this variable a name and usually this one is called velocity which i am remarkably bad at spelling for some reason my brain just can't get around it all right now we want to create a vector and for that we just need the vector keyword and godot now asks us do we want a 2d vector or a 3d vector and since we have a 2d game we want a 2d vector and now when you press a dot you can access its attributes so what the arrow is pointing at by default and what i want to go with is 0 all in uppercase letters and this means that by default this vector is 0 0 so it doesn't point in any direction it's just the point in space although we can influence this and that actually comes now because now we're getting keyboard input and for keyboard input we need a specific keyword that is called input and here again we need a dot sign to use a specific part of this input so the input is essentially a large object it has lots of different functions that you can all access with a dodge and the one we want to access is called is action pressed and all this does is it checks for specific keys and here you have a list that i predefined but you could create your own and what i want to look for is ui up which is the up key on your keyboard so if i click on this we have it as an argument inside of this function and this is actually bringing us to a new data type and that is a boolean and booleans can either be true or false so in our case if we were to run this game and we press the up key this entire line would signal that something is true and if we don't press the up key it would be false and to actually use this in code we need an if statement so that if all of this is true we want to do something and else we don't want to do that and then to finish this line we need a double colon and now when i press enter again we again start on an indented line so this means that anything that comes below is only being executed if this line is true so if we are pressing the up key and if that is the case we want to target our velocity again so here be aware in here we are creating velocity and here we are using velocity so you only have to create a variable once once you have done that you can just use the keyword and work with it and a velocity has an x and a y attribute that you can influence with x being the horizontal one and y being the vertical one so we want y because we want to go up and down and all we have to do in here is to change this number to a different number so it's pointing in a certain direction so i want to take this value and subtract one from it which happens with minus equal and one so this kind of operation is really common in programming languages it basically means we're taking this value and subtracting one from it so this would be the same as velocity dot y equals velocity dot y minus one these two lines do exactly the same thing except this one is quite a bit faster to write okay and this is all we need for this one line to move the player upwards but obviously we also want to go downwards and here again if you want to challenge yourself pause the video now and try to implement the code for the down movement but to do it all you have to do is to copy this line or really type it yourself it doesn't matter and now instead of looking for ui up we want to go for ui down and in here instead of subtracting 1 we want to add one and this is something that might be weird to you right now that if you want to go up we have to subtract from y and if you want to go down we have to increase y which is going to be really strange if you paid attention in high school so let me explain in high school when you saw a coordinate system it always started in the bottom left so if you went to the right you have to increase x if you want to go up you have to increase y which tends to make sense in most video game developments this is slightly different because the origin point is in the top left meaning that if you want to go to the right you still have to increase x this one stays the same however if you want to go down you have to increase y and if you want to go up you have to decrease y which is honestly really counterintuitive and is going to take you some time to get used to but it just became the standard in quite a lot of engines i have no idea why but you will get used to it eventually so don't worry about it too much but with all of that covered we have the two first steps to get input we have code to get input from the player and we can store the input now we just have to apply this input to our player and this happens with the move and slide function so i type move and slide and in here godot already gives us some hints in terms of what it needs and the first argument it wants in here is a linear velocity which we have it's our velocity and well that's all we needed so let me save this entire thing now and let me run this scene by clicking again on this icon at the top or pressing f6 and now we can see our player and let me move up and we can see that our player is moving up just very very slowly and that's for a good reason let me close this again because we are only moving it by one unit but we want to move it by this 400 and so all we really need to do is to multiply this one by 400 so when we call this move and slide function we just multiply velocity by our speed and now if i run this again by pressing f6 now we can move up and down this feels so much better okay and there was a ton of theory in this part of the video so i think it's good for this section so let's talk about creating our level for now our entire game consists of a single scene and that's the player scene but obviously this is quite limited because we want to have other elements in our game as well we want to have a ball and the opponent at the very least and each of them is going to be their own scene but we have to bring all of them together into one big scene and this is going to be the level scene where we actually going to create our game logic and our level doesn't actually have to do all that much it's quite a simple thing it really only has to carry all the other scenes and have a bit of extra code to reset the ball for example or to limit the movement of the player so let's actually go right in and let's create this so here i'm back in my game and what i want to do is to click on this plus icon and create a new scene and we are still in the code view so i go back to 2d and here we can again see our 2d space and now we have to determine what kind of node do we want and in this case you could go with a 2d scene but you don't really need it so i'm going to go on other node and i'm going to just click on node which is the base class for all scene objects which is a fancy way of saying this node is a really basic node that can't really do anything by itself and let's click on create so now we have a node and let me rename it to level right away and if you look into the inspector you can't really see anything so we have pause and script but they don't do much so this note is so basic it doesn't really have any attributes so it can't do all that much but it is really useful to organize your code so you can put other nodes connected to it and this is what i want to do i want to connect our player scene to this level node and for that we have to instance our player into this new scene and let me actually save it before we do anything so right now when you look at the tab it says unsaved so i press on control or command s and here again we can see our folder and i want to create a new folder that i'm going to call level and in here i want to save this scene as level scene because our root node is called level so click on save and now we have our level scene and now with this level selected click on this chain icon and this is the instancing icon and if you click on this you can see all of our scenes we have a level scene and we have a player scene and we want to play a scene so i click on open and now we can see our player scene inside of our level and it is still going to have the same capabilities so if we were to run this scene now our player character would still work in exactly the same way and let's actually try this so again i press on f6 and now we have the very same thing even though we have a different scene so now we're running the level scene not the player scene but the player scene is part of the level scene okay cool so this works quite well and now we can actually add more useful stuff to this and the very first thing i want to add is that let me run the game again if i go up and down we can move outside of the screen which well is unintentional so we want to add something that the player can't go outside of the screen and there are different ways to achieve this but before work on this i do want to work on how large our game is supposed to be so let me close this so right now here our game has the size of this blue rectangle and we can influence how large this is going to be and to influence this you have to go all the way to the top to project and project settings and in here you have all the settings for the project and if i go down a little bit there we have display and window and in here we can change the width and the height of our window and by default this is always 1024 by 600 and you can't leave it at that it's perfectly fine but i feel like 1280 by 720 tends to feel a bit better but it's really up to you you can also change if it's resizable or borderless or full screen it's really up to you play around with this but for now i'm not going to worry about screen scaling in any meaningful way so i'm just going to close it and now we can see that our blue box has increased in size by quite a bit and if we were to run this game we'd also see it is quite a bit larger now so we know this is working good start but now the actual important part we want to limit our player from moving outside of the screen and we can approach this in two different ways one is that we can give our players some code that it can't move outside of the screen or number two we could use another physics body to limit the movement so so far we have seen a kinematic body we can use another physics body at the border of our screen that the player would collide with and those would basically be walls and since for our ball we also want to use walls i am going to go with the second approach so we have walls that limit our player our opponent and also make our ball bounce so we have lots of functionality and one object which is really nice and for that we have to talk about another physics object in godot which is called the static body 2d and i think the name already explains it quite well it's well a static body that can't move by itself so it is essentially a wall and that is really it it's just a physics body that can't move by itself but if other objects move against it they will be influenced by its physics and static body 2ds also work like a kinematic body 2d that you start with a single note that has the physics and then you have to give this note a shape so let's actually create all of this so here i'm back in my level scene and with the level note selected i want to add another node that is going to be a static body and here again you have a static body in 3d and a static body in 2d and i want to go with 2d so i click on create and here again we have a static body 2d and we are getting an error message that this note has no shape so let's give it one so with this note selected and not the text i'm going to click on the plus icon and i want to give it a collision shape this one down here so click on create and still we can't see anything we get another error message again that we have to provide a shape and this happens again in the inspector and here i just click on whatever shape i want and i think again we want to go with a rectangle shape 2d because well the wall doesn't need any fancy shape a rectangle is fine so i click on this and now we have a wall that the player couldn't collide with and let me actually demonstrate this so i'm going to drag this out a bit and move it let's say here so when we run our game we should not be able to move past this point so i save the game and press f6 again to launch it and let's move up and indeed i can't move further up than this point so this is working but obviously we want to be limited by the top of the screen so we have to change all of this and move this entire shape to the top of this blue line and let me zoom in quite a bit if we want to be right on this blue or red line and to be more finegrained you can also use the arrow keys and move it up or down or you could use transform and use it here let's actually go with that so i have transform open and i also click on rectangle again so now we can see the dimension and the position and all we need to do is to change this to 10 and this is going to bring us exactly 10 units from the top of the screen and now we want to have this static body cover the entire top part of the screen so i'm just dragging it out and this would be fine or if you want to be a bit better looking for the game you can also move it to the middle and have the size a bit more appropriate for it so it doesn't move massively outside of it and yeah i think this looks about right and here if you look at our scene tree now we have a bit more of a complex structure we have a root note the level we have one child that's the player and we have a static body that's also child of the level node but now this static body 2d has its own child which is the collision shape 2d so if we were to move this static body we would move the collision shape 2d but if we move the level we would move both the static body 2d and the collision shape because they are both children of the level node ok let me rename this one to wall top and then you can minimize it which makes it easier to work within your game and this is giving us our turbo so let's try this by running our game and i can move all the way to the top of the screen but not further so this is working quite well cool so now we have to create a wall at the bottom of our screen and here again if you want to challenge yourself pause the video now and try to do this yourself but effectively all you have to do is to copy this entire wall top by pressing ctrl d and let me rename it right away toward the bottom and then you can just drag the entire thing down and here again you can see that i'm moving the collision shape not the static body although in this case it wouldn't matter too much because this collision shape is what actually matters but it doesn't feel good so with the wall bottom selected i'm going to click on this icon again that we cannot select the children and now i can move the static body down and let me zoom in again and i want to roughly move it at the bottom of the screen or if you want to be really precise about this you could also move it to 740 and okay this is all we needed and let me change the same thing so it's all consistent and let's run the game now and i can't move to the top and i can't leave the screen from the bottom so this is working quite well cool and we are making some decent progress and with that one done let's start by creating our opponent and the opponent is actually done in a really similar way compared to our player as a matter of fact it is going to have the same notes it is just going to have some slightly different code so instead of using keyboard import to move this one we are going to make this one move to wherever the ball happens to be but this part will come later when we actually have a ball for now let's just create a basic opponent so here again we are in our level scene and i want to create a new scene for the opponent so i click on the plus icon at the top to add a new scene and here we have the scene and what we want to do is to basically copy this player scene and do the same thing except for the code and this again could be a challenge if you want to code along pause the video now and try to recreate our player but let me go through it i want to start with another note that is going to be a kinematic body 2d and this time i guess that's one difference i want to name this opponent and again we're getting the warning but i'm going to ignore it for now because i want to start by adding the picture so i click on this plus icon and i type in sprite and i'm going to add the sprite and here again we're going to use our assets and the pedal it is the same as the player has and here now we have an opponent that is a kinematic body and a sprite now i want to add our collision shape so here you could add a collision shape 2d and this works just like for the player you can add a rectangle shape 2d and move it roughly in place to where this needs to be something like this so yeah i think this looks good and just for completion's sake what he could also do so let me just hide this one for now you could also use a collision polygon 2d this one works in basically the same way except now you cannot select a prebuilt shape instead at the top of the screen you can see these three icons that says create points edit points and delete points or erase points and what you basically do with a collision polygon is you are creating your own shape so when i click on create points i can literally just put points on the screen so if you have a more complex shape this one would be quite easy and then if you're at the last point just click on enter and then it finishes the shape so now we also have a square shape but this shape could be any point so if you added points you could create something much more complex but in my case i well don't need to so i'm happy by just using a collision shape because this one is much easier and we don't have any fancy shapes and yeah that's literally all we needed so now i'm going to save this entire scene in its own folder that i'm going to call opponent and again it's already named appropriately so i click on save and this is our opponent so now this i can also put into our level scene and here again i have the level note selected i click on the chain icon to instance it and put an opponent and now move opponent roughly in place okay this looks good so now let me save this level scene and run the entire thing we can see that we have two pedals and we can only move our player our opponent is not moving and we don't have a ball but that comes later but i think we're making decent progress there's two more things i would like to add though number 1 is to make this level scene our default scene so right now we have always only played a single scene and this happened with f6 but what we can also do is run the entire game as a whole and our game consists of different scenes but by default godot does not know which is the default scene it needs to start for the game and this we have to define ourselves and all this really means is when you click on f5 udo is going to ask you that no main scene has been defined do you want to select one and we do so click on select and here we would have all of our folders and i want the level scene to be the main scene so i click on level scene and now we can see our level again and now even if we were in our player scene i could press f5 and i could start the actual game how it's supposed to be looking when it's actually being played so this one makes it easier to launch games but okay let me close the player and the opponent scene closing them doesn't mean you delete them you can still open them from the file system so down here so down here you can just double click on the player scene and reopen it all right the last thing for the level is that this gray background looks absolutely hideous so i want to change it and to change it we have to add another note so with level selected i'm going to click on the plus icon again and i want to add a color rect which is well it's a colored rectangle kind of like the name implies so i click on create so now we have this colored rectangle in the top of our screen and let me zoom in a little bit so here you can see the color and you can influence the color here and i will talk about this in just a second but for now what you do have to be aware is that when you look at the color of this note it's green and this means that it's a ui note so godot essentially has four different kinds of notes we have the blue ones those are 2d notes then we have the red ones those are 3d nodes then we have the green ones those are ui nodes and then we have all the other nodes like the plane node for example is just another node it doesn't really have a specific group and ui nodes have a couple of specific parts that are really powerful and effectively what they can do is be really responsive to the size of the window so you can always make sure they're for example in the middle of the screen always cover the entirety of the screen which in our case isn't going to matter too much because the game isn't designed to be resizable although we could add that later on but we could for example make it cover the entire screen really easily let's actually do this so here we are back in our editor and with the color rect selected at the top you can see these two green icons that say layout and then you have this anchor kind of icon and if you click on layout you have lots of different options and what you can click is full rect and then this rectangle is immediately covering the entire screen and right now it's covering everything even our players which we don't want so i'm going to move this color direct above all the other elements so it's below them so now we can see our player and our opponent again and here you would have a couple more elements that we are going to see in a bit more detail later on but for now just be aware that ui elements have lots of options to arrange elements on the screen but okay now the white color doesn't look too good so we have to give it a different color and here we have quite a few different options in terms of how we are going to work with color we have rgba numbers we have hsv we have raw and we have hexadecimal numbers and every single one of them are a different way to create a color what we are going to use is the hexadecimal number which is the one down here and the number i want is 14 21 and 26 and now if i press enter we get a dark color and let me explain how this works hexadecimal number always consists of six different numbers that follow a hashtag and the first two ditches define the amount of red the third and the fourth digit determine the amount of green and the last two digits determine the amount of blue so the higher the number gets the more amount of this color we have and the way we are counting a hexadecimal number is going to look a little bit weird because we're counting from zero to one and then from a to f so basically goes one two three four five six seven eight nine ten a b c d e and f so there are 16 different stages that you can have and then you have three different colors and you essentially mix them and i hope that makes sense okay with that we have our background color so now when i press f5 this does start to come together and look quite decently so with all of these parts covered let's actually start talking about how to create our ball so our ball is going to be the most complex object in the entire game which basically means it's going to be the object with the most amount of code but in terms of notes our ball is actually going to be remarkably similar compared to the player and the opponent we will still start with a kinematic body2d add an image and add a collision shape and i think you really start to notice that there is a pattern that most objects in godot work in really similar ways that you always have some kind of physics node then you add a picture and then you add a collision shape and this can be more complex for example the image could be an animation or the collision shape could be more complex but really at the most basic level most objects in godot work really similarly so it's really easy to create them so let's start to create our ball so here we're back in our editor and i want to create a new scene and again i'm going to pick another note and here again i'm going to pick kinematic body 2d and i'm going to rename this one to ball and i'm going to add the sprite and i am going to add a collision shape 2d and for the sprite this time i'm going to go to my assets and add the ball and then for the collision shape let me zoom in a bit i am going to pick a circle shape 2d this time because now we have a circle we don't have a rectangle anymore and in here now we only have one red dot because a circle is a bit of an easier shape and i'm just going to drag out this red dot to make sure this circle roughly matches our ball and that's all we needed so now let me save this in a new folder that i call ball and save this as ball dot scene cool and now i go back to my level scene and instance the ball into it now we can see the ball on the top of the screen and let me move it roughly in the middle of the screen at least for now and that's all we need for the basic ball so if we run the game now by pressing f5 we can see all the very basic elements of our game so that's a pretty decent start so now we can close this game for now and now we actually have to make our ball move and that's going to be the more complex part so let's go through it step by step with the ball selected i'm going to create a new script and here again we have all the same options except this time i want to start with an empty template but the folder is still fine so i click on create and here now we're starting with completely empty code except that our code extends a kinematic body to d so this one is fine and here again i want to create a couple of basic variables that are going to be important for our ball and the first one is going to be the speed of the ball so speed equal to let's say 600. again you can play around with this value it just determines how fast the ball is going to be and another important thing let me open my player script again so on the left you can see all the open scripts and if you go to the file system and click on player.gd for example you could open the old script and right now what we have is that our player has a speed variable and our ball has a speed variable and that's fine each of these nodes has its own scope meaning that you can have a variable name speed for the ball and the variable name speed for the player and even the variable name speed for the opponent that's perfectly fine it doesn't matter if they have the same name so this was a good start and then this time i want to create a velocity vector again and this one again is going to be a vector 2 dot zero so an arrow that doesn't point in any particular direction and here do know the difference that for our player we created this velocity inside of the physics process whereas for the ball we are creating it outside of it and there's a specific reason that you are going to see in just a second actually right now so the reason we have to define velocity outside of a function is because we want to use it in lots of different functions so what i effectively want to do is when our ball is ready i want to change this vector 2.0 to a specific direction and then i want to use this direction in the actual game in the physics process so we couldn't define this velocity inside of a function because we want to use it across multiple functions oh yeah and this is something i haven't mentioned before so let's say open the player again if you create a variable inside of a function this variable is only available inside of this function so this velocity here is only going to be available inside of this physics process function so we couldn't use it outside of it but in this case it's fine because we don't need it outside of it and helps to keep our code clean but in case of this ball velocity we do need to use it in different functions so it's important to define it outside of a function okay cool so now when our ball is ready we want to give it a random direction so we first have to run a function that only runs when our ball is ready and i talked about this a tiny bit earlier it's called the ready function and remember the underscore that one is quite important and use the double colon again and now we are indented in the line so any code we put in here is only going to run once when the ball scene is ready and what i want to do is to target velocity and now target the x attribute of it and now i want to give it a random number and this is a topic we haven't covered yet in godot how to create random numbers and there are a couple of different ways and to get to a random number we actually have to cover a couple of different concepts so i think the best way to go on about this is to first write the line and then explain how the line works so let me write the entire thing okay so this line is probably going to look really confusing so let me go through it step by step and there's actually going to be a new kind of data type we have to talk about so we are starting the entire thing with square brackets where we have minus one and one and this is called an array and an array is basically just a list so in this array we have two numbers that are minus one and one you store different numbers inside of a list so it's kind of comparable to a shopping list and this allows us to store different values inside of a single data type so this can be quite useful so basically what we have right now is a box with two values inside minus one and one and essentially what we are doing with the other square brackets is to pick one of these numbers at random and this process is called indexing that after you're putting square brackets after an array and put an integer inside of it you are picking a specific value from this array with a number zero picking the first element and number one picking the second element and so on and be aware here that the first element in an array is always the number zero but we want to pick a random integer and for that we have the function rand i and rand i generates a random integer but by default it generates a random integer across an infinite range so that's not good so we have to add the modifier 2 after it and this is what this entire part does it generates a random number that's either 0 or 1. and then this random number 001 is being used to pick either the minus one or the one and i hope that makes sense it's a tiny bit more complex i will put a link into the description of this video to explain this in more detail if you are interested but okay this covers our x speed so our horizontal speed now we need to talk about the vertical speed and this happens in exactly the same way so instead of x i change this to y and we are almost good to go the one thing i do want to change is that 1 and 1 feels a bit too steep so if we were to leave it at this our ball would start moving in a 45 degree line which i think would look quite slow so instead i want to lower the degree so this one could be 0.8 and or minus 0.8 and 0.8 so what this effectively means is that our ball is going to move to left and to the right by the unit of 1 but it's only going to move up and down by unit of 0.8 or negative 0.8 so it is moving faster in the horizontal direction than it is moving in the vertical direction and for now that's all we needed for the direction of the ball now just like for the player we can go with funk physics process and all we have to do now is to use the move and slide function and add in our velocity and let me actually try this and see if this is working so i press f5 and we can see that our ball is moving very very very slowly and again the reason for that is that we have to multiply it by our speed so now let's try this again and there we go there is you can see at the top the ball doesn't bounce but that's okay we can work on that in just a bit for now i think this seems okay but there's one more thing i do want to add before finishing this part that let me run the game again our ball is again moving to the top right and if i press it again our ball is again going to move to the top right and the reason for that is that these random numbers are not perfectly random and let me explain what godot does whenever you use a random number in godot what godot effectively does is it creates what's called a seed and the seed is really just a long list of numbers that godot picks from but godot always uses the same seed which always gives us the same number so these numbers are not actually random but we can change that by using the random mice function so now whenever our scene is ready godot is going to pick a random c to pick numbers from meaning that now when we run our game the ball doesn't start to the top right every time it can move in random directions and i hope at some point it moves to the left there we go okay so this is also working as well cool obviously the ball needs to bounce so let's talk about that so bouncing something off in godot with a kinematic body is actually really easy because there's a specific function for it and it's called move and collide and move and collide works kind of similar compared to move and slide they are both moving a specific kinematic body in a certain direction given the vector you put into it but when they are colliding with something they are doing different things when move in slide collides with an object it slides along the surface of this object whereas move and collide by default doesn't do anything but it returns what's called the collision object and you can use this collision object to make the object bounce off whatever we have hit so this is what we're going to do instead of using move and slide we're going to use move and collide and use that to calculate the angle we have to bounce off and i think it is best to just write in code so here we are back in godot and we have the code for our ball open right now and i don't want to use move and slide so i'm going to delete it and i want to use move and collide and again moving collide needs a vector so we need velocity so far this is exactly the same and again i also want to multiply it by speed but now there's one difference already that we have to multiply move and collide by delta and now with that let me explain what delta does delta is the amount of time that has passed since the last frame of the game was called so let's say if our game runs at 60 frames per second then the difference between each frame is about 17 milliseconds and godot is using that number to calculate how fast the game is going to run and let me illustrate why this matters imagine you have a game on two different computers one computer being really fast the other computer being really slow now the fast computer is going to be able to run a computer really fast so you might have frame rates like 200 whereas the slow computer might only get something like 20 frames per second now if we didn't account for the faster frame rate the game on the fast computer would run about 10 times as fast as compared to the slow computer which should make it really weird to play the game on different computers also within the same game if you come to the scene that is more complex the game might slow down and feel inconsistent so we have to account for different frame rates and that is what delta is for and really delta is just a very very small number that measures the time since the last frame and really what happens if you have a fast computer delta is going to be really small but applied very often whereas if you have a slow computer delta is going to be comparatively larger but it is going to be applied less often but both of these are going to equal out so the game is going to run at the same speed so the movements and side of the game are at the same speed and move and slide applies delta automatically whereas move in collide does not and the reason for that is that movement collide does more with physics so we need more control over it now the important thing is that moving collide whenever it hits something it is going to return what's called the collision object and this we can store in a variable so let me create a new variable that i call collision object and this will just assign with the equal sign so whenever we come to this line here udo is going to run this function and move our ball but then when this function is colliding with an object like our wall it is going to return a value this collision object and this collision object we can use to change the velocity of our player so the direction it is moving in and this we do we first check if this collision object exists in the first place which we can just do by typing if collision object and that's all we need so if this kind of object exists then this line is going to evaluate to true and then this if statement is going to trigger so we can use it like that and if that is the case we want to change our velocity because that is the direction we are moving in so we have to assign it a new value so use the equal sign and here we have to use velocity again and then use the bounce keyword and this one bounces a vector and into response vector we have to pass in the collision object and not just that but we also need a normal of this collision object so this line is going to look quite weird so let me explain what's happening here and let me illustrate this actually so here you can see a ball colliding with a wall and we want to bounce this spot off this wall and to do that we are going to need what's called a normal and the normal is just the direction a specific surface is facing so our wall right now is facing upwards for example and this normal we then can use to bounce the wall off in the right direction so the correct one for the bounce direction and all of this is done with the bounce method but well that's all we needed so let's actually try to run this game and see what happens so yeah there we go so the ball goes right outside of the screen let me run it again and we can even bounce off the pedal and oh it's actually working nice so here we have a bouncing ball so this works quite well actually and with that we almost have a working game there's one more thing we need and that is to have an opponent that can actually move along with the ball and that's going to come in the next section so what this means is that we have to talk about artificial intelligence at least on a very very very basic level but effectively this is what we are doing we are giving our opponent some kind of basic intelligence so they can follow the ball and we have an actual game but obviously we are not going to create anything sophisticated so all i really want to do is if the ball is above the opponent i want to move the opponent up if the ball is below the opponent i want to move the opponent down and then the strength of the opponent is going to be determined by the speed of the opponent and i think this is best explained while i'm actually doing it so let's jump right into our game and let's do this so here i'm back in my game and right now i only have the level scene open and if you look to the right you can see our opponent and if you want to open a scene really fast you can just click on this editor icon i guess and now we have opened our opponent scene and i want to give my opponent a script so i click on the script like again and here all the usual stuff i want an empty script let's say let's go with no comments so you can see what it looks like and i click on create so now we just have the function ready and we're actually going to use it in just a bit so i leave it here for now and as always i want to start with a speed variable just like for the player and the opponent and this one i'm going to set to 250 but now we do need another thing for the opponent to function properly it needs to know where the ball happens to be on the screen so i want to create another variable that i call ball and you don't actually have to assign any value by default this one is fine so this one doesn't have any value by now and i want to pass a value into it once the scene is ready which is going to be the ball so once the ball scene is ready i want to work with this variable and let me first type what i'm doing and then explain so i want to get parent and then find note so what happens here so whenever the ball scene is ready it looks for its parent which is in this case our ball scene's parent is the level node and then from this level node we are looking for a specific note which is the ball which is really all we're doing here that whenever our level scene is ready we are looking for the main level node and then from this node we are trying to find a node called ball and then we are storing whatever the result is inside of this ball variable so now we can work very easily with this node and now just as before we have to add some more functions to move this thing which again is going to be physics process delta and here we just need move and slide and pass in the vector and now here we don't have a vector just yet so for now let me just pass in vector2.0 so this thing is not going to move at all because this arrow doesn't point in any direction instead we have to add some more code to figure out where this ball is in relation to our opponent and for this i'm going to create our first regular function so i'm going to call this func get opponent direction it doesn't need any arguments and here note there's no underscore before it meaning that this function has to be called for it to be run at all which is different compared to this and this function but i'm going to explain this when we get to it so in here we have to create some logic to figure out when the player has to move up and when the player has to move down and we can work with that actually quite easily because we can get the position of both the ball and the opponent very easily and let me explain what we are going to do in here in the most basic sense we are going to check is the ball above the opponent then we move the opponent up is the ball below the opponent then we move the opponent down however we are going to give a little bit of a wiggle room so that we are only going to move the player up if the ball is slightly above the player so if the ball on the opponent are roughly on the same height we are not going to move the opponent because if we did the opponent would adjust all the time and would look incredibly wiggly so we have to create what's called a nested if statement so we first have to check if there is enough distance between the ball and the opponent and then inside of this if statement we check if the ball is above or below the opponent so let's get to it i first want to do the outer if statement that if there is enough vertical distance between the two and for that let me write the entire line first and then explain so we want apps ball dot position dot y minus position dot y is greater than 25. so what does any of that mean i think ballposition.y and position.y are fairly clear baller position at y is the y position of the ball and position note y is the position of this note here so we are essentially subtracting one from the other but we are putting this inside of an abs function and absolute numbers are just always positive numbers so let's say if we're getting something like 50 out of here the absolute function would turn into a positive number and this is there to ensure that it doesn't matter if the ball is above or below the opponent so we're just looking for the distance between the two not if it's above or below this comes on the next line and what we want to check in here is if ball dot position dot y is greater than position dot y and if that is the case we want to return one and i'm going to explain what this means in just a bit for now just stick with me and all what we are checking right now is if the ball position is if the ball is below the player so if it has a greater y value and if that is not the case so else we want to return a minus one and again don't worry about return right now i'm going to cover this in just a bit and now we have our two possibilities that either the ball is below the opponent or it is above the opponent so the else statement here so if this entire if statement doesn't come to true then we want to else return zero and this is the entire logic to move the opponent so let me explain what the return means so every time a function is running it returns a value and let me actually open the code for our ball so here we can see this line we have move and collide and this is returning a value into this collision object so whenever this function is running it returns a value and when you create your own functions you can set what the function is returning so in this case if this is true our function is going to return 1 or it might return a negative one or it might return a zero so really all this function does is if the ball is below the opponent it returns a one if the ball is above the opponent it returns a minus one and if neither of these are true then it returns a zero whereas for the ball this move in collide returned a collision object so something much more complex but this number we can use immediately in here so our vector 2 when we add brackets to it we can specify what directions we are looking at when we create this and for the x we just want it to be zero because we don't want to move the opponent left or right we only want to move it up or down and for up or down we want to use this value here so we can just call this function inside of this vector so get i called it opponent direction so now whenever godot runs this function it creates a vector inside it that doesn't move on the x but for the y it looks at this entire function what is being returned and then again we have to multiply the entire thing by our speed and this is a slightly more complex example so it's probably making sense to go over this a couple of times if you're new to programming or good dough but let me run all of this and let's see if this is working and yeah it is and really nothing complex happens here all that's really happening is that we check if the ball is above or below the opponent and then we move the opponent up or down depending on where the ball is so we have almost a workable game there's one thing left to do that we have to reset the ball once it moves outside of the screen so that's going to come in the next part and again to achieve that we have a couple of different options we could just calculate something in code to check the position of the ball but i'm not going to do that instead i'm going to use a node for this approach and this is bringing us to the third kind of physics node it's called an area 2d node and an area to danio doesn't really calculate physics instead it just checks if the physics body is inside of it so what i'm going to do is to put area 2d notes to the left and to the right of the screen and whenever the ball is inside of them i'm going to put the ball back to the middle of the screen so really something very simple so let's jump right into godot and let's do this so here we're back in our level scene and i want to add a few more notes so with the level selected i click on the plus icon and now i want an area to denote i add it and here again the door wants it to have a shape so i press ctrl a and i add a collision shape 2d and here as always i want to add a new rectangle shape and here we can see our rectangle shape and move it roughly into place and here's one thing you do want to be aware of that both of the wall top and the wall bottom they are also physical shapes so if the wall is colliding with the area to d this area to d would also be triggered so the area 2d at least by default only cares if any physical body comes inside of it this could be a wall it could be a player this could be a ball it doesn't matter so at least in our case we have to make sure that it doesn't collide with either of the walls and granted this isn't the best approach to do this kind of thing but i think for our game at least it's serviceable so i'm not going to worry about it too much ok now we have an area to the side of the screen and the ball wouldn't bounce off this shape it would go through it but then this area to denote could tell us that it's colliding with the ball but step by step before that i want to copy this area to d and again select it so you can't select the children and move it all the way to the left behind the opponent and this doesn't have to be too precise okay now we have area nodes to the left and to the right side of the screen and they are going to know that the borders collided with them but by default they're not going to tell us and we have to add some specific functionality that they're actually telling us that the ball is colliding with them and to do that we have to cover a new concept that is called signals and all a signal does is it helps us to make nodes communicate with each other so in our case what we want to do is if the ball is colliding with the to denote we want the area to linear to tell us that it's colliding with the ball and that's really all there is to it in a bit more detail though when you're creating a signal you always have to connect the signal to a node with some code because the signal is effectively creating a new function that works like an inbuilt function that is only being called at specific instances so for our area to denote for example it's only being called when it's colliding with physical body but okay lots of theory let's actually implement this so here we are back in our good old editor and i'm going to start worrying about our left side and let me actually rename them to left and right and yeah i got the right side so i want this left side to tell this level scene when the ball is colliding with it so with left selected i go to the right and there's inspector and there's also node and if i click on that we have signals and groups for now we only look at signals groups come later but here let me explain this we have all the different options that could be signals and what we are looking for is body android so this signal is only being triggered when a body like the ball is entering this area to the node so i double click on it and now we have a problem that we can only connect this signal to a node with some code and it doesn't really make sense to connect it to the player the opponent or the ball well maybe the ball but i want to connect it to the level itself so what i have to do is to give this level its own script so again i click on the icon and i just click on empty and create a new script and let me minimize this again because we don't need it so now our level scene has a script as well that doesn't really do too much at least just yet but again i go to left and click on body edit again and now if i double click on it i can connect it to the level and i could also give it a specific name but usually the default names are fine so i click on connect and now inside of the script for our level scene we have a new function and this function is going to be triggered every time a body enters this area 2d and we also have an argument with the body and this is the body that entered the area 2d so we could use this to influence the ball itself and let's first try if this is working and there's a really useful tool to check if something is working is called the print function and let me just call it collision for now so what we're doing in this line that if this function is being executed we want to print this text so collision and we will be able to see this at the bottom in the output tab so with this one open let me run the game and the ball goes outside and unfortunately we can't see anything because we're only checking the left side right now we're not checking the right side so let's try this again okay see when i get lucky there we go okay now it's on the left side now we can see collision so we know that this function here works and it only works if the ball is colliding with it so print is really useful to test your code but in my case i don't really care about it for now so what i want to do now is whenever this function is being triggered i want to reset the ball and that brings us to a new concept that we have to select different nodes from a starting node so right now let me open the opponent for example all of these methods they always apply to the opponent node itself we never tried to influence the sprite node or the collision shape 2d we always worked directly with the opponent node but now this is slightly different because we want to go from the level note and influence the ball so what we have to do in our code is first select the ball and then influence the ball and we can do this very easily and there are actually different ways of doing this the easiest one is use the dollar sign and then the name of the note you want to target so my case ball so if we have this line here we would only target the ball and if i now for example change the position we would only change the position of the ball not the position of the level note and that is actually what i want to do and the position has to be a vector 2 and now we have to put in the x and the y position and i want to go right in the middle of the screen so it's 640 by 360. so when i open our screen dimensions again so i just halved both of these numbers which brings our ball right in the middle of the screen and at least for now that is all we needed but obviously this is just the left side so we also have to connect the right side and this could be a challenge again if you want to code along so pause the video now and try to connect the right side with a signal and also reset the ball if the ball collides with the right side but let me do it so with the right side selected i am going to click on body entered and with body entered i again connect the signal to the level scene and i don't change the name but you could if you wanted to and now i'm just going to copy this line here and that's basically all we needed so let's try all of this and let me actually lose and there we go we have the ball starting again in the middle and with that we actually have a really basic game all that's left to do now is to add some more refinements to make the game look a bit prettier and that's going to come in the next part and i'm going to start by adding a score which is actually super easy to add but it is going to require us to work with text which is something we haven't done so far but text is actually really easy so let's actually jump right in and i will explain it while we are implementing it so here again we are in our level scene and i want to add some text and text in godot is called a label and you have also a rich text label but for now i just want a label which is a really really simple text but it could be more complex but i don't need that so now we have a label and if you look at the inspector we can write for example test in there and if i zoom in we can see test so this is working quite well obviously we don't want it to be in the top left of the screen instead i want it to be roughly in the middle a bit further to the left so we can see it's the player score and actually let me rename it to player score and here again you can see it's a green node just like our color rect and i can actually put them together that makes sense and here we can use the layout again and what i first want to do is to check for the full rectangle so this node is looking at the entire screen but our note is still in the top left so effectively what we have created is a really large text box with some text in the top left so we have to change this text box to move the text right into the middle which we can do if you look at the inspector you have a line and via line which is short for vertical align and right now it's left and top but if i change it to center and center and now we have it right in the middle it might look a bit deceptive because of the ball but i just put the ball randomly on the screen so the test is actually in the middle of the screen and obviously we don't want it to be right in the middle so i want to add a margin to it that it's moved slightly further to the left and this we can do under margin and here we have left and right and you can just move either of them so let's go with negative 200 and this is going to move the text a bit further to the left and alright this looks fine so now i can copy the entire thing so i also have an opponent score opponent score and this opponent score i just moved the margin to 200 so it's a bit further to the right and let me trial of this in the game now and yeah we can see test and it looks roughly in the middle cool so now we have two things to do the first one is we have to update the score and the second one is that this text doesn't look very good so we have to update that as well and let me start with the actual score and this one is not that difficult to do so i go back to our code and in our code i'm going to create two new variables the first one is called player score it's going to be zero by default and then we also have an opponent score which is also going to be zero and now on every single frame of the game i want to set these scores as the text for our player score and opponent score labels and for this this time we are going to just use the process function so let me type func underscore process so this process works kind of like the physics process except in this case we are not calculating anything physical we're just setting some text hence we're only using process not physics process and what i want to do in here is to first target our player not player sprite player score and to change the text i need text and if you want to find out what the attributes are of a certain note you can just look at the node itself so players go in this case and hover over what you want to influence so if you hover over text you can see property text and this is what you have to use in the code to target this attribute and then for this text i want to set player score but this would not be working by default because of the data type that this kind of text is looking for a string so a certain kind of words but this player score is a number so we have to change this player score from a number to a text which we can do very easily with the str method which is called string and all it really does is it takes a number and turns it into a string so exactly what we need so let me try this now so now player score should be zero and it is cool but it doesn't update yet so we have to work on that but before that i'm going to copy this entire line and change it to opponent score and up opponent score and now we run this they should both be zero and they are cool now what we have to do is to update these two scores to reflect the actual score and this we can actually do very easily because we already know if the ball is leaving on the left side of the screen or the right side of the screen so if the ball is leaving on the left side of the screen we know the player's score is increasing by one and if the ball is leaving on the right side we have player score plus equal one and this is all we needed for the score so let me try this now and let me get score there we have one two oh yeah i messed up the sides so i just have to change this one around oh no it's player score and player score right so on the left this would be opponent score opponent score let's try this now and yep this looks better and yep this also works and there we can actually see one more problem that we're going to cover later that either the opponent or the ball could be moved by the ball in terms of physics but don't worry about this for now we're going to fix this in just a bit but for now we have a working score system so what's left to do for now is to change the style of these fonts because they look pretty bad right now and again this is quite easy to do so with the player score selected we have custom fonts and custom colors i'm going to start with custom fonts if you open this tab you have a drop down menu and you can type new bitmap font and new dynamic font we want a dynamic font so i click on it and now i have to type on dynamic font and don't worry about the text disappearing that's normal so i click on dynamic font and now we have settings extra spacing font and resource and in font we can set our custom font and in our assets folder there actually is a custom font it's called poets and one regular and if i drag it into we can see a custom font and here we can also change the size of it and make it smaller i think i went with 50 possibly a bit large let's go with 40. and this would be a custom font so if i run the game now this one would look drastically better cool and we can also change the color of this so custom colors and by default it's black and here you can change again the color around and in my case i'm going to use a hexadecimal number again that is b9 d8 and d7 which is a fairly whitish color but not perfect white and all right that's really all we need to make the text look prettier now we have to do the same thing for the opponent score and again if you want to challenge yourself pause the video now and try this yourself but all you really have to do is go again to custom fonts create a dynamic font click on dynamic font again click to font and now drag and drop the font in there from the asset folder and then for settings i went with a font size of 40 if i remember correctly and now under custom colors enable font color and click on it and it was d9 d8 and d7 click on enter and you're good to go so let me run all of this again now and we have our scoring system so seems fine and with that we're actually making pretty good progress in the next part i'm going to add a countdown timer so there's a bit of a delay before the ball restarts okay then it timer and timers in godot are actually fairly straightforward because again we have a specific note for that that we can use actually quite easily and more specifically what i'm trying to achieve are two things number one is that we're having a count on timer before the ball restarts after we have fit a goal and number two is that i also want to display this count on timer so that we can see two one and zero on the screen or something like that and some short number that counts down from a certain number to zero how long that is going to be is up to you but i found two is a good starting point because three actually felt a bit too long but the specific number really doesn't matter let's have a look at this so here we are back in the code and the first thing i have to add is a timer node so with our level selected i click on the plus sign again and i want a timer node and it literally says a countdown timer so create and again i'm going to rename it to count down timer and if you look to the right at the inspector you can see a couple of attributes number one is the wait time so this is the length of the timer then we have one shot so is this time we're going to run just once or multiple times in our case this is going to be true and then we have autostart so if it starts by itself or if we have to trigger it quite straightforward so in my case i want wait time to be 2 and one shot to be on and that's all we need for the attributes but now obviously if this timer were to run out we would again need a signal to tell other nodes that the time has run out kind of like for the signals for the area to denote for the left and right areas so here same principle this timer right now would be running however we have to tell another node that it has triggered so for this again we need a signal and for that i go to the top to node and here we only have one really big signal that's timeout and this is when the timer reaches zero so seems appropriate so i double click on it and i'm going to connect it to our level and here again besides our signal for the right body entered and left body entered now we also have a count on timer timeout and now here's the logic i'm trying to achieve with this that once we have scored a goal i want the ball to return to the middle of the screen and i also want our countdown timer to start ticking down and only once the countdown timer has reached zero then i want the ball to restart so for now we are not going to worry about the text displaying all of this we are just going to worry about the timer functionality and this is bringing us to kind of a problem that right now we're controlling our level scene but we do want to influence the ball which is in its own scene so we need to work across different scenes but from our level node we want to tell our ball not to move anymore at least for a certain amount of time and there are a couple of ways to achieve this the one i'm going to use is called a group which is fairly similar to a signal but with a slight difference so let me illustrate so far we have seen a signal where let's say for a timer where you send a signal from one node to the other so let's say from our count on timer node to our level node or from our area to denote to our level node so we always start from one node and go to the other node and for a group we are still starting at a single node however now we can target as many nodes as we want so any node that is inside of a specific group can be targeted and what this is really useful is that it doesn't matter where the node is so it could be in a different scene it could be inside of a scene of another scene it doesn't matter as long as the node is inside of a specific group we can always target it no matter where it is so what i'm going to do is to put our ball inside of a group and then from our level scene i'm going to target that group and then this group is going to tell the ball to execute certain functions so let's actually implement this so here i'm back in my code and let me just quickly save okay and now i want to open my ball scene so i click on ball and click on the little film icon and here we have our ball again and i still have the notes section open that is next to the inspector so far we looked at signals now i want to click on groups and then here all we can see is manage groups we can type some text in here and click on add and if you have a node selected in here like i have for ball and i can type in a name in here let's say ball group i can click on add and now our ball is inside of the ball group which you can see from this icon next to the note it's a circle inside of a square bit of a random icon but who cares so now what this means is that this node is inside of a group and whenever we target this group we could also target the node itself and how this most specifically works is that we're going to give this node a specific function let's say we're going to give it a function that i'm going to call stop ball and all that this function does is it sets this speed to zero so all we need is speed equal zero and then inside of our move and collide function if we multiply velocity and delta by zero it is going to be zero so the ball would stop moving so exactly what we want so now we have to figure out how to call this double function from our level script so i go back to our level script actually let me save the script first just to be sure so what i want to do is when either of these two areas are being hit i want to call the stop function and for that we need two commands the first one is get three and the second one is call group and in here we could pass in the name of the group and the method we want to call so in my case this is ball group and stop how do i call it stop ball stop ball so i think this entire part kind of makes sense we are calling a group and we have the name of the group and the method we want to call inside of this group so why do we need get tree and this i can actually illustrate so let me run the game right now and let's hope it doesn't crash yeah okay so the ball actually stops in the middle so we know it's working but while the game is running if you look to our scene 3 you can right now see local and remote and you can click on this still while the game is running and it shows our game and all the notes inside of our game in real time so you can see all the notes inside of the game while the game is running and here you can see a root note and only then our level note and this entire thing is our scene tree for the entire game and obviously it's still a fairly simple one but what we actually want to get is this root node that will get access to the entire tree while the game is running and this is what get tree is doing that it gets us the entire tree and from there we can access specific functions like calling a group which we couldn't do just from a specific note by itself so i hope that makes sense but we're making progress because the ball is stopping indeed so that's quite nice this has to be called on both sides of the field and with that we can start talking about restarting the ball and this works in basically the same way so i go back to my ball and in here i want to create another function that i'm going to call let's call it restart all and in here we could just set speed back to 600 but i don't think this would be enough and the reason for that is quite simple that if we were to restart the ball like this it would still point in the same direction so if the ball is going to top right and then hits the end of the field it will restart to the top right which would get really predictable so not only do i want to set the speed again to 600 i also want to restart the velocity and get different random values and i can literally just copy and paste them and now i would get new values when i restart the ball so quite straightforward and now again we have to call the group to restart this function and if you want to challenge yourself this should be doable if you got this far so try this for yourself but really all you have to do let me save this one again we need to call this function in a very similar way compared to this but i only want to do this once the timer has run out so this has to be inside of this countdown timer and now instead of stop ball i want to have start ball i think restart what i called it i'm terrible with naming functions but okay so now whenever this time has run out we're going to call this group and called the restart ball function so there's one more thing we need that we have to start this timer so whenever the ball has set either of the fields we want to start the timer and once the timer has finished we want to call this group so we have to figure out how to start this timer and that is actually super easy so all we need is to first target the node of the timer which again you do with the dollar sign and what you can also do is just drag and drop the node next to dollar sign and there you would get the name of the node this time in quotation marks but that is the same outcome so if you typed it with quotation marks or without it's the same thing they both result in the same thing that you are getting the note and now to start the timer all we need is start and let me copy this to both sides and now this should be working so let's try so we have the ball here and let me and there we go this is working so let me lose again and wait a bit and there we go so the ball is restarting after about two seconds over however long it takes so cool seems quite all right there's one thing we could be doing that right now we're duplicating code here quite substantially so instead what i'm going to do is create a new function um let me put it all the way at the bottom and that is to create a new function let's call it score achieved and in here all we have to do is copy this entire line or even cut it and then inside of each of these signals i just want to call this so score achieved and score achieved so now if you want to influence either of these we just have to work with this function and this doesn't duplicate code so quite a bit nicer but all right now we have a basic timer and all we need now is to display this timer and this is going to be another label so i have a player score right now and an opponent score i want to add another label so i select the level note and add another label that i'm going to call countdown timer alright i already have one um let's call it count down label that feels better and i'm gonna put it right to the other labels and the really important part here is that all of these labels are above all of the other notes in the scene tree especially the ball so i want the ball to be above the countdown label in the actual game otherwise i think it would look quite a bit weird that we have text over the ball okay now we have our countdown label and for now let me just write in here countdown and move it to the middle of the screen so again i click on layout i click on full rect to select the entire viewport and now i align it to the center and to the center and now with the margin i just move it up a tiny bit um i guess here seems fine it's fairly subjective whatever you feel like it looks good could also be at the bottom could be anywhere whatever you fancy and again we have to give this a custom font to match it with the other two pieces of text we have so i go to custom font get to dynamic font then get to font again it's quite click intensive and then drag and drop our font in there and i'm going to make this um let's go with 50. um yeah i think that seems fine and now this one got a slightly different color so again under custom colors i click on font color and this time let me demonstrate another way to pick a color and that is this color picker here so if you click on this godot lets you just pick another color maybe not the background let me use the white color here so if you just use this you can literally select any color on the screen and what i want to do is i want to select the color of the ball which right now we can't do because there's the collision shape above the ball so i go to the ball scene and just make this invisible and here's an important thing just because the shape is invisible does not mean it's not there anymore you just can't see it but for collision shape you can never see it anyway so it doesn't matter if you actually wanted to disable it you would have to go to disabled and click this on on but just because it's invisible doesn't mean it's not there so be aware of that but now with this one disabled we can actually see the color of our ball and now i can just go back to font color and just pick the color of the ball which is this orange redish color and all right this seems alright but now we have to figure out how to display this text only if the countdown timer is running and how to get the text of the count on time and for that we have to go back to our code and in here there are two things we need to work on number one is that we actually displayed the time left within our countdown label and this happens in the process function because we want to continuously do this on every single frame of our game so in here i want to target our countdown label and i want to set the text now what i want for the text is how much time is left for the timer and this we can target quite easily all we need is the countdown timer itself and it has an attribute called time left so this is how much time is left after the timer has started but there are two problems with this right now number one is that this is a number so as always we have to use the string method just like with the other labels oh and let me do this properly there we go but there is going to be another problem and i think if i run this code this should demonstrate it quite well meaning that we have a lot of numbers after the digit which well isn't great and this is another thing with data types that so far we have only seen integers which is numbers without a decimal point numbers with a decimal point are called floating point numbers or floats in short and while floats can be generally quite useful in this case we really don't want them so we want to convert the float of our count on time at time left to an integer which we can do really easily by using the in method which just takes a float and turns it into an integer so that's all we have to do in our code editor so before count on timer i type int and then i just copy and paste or cut the entire thing in there and now if i'm running this we can see let me lose one there we go and all of this is starting again but now right now it starts at one and goes to zero and this seems quite weird so i'm going to add one to this so just plus one and now two one and then we start and yeah i think that seems okay so there's one more thing we need to do that now when the timer is not running or when a timer has finished we want to hide this text because we don't need it anymore and this we can also do really easily so once the timer has run out i want to target the note again so count on timer and i want to target the visibility which you can see down here and there's visible and you can switch it on and off so i can go visible and this is going to be false false and here again this is directly using a boolean so far whenever we used an if statement we implicitly used a boolean so let me go with this one here if this value existed this line would be true but we can use boolean values immediately so you can use false and true in cases like this so if something is on it's true something is off it's false and what i want to do for our timer is that when the timer is running out we want to set this to false however when we are scoring a goal i want to set this to be true again so once the score is achieved i also want to set the countdown timer dot visible is equal to true and then by default i want this to be off so we can't see it when the scene is starting and let's try all of this so we are in our game again we can't see it by default and let me lose and the game crashes and the game crashes for a very simple reason targeting the count on timer i need to target the countdown label and the countdown timer is always invisible so this one wouldn't make sense so count on label and now this should be working so now let's start off this again and two one and go and there we go we have our countdown label so seems quite good now we are basically done with the entire game and we already have the really basic setup all that's really left to do is a couple of fine tuning things and adding the sound and that's going to be coming in the next part so adding the sounds is a really simple thing to do we just have to add a couple of notes and then it's basically done it's as easy as that but besides that we have to add another thing and this is something you have seen earlier a tiny bit that because we are moving with physics it can happen if the ball hits a pedal at a certain angle that the pedal is moving which i want to avoid and my fix for this is going to be the simplest one i can think of and all i'm really going to do is to reset the pedals on each side every time a score is being achieved so if a pedal is being moved to his side during the game it is going to be reset once the game restarts and that is just a couple of lines of code nothing fancy so let's start with the sound that's the much easier part and let's actually jump right in so here we're back in our level scene and what i want to add is a couple of sounds i want to add a sound to the ball that if the ball hits either of the pedal or with either of the walls then i want to play one sound and if a score is being achieved then i want to play another sound so let's start with the sound of achieving a score so with our level selected i'm going to add another note and the note we need is called an audio stream player and when you type just audio stream audio stream player you can see we have an audio stream player an audio stream player 2d and an audio stream player 3d and now you might be wondering why do we need spatial awareness for our sound and the answer is quite simple think of if you have a 3d scene you might have sound behind a wall or really far away and if that's the case you want the sound to be less loud same for 2d if the sound is really far away you want it to be less loud whereas for audio stream player this one doesn't care about space it will always have the same volume so this is what we need so i click on create and i want this to be score it's called score sound and in our asset folder we have a couple of sounds we have 8 bit beep and 8bit blob let me drag this up a bit so beep and blob the score sound had to plop sound so all i have to do is to drag and drop this file into the stream and here you can preview this thing you have playing and auto play playing means it is literally playing all the time auto play means it's starting when the game is starting so if you want to click on play you can hear the sound right now and let me click on it and you should be able to hear a very long and monotonous sound which well is not intended and what is happening here is that godot is repeating the sound all the time whereas we only want to play it once and this we can achieve very easily all we have to do is to go to the import setting next to rsc3 something we haven't seen so far actually but in here you can set specific variables on how something is being imported and for otg files that's a sound format you can click on loop so is this file being imported as a loop or just as one specific sound and i want this to be one specific sound so i deselect loop and click on reimport and now we have only one sound so if i click on playing you can hear it only for a very brief period of time so exactly what we want and while we're added i also want to do the same thing for the other sound just so we have it all ready and now we have our sound all we have to do now is to play this whenever we achieve a score so for that i am going back to my code by pressing f3 and here we already have a score hd function so all we have to do in here is target our score sound and we just wanted to play so then it's going to play the sound once and let's try this and yeah i hope you can hear it it's quite short but it's definitely there cool so now we have the score sound the one thing left is we need to do the same thing for our ball so i open the bald script and in here what i want to do is whenever we have a collision i want to play the plop sound or the beep sound this one and we actually already have that so we know if this one is true we have a collision so in here we could execute the function for this but obviously we first need a node let me open the entire ball scene again and in here i'm going to add another note that is also going to be an audio string player and this one is going to be collision sound and now i want to add the beep sound and let me preview it and yeah sounds like a collision and it only plays once so now in here we can just play it so collision sound dot play and now let me run the entire game by pressing f5 and yeah this looks good um you might want to work on the sound design a bit but those i think are fine for a test game okay and we are almost done the one thing left to do is now a level scene let me open it is that whenever a score is being achieved i want to reset both of the players with a certain distance to their respective side and for this let me open the code we just have to work in this function and set the x position of each of the players so i want to target my player the position of the player and then the x position of the player and in here let me put it at 35 so it's 35 pixels from the left side of the screen and now the same for the opponent dot position dot x and we know our entire screen is 1280 pixels wide and from that i want to subtract 35 pixels and that is really all we need to do so let me run the code now and this is probably going to be a bit difficult to see you can see it very slowly but this would if we have any kind of physics mistake this is going to fix it quite drastically so with that we have a finished game
