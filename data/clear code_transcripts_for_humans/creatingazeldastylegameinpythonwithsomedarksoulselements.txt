With timestamps:

00:00 - [Music]
00:08 - [Music]
00:16 - [Music]
00:28 - [Applause]
00:30 - [Music]
00:41 - in this tutorial we will be creating a
00:43 - zelda style rpg and it is going to
00:45 - involve a lot of components like
00:47 - sophisticated animations and graphics
00:50 - rpg mechanics and we are going to use
00:52 - tiled for the level creation and we are
00:55 - even going to create enemy ai speaking
00:57 - of ai i would like to give a shout out
00:59 - to the sponsor of this video ai camp if
01:02 - you want to learn more about artificial
01:04 - intelligence and build some seriously
01:06 - cool projects they have something for
01:08 - you ai camp offers either one-on-one
01:10 - guidance or a summer camp during which
01:12 - students create real world ai projects
01:15 - like face mask detectors sign language
01:17 - identifiers currency exchange automation
01:19 - and much more student testimonials from
01:22 - past summer camps are very positive and
01:24 - many students received either partial or
01:26 - even full scholarships to attend by
01:29 - visiting my partner link in the
01:30 - description you can apply for a unique
01:32 - scholarship opportunity to fund your
01:34 - time at ai camp and best of all it only
01:37 - takes 10 minutes
01:39 - and even more upon successful completion
01:41 - the top aicam students are hired to work
01:44 - for ai camp or for other silicon valley
01:47 - startups
01:48 - if you want to study ai or computer
01:50 - science at university or work in the
01:52 - field professionally this is a great
01:54 - experience to get started ai camp is
01:57 - currently looking for people to join
01:58 - their summer camp and i would strongly
02:00 - recommend you to check it out if you are
02:02 - interested
02:04 - now before i jump into the project a
02:06 - quick note on this setup we have one
02:08 - folder with four subfolders although we
02:11 - will only make changes to the one that
02:13 - contains the code
02:14 - and since the tutorial is quite long you
02:17 - can find the game files for each stage
02:19 - on github there are 15 in total there
02:22 - are also placement files to get started
02:24 - and to copy code it takes a bit longer
02:26 - to type and well that's basically it i
02:29 - hope you enjoy it so here we are in the
02:32 - code and right now i have three
02:34 - different files open we have main we
02:37 - have settings and we have debug and all
02:40 - three of those are python files
02:43 - and if i run the main file that's the
02:45 - really important one
02:47 - we are getting this window here plain
02:50 - lag doesn't do anything right now but at
02:52 - the very least we have a window that is
02:54 - all we are going to need for now
02:57 - and i guess before we get into the
02:59 - proper code let's go through this to
03:01 - have a solid basis now we are starting
03:04 - all the way up here with importing
03:06 - pygame and says that's the usual stuff
03:09 - the more important stuff comes right
03:10 - below where we are importing everything
03:13 - from settings
03:16 - and settings looks like this
03:19 - we basically have two sections in here
03:21 - the first one contains the main game
03:24 - variables most importantly here we have
03:26 - width and height of our game window
03:29 - and those would be flexible so if the
03:32 - game window is too large for your window
03:34 - you can make these smaller i guess you
03:36 - could also make them larger if you
03:37 - wanted to
03:38 - and then besides that
03:40 - we have the fps and the tile size
03:43 - and i would recommend to keep those two
03:44 - numbers static now besides that we have
03:47 - our world map
03:49 - and the world map is for now going to be
03:52 - the layout of our game
03:54 - in this world map we have our player
03:56 - that's the p
03:57 - then besides that we have axis and that
04:00 - is going to be a rock on obstacle same
04:02 - thing and then besides that we have a
04:04 - ton of empty space
04:07 - and that is going to be space the player
04:08 - can walk on
04:09 - so then if i go back to our main file
04:12 - we have a game class let's talk about
04:14 - this in a second
04:15 - but what we are doing with the class
04:17 - comes down here we first check if this
04:19 - is our main file then we are creating an
04:22 - instance of this game class and then we
04:24 - call the method run of this class
04:27 - so let's look at our game class and in
04:30 - here not much is actually happening
04:33 - we have our init method and in here we
04:36 - are initiating pi game
04:38 - we are creating a display surface and we
04:41 - are creating a clock
04:42 - so this is the basic setup you always
04:45 - need for pi game
04:46 - then more importantly we have our run
04:49 - method and in here two things
04:51 - essentially happen
04:52 - the first one is going to be this bit
04:54 - here and that is going to be our event
04:56 - loop and right now we are just checking
04:59 - if we are closing the game now besides
05:01 - that down here we are filling the screen
05:04 - with a black color we are updating the
05:06 - screen and we are controlling the frame
05:08 - rate so none of this should be difficult
05:10 - if you have any experience with pygame
05:13 - however if you have no idea what any of
05:16 - this means
05:17 - check out my introduction to pygame it
05:19 - explains all of this in quite some
05:21 - detail but alright so this is going to
05:25 - be our basic setup now there's one more
05:27 - file that we have to talk about and that
05:30 - is debug
05:31 - and debug isn't actually going to
05:33 - influence our game
05:35 - instead it's as the name suggests a
05:37 - debug tool so it's really just there to
05:40 - give us information about whatever is
05:42 - going on in the game but it's not
05:44 - actually going to influence the game so
05:46 - you could ignore it entirely if you
05:48 - don't care about it
05:49 - and i am going to use it just to
05:52 - illustrate in a bit more detail what's
05:54 - going on in the game and let me actually
05:56 - demonstrate what it does so if i go to
05:58 - my main file in here i can from
06:02 - debug import debug
06:05 - and then in my game loop i can run debug
06:09 - and print any kind of information that i
06:12 - think is important so let's say hello
06:16 - and let's see what we get
06:18 - now in the top left of our window we get
06:20 - the word hello
06:22 - and obviously right now not particularly
06:24 - helpful but later on this could be a
06:27 - game variable that we want to illustrate
06:29 - so this is very helpful
06:32 - all right but right now i don't want it
06:34 - so let me get rid of all of that
06:36 - now with that we have our basic setup
06:39 - although there's one more thing i would
06:41 - like to add in here and that is that
06:44 - right now let me actually demonstrate
06:47 - in the top left of our window it says
06:49 - play game window and i would rather that
06:51 - this says zelda or something more
06:53 - customized and this would be a challenge
06:56 - for you that i want you guys to change
06:58 - this text to something more custom in my
07:01 - case it's going to be zelda but you
07:03 - could write whatever you want
07:12 - alright let's try together let me close
07:15 - this and we only really need one line
07:18 - when we are initiating all of pi game so
07:21 - it happens right here after i create a
07:23 - display surface
07:25 - and the line we need is pygame
07:28 - spelled correctly dot display dot set
07:31 - underscore caption
07:33 - and then here we have to pass in a
07:35 - string
07:36 - and in my case it's going to be zelda
07:39 - and now if i run this
07:41 - we can see zelda in the top left it
07:44 - really isn't going to make much of a
07:45 - difference but well it looks a bit nicer
07:48 - so with that we have our basic setup and
07:51 - now we can talk about the actual level
07:55 - and our level class is going to become
07:57 - incredibly important it's essentially
08:00 - the central part of the entire game so
08:04 - effectively it's going to be the
08:05 - container that contains all the
08:07 - essential game elements
08:09 - like the player all the enemies the
08:11 - level map
08:12 - all of the obstacles and so on it is
08:15 - really important
08:16 - and that is actually bringing us to the
08:18 - core concept the level class has to
08:20 - manage
08:21 - and that is that we have to take all of
08:23 - our sprites for the game put them in
08:25 - different groups and somehow manage all
08:28 - of this efficiently and the key concept
08:30 - to make that work is to use different
08:32 - groups to give different functionality
08:34 - to different sprites so let me give an
08:37 - example
08:38 - for start we are going to create two
08:40 - groups in our level class one is called
08:43 - visible sprites the other is called
08:44 - obstacle sprites
08:46 - and literally any sprite that is going
08:48 - to be visible will be in the visible
08:50 - sprites class so this is the only group
08:53 - that we will draw on the screen
08:55 - at the end of this project it will
08:57 - contain the player the map all the
08:59 - enemies all the obstacles and so on so
09:02 - if a sprite is not inside of this class
09:05 - it will not be drawn and for the
09:07 - obstacle group well anything that is
09:09 - going to be in here
09:10 - will be able to collide with the player
09:13 - and anything that isn't in here will not
09:14 - be able to collide that's fairly
09:16 - straightforward and how this will become
09:18 - useful later on is that for example for
09:21 - our level boundary so the coastline
09:23 - effectively i have basically placed
09:26 - sprites there that will interact with
09:28 - the player via collisions but they are
09:31 - not drawn because they're not in the
09:32 - visible sprites group
09:34 - you will see how that is going to work
09:35 - later on but the main thing you should
09:38 - understand is this
09:39 - that you can put sprites into different
09:42 - group and the sprite can be in multiple
09:44 - groups at the same time and depending on
09:46 - what group it is in it should be
09:49 - interacting with its environment
09:51 - slightly differently
09:52 - and that is going to become a key
09:54 - concept to make this entire project work
09:56 - but let's actually jump into our code
09:59 - and let's implement all of this
10:01 - so here i'm back in the code and i want
10:04 - to create a new file
10:06 - and i will save this one as level dot pi
10:11 - and in here as always we have to import
10:14 - pi game nothing else for now though
10:17 - and now we have to create a class
10:20 - level
10:21 - there's no inheritance but we do need
10:24 - an init
10:26 - method that needs self and nothing else
10:29 - and i guess now we can go straight to
10:33 - creating the two sprite groups that i
10:34 - just talked about
10:36 - so let me add a comment here and let's
10:38 - call this sprite group set up
10:42 - and in here i want to create self dot
10:44 - visible underscore sprites
10:47 - and this is just going to become pygame
10:50 - dot
10:52 - sprite dot group
10:55 - and now i can copy all of this
10:57 - and i want to create obstacle sprites
11:02 - so these two groups will become really
11:04 - important
11:05 - and essentially what i want to do later
11:07 - on in my level class is i want to give
11:09 - it another method that i'm going to call
11:12 - run
11:13 - doesn't need any argument besides self
11:16 - and in here i want to essentially update
11:19 - and draw the game
11:21 - but for now i'm just going to add pass
11:24 - because it's not doing anything
11:26 - and now that i have my level i can go
11:29 - back to my main
11:30 - i can
11:32 - import so from
11:34 - level import
11:37 - level
11:39 - and what i can do now is create self dot
11:43 - level
11:44 - is going to be
11:47 - the level
11:49 - and then in the game
11:50 - i can call self dot level
11:54 - dot
11:54 - run
11:56 - so we are essentially creating an
11:57 - instance of our level class
12:00 - this one here
12:01 - in our main game
12:03 - and then we are running all of this
12:04 - inside of our loop
12:08 - so really all we're doing is we are
12:10 - calling this method here
12:13 - and let me just run all of this to see
12:14 - if it's working and yeah it's still
12:16 - looking good we still can't see anything
12:18 - but that comes later
12:20 - so now we have a basic level
12:23 - now next up there's one more thing i
12:25 - will need in the init method and that is
12:27 - the display surface
12:29 - because at the end of the game we want
12:32 - to draw all of our game on this
12:34 - self.screen
12:35 - so we can approach this in two different
12:37 - ways
12:38 - we could either take this self.screen
12:41 - and pass it in this level this would be
12:43 - perfectly fine
12:45 - although in my case
12:48 - in my level
12:49 - i am let's do it right at the top
12:52 - we can use a function to just get the
12:55 - display
12:57 - surface from anywhere in our code
12:59 - and the code for that let's call this
13:01 - one self
13:03 - dot
13:04 - display underscore surface
13:07 - all we need is pygame dot display dot
13:10 - get
13:11 - underscore surface
13:13 - and this is going to get us the display
13:15 - surface from anywhere in our code which
13:18 - is quite handy
13:20 - as a matter of fact in the debug method
13:23 - we are using the very same line if
13:25 - you're interested but that doesn't
13:27 - matter too much so now we have our basic
13:30 - level class
13:31 - it still doesn't do all that much
13:34 - because we're not drawing anything
13:36 - and to draw something we essentially
13:40 - have to go through this
13:42 - world.map
13:43 - and draw either a rook wherever there's
13:46 - an x
13:47 - nothing if there's an empty space or the
13:49 - player if there's a p
13:51 - and the problem we have right now is
13:53 - that we neither have an x nor a player
13:56 - so let's create both of these in a very
13:58 - simple way and then we're going to cycle
14:01 - through this entire map to place them on
14:02 - the screen
14:04 - so back in my level well actually
14:06 - this should be a new file and let me
14:09 - save this one as tile dot
14:11 - pi
14:12 - and for now this is going to be a class
14:14 - that will always going to be a rock but
14:16 - later on we are going to make it
14:18 - slightly more flexible so it goes to
14:20 - become a tree or statue or basically any
14:22 - kind of object
14:24 - import pie game as always that was
14:27 - terrible spelling
14:28 - and from settings import
14:32 - everything
14:34 - and now i want to have a class called
14:36 - tile
14:37 - and this one is going to be a sprite so
14:39 - pygame dot sprite dot sprite for
14:41 - inheritance that is really important
14:44 - and now i want to create a dunder init
14:48 - method
14:49 - that needs self and now this one
14:52 - is going to do a couple of things
14:54 - most importantly
14:56 - we are going to need a position so we
14:58 - know where to place it besides that
15:01 - i am also going to give it an argument
15:03 - called groups
15:06 - and this is going to be the spread group
15:08 - it should be part of
15:10 - how that is going to work you see in
15:11 - just a second but there's a very handy
15:13 - feature to assign a sprite to a group
15:16 - via the arguments you see in a second
15:18 - what i mean
15:19 - actually we can do this right now so
15:21 - these are the two arguments i need
15:23 - and the first thing you always eat in a
15:25 - sprite that's very easy to forget is
15:27 - super
15:28 - dot
15:30 - init
15:32 - and then brackets so we initiate this
15:34 - class here essentially
15:36 - and what you can do that is super handy
15:39 - is if you pass
15:41 - the groups in here so the argument we
15:44 - have just declared
15:46 - now we are going to need two things the
15:48 - first one is always
15:49 - self.image and we need self.rect
15:53 - the two main things you always need for
15:56 - any kind of sprite
15:58 - and direct is the easier part we need
16:00 - self dot image dot get
16:03 - underscore rect
16:06 - and the top left
16:08 - is just going to be the position so this
16:11 - is the position that we get up here that
16:13 - we will give this tile when we create it
16:16 - now for the image i want to import a
16:19 - file so pygame dot
16:21 - door
16:23 - and in here we first have to get outside
16:26 - of our folder so right now we are in the
16:28 - code folder so dot dot
16:31 - then we have to go into the graphics
16:33 - folder
16:35 - and inside of the graphics folder
16:37 - there's a folder called test
16:40 - and inside of test we have a player and
16:43 - a rock and for this one i want to use
16:46 - rock.png
16:48 - and really important do not forget to
16:50 - convert
16:52 - alpha this rock with that we have our
16:56 - basic rock or well a basic tile that's a
16:59 - pretty good start
17:00 - and i guess what we can also do is let
17:03 - me copy all of this
17:05 - and now i want to create a new file and
17:07 - this one is going to become our player
17:10 - so let me save it as player dot
17:14 - pi
17:15 - and now i can paste all of this and
17:18 - change the class name from tile to
17:20 - player
17:21 - and now
17:23 - instead of the rock
17:25 - i want to have the player
17:27 - and the rest can stay the same although
17:30 - this player class later on we are going
17:32 - to massively change so there's no point
17:35 - using inheritance between these two
17:36 - classes
17:37 - with that we have a player and a tile or
17:41 - rock so now in our level
17:44 - we can actually set some basic stuff up
17:47 - so we can finally actually see something
17:50 - but first of all let's see if things are
17:52 - still working and they do that's they're
17:55 - looking pretty good
17:56 - and i guess let me really quickly
17:58 - explain what we are going to do so the
18:01 - really important part in our settings is
18:04 - this world map
18:06 - and let's go through this thing really
18:07 - quickly just to explain what it is and
18:09 - how it's going to work so essentially
18:12 - world map is a list here's the start and
18:15 - here's the end
18:16 - and this list contains a ton of
18:19 - individual lists and inside of each list
18:22 - we have one string there could either be
18:24 - an x a space or a p
18:27 - and this we are going to translate into
18:30 - specific positions
18:32 - for example this top left x
18:35 - should have the top left position so
18:36 - this point here should be position 0 and
18:40 - 0. for the simple reason that it's right
18:43 - in the top left
18:45 - now the x right next to it so this one
18:47 - here should have the top left position
18:50 - let me add a small arrow to make it a
18:51 - bit easier to see
18:53 - this should have an x position of 64
18:56 - because our tile size is 64 but then the
18:59 - y position should still be zero because
19:02 - it's right at the top and now for
19:04 - another example let's say if we want to
19:06 - place the player i still want to place
19:09 - the top left
19:10 - and now i have to figure out the x and
19:12 - the y position and this could actually
19:14 - be a really good exercise for you
19:17 - try to figure out what the coordinates
19:19 - of the player are supposed to be
19:26 - i know the player is in the column with
19:29 - the index two so we have zero
19:32 - we have one
19:33 - and we have two so the x position of
19:37 - this point here
19:38 - should be 2 times 64. and let me add x
19:44 - here
19:45 - and that is going to be 128
19:48 - and now for the y position that's one we
19:51 - haven't done so far
19:52 - we can use the list themselves so we
19:54 - know this is list number zero this is
19:56 - list number one
19:58 - and this is list number two
20:00 - so our player is in the list with index
20:03 - number two so for y we also have to
20:06 - place the player at 2 times 64 which is
20:10 - still going to be 100
20:12 - so the top left of the player should be
20:14 - a position 128 and 128
20:17 - and this sort of logic we are going to
20:19 - do for every single item in this entire
20:22 - list
20:24 - so i want to go back to my level and in
20:26 - here i am going to create a new method
20:30 - let's call it create underscore map it
20:34 - doesn't need any arguments besides self
20:36 - and in here essentially i have to nest a
20:38 - couple of for loops and let me build
20:41 - this up slowly first of all i need 4 row
20:44 - in
20:45 - world
20:46 - underscore map
20:48 - and now let's print what we get
20:51 - so print row
20:54 - and i guess when we set up the class we
20:56 - can call this method
20:58 - so in here let me add another section
21:01 - and let's call it sprite set up
21:05 - and what i want to do is self dot create
21:07 - map so we're just calling this method
21:10 - here
21:11 - and now if we run out of this
21:14 - we are getting an error that world map
21:16 - is not defined
21:18 - for the simple reason that i didn't
21:20 - import the settings so from settings
21:23 - import star
21:25 - now this should be working there we go
21:27 - so now we still can't see anything but
21:30 - now
21:31 - we have printed essentially the entire
21:34 - map that we can see in the settings
21:37 - so the same map we can see here
21:42 - pretty good start although not
21:44 - particularly helpful
21:46 - because there's a really important thing
21:48 - i need to get here that for each row
21:52 - i need to know the index because that is
21:54 - going to be the number i will multiply
21:56 - with the tile size to get the y position
21:59 - so besides the row information i also
22:02 - need to know what index it's on
22:04 - and this is information
22:06 - i am getting with the enumerate method
22:09 - so enumerate
22:11 - and we need row
22:13 - index and row
22:15 - so now i can let me copy this
22:19 - i can print the row index and the row
22:22 - so now if i run this
22:24 - and close the window
22:28 - we can see
22:30 - that we have index zero then the first
22:32 - row index one
22:34 - and then the second row about the first
22:36 - row the row of the index one let's put
22:38 - it this way
22:39 - and this is really important information
22:42 - because this entire row here i want to
22:44 - multiply for the y position with zero
22:47 - times 64 which is going to be zero
22:51 - but for the second row or the row of the
22:53 - index one
22:54 - we want to go with one time 64. so that
22:58 - way there's always going to be a 64
23:01 - pixel offset between each row and all
23:03 - right
23:04 - now we have our row and our row index
23:08 - so that is going to give us the y
23:10 - position
23:11 - but from that we also need the x
23:14 - position
23:15 - so this is going to be another for loop
23:17 - so let me go back to my settings
23:20 - essentially
23:21 - we went through every single list with
23:23 - this for loop and we got the list and
23:26 - the index
23:27 - now what we want to do
23:29 - is that inside of each of the lists
23:31 - we want to look at each of these x's
23:34 - and then figure out what the information
23:37 - is so what's inside of the string and
23:39 - what index this string is on and that
23:42 - way we're going to get our x position
23:45 - and this is going to look very similar
23:47 - so for let's call it call
23:50 - index and column
23:53 - in
23:54 - enumerate
23:56 - and now it's going to be the row
23:58 - and that is literally all we are going
24:01 - to need for the basic setup
24:04 - so this is going to cycle through every
24:06 - single item so every single x empty
24:09 - string or p
24:11 - inside of this world map
24:13 - and it's also going to give us the x and
24:15 - the y position and i guess just for the
24:17 - formula now we can get an x
24:20 - and we can get a y position the x is
24:22 - going to be the column index
24:25 - multiplied by the tile
24:28 - size
24:29 - and y
24:31 - is going to be the row index
24:34 - multiplied by the tile size
24:36 - and with that we have converted the
24:39 - world map into a position
24:41 - so now what we can do
24:43 - is if the column so each individual item
24:48 - inside of this world map so x empty
24:51 - space or p
24:52 - and use that information to create a
24:55 - certain kind of sprite
24:56 - so for example if
24:58 - column is going to be equal to an x then
25:02 - we want to create a rock
25:04 - and for that to work we obviously have
25:07 - to import the tile for the rock
25:09 - so
25:10 - from tile import tile i think i called
25:14 - it yeah tile
25:16 - and i guess what we added
25:17 - from player import
25:20 - player
25:21 - essentially all we want to do is if we
25:24 - have an x we want to create a tile and
25:28 - the tile has two arguments we have to
25:30 - figure out
25:31 - we need a position
25:33 - and the groups
25:34 - so let me copy them and the position we
25:37 - already have that is just going to be a
25:39 - tuple
25:41 - with x and y
25:43 - and for the groups all i want is a list
25:47 - with all the groups this one is supposed
25:48 - to be in let's say for now it's just
25:51 - going to be self dot
25:54 - visible sprites so we can see them but
25:56 - later on there are going to be more
25:58 - groups in here and with that we have the
26:01 - basic setup this is not looking bad at
26:03 - all so first of all let's run out of
26:06 - this to see if we get an error and we
26:08 - don't that's generally a good sign
26:11 - so now we just have to display
26:14 - this visible sprites and we should be
26:17 - good to go and i think this could be a
26:19 - good exercise to see if you are still
26:21 - following along
26:22 - so try to display all the sprites inside
26:25 - of visible sprites
26:32 - i hope that was a simple exercise
26:34 - because all we have to do is self dot
26:37 - visible
26:39 - and then we need the surface we want to
26:41 - draw on which in our case is self dot
26:43 - display surface and now let's see if
26:47 - this is working
26:48 - and it is indeed working we can see
26:51 - the top part of our game we can't see
26:54 - the bottom part but for that we are
26:56 - going to create a camera later on but
26:58 - for now this is looking pretty good
27:02 - and let me make this a bit smaller
27:04 - so with that we have our rocks
27:06 - next up we also want to place the player
27:09 - so if the column
27:11 - is equal to the letter p
27:14 - then we want to place the player so we
27:16 - want to just create the player
27:19 - and the player is in here it also has
27:22 - position and groups for now so let me
27:25 - just copy them in here
27:26 - and we can actually just copy
27:29 - the arguments from the rock and place
27:31 - them in here
27:32 - so essentially right now the tile and
27:34 - the player identical but they are going
27:36 - to become very different very soon
27:39 - but let's try this and there we can see
27:42 - our player
27:43 - so with that we have our basic level
27:45 - setup
27:46 - and i guess one more thing that we can
27:48 - do for now is that the tile for the rock
27:52 - should be in two different groups it
27:54 - should be indivisible sprites and it
27:56 - should also be let me copy it
27:59 - it should also be
28:02 - in the obstacle sprites
28:04 - i guess let me call it obstacle sprites
28:06 - not obstacles sprite that's very
28:08 - annoying to pronounce now you will not
28:10 - be able to see a difference but now
28:13 - whenever we create a tile this tile is
28:15 - going to be in the visible sprites and
28:17 - inside of the obstacle sprites and later
28:20 - on this will become incredibly helpful
28:23 - because essentially what we will do is
28:25 - we will check the obstacle sprites and
28:27 - the player and if there is any collision
28:29 - we are going to influence the player
28:31 - from that collision and this is actually
28:33 - something we could start working on
28:35 - right now so the next part is going to
28:37 - be about the player
28:39 - and the player is going to become quite
28:41 - substantial because well it's the main
28:44 - player of the game but for now we are
28:46 - going to focus on two things only the
28:49 - movement of the player and the collision
28:51 - mechanics
28:52 - and that is going to allow us to sort of
28:54 - run around the level already
28:57 - and i guess let's do all of this
28:59 - straight in the code that should be the
29:01 - easiest way
29:02 - here we are back in the code and i want
29:04 - to look at my player
29:07 - and right now our player really doesn't
29:09 - do all that much so we have to add a few
29:12 - more things here
29:14 - now first of all
29:15 - we need some kind of direction the
29:18 - player is supposed to walk in and this
29:20 - in my case is going to be a 2d vector
29:22 - so
29:23 - self.direction is usually a good name
29:26 - and what i want is pie game dot map dot
29:30 - vector 2
29:33 - and don't forget the brackets if you
29:34 - leave them empty it's going to be 0 and
29:36 - 0.
29:37 - and this is going to give us a vector
29:39 - that is going to have x and y and right
29:43 - now by default both are going to be zero
29:48 - and what we want to do is to use
29:50 - keyboard input to change either of these
29:52 - numbers to a certain direction
29:54 - for example if we are pressing right
29:56 - then this zero for the x should be
29:59 - a one
30:01 - and then later on we are going to
30:03 - multiply this vector with a certain kind
30:06 - of player speed
30:09 - and that way
30:11 - this direction would become something
30:13 - let's say 5 and 0 and our player would
30:16 - move to the right at the speed of 5
30:18 - pixels per frame
30:21 - so we essentially have to do two things
30:23 - number one we have to get keyboard input
30:26 - and number two we have to multiply this
30:28 - vector by a speed
30:30 - and well let's start with the keyboard
30:33 - input so let's call it just input needs
30:36 - self and nothing else as always
30:39 - and in here
30:40 - we need to get our keyboard input
30:43 - and i guess this could become a good
30:45 - exercise so try to get the keyboard
30:48 - input for up down left and right on the
30:51 - keyboard and see if you can figure this
30:53 - out
30:59 - so first of all
31:01 - i need to get all the keys that are
31:03 - potentially being pressed and this
31:04 - happens with pygame dot key dot get
31:08 - underscore pressed
31:10 - and now what i can do is if keys
31:15 - and we can check for specific key let's
31:18 - say i want to start with pygame.k
31:21 - underscore
31:23 - up
31:24 - and if that is the case i want to set
31:26 - self.direction.y
31:30 - to negative one
31:34 - and that's all we need
31:36 - now we can copy this thing
31:39 - and change this one to
31:41 - down and now y
31:43 - should be one
31:45 - and now we can copy both of them
31:48 - although don't forget they should be
31:50 - alif
31:51 - so right now we are pressing negative
31:53 - one so our player is going up later on
31:56 - at some point now for pressing down
31:58 - this y becomes 1 so our player is moving
32:01 - downwards
32:02 - however now we have a problem that let's
32:06 - say in our game we pressed down and then
32:09 - we lift up the key again our player
32:11 - would keep on moving down because this y
32:14 - being 1
32:15 - sticks around because we don't change it
32:16 - anymore
32:18 - and well our play will just keep on
32:19 - moving downwards which is not ideal
32:22 - but we can fix that quite easily by
32:24 - adding
32:26 - an else statement that self.direction
32:30 - is going to be
32:32 - zero so really all we're checking is is
32:36 - the up key being pressed if that's the
32:37 - case y is negative one if we're pressing
32:40 - down y is going to be positive one and
32:43 - if we are pressing neither of these
32:44 - buttons the player doesn't move in the y
32:46 - direction at all actually i forgot
32:48 - direction dot y
32:50 - and that's it for the y direction
32:53 - now i can just copy the entire thing and
32:56 - do the very same logic for right and
32:58 - left let's say we want to start with
33:00 - right and right is going to be x and it
33:04 - is the positive number and if we go with
33:07 - k left
33:08 - this should also be x
33:11 - and it should be negative one
33:13 - and then direction x is going to be zero
33:15 - this one doesn't have positive or
33:16 - negative and all right with that we have
33:20 - our basic input
33:22 - so now we can give this class an update
33:25 - method
33:26 - so update self that's horrible spelling
33:30 - and for now i just want to get self dot
33:33 - input and now what i want to do back in
33:36 - my level dot pi
33:38 - i also want to update all of the visible
33:40 - sprites
33:42 - so self dot visible sprites dot
33:45 - update
33:46 - and now let's run all of the code and
33:49 - let's see if anything happens
33:51 - so we can't see anything right now
33:54 - but something is happening at least
33:57 - hopefully inside of our player
33:59 - and actually we are able to visualize
34:02 - what's happening by using our debug
34:04 - function but first of all back at my
34:06 - level
34:07 - when i created the player
34:09 - i also want to put this inside of self
34:12 - dot player
34:14 - player and the reason for that is that
34:16 - i'm going to use this software player
34:18 - quite a bit
34:19 - and this way i can target it directly
34:22 - but it is still going to be inside of
34:24 - this visible sprites
34:26 - and well now what i can do is right at
34:29 - the top i can from debug import
34:33 - so this function here and now
34:37 - in my run method i can call debug
34:40 - and i can call self dot player
34:45 - dot
34:46 - direction and now if we run out of this
34:50 - we can see in the top left we have 0 and
34:52 - 0 right now and that's our direction and
34:55 - if i press to the left we get negative 1
34:57 - for x
34:58 - or positive 1 if i press to the right
35:00 - and if i press up we get negative one
35:02 - and if i press down we get plus one for
35:04 - the y
35:05 - and that way i can press in a different
35:07 - directions and we get different numbers
35:10 - so this is already going to give us the
35:12 - keyboard input and all we want to do is
35:15 - to multiply this with a certain kind of
35:17 - speed
35:18 - and that is also going to happen inside
35:21 - of the player
35:22 - so now besides direction i also want to
35:25 - give my player self dot
35:28 - speed at least for now and let's put it
35:31 - at 5.
35:33 - although be aware later on this speed is
35:35 - going to disappear because we will
35:36 - replace it with a proper dictionary of
35:38 - all the player attributes but for now we
35:41 - can work with it quite well
35:43 - and besides that
35:45 - i want to create
35:47 - a move method
35:49 - and this one itself and it's going to
35:51 - need the speed
35:53 - and in here we are going to move the
35:55 - player
35:57 - all we have to do is
35:59 - self.rect.let's say center
36:02 - plus
36:02 - equal
36:05 - self.direction
36:07 - multiplied by the speed
36:10 - and that is all we need so now i can run
36:14 - in the update method self.move
36:16 - and the speed is going to be self.speed
36:20 - and let's actually try this and see what
36:22 - happens
36:23 - so nothing happens if i don't press a
36:25 - button but if i press to the right or to
36:27 - the left or up and down our player is
36:29 - moving so this is working quite well
36:34 - although well you can see that the
36:36 - overlap with the different rocks doesn't
36:38 - work at all right now and we have no
36:40 - collisions but we can at least move
36:42 - around
36:44 - obviously we also don't have a camera so
36:45 - if the player moves outside the window
36:47 - it just disappears
36:49 - but that comes soon although before we
36:52 - get to that there's one more thing i do
36:54 - want to work on and let me illustrate
36:56 - what the problem is right now
36:58 - if i just move left or right
37:01 - or up and down
37:02 - we have a certain kind of speed
37:04 - however
37:05 - if i move to the right and down we are
37:08 - moving significantly faster i think it's
37:10 - quite good to see
37:12 - and the reason for that is trigonometry
37:15 - essentially that if we apply two
37:17 - different directions
37:19 - we are moving slightly faster
37:21 - and this we have to account for
37:24 - and essentially what we have to do
37:26 - in this player
37:28 - so this direction here we have to
37:30 - normalize it and what normalizing means
37:33 - is that we are changing the length of a
37:35 - vector to 1.
37:38 - and that way if we multiply by the speed
37:40 - it's always going to have the same speed
37:42 - no matter what direction we are going in
37:44 - and well doing that is actually super
37:47 - easy all we have to do is if self dot
37:51 - direction dot
37:53 - magnitude
37:56 - 2 that's how you spell that so magnitude
37:59 - essentially is the length of the vector
38:01 - and if that is
38:04 - different from zero then i want to get
38:07 - myself dot direction
38:10 - and simply get self.direction.normalize
38:16 - so first of all we are checking if our
38:18 - vector has any kind of length and as
38:21 - soon as it has a length we are setting
38:23 - the length of the vector to one that way
38:26 - it doesn't matter which direction it's
38:28 - going in it's always going to be one
38:32 - which down here instead number 3 is
38:34 - going to result in the same speed in all
38:36 - directions
38:37 - now the reason why we need this if
38:39 - statement
38:40 - is because a vector of 0 cannot be
38:43 - normalized pygame would throw an error
38:45 - this is why we need this if statement
38:48 - but now if i run main.pi
38:51 - i can move left and right still works
38:52 - but now if i move down
38:54 - now we can see in the top left we get
38:56 - 0.7
38:58 - and that is because of the normalization
39:01 - but well you can see in the game now the
39:03 - movement looks significantly more
39:05 - constant
39:07 - so that's a pretty good start
39:09 - and you might have one question
39:12 - that in the player why do i add the
39:15 - speed as an argument instead of just
39:17 - writing
39:19 - self.speed
39:21 - now this would work but the reason why
39:25 - i'm not doing this
39:26 - is later on for the enemies
39:29 - we want to use the same move method
39:32 - so what i'm essentially going to do is
39:35 - i'm going to later on remove this move
39:37 - method from the player and put it inside
39:39 - of another class along with a couple of
39:42 - other methods actually
39:43 - and then both the player and the enemies
39:46 - are going to inherit from that class and
39:48 - that way i'm going to keep things a bit
39:50 - more flexible so both the enemy and the
39:52 - player can inherit from them and use all
39:54 - of these methods
39:56 - so just keep that in mind if you want to
39:58 - use self.speed
40:00 - but okay with that we have our basic
40:02 - movement so next up we have to work on
40:04 - the collision
40:06 - and collisions generally can be a bit
40:09 - finicky to work with
40:11 - for the simple reason that in pygame all
40:13 - we can really check is if two sprites
40:16 - are overlapping but pygame doesn't tell
40:18 - us where they're overlapping so let me
40:21 - put two sprites on the screen
40:23 - right now we have one sprite and one
40:25 - sprite slightly to the right and the
40:27 - bottom
40:28 - now these two obviously overlap but do
40:31 - they overlap from the right or from the
40:33 - bottom that's a really important thing
40:36 - because what we want to do if they
40:38 - overlap we want to place the colliding
40:40 - rectangle either to the right or to the
40:43 - bottom of this other sprite
40:46 - so the problem we might have is that if
40:48 - we get a collision from the right
40:50 - pie game might get confused and place
40:52 - the sprite at the bottom of the other
40:54 - sprite and in the game this would look
40:56 - like our players teleporting around and
40:58 - it might even break the entire game
41:01 - but fortunately it can be fixed fairly
41:03 - easily all we have to do is to apply
41:05 - each direction individually let's say
41:07 - we're going to start with the horizontal
41:08 - movement so we're going to move the
41:10 - player in the horizontal space check for
41:12 - collisions and if there is a collision
41:14 - we are going to move the player to the
41:16 - point of that collision and once all of
41:19 - that is done we are going to work on all
41:21 - of the vertical movement and collisions
41:23 - that way there cannot be a confusion
41:25 - between what kind of collision is going
41:27 - to happen
41:28 - and well that is all we need to get
41:31 - started so let's go back into our code
41:34 - and let's have a look at this
41:36 - here we're back in the code and i have
41:37 - my player class open
41:39 - now what i would like is to have all of
41:42 - the collisions inside of this class
41:45 - the problem is
41:47 - that this player
41:49 - doesn't know where all of these obstacle
41:51 - sprites are so we have to pass them into
41:54 - the player and this is going to happen
41:57 - by simply giving the player another
41:59 - argument and let's call this one the
42:01 - obstacle
42:04 - sprites
42:05 - and then in the init method i want to
42:08 - get myself dot obstacle sprites it's
42:11 - just going to be
42:13 - obstacle sprites
42:14 - and now when we create the player
42:17 - at the end
42:18 - it is going to get self dot
42:21 - obstacle sprites
42:23 - be aware here
42:24 - we are placing the player inside of this
42:26 - group and then we are giving the player
42:29 - this group here but just for the
42:31 - collisions the player itself isn't in
42:34 - that group that is a really important
42:36 - distinction all right with that we can
42:39 - actually create let me create the
42:43 - collision method in here
42:45 - so let's call it collision it needs self
42:49 - and i want to give it a direction
42:52 - essentially what we are going to do
42:54 - first of all we are going to check the
42:56 - direction and this one could either be
43:00 - horizontal
43:02 - and then we want to do stuff
43:05 - and i guess let's be a bit specific so
43:08 - if direction
43:11 - is going to be
43:13 - vertical then we want to do
43:16 - other collision stuff
43:18 - and let's work on the horizontal one
43:21 - first
43:22 - essentially what i want to do i want to
43:24 - look at all of the sprites inside of my
43:26 - obstacle sprites so for sprite in
43:30 - obstacle sprites in self dot obstacle
43:33 - sprites and now for all of these sprites
43:36 - if sprite dot wrecked dot collide
43:41 - wrecked
43:42 - and self dot rect
43:44 - so we are essentially checking the
43:48 - rectangle of the sprite with the
43:50 - rectangle of the player
43:52 - so this information is going to tell us
43:55 - if there is a collision between these
43:57 - two but we still don't know if this
43:59 - collision happens on the left or on the
44:02 - right
44:02 - but this we can also get quite easily
44:06 - because we know the direction of the
44:08 - player
44:10 - so for example if this is our player and
44:13 - our player is moving to the right
44:16 - then it would be pretty unlikely to have
44:18 - a collision on the left side that would
44:21 - be a little bit strange
44:24 - instead we can kind of predict that we
44:26 - are always going to have a collision
44:29 - on the right side if the player is
44:31 - moving to the right
44:32 - and then the same thing for the left
44:34 - side if we're moving left all of our
44:36 - collisions are going to be on the left
44:38 - as well
44:39 - i guess important to say here all of our
44:41 - obstacles are going to be static so that
44:44 - should make it much easier
44:46 - all we have to do
44:48 - is if self dot
44:51 - direction
44:52 - dot x let's say is greater than zero
44:57 - so if that is the case we are
45:00 - moving right
45:02 - and if we are moving right we need
45:04 - self.rect.right
45:07 - that's not how you spell that
45:10 - is going to be sprite
45:13 - dot wrecked dot left
45:16 - so now essentially what's happening here
45:18 - if we have our player so this again
45:21 - is our player our player is moving to
45:24 - the right
45:26 - and now our player is colliding
45:28 - with some kind of obstacle and they are
45:30 - overlapping right now
45:32 - what i essentially want to do
45:34 - is to move the right side of my player
45:36 - so this side here
45:38 - to the left side
45:40 - of the obstacle we have been colliding
45:42 - with
45:43 - so that way it looks like the player is
45:45 - always on this particular side and
45:47 - they're not overlapping
45:49 - and that is all we have to do with this
45:52 - line here
45:53 - so now next up we have to do the very
45:55 - same thing for the other side so if
45:58 - self.direction
46:00 - dot x
46:02 - is smaller than zero
46:06 - then self.rect.left
46:09 - is going to be sprite dot direct dot
46:13 - right
46:15 - so the exact flip side of the upper line
46:18 - this is then all we need for the
46:20 - horizontal collisions now next up we
46:23 - have to do the very same thing for the
46:25 - vertical ones
46:26 - and this i think could be a really good
46:28 - exercise for you
46:30 - so after looking at the horizontal
46:32 - collisions
46:33 - try to do the same thing for the
46:34 - vertical ones so you want to check for
46:36 - the up and the down movement
46:44 - let's try together now but first of all
46:46 - i want to add proper comments so this is
46:48 - moving left
46:50 - and now let me just copy
46:52 - the entire thing
46:55 - now the first two lines are still
46:57 - perfectly fine but besides that i now
47:00 - want to look at direction dot y so if
47:03 - direction dot y is greater than zero we
47:06 - are moving down
47:09 - and if that is the opposite way so we
47:11 - are smaller than zero we are moving
47:15 - up
47:16 - so if we are moving down
47:18 - we want to place the bottom of the
47:20 - rectangle
47:22 - at the top of the sprite so essentially
47:25 - what we are doing if this is our player
47:27 - again right now our player is moving
47:30 - down
47:31 - and if now
47:33 - we are colliding with any kind of
47:35 - obstacle
47:36 - the bottom of our player should be at
47:38 - the top of the obstacle
47:40 - so this line here
47:43 - and then we have to do the same thing
47:45 - for the up movement so the top of our
47:48 - rectangle
47:49 - is going to be at the bottom of the
47:52 - collision object
47:54 - and all right with that we have our
47:57 - collisions
47:58 - actually not all that bad
48:00 - so let me minimize this
48:03 - and now
48:04 - we have to work in this move method
48:07 - and essentially we have to take this
48:11 - method here
48:12 - and split it apart into
48:15 - the x and the y movement
48:17 - so
48:18 - self.direct self.rect.x
48:21 - plus equals self.direction.x
48:25 - multiplied by the speed
48:27 - and then we can do the same thing for
48:32 - the y
48:33 - so if i just left it at this and ignore
48:36 - the collision method entirely
48:38 - we shouldn't see any kind of difference
48:42 - and things are still looking pretty
48:45 - identical cool good start
48:47 - but now what i want to do
48:49 - after we are moving our player let's say
48:52 - on the x
48:53 - after we have done this i want to call
48:55 - myself dot collision
48:58 - and i want to check my horizontal
49:00 - collisions and let's just use one of
49:03 - them to see what is happening
49:05 - so now if i run my main file
49:07 - i can move to the left and i have proper
49:10 - collisions
49:11 - although if i move from the top
49:14 - nothing is going to happen and pie game
49:16 - is getting a bit glitchy
49:18 - but this we can fix quite easily because
49:21 - all we have to do
49:22 - is call self dot collision
49:26 - and now we want the vertical collisions
49:30 - so now if i run out of this
49:32 - we get very nice working collisions and
49:36 - everything is working just fine cool
49:39 - this is looking really good
49:42 - there are no bugs
49:44 - as far as i can see this is working very
49:47 - nicely
49:48 - now the problem is i can actually
49:50 - demonstrate this i can move outside of
49:52 - the window no problem
49:54 - so this is not ideal
49:57 - also
49:58 - the game doesn't look as good as it
50:00 - could because there are no overlaps so
50:03 - for example if i'm on top of a rock
50:05 - my player stops where the rock begins
50:08 - but ideally there should be a tiny bit
50:10 - of overlap to give the illusion of depth
50:13 - which is what we are also going to need
50:17 - so let's work on these two bits
50:20 - now to achieve both of these things the
50:22 - camera and the overlap we essentially
50:25 - have to create our own group
50:28 - or at the very least we have to take a
50:29 - spread group and change some key
50:32 - functionality
50:34 - and that is very neatly going to bring
50:36 - us into a bit more of an advanced
50:38 - concept inside of pygame
50:41 - so far if you follow this channel we
50:44 - only ever used a group to place a sprite
50:46 - in there to update them and to draw them
50:49 - but you can totally take a sprite group
50:52 - and rewrite some core functionality
50:55 - but to do that we first have to
50:57 - understand what a group is actually
50:58 - doing and fortunately it really isn't
51:01 - all that complicated
51:03 - essentially all that the spread group
51:05 - really does is that it stores a ton of
51:08 - different sprites then it can call the
51:10 - update method and all of these sprites
51:12 - and we can also draw all of the sprites
51:15 - and all that is really going to happen
51:17 - inside of a draw method of a group is
51:20 - that we are going to call blit with the
51:22 - sprite and the rectangle of whatever
51:24 - sprite we have inside of that group so
51:26 - with that knowledge we can totally
51:28 - override key parts of a group or give it
51:31 - extra functionality
51:33 - here i'm back in my code and i want to
51:35 - go to my level
51:37 - and
51:38 - i want to change this visible sprites
51:41 - class
51:42 - to a custom made group
51:45 - and let's create that class in the same
51:47 - file i think that makes sense and i'm
51:51 - going to call this new class y
51:54 - sword
51:55 - camera
51:57 - group
51:59 - and it's going to inherit from
52:00 - pygame.sprite.group
52:04 - and the naming here has two key parts
52:07 - number one
52:09 - the more obvious one
52:11 - the camera group so this spread group is
52:15 - going to function as a camera and that's
52:17 - the part we are going to work on in just
52:19 - a second
52:20 - the other part the y sword
52:23 - means that we are going to sort the
52:25 - sprites by the y coordinate and that way
52:28 - we are going to give them some overlap
52:30 - now in here we are going to need a
52:33 - couple of different things first of all
52:34 - as always
52:36 - we need a dunder
52:38 - init with self and nothing else
52:41 - and let me start with a general setup of
52:44 - all the stuff we are going to need now
52:46 - first of all as always like with the
52:49 - sprite we need super
52:51 - ideally spelled correctly that tends to
52:53 - help
52:54 - dot init
52:56 - no arguments are needed now once we have
52:58 - this we can actually replace
53:01 - our
53:03 - visible sprites with this group
53:06 - so why sort camera group and since we
53:09 - haven't replaced any functionality yet
53:12 - and we've initiated the original class
53:14 - this should still work let's try it
53:18 - and we still get the very same
53:19 - functionality
53:21 - everything works as intended
53:23 - so at the very least we didn't break
53:25 - anything yet
53:27 - but with the setup we can make some
53:29 - simplifications
53:31 - for example what we could be doing let
53:33 - me actually go to the display surface
53:35 - and let me copy this line here just to
53:38 - illustrate what we can do a very simple
53:40 - example
53:41 - now with our display surface
53:43 - inside of our class
53:47 - so now i can create
53:50 - a new let's call it
53:52 - custom
53:53 - draw
53:54 - and itself and nothing else for now and
53:59 - really all we need to create our custom
54:01 - draw is for
54:04 - sprite
54:05 - in
54:07 - self.sprites
54:08 - and don't forget the brackets
54:10 - and now we can get all of the sprites
54:13 - and now all we have to do is self dot
54:15 - display surface
54:17 - dot blit
54:20 - and we need sprite dot image and sprite
54:24 - dot rect
54:26 - so this is essentially what a normal
54:28 - sprite group is going to do
54:31 - and now in our run method
54:34 - we can replace our draw from the
54:37 - original group
54:38 - with custom draw
54:40 - and now we don't need any arguments
54:42 - because we already have the display
54:44 - surface
54:45 - and let's run this
54:46 - and it's still working just fine
54:49 - except now we're using a custom draw
54:51 - that is going to give us significantly
54:54 - more power
54:56 - and i guess what i can do
54:58 - we can get rid of this debug it isn't
55:01 - useful anymore
55:02 - now we want to use this for two specific
55:05 - purposes number one we want the camera
55:07 - number two we want some overlap between
55:09 - the different sprites in the y direction
55:12 - and let's start with the camera that's
55:14 - the more important bit
55:16 - and the logic to make the camera work is
55:18 - actually surprisingly simple
55:21 - and all of it happens in the custom draw
55:24 - but by default we are always drawing
55:26 - this bright image in the same position
55:28 - as the sprite rectangle but we don't
55:31 - have to we can totally give this bright
55:33 - rectangle a certain kind of offset
55:36 - and this is what we are going to use for
55:38 - the camera
55:39 - so really all that's going to happen in
55:41 - practice when we are calling blit on the
55:43 - surface
55:44 - we are still going to keep our sprite
55:46 - dot image but now for the sprited rect
55:49 - we are going to add a vector to give
55:51 - them a certain kind of offset and this
55:54 - vector is essentially going to be our
55:56 - camera
55:57 - because it's going to give us control
55:59 - where the sprites are going to be drawn
56:02 - and then really all we have to do is to
56:04 - get the offset from our player and
56:06 - connect this to this bright rect vector
56:10 - and once we have that we are good to go
56:12 - essentially we are going to give the
56:14 - offset of the world to wherever the
56:16 - player is going to be
56:19 - and well i think this makes much more
56:21 - sense once we actually implement it so
56:24 - let's go back into the code and here we
56:26 - still have our y sword camera group and
56:30 - what i want to achieve is that the
56:31 - player is always right in the middle of
56:34 - the window
56:36 - but that's going to come in just a
56:37 - second first of all let me illustrate
56:39 - what i mean with the offset
56:42 - essentially all that's going to happen
56:44 - is we're going to create a vector let's
56:47 - call it
56:48 - offset
56:49 - and this offset is going to be
56:51 - pygame.math.vector2
56:55 - needs to be
56:56 - capitalized and by default is going to
56:59 - be 0 and 0.
57:01 - and this vector we are going to add to
57:04 - our sprite rectangle so all we have to
57:06 - do in here
57:08 - let me create a new let's call it the
57:10 - offset rectangle
57:13 - and this offset rectangle
57:15 - is going to be the sprite
57:18 - dot direct dot top left
57:21 - and then plus self dot
57:24 - offset and that way we are going to get
57:28 - a new position it's not a rectangle
57:30 - anymore but well
57:32 - high game is happy with a tubal so this
57:34 - is still fine
57:35 - so now we can do
57:37 - is put this
57:38 - offset
57:40 - rect actually let me call it offset
57:42 - position that's going to make more sense
57:44 - so offset
57:46 - position
57:47 - and now
57:49 - anytime
57:50 - we have any kind of offset we are going
57:52 - to add this to our rectangle now right
57:55 - now this is going to be zero so we
57:57 - should not be seeing any kind of change
57:59 - so let's run main.pi
58:01 - and we still get the same outcome
58:04 - but what we are now able to do is if i
58:07 - give this vector some starting positions
58:09 - let's say 100 and 200
58:13 - now if we run out of this
58:15 - our entire game is slightly offset so
58:18 - this is the offset we have just given it
58:23 - so what you can see here
58:25 - is that this distance is 100
58:29 - and this distance is 200
58:33 - so essentially our game itself didn't
58:37 - actually change any kind of position we
58:39 - are just drawing all of the elements in
58:41 - a different spot
58:43 - and the distance to that spot is
58:46 - determined by our offset
58:48 - so this is working really well
58:51 - now next up what i have to figure out is
58:54 - how to connect this offset to my player
58:57 - and since i want the player to be
58:59 - exactly in the middle of the screen i
59:01 - first need half the screen width and
59:03 - half the screen height and we can do
59:05 - this in the init method so let's call
59:07 - this half
59:09 - with
59:10 - and all we need to get this is self dot
59:13 - display surface dot get underscore size
59:17 - and for x we need zero and we want to
59:20 - floor divide this by two so we are
59:22 - getting an integer
59:23 - now we can do the same thing for the
59:27 - height
59:28 - and all we have to change is from the
59:30 - tube we get from get size we need the
59:32 - first one
59:33 - and that's going to be the y one so now
59:36 - we know how much distance we want from
59:37 - the left and from the top
59:40 - so all we have to do in our custom draw
59:43 - i want to get another argument and that
59:46 - is going to be the player
59:48 - so when i call custom draw up here
59:50 - i want to pass in self dot
59:53 - player
59:54 - so now i can access the player and get
59:57 - the player position
59:59 - and let me add another comment here and
60:01 - let's call it getting the
60:03 - [Music]
60:04 - offset
60:06 - and in here i want self.offset.x
60:11 - and then dot y
60:13 - so now we have to figure out these two
60:15 - positions
60:16 - and unfortunately we couldn't just add
60:19 - player.rect.center
60:23 - x
60:24 - and
60:26 - player.rect.center y
60:28 - although it would be nice and simple
60:30 - actually
60:31 - let's try and see what happens if we
60:33 - just use those two numbers
60:35 - so now back in my main file
60:38 - now if i move the player
60:41 - we get something but
60:45 - looks a bit weird
60:48 - but we do get something that's at least
60:50 - a start and essentially all we have to
60:53 - do is from this number subtract either
60:56 - self dot half with
60:59 - and self dot half
61:02 - height
61:03 - so now we are getting some kind of weird
61:06 - outcome
61:08 - and i might be able to see the player i
61:10 - could see her there for a bit so now the
61:13 - camera movement is a bit weird
61:16 - and the reason for that
61:19 - is that
61:20 - this plus here should be a negative and
61:24 - now let's try this again it should work
61:26 - and there we go
61:28 - this feels significantly better
61:34 - and with that
61:36 - we have our offset
61:38 - and if you're really interested in the
61:40 - math here i would recommend to go over
61:42 - the geometry a couple of times it is a
61:45 - little bit weird but once you go over it
61:48 - it should make sense
61:50 - and probably just draw it out a couple
61:51 - of times eventually it starts to make
61:53 - sense
61:55 - but that is literally all we needed for
61:57 - the camera movement
61:58 - so now we have covered the first part we
62:00 - have a proper camera movement
62:03 - so i guess now we can start working on
62:06 - part number two the overlap and this one
62:09 - consists essentially of two things the
62:13 - first one is a hitbox for all of our
62:15 - sprites so right now for example for our
62:18 - player the hitbox is the entire image
62:21 - but i don't want that to be the case i
62:23 - want the hitbox of the player to be
62:25 - slightly smaller than the original image
62:29 - and these parts are going to be the
62:31 - overlapping parts
62:32 - but this by itself wouldn't be enough
62:34 - because our group right now doesn't know
62:37 - what elements to draw on top and what
62:39 - element to draw on the bottom this is
62:42 - going to be another part we have to make
62:43 - ourselves
62:45 - it's not actually that difficult but
62:47 - it's something we have to implement
62:49 - but i guess let's go through it step by
62:52 - step and let's first of all start by
62:54 - creating all of our sprites a custom
62:56 - hitbox
62:58 - so here we are back in the code and i
63:01 - want to start with the tile that's going
63:02 - to be the easiest one
63:05 - and right now
63:06 - we have our rectangle so this is always
63:09 - going to be the full size of our entire
63:12 - image
63:14 - i want to give it another attribute and
63:16 - that is going to be self dot hit box
63:19 - and the hitbox is going to be
63:21 - essentially the same as self.rect
63:24 - except now we want to change the size
63:27 - and this happens with inflate
63:31 - and what inflate essentially does is it
63:33 - takes a rectangle and it changes the
63:35 - size
63:37 - so in my case really all i want to do is
63:40 - if this
63:42 - is my original rectangle
63:45 - then i want the hitbox to look something
63:48 - like this
63:51 - so we have the same width the same
63:53 - center but the top and the bottom are a
63:55 - bit shorter
63:57 - and that way later on the player could
64:00 - be standing behind this for example
64:04 - and that's really the entire idea of all
64:06 - of this
64:07 - and inflate needs two arguments one for
64:09 - x and one for y
64:11 - now my x
64:13 - can just remain zero
64:15 - but for my y i want to have a specific
64:17 - number
64:18 - and let's say just to get started let's
64:21 - go with negative 10. oh and by the way
64:24 - this is going to keep the center point
64:26 - at the same position so let me draw all
64:28 - of this again this is our original
64:32 - rectangle
64:33 - and now our hitbox
64:35 - is going to have
64:37 - the same center
64:38 - but now on the top
64:41 - and the bottom
64:42 - we are going to have a 5 pixel
64:45 - because we specified negative 10 up here
64:48 - and negative 10 makes the entire thing
64:50 - shrink by 5 pixels on each side
64:53 - and now we have to do the very same
64:55 - thing for the player
64:57 - and let me do it right below the
64:59 - rectangle so self dot hitbox
65:03 - is going to be self dot wrecked dot
65:06 - inflate
65:08 - and for my player let's say for now i
65:10 - want to go with 0 and since the player
65:13 - is a little bit taller
65:15 - i want to go with negative 26
65:18 - and now let's run the code and
65:20 - well this shouldn't make any difference
65:22 - for now but at least the code isn't
65:24 - crashing so that's a good start
65:27 - but now essentially what i want to do
65:30 - i am not going to move the rectangle
65:32 - anymore instead i'm going to move the
65:35 - hitbox and i'm going to move the hitbox
65:38 - and check collisions on that hitbox as
65:40 - well
65:41 - and after all of that is done
65:43 - i'm going to put the center of the
65:44 - rectangle where the hitbox is going to
65:47 - be so that way the rectangle always
65:49 - follows the hitbox
65:51 - and that way i can get all the
65:53 - collisions with the hitbox and have some
65:55 - overlaps but then draw the player in the
65:57 - correct position
65:59 - so essentially what we have to do
66:02 - let's go with move first
66:05 - and let's get rid of this comment we
66:07 - don't need that one anymore
66:09 - so instead of self.rec.x
66:12 - we want to move self.hitbox
66:16 - and we want to move both x and y
66:20 - and at the end of all of this we want to
66:22 - get self.rect.center
66:26 - is going to be self.hitbox.center
66:30 - and now what we can do
66:33 - that instead of checking the rectangle
66:35 - of all of the sprites we want to check
66:38 - the hitbox so this should be hitbox
66:41 - and we're also not going to check the
66:43 - rectangle of our player but the hitbox
66:45 - of our player
66:47 - and this is going to happen
66:50 - for basically all of the rectangles we
66:52 - are going to replace them
66:54 - with the hitbox
66:57 - so this should be hitbox this should be
66:59 - hitbox this should be hitbox hitbox
67:02 - hitbox and finally hitbox
67:05 - and now
67:07 - let's see if this is going to work
67:10 - so now
67:11 - we can indeed see some offset so right
67:15 - now our player is behind the rocks and
67:17 - this is looking
67:18 - really really good
67:20 - the problem we have now is that our
67:22 - player is always below the rocks
67:26 - so no matter where we go oh except here
67:28 - because these rocks were created earlier
67:31 - in the level setup so these rocks are
67:35 - behind the player because they created
67:36 - earlier in the code
67:38 - but these were created after
67:40 - these were created after
67:42 - and further down here all of these rocks
67:44 - are above our player
67:46 - so this is going to look kind of silly
67:49 - but we are very nearly there
67:52 - so
67:53 - we are making some definite progress
67:56 - there's only one more thing that we need
67:59 - so right now we have a custom hitbox for
68:02 - both our player and for our tiles
68:05 - now the last thing we have to do in our
68:07 - ysort camera group
68:09 - we have to order our sprites so we have
68:12 - to tell it when to draw each of these
68:14 - sprites
68:15 - and right now they are being ordered by
68:18 - the time of when they are being created
68:20 - this happens
68:22 - here some of the tiles were created
68:25 - before the player but some tires were
68:28 - created after the player was created so
68:30 - those tiles would be on top of the
68:32 - player whereas the titles created before
68:34 - the player was created they would be
68:36 - below the player
68:37 - and in most situations this really
68:39 - doesn't matter but in our case we don't
68:42 - want to order our sprites by that logic
68:46 - instead
68:47 - we want to order our sprites by the y
68:49 - position and essentially the sprite that
68:52 - should be drawn on top should be the one
68:53 - with the highest y position
68:56 - because if the sprite is a lower wide
68:58 - position than another sprite then the
69:00 - sprite that should be behind or high up
69:02 - on the screen should be behind that
69:04 - other sprite in godot for example this
69:07 - is just being called y sword
69:10 - and this is basically what we're
69:11 - implementing ourselves manually right
69:13 - now and the way we are doing it is by
69:16 - using the sorted function
69:18 - and let's do this straighten the code so
69:21 - here right now
69:22 - we are just going through all of the
69:24 - sprites but this
69:26 - i don't want to do anymore
69:28 - instead
69:29 - i want to go with for sprite in
69:33 - sorted
69:34 - and sorted essentially takes two
69:37 - arguments first of all it wants a list
69:39 - of what we want to sort and this we do
69:42 - have it's just self dot sprites
69:45 - and again don't forget the brackets it's
69:47 - very easy to do
69:48 - and next up it wants some kind of key
69:52 - and the key essentially going to be by
69:54 - what kind of metric we are going to sort
69:57 - all of the sprites
69:58 - now in our case this should be the y
70:00 - position of each of the sprites
70:03 - and to get that we basically need a
70:05 - lambda function so lambda and i want to
70:09 - look at this sprite and all i want to
70:11 - return is sprite.rect.center
70:16 - y i guess let me know if you want a
70:19 - specific video on the sorted function
70:22 - once you're nested lambdas it's actually
70:24 - pretty simple but now we have overlaps
70:27 - so let me run the code again and now
70:31 - we are still behind the rocks but now if
70:33 - i go a bit further down
70:35 - now we are on top of the rocks but if we
70:38 - go behind them we are well behind them
70:41 - and all of our collisions still work
70:44 - just fine
70:45 - and all of the overlapping works really
70:48 - nicely
70:49 - and this is going to make our game look
70:52 - really good
70:54 - so cool this is working exceptionally
70:57 - well nice
70:58 - there are no bugs so anything this is
71:00 - all working good cool
71:02 - and with that we have a basic top-down
71:04 - game with a camera collisions overlaps
71:06 - and all of the good stuff
71:08 - now i guess for the rest of the game we
71:10 - are just going to add more and more
71:12 - visual detail and enemies and extra
71:14 - stuff to it to make all of this into a
71:17 - proper game
71:18 - but at this stage you already have the
71:19 - basic logic you need to really create
71:22 - any kind of top down game
71:24 - i guess next up we can start working on
71:26 - importing the actual map to make this
71:29 - entire thing look significantly better
71:32 - now for the graphics we are going to
71:34 - need quite a few different things for
71:37 - now we only had our world map and we
71:40 - spawned either a rock or player which
71:43 - really wasn't ideal
71:45 - but to get the actual graphics of the
71:47 - entire game
71:48 - we are first of all going to need
71:50 - significantly more data
71:53 - and that is going to be way more data
71:55 - than i could assemble by hand so we have
71:57 - to use a program
71:59 - and the program that i am using is
72:01 - called tiled which is super useful
72:04 - completely free and it allows you to
72:06 - assemble graphics and let me actually
72:09 - show how this looks
72:12 - so here we have the tiled editor and
72:15 - right now you can see our entire map
72:18 - and this thing i essentially created
72:21 - from these tiles on the right so here we
72:24 - have all our floor tiles here we have
72:26 - the details
72:28 - we have flowers and we have trees
72:30 - so i could for example literally just
72:33 - pick a tile
72:34 - and draw over this thing and expand it
72:39 - and i have made an entire tutorial on
72:42 - how to use tiled so for this video i am
72:45 - not going to go over it and i will keep
72:48 - the map i have already created so this
72:50 - thing took about an hour possibly a bit
72:53 - more to assemble as a whole actually
72:56 - let's go through the entire thing layer
72:57 - by layer and then i can explain how this
73:00 - comes together
73:01 - so right now we have nothing and the
73:04 - bottom layer looks like this
73:07 - this is going to be our ground and on
73:09 - top of that we have some details they
73:12 - will be integrated into the ground as
73:14 - well
73:15 - and essentially what i'm going to do i
73:17 - am going to export this entire thing as
73:20 - one image
73:21 - and this one image will be below all of
73:24 - the other objects so even below the
73:26 - player
73:27 - and then if we move this map it looks
73:30 - like our player is moving on top of an
73:33 - actual surface
73:34 - but in reality we are just moving an
73:36 - image
73:38 - now on top of that
73:39 - something we can't see but that's really
73:41 - important is floor blocks
73:44 - and flow blocks if i make it visible
73:46 - is going to be our constraint that our
73:48 - player cannot walk outside of the map
73:51 - so all of these red squares are going to
73:54 - be obstacles that the player cannot
73:56 - cross and they are blocking the entire
73:58 - map so the player cannot leave it
74:01 - and in the game they are not going to be
74:03 - visible so let's hide them
74:05 - now on top of that we have our entities
74:08 - the blue p is our player and besides
74:11 - that we have all of our enemies
74:14 - now then we have grass and the grass is
74:18 - well the grass and finally we have the
74:20 - larger objects and those are of the
74:22 - statues the trees the rocks all of that
74:25 - kind of stuff
74:27 - and importantly
74:28 - all of the objects the grass the
74:31 - entities and the flow blocks have to be
74:34 - placed by going over the entire layer so
74:37 - we have to circle through the entire
74:39 - layer like we have done for the world
74:41 - map and place all of these elements
74:44 - and to make that work in our game we
74:47 - will later on have to import quite a few
74:49 - different things for example we have to
74:51 - import the graphics for each individual
74:53 - tree and rock and statue into pie game
74:57 - same for all the enemies same for the
74:59 - player and there is going to be a lot of
75:01 - importing
75:02 - and also when we export these data sets
75:05 - we get a csv file which stands for comma
75:09 - separated value which effectively is a
75:12 - long list with numbers and these numbers
75:14 - tell us where stuff needs to be and
75:16 - those numbers we also have to import and
75:19 - all of that gets quite complex
75:21 - so this section will be quite heavy on
75:23 - managing all of that data
75:26 - but i guess let's go for the step by
75:27 - step and let's start with the easier bit
75:29 - and that is going to be the floor
75:32 - and for that we are just going to be
75:34 - importing an image and placing it below
75:36 - every other element and then we are good
75:39 - to go
75:40 - here we are back in the code and i want
75:43 - to go to level
75:44 - and
75:46 - all of our drawing is happening
75:48 - in this section down here so essentially
75:51 - this part here draws all of our elements
75:55 - and we kind of want to draw our floor in
75:58 - there as well
76:00 - the problem is that the floor is
76:03 - slightly different from all of the other
76:04 - elements so we couldn't just add the
76:06 - floor to the sprites and call it a day
76:09 - for the simple reason let me actually
76:11 - draw this
76:12 - that right now
76:13 - we are drawing all of our elements
76:17 - by their y position
76:21 - so this is essentially how our drawing
76:24 - is going to work
76:26 - so the greater of a white position an
76:28 - object has the higher up on this thing
76:31 - is going to be drawn and we are looking
76:33 - at the center of the y position now the
76:37 - problem with that is that our map is
76:39 - always supposed to be on the bottom so
76:41 - our map is always supposed to be here it
76:44 - needs to be below all of the other
76:46 - elements otherwise it wouldn't be a
76:48 - ground or a floor
76:49 - so we have to place this in here anyway
76:52 - and if we didn't do it it would end up
76:55 - somewhere let's say here
76:57 - and since it's a giant image it would
77:00 - essentially cover up
77:02 - the entire field and we wouldn't be able
77:05 - to see anything
77:06 - so we have to make sure it's below all
77:08 - of the other elements
77:10 - so what we are going to do to this group
77:13 - we are going to add a surface and a
77:14 - rectangle for the floor specifically and
77:17 - that is not going to be a sprite
77:19 - but then in this custom draw we are
77:22 - going to draw it and i guess let me
77:24 - implement this straight away
77:26 - so in here creating the
77:29 - floor
77:31 - and for this i need two different parts
77:35 - first of all i need the actual image of
77:38 - the floor so self dot let's call it
77:40 - floor
77:42 - surface
77:43 - and this is just going to be an image so
77:45 - pygame.image.load
77:48 - and this i need to go up
77:50 - i need to go to my graphics
77:52 - in my graphics there's a folder called
77:54 - tilemap
77:55 - and in tile map we have ground dot png
77:59 - and this we also want to convert but we
78:02 - don't need convert alpha this time and
78:04 - next up since we do want to place it i
78:07 - also want to have
78:08 - self.floor underscore rect and let me
78:11 - call it surf instead of surface so
78:13 - things are lining up a bit nicer and
78:15 - this is just going to be self dot floor
78:18 - surface dot get underscore rect
78:21 - and the top left for now is going to be
78:23 - 0 and 0
78:25 - but this doesn't actually matter all
78:27 - that much since we are going to change
78:29 - it
78:30 - well right now
78:32 - and really what we have done so far in
78:34 - our custom map
78:35 - we have created an
78:37 - offset position and the offset position
78:40 - came from the top left of the rectangle
78:43 - and the offset
78:44 - and the offset we got
78:47 - from the player
78:49 - so now what we want to do is the exact
78:52 - same thing
78:53 - except now we only want to do it for the
78:56 - floor surface and not for all of the
78:58 - sprites
78:59 - and this could be a pretty good exercise
79:01 - for you so try to implement the offset
79:04 - for the floor and then draw the floor
79:06 - before the for loop for the sprites
79:14 - now first of all let's add another
79:17 - section and let's call this one drawing
79:19 - the floor
79:21 - and first of all we are going to need a
79:23 - floor
79:24 - offset
79:25 - position
79:26 - and this we get in the same way that we
79:28 - have used just before so we want self
79:31 - dot floor rect dot top left and then
79:36 - minus self dot
79:38 - offset
79:39 - and that is going to be all that we need
79:43 - so now we can run self dot display
79:46 - surface
79:47 - dot blit
79:49 - and self dot floor surface
79:52 - and
79:53 - i call this one floor offset position
79:56 - and that is literally all we needed so
79:59 - let's run this and see what happens
80:02 - and there we go now in the top left of
80:04 - our world we have oh well
80:08 - below our player we have the entire
80:10 - world map
80:11 - now right now we can't really walk over
80:14 - it and we can well we can kind of walk
80:16 - over it but you get what i mean
80:18 - but right now all of the rocks don't
80:21 - line up at all anymore
80:23 - so we have to make a few more changes
80:25 - but at the very least for now the basics
80:28 - are working
80:29 - so this is quite nice
80:32 - and now next up we have to work on all
80:36 - of the other objects and this one is
80:38 - going to need a little bit more work
80:41 - but i guess we can start with by
80:43 - removing the old stuff and just placing
80:46 - the player somewhere in the middle of
80:47 - the screen
80:49 - and this is going to happen in our level
80:51 - and let me minimize our camera group so
80:54 - we can focus on this a bit more
80:57 - so right now we are using all of this
81:00 - stuff here
81:03 - to set up our world
81:05 - and this worked so far but now we want
81:08 - to get rid of it
81:09 - so let me comment out
81:12 - essentially all of this except i want to
81:15 - copy the player
81:17 - and
81:18 - now i want to place the player somewhere
81:21 - on the map
81:22 - let's see what works
81:24 - let's say 400 and 300 and that might be
81:29 - a good position
81:31 - yeah okay i probably need
81:34 - larger numbers
81:36 - let's say 2000
81:38 - and 1500.
81:43 - we are almost there let's say one
81:45 - thousand
81:46 - four
81:47 - hundred
81:48 - thirty
81:50 - because that way we should be on the
81:51 - path and we make sure we are not going
81:53 - to hit any other tile so our player
81:56 - isn't going to collide with anything by
81:57 - default but now we can move around our
82:00 - entire map
82:02 - there are no collisions yet but well we
82:06 - have a much better system
82:10 - so now essentially all we have to do is
82:12 - to reintroduce all of the layers and
82:15 - then work with them
82:16 - although they just might be a little bit
82:19 - oversimplifying things
82:21 - so let's go through what we are going to
82:23 - do first of all
82:25 - we have to make our tile a bit more
82:27 - flexible because so far the rocks are
82:30 - the only tile we could have but in this
82:33 - section we have many more and many more
82:35 - differently sized tiles
82:37 - and we also have some tiles that
82:39 - shouldn't have any graphic whatsoever
82:41 - for example the tile for the collisions
82:43 - that limit our player they don't have a
82:46 - graphic but since they are also sprites
82:48 - they will need some kind of surface
82:51 - so essentially our tile class
82:53 - needs to be able to accept any size
82:55 - graphics and also be able to accept no
82:58 - graphics at all
83:00 - and i guess let's implement this
83:03 - and all of this is going to happen in
83:05 - our title class or well the tile file
83:08 - and this is going to get two more
83:10 - arguments the first one i want to call
83:12 - sprite
83:14 - type
83:15 - because later on we do want to have a
83:17 - bit more control over what kind of
83:19 - sprite we have
83:20 - and besides that
83:22 - i also want to pass in a surface as an
83:25 - argument
83:26 - and this could then be anything but if
83:29 - we don't pass in any surface
83:32 - this class should generate its own
83:34 - surface so as the default argument here
83:37 - i want to have pygame dot surface
83:41 - so this is just going to give us a black
83:44 - surface that we can work with and the
83:46 - size of that should be tile size
83:49 - and tile size
83:52 - so by now since our tile size is 64. the
83:56 - one we determine here
83:58 - if we don't pass in the surface as an
84:00 - argument we get a tile size of 64 by 64.
84:04 - and then for the image
84:06 - this is then going to be what we get
84:09 - and besides that i also want to get
84:12 - self.sprite type is going to be sprite
84:16 - type
84:17 - and this later on for example could be
84:19 - an enemy or could be invisible or it
84:21 - could be any of those things
84:23 - and that's going to allow us to target
84:25 - in a bit more detail what's going to
84:27 - happen to any of these
84:29 - so we are using both groups and the
84:31 - sprite type to determine what a sprite
84:34 - is going to do in the game for example
84:37 - later on if the player attacks grass the
84:39 - grass should disappear immediately but
84:41 - if we attack an enemy we should just
84:43 - reduce the health of the enemy but both
84:45 - of those are going to be in essentially
84:47 - the same groups
84:48 - this is for now all we need for our
84:51 - title class
84:53 - now we can go back to our level
84:56 - and what we first of all have to do
84:58 - is to import all of the layouts because
85:01 - right now let me open them in the folder
85:04 - so in our project we have a map folder
85:07 - and in here we have six different files
85:09 - we don't need all of them so map floor
85:12 - and map details we could just ignore
85:14 - but floor blocks we do need to import
85:18 - and by default we couldn't work with a
85:21 - csv file so we have to figure out how to
85:23 - import this kind of file
85:26 - and then convert it so it looks more or
85:28 - less like this world map so that we can
85:30 - work with it
85:32 - and this i still want to do in my create
85:35 - map
85:36 - and since we have a couple of different
85:37 - files i want to turn this into a
85:39 - dictionary
85:41 - and in here let's start with the easiest
85:43 - one the boundary so this is going to be
85:45 - what limits our player
85:48 - and in here essentially what i want to
85:50 - store
85:51 - is
85:53 - this kind of world map except for all of
85:56 - the boundaries
85:58 - so i have to write a function like
86:00 - import csv
86:02 - layout and this one should then get the
86:04 - path to my csv
86:06 - file something like this
86:10 - so what we have to do is to actually
86:13 - write this function
86:15 - and this since we are going to be using
86:17 - it quite often i put into a separate
86:20 - file so let's create a new file
86:23 - and i save this one as support dot
86:26 - pi
86:27 - and in here we want to define import csv
86:32 - layout and it needs a path
86:35 - and nothing else
86:36 - and just to demonstrate what i'm doing
86:38 - while we're doing it
86:40 - let's call this function
86:42 - and let's see what it does
86:44 - so right now if i press pass we run this
86:47 - file nothing is going to happen because
86:49 - pass doesn't do anything
86:51 - now the first thing that we have to do
86:54 - is to figure out how to read a csv file
86:57 - and fortunately python has a module just
87:00 - for that but i don't want to import all
87:02 - of it instead i want from csv
87:06 - import
87:07 - reader
87:09 - and this is allowing us to read a csv
87:11 - file
87:12 - and now to use it
87:15 - we first have to open the csv file so
87:18 - with
87:19 - open and we pass the path in here and
87:22 - then python wants a name for this file
87:25 - and i called it level
87:27 - map
87:28 - and all of this so far could work for
87:31 - any file so this could also be a text
87:33 - file and unfortunately right now you
87:36 - wouldn't really be able to see anything
87:38 - so if i print my level map
87:41 - all you would get is
87:43 - something in our memory
87:45 - not particularly helpful
87:48 - but this thing
87:50 - we now have to convert
87:52 - with our reader
87:54 - to something actually readable
87:56 - and the reader needs two arguments first
87:58 - of all the file we want to work with
88:01 - which in our case is level map
88:03 - and besides that it also wants it
88:06 - delimiter
88:07 - and a delimiter in our case is a comma
88:11 - and what it means is what separates each
88:14 - individual entry in our file
88:16 - this could also be a space for example
88:19 - now this information is going to return
88:22 - another value that i'm going to store as
88:25 - layout
88:27 - now unfortunately still if i print
88:31 - the layout
88:33 - now we get a csv reader object
88:36 - so at the very least i guess we know we
88:38 - have a csv object but that's about it
88:42 - but now comes the actual part where we
88:44 - get to see something because now what we
88:46 - can do is for row in layout
88:50 - we can print
88:52 - the row and now we can see the actual
88:55 - files
88:57 - so in here we can see a whole lot of
89:00 - negative ones
89:02 - but
89:03 - all the way at the top you can already
89:05 - see
89:06 - we now have a list so here the list
89:08 - starts and the list is ending here
89:12 - and wherever we have a negative 1
89:15 - there is no tile however if we have 395.
89:20 - so any of these numbers here
89:23 - there should be a constraint for the
89:26 - player so the player wouldn't be able to
89:27 - move over this tile
89:29 - and it's really hard to see right now
89:31 - but if all of these tiles were on the
89:33 - same line
89:35 - they would in my tiled editor have the
89:37 - same shape as this red line here
89:41 - but in our case since the line isn't
89:43 - wide enough this is really hard to see
89:45 - but now all we want to do is to put all
89:48 - of these lists into a separate container
89:51 - which is going to be another list
89:53 - so let's call this one terrain
89:55 - map
89:56 - and this one is just going to be a list
89:59 - and now for each row that we get from
90:01 - the layout
90:03 - i want to
90:04 - append this to my terrain map
90:07 - so this could just be row
90:09 - although just to be sure
90:11 - i want to convert this row
90:14 - to a list
90:15 - and now the last thing we are going to
90:18 - need
90:19 - is to return
90:21 - that terrain map
90:23 - and now
90:24 - whenever we get this import csv layout
90:27 - we can put all of this
90:29 - for example in a print statement
90:31 - print it and now we get a list that
90:34 - contains a whole bunch of other lists
90:37 - that give us the layout of our map
90:39 - so that is going to be quite useful
90:42 - and now let's actually go straight ahead
90:44 - and use it so in my level dot pi i now
90:48 - have the boundary
90:50 - for my floor blocks as i called it which
90:54 - is just going to be my boundary
90:56 - now i actually want to place them in the
90:58 - same way i have used it earlier with the
91:01 - tile map but what did i call it
91:04 - my world map
91:06 - so now my boundary has the same kind of
91:08 - layout as this thing except it's
91:10 - significantly larger
91:12 - so let's work with it and since it's so
91:15 - similar we can reuse
91:17 - all of this code
91:19 - except there's going to be one
91:20 - modification i want to place all of this
91:23 - inside of another for loop
91:26 - and what the other follow-up is going to
91:27 - be let's call it style and layout
91:32 - in
91:34 - layout let's call it layouts that makes
91:36 - a bit more sense
91:38 - dot
91:39 - items and don't forget the double colon
91:42 - so essentially the style is going to be
91:45 - boundary right now and the layout is
91:48 - going to be
91:49 - this csv map and right now we only have
91:52 - a single one of these so it doesn't make
91:54 - too much sense however later on we are
91:57 - going to add more and more data in here
91:59 - and then this follow-up is going to make
92:01 - significantly more sense
92:03 - so that way our code is nice and
92:05 - scalable but now we are still looking at
92:08 - the y position we get the x position and
92:11 - we are converting all of this into an x
92:13 - and y position
92:14 - so now we can use this quite well and
92:17 - all we have to do now is if the style
92:21 - is equal to boundary
92:24 - then we can create a new tile
92:27 - so we can now create a new tile group
92:30 - and let me copy
92:32 - all of the parameters
92:34 - place them in here
92:35 - and let's go for them one by one
92:37 - actually or actually even better try to
92:40 - figure this one out yourself to place in
92:42 - all the proper arguments for each of the
92:44 - parameters to place the boundary for the
92:47 - world map
92:54 - all right let's go through it one by one
92:56 - first of all position that should be the
92:58 - easiest one
93:00 - because in here
93:02 - we just want to get x and y
93:06 - and that's just going to be what we
93:07 - created
93:08 - up here
93:10 - and actually this should be indented
93:12 - one more line
93:13 - next up we want our groups and for now
93:17 - let's place let me copy from the player
93:21 - i want the visible sprites
93:23 - and i want the obstacle sprites
93:27 - then we need the sprite type and the
93:29 - sprite type i have called
93:32 - invisible
93:34 - because they're not supposed to be
93:35 - visible later on and then finally we
93:38 - have our surface
93:41 - and this one we can just ignore
93:44 - since it's then going to use the default
93:46 - argument
93:48 - and all right that is then going to be
93:50 - all we need for the boundary
93:52 - and let's actually see what happens so
93:55 - we don't get an error we do get an error
93:58 - and the error we're getting is import
94:00 - csv layout is not defined
94:02 - that is an error i tend to make very
94:04 - often
94:05 - fortunately it's quite easy all i did
94:07 - was i forgot to
94:10 - from support
94:12 - import star
94:14 - so that this function is another file
94:16 - and we didn't import that file
94:18 - now let's try this again
94:20 - and now i made another mistake the
94:22 - obstacle sprites are not defined and
94:24 - that is probably because i forgot the
94:27 - self there we go
94:29 - and now if i run the code we can see
94:33 - something strange so at the very least
94:36 - we get some kind of collision
94:39 - although
94:40 - something is definitely gone wrong here
94:43 - and i think i can already tell the
94:44 - problem so
94:46 - right now
94:48 - when we are calling this boundary
94:51 - our boundary is slightly different
94:53 - compared to this map here
94:56 - because for boundary there is no empty
94:59 - space we get a negative one actually in
95:01 - my support file
95:03 - let me open it again
95:06 - so let me copy this one
95:09 - and let's call
95:11 - import csv layout and let's print it
95:16 - so what we can see here is the number
95:18 - 395 a whole lot of time
95:22 - and besides that a lot of negative ones
95:25 - and what pygame did it always put a
95:28 - block where we have a negative one but
95:30 - we only want to block at 395
95:34 - and that was different from our world
95:36 - map so
95:38 - let me get rid of this one again
95:41 - so what we want to do in here
95:43 - when we go through the column we want to
95:45 - add another if statement
95:48 - that if our call
95:51 - is different from the string
95:54 - negative one and only if that is the
95:57 - case we want to do anything in here
96:00 - and negative one in a tiled export means
96:03 - there's not supposed to be anything so
96:05 - this negative one would work for any
96:07 - kind of layout
96:08 - so now let's try this again and let's
96:10 - see what we get
96:13 - we still get a giant block
96:16 - that seems like something is going wrong
96:18 - with the position
96:20 - so let's investigate what the problem is
96:23 - and
96:24 - i just realized the problem is i am very
96:27 - very stupid
96:29 - well
96:30 - so in here
96:32 - we are still using the world map we are
96:34 - not actually using the layout
96:36 - so that may have been a problem
96:39 - so now let's try this again that should
96:42 - fix the issue so now if i go to the
96:45 - right at some point there we go
96:48 - now we have the black
96:50 - coastline that we can't walk over and we
96:53 - still get our overlap that one works
96:56 - pretty well
96:57 - cool and now we are not able to leave
97:00 - this game anymore
97:02 - but we can still use something like a
97:03 - bridge and we can move on this tiny
97:05 - island
97:07 - and obviously right now we don't want to
97:09 - draw any of these black tiles
97:13 - and to get rid of them at least in terms
97:15 - of visibility
97:17 - we can just remove
97:19 - the visible spreads group
97:21 - and now let's run this again
97:24 - now we can't see them anymore however
97:27 - we can still not move over into the
97:31 - water
97:32 - so this is all working
97:34 - very very nicely
97:35 - this is a very nice upgrade cool
97:40 - okay that took way more time than i
97:42 - expected but well here we are
97:45 - all right so for now we need two more
97:46 - objects we need the grass and we need
97:48 - the objects so all of the trees and the
97:51 - statues and stuff like that
97:53 - and for that first of all we have to
97:56 - import two more csv layouts
97:59 - and let me just copy them that's going
98:00 - to save me a bit of writing
98:03 - so one is called grass and the other i
98:07 - have called object
98:09 - so essentially what we need to do with
98:11 - those two is if this style
98:15 - is going to be
98:17 - grass
98:18 - let me just add a comment create a
98:21 - grass tile
98:23 - and if the style that's not how you
98:25 - spell that if the tile is
98:29 - object
98:30 - then we want to
98:32 - create an object tile
98:36 - and we do have most of it but we don't
98:39 - have the most important part we don't
98:41 - have the graphic for either the grass or
98:43 - any of the objects what we have right
98:46 - now is two folders one with three
98:48 - different grass images and another
98:50 - folder with like 20 different objects
98:53 - and right now those really aren't usable
98:56 - and i really do not want to import every
98:59 - single one of these images individually
99:02 - so i want to create a function that does
99:04 - all of this for us
99:06 - and this is also quite easily done let
99:09 - me add a path in here so python doesn't
99:12 - throw an error
99:14 - and in my support file
99:17 - besides import csv layout i want to
99:20 - create another function
99:22 - and i call this one
99:24 - import underscore folder it also needs a
99:28 - path
99:29 - and this one is going to go through a
99:31 - folder import all of these images as a
99:34 - surface into pygame or well into our
99:36 - python code
99:38 - and there's one module that we will need
99:40 - for this
99:41 - it is called the os module and i don't
99:43 - want to get all of os instead i just
99:46 - want to get the one that's called walk
99:49 - and walk just allows you to walk through
99:51 - the file system that's really all it
99:53 - does
99:54 - and let's actually check out what it is
99:56 - doing
99:57 - so for data in walk and now we have to
100:02 - add a path
100:03 - and let me use the path for the grass
100:06 - objects
100:07 - that one is looking like this
100:09 - and now let's just print
100:12 - our data
100:13 - and now
100:14 - let's run
100:16 - import folder oh i made a mistake
100:19 - the import grass
100:21 - should be
100:22 - what we pass into the function
100:25 - and then walk gets the path from the
100:26 - parameter that looks much cleaner now
100:29 - let's run this
100:30 - and now we are getting three different
100:33 - bits of information
100:35 - first of all we get the folder name the
100:37 - first bit here
100:39 - in our case we just don't care about it
100:41 - and we already have it anyway so this
100:43 - one we could just ignore
100:45 - next up we have an empty list this one
100:48 - here
100:49 - and if there was any folder inside of
100:51 - this folder this list would contain the
100:53 - names of these folders in our case we
100:56 - just don't care about it
100:58 - now finally
100:59 - we have the list of the images or well
101:02 - the files inside of this folder
101:04 - and this is what we care about
101:07 - essentially what we want to do let me
101:10 - clean this up a bit
101:11 - basically what i want to do
101:14 - is i want to combine
101:18 - this path here
101:20 - with any of these names
101:24 - so these three names
101:26 - and that is going to give me a whole
101:28 - file path to that image from my code
101:31 - wherever i run it in my setup
101:33 - and once i have that i can just import
101:36 - this file as a surface so i would just
101:39 - loop over all of these names turn them
101:41 - into a full file path and then import
101:43 - all of this as a surface and that is
101:45 - what we are going to do so first of all
101:48 - let me rename the data
101:51 - and split this into three different
101:52 - parts now for the first one before the
101:55 - name
101:56 - i'm going to use an underscore since i
101:57 - don't care about the information for the
101:59 - subfolders i can use a double underscore
102:02 - because i don't care about this either
102:04 - now finally i have the let's call it the
102:07 - image
102:08 - files this is what i actually care about
102:11 - and this is still going to be a list so
102:14 - i want to split this up so i need
102:16 - another for loop so for image in img
102:20 - files
102:21 - and now if i print each individual image
102:24 - we get the list ideally of our grass
102:26 - images so grass one two and three
102:29 - and now what i can do with them is i can
102:31 - turn them into a full path so right now
102:35 - all we have is strings
102:37 - that we can combine quite easily
102:39 - and what i want to do is to get my path
102:44 - on that i'm going to add the string of a
102:46 - forward slash
102:48 - and to that i'm going to add my image
102:52 - so if i print
102:54 - this full path
102:56 - i have
102:57 - a nice path to my image that i can use
103:00 - to import this image
103:02 - so literally all i want to do
103:05 - let's call it my image surface
103:09 - i want pygame.image.load
103:12 - i need my full path and don't forget
103:16 - convert alpha
103:19 - and spelling this correct also helps
103:22 - and this is then going to be our image
103:26 - or our surface
103:27 - now finally we want to return this
103:30 - entire list and right now we can't
103:32 - really do that so what i usually do is i
103:35 - just create a surface list that by
103:38 - default is empty
103:39 - and then as soon as we create this image
103:41 - surface
103:42 - we get our surface list
103:45 - and we append this image surface
103:48 - and at the end of all of this we are
103:51 - returning
103:53 - the surface list
103:54 - and that way let me print what import
103:58 - folder gives us
104:02 - ah we get an error pi game is not
104:04 - defined because
104:07 - we need to import
104:09 - pygame
104:10 - and i suspect we get another error aya
104:12 - right now
104:14 - we haven't initialized pygame.display
104:16 - because we're only running this file by
104:18 - itself so i can't really show this right
104:21 - now but fortunately when we are running
104:23 - our level we have initiated pi game this
104:26 - happens in the main file so this happens
104:28 - here
104:30 - as a consequence we don't have to worry
104:31 - about this error you're gonna see in a
104:33 - second what this means actually
104:36 - let's import all of the graphics that we
104:38 - need and since we have more than one i
104:41 - want to put this
104:43 - into a dictionary as well
104:45 - so we have graphics it's going to be a
104:48 - dictionary
104:49 - and in here for now we only have the
104:51 - grass
104:53 - and for the grass i want import
104:56 - underscore folder
104:58 - and i have called it
105:01 - this one here
105:02 - and now we can actually print our
105:06 - graphics
105:07 - so let's run all of this
105:09 - we get our file no error and now we can
105:11 - see in the dictionary we have grass
105:14 - and we have three surface files inside
105:17 - of a list that's exactly what we wanted
105:20 - so all right
105:22 - you can get rid of this
105:24 - and now we can actually work out our
105:27 - grass tiles and essentially what i want
105:29 - to do i want to pick
105:31 - a random image from this folder or from
105:34 - this list and then create a tile with
105:36 - that random image
105:38 - and this could be a really good exercise
105:40 - for you so try to create a tile with the
105:43 - grass and the sprite type should also be
105:45 - grass
105:46 - and see how far you get
105:53 - all right so first of all let me get rid
105:56 - of all of this
105:58 - and the first thing i want is to get a
106:01 - random
106:03 - grass
106:04 - image
106:06 - so we want to pick one item from the
106:08 - list and to do that we need
106:12 - the choice method which we get from
106:15 - random import
106:17 - choice
106:19 - so now in here we can just call choice
106:23 - and get our graphics
106:26 - and
106:28 - i want to get
106:29 - the grass list
106:31 - and once we have that we can just create
106:34 - another tile
106:35 - now the x and y position is still going
106:37 - to be x and y that one didn't change
106:41 - but now
106:43 - for the groups we want self dot visible
106:46 - sprites and self dot obstacle sprites
106:50 - because the grass is supposed to be
106:51 - visible and collidable and finally i
106:55 - gave those a type of grass
106:58 - and now
106:59 - this should be working
107:02 - and
107:04 - oh yeah i know what i forgot so we can
107:07 - see something but
107:09 - we have a problem
107:11 - and look at this for a second and just
107:13 - think about what i forgot
107:16 - the important thing i forgot was the
107:18 - actual graphic so random grass image
107:22 - now let's try this again
107:24 - there we go this is much better so now
107:26 - we have our grass image
107:29 - and they are collidable they are very
107:33 - much visible
107:34 - and this is working really well so now
107:37 - we have our grass this is working really
107:41 - nicely i think down here we have quite a
107:43 - few more there we go
107:45 - this is coming together quite well cool
107:49 - so with that we have the grass
107:52 - and then finally we need the larger
107:54 - objects and we already have up here
107:58 - the object in our layout
108:01 - and besides that we are also going to
108:03 - need
108:04 - the graphics
108:05 - and this one
108:07 - i called objects
108:09 - and then here we just want to get the
108:12 - import folder
108:14 - and the file path towards it i have
108:17 - called
108:19 - this
108:20 - and with these two things we have a
108:22 - layout and we have the graphics so we
108:24 - can start working on actually creating
108:27 - these tiles here
108:29 - but now we do have a bit of a problem
108:33 - because for the grass tiles we could
108:35 - just select a random grass tile from the
108:37 - list for the objects we cannot do that
108:40 - because each of these objects is one
108:42 - specific thing that we couldn't just
108:45 - randomly pick
108:47 - now fortunately that isn't too much of a
108:48 - problem and let me open tiled again to
108:51 - explain why
108:53 - so here we have tiled and all of the
108:55 - objects are in here
108:57 - and
108:58 - if i click on one let's say this tree
109:00 - stump this is the id of zero
109:03 - if i go to the next one it's the id of
109:05 - one
109:05 - then two three four and five and so on
109:09 - and essentially what tiled is exporting
109:12 - is this id
109:15 - and this is really useful because we can
109:17 - use this id
109:18 - to import the index of the image in that
109:21 - folder so when we import the images
109:24 - they are in the list so they can be
109:26 - indexed and the way we're importing them
109:29 - right now is by the name and since you
109:32 - can see it in the image the name is 0 1
109:35 - 2 and so on
109:37 - so the naming here lines up quite nicely
109:40 - with the file name
109:42 - and that way we can use the id as an
109:44 - index
109:45 - and this means all that we have to do to
109:48 - get our surface
109:50 - we have to get our graphics and in here
109:53 - we want to get the objects
109:57 - and this is then going to return a list
109:59 - and from this list
110:01 - we want to get the index
110:04 - and the index we get is this column here
110:08 - so this is the column we want to use for
110:11 - indexing
110:13 - now right now this column is going to be
110:16 - a string so we want to turn this
110:18 - into an integer
110:22 - and now
110:24 - we can just use this surface so i can
110:27 - just copy the tile
110:29 - we again need x and y
110:32 - then we also want visible and obstacle
110:36 - sprites so i can just copy them
110:38 - and for the type i call this one object
110:41 - and finally for the image we want the
110:44 - surface
110:45 - and that is all we needed
110:48 - almost at least so now if we run this we
110:50 - can see some trees so this is coming
110:52 - together very nicely
110:54 - the problem is this isn't working
110:56 - perfectly so for example here you can
110:59 - see the flower and the column on top of
111:01 - each other
111:02 - and i think further here that this one's
111:04 - actually working quite well
111:06 - um i guess if i go in here you can see a
111:09 - couple of overlapping things that don't
111:11 - look as good as they should be oh
111:13 - especially down here you can see some
111:14 - problems
111:16 - and the problem is this
111:20 - in our tile.pi
111:22 - right now we are basically assuming that
111:25 - all of the files or all of the images
111:27 - are 64x64 pixels
111:30 - but the larger objects really aren't
111:32 - that and let me explain this issue
111:35 - entitled
111:36 - now here we can see the thing that we
111:39 - just saw doesn't work in code
111:42 - and the problem is this
111:43 - that in tile we always assume we have a
111:46 - 64 by 64 tile grid and this works for
111:50 - most of the objects like the grass for
111:52 - example
111:53 - where it doesn't work is with these
111:55 - larger objects so this column here for
111:58 - example is much larger than 64 pixels
112:02 - and we are always placing
112:05 - the top left of this column
112:08 - but since this is larger than 64 pixels
112:11 - we are placing this column somewhere
112:14 - here on this line so we are placing it
112:16 - here as a matter of fact all of these
112:19 - larger elements are a bit further down
112:21 - than they are supposed to be
112:23 - but that's something we can fix quite
112:25 - easily
112:27 - so let me go back in the code and when
112:29 - we are placing the rectangle
112:32 - now we have to adjust things a tiny bit
112:36 - and essentially what i want to check if
112:39 - this bright type
112:42 - is equal to object because those are the
112:45 - only things that are going to be larger
112:47 - than that and these we get from object
112:50 - here and we're placing them in here
112:54 - and that way we do have access to them
112:57 - and if they are an object we want to
113:00 - do an
113:01 - offset
113:02 - but if they're not an object we just
113:04 - want else
113:06 - else and do the thing we have already
113:08 - done
113:10 - and the rest can stay exactly the same
113:13 - now if we do have an object we still
113:15 - want to get self.write
113:18 - and we still want to get
113:19 - self.image.get underscore act and we are
113:22 - still placing the top left
113:25 - but now we are still placing it x and y
113:27 - as well and the x stays exactly the same
113:30 - so this is going to be position zero
113:33 - so we are splitting apart this position
113:35 - into the first and the second integer
113:38 - and now for the y
113:40 - we have to make a tiny adjustment i
113:43 - guess we still want
113:44 - the first index
113:46 - but now
113:48 - we have to reduce a tiny amount from
113:50 - that
113:51 - and here our life is going to be made a
113:53 - tiny bit easier because all of these
113:56 - larger objects have twice the height of
113:59 - all of the other elements
114:00 - so really all we have to do is to
114:03 - subtract the tile size
114:05 - from it
114:07 - here is
114:08 - a normal tile it's 64 by 64 pixels
114:14 - and the larger tiles look either like
114:17 - this
114:19 - where we have 64 by 128
114:24 - or we have even larger tiles that look
114:27 - something like this
114:28 - well we have 128
114:31 - and 128
114:34 - and the problem that we faced is that
114:37 - all of these tiles are being offset
114:40 - over here
114:41 - so the position we want to place is
114:43 - actually this one instead of this one so
114:46 - what we want to do is to just move
114:49 - any of these larger objects a little bit
114:52 - further up
114:54 - and since they're always the same height
114:56 - with 128 pixels we can just move them up
114:59 - by 64 pixels or exactly the tile size
115:02 - which is making our life significantly
115:04 - easier
115:05 - and all right that's all we needed
115:08 - so now let's run this
115:10 - we don't get an error
115:12 - and
115:15 - that is looking quite good i can't see
115:18 - any overlaps
115:22 - this is also looking really good
115:25 - and yeah i think we have a pretty nice
115:29 - looking map that is coming together very
115:31 - much
115:33 - so all right with that we can get rid of
115:37 - these
115:38 - old comments
115:40 - and we can get rid of in our settings of
115:43 - the world map we don't need it anymore
115:46 - so i guess with that we can start
115:49 - working on a better looking player so we
115:52 - have the different kind of animations
115:55 - and that is going to be the next section
115:58 - so let's talk about the player animation
116:00 - and to make our player animations work
116:03 - we have to figure out what our player is
116:05 - doing at any given time so what the
116:08 - status of the player is
116:10 - and at the end of the day there are
116:12 - going to be 12 different states our
116:14 - player can have
116:16 - we can either walk in any of the four
116:18 - directions we can be idle in any of
116:20 - these directions or we can be attacking
116:22 - in any of these four directions so it's
116:25 - going to be 4 times 3 and that's how we
116:27 - get to 12 different states
116:30 - and in the most basic sense all we
116:32 - really have to do is whenever there is a
116:34 - certain kind of state we are going to
116:36 - play a certain kind of animation that's
116:39 - the easiest way to think about it but
116:41 - that's still quite a bit away first of
116:42 - all we have to import all of these
116:44 - graphics and we also have to give our
116:47 - player the ability to attack and to cast
116:49 - magic
116:51 - and i guess we should work on those two
116:53 - first
116:55 - here we are back in the code and i only
116:57 - want to work on my player we don't need
116:59 - anything else right now as a matter of
117:01 - fact let me minimize the functions so
117:04 - it's a bit easier to see what we are
117:06 - doing
117:07 - that makes a bit more sense first of all
117:10 - in my input
117:12 - here
117:12 - we are getting the input to move around
117:15 - and
117:16 - i want to get a few more and let me
117:18 - actually add a few more comments
117:20 - so this here is the movement
117:24 - input
117:25 - and down here we have the attack
117:28 - input
117:30 - and then a bit further we get the magic
117:32 - input
117:33 - and for the attack input we can still
117:35 - use our keys so if keys
117:38 - and in my case i use pygame dot k
117:42 - underscore space so the spacebar means
117:45 - that we are attacking
117:47 - and for now if we are attacking let me
117:50 - just print
117:52 - attack
117:54 - and now we can do the same thing for the
117:56 - magic
117:57 - i can just copy all of this
117:59 - and
118:00 - and for magic i use the left control
118:04 - which is triggered with lc
118:07 - tr so left control
118:09 - and if that is being triggered i want to
118:11 - cast some magic
118:14 - and now if i run this we don't get an
118:16 - error if i press space we get attack if
118:19 - i press ctrl we get magic so that's a
118:23 - good start
118:24 - but there is a bit of a problem right
118:26 - now let me run the game again
118:28 - so if you press attack we attack
118:30 - multiple times same for the magic
118:32 - and the reason for that is that our game
118:35 - runs at 60 frames per second if we press
118:37 - space once pygame checks for this
118:40 - multiple times a second and it finds the
118:42 - bar being pressed
118:44 - for longer than a few milliseconds
118:46 - that's why it triggers it multiple times
118:48 - so for these two if statements we have
118:50 - to add a timer that can only be
118:52 - triggered every few milliseconds
118:55 - so in our player
118:57 - let me add another section
119:00 - or it's our first section here actually
119:03 - and let's call those
119:05 - um i guess we can call them movement
119:08 - let's just give it a movement and we can
119:10 - put them up here
119:14 - and in here i also want to create a few
119:18 - more variables or attributes first of
119:20 - all
119:21 - the first point is called attacking and
119:24 - by default it's going to be false
119:27 - next up i want to have a self dot attack
119:31 - cool down
119:33 - and let's put this one for now at 400 i
119:36 - think is a good number and finally self
119:39 - dot attack
119:41 - time
119:42 - and by default this is none or could be
119:44 - zero doesn't really matter
119:46 - and these three numbers we are going to
119:48 - use to create a timer
119:51 - so what i want to do
119:53 - whenever we call
119:54 - keys for attacking and for magic we also
119:58 - want to check that our player currently
120:00 - is not self dot attacking
120:04 - and this we want to do for both magic
120:07 - and attacking
120:09 - and those two get the same variable for
120:11 - the timer because i want that to be an
120:13 - offset that the player can't cast an
120:15 - attack and magic at the same time or
120:17 - really fast after each other
120:19 - now
120:20 - once we are calling either of these
120:24 - i want to set self dot attacking
120:27 - to
120:29 - true
120:30 - and let me copy it to both
120:33 - and now what we should be seeing is that
120:35 - we can attack or cast magic once so let
120:38 - me press space for attack
120:40 - and now i keep on pressing space or
120:42 - control nothing happens
120:45 - and there shouldn't be anything
120:46 - happening because now attacking is true
120:48 - so this if statement cannot trigger
120:50 - anymore
120:52 - but obviously eventually we do want to
120:54 - attack again so we want to create
120:57 - another method
121:00 - that i am going to call cool downs
121:04 - needs self and nothing else and in here
121:06 - we are going to have all of our cool
121:08 - downs and let me explain the logic so i
121:12 - explained this a couple of times but the
121:14 - problem is that high game by itself
121:16 - doesn't have a timer function
121:18 - so we couldn't just tell pygame to do
121:21 - something in half a second
121:23 - it just doesn't have that and also
121:26 - i should check
121:28 - my spelling
121:29 - so instead we have to create our own
121:31 - timer which we can do
121:34 - and essentially what we want to do
121:38 - so here we have the timeline of our game
121:42 - so this is time 0
121:45 - and this is time x this is the maximum
121:48 - time once we close the game
121:50 - and we want to check two things we want
121:53 - to check when our attack has occurred
121:56 - so let me use this in a different color
121:58 - let's say our attack occurred right here
122:02 - at around let's say milliseconds at 700.
122:08 - and now from this point
122:10 - we want to continuously measure our time
122:12 - so as the game goes on
122:14 - we want to check what the time is
122:17 - so for example
122:18 - here we could have 800 here could be 900
122:21 - here we could have a thousand
122:24 - and here we could have 1100
122:27 - and what we basically want to check let
122:29 - me write it so 1100
122:33 - now what we basically want to check is
122:35 - this distance here
122:38 - and that is going to be our timer
122:41 - i have actually made a video
122:42 - specifically on timers but really all we
122:45 - are checking is one point in time and
122:47 - then we continuously check the time and
122:49 - if difference between our current time
122:51 - and our starting time is greater than
122:53 - our cooldown in this case then we want
122:56 - to trigger whatever code we have
122:59 - so i hope that makes sense
123:01 - we need to get our current
123:03 - time and stored in the variable
123:05 - and to get our current time we need
123:07 - pygame dot time dot get underscore ticks
123:11 - so this is going to continuously measure
123:13 - what our time is
123:15 - and the other thing we need is when the
123:17 - attack actually occurred and this we can
123:20 - get up here
123:22 - so what we want to do in here is self
123:24 - dot attack time
123:27 - this is going to be
123:29 - pygame.time.getticks as well
123:31 - now a really important thing here is
123:33 - that this sketch is only called once and
123:37 - once only
123:39 - because this if statement is only going
123:41 - to be run once
123:43 - however this get ticks down here
123:46 - will be run basically
123:49 - infinitely
123:50 - because there's no restriction on it and
123:52 - we're going to put this cooldown in the
123:54 - update method in just a second
123:57 - so to get ticks down here is being run
123:58 - multiple times they get ticks up here is
124:01 - only run once that's how these two
124:03 - functions differ
124:05 - okay but now all we have to do
124:08 - is let's say if self dot attacking
124:11 - because that's the only reason why we
124:12 - reject this
124:13 - if our current time
124:16 - minus self dot attacking time
124:20 - is greater or equal than self dot cool
124:25 - down
124:26 - should just be cool down did i make a
124:28 - typo again
124:30 - oh i put this down as attack cooldown
124:33 - so let's call it attack cooldown
124:36 - and if that is the case self dot
124:40 - attacking
124:41 - should just be false again
124:43 - and that is a very simple timer and
124:46 - later on we are going to add a few more
124:48 - timers in here for example when the
124:51 - player is vulnerable or when the player
124:52 - is switching a weapon but this is the
124:54 - most basic one
124:56 - and now all we have to do let's put it
124:58 - right on the input self dot cool downs
125:03 - and now let's try this again
125:06 - i can press space we only get it once
125:08 - but if i keep on pressing it it only
125:10 - happens after about half a second
125:12 - and this also works oh um magic is still
125:16 - a bit different
125:17 - so let's have a look
125:19 - ah the problem for magic is we didn't
125:22 - set the starting time
125:24 - so this is what we need now let's run
125:26 - this again
125:28 - and now both magic and attack work
125:31 - much better
125:32 - so now our player has the ability to
125:35 - move around up here and to attack and
125:38 - cast magic at least in theory
125:42 - so now we can actually import all of the
125:45 - animations to show what the player is
125:48 - doing
125:49 - and that is going to become quite
125:51 - extensive so let me minimize all of the
125:54 - functions
125:56 - and put all of this in a new method
125:59 - and let's call it import
126:02 - player
126:04 - assets needs self and nothing else
126:09 - and then here first of all i want to get
126:11 - my character path to the folder
126:14 - this shouldn't be capitalized
126:16 - and the path to my folder is going to be
126:19 - one fold up then graphics and then the
126:22 - player
126:23 - and then forward slash don't forget that
126:25 - because in this folder there are a
126:27 - couple of subfolders
126:30 - and now we need all the different states
126:32 - that our player can have
126:34 - and this i want to put
126:37 - in a dictionary because this will get
126:39 - quite extensive
126:40 - and let me just copy all of this it's
126:43 - going to look like
126:46 - this
126:47 - and there's a bit much white space
126:50 - like this so this is what i talked about
126:52 - earlier
126:53 - we have the animation states for the
126:55 - player walking in all the four
126:56 - directions
126:57 - the player being idle in all the four
126:59 - directions and the player attacking in
127:02 - all of the four directions
127:04 - so these are all the possible states the
127:05 - player can have
127:07 - and if you look at the folders they are
127:10 - named in the exact same way
127:12 - and that makes it really easy for us to
127:15 - use the names of these dictionary
127:17 - entries to import all of the graphics so
127:21 - what i can do now
127:22 - is for animation in self
127:26 - dot animations dot keys
127:30 - let's say if i just print it to
127:32 - illustrate what i'm getting so animation
127:35 - and in the init method i want to call
127:38 - this
127:39 - so let's put it right at the beginning
127:42 - in here
127:44 - and let's call it a
127:47 - graphics setup
127:50 - and self dot import player assets
127:54 - and now if i run the game
127:57 - we can see
127:58 - we have all of our different states the
128:00 - player can have
128:01 - that's working quite well
128:03 - and keep in mind those are names for
128:05 - folders we are not working with images
128:08 - yet
128:09 - but basically what i want to do
128:11 - i want to combine
128:13 - this player path here with all of these
128:17 - different subfolders
128:19 - and that is actually going to look
128:21 - really similar compared to our support
128:23 - file here so to what we have done with
128:26 - this
128:27 - and then once i have the full path i
128:30 - want to use my input folder function
128:32 - and fill the list for each of the states
128:36 - with the graphics from each folder
128:39 - and this might be a good exercise for
128:41 - you try to figure this out yourself
128:44 - that you go through every single
128:45 - animation you create a full path you use
128:47 - the input for the function to fill each
128:50 - of these folders with the associated
128:53 - images so try to do this yourself
129:01 - first of all we are going to need our
129:03 - full path
129:05 - and the full path is just going to be
129:08 - the character path
129:10 - plus the
129:12 - animation
129:14 - and now for each self dot animations
129:19 - and we can target the animation
129:22 - i want to set each of these lists to my
129:25 - import folder and this import folder i
129:28 - have to import into my player
129:31 - so from support import import folder
129:36 - and now my input folder just needs a
129:39 - path and that is going to be my full
129:41 - path
129:42 - so at the end of all of this
129:45 - let me just print my self dot animations
129:49 - and let's see what we get let's open
129:51 - certain error that looks good
129:53 - in here you can see for example we have
129:56 - up so that's walking up and there are a
129:59 - bunch of different surfaces in there
130:02 - next up we have down
130:04 - more surfaces then we have left at some
130:07 - point we have right then we have right
130:09 - idle
130:10 - and all of the different states are in
130:12 - here which is exactly what we wanted so
130:16 - now we have effectively imported
130:19 - all of the assets for our player so now
130:21 - we can minimize this method and not
130:23 - worry about it anymore
130:26 - with that we have covered the first part
130:28 - that we have figured out how to get the
130:31 - resources into our player
130:33 - now next up we have to figure out how to
130:36 - actually play all of these states
130:40 - and for that we have to talk about state
130:42 - management
130:44 - and essentially what we are going to do
130:46 - our player is going to get an attribute
130:48 - called self.status
130:50 - and this self.status is going to
130:52 - correspond with one of the keys in
130:54 - self.animation
130:56 - so for example it could be up down left
130:58 - right up idle left idle left attack up
131:00 - attack any of those
131:02 - and for example if it is up we are going
131:05 - to pick all the surfaces inside of the
131:07 - up folder and play those repeatedly
131:11 - so with that we have to figure out our
131:13 - state management and really what this
131:16 - one comes down to is we are going to
131:18 - look at our player direction and our
131:20 - player input and see what kind of
131:23 - movement the player is doing
131:25 - for example in our direction vector if
131:27 - we have something like 1 and 0
131:30 - we know our player is moving to the
131:31 - right
131:33 - and just now from the timer if
131:35 - self.attacking is true we know the
131:37 - player has just been attacking so we
131:40 - want to play the attack animation
131:42 - and really all we are going to do is
131:44 - figure out the right condition for each
131:46 - of the 12 possible states
131:48 - and once we have that we can display an
131:50 - animation and be done with it
131:54 - so let's try to figure out some states
131:57 - here we are back in the code and let's
131:59 - put it under
132:01 - graphic setup
132:03 - self.status
132:06 - and let's say by default this is going
132:08 - to be down
132:10 - and now
132:11 - we also want to create another method
132:15 - and i call this one get status
132:18 - and itself and nothing else as always
132:21 - and in here we have to figure out how to
132:24 - get all of the different states
132:26 - and let's start with the easiest one the
132:29 - idle status
132:31 - and this one is actually fairly easy all
132:33 - we want to check is if self.direction.x
132:39 - is equal to zero and self.direction.y
132:44 - is equal to zero
132:45 - but now we have a problem and let me
132:48 - actually illustrate this by drawing so
132:50 - here is our player
132:54 - and right now we know our player is
132:57 - not moving so we want to play the idle
133:00 - animation now the problem that we have
133:03 - is that we don't know what direction our
133:05 - player was working so we have four
133:07 - different idle statuses we have down
133:10 - left
133:11 - up or right
133:13 - but right now all we know is that our
133:15 - player is idling
133:17 - we don't know in which direction he or
133:19 - she is idling and that is something we
133:22 - do have to figure out
133:24 - and i guess there are two ways to figure
133:25 - this out one way
133:27 - we could look at the direction before
133:30 - the player stopped moving so for example
133:32 - the direction before we stopped was
133:35 - positive one here the player was
133:37 - probably walking to the right
133:39 - but that would involve quite a bit of
133:41 - extra code that would be a bit annoying
133:43 - to work with
133:45 - so instead what i'm going to do
133:47 - i'm going to check the current status so
133:50 - for example right now it's down
133:53 - which means the player is walking
133:54 - downwards
133:56 - and all i'm really going to do is to add
133:58 - towards this and idle so that way i keep
134:02 - my downwards movement but now instead of
134:04 - walking it's going to be idle and
134:07 - really what we are doing i think the
134:09 - best way to think about this is if i
134:11 - show the animations
134:13 - so here we have up down left and right
134:17 - and then for idle we have right idle
134:20 - left idle up idle and down idle so to
134:23 - move from up
134:24 - to up idle
134:26 - all we have to add is underscore idle
134:29 - and the naming here is very intentional
134:32 - it's the same for attack so if we are
134:34 - moving right and we are attacking we
134:36 - just have to add underscore attack to up
134:39 - and we go from walking to the right to
134:41 - attacking to the right
134:42 - so basically all i'm going to do
134:46 - is instead of overwriting self.status
134:50 - i am just going
134:53 - self dot status
134:56 - last
134:57 - underscore
134:58 - idle
134:59 - and now what we can do in the update
135:01 - method let's say after cooldowns
135:04 - self dot get
135:06 - status
135:09 - and i guess what we can do we haven't
135:12 - used our debug method in a while i still
135:15 - have it i don't
135:17 - uh let's do this in the player
135:19 - so in here right now we have our run
135:22 - method
135:24 - and i want to call debug or
135:26 - myself.player.status
135:29 - just to see what's going on because
135:31 - right now we don't have an animation we
135:33 - just have the status
135:35 - so let's see what it's doing
135:37 - so right now you can see the problem
135:40 - that we keep on adding idle to it
135:42 - and we also don't get updated down
135:46 - not working too well yet
135:49 - and i guess i jumped a little bit had
135:51 - with the idle here because we first want
135:53 - to figure out the walking directions and
135:55 - this happens in the input method because
135:57 - we know if we are pressing up our player
136:00 - is going to move up so what we can do in
136:02 - here itself.status
136:05 - is going to be
136:07 - up
136:09 - and we can do the same thing for
136:13 - down
136:15 - and we can do the same thing for
136:19 - right and then finally we have
136:22 - left
136:24 - so this way we are just determining the
136:26 - directions
136:27 - and let me minimize input again and
136:29 - let's comment out get is for now
136:32 - just so not be confusing so now main.pi
136:35 - we have down we have right left
136:38 - up and down
136:40 - so this is working pretty well
136:45 - and even if i stop moving it still says
136:47 - right left down and up so these
136:50 - directions are working really really
136:52 - well the problem is right now i have no
136:55 - way to separate between our player
136:57 - walking and our player idling and that
136:59 - is what we have to work on
137:02 - and this is what all of this code here
137:03 - is for i should have planned that a
137:06 - little bit better sorry about that so
137:08 - now if i uncomment this method here
137:11 - what we basically get is if we are
137:14 - moving things are well but now if i stop
137:17 - moving we keep on adding idle
137:20 - and well it's not particularly helpful
137:25 - oh and what is annoying me i don't want
137:27 - to print self.animations
137:30 - all right now the problem is
137:33 - we don't check if our status already has
137:37 - idle in there so we have to add another
137:40 - if statement
137:41 - that if
137:42 - not
137:44 - idle
137:46 - in self dot status
137:50 - so what we basically do
137:52 - we first of all check if our direction
137:55 - for x and y is zero that's this part
137:57 - here so then we would assume if we are
138:00 - not moving we are idling
138:02 - now next up we are checking if our
138:05 - status doesn't already contain the idle
138:07 - part and only if that is the case we are
138:10 - going to add underscore idle to our
138:12 - status
138:13 - and that way we are only adding idle
138:15 - once and not multiple times at least
138:18 - hopefully
138:19 - let's check this now so we have down
138:21 - idle we have up idle left if i stop
138:24 - moving
138:25 - that looks pretty good
138:28 - so now we have
138:31 - some nice upgrades
138:33 - although if i now attack
138:35 - it doesn't change anything but the
138:38 - animation i want to play should be left
138:40 - attack or down attack so that's the next
138:42 - part
138:44 - and that is just going to be another if
138:46 - statement so if self dot
138:49 - attacking
138:51 - first of all i don't want the player to
138:53 - be able to move and attack at the same
138:55 - time so if we are attacking
138:57 - self.direction
139:00 - dot x
139:01 - should be zero and the same for
139:03 - y
139:04 - and now basically what we want to do is
139:07 - copy
139:08 - this line here
139:10 - and let me actually just copy the entire
139:11 - thing
139:12 - and i first want to check if we don't
139:15 - already have attack in our status
139:18 - and if that is not the case i want to
139:20 - add attack
139:22 - to my status
139:24 - and this is i guess kind of going to
139:26 - work let's try
139:28 - so now we have down idle up this is the
139:30 - working and now if i press attack
139:33 - we get left idle attack and right idle
139:35 - attack
139:37 - and
139:39 - well it's kind of working but the
139:41 - problem we have
139:42 - is that we only want left underscore
139:44 - attack we don't want the idle in there
139:47 - so what we want to do
139:50 - for attack
139:52 - is that we don't want to just attach a
139:54 - tag we want to remove idle if it is in
139:57 - there
139:58 - and the same thing here
140:01 - that if we are attacking we don't want
140:04 - the player to play the idle animation or
140:06 - to add the idle tag
140:08 - and this is just a matter of another if
140:11 - statement or well a longer if statement
140:13 - so for example for the status if not
140:15 - idle and self.status
140:17 - and
140:19 - not
140:20 - attack
140:21 - in self. status
140:24 - so now we are checking if the player
140:26 - isn't moving
140:27 - and we don't already idle or we are
140:30 - attacking and only if neither of these
140:33 - are true
140:34 - then our player is going to idle
140:37 - now at the same time for the other if
140:39 - statement
140:40 - we first want to add another if
140:42 - statement so in
140:45 - idle
140:47 - in self.status
140:50 - so if that is the case we want to
140:54 - overwrite
140:56 - idle but if that is not the case
141:00 - then we can just add attack to the
141:02 - status
141:04 - but now we want to overwrite the idle
141:07 - and this
141:08 - is done with self dot status
141:12 - is going to be self dot status dot
141:15 - replace
141:16 - and here we have idle
141:20 - and we want to replace it with
141:22 - underscore
141:23 - attack
141:25 - and that is technically all we need so
141:29 - now
141:30 - let's move up down left and right that
141:32 - is still working now if i stop we have
141:35 - left idle right idle up idle and down
141:38 - idle and now if i attack with down
141:40 - attack left attack right attack and up
141:43 - attack
141:45 - but the one final problem we have is
141:47 - that
141:48 - you can still see it in the top upper
141:50 - tag still sticks around
141:53 - so what i want to do after
141:55 - self.attacking is over
141:57 - up attack should automatically switch
141:59 - back to up idle
142:01 - and that's going to be the final bit
142:05 - and this is going to still happen in get
142:07 - status
142:08 - and this could also be a pretty good
142:10 - exercise
142:11 - so one self.attacking is false
142:14 - i want to remove the attack and
142:16 - self.status
142:18 - so try to figure this out yourself
142:24 - all right so
142:26 - we know
142:28 - this if self.attacking
142:30 - is only going to run if self.attacking
142:32 - is true so if we had an else statement
142:35 - at the bottom here
142:36 - we are checking if self.attacking is
142:38 - going to be false
142:40 - and in here all we want to do is
142:42 - self.status
142:44 - is going to be self.status.replace
142:48 - and now we want to replace underscore
142:51 - attack
142:52 - with an empty string
142:54 - although this by itself might throw an
142:56 - arrow because python might try to remove
142:58 - attack if there's no attack in the
143:00 - string
143:02 - so this needs to have another if
143:03 - statement that if
143:06 - attack
143:07 - in self dot status
143:12 - so now this should be working
143:14 - and i guess with that we have our player
143:17 - status let's try
143:18 - so down idle up idle attack we go back
143:21 - to idle
143:23 - we have left right i can attack i go
143:26 - back to idle
143:27 - this also works with magic
143:30 - and yeah this is working really good
143:34 - cool
143:36 - so this is then going to be our get
143:38 - status
143:40 - now i can minimize this
143:42 - and now we come to the finally good part
143:45 - where we actually animate our player
143:48 - so let's really briefly talk about the
143:50 - logic for the animation it really isn't
143:53 - all that difficult essentially all we
143:56 - have to do
143:57 - right now we always have the same image
143:59 - for our sprite and for an animation all
144:02 - we want to do is to loop over a list of
144:05 - different images for example if our
144:07 - player is moving to the right we have
144:09 - five different images to loop over for
144:12 - the animation and once we have that we
144:15 - are well we are good to go it really
144:17 - isn't that complicated
144:19 - so all that we have to figure out in our
144:21 - code
144:22 - is how to quickly loop over different
144:24 - sprites in our animation frames and
144:28 - let's do this straighten the code that
144:30 - should be the easiest here we are back
144:32 - in our player and i want to create a new
144:35 - method let's put it all the way down
144:37 - here
144:38 - and i call this one animate
144:41 - we need self and no other arguments
144:45 - and first of all
144:46 - i want to have an animation
144:49 - and the animation is going to be self
144:51 - dot animations
144:53 - and then we get the key from self dot
144:56 - status
144:58 - so if i open the play assets again
145:01 - our player status can only be any of
145:04 - these 12 states
145:05 - so if we pick any of these keys we are
145:08 - going to get a list with the right
145:10 - animation that we want to loop over so
145:13 - that's the first part
145:14 - now next up we have to give our player a
145:18 - couple of extra attributes and let's put
145:20 - them all the way up here first of all we
145:23 - need self dot frame underscore index
145:26 - which by default is zero
145:28 - and then self dot animation underscore
145:32 - speed
145:33 - and in my case this is going to be 0.15
145:37 - now let me minimize this again
145:39 - and essentially what we are going to do
145:42 - now
145:43 - is that we are going to loop
145:46 - over
145:47 - the frame
145:49 - index
145:50 - so really what i want to do is self dot
145:53 - frame index plus equal
145:55 - self dot
145:57 - animation
145:59 - speed
146:00 - so this is going to give me a
146:01 - continuously larger number and let me
146:03 - actually draw this
146:05 - so we're going to start at zero
146:09 - and then we're going to get larger and
146:10 - larger numbers
146:12 - and let's say eventually we want to pick
146:14 - one we want to pick two we want to pick
146:16 - three we want to pick four and so on
146:20 - but the problem we have right now
146:22 - is that our animation so this thing here
146:26 - has a finite number of frames so we want
146:29 - to make sure that once we reach the end
146:32 - of this list we want to go back all the
146:35 - way
146:36 - to zero
146:37 - and this we can do
146:40 - simply by checking
146:42 - if self dot frame index
146:45 - is greater or equal than the length
146:48 - of our
146:50 - animation
146:51 - and if that is the case self dot frame
146:54 - index
146:54 - is going to be zero
146:56 - all we are doing is we are increasing a
146:58 - number and once the number is larger
147:00 - than the length of our animation frame
147:02 - index goes back to zero so that way we
147:04 - continuously loop over our list
147:08 - so that should be a pretty easy part
147:10 - now next up
147:12 - we want to actually
147:14 - set the
147:15 - image
147:16 - and all we have to do here is to create
147:18 - a new self.image
147:21 - and the image we want to get is from our
147:23 - animation
147:25 - and in here we want to get self dot
147:27 - frame index
147:28 - however right now pi game or python in
147:32 - general for this indexing expects number
147:35 - like 0 or 1 or 2 essentially an integer
147:39 - the problem is our animation speed is
147:41 - 0.15
147:43 - so a floating point number hence if we
147:46 - passed this number in here python would
147:49 - be very unhappy
147:51 - so we have to convert this frame index
147:54 - to an integer
147:56 - which we can do very easily
147:58 - with the end function
148:00 - and we are good to go although there's
148:02 - one more thing i do want to do that if
148:05 - we are changing the image we also want
148:06 - to update the rectangle again so
148:09 - self.image.get
148:14 - and the center
148:15 - is going to be where our
148:17 - self.hitbox.center
148:20 - was in the last frame
148:22 - the reason here is that different images
148:24 - of our player have different dimensions
148:27 - so if we didn't update the rectangle the
148:28 - player might shift by a couple of pixels
148:30 - around it would make it look slightly
148:33 - weird
148:34 - but that's really all we needed so now
148:38 - after get status self dot
148:41 - animate
148:44 - and let's see how this is going to look
148:47 - so now the player can move up left right
148:52 - and things are looking good so now if i
148:54 - attack
148:55 - we get an attack animation
148:57 - now the sword and the magic attack are
148:59 - the same but
149:01 - well doesn't really matter
149:04 - however there's one last thing i do want
149:07 - to fix because right now let me run the
149:09 - code again
149:11 - so if i attack i can move to the left
149:16 - i think it's good to see now
149:19 - and
149:20 - i don't want the player to be able
149:22 - to change direction mid attack
149:24 - essentially i don't want a player to do
149:27 - any keyboard input during an attack
149:29 - anyway so what i want to do let me
149:32 - minimize animate and go back to input
149:36 - i only want to do
149:39 - all of
149:42 - this
149:44 - if the player so if not self dot
149:48 - attacking
149:50 - and now
149:54 - i can't do anything during an attack
149:58 - i guess with that we can also remove
150:02 - these lines here because they are not
150:04 - necessary anymore
150:06 - so now let's try this again
150:10 - still feels pretty good
150:15 - and yeah
150:18 - is working really well so with that we
150:20 - have player animations
150:22 - and for the next part let's add some
150:24 - weapons
150:26 - and essentially all that we are going to
150:28 - do whenever the player presses attack
150:31 - we're going to create a new sprite with
150:33 - any of the weapons we have quite a few
150:35 - different ones actually
150:37 - and that way we can already see the
150:39 - weapon the only thing we really have to
150:41 - do is to work with the position and then
150:43 - destroy weapon one self.attacking of the
150:45 - player is over but that's basically it
150:48 - essentially what we are doing is we are
150:50 - creating a sprite for a short period of
150:52 - time and that sprite shows the weapon of
150:54 - the player
150:55 - and later on we will have to add a bit
150:57 - more to make the weapon actually do
150:59 - anything but that comes later i guess
151:02 - for now let's actually show the weapon
151:05 - and the first thing we will need is some
151:07 - data so let's start working on that
151:09 - straight in our code
151:11 - here i am back in the file and i want to
151:14 - keep my data broadly in settings and
151:17 - right now it doesn't actually have that
151:18 - much so i want to import oh well not
151:21 - import but rather paste
151:24 - one dictionary that looks like this
151:27 - and this one has our weapon data so in
151:30 - here we have our sword our lance our x
151:33 - our repair rapier whatever it's called
151:35 - and our sigh
151:37 - and each has its own cooldown its own
151:39 - damage and its own graphic that we are
151:42 - going to show later in the ui
151:44 - and now that we have that
151:46 - i want to create a new class but let me
151:49 - first close debug and tiled so you can
151:53 - see all of the tabs i guess we can also
151:54 - close support we don't need those
151:56 - anymore
151:57 - so now i want to create a new file
152:00 - that i'm going to save as weapon dot
152:04 - pi
152:05 - and then here we are going to need the
152:07 - usual so import by game
152:10 - and then we have to create a class that
152:12 - i'm going to call weapon and this one is
152:14 - going to be a sprite so we need
152:16 - pygame.sprite.sprite
152:19 - and then we have our init method for now
152:24 - we're just going to go with self
152:25 - and then as always we need super
152:28 - dunder
152:30 - in it
152:31 - and now we have to figure out well we
152:34 - have to figure out two major things the
152:36 - first one is self.image and the second
152:39 - one is self.wrecked
152:42 - and let me actually draw what i'm hoping
152:44 - to do
152:45 - this square here
152:47 - is our player
152:49 - and our player is facing to the right
152:52 - and essentially what we want to do with
152:54 - our weapon is to spawn another sprite
152:57 - that essentially starts at the right
153:00 - side of our player and then stays
153:02 - roughly here
153:04 - so for now what we have to figure out is
153:07 - what is the direction of the player and
153:09 - from that how can we use that direction
153:11 - to spawn the weapon to that side of the
153:13 - player
153:15 - and i guess just to keep things simple
153:17 - for now our self.image is just going to
153:20 - be pygame dot surface
153:23 - with uh let's say 40 and 40.
153:26 - so for now it's just going to be a black
153:27 - square but later on it's gonna be a
153:29 - proper graphic
153:31 - so we have to figure out the rectangle
153:34 - the problem is to figure out the right
153:36 - position we need our player since our
153:38 - weapon is supposed to be right next to
153:40 - the player so we have to import let's
153:42 - say the actual player
153:44 - and i guess while we add it we can also
153:47 - add groups
153:49 - to know where the groups are supposed to
153:50 - be and for now just to have something
153:53 - let's say
153:55 - our rect is going to be self.image.get
153:57 - underscore rect and the center is going
154:00 - to be just on top of the player so
154:03 - player dot rect dot center
154:07 - and to spawn that weapon we need a
154:09 - two-step process first of all in our
154:12 - level this is where our weapon has to be
154:14 - let me actually minimize
154:16 - all of this so it's a bit easier to see
154:19 - so right now
154:21 - in our level class
154:22 - we have all of our
154:25 - well sprites all of our everything so my
154:28 - weapon has to be in here as well and
154:31 - that way it's later possible to interact
154:33 - between a weapon and an enemy or between
154:35 - the grass so our weapon has to be
154:37 - available inside of the level
154:39 - the problem is
154:41 - we are
154:42 - getting the attack input from our player
154:46 - so from
154:47 - this
154:48 - line here so our attack happens inside
154:50 - of the player but we want to sort inside
154:53 - of our level that's the main problem we
154:55 - have right now
154:56 - so we have to get around that and that
154:58 - fortunately is quite easy essentially
155:01 - what we are going to do in our level
155:03 - class
155:04 - we are going to create another method
155:07 - and let's call it create
155:09 - attack
155:10 - needs self and nothing else
155:13 - and what we want to do in here is to
155:16 - create our weapon and for that we also
155:19 - have to import it so from weapon
155:22 - import weapon
155:24 - and now let me copy
155:27 - the parameters again so we can figure
155:30 - out the arguments
155:31 - so our player we do have we created this
155:34 - in create map so our player is stored
155:37 - right now in self. player down here
155:41 - so i can literally just copy
155:43 - this one and paste it in here
155:47 - and let me minimize this again that
155:48 - makes our class significantly easier to
155:51 - read
155:52 - now for the groups for now i want this
155:55 - thing to just be in self dot visible
155:58 - sprites
155:59 - and well that is it for this method at
156:01 - least for now now next up what i want to
156:04 - do in my create map
156:06 - when i create a player
156:08 - i want to pass
156:10 - this method in here so self.create
156:14 - attack and really important here we are
156:17 - passing the function into this method we
156:20 - are not calling the function so there
156:22 - should not be brackets
156:24 - let me actually cross it out
156:26 - so
156:27 - these brackets here should not be there
156:30 - if they are there you are going to get
156:32 - some weird result
156:33 - because this function we want to call
156:35 - from inside of the player so inside of
156:38 - my player let me minimize everything in
156:41 - here as well
156:42 - there we go
156:43 - so now in our init method for the player
156:47 - we have another argument that we called
156:51 - create
156:52 - attack
156:54 - and let's put this under i guess
156:56 - movement works so self dot create attack
157:00 - it's just going to be create attack
157:03 - and now
157:04 - we have
157:06 - this method here
157:07 - available inside of our player
157:11 - and now what we can do
157:13 - in our input method
157:15 - we can call
157:16 - under create input instead of attack we
157:19 - can call self dot create attack
157:23 - and now
157:25 - we have no arguments so it should be
157:27 - fine by itself
157:28 - so let's run this and let's see what
157:30 - happens
157:31 - so now if i press space we can see a
157:34 - black square on top of our player
157:36 - and that is going to be our weapon
157:38 - cool so this is working already
157:41 - so
157:41 - now with our level and our player
157:44 - we have the ability to create a weapon
157:47 - although granted it's not particularly
157:50 - helpful right now but that's something
157:52 - we can work on
157:54 - and there are two things we essentially
157:56 - have to figure out the first one is
157:58 - where to place the weapon and the second
157:59 - one is how to figure out the graphic for
158:01 - the weapon because each direction is
158:03 - going to be different
158:05 - and since we already talked about the
158:06 - direction let's talk about with the
158:08 - placement of the weapon
158:10 - but let me actually separate this so
158:12 - here we want to talk about the graphic
158:15 - and then a bit further down we want to
158:17 - talk about the placement
158:19 - now in either of these cases we need the
158:22 - direction of the player because if the
158:25 - player is moving to the right we want to
158:27 - place the weapon to the right and also
158:29 - show the right image of the weapon
158:32 - so we have to figure out let's do it all
158:34 - the way at the top let's call it
158:36 - direction
158:38 - and this i think could be a pretty good
158:40 - exercise so try from the player
158:43 - to get our direction so our player has a
158:47 - ton of different attributes that he
158:49 - could be using
158:50 - try to figure out one so he can reliably
158:53 - tell which way the player is facing
159:01 - i guess there are two ways you could
159:03 - approach this you could either look at
159:05 - the status of the player or at the
159:08 - direction
159:09 - they both would work but in my case
159:11 - self.status i think is the easier one so
159:14 - that's the one i am going to use
159:16 - so really all i'm going to do is player
159:19 - and status
159:21 - and what i want to get
159:23 - essentially is let me illustrate it here
159:26 - so i want to have these four directions
159:28 - so up down left and right
159:31 - my problem right now is that i have to
159:34 - get rid of these other directions so
159:37 - right idle would be kind of annoying
159:40 - but this is fortunately quite easy to
159:42 - get rid of because for that
159:44 - we have the
159:46 - split method
159:49 - and split method needs two arguments the
159:52 - first one is at which character we want
159:54 - to split things in my case at the
159:56 - underscore
159:57 - because back my player
159:59 - the up for example is
160:01 - split from the idle by the underscore so
160:05 - if we split this string by the
160:07 - underscore
160:08 - we get up and idle
160:11 - so that's then the first thing i'm
160:13 - caring about
160:15 - and you could also pass in a second
160:16 - argument that tells you how many times
160:18 - you could potentially split the string
160:21 - but in my case that shouldn't matter
160:24 - and now let's actually print what we get
160:26 - that's probably the easiest way to
160:28 - illustrate this so now when i run this
160:30 - again i press space
160:32 - now we get right now down and idle
160:36 - now if i move up we get up
160:38 - we get left and idle right down
160:41 - left this is working pretty good
160:44 - now what you do notice
160:46 - if we only stand and we have up and idle
160:50 - then python splits this but if we are
160:52 - moving and we only have up then we only
160:55 - get a single element
160:57 - but in both cases this is working really
160:59 - well
161:00 - so
161:02 - essentially this split method here if it
161:05 - doesn't find an underscore it's just
161:08 - going to ignore whatever it has
161:10 - but now we have a list of our directions
161:13 - and if the player is idling or not now
161:16 - the information if the player idles i
161:17 - was attacking i don't care about so i'm
161:20 - just going to pick the item with the
161:22 - index 0
161:23 - because our string is always going to
161:26 - start
161:27 - with the direction
161:28 - which is the only part i really care
161:30 - about
161:32 - so with this simple line
161:34 - we already have the direction of our
161:36 - player
161:37 - so with that
161:39 - we can start figuring out the
161:40 - positioning of our weapon
161:42 - so
161:43 - if direction
161:45 - is equal to right
161:48 - i now have to figure out a different
161:50 - kind of rectangle
161:53 - and again let me visualize what i want
161:55 - to do and let me draw it a little bit
161:57 - larger so here
162:00 - we have
162:02 - our player
162:04 - and
162:06 - the weapon should be if we're moving to
162:08 - the right should be right
162:11 - here
162:13 - and i would invite you to think about
162:14 - how we could place the weapon in the
162:17 - middle of the player to the right of the
162:19 - player so that they're right next to
162:21 - each other
162:23 - and do think about this for just a
162:24 - second
162:29 - basically what i am going to do
162:32 - is our player has
162:35 - a mid right position of the rectangle so
162:39 - that's the position we are going to use
162:40 - for the player
162:42 - and then when we are placing the weapon
162:44 - we are going to place the mid left so
162:48 - let's call this one
162:50 - ml
162:51 - and this one is going to be m r
162:55 - so if we place those two points in such
162:57 - a way we would have both of these right
162:59 - next to each other
163:01 - when my player is walking to the right
163:04 - i want to place the mid left
163:06 - of my weapon and the position where i
163:09 - want to place it
163:10 - is at the mid right of my player
163:14 - and for now let's just add an else
163:17 - statement so we have something so
163:19 - self.rect is self.image.get
163:22 - underscore rect
163:24 - and center
163:25 - is going to be
163:26 - [Music]
163:28 - layer.rect.center so we don't get an
163:30 - error but now if we're running the game
163:33 - and we're moving to the right
163:34 - our rectangle should be spawned to the
163:36 - right of the player so let's try this
163:39 - and if i move to the right
163:41 - we get indeed something that almost
163:44 - works
163:45 - so
163:46 - we have
163:47 - our rectangle of the weapons pointing to
163:49 - the right of the player
163:51 - but if we look a bit closely
163:53 - and during the attack animation
163:55 - our player's hand
163:58 - is a bit too low and the reason for that
164:01 - is that
164:02 - the player hand is a bit below the
164:05 - middle part of the sprite so we don't
164:08 - actually want to spawn our weapon
164:10 - right in the middle of the player we
164:11 - want to give it a tiny offset
164:14 - and this we can add quite easily
164:16 - actually
164:17 - so
164:18 - this position here right now is a tiny
164:20 - bit too high
164:23 - but really all we have to do to change
164:24 - it is pygame.math.vector2
164:27 - [Music]
164:30 - and we don't want to move it in the x
164:32 - position but we do want to move it down
164:35 - by 16 pixels
164:38 - so now let's try this again
164:41 - and now we have a weapon
164:43 - exactly where the hand is supposed to be
164:47 - so with that we have one direction now
164:50 - all we have to do is figure out all of
164:52 - the other directions
164:54 - so l if direction
164:57 - is equal to left
164:59 - and for this one i can just copy paste
165:02 - the right direction
165:04 - and change mid left to mid right
165:07 - and then mid right to mid left
165:11 - and the vector can actually stay the
165:13 - same that one's perfectly fine
165:15 - so now
165:16 - if i move right still works if i move
165:18 - left
165:19 - name left is not defined let's have a
165:21 - look ah should be in quotation marks
165:25 - so now let's try this again so right is
165:27 - still working and left is still working
165:29 - so cool now we already have two
165:32 - directions that work just fine
165:36 - okay
165:37 - now
165:38 - next up
165:40 - we have l if direction
165:44 - is going to be down
165:46 - and i guess let me copy the line again
165:49 - except now
165:50 - we want to place the mid
165:54 - top of our weapon and we want to place
165:56 - this at the mid
165:58 - bottom of our player
166:01 - and now for the vectors we do have to
166:02 - make a slight adjustment
166:04 - so in this case we do want to move the x
166:06 - position but not the y position
166:09 - so let's try this and we have right we
166:12 - have left and now we have down
166:15 - this one also seems to work so the one
166:18 - thing left is up
166:20 - and this we could put in the else
166:22 - statement so in here we want to place
166:26 - the mid bottom of our weapon
166:28 - and it should be in the mid top of our
166:30 - player
166:32 - and then we want to add this vector to
166:35 - it
166:38 - now we should have the placement of our
166:40 - weapon so
166:42 - down
166:43 - all directions look pretty good
166:49 - so i can't see any problems with this
166:52 - nice
166:53 - so with that we have the placement of
166:55 - our weapon
166:56 - obviously right now doesn't look very
166:58 - good because we have to figure out the
167:00 - actual graphics of the weapon
167:03 - now fortunately this is quite simple and
167:05 - let me show you the folder setup so here
167:07 - we have all of our folders and the one i
167:10 - care about right now is weapons
167:12 - and inside of weapons we have our five
167:14 - different weapons now if i go inside of
167:17 - sword
167:18 - we can see down full left right and up
167:22 - and the full sword is the one that's
167:24 - going to be in the ui
167:26 - but all the other directions we are
167:28 - going to actually display in the game
167:31 - and notice here
167:33 - down is exactly named like the direction
167:36 - or the status of our player so we can
167:38 - use the string of our player to select a
167:41 - specific weapon inside of this folder
167:44 - which is exactly the idea here
167:47 - although before we can actually select
167:49 - any direction we first have to select
167:52 - the weapon we actually want to use so we
167:55 - have to tell our player what weapon is
167:57 - currently selected
167:59 - and that is the first one we have to
168:01 - work on so let me do it straight back in
168:03 - the code
168:04 - so here we're back in the weapon code
168:07 - and right now we want to pick one image
168:10 - of the weapon but to pick the right
168:12 - weapon we need to know what weapon the
168:15 - player has selected
168:16 - and this i want to keep in the player so
168:19 - let me minimize this one again the input
168:21 - as well
168:23 - so in the movement let me actually add a
168:25 - whole new section here
168:28 - and let's call this one
168:30 - uh let's call it a weapon i guess that
168:32 - works and then here we can actually put
168:33 - create a tag as well that works a bit
168:36 - better
168:38 - now what i want to do in here is self
168:40 - dot
168:41 - weapon
168:42 - index
168:43 - and right now it's zero and later on
168:46 - this is the number we are going to
168:48 - change to select different weapons
168:50 - and how that is basically going to work
168:53 - is i'm going to get my
168:55 - self.weapon
168:57 - and this is going to cycle through
169:00 - this weapon data list here
169:03 - and we are already importing all of the
169:06 - settings so i can just use weapon data
169:10 - so i want to get one specific key from
169:13 - this weapon data
169:14 - and to get that we need a couple of
169:16 - different things
169:18 - first of all right now we only care
169:20 - about the keys
169:23 - so
169:24 - in our weapon if we have a sword
169:26 - allowance an x or any of the other
169:28 - weapons
169:30 - and from this
169:31 - i want to get myself dot weapon index so
169:35 - for example if our weapon index is zero
169:38 - i want to pick the sword
169:40 - if my weapon index was 1 it would be the
169:43 - lance
169:44 - but right now this would not be working
169:46 - because what keys returns isn't the list
169:49 - that you can index from apparently so we
169:51 - have to turn it into
169:53 - a list
169:55 - and now we can just pick from this list
169:59 - with a different index and let me
170:01 - demonstrate so print self dot web pin
170:07 - and in theory now if we start the game
170:10 - we should be getting sword
170:13 - so let's try it
170:14 - and windy gets sword so this is actually
170:18 - working nice
170:20 - so now we know what weapon our player is
170:22 - supposed to have
170:24 - with that information back in my weapon
170:27 - i can now get a full
170:29 - path to that weapon
170:32 - and that is going to become an f string
170:36 - and first of all we have to go up to the
170:39 - graphics folder
170:41 - and inside of the graphics folder we
170:42 - have to go to weapons
170:44 - now inside of weapons
170:48 - we have to get the specific kind of
170:50 - weapon our player has selected
170:52 - fortunately the naming of the variable
170:55 - is the same as the folder so we can just
170:57 - go with
170:58 - player dot
171:00 - weapon
171:02 - now next up we want to select the right
171:04 - direction
171:06 - and this we get with direction
171:08 - and finally all we need is dot png
171:12 - so now we have the weapon and the
171:13 - direction
171:15 - so really all we have to do now is use
171:18 - pygame.image.load
171:21 - and import the full path
171:24 - and as always don't forget to convert
171:27 - alpha all of this
171:30 - and technically this is all we needed so
171:33 - now let's run this
171:35 - and now if i press to the right we get
171:37 - an error
171:40 - and you can see down here we have
171:41 - graphics swords weapons sword right
171:46 - essentially i forgot one slash
171:50 - so back in my weapon
171:52 - after weapons there should be forward
171:55 - slash so now let's try this again
171:58 - and there we go we have a sword that
172:01 - works in all the different directions
172:04 - and that's a pretty good start
172:06 - although you can see the problem right
172:07 - now our weapon does stick around which
172:10 - is not ideal although it's kind of
172:13 - looking funny
172:15 - but okay cool this is working pretty
172:17 - well
172:19 - so the last thing we have to figure out
172:21 - is how to despawn the weapon once it's
172:24 - supposed to end
172:26 - and this i am also going to do in my
172:28 - level.pi file
172:30 - and in here let me minimize everything
172:32 - again
172:33 - i just want to create
172:35 - another method that i'm going to call
172:38 - destroy
172:40 - weapon and in itself and nothing else
172:44 - and now i want to first check if this
172:47 - weapon exists in the first place
172:50 - now right now we can't really do this
172:52 - because we have no way to identify if
172:54 - this thing exists so i want to store it
172:57 - in its own variable
172:59 - so in my init method
173:02 - i'm going to create let's put it
173:05 - actually even better let's add a whole
173:07 - another section and let's call it the
173:09 - attack
173:11 - sprites
173:12 - because there's going to be a bit more
173:14 - later on but for now i just want to have
173:16 - self.current
173:19 - attack and it's going to be none by
173:21 - default
173:23 - and then when we create the weapon it's
173:25 - going to be stored in self dot
173:30 - current attack
173:32 - so now in our destroy weapon all we have
173:34 - to do is if self dot current attack
173:37 - exists then we want to get self.current
173:40 - attack
173:41 - and kill it
173:43 - and i guess just for good form we can
173:45 - also set self.current attack
173:47 - back to none
173:49 - and now all we have to figure out is how
173:51 - to call this method here and i think
173:54 - this could be a pretty good exercise for
173:56 - you so try to figure it out and it's
173:59 - going to work in a very similar way
174:01 - compared to create a tag
174:08 - so let me minimize the init method again
174:11 - and in my create map
174:13 - i have already put self.create attack in
174:16 - there and now besides that i also want
174:18 - self self.
174:20 - destroy weapon
174:23 - oh i just realized the naming here isn't
174:25 - ideal let's call it destroy attack
174:28 - and
174:30 - destroy
174:33 - attack and here as well
174:36 - that way our naming is a bit more
174:38 - consistent
174:40 - okay and then in our player
174:43 - we now want self
174:45 - dot destroy
174:48 - attack as well and that one is just
174:50 - going to be destroy
174:52 - the tag
174:53 - and this one then is going to be another
174:56 - parameter
174:58 - so now we can call destroy tag inside of
175:01 - our player
175:02 - we just have to figure out when to call
175:05 - it
175:06 - and the answer in my case is in my
175:08 - cooldowns because we know
175:11 - after this cooldown our player's attack
175:14 - is supposed to be over so we can attack
175:16 - again
175:17 - so what we can do in here is self dot
175:20 - destroy
175:21 - attack
175:23 - and that is
175:25 - all we needed i believe so now
175:28 - i can attack in each direction
175:30 - and we can see the weapon
175:33 - so this is actually coming together
175:35 - really nicely
175:37 - and on top of that our weapon is also
175:40 - obeying
175:42 - the drawing order so it's drawn above or
175:46 - below different sprites so all of this
175:48 - is working super well
175:50 - now i guess there's one more thing that
175:52 - we do have to implement because right
175:54 - now we cannot switch between different
175:57 - weapons or well i guess we can if we go
176:00 - to my player and we change weapon index
176:03 - let's say to a free
176:06 - let's see what we get if i now press
176:08 - now we get the whatever this weapon is
176:10 - called but it's definitely working
176:15 - so we have to figure out in code how to
176:17 - change this weapon index
176:20 - from inside of the game
176:23 - and well
176:24 - let's do this in the input
176:26 - so in here we already have quite a few
176:28 - different things
176:30 - and i just want to add
176:32 - another if statement
176:34 - and in my case if keys
176:37 - now in my case the key i am using to
176:39 - switch the weapon is q so pygame dot k
176:43 - underscore
176:44 - q
176:45 - and in the most basic sense all that
176:47 - this one is supposed to do is get myself
176:50 - dot weapon index and add 1 to it
176:55 - unfortunately by itself it's not that
176:58 - easy for the same problem that we have
177:00 - seen with the attack and the magic input
177:03 - that if we didn't add a timer in here
177:06 - pygame would press
177:08 - or would trigger this code
177:10 - very often because the normal button
177:12 - press for normal human being is going to
177:14 - be let's say half a second long now for
177:16 - pygame half a second is a lot of frames
177:20 - in our game and for each of those frames
177:23 - this button would be pressed
177:25 - so if we press this button once
177:27 - python would update weapon index with
177:29 - plus 1 probably about 10 times
177:32 - so instead we have to create another
177:34 - timer like we have done earlier
177:37 - and now this timer has to be independent
177:40 - from the attack and the magic one
177:42 - because the player should be able to
177:43 - switch weapons at basically any time
177:46 - so i want to create another timer
177:48 - and the first we have to do for that
177:51 - is let's say in my weapon i think it
177:54 - makes sense there
177:55 - and what i want to create in here is
177:57 - going to look very similar compared to
177:58 - these lines here
178:00 - so first of all i want to create another
178:02 - variable that i called can switch
178:06 - underscore weapon
178:08 - and by default this one should be true
178:11 - and then besides that i want to have
178:13 - self dot
178:15 - weapons switch
178:18 - time
178:20 - and this by default is going to be none
178:22 - so that's the equivalent of our attack
178:24 - time now finally we need to cool down
178:27 - duration
178:28 - and in my case it's going to be the same
178:30 - thing for the weapon and for the magic
178:32 - switching
178:33 - so we can call this one self dot
178:37 - switch
178:38 - duration
178:40 - cooldown
178:42 - and this one i put at 200
178:44 - so now we have all we need to create a
178:47 - basic timer
178:48 - so now back
178:51 - in this line here
178:53 - i only want to trigger
178:55 - the cue press if we press the button and
178:58 - if self dot can't switch weapon is true
179:02 - and if we have pressed it then self dot
179:05 - can't switch weapon
179:08 - should be false
179:09 - and just like we have done
179:11 - up here we also want to get the time
179:14 - that we press this button so self dot
179:18 - i think what did i call it
179:21 - weapon switch time
179:23 - so weapons which time
179:26 - is going to be
179:27 - dot time dot get
179:29 - underscore ticks
179:30 - and only once that is the case we want
179:33 - to update our weapon with plus equal one
179:36 - and let me just check if i'm starting at
179:38 - weapon zero yep so now in the game
179:41 - secondly we should be able to switch our
179:43 - weapon once let's try
179:47 - so right now if i press the attack we
179:49 - get our sword now if i press q
179:53 - we still get our sword and i think i
179:55 - know why
179:57 - so back in my player
180:00 - we are updating our weapon index
180:03 - but if i go up to the init method
180:07 - we have changed right now our weapon
180:09 - index but what we have not updated is
180:11 - our actual weapon so this was only set
180:14 - in the init method but it's not being
180:17 - updated when we press the button so
180:19 - that's what we have to do as well
180:21 - and let me just copy the entire list i
180:23 - think that's the easiest way to approach
180:25 - this
180:29 - so after i've updated the index i also
180:31 - want to update myself.weapon
180:35 - and this happens basically with the same
180:37 - line well exactly with the same line
180:39 - so now let's try this again
180:42 - so sort now if i press q and now we get
180:45 - the lance
180:46 - although since i don't have a timer to
180:49 - react to weight my can't switch weapons
180:52 - we can't change it again
180:54 - but that we can do now
180:56 - and that's going to happen down here in
180:58 - cooldowns
180:59 - and i would actually recommend you to
181:02 - look at our cooldown for the attack
181:04 - animation and copy it so we can switch
181:07 - weapons and have a timer for that
181:14 - what i basically want to do is
181:17 - if
181:18 - self dot can switch weapon
181:23 - and i want to check if this is not the
181:26 - case
181:27 - because we are setting this thing up
181:28 - here to false so only if this is false
181:31 - we want to run the timer
181:33 - and if the time is running i want to get
181:35 - my current time
181:37 - and subtract self dot weapon switch
181:42 - time
181:43 - and if that is greater or equal to self
181:47 - dot weapons which what i call it again
181:52 - we start to have a lot of variables
181:54 - switch duration cooldown there we go
181:57 - so down here switch duration cooldown
182:00 - now if that is the case we want to set
182:02 - self dot can switch weapon
182:06 - back to true
182:08 - and now let's try this again
182:10 - so now my weapon still works now if i
182:12 - press q
182:13 - we get the lance if i press it again
182:16 - we get the x
182:17 - press it again different weapon and a
182:19 - different weapon but now i press it
182:21 - again and now we have list index out of
182:24 - range
182:26 - and this happens if i go to my
182:28 - player that we are always updating this
182:32 - number by one but we only have five
182:34 - weapons inside of our list so at some
182:37 - point this number is going to exceed the
182:39 - length of that list
182:40 - but that we can fix fairly easily and
182:44 - really all we have to do is if self dot
182:48 - weapon
182:49 - index
182:50 - is more than the length of the list of
182:53 - our keys so this thing here
182:57 - and only if that is the case we want to
182:58 - add plus one to our weapon index
183:02 - now if that is not the case we want to
183:04 - do something else and what we want to do
183:07 - is to set our self.weapon index back to
183:10 - zero so once we're exceeding that number
183:12 - we are going back to zero
183:15 - and that way i don't have to implement a
183:17 - backwards mechanic for this button but
183:20 - you could totally do that if you wanted
183:22 - to
183:23 - but with that logic we have the weapon
183:25 - mechanic so let's try
183:28 - so now i get sword
183:30 - lens x next one next one now if i press
183:33 - q again
183:35 - we still get an error okay
183:37 - not great
183:38 - let's have a look ah and what i just saw
183:42 - this should be length
183:44 - minus one
183:45 - because we start counting from zero
183:49 - so
183:50 - now let's try this again
183:51 - different weapons different weapons and
183:54 - answer again now we're back to sort cool
183:56 - so now this is working
184:00 - so this is a common thing in python that
184:03 - the length of our list was one too large
184:06 - because of the way we're counting the
184:07 - length of the list
184:09 - but well now we have our proper weapon
184:12 - mechanic
184:13 - so all right with that we have a weapon
184:16 - although right now you can't really see
184:19 - the weapon so next up we are going to
184:21 - work on the ui and i guess while we're
184:24 - at it we can also implement the health
184:25 - bar the energy bar the experience or the
184:28 - souls and then the magic we currently
184:30 - have selected so we have all of the
184:32 - stuff in one place
184:35 - so i guess let's talk about how to
184:36 - approach the ui that's going to be the
184:38 - next section
184:39 - i guess in the most basic sense the ui
184:43 - is going to consist of two different
184:45 - elements number one is our player is
184:48 - going to have a ton of different data
184:50 - for example what our current weapon is
184:52 - that's one we already have but besides
184:54 - that we also need health energy
184:56 - experience our magic
184:59 - and i guess that's it and these are the
185:01 - things we have to add to our player
185:03 - now once we have all of them we can
185:06 - actually start working on the ui
185:07 - elements that are visible
185:09 - and this is going to involve a couple of
185:11 - different things for example we have to
185:13 - show the health bar and the energy bar
185:16 - and both of those for example are just
185:18 - rectangles and the width is determined
185:20 - by the amount of health as a proportion
185:22 - of our full health or our full energy so
185:26 - we're not really going to do anything
185:27 - sophisticated we're just creating
185:29 - different rectangles
185:31 - and the weapon and the magic are just
185:33 - the images with some background
185:34 - rectangles one has a color one only has
185:37 - an outline and if we combine these
185:39 - different elements we basically get some
185:42 - nice looking ui that i think came
185:44 - together really really well and i guess
185:47 - this part is best explained when i
185:49 - actually implemented so let's start with
185:51 - number one and let's give our player a
185:53 - couple of key attributes to actually
185:55 - create a game
185:57 - here i am back in my player and let me
186:00 - go down and add another section here and
186:03 - let's call this one stats
186:06 - and what i'm going to paste in here is
186:08 - just going to be a dictionary so we have
186:11 - our health our energy our attack our
186:13 - magic and our speed
186:15 - and i guess if you're confused right now
186:17 - we have attack here and for each weapon
186:20 - we have damage
186:23 - and what i'm going to do later on is our
186:25 - ultimate damage of the player is the
186:27 - base attack plus the weapon damage
186:31 - so these are going to be our base stats
186:33 - but we need a few more things so right
186:36 - now our health is at 100 and this would
186:39 - be our current maximum but now imagine
186:42 - we run the actual game and an enemy hits
186:44 - us then we have to lower this amount but
186:48 - we still have to know what our maximum
186:49 - amount is
186:51 - and for that
186:53 - i want to add self.health
186:56 - and by default it's going to be
186:58 - self.stats
187:00 - and just
187:02 - health
187:03 - so by default our self.health is going
187:06 - to be the same as the maximum we can
187:07 - have
187:08 - however later on in the game we can
187:10 - actually lower this amount and then we
187:13 - can have a different between the maximum
187:14 - and our current health
187:16 - and we can do the same thing since we're
187:18 - going to need it anyway
187:20 - is our energy
187:23 - and this is just going to be self.stats
187:25 - and in here our energy
187:28 - and there's one more thing that we do
187:30 - need for the ui and that is self.exp
187:35 - and this one doesn't have a stats entry
187:37 - because it's well just the experience
187:39 - and let's say just so we have a number
187:41 - let's go with one two three
187:43 - and actually while we're here we can
187:45 - also now determine self dot speed
187:48 - is going to be self dot stats
187:52 - and speed
187:54 - so now we can go up a tiny bit and get
187:56 - rid of this speed here
187:59 - because later on we want to be able to
188:01 - update this and i guess it should be
188:03 - five by default so we keep the same
188:05 - speed
188:06 - okay now our player has some stats and
188:09 - some current stats that we can work with
188:12 - so now we actually have to create the ui
188:16 - and what i want to do
188:18 - is to create a new file that i'm going
188:20 - to save as ui.pi
188:23 - and in here as always we need import
188:25 - pygame and from
188:27 - settings import all of it
188:31 - and now i want to create a new class
188:32 - called ui
188:34 - and then here as always we need our
188:38 - init method
188:39 - with self and nothing else
188:42 - and for now let's just add a pass in
188:45 - here
188:46 - and figure out how to call this thing in
188:48 - the first place
188:50 - and i want to call this from the level
188:52 - because in here we are drawing all of it
188:54 - and let me minimize all the methods so
188:57 - it's a bit easier to see let's say we
188:59 - can minimize this one as well
189:01 - now in my level class
189:03 - i want to create another section
189:05 - and let's call this one the
189:08 - user
189:09 - interface
189:10 - and what i want to do here is self.ui
189:14 - is going to be ui so the class we have
189:17 - just created this one here
189:20 - and for that to work we have to do from
189:23 - ui
189:24 - import ui
189:26 - so now we can actually use it
189:28 - and pretty much what i want to do
189:31 - in my run method on top of everything
189:34 - else i guess i can get rid of the debug
189:36 - one
189:37 - i can run self dot u i
189:41 - and essentially i want to give it one
189:44 - method that i call display
189:46 - and to get the information from the
189:48 - player i want to pass self dot player in
189:51 - here
189:52 - and that is pretty much all we have to
189:54 - do in our level now we can just work in
189:58 - our ui
189:59 - and all we need is one method that was
190:02 - called
190:04 - this
190:05 - play
190:06 - and we need self and the player as the
190:09 - arguments
190:10 - so now we can go pass and now we have a
190:13 - class where we have access to the player
190:15 - and we can call it from the level itself
190:18 - or well we are always calling it
190:21 - and now let's run this we don't get an
190:23 - error
190:24 - so at the very least it's working cool
190:27 - so now we just have to figure out all of
190:29 - the ui elements
190:31 - and there are quite a few different ones
190:34 - so let's go through this thing step by
190:35 - step
190:36 - first of all
190:38 - we need a couple of general bits of
190:40 - information
190:41 - so let's call this general
190:44 - and first of all i want to have access
190:46 - to the display
190:48 - surface
190:50 - and this we get as always with pygame
190:52 - dot display dot get underscore surface
190:56 - now next up we also have some text so i
190:59 - want to create self dot font
191:02 - now we do have a font that we can just
191:04 - import and i also know the font size but
191:08 - for my ui design i have quite a few
191:10 - parameters like the bar height the width
191:13 - of all the elements the box sizes of the
191:16 - weapon and magic items
191:18 - and i want to store all of this in my
191:20 - settings
191:21 - so before i import the font
191:23 - let me go to my settings and in here i
191:26 - want to add another sections that i
191:28 - called
191:29 - the ui
191:32 - and in here i have a couple of
191:34 - parameters that look like this
191:37 - and these are all the elements i will
191:40 - need to well make the ui work
191:43 - and actually while we are here there are
191:46 - a couple more
191:47 - and these ones are going to be colors so
191:50 - we have our general colors we have the
191:52 - water the uibg color the border color
191:55 - and the text color
191:56 - and then we have the health bar color
191:58 - the energy bar color
191:59 - and then if we select something you're
192:01 - going to see how those look later on but
192:04 - for now all of these are just very
192:07 - simple variables that don't really store
192:10 - anything complicated
192:12 - so all right now we can use them so
192:14 - first of all i want to import my font
192:17 - and this is going to happen with
192:17 - pygame.font.font
192:20 - and in here we need the font we want to
192:22 - import
192:23 - which in my case is i called this one ui
192:28 - font
192:29 - so ui underscore font and then we need a
192:33 - font size which in my case is stored in
192:35 - ui underscore font underscore size
192:40 - and now we have to choose which element
192:41 - to start with so we can either do the
192:43 - health and the energy bar the experience
192:46 - or the weapon or magic
192:48 - and let's say we're going to start with
192:50 - the health and energy bar
192:52 - i'm going to add another tab here and
192:54 - let's call it for now
192:56 - the bar
192:58 - setup
192:59 - and right now i want to create some
193:01 - general rectangle where the health and
193:03 - where the energy bar is going to be
193:05 - and this is just going to be a rectangle
193:07 - and i'm going to call this health bar
193:11 - rect
193:12 - and this is going to be pygame dot rect
193:16 - and now for this one
193:18 - we need the left the top the width and
193:21 - the height
193:22 - now the width and the height we do have
193:24 - in here
193:25 - so we have a health bar width that we
193:28 - can put in here
193:30 - and the bar height is identical so it's
193:32 - just called bar height
193:34 - so bar height
193:37 - now next up for the left and the top
193:39 - i just went with 10 and 10
193:43 - which is in the top left now besides
193:45 - that i also want self dot energy
193:48 - bar
193:50 - rect
193:51 - and this one is going to work in a very
193:53 - similar way so pygame direct and now
193:56 - again we need to left we need the top we
193:58 - need to weft and we need the height
194:01 - and now the height we already have is
194:03 - just the bar height
194:05 - for the width we have energy bar width
194:08 - in our settings so within here
194:11 - and i want this one to start on the same
194:14 - x position but the top is supposed to be
194:17 - a bit further down i went with 34
194:20 - and now once we have that we could
194:22 - actually already try to draw something
194:25 - so let's see if this works in the first
194:26 - place
194:27 - so i just want to use pygame.draw.rect
194:32 - and in here we need a surface
194:36 - we need a color and we need a rectangle
194:40 - and for the surface we have self dot
194:43 - display surface
194:45 - let's say for the color for now it's
194:46 - going to be black we're going to change
194:47 - this anyway
194:49 - and for the rect let's go with dot
194:51 - health bar rect
194:54 - so now let's try this and we can indeed
194:56 - see a health bar in the top left and
194:59 - this one stays in a nice position so
195:02 - this is working very well cool
195:05 - but i don't want to draw this element
195:08 - right here so let me add a pass in there
195:11 - again
195:12 - instead i want to create a function that
195:14 - is a bit more flexible so just a
195:17 - function that can take a current amount
195:19 - a max amount a background rectangle and
195:21 - a color and then display either health
195:24 - bar or energy bar so we can use it for
195:26 - both
195:28 - and well
195:29 - let's implement this one so i call this
195:32 - one show
195:33 - bar
195:35 - and in here we need a couple of
195:36 - different arguments so first one we need
195:38 - the current amount
195:42 - then we need the max
195:44 - amount
195:46 - then we need the background
195:48 - rectangle
195:49 - and then we need a color
195:52 - so for example what i essentially want
195:54 - to do i want to call self.showbar
195:58 - and then in here i want to pass in
196:01 - player dot health
196:03 - and
196:04 - player dot stats
196:07 - and health so that's our max health
196:10 - then i want to pass in this rectangle
196:13 - and this is going to give us the
196:14 - position of where the health bar is
196:16 - going to be
196:17 - and then finally i want to give this
196:19 - thing a color and a color we get from
196:21 - our settings we have health color
196:23 - although granted it's just red
196:26 - so in my ui i can pass this in here
196:30 - and where this system is really useful
196:33 - now we could just copy all of this
196:35 - and change health
196:37 - to
196:40 - energy
196:41 - and then this health should also be
196:45 - energy
196:46 - and our health color should be
196:48 - the energy color although again the
196:51 - energy color is just blue
196:54 - all right now we have a function to
196:56 - create the health and the energy bar we
196:59 - just have to write it
197:00 - first of all we have to draw the
197:02 - background
197:04 - that is what i basically wrote just a
197:05 - second ago so again pygame.draw.rect
197:10 - and here we again need
197:12 - self.display surface
197:14 - then we need a color and in my case the
197:17 - color is the
197:20 - ui bg color
197:22 - so i can paste this here and then we're
197:24 - going to need our bg rectangle and i
197:27 - guess quite important
197:29 - this color here
197:30 - is not supposed to be
197:32 - this color up here so that's not the
197:34 - case right now we are just drawing the
197:36 - background of our bar we're not drawing
197:39 - the bar that's supposed to indicate the
197:40 - health right now that will come in just
197:43 - a second
197:44 - but now actually this should already
197:46 - work let's try this
197:48 - and yeah now we can see
197:50 - our two bars for health and energy in
197:52 - the top left and they are working
197:55 - perfectly fine and now that we have that
197:58 - we can start working on drawing the bar
198:02 - although now we do have a problem and
198:05 - let me illustrate what the problem is so
198:08 - right now we have one bar let's say it
198:11 - has a length of something like this
198:14 - and i know from my settings so the
198:16 - health bar width for example that this
198:18 - entire thing right now is 200 pixels
198:20 - wide and all of that so far worked
198:23 - pretty well
198:24 - now the problem is that my health is not
198:27 - in pixels
198:29 - so this player health here
198:31 - at the current maximum would be
198:34 - 100.
198:36 - so this would be our full health the
198:38 - problem is
198:41 - inside of this thing we have to convert
198:43 - this 100 to a 200
198:46 - and this should then obviously be
198:47 - flexible so we have to figure out how
198:50 - much is 100 health in terms of pixels in
198:54 - our health bar
198:55 - so we need a bit of math to convert our
198:57 - health into pixels
198:59 - and let me actually add another section
199:02 - to that
199:03 - so converting
199:06 - stat to
199:08 - pixel
199:10 - and first of all i want to figure out a
199:12 - ratio
199:13 - and that is going to be
199:15 - my current amount
199:16 - divided by my max amount
199:19 - and that is going to tell me how much of
199:21 - my max amount do i actually have and
199:24 - this is already getting us really close
199:25 - to a pixel measurement because i know
199:28 - for example for my health my max amount
199:30 - is going to be 200 pixels wide
199:33 - so what i want to figure out next is my
199:36 - current
199:38 - width from that and all i really want to
199:40 - do in here is get my background
199:43 - rectangle and get the width from that so
199:45 - that is my max width in pixels
199:49 - and this i just want to multiply by the
199:52 - ratio
199:53 - and let's do some numbers just to
199:54 - illustrate how this is going to work so
199:57 - our current health right now is 100
200:00 - and our maximum is also
200:03 - 100 so if you divide one by the other
200:06 - you end up with one
200:09 - now our b direct for our health is going
200:12 - to be 200 pixels wide
200:14 - and if our ratio then is one
200:17 - we are going to get a pixel width of 200
200:20 - for our entire bar
200:22 - so this is then working quite well
200:25 - now let's say we have different numbers
200:27 - so instead of 100
200:29 - we get
200:30 - 50.
200:32 - now our result is going to be 0.5
200:37 - and if we multiply 200 with 0.5 we don't
200:41 - get 200 we get 100
200:44 - which is exactly half of the width of
200:47 - our background rectangle all right so
200:50 - now we have to use that information to
200:52 - create a new rectangle so let's call it
200:54 - current rect
200:56 - and
200:57 - since i already have in my background
200:59 - rectangle most of the information
201:02 - i can just copy this one
201:04 - and now for my current react dot width
201:08 - i'm going to set this to my current
201:11 - width
201:12 - so this way i have a rectangle in the
201:14 - same position with the same height but
201:16 - with this line i give it a different
201:18 - width
201:20 - so all we have to do now is to draw this
201:22 - rectangle so pygame.draw.rect
201:27 - now we still need self.display surface
201:30 - next up we need the color and that color
201:33 - we are getting from the parameters so we
201:35 - don't have to worry about it
201:37 - and finally
201:39 - i want to draw my current
201:41 - rect
201:43 - and now
201:45 - let's try this
201:46 - there we go
201:48 - now in our top left we can see our
201:50 - health and our energy bar
201:52 - and what i can also do
201:54 - so let's say in my player
201:57 - just to illustrate let me multiply our
202:01 - health by 0.5
202:03 - and our energy by 0.8
202:09 - now if we run this
202:11 - you can see that we have half of our
202:12 - health and most of our energy
202:16 - so this way we can change the health and
202:18 - the energy of the player and it updates
202:20 - automatically so this system works super
202:22 - well
202:23 - now there's one more thing i did add to
202:25 - this
202:26 - and that is basically a border around
202:28 - the health bar which does make it look a
202:30 - bit nicer and this is just
202:32 - pygame.draw.org
202:35 - self dot display surface
202:38 - now for the color
202:40 - we have in settings a ui border color so
202:44 - that's the one i'm going to use here
202:46 - and then besides that we have the
202:47 - current rectangle
202:49 - so right now we are just drawing a
202:51 - rectangle on top of the other rectangle
202:54 - which wouldn't be very helpful
202:56 - but now if we are giving this another
202:58 - argument this would be the line width in
203:00 - my case it's free
203:03 - and once it gives something in line
203:05 - within pie game the fill disappears and
203:07 - we only have the line let me actually
203:10 - demonstrate
203:11 - now it looks like this
203:13 - oh when i did make a mistake right now
203:15 - we are just drawing a bar around our
203:17 - actual health which is not what i want
203:20 - instead i want to draw
203:23 - around my
203:25 - bg rect so we are covering the entire
203:27 - bar with an outline so now let's try
203:30 - this again
203:32 - and there we go this is looking quite a
203:34 - bit better
203:35 - it's a touch hard to see but if you look
203:37 - at the left of it it is definitely there
203:40 - so alright with that we have our health
203:43 - bars wasn't actually that bad
203:46 - so now i can minimize my show bar and
203:48 - never worry about it again
203:50 - so with that part covered we can start
203:53 - working on the experience and that part
203:55 - should be really easy basically what i
203:57 - want to do
203:58 - i'm going to call another method and
204:00 - this one's going to be called show
204:02 - exp
204:04 - so let's create that method
204:07 - show underscore ex and this one besides
204:10 - self also needs let's call it the
204:13 - exp
204:14 - and now what i want to do first of all i
204:17 - want to create a text
204:19 - surface
204:21 - and the text is going to be the
204:22 - experience
204:23 - and essentially this means i want
204:26 - self.render
204:28 - and in here we need the information we
204:31 - need anti-aliasing
204:33 - and we need a color
204:36 - and let's go through them one by one
204:38 - let's start with the easiest one
204:39 - anti-aliasing in my case
204:42 - it's false because i have pixel art and
204:44 - this one shouldn't be in the earliest
204:47 - and besides that for the color
204:49 - i can go to my settings and in settings
204:53 - i have a text color so that's the one
204:55 - i'm going to use
204:57 - and then finally
204:59 - we have our information
205:01 - and this is supposed to become the axp
205:04 - and right now exp
205:06 - is going to be in our player
205:09 - and it is
205:12 - this number here an integer
205:15 - now the problem is that python for this
205:17 - one needs a string
205:19 - so this one wouldn't work by itself but
205:21 - we can fix that fairly easily
205:24 - by using the string method
205:27 - and there's one more thing i would like
205:28 - to do and that is that i want to convert
205:31 - this number
205:32 - into an integer now why do i want to do
205:35 - that because right now our experience
205:38 - already is an integer
205:40 - essentially this is to make sure that
205:42 - our numbers don't get too long so if by
205:44 - some weird math we end up with a
205:46 - floating point number with 10.0001
205:50 - this would look very strange in the
205:51 - experience
205:52 - and converting this experience to an
205:54 - integer avoids that problem entirely
205:57 - so next up
205:59 - we have to figure out how to place this
206:01 - surface and i did that with a rectangle
206:04 - and really all we need here is the text
206:06 - surface and get rekt
206:09 - and since i want to place this thing in
206:11 - the bottom right let me actually draw it
206:13 - really quick
206:15 - so if this is
206:16 - my entire game window
206:18 - i want the experience to be down here
206:22 - ish
206:23 - and to place it down here i think the
206:25 - best point would be the bottom right
206:29 - so let's place that one
206:31 - actually i think this could be a pretty
206:33 - good exercise so try to place the text
206:36 - rectangle on the bottom right of the
206:37 - window wherever you think it looks good
206:40 - and then draw the text on the display
206:42 - surface
206:48 - first of all i need bottom right that's
206:51 - the point i would like to place
206:53 - and for this one i need x and y
206:57 - so i have to figure out what the
206:59 - dimension of these two variables are
207:00 - going to be and let's do them in
207:03 - separate variables so it's a bit easier
207:06 - to see what i'm doing
207:08 - now what we have to be aware of here if
207:10 - this again
207:11 - is our entire window and we are placing
207:14 - our experience down here with this
207:16 - origin point the thing i have to figure
207:19 - out is the maximum width of my window so
207:22 - this distance here and this would give
207:24 - me the right side of the window
207:26 - and now what i have to figure out from
207:28 - here is how far away i want to get from
207:31 - there and this would then give me my
207:34 - origin point on the x-axis and the same
207:36 - for the y we essentially first have to
207:39 - get the entire height of the window and
207:41 - then from that point subtract
207:44 - how high we want the experience to float
207:46 - from the bottom of the window
207:48 - so what that means in practice is we
207:51 - first have to get the dimensions of our
207:53 - window
207:54 - and this we can get
207:56 - with
207:57 - self dot display surface and get
208:01 - size
208:02 - and this is going to return as a tuple
208:04 - of x and y and for x we only care about
208:07 - the first one that is the x dimension
208:10 - now we can copy all of this
208:12 - and target the first one so with these
208:15 - two points our window would be right at
208:17 - the bottom right of the screen but i
208:19 - want that to be a tiny offset
208:22 - and in my case for x i went with 20
208:25 - and for y i had the same number
208:28 - so now our text rectangle is in the
208:30 - bottom right of the window
208:32 - now all we have to do is call
208:35 - self dot display surface
208:38 - and blit and pass in the text surface
208:41 - and the text rectangle
208:44 - and we are almost done the one thing we
208:47 - haven't done yet
208:48 - is in show xp we have to pass in the
208:51 - experience
208:52 - and this we get from player
208:54 - and that is still the player we are
208:57 - getting from the argument of the display
208:59 - method
209:00 - but player right now isn't good because
209:03 - we want the experience of the player so
209:06 - i want player.exp
209:08 - i believe i called it so in here yeah
209:11 - player.exp
209:13 - and now this should be working so let's
209:15 - try to run all of this
209:18 - and there we go in the bottom right of
209:20 - the window so all the way down here you
209:22 - can see the experience so not a bad
209:24 - start
209:26 - although also not a great one because
209:28 - you can barely read it
209:30 - but this we can fix quite easily because
209:33 - we can use the text rectangle to draw a
209:36 - background and a frame around this box
209:39 - so let's do that
209:41 - and first of all the background has to
209:43 - be behind our text
209:45 - and all i really need to do in here is
209:47 - to call pygame.draw.rect
209:51 - and in here i need my display surface so
209:53 - self.display surface
209:55 - then i need a color which in my case i
209:57 - called u i b g color the same as the
210:00 - health bar and finally a rectangle so
210:03 - our text rectangle
210:06 - and now
210:07 - this is already looking quite a bit
210:09 - better
210:10 - although not ideal because i would like
210:12 - the box to be slightly larger than the
210:14 - text but this we can also fix so this
210:18 - rectangle i want to be slightly larger
210:20 - and this we can also do with the inflate
210:22 - method
210:23 - that's the same method we've seen
210:24 - earlier to create the hitboxes
210:26 - and earlier we passed the negative
210:28 - numbers to make the rectangle smaller
210:30 - but if we pass the larger numbers let's
210:32 - say 20 and 20
210:36 - now our rectangle is going to become
210:38 - larger and that is exactly what i wanted
210:41 - so with that we have our background but
210:44 - i also want to draw a frame around this
210:48 - box and for that i am just going to copy
210:50 - the draw method and now i can add
210:53 - another argument and that way we get a
210:55 - frame which in my case has a width of
210:57 - three
210:58 - and then we also need another color and
211:00 - i call this one ui border color
211:04 - and now let's have a look
211:06 - and there we go
211:08 - the effect is fairly subtle but i do
211:10 - think it does make it look a little bit
211:11 - better
211:12 - but all right now we can show our
211:15 - experience
211:18 - so now let me minimize the experience
211:20 - method
211:21 - and now there's only one more element we
211:24 - have to cover and that is the selection
211:26 - box for the weapon and the magic and
211:29 - this i want to work kind of like the
211:31 - health and the energy bar that i have
211:33 - one method that just creates a box and
211:35 - then i can give this box different
211:37 - arguments to display different player
211:39 - statistics
211:40 - although this one has to become a little
211:42 - bit more complex since we're displaying
211:44 - an image but it's not that bad
211:47 - i guess let's work on it straight in the
211:49 - code
211:49 - now first of all i want to create
211:51 - another method that i have called
211:53 - selection underscore box
211:56 - needs self as always and then we need a
211:58 - position and i call this left and top
212:03 - and that is all we are going to need for
212:05 - now although there is going to be a
212:07 - change later on
212:08 - and this selection box is essentially
212:10 - going to give us the background
212:13 - box for our weapon so this is the box
212:16 - and then later on we are going to paste
212:18 - an image of the
212:20 - weapon
212:22 - in here
212:23 - so this selection box gives us the box
212:26 - and the position where to place this
212:27 - surface you're going to see a second
212:29 - what i mean now first of all we need a
212:32 - rectangle and i call this one the bg
212:34 - rectangle and for this one we want to
212:37 - create a rectangle so
212:38 - pygame.rect
212:40 - and for this one we have to figure out
212:42 - the left the top the width and the
212:45 - height
212:46 - and left on top we already have that
212:49 - part is literally the arguments we are
212:52 - getting from the function itself so
212:54 - those two we don't have to worry about
212:57 - now width and height are also very
212:59 - simple
212:59 - because in my settings
213:01 - i have an item called item box size and
213:05 - this one is supposed to determine the
213:07 - size of this box
213:09 - and since we are creating a square
213:12 - it's the same dimension for both x and y
213:15 - so now we have our background rectangle
213:18 - and what we can do already is draw it so
213:21 - pygame.draw.rect
213:23 - we need self dot display surface
213:26 - then ui bg color
213:29 - and then bg
213:31 - wrecked
213:32 - we can already call it just to see
213:35 - what's going on so selection box
213:38 - and let's say for the left i will go
213:39 - with 10
213:40 - and for the height let's say
213:42 - 1150
213:45 - so now let's try this
213:47 - and we can't see anything ah for the
213:50 - simple reason that this number is way
213:51 - too high it should be more like 600
213:55 - let's try now there we go now in the
213:58 - bottom right you can see the rectangle
214:01 - i guess let's put it a tiny bit further
214:03 - down
214:04 - let's say 630.
214:08 - oh yeah this feels much better so now we
214:11 - have a rectangle cool now what we can
214:14 - also do is copy this entire thing
214:17 - give it a border radius and now call
214:19 - this ui
214:21 - border color
214:22 - and with that
214:24 - we also have the frame around this box
214:27 - which is already making it look better
214:29 - nice
214:31 - and this is basically all we are going
214:33 - to need for the overlay for either the
214:35 - weapon or the magic so essentially what
214:38 - i'm going to do is call this twice
214:41 - the first one is for the weapon
214:44 - and the second one is for the magic
214:48 - and for the magic box i went with
214:52 - 85 and i put it a slight bit further
214:56 - down i think 35 is what i used so let's
215:00 - call it and there we go now we have our
215:02 - two boxes and they are slightly
215:03 - overlapping which i think looks pretty
215:05 - good actually let's give it a bit more
215:08 - of an overlap let's turn this to an 80.
215:12 - and there we go i think this looks
215:14 - really nice
215:16 - cool so with that we have our selection
215:19 - boxes
215:20 - now what we have to figure out is how to
215:22 - pass the weapon or the magic image in
215:24 - here and i realize we don't have the
215:26 - magic yet we're gonna work on that in
215:28 - the next section
215:30 - but for now let's figure out the weapon
215:32 - and i'm gonna put this in its separate
215:34 - method
215:35 - and let's call it the weapon
215:38 - overlay
215:39 - and since this method has to know what
215:41 - weapon the player is using i also want
215:44 - to get what i call the weapon
215:47 - index
215:48 - and this weapon index is going to be
215:50 - this weapon index in our player file or
215:53 - player class
215:54 - and i'm going to use that to figure out
215:56 - which surface we want to draw
215:58 - now first of all i want to call this
216:01 - selection box method from inside the
216:03 - weapon overlay and for that i can just
216:05 - copy all of this and paste it in here
216:08 - that already cleans things up and
216:11 - instead of calling this method i can
216:13 - call
216:14 - weapon overlay
216:16 - and i guess what we call the method
216:18 - i can also place in the argument so
216:20 - player dot weapon index
216:24 - so right now there shouldn't be any
216:25 - change and there isn't
216:27 - so now we are already drawing our
216:30 - background but this is only one thing i
216:33 - want from this because what i really
216:35 - want from this background is the
216:37 - position where my surface is supposed to
216:39 - be placed
216:41 - so ideally what i would like to do is to
216:43 - take this background rectangle and
216:46 - somehow get it inside of my weapon
216:48 - overlay and then place my surface of the
216:51 - weapon inside of that rectangle
216:54 - and that i can just get by
216:57 - returning the bg rect at the end of this
217:00 - method
217:01 - so now
217:02 - in this other method
217:04 - i can get let's just keep calling it be
217:06 - direct
217:07 - and i can get rid of the comment i
217:09 - suppose so now we have our bg rectangle
217:12 - available in our weapon overlay and i
217:14 - can minimize selection box we don't need
217:16 - it anymore
217:17 - and now essentially what i want to do i
217:19 - want to get myself.display surface
217:22 - and blit
217:24 - and i want to get a weapon
217:26 - surface and a
217:29 - web
217:30 - pin
217:31 - rect
217:33 - the weapon surface i'm going to get from
217:35 - settings and in my weapon data it's this
217:38 - graphic here
217:40 - and my weapon rectangle is going to be
217:43 - just a rectangle and the center of this
217:46 - rectangle is going to be in the center
217:49 - of this bg rectangle and that way our
217:52 - weapon is inside of our background
217:55 - i hope that makes
217:56 - sense so we have to figure out two
217:59 - things first of all we need the weapon
218:02 - surface and for that
218:04 - we have to look at our settings and in
218:06 - here
218:08 - we want essentially get this information
218:12 - although right now this is slightly
218:14 - difficult to get because this is a
218:16 - dictionary and we only have an index
218:21 - so instead we have to convert this
218:24 - dictionary here into a more usable list
218:28 - and that i want to do in the init method
218:31 - so
218:32 - let me add a comment here and let's say
218:35 - convert
218:37 - weapon dictionary
218:40 - and really all i want to do i want to
218:42 - have self.weapon
218:45 - weapon
218:46 - graphics
218:48 - as a list
218:49 - and i also want to spell this correctly
218:52 - and in this list i want to have all of
218:54 - the surfaces of my weapons
218:56 - so essentially what i want to do is for
218:59 - weapon
219:00 - in
219:02 - my settings i want to get the weapon
219:04 - data
219:05 - so in weapon data
219:07 - and i don't really care about the keys i
219:10 - only care about the values
219:12 - so what i essentially get now is
219:15 - another dictionary
219:17 - and inside of this dictionary i only
219:19 - really care about graphic
219:21 - so let's save this one in path
219:25 - and we get this one in weapon
219:28 - and graphic
219:30 - i think graphic or graphics just graphic
219:33 - and now what i can do is get my weapon
219:36 - and just pygame dot image dot load
219:42 - and i need my path and as always i need
219:44 - my convert alpha
219:47 - and once i have that i just want to add
219:49 - this weapon to my weapon graphics
219:52 - so append
219:54 - and my weapon
219:56 - so now i have all of my weapons in an
219:59 - accessible list
220:00 - and what i can do with that in this
220:02 - weapon surface down here in my weapon
220:04 - overlay
220:05 - i can just get self dot
220:08 - weapon graphics
220:10 - and pick the one with the weapon
220:13 - index
220:15 - and that is literally all i needed now i
220:18 - have the graphic and now i can get my
220:20 - rectangle
220:21 - and this is just going to be my weapon
220:24 - surface dot get underscore rect
220:28 - and i want to place the center
220:30 - at the center of my bg rect
220:33 - so dot center and now we should be
220:36 - having a weapon let's try and there we
220:38 - go we can indeed see a weapon and now if
220:41 - i press q
220:42 - we also get different weapons depending
220:44 - on well what we have selected
220:47 - so this is working very very well
220:49 - attacking also still works with the same
220:51 - result nice
220:53 - now there's one more change i would like
220:54 - to make and that is when we change the
220:57 - weapon
220:57 - i want the frame of this box to be
221:00 - highlighted in yellow so we get some
221:02 - indication of what we are doing
221:05 - and that's just adding some visual
221:06 - niceties to it it really isn't anything
221:09 - major and all this really means in code
221:11 - is that this border color should have a
221:14 - different color while our player is
221:16 - switching the weapon
221:17 - and we know when the player is switching
221:19 - the weapon because in my player
221:21 - i have
221:22 - can switch weapon
221:24 - and essentially if this one is false i
221:26 - want to have the border color of this
221:29 - one differently
221:30 - and well for that we have to pass a
221:32 - couple of arguments through so let's
221:34 - start with the selection box that's the
221:36 - first one down and in here i want to add
221:39 - another argument and let's call this has
221:42 - switched
221:43 - and now i can add an if statement that
221:45 - if
221:46 - s switched is true then i want to do
221:49 - something
221:50 - but if that is not the case so else
221:53 - then i want to keep on doing what we
221:54 - already have done by drawing this border
221:57 - color
221:58 - however
221:59 - if it is the case that we have switched
222:03 - i can copy this and just draw
222:05 - this frame in a different color and the
222:07 - different color we have it's ui border
222:10 - color active although this one is just
222:12 - gold i'm very lazy with colors okay now
222:16 - we have border color active cool
222:18 - so now we have to figure out how to get
222:19 - this hair switched
222:21 - inside of our weapon overlay
222:25 - so in here our selection box
222:27 - also need
222:29 - has switched
222:30 - which we can't get right now because we
222:33 - only have the weapon index
222:35 - so
222:37 - i need to give this one another
222:38 - parameter
222:40 - and i guess we can keep on calling this
222:42 - as switched
222:44 - and now finally
222:45 - when we call this method we're getting
222:48 - our
222:49 - weapon index and now we have to figure
222:51 - out an argument
222:53 - and we know it's going to come from the
222:55 - player
222:56 - but now
222:57 - in my player we have can switch weapon
223:01 - but if i just pass it in here actually
223:04 - let's try this but first of all we have
223:06 - to comment this selection box out
223:08 - otherwise we get an error
223:10 - so now if i run this
223:12 - we get
223:13 - the golden border by default and if i
223:16 - switch my weapon
223:17 - it disappears for a second so we have to
223:21 - do the exact opposite
223:23 - because by default
223:25 - this
223:25 - attribute here checks if we can switch
223:28 - the weapon
223:29 - but what we want to check in here if the
223:31 - player has switched the weapon is the
223:32 - exact opposite
223:34 - and well all we have to do is add a not
223:36 - before that and now we should be good to
223:38 - go
223:39 - so now we're checking the inverse of
223:41 - that variable and now if i press this
223:44 - we are getting the right selection so
223:48 - this is working pretty good nice
223:52 - and i guess to get the magic in there as
223:54 - well we actually have to give our
223:56 - players some magic abilities
223:58 - and i guess let's work on that and once
224:01 - we have the magic we're going to finish
224:02 - the ui
224:03 - and the magic is going to work kind of
224:06 - like the sword at least in terms of data
224:08 - and the player so we have a dictionary
224:11 - with lots of data we give our player a
224:13 - timer and the ability to switch between
224:16 - different kinds of magic
224:17 - and then once we are casting magic we
224:20 - are doing something
224:22 - although that something is going to be
224:24 - slightly more complex than just spawning
224:26 - a sprite because our magic is going to
224:28 - be a bit more complex so for now we are
224:31 - going to skip this part and we are still
224:34 - going to just print at our players doing
224:36 - something
224:37 - the reason here is that to actually make
224:39 - the magic work we need particle effects
224:42 - that we don't have yet and that are
224:44 - really really important hence we can't
224:46 - really do this but we'll come back to
224:48 - this later but for now let's do at least
224:51 - the basic magic so we can finish the ui
224:54 - and there really isn't anything new so
224:56 - let's jump straight into the code
224:59 - and here we are back in my main file and
225:02 - i want to go to settings
225:04 - i need another dictionary for my data
225:07 - and this one is for my magic and if i
225:09 - paste this we essentially have two
225:11 - spells we have flame and we have heal
225:14 - and this dictionary works very similarly
225:17 - compared to the weapon data
225:19 - and for the ui the important one we care
225:21 - about is this file here or this string
225:24 - to an image and i guess for the player
225:27 - we also have a strength and a cost but
225:29 - really nothing particularly complicated
225:32 - so now we have to figure out in my
225:34 - player how to use this
225:37 - and i guess we need a couple more
225:39 - attributes and let's put it right below
225:41 - weapon it makes the most sense there
225:44 - and first of all i need a magic
225:47 - index that by default is going to be
225:50 - zero and that is the same idea we had
225:52 - for dot weapon index so those two are
225:55 - going to be the same
225:57 - as a matter of fact we are going to copy
225:59 - quite a bit from here since our weapon
226:01 - and our magic at least in terms of data
226:03 - are very similar so the next thing i
226:06 - want to do actually i can copy this
226:07 - entire thing
226:10 - and paste it in here so now i want to
226:12 - get myself.magic so the magic i
226:14 - currently have selected and for that i
226:17 - want to get my magic data dot keys and
226:20 - self dot
226:22 - magic index so this information
226:24 - essentially gives me
226:26 - either of these two strings which is the
226:30 - key for this dictionary then besides
226:32 - that we also want can
226:35 - switch magic to select it for the ui and
226:38 - by default this should also be true and
226:40 - then we need self dot
226:43 - magic switch
226:45 - time
226:46 - and this by default is going to be none
226:48 - essentially what we have done in these
226:51 - four lines here is the same we have done
226:53 - earlier for our weapon so nothing new
226:56 - although there's one more thing that we
226:58 - do need and for our weapon we have
227:00 - self.create attack
227:02 - and we are going to need the same thing
227:05 - for our magic
227:06 - and i guess just to keep the symmetry
227:08 - let's put it right at the top so self.
227:10 - let's call it create
227:12 - magic
227:14 - and this one is going to be create magic
227:18 - and this create magic we have to get
227:20 - from our parameters so here create
227:24 - magic now in my level let me minimize
227:27 - all of the methods
227:29 - besides create attack i also want to
227:32 - define create
227:34 - magic
227:35 - and this create magic is going to need a
227:38 - few more parameters first of all i want
227:40 - the style of magic i'm using
227:42 - then i want the strength of that style
227:45 - and finally i want to have the cost of
227:47 - that style and in this method later on
227:51 - we are going to have a system to select
227:53 - different kind of magic spells but well
227:56 - that's quite a bit off for now we're
227:58 - just going to print
227:59 - this style
228:01 - we're going to print the strength and
228:03 - we're going to print the cost so at the
228:06 - very least we can tell what's going on
228:08 - and besides that what we need is when we
228:11 - create the map and we create the player
228:14 - actually let me
228:16 - add a bit of a few more lines here
228:20 - so we can actually tell what's going on
228:22 - with the player
228:23 - okay this is much easier to read
228:26 - so now finally i want to add
228:29 - create
228:31 - magic
228:34 - and as always make sure you're not
228:35 - calling this method you're just passing
228:37 - it into the player
228:40 - and all right now in our player we have
228:42 - to create magic method
228:43 - and we have all of the attributes we
228:46 - need i hope i didn't forget any so for
228:48 - the next step let me actually minimize
228:50 - all of the methods for the player so
228:52 - it's a bit easier to see now the next
228:54 - thing i want to do is in my input
228:57 - right now
228:58 - we have
229:00 - one way to cast magic
229:02 - and what we have done so far we just
229:04 - printed magic but now i want to self dot
229:09 - create magic and for that create magic i
229:12 - need my three arguments i need my style
229:14 - i need my strength and i need my cost
229:18 - and let's put those three in the
229:20 - separate lines so it's a bit easier to
229:22 - see so we need a style we need a
229:24 - strength
229:26 - and we need a cost
229:28 - and this is information we will get from
229:32 - this dictionary here and we know which
229:34 - of these to target
229:36 - by using our
229:38 - in the unit method
229:40 - by using this magic index
229:43 - and i feel like this could be a pretty
229:45 - good exercise so try to use the magic
229:47 - index
229:48 - that when we are pressing the magic
229:50 - button
229:51 - we are calling this create magic
229:54 - in the proper way
230:00 - alright let's start with the easiest one
230:02 - this style and we first want to look at
230:05 - the magic underscore data
230:09 - and what style is supposed to be
230:11 - is a string that either says flame or
230:14 - here so we need the keys of this
230:16 - dictionary
230:17 - so
230:18 - magic data dot keys
230:21 - and this i want to turn into a list
230:24 - with list so we can use indexing on it
230:27 - and once we have that all we really need
230:31 - is self dot magic index
230:35 - and then we are good to go that is
230:38 - actually all we needed so next up we
230:41 - want to do something fairly similar so
230:43 - let me copy
230:44 - all of this
230:46 - and now we want to figure out the
230:48 - strength so let's look at the dictionary
230:51 - again
230:51 - now we actually want to look at one of
230:54 - the values for these dictionaries and
230:56 - from this dictionary
230:58 - we want to get
231:00 - the one that is called strength that has
231:02 - the key strength rather
231:04 - and that is actually kind of simple as
231:07 - well so now instead of keys we are
231:10 - looking at values
231:12 - so this list here
231:14 - would be a list of all of our values and
231:16 - if we pick one we end up with one
231:18 - dictionary let's say this line here if
231:21 - it was zero would be giving us this
231:24 - dictionary
231:25 - and once we have that all we need is to
231:27 - pick one element from this dictionary
231:31 - and i want the key
231:32 - strength
231:34 - is what i called it i think yes strength
231:37 - and now for the cost all we have to do
231:40 - is copy
231:41 - this thing
231:42 - and now instead of strength we are
231:44 - looking at cost
231:46 - and i guess just to check if this is
231:49 - even working let's try this in our game
231:51 - so let's run my game and let's press
231:54 - ctrl and we get flame 5 and 20.
231:59 - so this is actually working nice
232:02 - although there's one change i would like
232:04 - to make that right now my strength is
232:08 - just from the settings
232:10 - this strength here but essentially what
232:12 - i want to do is to give my player
232:15 - also a magic ability actually my player
232:17 - already has that this magic here that's
232:20 - basically the in build magic power of
232:22 - the player and we're gonna add this to
232:25 - the magic damage
232:27 - so
232:28 - for the strength
232:29 - i want to get the strength of the spell
232:32 - plus
232:33 - myself dot stats
232:35 - and i call this one magic
232:38 - i think
232:39 - yeah magic so this self dot stats magic
232:41 - here
232:42 - so that way we can level up our spells
232:44 - and we make them stronger so let's try
232:47 - this again and now we get five plus four
232:50 - is nine so this is working really well
232:53 - so with that
232:54 - we can call our magic
232:58 - and next up we have to be able to switch
233:00 - between different kinds of magic and
233:02 - that's going to look very similar
233:03 - compared to this weapon switching
233:05 - mechanic
233:06 - so i suppose what we can do
233:08 - is just copy the entire thing and then
233:12 - let's work from there
233:13 - first of all on the first line
233:16 - instead of q i want to look at e
233:20 - and then can't switch weapon
233:22 - should be
233:23 - can switch
233:25 - magic
233:26 - now the next line can't switch weapon is
233:29 - false should be can switch magic
233:32 - and for the time
233:34 - it should not be weapon switch time it
233:36 - should be magic switch time
233:39 - then next up
233:41 - we don't want our weapon index in any of
233:44 - these
233:46 - so this should be magic
233:48 - and then the list we are looking at
233:49 - shouldn't be weapon it should be magic
233:52 - but everything else is still the same
233:54 - this weapon should also be magic
233:57 - and then finally self dot
234:00 - magic
234:01 - should be our list with not weapon data
234:05 - or the weapon index it should instead be
234:08 - our magic index
234:10 - and now
234:12 - this should technically be working so
234:14 - let's try this in the game
234:16 - so now i press ctrl we get flame 9 and
234:19 - 20. now if i press e
234:22 - now we get here 24 and 10. if i press e
234:25 - again we should go back to flame
234:27 - and we are not it sticks to heal
234:32 - so let's have a look
234:35 - here we have our entire if statement and
234:39 - i think i just figured out what the
234:40 - problem is
234:42 - that for our weapon
234:44 - we have a timer that reactivates the
234:46 - weapon whereas for the magic
234:49 - we don't have a timer so once can switch
234:52 - magic goes to false it never turns on
234:54 - again
234:55 - we can actually test this
234:57 - so at the end of this if statement i
234:59 - want to print
235:01 - magic
235:03 - and now if i call this we get flame if i
235:06 - press e we get magic but if i press e
235:08 - again
235:10 - i don't see anything so we only ever
235:12 - update
235:14 - or we only ever call
235:16 - this one here once
235:18 - and the reason we can only call it once
235:21 - is because further down in our cooldowns
235:24 - there's no cooldown for the magic
235:26 - but we can create one quite easily by
235:28 - just copying the weapon switch mechanic
235:33 - so if can switch
235:36 - magic
235:37 - i want to get my current time
235:39 - then my magic switch time is what i
235:42 - called it
235:43 - and if that is greater than my switch
235:45 - duration cooldown that's the one that
235:47 - can stay constant or well the one that
235:50 - doesn't change between the weapon and
235:51 - the magic
235:52 - and if that is the case
235:54 - mike can switch magic should be true
235:58 - so now we have the cooldown now let's
236:00 - try this again
236:01 - so
236:02 - i get my flame 9 and 20 i press e
236:05 - we get heal i press e again
236:08 - now we're back to flame
236:09 - and i can keep on pressing this it
236:11 - always works
236:12 - nice
236:14 - and with that we have our basic magic
236:18 - obviously it doesn't do anything right
236:19 - now but that will come later
236:22 - i guess what we can do now is work on
236:24 - the ui to display the magic
236:27 - and this is going to work in essentially
236:29 - the same way that we have done for the
236:31 - weapon overlay
236:33 - so let's actually implement it straight
236:34 - away although if you want to do this as
236:36 - an exercise i would recommend you to try
236:39 - this out
236:40 - in my case let's call this one magic
236:43 - overlay
236:45 - and here we need self
236:47 - we need the magic index
236:50 - and we again need has
236:52 - switched
236:54 - and if that is the case actually let me
236:56 - copy all of this again
236:57 - since it's going to look fairly similar
237:00 - so magic overlay
237:02 - might be direct is now going to have
237:06 - these two numbers
237:08 - so these two numbers
237:11 - and i actually also want to call self
237:13 - dot
237:15 - magic
237:16 - overlay
237:18 - with my player dot
237:21 - magic index
237:23 - and then not player can
237:27 - switch
237:28 - magic i believe i called it
237:30 - so those two methods are basically
237:33 - identical except we're using different
237:34 - data
237:38 - and the bg-rack still works but now we
237:40 - need a
237:42 - magic surface
237:45 - and a magic rectangle
237:47 - and for the magic surface we need our
237:51 - magic graphics
237:54 - and our magic index oh and i just
237:56 - realized we don't have our magic
237:58 - graphics yet
237:59 - let me cover this one in just a second
238:01 - first of all for magic rectangle
238:04 - i want to get my magic surface
238:07 - and the rest can stay the same
238:09 - and now
238:11 - i want to replace weapon with magic
238:14 - okay we are nearly done the one thing i
238:17 - did forget
238:19 - is that
238:21 - in the init method
238:23 - we also have to get
238:25 - the convert magic
238:28 - dictionary so kind of the same thing we
238:31 - have done for the weapons that we create
238:33 - a list with all of the surfaces
238:36 - and i want to do pretty much the same so
238:38 - self dot
238:39 - magic
238:41 - graphics
238:43 - by default it's an empty list and now
238:45 - for magic in
238:48 - magic underscore data
238:50 - dot values
238:52 - i guess for this one we can go straight
238:54 - to the magic surface
238:56 - and i want to get pygame dot image dot
238:59 - load
239:00 - and the path is going to be
239:03 - magic
239:05 - and
239:06 - graphic
239:07 - and as always for this one we also need
239:10 - convert
239:11 - alpha
239:12 - and then self dot magic graphics dot
239:16 - append
239:18 - magic
239:21 - i guess if you were to do all of this by
239:23 - yourself i would recommend to combine
239:25 - these two imports into one function so
239:28 - you can reuse them it's a bit more
239:29 - elegant
239:31 - and i guess you could also combine
239:33 - these two
239:34 - functions here in a bit more detail but
239:37 - i guess there are so few lines in my
239:38 - case i don't really mind that much but
239:40 - alright now we have our import graphics
239:44 - and this magic overlay also works
239:47 - and i think we're done let's try
239:50 - so i can see my magic and i can see my
239:53 - weapon if i change my weapon it still
239:55 - works if i change my magic it also works
239:58 - cool so now i can change between my
240:01 - different
240:03 - magic and weapons
240:06 - and we can still use them in the game as
240:08 - well so this is working really well
240:11 - so with that we have the ui all covered
240:15 - next up i guess we can actually start
240:17 - adding some enemies to make the game a
240:19 - bit more interactive
240:21 - and the enemies have to be able to do
240:23 - quite a bit because they are nearly as
240:25 - complex as the player
240:27 - so there are a couple of things that we
240:30 - have to implement here
240:32 - and there's one more thing i would also
240:34 - like to cover that since our player and
240:36 - our monsters are fairly similar they can
240:39 - share a couple of methods with each
240:41 - other
240:42 - in my case the methods they do share is
240:44 - the move and the collision method
240:47 - they essentially move in the same way
240:50 - the only difference is that our player
240:52 - gets the direction from the input
240:54 - whereas the enemies get the direction
240:55 - from what the player is doing so if the
240:58 - player is very close to them they're
240:59 - moving towards the player and if the
241:02 - player is further away they don't move
241:03 - at all
241:05 - but once we do have a direction they are
241:07 - basically going to work in the same way
241:10 - so what we have to do for now first of
241:12 - all we have to import a bunch of data
241:13 - for the enemies to actually display the
241:15 - very basics of them
241:17 - then we have to split some methods from
241:20 - our player and create a new class called
241:22 - entity and then both our player and our
241:25 - enemies are going to inherit from that
241:27 - class
241:28 - and once we have all of that we can
241:29 - actually start implementing some enemy
241:31 - functionality
241:33 - so i guess let's jump straight into the
241:35 - code and let's have a look at this
241:37 - so here i'm back in my code and first of
241:40 - all i need some data and all of that is
241:43 - in the settings
241:45 - and in here i want to add yet another
241:47 - section that i called enemy
241:50 - and in there i want to import another
241:53 - dictionary that looks like this
241:56 - so in here we have our enemies for
241:58 - example we have let's say the raccoon
242:01 - we have a health experience damage their
242:04 - attack type and their attack sound and
242:07 - then at the end we get quite a few more
242:10 - like speed resistance attack radius and
242:13 - notice radius
242:14 - and all of these things are going to
242:16 - determine how they are going to operate
242:19 - but that is literally it besides that
242:21 - the classes are going to be identical
242:24 - and i guess really quick to go through
242:26 - what each of these pairs do
242:29 - health should be fairly obvious it's how
242:31 - healthy they are experience is how much
242:33 - experience they give and damage is well
242:36 - how much damage they do to the player
242:38 - attack type is purely for the particle
242:41 - effects so when the enemy is attacking
242:44 - the player this is going to be
242:46 - what will be displayed on the window
242:49 - and besides that at the end
242:51 - speed should be fairly obvious
242:53 - resistance basically means if the player
242:56 - is hitting the enemies so let's say this
242:58 - is our player and this is our enemy and
243:01 - if the player hits
243:04 - the enemy
243:05 - then our enemy is supposed to go a
243:07 - little bit
243:08 - backwards and the distance by how much
243:11 - the enemy is being pushed back that's
243:13 - the resistance
243:14 - then we have attack radios and notice
243:17 - radius and essentially what they mean
243:20 - let's say that this here is our enemy
243:24 - and the enemy has two radiuses the first
243:27 - one is the attack radius and let's say
243:29 - this one is going to look something like
243:30 - this it is literally a radius around the
243:32 - enemy
243:33 - and if the player is inside of this
243:36 - radius
243:37 - let's say right now our player is here
243:40 - if that is the case then the enemy is
243:42 - supposed to attack
243:44 - the player
243:46 - and that is the attack radius and you
243:48 - see it's 80 and 120 or very small
243:51 - numbers they basically mean if the enemy
243:54 - and the player are very close to each
243:55 - other then the enemy should attack
243:58 - now besides that we have our notice
244:00 - radius and the notice radius is
244:03 - substantially larger it essentially is
244:05 - something like this let me draw it out
244:10 - and if our player is inside of this
244:13 - radius
244:14 - then the enemy should only
244:18 - move towards it but it should not attack
244:21 - so that way once our enemy is close
244:24 - enough to the player it starts moving
244:25 - towards the player and then once the
244:27 - enemy is close enough to the player so
244:29 - the players inside of the attack radius
244:31 - then the enemy is going to attack
244:33 - and if the player is outside of that so
244:36 - here
244:36 - then the enemy isn't going to do
244:38 - anything
244:39 - so i hope that makes sense
244:41 - and all right with that we have the data
244:44 - for our enemy they do get fairly
244:46 - substantial
244:48 - now next up in my player let me minimize
244:52 - all the different methods
244:54 - so it's a bit easier to see
244:57 - now right now the move and the collision
244:58 - method we want to reuse for the enemies
245:02 - as well
245:03 - so what we could do is make the enemies
245:05 - inherit from the player but that feels
245:08 - kind of weird so instead i'm going to
245:11 - take these two methods out and put them
245:13 - in a separate class
245:15 - and let me for that create a new file
245:18 - and let's call this one entity dot pi
245:22 - and in here we have to import pi game
245:25 - and then i want to create a class that i
245:28 - called entity it has to inherit from
245:31 - pygame.sprite.sprite
245:35 - and once we have that i want to give
245:37 - this thing a done there init method in
245:40 - itself and groups
245:43 - and then in the super
245:45 - dot
245:46 - init method we're going to pass in the
245:49 - groups
245:51 - now once we have that
245:54 - we can from the player
245:56 - get this move and this collision method
245:59 - so let me just copy them
246:02 - paste them in here
246:03 - and now our entity has these two methods
246:07 - so what we can do now in the player i
246:09 - can literally just delete both of these
246:12 - methods
246:14 - and now the player isn't supposed to
246:15 - inherit from sprite anymore instead we
246:17 - want to inherit from entity
246:20 - and for that to work we have to from
246:23 - entity
246:24 - import entity
246:27 - and now technically nothing should
246:30 - change
246:31 - and this is still looking
246:34 - very good cool we can still
246:37 - do all the stuff yep that looks very
246:40 - good
246:40 - this is then what we can use for the
246:42 - enemies as well it's going to make our
246:44 - life a bit easier
246:45 - and on top of that we can actually add a
246:48 - few more things in here so we could for
246:50 - example add the self dot frame
246:54 - index
246:55 - with a start of zero
246:57 - self.animation
246:59 - speed could also be in here so 0.15
247:03 - and
247:04 - self.direction
247:06 - is going to be pygame.math.vector2.
247:10 - these basic attributes are going to be
247:11 - shared across our player and our enemies
247:14 - anyway so having them in here seems to
247:16 - make a bit more sense so now in my
247:19 - player
247:20 - i can get rid of frame index and
247:23 - animation speed
247:25 - and from direction
247:28 - and just to make sure things are still
247:30 - working let's try
247:33 - and
247:34 - seems to be all good and working
247:38 - so with that we have a basic setup for
247:42 - our enemies
247:44 - and with that we can start creating the
247:46 - actual enemy class but first of all let
247:48 - me clean this up a bit so we don't need
247:50 - our ui anymore and we also don't need
247:53 - the weapons and if i close them we have
247:55 - a bit more space
247:57 - and now let me create a new file and i'm
248:00 - going to save this one as enemy dot pi
248:04 - and in here as always we have to import
248:07 - pi
248:08 - game
248:09 - then from settings import everything
248:14 - and
248:16 - don't forget from entity import entity
248:20 - and now we can create our class
248:23 - and me
248:25 - and this one is supposed to inherit from
248:27 - entity
248:28 - and that way we already have all of this
248:31 - available so we don't have to rewrite it
248:33 - but we are still going to need an
248:36 - init method
248:38 - needs self first of all
248:40 - then i do want a couple of different
248:43 - things
248:44 - first of all i want something like a
248:46 - monster
248:48 - name
248:48 - and this monster name is going to be
248:50 - used in a bit
248:52 - to pick either squid raccoon spirit or
248:54 - bamboo so we get different monsters
248:57 - then besides that i also need a position
248:59 - so i know where to place it at the
249:01 - beginning of the game
249:03 - and don't forget we also need the groups
249:05 - now besides that let's start with a
249:07 - general
249:09 - setup
249:10 - and in here the first thing we always
249:12 - need is the super done the ended method
249:15 - and in here we have to pass in our
249:17 - groups
249:18 - and there's one more thing that i would
249:19 - like to add that is self.sprite
249:22 - underscore type
249:24 - and in this case it's just going to be
249:26 - enemy and this sprite type let me open
249:30 - my tile again it was in here so this is
249:34 - our tile class for all the inanimate
249:36 - objects this one also has a sprite type
249:39 - although this one is a tiny bit more
249:41 - flexible because we have different types
249:43 - of tiles
249:44 - but for our enemy we are always going to
249:47 - have our enemy
249:48 - and the reason here is that these are
249:50 - supposed to react differently that if
249:52 - our player attacks an enemy for example
249:55 - then we want to reduce the health or
249:57 - kill the enemy if the health goes below
249:59 - zero
250:00 - however if our player attacks a tile
250:03 - that is a grass for example
250:05 - then we want to destroy the grass
250:06 - immediately the grass doesn't even have
250:09 - any kind of health
250:10 - and then if we have something like a
250:12 - tree or a statue they are not supposed
250:14 - to react to the player whatsoever and
250:17 - for that reason we need different kinds
250:19 - of sprites
250:20 - and i guess you could organize this with
250:22 - different groups as well but i feel like
250:24 - using this system is a little bit more
250:26 - straightforward but there are different
250:28 - solutions to this all right
250:30 - now we have our spread type
250:33 - now next up we have to work on the
250:36 - graphics setup and i guess for now
250:40 - let's just place the enemies on the map
250:42 - and then improve them continuously so
250:44 - what i want to do for now is create a
250:46 - self.image and a self.wrecked and that
250:49 - way we can just place them on the map
250:51 - and then improve on them and for now for
250:54 - the image i just want pygame dot surface
250:58 - let's say 64 and 64. we're going to
251:00 - change that anyway
251:02 - and self.image
251:05 - dot get
251:06 - rekt and the top left should be the
251:09 - position
251:10 - and with that we have our enemies now if
251:14 - you remember all the way back in our
251:15 - level
251:16 - we made this thing here
251:19 - and we are still going to use it to
251:21 - place the enemies
251:24 - and for that we first have to import the
251:26 - csv file
251:29 - which fortunately is very easy
251:32 - so in here i want to create my entities
251:35 - and this is going to be both my enemies
251:37 - and my player
251:39 - and we again want import csv layout
251:43 - and in there we have one more string
251:46 - that we didn't import so far
251:48 - and let me just copy it in here it looks
251:51 - like this
251:54 - it's in the same folder as all of the
251:56 - other csv files we just didn't import it
251:59 - earlier because we didn't need it but we
252:00 - always had it
252:02 - and all right so now
252:04 - this for loop is going to get another
252:07 - csv layout
252:09 - so
252:10 - what we can do
252:12 - is add another if statement in here
252:16 - so if the style
252:18 - is equal to entities
252:22 - and there are a few different kinds of
252:23 - enemies we have to be aware of so this
252:25 - if statement will get more complex but
252:28 - for now we only really have two
252:29 - different kinds of tiles we either have
252:32 - the player that one's actually right
252:34 - here
252:35 - and then we have our basic enemy class
252:37 - that for now is just black image
252:40 - and how this is going to work is if the
252:43 - column is a certain number
252:46 - for example the player in this list is
252:48 - number 394
252:52 - and if that is the case i want to create
252:54 - my player
252:56 - in that if statement
252:59 - and let me just indent things properly
253:01 - so it's a bit easier to see
253:03 - uh this player also works yes
253:06 - okay
253:06 - now i think you might be confused where
253:08 - do we get this 394 from and the best way
253:13 - to see this is if i just open tiled
253:15 - you're going to see it in a second
253:17 - alrighty here we are entitled and
253:22 - this is our entire map and we got this
253:24 - map from this tile set here and let me
253:27 - open the tile set by itself
253:30 - and here we have the tile map and if i
253:33 - just click on the random tile let's say
253:35 - this one here let me add an arrow to
253:38 - make this a bit more visible so this
253:40 - tile here
253:42 - has an id of 252
253:45 - and if we export this tire set that is
253:47 - the number we get
253:50 - and now if we click for example on the
253:52 - player
253:53 - it says
253:55 - 394
253:56 - exactly the number i used to import the
253:58 - player
254:00 - and if you clicked on different kinds of
254:01 - enemies
254:02 - we get 390 91 92 and 93.
254:07 - so basically where this number comes
254:08 - from is on this tile set tiled orders
254:11 - each tile from 0 all the way to the end
254:14 - so we have 0 1 2 3 4 5 6 and so on
254:19 - so if you ever have to double check the
254:21 - numbers that's where they are coming
254:22 - from
254:24 - so now
254:25 - we are importing our player and later on
254:28 - we are going to have more if statements
254:29 - with the different numbers for the
254:31 - enemies as well
254:32 - but now
254:34 - we can also update the position of our
254:36 - player
254:38 - it should not be this random position i
254:39 - gave it it should instead be x and y
254:44 - and those are the numbers we created
254:47 - ages ago all the way up here
254:50 - so we're just reusing those
254:53 - and i guess for now let's just see if
254:56 - this is working in the first place and
254:58 - there we go
254:59 - now our player is starting in a slightly
255:01 - different position but besides that
255:03 - nothing has changed
255:04 - but at the very least we know it is
255:06 - working
255:07 - so now back in my level
255:09 - i can for now just add an else statement
255:14 - and what i want to create in here is an
255:18 - enemy although for that to work i have
255:20 - to import the enemy class
255:23 - so chrome enemy
255:26 - import and me
255:29 - and now we can use it in here
255:32 - and i guess let me copy
255:35 - the parameters
255:37 - and paste them in here so it's a bit
255:39 - easier to work with
255:41 - now for the monster name
255:43 - let's say for now we can just say
255:46 - monster doesn't really matter
255:48 - for the position
255:49 - we keep on using x and y
255:53 - and for the groups
255:55 - let me copy it from the player so we
255:57 - definitely want the enemies to be in the
255:59 - visible sprites
256:01 - but besides that since the player isn't
256:03 - supposed to be able to collide with the
256:04 - enemies that's all we need for now
256:07 - so now we technically should be having
256:10 - all we need to create some basic sprites
256:13 - and there we go this is actually working
256:15 - well i guess kind of
256:17 - at the very least we can't see where the
256:19 - enemies are supposed to be
256:21 - so that's at the very least a start
256:25 - so i guess now we can just flesh out our
256:28 - enemy class and add more and more to
256:31 - this to make it actually work
256:34 - and i guess the first thing we can start
256:36 - with is the graphics setup so we can
256:39 - actually see what's going on
256:41 - and to get our graphics i want to import
256:43 - something and this i would like to keep
256:45 - in its own method so let's call this
256:48 - import graphics
256:51 - and since we have different kinds of
256:52 - data so in my settings i for example
256:55 - want to import all the data for this
256:57 - squid
256:58 - for that i will need the monster name
257:01 - and this i'm going to add in the import
257:03 - graphics so in here we are going to add
257:06 - monster name
257:08 - and i guess let's create that one
257:11 - so
257:12 - import graphics self and let's just call
257:15 - it name
257:17 - and this import graphic is going to be
257:20 - kind of similar compared to what we have
257:22 - done for the player so if i go back
257:24 - and here we have import player assets
257:27 - we had a character path and then we had
257:30 - different kinds of animation states in a
257:32 - dictionary and i want to do something
257:34 - similar for the enemies
257:36 - so the first thing i want to do
257:39 - let's call it self dot animations
257:43 - and this is going to be a dictionary
257:44 - with only three different value pairs
257:47 - we have idle
257:49 - then we have
257:51 - move
257:52 - and finally we have
257:55 - attack
257:56 - and these three states correspond to
257:58 - what the enemy is supposed to do so if
258:01 - the player is really far away it's
258:02 - supposed to idle if the player is kind
258:05 - of close it's supposed to move and then
258:07 - move towards the player and play the
258:08 - move animation
258:10 - and then if it's close enough it's
258:12 - supposed to attack
258:13 - and if you look at the folders there is
258:15 - a folder for each enemy that corresponds
258:17 - to this name so for example the squid
258:20 - has one folder for idle one for move and
258:22 - one for attack
258:24 - and this is going to work exactly like
258:26 - we have done for the player
258:28 - so what we can do
258:30 - we can create a main path
258:34 - and this is going to be an f string and
258:36 - in here i want to go up a folder i want
258:40 - to go to graphics
258:41 - then i want to go to monsters i called
258:44 - it
258:45 - and now we want to go to the specific
258:47 - subfolder for our enemy and this is
258:50 - going to be the name
258:52 - and now don't forget we want to go into
258:54 - different subfolders so we need one more
258:56 - forward slash
258:58 - so this path is going to lead us to each
259:00 - individual enemy and let's call it main
259:03 - path
259:04 - and now all i have to do is for
259:06 - animation in self dot animations dot
259:10 - keys
259:11 - and in here self dot animation
259:15 - and
259:17 - animation sorry this should be
259:19 - animations so essentially we want to get
259:22 - this dictionary and go for every single
259:24 - key of this dictionary so right now we
259:27 - want to get the idle and for this idol i
259:31 - want to import a couple of graphics
259:34 - and what is
259:36 - i need again my import folder function
259:39 - so from support
259:41 - import let's just say star
259:44 - so now
259:46 - i want my import folder the one we
259:48 - created earlier
259:50 - and then here
259:51 - i just want to create my main path
259:55 - plus the
259:57 - animation
259:59 - so just to explain what's happening here
260:01 - this main path
260:03 - is what we have created
260:05 - up here
260:08 - and then the animation is what we get
260:10 - from the for loop and this for loop
260:12 - could for example be idle move or attack
260:16 - and we are just combining them and that
260:18 - way we get a whole path to a specific
260:21 - folder
260:22 - and then we're using the import folder
260:25 - function to import every single image
260:27 - inside of that folder and turn it into a
260:30 - surface
260:31 - and that way we can use them in our
260:33 - dictionary
260:34 - so with that we have our import graphics
260:37 - now next up in my init method i want to
260:40 - set self.status
260:42 - and for now this is going to be idle but
260:45 - later on we are going to work with this
260:48 - to make a change depending on how far
260:50 - away the player is so this could be any
260:52 - value inside of this dictionary could be
260:54 - idle move or attack
260:57 - and depending on the status the enemy is
260:59 - then going to do different actions
261:02 - so now we have a dictionary and we have
261:04 - a status
261:05 - pretty much the same thing we had for
261:07 - the player
261:09 - and with that we can actually start
261:11 - setting the image and i think this could
261:14 - be a good exercise to see if you're
261:15 - still paying attention the video is
261:17 - getting quite long
261:18 - so try to use the imported graphics so
261:21 - self-dot animations and the status to
261:24 - pick out one image for each monster
261:32 - i want first of all to get
261:34 - myself.animations
261:36 - so i want to get
261:38 - this dictionary here
261:41 - and from the dictionary
261:42 - i want to pick one of the animations
261:45 - depending on what my status is and right
261:47 - now my status is idle
261:49 - so i want
261:51 - self.status i guess could be anything
261:53 - but right now it is idle
261:56 - so this would give me a list but image
261:58 - wants a surface so from this
262:01 - i have to get self dot
262:04 - frame
262:07 - index
262:08 - and you might be asking yourself
262:11 - where do we get this frame index from do
262:13 - we have to create it in this class
262:15 - and the answer actually is no because in
262:17 - our entity
262:18 - we have the frame index and this frame
262:21 - index already works in the player
262:23 - so in this player we have no frame index
262:26 - but the animations still work just fine
262:29 - somewhere down here
262:31 - so frame index
262:33 - comes from the entity
262:35 - and we don't have to declare it
262:38 - so we don't have to worry about it but
262:40 - there is one thing we do have to worry
262:42 - about and that is the different kind of
262:44 - monsters so in my level we always call
262:48 - it a monster but that wouldn't be
262:50 - accurate because in my settings i have
262:53 - squid raccoon spirit and bamboo and for
262:56 - now let's just use this squid those i
262:59 - think look the best
263:02 - and now this would actually work with
263:04 - the import and now let's try this
263:07 - and there we go we can see some enemies
263:09 - they don't do anything right now and
263:10 - they're all the same but at the very
263:12 - least it is working also we can't detect
263:16 - them but that comes later
263:18 - so for now we have some enemies
263:21 - now obviously we have different kinds of
263:23 - enemies and that's something we have to
263:24 - work on now
263:27 - and essentially what i want to do
263:29 - i want to create a monster name variable
263:32 - and now i want to create some if
263:34 - statements to check what kind of name we
263:36 - are going to get
263:38 - and this could for example look like
263:40 - if the column is going to be 390
263:45 - then my monster name
263:47 - is supposed to be
263:50 - bamboo
263:51 - then l if if my column name is equal to
263:57 - 391
263:59 - then my monster name
264:02 - is supposed to be
264:04 - spirit that's not how you spell that
264:10 - now next up if that is not the case and
264:13 - my column is
264:16 - 392 i am really bad at typing today
264:20 - if that is the case my monster name
264:23 - should be
264:25 - raccoon
264:26 - and if neither of these is the case so
264:28 - else
264:29 - then my monster name
264:32 - should be squid
264:35 - and let me indent them all properly
264:37 - python tends to be a bit annoying if you
264:39 - use if statements on the same line oh
264:41 - well sublime is a bit weird
264:43 - but with these couple of lines we now
264:45 - select the right kind of monster for the
264:47 - specific monster name
264:50 - and now let's try this again and we are
264:53 - getting an error that we have list index
264:56 - out of range
264:57 - and the error here let me close it all
265:00 - is simply that when python looks at this
265:02 - file here for the raccoon i misspelled
265:05 - it it should be spelled with a double c
265:09 - and because of that misspelling when we
265:12 - imported the folder python couldn't find
265:14 - it and try to loop over it and well that
265:17 - didn't work but now let's try this
265:20 - and now we can see different enemies
265:24 - so in here all of this is working really
265:26 - nicely
265:29 - so this is then giving us a ton of
265:31 - different kinds of enemies that we would
265:33 - like to have
265:36 - and i guess there's one small downside
265:38 - here let me actually open it again so
265:41 - our enemies have very different sizes
265:43 - these bamboo ones are 64 by 64. same for
265:46 - the squid and same for these little
265:49 - flames but the big raccoons are quite a
265:52 - bit larger
265:54 - and you could give the larger ones an
265:55 - offset but in my case i'm not going to
265:58 - worry because they're basically in the
265:59 - right spot but that's something you
266:01 - could work on but it doesn't really
266:03 - matter that much alright now we can
266:05 - place our different kinds of enemies and
266:07 - we can actually see them in the game
266:10 - i guess now we can start working on
266:12 - their movement and let me add
266:15 - a separate section to it and let's call
266:16 - it movement and then here we already
266:19 - have the rectangle
266:22 - and besides that i also want to give
266:23 - them self.hit
266:26 - box
266:27 - and this is going to be self.rect
266:33 - and let's go with
266:35 - 0 and negative 10.
266:37 - and this hitbox we are definitely going
266:40 - to need because in our entity
266:43 - we are moving the hitbox not the
266:45 - rectangle so our enemies are going to
266:47 - need a hitbox
266:49 - and besides that we are also going to
266:52 - need self dot obstacle
266:55 - sprites
266:56 - and that's just going to be obstacle
266:59 - sprites
267:01 - and again this is going to work just
267:03 - like we have done for the player
267:05 - so in our entity
267:07 - we are looking through self. obstacle
267:09 - sprites so our enemy has to have this
267:12 - attribute as well
267:14 - and well this one we are going to get
267:16 - from the parameters
267:18 - so this is obstacle sprites and then on
267:20 - our level
267:23 - for the argument just like the player we
267:25 - need
267:27 - obstacle sprites
267:29 - and that way our enemies also get
267:31 - collision mechanics with the rest of the
267:32 - level
267:33 - it would look very silly if they didn't
267:35 - have that
267:37 - so now they have the ability to move but
267:39 - they well don't move at all right now so
267:42 - that's something we do have to work on
267:45 - and to make them work we first of all
267:47 - need an update method
267:50 - and this one itself and nothing else
267:52 - it's the usual sprite update method
267:56 - and in here i want to add self.move
267:59 - and now this move method will need some
268:01 - kind of speed and i want to pass in
268:04 - self.speed in here
268:06 - and to get that kind of speed in the
268:08 - init method
268:10 - i want to give the enemy some stats
268:13 - and actually while we're here we can add
268:16 - a couple of different stats
268:18 - and let me just copy them it is quite a
268:20 - few so this is going to look like this
268:25 - so we get the monster name and that's
268:28 - just going to be the monster name
268:30 - then we get some monster info and that
268:32 - is then going to give us the health the
268:34 - experience the speed the attack damage
268:36 - resistance attack radius notice radius
268:38 - and attack type so all of this is
268:40 - basically
268:41 - this dictionary here
268:43 - just now converted into attributes
268:46 - and that way we can use them
268:47 - significantly easier and in here we have
268:51 - our speed
268:53 - so now they could be moving
268:56 - and although if i run the game
268:59 - they are not going to move for the
269:02 - simple reason that they don't have any
269:04 - kind of direction or well they do have a
269:06 - direction but each of their direction is
269:08 - zero and zero so i guess you could say
269:11 - they're all moving except they're moving
269:13 - in the same place so well kind of
269:15 - pointless
269:16 - and that means we have to give them
269:18 - another method to check where the player
269:21 - is
269:22 - and this is done
269:25 - in another method
269:26 - that i called get
269:29 - status
269:30 - and this one itself and we have to know
269:33 - where our player is
269:35 - and all we really want to do in here is
269:38 - we want to get the distance to the
269:39 - player
269:41 - so in here let's just add a question
269:42 - mark for now
269:45 - because this one gets a bit more complex
269:47 - but let's just imagine for now that we
269:49 - have the distance
269:51 - all i really want to do is if the
269:53 - distance is smaller or equal
269:56 - than our self dot
269:58 - attack radius
270:00 - then i want to set self.status
270:04 - to
270:05 - attack
270:07 - then l if if my distance
270:10 - is small or equal to self dot notice
270:14 - radius then self.status
270:18 - to move
270:19 - and if neither of these is the case
270:22 - then
270:23 - self.status
270:25 - should just be
270:26 - idle
270:28 - so really all we're doing in here is
270:33 - here we have our enemy so this is our
270:36 - enemy
270:38 - then we have one radius around it
270:41 - and we have a larger radius around it
270:44 - and if our player is inside of the
270:47 - yellow circle
270:49 - then we want to attack
270:50 - and if the enemy is inside of the blue
270:52 - circle
270:54 - then the enemy is supposed to move
270:55 - towards the player and if the player is
270:58 - outside of that
270:59 - then the enemy is just supposed to idle
271:01 - and not do anything
271:03 - and that's really all we need we have to
271:06 - make some more refinements in here later
271:08 - on but for now this is good to go so now
271:10 - we have to figure out what's the
271:11 - distance to the player
271:13 - and in here i want to create an extra
271:16 - method
271:17 - because we essentially need two bits of
271:19 - information let me actually draw them
271:23 - actually let me just redo the entire
271:25 - circle i've just done
271:27 - and let's say our player is here right
271:30 - now
271:31 - and i want the enemy to move towards the
271:34 - player now for that to happen i need two
271:37 - bits of information
271:39 - first of all i need the distance so how
271:41 - far the player is from the enemy
271:45 - but to move the enemy towards the player
271:47 - i will also need the direction so i need
271:50 - to know what angle this arrow is going
271:53 - to be so that i can move the enemy in
271:55 - this direction but once i have this
271:57 - direction i can just move it with my
271:59 - speed and then use the move method and
272:01 - then my enemy would be moving
272:04 - basically what all of this means i want
272:06 - to create a method
272:08 - it's called define
272:10 - that is going to get player
272:13 - distance and
272:15 - direction
272:16 - and this one itself and the player again
272:19 - and what this method at the end of the
272:21 - day is really all supposed to do
272:23 - is to return a distance and a direction
272:27 - direction
272:29 - so now we have to get both of these
272:31 - things
272:32 - and this might be a good exercise to
272:35 - check your vector math so try to figure
272:38 - out the distance and the direction
272:39 - between the player and the enemy
272:42 - although don't worry if you can't do it
272:43 - yourself
272:49 - all right let's do some vector math
272:51 - first of all i want to get some vectors
272:53 - let's call it my enemy vector
272:56 - and my player
272:58 - vector
272:59 - and essentially all that means is i want
273:01 - to use pygame.math.vector2
273:05 - and pass in self.rect.center
273:10 - so that way we are converting the center
273:12 - of our enemy into a vector and that
273:15 - makes it much easier to work with
273:17 - and i want to do the same thing for my
273:18 - player so pygame.math.vector2
273:23 - and then player.center
273:26 - so now i have two vectors and that's
273:29 - going to make my math significantly
273:31 - easier
273:32 - and that's already bring us to the first
273:35 - variable we want to get the distance
273:38 - and really all we want to get is the
273:41 - distance between these two vectors and
273:44 - the first thing we have to do for that
273:46 - is get our player vector and subtract
273:50 - the enemy vector from that so this is
273:53 - going to give us another vector
273:56 - that shows us the relation between these
273:57 - two vectors but importantly this is not
274:00 - a distance right now it's just another
274:02 - vector
274:03 - and let me illustrate this this can be a
274:05 - bit confusing so right now
274:08 - this is our entire game window
274:10 - and let's say our player is here and our
274:13 - enemy
274:14 - is here
274:16 - and each of those have their own
274:17 - separate vector
274:19 - and remember a vector is essentially an
274:21 - arrow so the vector looks like this for
274:24 - the player and like this for the enemy
274:28 - so we're going in x and the y direction
274:30 - to get to our player or our enemy
274:33 - and when we subtract these two vectors
274:34 - from each other we are getting this
274:37 - vector
274:38 - here and let's say just for some numbers
274:42 - this could potentially be something like
274:44 - for the x it's going to be positive
274:46 - so x could be let's say 100
274:50 - and for y
274:52 - possibly a bit less let's say
274:55 - 80. so this would be the vector that
274:57 - shows us the distance between our player
275:00 - and our enemy oh well not the distance
275:02 - just the arrow to get from the player to
275:04 - the enemy but importantly this is not a
275:07 - distance we couldn't really use this by
275:09 - default to understand how far away the
275:11 - enemy is
275:13 - but this we can change quite easily all
275:15 - we need
275:16 - is dot magnitude
275:21 - and this is converting a vector into a
275:23 - distance and this we can actually use
275:26 - so with that we already have our
275:28 - distance
275:30 - and i guess with that we can also work
275:32 - on the direction and this one isn't all
275:34 - that much more difficult it's actually
275:36 - very similar so we again want to get my
275:40 - player vector
275:42 - and subtract my
275:43 - enemy vector from that so again now we
275:46 - have our vector
275:48 - let me actually again bring it up again
275:51 - so now we have this vector
275:54 - but the problem we have now is let's say
275:56 - we have this vector and we want to
275:58 - multiply it
276:00 - with the speed let's just call it s to
276:03 - move our enemy towards the player
276:05 - the issue we have now is that this
276:07 - vector is going to be way too large
276:10 - so if you just multiply it with s being
276:12 - 5 then this arrow here wouldn't go
276:15 - towards the player it would go all the
276:17 - way to something like this
276:20 - so our enemy would just move way past
276:23 - our player since the original vector is
276:25 - way too large
276:26 - so essentially what that means is we
276:29 - want to reduce the length of this vector
276:31 - to one
276:33 - so we keep the direction but we reduce
276:36 - the length of this thing to make it
276:38 - exactly with a length of one and that
276:39 - way we can multiply it with the speed
276:41 - and have a proper movement and what that
276:43 - basically means is we have to
276:47 - normalize
276:50 - it
276:50 - and that way we will get a proper
276:52 - direction that we can actually use
276:54 - fortunately that is a very easy thing to
276:57 - do because all we have to do is pass in
277:00 - normalize afterwards
277:02 - and we are basically good to go
277:05 - although we do have to be careful and
277:07 - this is something we have seen with the
277:09 - entity earlier so in the move here
277:12 - we had to first check that the magnitude
277:15 - of our vector isn't zero and only then
277:18 - could we normalize because you cannot
277:20 - normalize a vector that has a length of
277:22 - zero
277:23 - so essentially we have to check if the
277:25 - length of this vector is greater than
277:27 - zero and only then can we normalize it
277:30 - now fortunately we already know how long
277:32 - this vector is going to be it's just our
277:35 - distance so we can use the distance in
277:38 - an if statement and just check if this
277:40 - is greater than zero and only if that is
277:42 - the case we want to get this vector
277:46 - and this distance could actually be zero
277:48 - if our player and our enemy are in
277:50 - exactly the same spot remember there's
277:52 - no collision between the enemies and the
277:54 - player
277:56 - and i guess what we can also do is if
277:59 - that actually happens so if my player
278:01 - and our enemy are on the exact same
278:03 - position
278:04 - we know in that case the direction could
278:06 - just be pygame.math.vector2
278:10 - with 0 and 0.
278:12 - so if our enemy is right on top of the
278:14 - player we can just give it a vector of 0
278:16 - and 0 and not move it at all
278:19 - and well with that we have our
278:22 - proper function that gives us a distance
278:25 - and the direction
278:27 - so now let me copy it
278:29 - we can paste it in here
278:30 - make sure to call it and pass in the
278:33 - player
278:34 - and right now we only really care about
278:36 - the first one
278:39 - so we only care about this distance here
278:41 - for now we don't care about the
278:43 - direction that will come very soon
278:45 - though
278:47 - but now we have another problem that i
278:51 - want to get myself.get status
278:54 - but now
278:55 - i have to get my player in this update
278:58 - method
279:00 - unfortunately this update method is
279:02 - going to run for every single
279:05 - way to have it every single visible
279:07 - sprite
279:08 - and
279:09 - passing in an extra argument to all of
279:12 - these seems kind of inefficient
279:15 - since only the enemy is going to need a
279:17 - player in the update method
279:19 - so instead here's what i'm going to do
279:21 - let me minimize all the methods
279:24 - in my level
279:27 - and in my ysort camera group i'm going
279:30 - to give this
279:31 - another
279:32 - method and i've got this one enemy
279:37 - update and only in here we get self and
279:41 - we get the player
279:42 - and essentially what i want to do in
279:44 - here i first of all want to get all of
279:46 - my enemy sprites and this we're gonna
279:49 - get in just a second
279:51 - and then for
279:53 - enemy in
279:55 - enemy sprites
279:57 - i want to call sprite dot
280:00 - enemy
280:01 - update
280:03 - and then in here i can pass in the
280:05 - player
280:06 - and then in my run method
280:09 - besides the regular update i want to
280:11 - call self.visiblesprites.enemyupdate
280:16 - and this one is going to get self dot
280:19 - player
280:20 - lay here
280:21 - so that way we can separate the enemy
280:24 - with the update method
280:26 - and i guess that means i want to copy or
280:30 - cut out all of this and give this enemy
280:33 - the enemy
280:35 - update method
280:38 - that is going to work very similar
280:40 - compared to the update method except now
280:42 - it's for the enemy only and this one
280:44 - gets
280:45 - self and player so now we have access to
280:49 - the player
280:50 - so the last one we have to figure out is
280:52 - how to actually get all of the enemy
280:54 - sprites
280:56 - and essentially what i want to do is i
280:58 - want to get my sprite
281:00 - or sprite in self.sprites
281:04 - so this would give us literally all of
281:07 - our sprites and i only want to select
281:10 - the ones with the enemies from that
281:12 - so this is going to be an if statement
281:16 - and here it becomes important that each
281:18 - of our tiles or each of our classes has
281:21 - a sprite type so our enemy has a sprite
281:24 - type
281:25 - and our tile has a sprite type
281:28 - and our player
281:30 - should have one as well not sure if i
281:32 - gave him one but doesn't really matter
281:34 - the player doesn't need one
281:36 - so what i want to check if sprite dot
281:39 - sprite
281:41 - underscore type
281:44 - is equal to
281:45 - enemy because in my enemy my sprite type
281:48 - is enemy
281:50 - now this can be a tiny bit dodgy because
281:53 - if a sprite doesn't have a sprite type
281:56 - attribute we're gonna get an error so
281:59 - what i want to check first
282:01 - is another if statement
282:03 - that
282:04 - if
282:06 - has
282:07 - attribute
282:08 - now has attribute basically just checks
282:11 - first a class and then we can check for
282:14 - a specific kind of attribute which in my
282:17 - case is sprite underscore type
282:20 - so we are first checking
282:22 - if the sprite has a sprite type
282:24 - attribute in the first place and once we
282:26 - have that we are checking if that sprite
282:28 - type is going to be enemy so that way it
282:31 - doesn't matter if the player has a
282:33 - sprite type or not or if we just forgot
282:35 - it for some other tile or maybe if you
282:37 - want to add more tiles later on
282:40 - this would basically save you
282:42 - alright so now
282:44 - we should be having a distance to the
282:47 - player
282:49 - i guess let me run the code nothing
282:51 - should happen yet we get invalid syntax
282:54 - let's check it out
282:56 - ah the problem here is
282:58 - this should not be an if statement so we
282:59 - only need one if statement
283:01 - and then we can combine the different if
283:03 - statements
283:04 - so now let's try this again
283:07 - and now we have name sprite is not
283:09 - defined
283:11 - oh and the reason here is i call this
283:14 - enemy
283:15 - i didn't call it sprite
283:17 - so next attempt
283:20 - and we get now name in our enemy
283:24 - name get player distance direction is
283:26 - not defined i think i know where this is
283:28 - coming from exactly here this should be
283:31 - self
283:32 - so now the next attempt and now things
283:35 - are working again although still nothing
283:37 - is happening
283:39 - but at the very least we are not getting
283:41 - an error
283:42 - so what's happening now is we are
283:44 - getting the status but we are not using
283:47 - that to move the enemy
283:49 - but let's work on that now then we can
283:51 - actually see what's going on so i want
283:54 - to create another method and let's call
283:56 - this actions
283:58 - and then here we need self and we again
284:01 - are going to need our player
284:03 - and in here i want to check my status so
284:06 - if self.status
284:08 - is equal to
284:10 - attack
284:11 - then i want to do a certain thing for
284:13 - now let's just print
284:15 - attack
284:16 - then i want an l if statement if myself
284:18 - dot status
284:20 - is equal to
284:22 - move i believe i called it
284:25 - let's double check yeah move
284:29 - so if this move is the case let's say
284:32 - we're going to work on this in a second
284:33 - let's call it pass for now
284:36 - and if neither of these is the case i
284:38 - well don't really want to do anything
284:41 - but let's just say self direction is
284:44 - going to be pygame.math.vector2
284:49 - this line here is important if our
284:52 - player let me draw it actually so if
284:54 - this is our enemy
284:56 - and this is the circle
284:59 - that attacks if the enemy is supposed to
285:01 - move towards the player
285:03 - if the player is inside of the circle
285:06 - then our enemy is going to move towards
285:08 - the player but i also want to make sure
285:11 - that if the player
285:13 - moves out of that circle
285:15 - then the enemy is supposed to stop
285:18 - moving so this is what this line
285:20 - essentially ensures that once the player
285:23 - is leaving the circle the direction of
285:25 - my enemy gets back to zero so it stops
285:28 - moving
285:29 - all right the actually interesting one
285:32 - is this one here
285:33 - i want to make my enemy move towards the
285:36 - player once the player is getting closer
285:38 - and this is again going to be in self
285:41 - dot direction
285:43 - and in here we need self dot get player
285:46 - distance direction
285:47 - it needs the player
285:50 - and now we care about the second element
285:53 - being returned so index one which is the
285:55 - direction so this is what we are getting
285:57 - now
285:59 - and now in my any update i can call self
286:02 - dot actions pass in the player
286:06 - and now let's try this
286:09 - so now we can actually see something
286:12 - moving so now the enemies are coming
286:13 - towards us if we are close enough on the
286:16 - cache you see if the enemy is
286:17 - overlapping we get attack in the bottom
286:19 - left
286:20 - so now we can actually do something
286:26 - so this section was probably one of the
286:27 - more difficult parts of this tutorial
286:29 - because there are lots of steps that
286:31 - need to be taken together
286:33 - so
286:34 - if you struggle to come along i would
286:36 - really recommend to double check each of
286:38 - these methods and see what they are
286:39 - doing
286:41 - there wasn't really any easier way of
286:43 - doing all of this
286:44 - but all right i guess now what we can
286:47 - work on
286:48 - is
286:49 - to
286:51 - animate the enemies
286:54 - and in here we basically want to do the
286:57 - same kind of animate we have done for
286:59 - the player
287:00 - let me just have a look actually let's
287:03 - minimize all of the methods here
287:05 - and
287:07 - i kind of want to do the same thing i've
287:08 - done for the player to animate the
287:11 - different kinds of states
287:13 - although for the enemy it's going to be
287:16 - a tiny bit different so we couldn't put
287:18 - this animate in the entity and also
287:20 - apply to the enemy
287:22 - although it is arguably somewhat similar
287:25 - but let's go for it step by step so
287:27 - first of all i want to get myself dot
287:29 - frame index
287:30 - and add plus equal self dot animation
287:35 - speed
287:36 - so these two parameters we are getting
287:39 - from the entity they are
287:41 - all the way at the top
287:43 - and now i want to check if self dot
287:45 - frame index is greater or equal than the
287:48 - length of self dot
287:51 - animations
287:53 - and then myself dot status
287:56 - and if that is the case i want to set
287:58 - self dot frame index back to zero
288:02 - so this is pretty much the same thing we
288:05 - have done
288:06 - in these two lines except i guess the
288:08 - animation
288:09 - we have set for the player in a separate
288:11 - variable makes it a bit easier to read
288:14 - let's do it here as well
288:16 - so now length of our current animation
288:21 - so so far those two are pretty much
288:24 - identical
288:26 - and for now they will continue to be
288:28 - identical because now we can set self
288:30 - dot image
288:33 - is going to be my animation
288:37 - and i want to get my integer of self dot
288:40 - frame index
288:43 - and importantly here what we have done
288:45 - for the player as well
288:46 - we have to update the self.rect
288:49 - so let me copy it actually
288:52 - and now we are setting our rectangle in
288:56 - the center of the hitbox because
288:58 - remember we are moving the hit box we
289:00 - are not moving the rectangle
289:03 - so if we didn't add this we wouldn't
289:05 - display the enemy in the right position
289:08 - but now we can in the update method
289:11 - actually called self dot animate
289:15 - and let's try this now
289:17 - and we actually get animation
289:19 - and they don't really have a good attack
289:21 - animation i think this one is an attack
289:23 - animation yep there we go so now this
289:25 - thing has an attack animation
289:27 - and i guess the proper attack animation
289:29 - comes with the raccoon
289:32 - and there we go this is working not
289:34 - badly although now we have a problem and
289:36 - let me actually stand here
289:39 - i want to make sure that my enemies have
289:41 - a proper attack animation so for the
289:43 - raccoon for example it's supposed to
289:45 - play the entire thing and not be stuck
289:48 - in the attack loop which i think looks a
289:51 - bit silly
289:53 - so that is something we have to work on
289:55 - in our enemy and i think it's a good
289:57 - idea to minimize all the methods in my
290:00 - enemy it's getting a bit longer
290:02 - and in my init method i want to add
290:05 - another section and let's call this one
290:08 - player
290:09 - interaction
290:11 - and for now on here i want to have one
290:13 - method that's called self.can attack
290:17 - and by default this should be true
290:20 - and then in my get status
290:24 - i only want the enemy to be able to
290:26 - attack if the player is close enough and
290:29 - if self
290:31 - dot can attack is true
290:34 - and now in my actions
290:38 - once the player has actually attacked
290:41 - i now
290:43 - want to restart the timer to make the
290:45 - enemy
290:46 - not attack anymore
290:48 - but now we have a problem so this entire
290:51 - graph
290:52 - is the entire length of our attack
290:54 - animation for the enemy
290:56 - and for the sake of simplicity let's say
290:58 - it has just a couple of frames so we
291:01 - have zero one two three
291:04 - and four and each of these is a frame
291:07 - for the different cycles of the attack
291:09 - now if we set
291:13 - dot can attack defaults in here then we
291:16 - would only get to the first step and
291:18 - then our attack would stop so we would
291:20 - not actually see the attack so what we
291:23 - want to do is we want to set self can
291:26 - attack only to false after the animation
291:29 - has finished
291:30 - and this is then going to happen in my
291:33 - animate would i put it down here animate
291:36 - function
291:37 - so what i want to do in here is if self
291:40 - dots self.status is equal to
291:44 - attack
291:45 - so right now we're checking
291:47 - if our current frame index is longer
291:49 - than the animation
291:50 - and if we are attacking and only if
291:52 - those two
291:54 - are correct then we can set self dot can
291:58 - attack
291:59 - back to false
292:00 - and that way the player only stops being
292:02 - able to attack after the attack
292:04 - animation
292:05 - so now we have a proper
292:07 - method here so technically now
292:10 - the enemies should only be able to
292:11 - attack once let's try this with the
292:13 - raccoon
292:16 - so there you could see our raccoon could
292:18 - attack once but not again
292:20 - so this is
292:22 - working reasonably well
292:26 - so now what i want to do
292:28 - i want to create a timer that the
292:30 - enemies can attack again after a certain
292:32 - period of time
292:33 - and this i think could be a pretty good
292:35 - exercise so check the previous cooldowns
292:38 - we have created and try to make a
292:41 - similar one for the attack animation of
292:43 - the enemies
292:49 - alright first of all we need two more
292:51 - attributes we need self dot let's call
292:54 - it attack time
292:56 - by default it's going to be none
292:59 - and we are going to need some kind of
293:01 - let's call it attack
293:03 - cool down
293:06 - in my case i've set this one to 400 it's
293:08 - identical for all of the different
293:10 - enemies although this you could also put
293:13 - into this dictionary if you really
293:15 - wanted to
293:16 - but mine is already getting quite long
293:18 - so i didn't worry too much about it
293:20 - now let me minimize all of those methods
293:23 - and let's put it down here
293:26 - i want to create a timer for the attack
293:29 - cooled down
293:32 - and in here i first want to check if not
293:35 - self
293:36 - dot can
293:38 - attack because we only want to check
293:40 - this timer if this one is wrong
293:43 - and here we have to get our
293:46 - current time with pygame.time dot get
293:50 - underscore ticks
293:53 - that was atrocious spelling
293:55 - all around
293:57 - this one should work now
293:59 - and now if my current time minus myself
294:02 - dot
294:04 - attack
294:06 - time
294:08 - is greater or equal than myself dot
294:11 - attack
294:12 - cooldown
294:13 - and if that is the case self dot can
294:16 - attack
294:17 - should be set back to true
294:18 - now the one thing i haven't done is to
294:20 - get my attack time
294:23 - and this is going to happen in my
294:26 - not in my animate it's going to happen
294:27 - in my actions
294:29 - so in here besides print attack i want
294:31 - to get self dot attack
294:35 - time
294:36 - and it should be pygame
294:39 - by game
294:40 - dot time dot get underscore
294:44 - ticks
294:45 - and now let's try this
294:48 - and we get invalid syntax in the enemy
294:53 - ah because for
294:55 - attack cooldown i forgot the self
294:58 - now let's try it again and there we go
295:00 - so now we get attack
295:03 - okay that's a bit hard to see
295:10 - so the animation still doesn't seem to
295:12 - work perfectly
295:14 - let's see what went wrong ah and i
295:17 - believe
295:18 - in my get status
295:22 - in this line here after we have just
295:24 - attacked
295:26 - i want to check if self dot
295:30 - status
295:31 - is different from
295:33 - attack
295:34 - and if that is the case i want to set
295:36 - self.frame index back to zero so we
295:39 - essentially always want to be able to
295:41 - reset
295:42 - the animation once we switch to
295:45 - different animations
295:46 - maybe that helped
295:53 - nope also didn't make a difference
295:55 - so there's something else i missed sorry
295:57 - the code is getting very long it's a bit
296:00 - hard to plan this
296:02 - oh and i think i've just realized the
296:05 - mistake
296:06 - that this attack cooldown we don't
296:08 - actually call
296:10 - so self dot attack
296:13 - cooldown
296:14 - and while doing this i realized we have
296:17 - one attribute called the tag cooldown
296:19 - and the method is called the same
296:21 - so let's just call it cooldown
296:24 - our enemy only has one anyway
296:27 - so
296:28 - now let's try this again
296:30 - so let's go to the raccoon
296:34 - and this is looking much better cool
296:36 - there we go so now we have proper attack
296:38 - animations and once we add particles
296:40 - this is going to look even better
296:43 - but now
296:44 - we have
296:45 - the basic enemy logic
296:48 - and i guess this was a really long
296:50 - section so let's finish this one for now
296:53 - and for the next one we are going to
296:55 - start with the interaction between the
296:58 - player and the enemies so let's talk
297:00 - about that and this has to go two ways
297:03 - on the one side our player has to be
297:06 - able to attack the enemies with the
297:08 - weapon or with magic
297:10 - and on the other side the enemies have
297:12 - to be able to attack the player as well
297:14 - now the logic for the enemies attacking
297:16 - the player is actually quite simple we
297:19 - already made most of it all we really
297:21 - have to check is if the enemy is close
297:23 - enough and then triggers an attack and
297:25 - if that is the case we can just call a
297:26 - function to reduce the player's health
297:29 - now the other way around is a bit more
297:31 - complicated
297:32 - because we have to check if the player
297:34 - weapon actually collides with an enemy
297:37 - and here's how we are going to do that
297:39 - we are going to create two more sprite
297:41 - groups one is called attack sprites the
297:44 - other is called attackable sprites
297:47 - and whenever we create a weapon we are
297:49 - going to put it into the attack sprites
297:51 - and magic is also going to go in there
297:54 - and all of the enemies or anything that
297:56 - can be attacked will go into attackable
297:58 - sprites
297:59 - and then in our level we're going to
298:01 - check the collision between any sprite
298:03 - and attack sprites with the attackable
298:05 - sprites
298:06 - and if there is any kind of collision
298:09 - then we're going to check the tile type
298:10 - and trigger a certain thing for example
298:13 - if we have grass we're going to destroy
298:15 - the grass if we have an enemy we are
298:17 - going to lower the health of the enemy
298:19 - and that's pretty much the entire logic
298:22 - there are a couple of visual things we
298:24 - are going to add but let's implement the
298:26 - basic logic first
298:27 - here we are back in our main file and i
298:31 - want to go to level and in here we
298:33 - already have quite a few different
298:34 - methods and i want to go to my init
298:36 - method and add a bit more here
298:39 - and i guess we can put this under attack
298:41 - sprites it doesn't really matter where
298:43 - you put it so here we have attack
298:46 - sprites and this is just
298:48 - pygame.sprite.group
298:51 - then i can copy it
298:53 - and
298:54 - let's create another group that's called
298:56 - attackabilt sprites
298:58 - so the basic logic is we are going to
299:00 - spawn our weapons and our logic inside
299:02 - of this group all our enemies will be in
299:04 - this group and then we can check the
299:06 - collisions between these two groups and
299:08 - check if we hit anything
299:10 - but for that to work we actually have to
299:12 - assign things to the different groups so
299:15 - let's start with the enemies in create
299:18 - map
299:19 - so in this section here
299:22 - actually in this section here we are
299:25 - creating all of our enemies and right
299:27 - now the enemies are just invisible
299:29 - sprites
299:30 - but they should also be in self-dot
299:33 - attackable sprites
299:35 - and i guess for this one let me put the
299:37 - enemy on multiple lines so it's a bit
299:39 - easier to see what's going on
299:42 - because enemies will get a few more
299:44 - lines of code and i'd like to keep it a
299:46 - bit more readable
299:48 - now next up when we are creating an
299:50 - attack so in this method here
299:52 - we have our weapon
299:54 - and right now this one is also only
299:56 - invisible sprites and it should also be
299:58 - in self dot
299:59 - attack sprites
300:02 - so now we have well different kinds of
300:05 - sprites and there's one thing i forgot
300:08 - because the grass is also supposed to be
300:10 - attackable
300:12 - and that could be a good exercise so try
300:14 - to figure out which group the grass
300:16 - should belong to should be really easy
300:24 - so in my grass right now i have
300:27 - self.visible sprites and self.obstacle
300:29 - sprites and i want to add a third group
300:33 - that is self dot attack a bill sprites
300:37 - attack bill sprites there we go
300:40 - and since grass is also getting quite
300:42 - large let's put this on multiple lines
300:44 - so it's a bit easier to read
300:47 - so now we have a couple more groups
300:49 - although if i run the game
300:51 - nothing is going to change
300:53 - but now in my level let me minimize the
300:57 - create map function again it's getting a
300:58 - bit large
301:00 - i want to create another method and
301:02 - let's put it right at the end
301:04 - and let's call this one player attack
301:08 - logic
301:10 - and we need self and nothing else
301:12 - and in here we basically want to cycle
301:14 - through all of the attack sprites and
301:17 - then check if any of those are colliding
301:19 - with any of the attackable sprites
301:21 - and be aware for now we only ever have
301:23 - single attack sprite whatever our weapon
301:26 - is
301:26 - but later on once we have magic there
301:28 - could be multiple sprites inside of that
301:30 - group so just be aware of that so first
301:32 - of all
301:33 - let's use an if statement to check if
301:35 - anything is in attack sprites in the
301:37 - first place because if not we don't have
301:39 - to bother anyway
301:42 - now once there is something inside we
301:44 - can check for
301:45 - attack sprite
301:48 - in self dot
301:50 - attack
301:51 - sprites
301:52 - and now i want to use pygame dot sprite
301:55 - dot
301:56 - sprite collide
301:59 - and in here we need a sprite we need a
302:01 - group and then we need to do
302:03 - kill argument
302:05 - and let's go through what this one means
302:07 - and sprite is the easiest one it's just
302:10 - going to be a sprite let's say it is
302:12 - this sprite here
302:13 - then we are going to check this sprite
302:15 - if it collides with any sprite inside of
302:17 - a group so let's say we have our group
302:20 - here
302:21 - and inside of this group
302:24 - we have a bunch of
302:26 - sprites it doesn't really matter how
302:27 - many you have it's completely relevant
302:30 - and this method basically goes through
302:33 - if this sprite is colliding with any of
302:37 - these sprites and then the do kill
302:39 - argument determines if the yellow sprite
302:42 - is gliding with the purple sprite are we
302:44 - going to destroy that sprite
302:47 - and that's literally all that sprite
302:49 - collide does so in my case i don't want
302:52 - to kill any of the sprites
302:55 - for the sprite i want to check my attack
302:58 - sprite
302:59 - and for the group i want to look at it's
303:02 - going to be self dot
303:04 - attackable
303:06 - sprites and this then returns a list
303:10 - of all the sprites that have been
303:12 - colliding so we can store it in let's
303:15 - call it collision
303:17 - sprites
303:18 - so what we can do now once we have that
303:22 - we can check if collision sprites exists
303:25 - so if we have any kind of collision
303:28 - and then once we have that we can cycle
303:30 - through that list and let's call it for
303:32 - target sprite
303:34 - in collision
303:37 - sprites
303:38 - and now we finally have the sprite that
303:40 - have been colliding with our weapon so
303:42 - what we can do now is check different
303:44 - kind of things but i guess for now we
303:47 - can just check if this is working so
303:48 - let's say target sprite dot kill so we
303:51 - essentially destroy any kind of sprite
303:53 - we are attacking
303:56 - and we have to make sure we're actually
303:57 - calling it
303:59 - let's call it right after the enemy
304:01 - update
304:02 - so self dot player attack logic
304:07 - and now let's run it we don't get an
304:09 - error it's good start
304:11 - and now i can attack the grass it
304:12 - disappears i can attack the enemies they
304:14 - disappear
304:16 - and this seems to be working quite well
304:19 - obviously
304:20 - not ideal so far but at the very least
304:23 - something is working
304:25 - the problem now is we don't just want to
304:28 - destroy the target sprite we want to do
304:30 - something else
304:31 - and to figure out what we have to do we
304:34 - have to figure out the sprite underscore
304:37 - type so for example for my grass
304:40 - the sprite type would be grass
304:42 - that's the one we set here so this is
304:45 - basically then
304:46 - an if statement
304:48 - so if the target sprite is equal to
304:51 - grass
304:53 - then
304:54 - well
304:55 - if that is the case we just want to
304:56 - destroy the grass anyway
304:58 - so in here we actually do want to get
305:01 - target sprite dot kill
305:04 - and let's try this now
305:06 - so i can attack the grass this one still
305:08 - disappears
305:09 - and if i attack the enemies they also
305:11 - disappear so something has gone wrong
305:13 - here let's check
305:15 - oh and i realized that this argument
305:17 - here should be false because i do not
305:19 - want to destroy the sprite so you have
305:21 - just seen that because this one was true
305:24 - we are destroying any kind of sprite so
305:26 - we basically never got across this line
305:29 - so now it is false let's try it again
305:31 - now
305:32 - so we can still destroy the grass but
305:34 - now the enemies we can't destroy anymore
305:37 - now it's working
305:39 - and right now this destroying here looks
305:42 - kind of boring but later on once we had
305:45 - some particles it does end up looking
305:47 - significantly better
305:48 - but step by step now besides that if
305:51 - we're not attacking grass i guess i can
305:53 - just add an else statement
305:55 - because we only really have one other
305:57 - thing we can attack and that's the
305:59 - enemies
306:00 - although each of our enemies also has a
306:02 - sprite type so you could be more
306:04 - specific if you really wanted to
306:07 - but now we can again target our spread
306:09 - type
306:10 - and now i want to give them a method and
306:13 - let's call it get
306:15 - damage
306:16 - and for this one i need a couple of
306:18 - arguments so first of all i want to know
306:20 - what the player is doing
306:22 - and besides that i also have to know
306:24 - with what attack we are hitting the
306:26 - enemy so are we using a weapon or are we
306:28 - using magic
306:30 - so i basically want to know the attack
306:32 - sprite
306:35 - dot
306:36 - sprite
306:38 - type
306:39 - so this is the attack sprite we got from
306:41 - all the way up here that we are going to
306:43 - pass
306:44 - in there
306:45 - and let me just make sure that our
306:47 - weapon actually has a sprite type
306:50 - so we can reopen our weapon
306:53 - and right now this one doesn't have a
306:54 - sprite type so we have to give it one
306:57 - and let's do it right at the top
307:00 - so self.sprite
307:02 - underscore type
307:04 - is going to be weapon so now we can use
307:07 - it and let me close it again so we don't
307:09 - have too much random stuff
307:11 - and all right
307:12 - now in our enemy we have to create this
307:15 - method and i guess let me copy it so we
307:17 - can work on the parameters
307:19 - so back in my enemy let me minimize
307:22 - things
307:23 - in here
307:25 - i want to create
307:28 - get damage
307:29 - and we will need the player
307:33 - and besides that we are also going to
307:36 - need let's just call it the
307:38 - attack
307:40 - type and essentially what i want to do
307:42 - in here is if
307:44 - the attack type
307:47 - is equal to weapon
307:50 - then i want to set self dot
307:52 - health
307:53 - negative equal
307:55 - and now i have to figure out by how much
307:58 - i should lower the health and for that i
308:01 - have to know what is the player's damage
308:04 - and this i'm gonna get with another
308:06 - function and from the player i want to
308:08 - create a new method let's call it get
308:10 - full
308:11 - weapon
308:13 - damage
308:14 - so this is basically a getter function
308:16 - and let's copy this one and now we can
308:18 - go to my player
308:20 - in here let's minimize things as well
308:23 - and now we can add another method in
308:26 - here
308:27 - itself and nothing else
308:30 - and in here really all we want to do is
308:32 - want to get our player base damage we
308:34 - can get this
308:37 - from
308:38 - this dictionary here so our base attack
308:41 - is going to be this one
308:43 - and then besides that we also want to
308:45 - get our current weapon so the one we
308:47 - have basically up here
308:50 - and we basically want to get these two
308:52 - together and that is our full
308:55 - damn
308:56 - mitch so we're just adding those two
308:59 - numbers together
309:01 - so in this function let's first get the
309:03 - two different kinds of damage we have so
309:05 - we have our base damage and we have our
309:08 - weapon
309:09 - damage
309:10 - and all i essentially want to return
309:13 - is my base damage plus my weapon
309:19 - damage
309:20 - so all i have to figure out is what
309:22 - these two numbers are going to be
309:25 - and actually let's do this as an
309:26 - exercise so try to figure out from the
309:29 - player what is the full damage so what
309:31 - is the base damage plus the weapon
309:33 - damage
309:39 - for the base damage we essentially want
309:41 - self.stats
309:43 - and in there we have what is called
309:46 - attack
309:47 - we are essentially looking at this
309:48 - dictionary entry up here
309:51 - and then besides that i want to have my
309:54 - weapon damage
309:56 - and for that i first have to get my
309:58 - weapon
309:59 - data so in settings i am essentially
310:01 - accessing
310:03 - this data here
310:05 - and i want to get one of those keys
310:07 - let's say right now my weapon is a sword
310:10 - and then i want to get this key
310:12 - and this is information i can get from
310:15 - self.weapon
310:18 - what i can do here is weapon data and
310:21 - then self.web
310:23 - pin
310:24 - and once we have that i can just pick
310:27 - another entry because now we have
310:30 - this dictionary for the sword and inside
310:33 - of this dictionary
310:34 - we have damage
310:36 - and
310:37 - well all i have to do is add this to
310:40 - damage
310:41 - oh and while we are here i realized i
310:43 - forgot something because in our settings
310:46 - we also have a weapon cooldown and i
310:49 - didn't include that one in our player
310:51 - cooldown
310:52 - so in my player in cooldowns
310:55 - here we have the attack cooldowns
310:58 - and
310:58 - this is my base cooldown and to watch
311:01 - this i also want to add the weapon
311:02 - cooldown so in here we can basically do
311:05 - the same thing so we still use our
311:07 - weapon data let's copy the entire thing
311:10 - but except now instead of damage i want
311:12 - to add cool down
311:14 - and that is going to be this cool down
311:17 - here
311:20 - all right but now we have our get full
311:22 - damage
311:24 - so with that we can return to our enemy
311:26 - and now
311:28 - we have something
311:31 - i guess later on what we're also going
311:33 - to do is else
311:36 - let's add a pass in here but this is
311:38 - going to be magic damage it's going to
311:40 - work slightly differently
311:43 - and right now
311:45 - i guess this would work but we would
311:47 - never be able to see it because well our
311:49 - enemies don't have anything to well
311:52 - react to
311:53 - so i want to add another method again
311:57 - and this is just going to be check def
312:01 - needs self and nothing else and all
312:04 - we're going to check in here is if self
312:06 - dot health
312:07 - is smaller or equal to zero
312:10 - and if that is the case i just want to
312:12 - run self self.kill
312:15 - although right now
312:17 - this logic isn't going to work
312:19 - but i guess let's just try the entire
312:21 - thing and see if things are working so
312:24 - we can still destroy the grass
312:28 - enemy get damaged doesn't work so let's
312:30 - have a look
312:32 - should be here in my player attack logic
312:35 - so we have self the player and the tech
312:37 - sprite so this one seems to be working
312:39 - so in our enemy i'm pretty sure i know
312:41 - what i forgot and what i forgot itself
312:44 - so now let's try this again let's attack
312:46 - an enemy
312:47 - and we can see that nothing has happened
312:51 - and this happened because
312:54 - in my enemy i'm not calling check def
312:59 - so in my update method we can run
313:01 - self.jackdev
313:04 - you could also call it in the enemy
313:06 - update it doesn't really matter
313:08 - so now let's try this again
313:11 - and there we go now we have something
313:13 - that maybe a tiny bit weird that all of
313:17 - our enemies die in one hit
313:20 - so even the bigger ones they just die
313:22 - immediately
313:24 - and this happens even though they should
313:26 - be having quite a bit of health so in my
313:28 - settings for the monster data the
313:30 - raccoon for example has 300 health
313:33 - but all of our damage is like 15 or
313:35 - maybe
313:36 - 30. and the problem here
313:39 - is that get damage runs on every cycle
313:42 - of our game
313:44 - so we think we're hitting the enemy once
313:46 - but pygame just sees a collision
313:49 - and it runs this get damage every time
313:51 - it has this collision which in our case
313:53 - is 60 times a second and that way we are
313:56 - essentially multiplying our damage by 60
313:58 - which kills anything instantly so it's
314:01 - not really fair and essentially what we
314:03 - have to do is to create a timer that
314:05 - enemies can only be hit after a short
314:07 - amount of time
314:08 - so essentially all that means is we have
314:12 - to create another timer
314:14 - and let's put it all the way down here
314:18 - so here we have let's call it the
314:21 - invincibility
314:23 - timer
314:24 - and let's add something like let's call
314:27 - it
314:28 - vulnerable by default this is going to
314:31 - be true
314:33 - then we have self dot hit
314:36 - time by default this is none
314:39 - and let me spell it properly
314:42 - and then self dot invincibility
314:46 - [Music]
314:47 - duration
314:48 - let's say it's going to be 300 but again
314:50 - this number you could also put into the
314:52 - settings to have different kind of enemy
314:54 - behavior
314:55 - in my case well it wasn't really needed
314:58 - so now we have the basis for another
315:01 - timer
315:02 - but first of all let's implement that
315:04 - our enemy can only be hit once in a
315:06 - while
315:08 - and this is going to happen in my get
315:09 - damage so in here i want to check is if
315:14 - self dot vulnerable
315:17 - and only if that is the case
315:20 - i want to run all of this
315:22 - and by the end of it once we have run
315:24 - everything else
315:26 - i want to run self dot
315:28 - vulnerable
315:30 - is going to be false
315:32 - and i guess now let's try this so now
315:35 - the enemies shouldn't disappear anymore
315:36 - and they don't
315:38 - cool
315:39 - so seems to be working
315:42 - but obviously we do want to be able to
315:44 - attack the enemies so what we also have
315:47 - to get
315:48 - is self dot hit
315:51 - time
315:52 - is going to be pygame dot time dot get
315:55 - underscore
315:56 - ticks and with that we have all we need
316:00 - to get another timer and i guess this
316:03 - cooldown let's call it cooldowns
316:07 - and
316:08 - now in here we can check if self dot
316:13 - vulnerable if that is the case
316:16 - then we want to run this timer
316:18 - and i guess i can run the current time
316:20 - outside of this function so we have it
316:22 - available everywhere
316:25 - and then here we just want to check if
316:27 - my current time minus self.hit time
316:31 - is greater or equal
316:33 - than myself dot invincibility duration
316:38 - and if that is the case self.
316:41 - vulnerable
316:43 - is going to be true
316:45 - and i forgot this should be not
316:47 - self.vulnerable
316:50 - and now let's try this
316:53 - so i probably have to hit the enemy a
316:54 - couple of times but it does disappear
316:56 - eventually let's look at this one
316:59 - so i hit it once i hit it twice there we
317:03 - go this looks pretty good
317:10 - okay those ones are going to take longer
317:12 - so i just assume it's going to work
317:15 - but all right so with that
317:17 - we have the ability to damage our
317:20 - enemies the problem right now is the
317:24 - enemies aren't really being pushed back
317:26 - so our attack is well kind of pointless
317:28 - because the enemies can attack us right
317:30 - away anyway so i want to get them some
317:33 - kind of hit reaction that they are being
317:34 - pushed backwards
317:36 - and that is going to be another method
317:41 - let's call it hit
317:44 - reaction
317:46 - and basically what i want to do in here
317:49 - i just want to check if
317:52 - not self.
317:54 - vulnerable so if my enemy has just been
317:56 - hit
317:58 - then i want to set myself dot
318:01 - direction
318:03 - and
318:05 - multiply it
318:07 - with myself
318:09 - dot
318:11 - resistance and this number
318:13 - should be negative
318:15 - so think of it like this
318:18 - right now this is our enemy
318:21 - and this is our player
318:24 - and our player has just attacked the
318:27 - enemy
318:28 - essentially what i want to achieve is
318:30 - that my enemy is being pushed back in
318:32 - the same direction
318:34 - and the distance by how much
318:37 - the enemy is being pushed back should
318:39 - come from the self dot
318:41 - resistance
318:43 - and this self.resistance we are getting
318:45 - from somewhere in the enemy so i believe
318:48 - it is
318:50 - there resistance
318:53 - so that's kind of all we are going to
318:55 - need
318:56 - and this i just want to call in my
318:59 - update let's call it right before move
319:02 - so hit reaction
319:05 - that way it's going to happen early on
319:08 - but now i also have to make sure i
319:10 - actually get the right direction so in
319:12 - my get damage all the way at the top i
319:15 - want to set myself dot direction
319:18 - and in here self dot get player distance
319:21 - direction
319:22 - i want to pass in the player that i
319:25 - already have
319:27 - and then just get
319:29 - the value with number one so this is the
319:31 - direction and really all we're doing
319:33 - here is we are working with the
319:35 - direction of the enemy and just moving
319:37 - it in a different direction
319:39 - so i guess let's try if this is working
319:42 - so there we go they're being pushed back
319:45 - and this is making all of this feel
319:48 - much better
319:50 - and let's use different weapons this
319:52 - also works cool
319:56 - so now we have well a better get damaged
320:01 - method
320:03 - although there's one more thing i would
320:04 - like to implement
320:06 - and that is that my enemies are
320:08 - flickering once they are being hit
320:10 - actually they should apply both to my
320:12 - enemy and my player so essentially i
320:15 - want some kind of indicator that they
320:16 - are being hit and usually in games this
320:19 - works by flickering and to achieve that
320:22 - i have to work with the visibility of
320:24 - both my player and my enemy
320:26 - and that is something we can kind of put
320:28 - inside of the entity although since our
320:30 - player and our enemy are animating
320:32 - slightly differently we do have to put
320:35 - this in kind of different ways but let
320:38 - me actually implement it
320:40 - so in the enemy
320:42 - for my animate
320:44 - i want to add a bit more at the bottom
320:46 - to make them flicker once they are being
320:48 - hit
320:49 - and
320:50 - essentially what that means is if self
320:54 - dot vulnerable and again this should be
320:57 - not because we're checking once the
320:58 - enemy is being hit
321:00 - then we want to essentially flicker
321:04 - and if that is not the case so else then
321:06 - i just want to get myself.image and set
321:08 - the alpha to 255.
321:11 - so when you set the alpha you set a
321:13 - transparency of the layer and 255 is the
321:17 - full value so all of this basically
321:19 - means if the enemy is not vulnerable
321:22 - anymore this one then we are setting the
321:24 - full alpha
321:25 - but if that is not the case
321:27 - i want to get a specific kind of alpha
321:30 - and this we are going to get from
321:32 - somewhere else and this can either be a
321:35 - 0 or 255 so invisibility or full
321:38 - visibility
321:40 - and then self dot image dot set
321:43 - underscore alpha
321:45 - with the
321:46 - alpha so now we just have to figure out
321:49 - a function that toggles between
321:52 - 0 and 255
321:55 - and the same thing we are going to need
321:57 - for the player so i'm going to create
321:59 - this in my entity
322:01 - and let me minimize all the other stuff
322:02 - in here we are not going to need it
322:05 - so in here
322:07 - let's call it
322:11 - a wave
322:12 - value
322:14 - l u we need self and nothing else
322:20 - and let me explain what we are going to
322:22 - do
322:23 - and we are going to use a sine wave in
322:24 - here and let me explain how it's going
322:26 - to work so let's say this is going to be
322:29 - a graph
322:31 - we have here our time and on the y axis
322:34 - we have the well y axis
322:36 - and a sine wave kind of looks something
322:39 - like this
322:42 - except in beta drawn and we can check
322:45 - each point of this value in time
322:49 - and pretty much what i want to do
322:52 - is if this curve is positive so if we
322:55 - are here we are going to return 255
322:58 - and if we are below that curve so we are
323:02 - down here
323:03 - then we are going to return zero that
323:05 - way we are switching between those two
323:07 - numbers
323:08 - actually pretty simple
323:10 - but first of all for that to work we
323:12 - need from math
323:14 - import syn
323:16 - and now all i want to get is my value
323:19 - and i need to get my sign value and in
323:22 - here i have to pass in some kind of x
323:25 - which in my case is going to be the time
323:27 - and the time i get with pygame the time
323:29 - dot get underscore ticks
323:32 - and now if this value
323:36 - is greater or let's say equal to zero
323:40 - then i want to return 255
323:42 - and if that is not the case
323:45 - i want to return zero
323:48 - and let's add proper indentation and
323:51 - there should be return
323:52 - and that's all we need for this method i
323:55 - can go back to my enemy now
323:57 - and self.wave
323:59 - value
324:01 - and no arguments are needed
324:03 - and now this should actually be working
324:06 - let's try
324:08 - so now
324:10 - this is working beautifully cool
324:14 - makes the game look significantly more
324:16 - responsive
324:17 - nice
324:19 - now if you wanted to do the same thing
324:21 - with a white color instead of
324:22 - invisibility you would probably want to
324:24 - work with a mask but in my case that's a
324:26 - bit of an overkill but i have made a
324:28 - whole tutorial on how to use a mask you
324:30 - could totally use that one as well
324:33 - but alright now i want to give my player
324:35 - the ability to flicker as well so in my
324:38 - player i want to minimize all the
324:40 - different methods again
324:42 - and look at my animate
324:43 - and in here
324:45 - i want to add flicker
324:49 - now unfortunately to actually implement
324:52 - this we well we need to know if the
324:54 - player has been hit or not which we
324:57 - don't know just yet
324:59 - so let's first implement the enemies
325:01 - hitting the player and then we can work
325:03 - on the flicker
325:04 - and fortunately this isn't all that
325:06 - difficult
325:08 - the only real limitation is that we have
325:12 - to figure out how to get from our enemy
325:15 - back to the level so we know when the
325:18 - enemy is attacking the player that's
325:20 - going to happen in where are my actions
325:24 - so we know in here we can print an
325:26 - attack if the enemy is attacking the
325:28 - player that one is working perfectly
325:30 - fine
325:31 - but the issue is from this place we
325:34 - can't really access the player
325:36 - actually we can we have the player right
325:38 - here
325:40 - so technically we could run something on
325:43 - the player from here
325:44 - but i don't want to do that but a simple
325:48 - reason that later on whenever the enemy
325:51 - is attacking i also want to create some
325:53 - particle effects and for that to work i
325:55 - have to create this function in the
325:56 - level so essentially what i'm going to
325:59 - create is create a couple of methods
326:02 - inside of my level
326:04 - and one of them for example is going to
326:06 - be
326:07 - damage
326:08 - layer
326:09 - this one will need self as always then
326:11 - we need an amount and then we need an
326:14 - attack type amount should be fairly
326:16 - obvious it's the amount of damage the
326:18 - enemy can deal
326:20 - attack type is going to be in settings
326:23 - it's what we get from
326:25 - attack type
326:27 - it's basically what kind of particle we
326:29 - are going to spawn once the enemy is
326:31 - attacking
326:32 - but for now we are not going to use it
326:35 - so now in here we want to write a
326:38 - function that can damage the player
326:40 - but first of all we need to deal with
326:42 - the same problems we have with our
326:44 - enemies that we first want to check if
326:47 - self dot player
326:50 - dot vulner
326:52 - vulnerable
326:54 - so essentially we want to create a timer
326:56 - after the player is hit so we can't
326:58 - attack the player multiple times in one
327:00 - attack
327:01 - but essentially once we have that we're
327:03 - going to implement that in just a second
327:05 - we want to get self dot player dots
327:08 - health
327:10 - and from that reduce
327:12 - the amount
327:15 - then we want to set
327:16 - self.player.vulnerable
327:19 - to false
327:21 - and in our player we want to have self
327:24 - dot player dot let's call it hurt time
327:27 - and this is going to be pygame dot time
327:29 - dot get underscore ticks
327:32 - and at the end later on we want to spawn
327:36 - particles but we don't have that one
327:38 - just yet
327:39 - now this damage player i want to create
327:42 - from the enemies
327:43 - so in my create map
327:46 - when i am creating the enemies so all
327:49 - the stuff down here
327:50 - i want to pass this one in there as well
327:53 - so self dot damage player and as always
327:56 - don't call this function
327:59 - and now in my enemy we also have to put
328:02 - this into a
328:04 - parameter
328:06 - uh spelling it correctly there we go
328:09 - so now
328:10 - in my
328:12 - let's call it player interaction i guess
328:14 - it fits best in there so self dot damage
328:17 - player
328:19 - is going to be damage
328:21 - underscore players what i called it
328:24 - oh i wrote parameter well never mind uh
328:27 - damage player that makes more sense
328:29 - so now our enemy has the ability to
328:31 - damage the player
328:32 - and now
328:35 - in my actions
328:37 - instead of printing attack
328:39 - i want to run
328:41 - self dot
328:42 - damage player
328:44 - and in here we have to figure out an
328:46 - amount and an attack
328:50 - type
328:51 - and well if you look at the init method
328:54 - we have a ton of statistics in here
328:56 - so the first one is self.attack damage
328:59 - we can just pick this one and paste it
329:03 - in the amount
329:05 - and we can do the same thing with the
329:07 - attack type
329:08 - it is all the way at the bottom this one
329:10 - here
329:11 - so attack type and
329:15 - actions this one here
329:17 - so now our enemy is able to attack the
329:20 - player and i guess let me minimize all
329:22 - of the methods it really is getting a
329:24 - larger project
329:26 - all right so
329:27 - this should be working at least
329:29 - hopefully
329:30 - now in my player we just have to set up
329:33 - all the attributes for the timer
329:36 - and let's add another section to this
329:39 - and let's call it
329:42 - a damage
329:43 - timer
329:44 - and in here we have self.vulnerabil
329:48 - which is true by default then we have
329:51 - self. i believe i called it hit time
329:54 - or was it hurt time it's hard to tell i
329:58 - called it her time there we go
330:00 - so self.her time
330:03 - and this by default is going to be none
330:06 - and finally we need something like
330:08 - self.invulnerability
330:12 - duration
330:13 - and let's say this one could be 500
330:17 - seems like a decent value but you can
330:19 - take it with this
330:21 - and all right now
330:22 - in my not animate but in cooldowns i can
330:26 - add another timer
330:28 - so in here if
330:30 - not
330:31 - self dot
330:34 - vulnerable then i want to run the timer
330:36 - so if current time
330:38 - minus self dot hurt time is greater or
330:42 - equal than so self dot
330:44 - invulnerability duration
330:47 - and once that timer is running we want
330:50 - self. vulnerable
330:52 - and set it back to true
330:54 - so
330:56 - now
330:56 - okay well now we can't really see it but
330:59 - we should actually be able to see it in
331:00 - our health bar so let's try it
331:04 - and there we can actually see it in our
331:06 - health bar it's going down so obviously
331:09 - if it goes below zero we should be dying
331:13 - but in my case that doesn't really
331:14 - matter so much
331:16 - at the very least we know it's working
331:20 - so now in the player not the level the
331:22 - player we can now start working on the
331:25 - flickering
331:26 - and let's do this as an exercise so try
331:29 - to figure out to make the player flicker
331:31 - once we get hit should be very similar
331:33 - compared to the enemy
331:39 - right so if self.
331:43 - vulnerabil
331:44 - is not the case
331:47 - then i again want to get my alpha value
331:51 - and we want self.wave
331:54 - value
331:55 - the thing we get from the entity so this
331:58 - one here
331:59 - and we want to get our self.image.set
332:04 - and paste in the alpha in here and if
332:06 - that is not the case
332:08 - then self dot
332:11 - image dot set underscore alpha and set
332:14 - this to 255 so full visibility
332:18 - and that should be all we needed let's
332:21 - try this now and we indeed get hit
332:27 - and we can still attack the enemies
332:29 - and that is working really well now i
332:32 - guess the one downside is it's very easy
332:33 - for enemies to overlap
332:35 - but
332:36 - well not going to worry too much about
332:38 - that but you can add a few more
332:40 - collision mechanics and improve on this
332:44 - alright so with that we have pretty much
332:47 - all of our collision mechanics at least
332:49 - in the most basic sense
332:51 - so with that let's start working on the
332:53 - particles that's going to be another
332:54 - major section
332:56 - now a particle effect sounds difficult
332:58 - in theory but in practice it really
333:01 - isn't that hard we already kind of
333:04 - created the basics for it anyway so
333:07 - essentially for my particle effects it
333:09 - is just going to be another sprite that
333:12 - animates for a couple of different
333:13 - images
333:14 - the only difference now is that this
333:17 - particle effect is going to disappear
333:19 - once we're running out of animation
333:20 - frames so we're not looping the
333:22 - animation anymore we're just playing it
333:24 - once
333:25 - and then we are giving it a position and
333:28 - that's kind of all we need although
333:30 - there's one downside here
333:33 - that we have a lot of different images
333:36 - for all of the different animations
333:39 - so i think in total we have about 15
333:42 - different animations and each animation
333:45 - individually has about 5 different
333:46 - frames
333:48 - so we are looking at a lot of images
333:50 - overall
333:51 - and what i want to do is to import all
333:53 - of these images when the game starts
333:56 - and then keep them in memory and only
333:58 - play them when they're needed in the
334:00 - game and the massive downside to avoid
334:02 - here is that we are importing images
334:05 - every time we are creating a new
334:07 - particle effect because that would be
334:09 - very slow importing images does take
334:11 - some time although i guess this is
334:14 - something that we can work on when we
334:15 - actually work on it so
334:17 - let's go into the code and let's have a
334:19 - look at this
334:20 - here i'm back in my file and i can close
334:24 - a couple of things because we don't need
334:25 - them for now so my entity and my tile
334:30 - and i guess for now my enemy as well i'm
334:31 - not going to need them
334:33 - and i do want to create a new file and
334:36 - let's call this one particles.pi
334:40 - and in here as always i want to import
334:42 - pi game
334:44 - and i already know that from support i
334:48 - want to import my
334:50 - import folder
334:53 - and now let's just create a dummy
334:55 - particle effect and that's going to be a
334:58 - particle effect class and this one is
335:01 - going to inherit from
335:02 - pygame.sprite.sprite
335:05 - and in here i want an init method as
335:08 - always we need self
335:10 - spelled properly
335:11 - then we need a position
335:14 - and we want some animation
335:17 - frames so this is what we are going to
335:19 - loop over
335:20 - where we are getting this from you will
335:22 - see in a bit and then finally what
335:25 - groups we want to pass this into
335:28 - and then we need super and dunder init
335:32 - as always with not self but with the
335:35 - groups
335:36 - and now in here we need all the basics
335:38 - for an animation so self.frame
335:42 - index is going to be 0
335:44 - then self.animation
335:48 - speed is going to be 0.15
335:51 - self dot
335:53 - frames is going to be the animation
335:55 - frames
335:57 - but now we can already set the first
335:59 - image so self.image is going to be self
336:02 - dot image dot get underscore rect
336:05 - and then here self dot frame
336:08 - index
336:10 - so essentially this is going to be the
336:13 - basic setup for any kind of animation
336:16 - and now that we have that
336:18 - we can create an animate function give
336:20 - itself and nothing else
336:22 - and now self dot frame index plus equals
336:26 - self dot animation speed and now here we
336:31 - come to the difference so if self dot
336:34 - frame
336:34 - [Music]
336:35 - is greater or equal than the length of
336:38 - my self dot
336:40 - frames so we are going beyond the length
336:43 - of our animation
336:44 - then we want to self.kill
336:47 - but else self.image
336:51 - is going to be self.frames
336:54 - and we want an integer
336:57 - of self dot frame
337:00 - index
337:01 - so
337:02 - really all we are going to do in here is
337:05 - we are increasing frame index and if we
337:07 - are still inside of the list we are just
337:11 - picking one image from this list
337:13 - however if we go beyond that list
337:16 - then we are going to destroy that sprite
337:19 - so this way we are only running this
337:21 - animation once and once the animation
337:22 - has finished we are destroying the
337:24 - sprite
337:26 - and now we also have to be able to call
337:29 - this particle effect with the update
337:31 - method and then here self dot
337:34 - animate
337:35 - now we have a basic particle effect
337:38 - the problem is we need to figure out
337:40 - where to get these animation frames and
337:42 - now you might be tempted to just create
337:45 - another method like import
337:48 - particle
337:49 - images or something like that but that'd
337:51 - be a really bad idea for the simple
337:54 - reason that we have a lot of particles
337:57 - and if pygame always imports something
337:59 - when we destroy an enemy or some grass
338:01 - the game is going to run very slowly so
338:04 - i'm going to do something else
338:05 - i'm going to create another class
338:09 - and this i have called animation
338:11 - player
338:13 - doesn't need any inheritance and in here
338:15 - we are going to create an init
338:18 - method with self and also nothing else
338:22 - and this one is going to get one long
338:24 - dictionary where we are importing every
338:26 - single thing
338:28 - so this is going to look like
338:31 - this
338:34 - a slightly longer dictionary that well
338:38 - um
338:39 - imports all of the different material so
338:41 - we have our flame our aura and our heel
338:44 - so these are both played when the player
338:47 - heals
338:48 - then these are different attack types
338:50 - then we have our monster deaths and we
338:52 - have different leaves when we are
338:53 - destroying grass
338:55 - although in here i have created one more
338:57 - method that is called reflect images and
338:59 - this we also have to create in
339:02 - here let's make sure i am on the right
339:07 - line
339:08 - should be this one
339:11 - let me actually minimize this dictionary
339:13 - it's getting very hard to read things
339:16 - so what i want to do in here is reflect
339:19 - images
339:20 - and we need self
339:22 - and
339:23 - frames
339:25 - and let me demonstrate what this one is
339:27 - doing right now
339:29 - for the leaves so this is when we're
339:31 - destroying grass we have six different
339:34 - animations
339:35 - and pretty much what i'm doing here is
339:38 - i'm importing these animations twice
339:42 - once in the proper direction and then
339:43 - once reflected so that way we are going
339:45 - to get a bit more variability in there
339:48 - that's really all it is
339:51 - and
339:52 - really all i'm going to do in here is
339:53 - for frame in frames
339:56 - i'm going to create a flipped
339:59 - frame and this is going to be pygame dot
340:02 - transform dot flip
340:05 - and we want to flip the frame
340:07 - for true and false flip can reverse
340:10 - something up in the x or in the y axis
340:13 - in my case i only want to flip the
340:15 - x-axis and ignore the y-axis which is
340:18 - why this one is true and false
340:20 - and now i have a flipped image and i
340:22 - want to save this one in a new list so
340:24 - let's call it new frames and that one's
340:27 - going to be an empty list
340:29 - and now
340:30 - new frames dot append
340:33 - and i want to get the flip frame
340:36 - and at the end of all of this i want to
340:39 - return my new frames
340:42 - and that is
340:44 - basically all we are going to need for
340:46 - now
340:47 - and now back in my level we can start
340:50 - working with this particle effect
340:53 - so in here all the way at the top
340:56 - actually let me minimize all of this
340:58 - stuff again it is getting a bit
341:00 - confusing
341:02 - so at the bottom here i want another
341:04 - section and let's call this one
341:06 - particles
341:08 - and i'm going to create my animation
341:12 - player
341:13 - with my
341:14 - animation
341:17 - so the animation player we have created
341:19 - in here and this animation player is
341:22 - basically going to be able to run a
341:24 - particle effect i'm going to see in a
341:25 - second how that's going to work but
341:27 - first of all
341:28 - we have to import it so from
341:31 - particles
341:33 - import
341:34 - animation player
341:36 - and to illustrate how that is going to
341:39 - work let's create our grass particles so
341:43 - in my player attack logic
341:46 - i know when i have destroyed some grass
341:48 - so in here i want to add a bit more
341:51 - logic to spawn some particles
341:54 - and basically what i want to do is run
341:57 - self dot animation player and do
342:00 - something like create
342:02 - grass
342:04 - particles but for that to work i am
342:07 - going to need two bits of information at
342:10 - the very least
342:11 - i need a position
342:13 - and i need to group
342:14 - so i can put these sprites into the
342:16 - visible sprite group
342:18 - but i am also going to need a position
342:20 - so let's first get the position
342:24 - and the position we can get fairly
342:26 - easily all i need is my target sprite
342:28 - dot rect
342:29 - dot center
342:30 - so we are playing these particles right
342:33 - where the grass used to be
342:35 - now next up for the group we just want
342:37 - self dot visible sprites
342:40 - and let's put it in the list so we're
342:43 - doing it in the same way we have done
342:44 - earlier
342:46 - pretty much all we have to do now is
342:48 - actually create this method here in my
342:50 - particle animation player
342:53 - this is going to happen down here
342:56 - great grass particle we need self we
342:58 - need a position and we need the groups
343:01 - and in here first of all i want to get
343:04 - some animation frames
343:06 - and the animation frames we are getting
343:09 - from self.frames because in here we have
343:12 - our leaf and i essentially want to pick
343:15 - a random animation from this list
343:18 - and to pick a random animation we need
343:22 - from random
343:23 - import choice
343:26 - and now
343:28 - in here i can just call choice
343:30 - and pick for myself dot frames
343:34 - and in there i have leaf
343:38 - so leaf is essentially a tuple with a
343:40 - bunch of lists inside and we are picking
343:42 - one of these lists
343:45 - and now that we have that
343:47 - we can actually create a particle effect
343:49 - so particle effect
343:51 - and then we need these parameters let me
343:54 - just copy them
343:55 - in here so position we already have
343:58 - animation frames we get from animation
344:01 - frames
344:02 - and then groups we get from groups so we
344:04 - didn't actually have to make any kind of
344:05 - change
344:07 - and well that should be it
344:11 - let's try
344:13 - so we get an error with inconsistent use
344:15 - of space let's see where he's
344:17 - complaining
344:20 - in there
344:21 - and in return new frames
344:25 - and from level a couple of errors
344:28 - so from particles
344:32 - in there not sure what happened with
344:34 - this one that was very strange okay
344:36 - there we go and now you can actually see
344:37 - that this one it took quite a bit of
344:39 - time to load
344:40 - and
344:41 - we get a key error so let's check my
344:44 - particles
344:45 - and oh i didn't mean left i mean leave
344:52 - okay now let's try this again
344:54 - now we get self where was that arrow
344:58 - so in particles
345:01 - we are getting self.image
345:04 - okay it is getting a bit late let's try
345:06 - this again now
345:07 - and now particle effect has another
345:09 - problem let's check it out
345:12 - and self.image this should be
345:14 - self.frames
345:16 - um
345:18 - it may be getting a bit very late
345:20 - let's check this out let's try again
345:25 - okay and now for the particle we are
345:27 - going to need a rectangle
345:30 - and this we get with self dot rect
345:32 - is going to be self
345:34 - dot rect dot get
345:37 - rekt
345:39 - and then here i just want to place the
345:40 - center is going to where the position
345:42 - will be
345:44 - okay
345:44 - we are working for all the errors
345:48 - so now particle effect has the same
345:50 - error that shouldn't happen anymore
345:53 - self dot image okay i am going to take a
345:56 - break after this section
345:58 - okay now particle effect we are back
346:01 - here
346:02 - and this should be self dot frame
346:05 - index
346:07 - so another attempt
346:10 - there we go finally
346:12 - now we have some particle effects
346:16 - that are going to spawn randomly and
346:18 - this is looking much better
346:21 - now there are a couple of things we have
346:23 - to work on first of all
346:26 - right now we are only spawning a single
346:28 - leaf which is not great
346:31 - so i want to create multiple
346:33 - and essentially what i want to do for a
346:36 - leaf in
346:37 - range
346:39 - and then here i'm going to use rand int
346:41 - which i have not imported yet i believe
346:44 - from random we have choice but we don't
346:46 - have rendent
346:49 - i want to get random number between
346:52 - let's say three and six
346:56 - and then for each of those numbers we
346:57 - are going to create another animation
347:00 - and that way we get a bit more particles
347:03 - let's try this now this already feels a
347:05 - bit better
347:10 - so this is quite a nice effect cool
347:15 - although now i feel like in my level
347:19 - this position
347:21 - doesn't feel like it's really
347:23 - appropriate so i want to give this one a
347:25 - tiny bit of an offset
347:27 - so i'm just going to add an offset and
347:30 - this is going to be pygame.math.vector2
347:35 - and here 0 and 75.
347:39 - so we're just lifting up the particle
347:41 - effect by a tiny bit
347:43 - and this i'm just going to subtract from
347:45 - my position
347:47 - and that just feels like it's looking
347:49 - better
347:51 - and there we go might even be a bit too
347:53 - high although this one feels pretty good
347:56 - and okay with that we have some basic
347:58 - particle effects
348:00 - and
348:03 - we are making some solid progress
348:06 - okay let me close it
348:09 - and now we can work on the other
348:12 - particles for the enemies
348:14 - and fortunately we already have in my
348:17 - level let me minimize all of this again
348:21 - we already have one
348:23 - method that's called damage player and
348:25 - in here we want to spawn some particles
348:28 - so what i want to do in here is self dot
348:31 - animation player
348:33 - and let's call this a bit more generic
348:35 - generate
348:37 - particles
348:38 - although for this one we need a few more
348:40 - arguments so i want to know what the
348:43 - attack
348:44 - type is going to be
348:46 - so which of these different attack types
348:50 - are we going for so slash claw thunder
348:52 - and leaf attack
348:54 - besides that i need a position
348:57 - and i will need the groups where they
349:00 - should be and we can basically figure
349:02 - out all of these things right now so the
349:04 - tag type is pretty straightforward this
349:06 - is the one we already get from the
349:07 - argument
349:09 - position is going to be self.player
349:14 - player.rect.center
349:15 - and for the groups i'm just going to go
349:18 - with the visible sprites
349:20 - so now all we have to figure out is how
349:23 - to create
349:24 - this function here about this method
349:28 - so in my particle effect
349:32 - i want to create my particles we have a
349:35 - tag type we want a
349:38 - position
349:39 - and we want the groups
349:43 - and let's do this one as an exercise so
349:45 - now try to write this function that our
349:48 - animation player plays one particle once
349:51 - the enemy is attacking the player
349:58 - alright first of all we need animation
350:01 - frames again
350:03 - and we want to pick from self.frames
350:07 - and in there we have
350:10 - different kinds of attack as a key
350:13 - so
350:14 - we can just pass in the
350:17 - attack type
350:19 - actually i think since we are later
350:21 - going to use discrete particles for
350:22 - something other than attacks
350:24 - let's call this not attack type but
350:28 - animation type that makes a bit more
350:30 - sense
350:32 - and now we have our animation frames now
350:34 - i can just call particle effect
350:37 - we again need a position
350:40 - we need the animation frames
350:42 - and we are going to need our groups
350:46 - back in my level
350:47 - now i have all i need i think
350:51 - and
350:53 - let's try this actually let's check
350:55 - let's reopen my enemy
350:57 - and let's see if we are passing in the
350:58 - right information
351:00 - so when we call
351:03 - in my where is my actions
351:08 - so in my actions when we call damage
351:10 - player we pass in
351:13 - attack damage and attack type so attack
351:16 - type is what we need
351:17 - i guess let's try it and let's see what
351:19 - we get
351:20 - so again we have problems with the
351:22 - indentation i do not know what his
351:25 - problem is
351:26 - okay let's try now
351:28 - and now if the enemies hit us we get an
351:31 - error
351:32 - so three position arguments but four
351:33 - were given
351:35 - so let's have a look i think i already
351:37 - know the problem i forgot self
351:41 - okay now let's try this again and now we
351:44 - get proper animations and let's try
351:46 - different enemies
351:48 - so we get this one and we get sparks
351:52 - we get all of this i may have spawned
351:54 - too many enemies
351:55 - uh okay but this is looking pretty good
351:59 - let's get to this squid as well
352:03 - and this one okay yep you can definitely
352:07 - see it but yeah i pretty much spawn too
352:09 - many enemies but who cares right now
352:11 - okay so with that we have our basic
352:14 - particle system
352:17 - and what you can see in there as well
352:19 - we have used
352:21 - basically
352:22 - the attack animations and the leaf
352:25 - animations now there's two more that we
352:27 - need to figure out we have the monster
352:29 - death animation
352:30 - and we have the magic one
352:33 - the monster deaths we can already take
352:35 - care of the magic ones come in the next
352:38 - section
352:39 - so let's talk about the monster deaths
352:42 - and essentially all we have to do is
352:44 - play this animation once the monster is
352:46 - being destroyed
352:47 - all this really means
352:49 - is back in my level let me minimize this
352:52 - one
352:53 - i want to create let's call it trigger
352:57 - death
352:58 - particles
353:01 - and we need self and
353:04 - a position
353:06 - and a particle
353:09 - type
353:10 - and all i'm really going to do in here
353:12 - is get myself dot animation player
353:16 - and call
353:17 - create
353:18 - particle
353:20 - the decoded particles
353:23 - create particles yes particles
353:28 - and i get the particle type from the
353:30 - argument
353:31 - same for the position
353:34 - and they should always be in self dot
353:36 - visible sprites
353:37 - and now all i have to do is when i
353:40 - create all of the enemies again so all
353:42 - the stuff down here
353:43 - i'm going to pass this function in there
353:45 - as well so self dot trigger def
353:48 - particles
353:50 - and now in my nme class i guess let me
353:53 - minimize all the methods here as well
353:57 - we first want to create another
354:00 - parameter
354:01 - so let's call it trigger
354:04 - def
354:05 - particles
354:07 - this one has to be stored let's put it
354:10 - into play interactions self
354:12 - dot trigger def particles is going to be
354:16 - trigger death particles so now we can
354:18 - call this method from inside of the
354:20 - enemy
354:21 - actually let's do this as an exercise so
354:24 - try to figure out when to call this
354:26 - method with the different arguments
354:33 - all right so i want to trigger this when
354:37 - the enemy is dying so this line here
354:40 - and really what i want to call is
354:42 - self-taught trigger death particles
354:46 - and in here i need let me actually copy
354:49 - it from the particles so we're just
354:52 - calling the animation type a position
354:54 - and a group and in here let me open it
354:57 - in the level
354:59 - we want to trigger def particles we need
355:02 - a position and a particle type
355:05 - so in the enemy position and particle
355:07 - type
355:08 - now position is going to be
355:10 - self.rect.center
355:13 - and the particle type
355:15 - is just going to be
355:17 - self.monster
355:20 - name i think i called it all the way at
355:22 - the top uh monster name there we go so
355:25 - this is the name if you look at the
355:27 - particles
355:28 - monster name
355:30 - is the name of the particle or the name
355:32 - of the key
355:34 - and with that we should be good to go
355:39 - let's try
355:41 - so now if i tag
355:43 - any of these
355:45 - we're getting a proper animation
355:47 - so let's try it again
355:50 - looks pretty good
355:51 - and let's try with a different enemy
355:54 - u
355:56 - and this is also working so i assume
355:58 - they all work identically
356:01 - and with that we have most of our
356:03 - particles covered
356:05 - the one thing we still need
356:09 - is the
356:11 - magic so in the next section we are
356:14 - going to figure out the magic that one
356:15 - is going to be a bit more complicated
356:18 - but we are getting very close and i'm
356:20 - going to take a break before i go to the
356:22 - next section because those were way too
356:24 - many errors sorry about that
356:26 - so let's talk about the magic and for
356:28 - the magic we right now have two
356:30 - different spells
356:32 - one for fire and one for healing
356:34 - and those two do very different things
356:37 - the flame is going to work kind of like
356:38 - the sword that it damages enemies
356:40 - whenever there's contact and this is
356:43 - literally going to work like the sword
356:45 - in the sense that we are going to put
356:47 - the flame inside of the attackable
356:49 - sprites and then check for collisions
356:52 - so all we really have to do is place the
356:54 - flames and animate them for which we
356:56 - have most of the things we actually need
356:58 - now for healing it is getting a little
357:00 - bit easier because this one doesn't need
357:02 - any collision with the enemies we just
357:05 - have to spawn some particles and heal
357:07 - the player so increase the health
357:09 - but i want to create this in a slightly
357:11 - more flexible way so i'm going to put
357:13 - all of this into a separate class
357:15 - and let's implement this straight in the
357:17 - code i think that's going to make the
357:19 - most sense
357:20 - so here we are back in our project and i
357:23 - want to create a new file that i'm going
357:25 - to call magic dot
357:28 - pi
357:29 - and in here i want to do the usual so
357:31 - import pygame and from settings import
357:35 - all of it
357:37 - and now i want to create a class that i
357:40 - called magic player
357:42 - there's no need for inheriting anything
357:44 - and i want to create an init method with
357:47 - self and besides self we also want to
357:50 - get an animation
357:52 - player as a matter of fact this is the
357:55 - animation player we have created here so
357:58 - when we create this magic player it can
358:00 - play animations from our animation
358:02 - player so in here all i want is my
358:05 - animation player
358:06 - and that's going to be my animation
358:08 - player
358:09 - and now basically all i want to do i
358:11 - want to have one method for here
358:14 - needs self as always we're going to add
358:16 - more parameters later on but for now
358:18 - let's add pass
358:20 - and
358:20 - i want to create a flame
358:23 - that for now works in the same way that
358:25 - it doesn't do anything
358:27 - so right now we have two spells you
358:29 - could be adding more here if you really
358:31 - wanted to so how can we actually use
358:34 - this thing now well in my level let me
358:36 - actually move it all the way to the left
358:38 - because it's the most important one
358:40 - and let's minimize some methods so
358:43 - essentially what i do in here in my init
358:45 - method
358:46 - besides the animation player i also want
358:49 - to create a self.magic underscore player
358:53 - and this one is going to be my magic
358:56 - player
358:57 - and as the one argument we need the self
358:59 - dot animation player and for this to
359:02 - work we have to import
359:04 - from magic
359:06 - import magic player
359:09 - so now we have our magic player and as a
359:12 - matter of fact we already have a create
359:14 - magic method and then here we have the
359:16 - style the strength and the cost and this
359:19 - we can use to cast the magic
359:22 - so essentially what i want to do
359:25 - is if the style
359:27 - is equal to heal is one
359:30 - i want to cast some healing
359:32 - and if the style
359:35 - is equal to flame i want to do something
359:38 - else which for now is going to be pass
359:41 - but let's start with healing that's the
359:43 - easier one i think so we already have
359:45 - our self.magic player and all i want to
359:49 - do here is call heal
359:51 - so i want to call
359:53 - this heal method and i just realized
359:56 - this is a horrible way to spell magic
359:58 - so let me save this one and let's spell
360:00 - this one properly so magic dot pie all
360:03 - right now in my here i want to actually
360:07 - cast the heel but let's first check if
360:09 - this is working in the first place so i
360:12 - want to print heal
360:15 - and this should actually be working for
360:17 - now so let's try it let me go to my heel
360:20 - and we can see heal we still get the
360:22 - other stuff but that doesn't matter
360:24 - right now
360:25 - so i printed this one as well but i
360:28 - guess we can get rid of it we don't need
360:30 - it anymore at the very least we know
360:32 - this heal spell is going to work
360:35 - and in here now we have to figure out a
360:37 - couple of parameters
360:39 - so i first of all want to know my player
360:43 - then i want to know my strength
360:45 - then i need the cost and then i need the
360:47 - sprite groups
360:49 - and now when we call this thing we can
360:52 - pass all of this in here let me actually
360:54 - copy all of the parameters that's going
360:56 - to make things a bit easier
360:58 - my player is just going to be
360:59 - self.player in this one we need for the
361:01 - position
361:03 - now the strength and the cost
361:05 - i already have is just the strength and
361:07 - the cost up here so we can just pass
361:08 - both of those in here and we are good to
361:10 - go
361:11 - now finally for the groups this is going
361:13 - to be a list again
361:15 - and in here i just want to have myself
361:17 - dot visible sprites
361:19 - and since there's no collisions with
361:21 - these sprites we don't need anything
361:23 - else but for the flame we will also need
361:26 - our attack sprites
361:27 - but all right now we have all the
361:30 - arguments we need now we can actually
361:32 - work with this
361:33 - and the first thing we will need is if
361:35 - we can actually call this spell so if my
361:38 - player dot
361:40 - energy is greater or at very least equal
361:44 - to the cost and if that's not the case
361:46 - nothing should happen
361:48 - and once that is the case i want to get
361:51 - my player dot health
361:53 - and at plus equal the strength of the
361:57 - spell
361:58 - and besides that i also want to get my
362:00 - player.energy
362:02 - minus equal the cost
362:04 - so we're increasing the health of our
362:06 - player and decreasing the energy that's
362:09 - kind of how all of this works
362:10 - and i guess now we can actually try this
362:15 - so
362:16 - now let's select the magic spell
362:18 - it is working but now we
362:21 - if we press this again
362:23 - well we keep on increasing our health
362:24 - bar but
362:26 - once we're running out of enough energy
362:28 - we stop being able to cast it although
362:30 - the animation still plays but i kind of
362:32 - like the effect
362:34 - all right
362:35 - now what we have to figure out is that
362:37 - if our energy gets too large we don't
362:40 - want to overshoot on the health bar
362:42 - which also is fairly easy to do all we
362:44 - want to do is if our player health
362:48 - is greater than or equal to my player
362:52 - dot stats and then here health
362:55 - now this health is our maximum health so
362:59 - in the player i have it right here
363:02 - our stats is what we initiate the player
363:04 - with so 100 here right now is the
363:07 - maximum player health
363:08 - and then in our code
363:10 - we are keeping our actual current health
363:12 - in this variable or this attribute so
363:15 - this is going to be our max health
363:18 - if our current health is greater than
363:20 - our max health i just want to set my
363:21 - player health
363:23 - equal to my player dot stats and
363:27 - the health in here
363:28 - so now
363:31 - i can select my healing spell again now
363:33 - we have maximum
363:35 - and i made a typo this should be
363:38 - player
363:40 - now let's try this again
363:44 - and now we have our energy still
363:46 - decreasing but we cannot increase our
363:48 - health anymore
363:49 - and i guess here we have to make a
363:51 - decision
363:52 - do we want to play it to be able to
363:54 - increase the health or cast the healing
363:56 - spell if we already are at maximum
363:58 - health and i think most games handle it
364:01 - by allowing the player to cast the
364:02 - healing spell
364:03 - even though we have full health so i'm
364:05 - not going to worry about it
364:07 - but with that we have the basic healing
364:09 - mechanic now finally we have to spawn
364:12 - some particles
364:13 - and in my particles i have aura and heal
364:18 - and i want to spawn both of those once
364:20 - we are casting a spell
364:22 - hence we should be calling this
364:24 - animation player here twice and i think
364:26 - this could be a good exercise for you
364:29 - use from our particles they create
364:32 - particles method and spawn
364:35 - the
364:36 - aura particles and the heal particles
364:38 - every time we are calling the heel magic
364:40 - effect
364:47 - right so in my heel method i want to get
364:51 - myself dot animation player
364:54 - and create
364:56 - underscore particles
364:59 - so now we are calling
365:02 - this method here and this method has
365:04 - three arguments
365:07 - and in my magic i want to paste the
365:09 - paradise so animation type
365:11 - the first one is going to be aura
365:14 - then for the position
365:15 - this should be in the center of my
365:17 - player so i have my player
365:19 - i want to get the rect and the center
365:22 - and groups we are just going to get from
365:25 - the groups we pass in into the
365:27 - parameters
365:28 - so that's something we're going to
365:29 - figure out in a bit
365:31 - but now in my level i am already casting
365:35 - self.visible sprites in here so i have
365:37 - the right group
365:39 - and this should give us one particle
365:41 - animation let's try it actually
365:44 - so
365:45 - now we get the aura spell this looks
365:48 - pretty good and once you run out of
365:50 - energy it doesn't work anymore
365:52 - and now i also want the heal
365:55 - particle and for that i can just
365:57 - duplicate this line
365:59 - and
366:00 - right here for the particle type
366:03 - so
366:04 - now let's run this again
366:06 - and now we get the other particle as
366:08 - well
366:09 - what you could theoretically do give
366:11 - this heel extra effect an offset that
366:14 - can look kind of nice
366:16 - so in magic
366:18 - when you add the center
366:20 - you can add plus
366:22 - pi game dot math dot vector 2
366:27 - and
366:28 - 0 for x and something like negative 60
366:33 - or the height
366:34 - and now if you try this again
366:37 - this thing is now slightly on top um
366:40 - whatever you think looks better in my
366:42 - case
366:43 - i'm not going to care too much about it
366:45 - so let me just remove it
366:48 - so all right with that we have our
366:50 - healing spell although there's one more
366:52 - thing i would like to add because right
366:54 - now we don't really have any way to
366:57 - increase our energy once it's run out
367:00 - which doesn't feel very good so
367:03 - in my player
367:05 - let me minimize all of the methods here
367:08 - i want to create another method
367:10 - that i called energy
367:14 - recovery
367:15 - and we need self and nothing else
367:18 - and basically what i want to do in here
367:21 - is if
367:23 - self.energy is smaller or equal to
367:26 - myself dot stats
367:29 - and
367:30 - energy and then i want to get self dot
367:35 - energy and for now let's say plus equal
367:37 - one although that number is going to be
367:38 - way too high
367:40 - and now if our energy for whatever
367:42 - reason gets greater than our maximum
367:44 - energy
367:45 - so else i want to set self dot
367:48 - energy
367:49 - equal to self dot stats
367:53 - and energy
367:55 - and now we can call
367:57 - this method
367:58 - so self dot energy recovery
368:03 - and we should have recovering energy
368:07 - so now you can already tell our energy
368:09 - is increasing really fast
368:12 - i can't even cast the spell fast enough
368:14 - to deplete my energy but at the very
368:17 - least it's working but we do have to
368:18 - make some adjustments in my player first
368:21 - of all
368:22 - they shouldn't be smaller or equal they
368:23 - should just be smaller
368:26 - so now let's rise again and now our
368:28 - energy bar stops at the maximum but if
368:30 - we cast a spell it still recovers way
368:33 - too fast
368:35 - so instead
368:37 - i don't want to add one
368:39 - i want to add 0.01
368:43 - and now if i cast this again
368:45 - now we can see a small increase
368:49 - and even if i cast the magic
368:51 - it still keeps on increasing so this
368:53 - works quite nicely
368:55 - now what you can also do
368:57 - is use in my stats i have it
369:02 - right here in here we have magic
369:05 - and this one i think is best to use it
369:07 - for two purposes one is our magic damage
369:10 - and then the other is our magic recovery
369:12 - so i want to multiply
369:14 - this
369:16 - with self dot stats
369:19 - and magic
369:21 - so that way if we're leveling up our
369:23 - magic we do more damage and we recover
369:25 - energy faster
369:27 - so now let's try this again
369:29 - and we have
369:31 - i guess it's kind of fast but you can
369:32 - play with this around and see what works
369:34 - well but i quite like this
369:37 - so now we have magic recovery and we
369:40 - have our healed spell so next up we can
369:43 - work on the flames
369:44 - and those do get a bit more complex
369:47 - although not that much
369:49 - let me explain the basic logic before we
369:50 - start right now we have our player here
369:54 - and essentially what i want to do is i
369:57 - want to cast
369:58 - five different flame spells that go in
370:00 - the direction of the player
370:03 - so for example if our player is facing
370:05 - to the right
370:06 - i want to create one flame two flames
370:09 - three flames four and
370:11 - five flames
370:13 - and then each of those flames get a bit
370:15 - of an offset to create some randomness
370:16 - here to make it look better
370:19 - and well that's the general idea
370:23 - and let me leave the graphic open for
370:24 - now we're going to need it in just a
370:26 - second again but first of all in my
370:28 - flame i want to check
370:30 - if
370:32 - my player dot energy is greater or equal
370:37 - to the cost of the spell
370:39 - oh and i forgot we need the parameters
370:42 - again
370:43 - so in here
370:45 - i want to get my
370:46 - player i want to get my costs and i want
370:50 - to get my groups now importantly here we
370:52 - have no strength i'll show you later how
370:54 - to get that strength
370:56 - but now we can work on the cost
370:59 - and once we have cast a spell i want to
371:02 - get my player energy
371:04 - minus equal the cost
371:06 - so now we have the basic setup
371:09 - and now
371:11 - what we have to figure out
371:13 - is how to get this direction because
371:16 - this direction determines if the flames
371:18 - are spawned to the right to the bottom
371:20 - to the left or up so this direction is
371:24 - really important to figure out
371:26 - fortunately
371:27 - we can get it reasonably easy from the
371:29 - player itself
371:31 - and we have kind of done something
371:32 - similar before so what i want to get is
371:36 - if my player dot status
371:39 - and my player status i can get from
371:43 - let me minimize all of this again it's
371:45 - kind of hard to read
371:46 - so when i
371:49 - imported all of the player assets
371:51 - we created animations and in here we
371:54 - have all of our possible player states
371:56 - and i just want to get just the
371:58 - direction so up down left or right
372:01 - and if we have something like down
372:02 - underscore idle i want to get rid of the
372:05 - underscore idol
372:07 - actually let's do this as an exercise
372:09 - because we have done this like four
372:10 - hours ago so figure out how to split
372:13 - this string to only get the direction
372:15 - and ignore anything like idle or attack
372:23 - alright so what we need is the split
372:26 - method and in here the one argument we
372:28 - need is an underscore so that is going
372:30 - to return a list
372:32 - with the strings that we have split so
372:34 - for example
372:36 - if we had down idle we would get a list
372:38 - of down and idle
372:40 - and in my case i don't care about
372:43 - anything that comes after the first
372:44 - element so i just want to get the index
372:47 - of zero
372:49 - and if that happens to be
372:51 - let's say right
372:53 - then i want to create a direction
372:55 - that is going to be a vector so
372:57 - pygame.math.vector2
373:00 - and a vector facing to the right is 1
373:03 - and 0.
373:04 - and that way we can use the vector in
373:06 - some math and now i can just copy
373:09 - all of this
373:11 - three times to have it three times
373:15 - and turn this into an l
373:17 - if statement and then at the end we have
373:20 - an else statement
373:23 - now first of all here we have left and
373:26 - left should be negative one and zero
373:28 - then let's say we can go with up
373:31 - and up has zero on the x and minus one
373:34 - on the y and then finally for else let
373:37 - me copy this direction
373:39 - so else is going to be just one which is
373:42 - downwards so with that we have our
373:45 - different directions and i feel like
373:47 - putting all of those on the same line
373:49 - looks a bit cleaner although it's
373:51 - entirely up to you to do this
373:54 - but in my case when i have a one line if
373:56 - statement
373:57 - tends to feel better to have all of this
373:59 - on one line
374:00 - now we have our direction
374:03 - and now basically what i want to do
374:05 - since i want to spawn five flames i want
374:08 - to create a for loop
374:10 - so let's call it for i in range and then
374:14 - here you might be tempted to go
374:16 - something like five
374:17 - but i want to use this i for the offset
374:20 - so the first element should be a 1 and
374:23 - that way we can multiply this one with
374:26 - the tile size to get an offset of 64
374:28 - pixels to the player center so this
374:30 - shouldn't start at zero it should start
374:33 - at one
374:34 - and since we still want five elements it
374:36 - should stop at five and go up two but
374:38 - not include six
374:40 - so now we have a proper for loop and now
374:44 - for the math i have to split this thing
374:46 - into horizontal and vertical direction
374:49 - so if direction dot x exists so it's
374:52 - different from zero
374:54 - this is going to be horizontal
374:57 - and else it's going to be vertical
375:01 - and let's just add a pass here for now
375:04 - so we don't get an error now we can work
375:07 - on let's start with the horizontal one
375:10 - first of all i have to get an offset and
375:13 - this one is in the x direction
375:15 - and basically what i want to do let me
375:17 - draw this out
375:19 - let me get a bit of space
375:21 - here we have my player again and let's
375:23 - say my player is facing to the right so
375:26 - my direction is going to be a vector
375:30 - that is one and zero the one we have
375:33 - created
375:34 - up here
375:36 - and essentially what i want to do i want
375:38 - to multiply this with i
375:41 - so the number we got here
375:43 - so if the vector is positive this one is
375:46 - going to get us further to the right and
375:48 - if the vector is negative for example if
375:50 - it was going to the left this would give
375:52 - us an increasingly larger negative
375:53 - number
375:55 - but now we would still just go by pixels
375:57 - of one so we go one to the right two to
376:00 - the right three to the right and so on
376:02 - so i want to multiply all of this again
376:06 - with my tile
376:08 - size and that way the first flame is
376:13 - going to be right to next of the player
376:15 - and we have an offset here
376:18 - of 64 pixels which is going to be the
376:21 - tile
376:22 - size and then for the next flame since i
376:26 - now is 2 we go another 64 pixels further
376:30 - to the right
376:31 - and now the center of our rectangle is
376:34 - going to be here the arrow should be a
376:36 - bit let's put the arrow but here
376:39 - so essentially all i want to do
376:42 - i want to get my
376:45 - direction dot x and multiply it with i
376:50 - and now i want to multiply all of this
376:52 - with my tile size i think i called it
376:56 - yep tile size this one
376:58 - and now for each of the flames i want to
377:00 - get an x and a y
377:02 - and once we have all of that i want to
377:04 - call myself dot animation player
377:07 - and create particles
377:10 - and then in here
377:12 - i want to call my flame so in my
377:15 - particles the flame here
377:18 - and besides that i will need a position
377:21 - and my groups
377:23 - so i need my flame
377:25 - i need x and y
377:28 - and then i need the groups i am getting
377:31 - from the parameters so all we have to do
377:33 - is figure out the x and we have to
377:35 - figure out the y
377:37 - and this might be a good exercise for
377:39 - you so try to figure out where each
377:41 - individual flame needs to be spawned so
377:44 - where the center x and y is supposed to
377:46 - be
377:52 - alright so first of all i want to get my
377:54 - player.rect.centerx
377:58 - and
378:00 - player.reg.center y because my flames
378:02 - are always supposed to start from my
378:04 - player
378:05 - now for the x position
378:07 - i want to get my offset x and that's
378:10 - basically all i need
378:12 - and for my y position since we're only
378:15 - moving in the horizontal direction we
378:18 - can just leave it as it is
378:20 - and that is basically all we need so now
378:24 - in my level
378:25 - when i call flame i can call self.magic
378:29 - player
378:32 - and the arguments i passed in here
378:35 - was player cost and groups
378:38 - so player is going to be self.player
378:40 - again cost we already have and groups
378:44 - let's say for now this is only going to
378:46 - be self dot visible sprites
378:48 - the attack sprites we do later let's
378:50 - first figure out the flames by
378:51 - themselves so now if i run this
378:54 - we are getting an error because the dict
378:56 - has no attribute split
378:58 - so this is going to happen in my magic
379:02 - and self.stats it shouldn't be stats
379:05 - it should be stat twist
379:08 - so now if i run this down isn't going to
379:10 - work but if i look to the right we are
379:12 - getting some flames and if i look to the
379:14 - left we're also getting some flames
379:16 - so this seems to be working just fine
379:20 - and let's try one more time we do need
379:22 - enough energy there we go so i'm happy
379:24 - with that although there's one small
379:27 - change i would like to do right now i
379:29 - feel like those flames look too
379:31 - predictable like they're too much in one
379:34 - straight line
379:35 - so i want to give them a bit of a random
379:38 - offset for both x and y
379:40 - and for that i need a random number
379:42 - generator so from random import rand
379:48 - and now for both of these positions
379:51 - i want to add rand
379:55 - and essentially what i have done i went
379:57 - from negative tile size
380:00 - divided by 3
380:03 - all the way up to tile size
380:06 - divided by 3 except in the positive
380:09 - direction
380:10 - and this i have also done for the y
380:14 - position
380:15 - so essentially tile size is 64. if you
380:19 - divide this by 4 you get a number around
380:20 - 21. and that way if we have a larger
380:23 - tile size we get a larger offset
380:25 - so let's try this now
380:27 - and this looks a bit more random i kind
380:30 - of like that one
380:31 - so with that
380:33 - we have the horizontal flames
380:36 - now all we have to do is do the same
380:38 - thing for the vertical ones
380:40 - so let me copy all of this we can pass
380:43 - it in here
380:44 - and now instead of offset x we have
380:46 - offset y
380:47 - instead of direction.x we want to get
380:50 - direction.y
380:52 - and the rest for this line can stay the
380:53 - same
380:54 - now for x and y
380:56 - we need
380:58 - the offset x removed from the x position
381:02 - and added to the y position
381:04 - and this should now be offset y
381:07 - and besides that we don't need anything
381:10 - else so let's try it now
381:13 - so this side is working
381:15 - this side is
381:16 - working let's wait for some energy this
381:19 - side is working as well nice so now we
381:22 - have our flame spell it doesn't do
381:24 - anything just yet but we can work on it
381:27 - i guess let's work on it right now
381:29 - first thing that we have to work on is
381:32 - we have to place each of our flames also
381:35 - inside our self dot attack sprites
381:39 - so let's try this but we will get an
381:41 - error once we attack an enemy
381:43 - so for the grass it should work and it
381:45 - does it's actually really cool effect so
381:47 - this is pretty good but now if we attack
381:49 - an enemy let's say this one
381:51 - we get an error that particle object has
381:54 - no attribute sprite type
381:56 - and this error happens
381:58 - in player attack logic
382:01 - so
382:02 - player attack logic
382:04 - in here
382:05 - and in here we have target sprite get
382:08 - damage
382:09 - and in our enemy
382:12 - let me minimize all of the methods
382:15 - in here we have where's get damage get
382:18 - damage is here
382:19 - so in here
382:21 - we need an attack type and for our
382:24 - weapons we have a sprite type called
382:26 - weapon and this sprite type
382:28 - we are passing in here so our attack
382:31 - sprite dot sprite type is the attack
382:34 - type in the enemy
382:36 - the problem is our particles don't have
382:39 - one so in this particle effect
382:41 - we don't have a sprite type
382:44 - we can give it one though so self dot
382:47 - sprite
382:48 - underscore type
382:50 - is going to be
382:52 - magic
382:54 - and magic is a bit broad but right now
382:56 - we only have a single attack spell but
382:59 - if you had multiple types of spells you
383:01 - could just get another parameter in here
383:04 - and there classify what kind of sprite
383:06 - type you have
383:07 - or you could even get a whole new
383:09 - particle effect
383:10 - that inherits from this particle effect
383:12 - and this one has a sprite type for
383:14 - different kind of spells so you can
383:16 - certainly make this very flexible with
383:17 - just a bit more effort but in my case i
383:20 - don't really mind
383:22 - and now let's try this actually to see
383:24 - what's happening now so now if i attack
383:25 - an enemy we are actually getting
383:28 - something but you see now it doesn't
383:30 - actually damage the enemies in any
383:33 - meaningful way
383:34 - and the reason for that is in my enemy
383:37 - i have weapon and we're reducing the
383:39 - health
383:40 - but
383:41 - when we have anything else nothing is
383:43 - really happening so in here we want to
383:46 - do something else
383:48 - and in here we have to figure out how
383:50 - much damage we are going to get
383:53 - but first of all we have to get our
383:55 - health regardless of what we are doing
383:57 - but besides that
383:59 - i want to get from my player which we
384:01 - still have available from the parameters
384:03 - so we're going to pass this in here and
384:06 - now from this player i want to get
384:09 - full
384:10 - magic
384:12 - damage
384:13 - like we have done just above so now in
384:16 - my player
384:18 - i
384:18 - right below get full weapon damage
384:22 - actually let me open this method just
384:23 - for reference
384:25 - so in here define get underscore full
384:29 - magic
384:31 - damage needs self and nothing else
384:34 - and in here again we need a base damage
384:39 - and we need let's call this one is spell
384:42 - damage
384:43 - and then we are going to return
384:45 - the
384:46 - base damage
384:48 - plus
384:49 - the
384:50 - spell
384:52 - damage
384:54 - and well for our base damage we have
384:56 - self.stats
384:58 - and this one is magic
385:00 - and then for our spell damage we have
385:03 - magic
385:04 - data
385:06 - and in here i want to get self dot
385:11 - magic
385:13 - and then from that i want to get what i
385:16 - called the strength
385:18 - so now this should be working let's try
385:22 - so now if i attack an enemy they should
385:25 - theoretically disappear let's try it
385:27 - again
385:30 - um okay this needed okay let's try this
385:34 - properly without reducing for the flame
385:37 - damage the
385:38 - energy cost so that way we can call it
385:41 - indefinitely so let's try this again
385:43 - let's use this one
385:45 - and let's do it again i'm not sure how
385:47 - much damage i gave ah there we go so it
385:49 - does indeed work and everything else
385:52 - still works just fine cool
385:56 - so with that we also have our proper
385:58 - flame spell
386:00 - so now in my player let me minimize all
386:03 - of the methods again
386:05 - and i think with that we have our magic
386:08 - figured out so that's another major part
386:10 - of this game and now it's actually
386:13 - coming together really nicely
386:16 - and we can call different spells
386:18 - different attacks
386:20 - and
386:21 - all of this is working very very nicely
386:24 - cool we are actually getting very close
386:27 - to being done
386:28 - the one thing we still have to figure
386:30 - out is the upgrade mechanic
386:32 - and that's going to be the next major
386:34 - section actually the last major section
386:38 - all right now how can we implement an
386:41 - upgrade mechanic and there are a couple
386:43 - of things that we need first of all
386:45 - something i haven't done yet our player
386:47 - should get some experience once we are
386:49 - destroying an enemy that one's really
386:51 - easy to implement and once we have that
386:54 - the basic upgrade mechanic works like
386:57 - this in our self.stats we want to be
387:00 - able to upgrade any of the key value
387:02 - pairs
387:03 - so for example we want to increase
387:04 - health by 20
387:06 - and every time we are doing that we are
387:08 - reducing the amount of our experience by
387:11 - a certain amount
387:12 - so i guess it's not really experience
387:14 - it's more like salts from dark souls but
387:17 - you get the mechanic
387:18 - and i guess the only really complicated
387:20 - bit in all of this is the gui for the
387:22 - upgrade mechanic because for that we
387:25 - need quite a few different bits
387:27 - but i guess let's do it step by step and
387:30 - let's first add an xp mechanic and then
387:32 - give our player a bit more data
387:35 - so here we are back in the code
387:37 - and i want to close down a couple of
387:39 - things so we don't need magic anymore we
387:42 - do need the enemies we don't need
387:44 - particles
387:45 - and settings can stay open i guess
387:48 - so in my player
387:50 - in the ending method i have down here
387:53 - right now my stats
387:55 - and i am going to need a few more stats
387:59 - the first one is going to be max stats
388:02 - so this is the maximum amount of health
388:05 - or energy or attack damage that my
388:07 - player can have
388:09 - and i realized speed of 12 was a bit
388:12 - high so let's go with 10.
388:14 - i also want to have an upgrade cost
388:18 - so this is going to be how expensive
388:20 - each upgrade is going to be
388:23 - and now just to get started let's
388:25 - increase our experience to something
388:27 - like 500 so we can work with this a bit
388:30 - more easily
388:32 - and now the first thing we are going to
388:35 - need is that our player should get some
388:37 - experience every time we are destroying
388:39 - an enemy
388:40 - and for that in our level let me
388:43 - minimize
388:44 - all the methods in here again
388:47 - i want to create
388:49 - another method and that's just going to
388:52 - be add
388:53 - xp
388:55 - and this one needs self and
388:58 - amount and really all we're doing in
389:01 - here is we are getting our self dots
389:05 - player dot exp
389:07 - and plus equal
389:09 - the amount
389:10 - and now this method i want to place into
389:14 - the enemies
389:16 - so when we are creating all of our
389:18 - enemies
389:20 - the final method i get is self dot add
389:23 - xp
389:24 - and now in my enemies
389:28 - when they die so check def
389:31 - in here i also want to call self dot add
389:36 - exp
389:37 - and then we can add the amount but first
389:39 - of all in the parameters we have to add
389:43 - add
389:45 - exp
389:47 - and then let's say player interaction
389:50 - self dot add exp
389:53 - and now we can actually call it
389:55 - so add exp now we have to figure out how
389:58 - much experience the enemy should give
390:01 - and that information we have
390:04 - up here
390:05 - so for each monster we have a custom
390:08 - experience so we can just copy this one
390:11 - and place it in here so self dot exp
390:16 - and now this should actually already be
390:18 - working let's try
390:19 - and we are getting an error
390:21 - so enemy object has no add experience
390:24 - which no enemy
390:27 - and it's in the level and
390:30 - let's call it self.exp self.exp
390:35 - and then in my enemy
390:38 - the
390:39 - parameter is called add exp
390:42 - and oh i just forgot
390:44 - add exp okay now let's try this again
390:48 - there we go and now if i take an enemy
390:54 - there we go and we get some experience
390:57 - trice again there we got another 120
390:59 - experience
391:01 - and let's try this one again and we get
391:04 - even more experience and i can also heal
391:09 - and
391:10 - well
391:11 - technically we should have just died but
391:13 - in my case i didn't really implement the
391:15 - death mechanic because well the game is
391:17 - already getting complex as it is but if
391:20 - you had an actual game this could lead
391:22 - you to an over world or something
391:24 - alright now
391:26 - in our enemy we have the ad experience
391:29 - so we can close enemies
391:31 - and minimize the create map method
391:35 - and add xp as well
391:38 - so all right now with that our player
391:41 - has the experience and we have the data
391:43 - now all we have to figure out is how to
391:46 - increase the stats of our player
391:48 - and for that i want to create a separate
391:51 - menu
391:52 - and that i actually want to do in my
391:54 - main file because in here i have my
391:57 - event loop
391:58 - and what i want to check in here is if
392:02 - event dot
392:04 - type
392:05 - is equal to pygame dot
392:08 - k down so we're pressing any button
392:11 - and if event
392:13 - dot key
392:15 - is equal to pygame dot k underscore m so
392:19 - my case the m button is the upgrade menu
392:22 - button
392:24 - and if we are pressing that
392:26 - i want to run myself.level and then
392:28 - there i have a method called toggle or i
392:31 - want to create a method
392:33 - so now in my level i can create a toggle
392:36 - method
392:38 - actually let's call it toggle menu that
392:41 - feels
392:42 - a bit more appropriate so toggle menu
392:46 - and if i'm doing that
392:49 - self dot toggle underscore menu
392:52 - wii itself and nothing else
392:54 - and basically all i want to do i want to
392:57 - create
392:58 - self dot game underscore paused
393:02 - is going to be not
393:04 - self dot game
393:07 - underscore paused
393:10 - and in my init method let's say
393:13 - all the way in the basic setup
393:16 - self.gamepast
393:18 - by default is going to be false
393:20 - and now what i can do
393:22 - in my
393:25 - run method of this level
393:28 - essentially what i want to do in here is
393:31 - if
393:32 - gamepost is true
393:34 - i want to
393:35 - display the upgrade menu
393:39 - and if that is not the case i want to
393:42 - run the game
393:45 - and now we have to figure out what to
393:47 - draw in here what to draw on here and
393:50 - what to draw all the time so let's go
393:53 - through it one by one
393:54 - our visible sprites we always want to
393:57 - draw even if the game is paused however
394:00 - we only want to update them if the game
394:02 - is not paused
394:04 - and same with the visible sprites and
394:08 - the enemy update
394:10 - then the attack logic should also be in
394:12 - here
394:13 - but my ui display i always want to
394:16 - display even if the game is paused
394:18 - because there we can see the experience
394:20 - so
394:21 - now we can get rid of all of those
394:24 - and now we have to figure out what to do
394:27 - when the game is paused and for now i
394:29 - just have pass in here
394:31 - and to actually get the full menu i want
394:34 - to create yet another python file and
394:36 - this one i called upgrade dot
394:39 - pi
394:41 - that is actually going to be our final
394:43 - new file so we are getting very close to
394:45 - finishing this project
394:48 - and in here as always we have to import
394:51 - pi game and from settings import
394:55 - everything
394:57 - now i have my class
395:00 - upgrade
395:02 - there is no need for inheritance and in
395:04 - here i want it under init method with
395:08 - self and i want to place the player in
395:10 - here as the parameter
395:13 - and in this method for now i want to
395:15 - have a general set up and first of all
395:18 - we need to display underscore surface
395:22 - that's just going to be pygame dot
395:24 - display dot get underscore surface
395:28 - and then self dot player is going to be
395:31 - my player
395:32 - we will need quite a bit more but that
395:35 - comes later
395:36 - the really important thing i want to
395:38 - have for now is a method called display
395:42 - this one doesn't need any arguments
395:45 - and for now i just want to make sure we
395:48 - can see what we are doing
395:51 - so for now i just want to get myself dot
395:54 - display surface dot fill and let's say
395:57 - we're going to fill it with black so
395:59 - whenever we have this menu open we're
396:01 - going to fill the screen with black and
396:03 - once it's gone we are not going to fill
396:05 - it
396:06 - so essentially what that means in my
396:09 - level
396:10 - i want to
396:11 - from
396:12 - upgrade
396:14 - import
396:15 - upgrade i believe i called it yep
396:18 - upgrade and now in the innit method
396:21 - all the way down here i guess this is
396:23 - also user interface so self.upgrade
396:27 - is going to be upgrade
396:30 - and this one is going to need self dot
396:33 - player
396:34 - so let's minimize this one now and now
396:37 - in my run method
396:38 - i want to run
396:40 - self dot upgrade
396:42 - dot display
396:44 - so now we can toggle at least in theory
396:47 - between a menu so in my game
396:50 - we get game paused not defined in my
396:53 - level.run because this should be
396:56 - self dot game paused
396:59 - there we go the game runs now if i press
397:01 - m it goes to black
397:03 - and if we press it again we go back to
397:05 - the same stage actually let me get
397:07 - chased by some enemies
397:08 - now press m and now we return back to
397:11 - the same stage where we were earlier
397:14 - so this is actually a pause mechanic
397:16 - and this keeps on working just fine cool
397:19 - and the reason why this is working
397:22 - is because when our game is paused we
397:25 - are not updating the main part of our
397:26 - game anymore and because of that the
397:29 - game picks up once we are stopping this
397:32 - so this is a nice pause mechanic
397:35 - so all we have to figure out now is how
397:38 - to create a proper menu
397:39 - and that is going to become a slightly
397:43 - longer section
397:44 - so i guess let's work through it one by
397:46 - one
397:47 - now first of all
397:48 - we need some input
397:51 - and for that again we need keys and
397:54 - pygame dot key dot get underscore
397:58 - pressed
397:59 - and then if keys
398:02 - and pi game
398:04 - dot k underscore right
398:08 - then
398:09 - let's say for now we just want to pass
398:11 - and
398:13 - l if keys
398:15 - pi game dot k
398:18 - left we want to move left but for now
398:20 - this is going to be passed as well
398:22 - and finally
398:24 - i want to check if
398:26 - keys and
398:28 - pie game that's not how you spell that
398:31 - pie game dot k
398:32 - space
398:34 - we also want to pass but this is going
398:36 - to be our select
398:38 - button
398:39 - and let's spell keys correctly
398:42 - all right so now we have to figure out
398:45 - how to actually implement these
398:48 - mechanics for left and right
398:50 - and let me explain how this is going to
398:52 - work i am basically going to create a
398:54 - selection index and this selection index
398:57 - can be a number between 0 and 5
399:00 - and that is the amount of stats my
399:03 - player has so once that could be health
399:05 - the other set could be energy and then i
399:07 - have speed attack and magic
399:10 - and then for each of those five i'm
399:12 - going to create a box and each of those
399:14 - boxes is going to be one class
399:17 - so three four
399:19 - five
399:21 - and essentially what i'm then going to
399:23 - do is i'm going to have a selection
399:25 - number that let's say right now it could
399:28 - be
399:29 - one and if it is one we're going to
399:31 - select the box with the index number one
399:34 - if it is three we're going to select
399:36 - this box here
399:38 - so that way when we press left or right
399:41 - we are either increasing or decreasing
399:44 - this number and that's then all we need
399:45 - to do
399:47 - okay but for that to work we need a
399:49 - couple of things
399:51 - first of all we need our self dot
399:54 - attribute
399:56 - number
399:57 - and all i really want in here is the
399:59 - length of my player dot stats
400:02 - so the length of in my player
400:06 - i want to get this dictionary and in
400:08 - there i have these different values and
400:12 - i guess while we're at it i can also get
400:14 - the names so self dot
400:17 - attribute
400:18 - names
400:21 - and this one is just going to be a list
400:25 - with my player.stats
400:28 - and from that i just want to get the
400:30 - keys
400:32 - and finally i am also going to need a
400:34 - font just like we needed one for the ui
400:37 - so self.font and in here we have pygame
400:40 - dot font dot font
400:42 - and now we can use the same font from
400:45 - our ui
400:46 - so ui font and ui font size
400:50 - so ui font and ui font size
400:55 - and that would then be all the basic
400:57 - information we are going to need but
401:00 - besides that
401:01 - we are also going to need let's call it
401:04 - a selection
401:06 - system
401:09 - and that is the number i just talked
401:11 - about that we're going to increase from
401:12 - zero to five and this i called self dot
401:15 - selection
401:17 - index and by default it's going to be
401:19 - zero
401:20 - and since we're going to move it we are
401:22 - also going to need a timer so self dot
401:25 - selection underscore time
401:28 - by default it's going to be none
401:31 - and then self dot can underscore move
401:34 - and by default this one is going to be
401:36 - true
401:37 - and now in my keys the most basic thing
401:40 - i want to do is self dot selection index
401:43 - not selection time selection index
401:46 - plus equal one
401:48 - if we are going to the right
401:50 - or
401:51 - minus equal one if we are going to the
401:53 - left
401:54 - but now for the proper timer
401:57 - we also want to set
401:59 - self dot can move
402:02 - to false
402:04 - and self dot selection
402:07 - time
402:08 - is going to be pygame dot time dot get
402:11 - underscore ticks
402:13 - and these two lines we need for both of
402:17 - the movement
402:20 - so in there and there we go
402:23 - and now when we call left and right
402:26 - besides the button we also want to check
402:29 - and self can move
402:31 - so this is basically our basic movement
402:34 - that we have implemented a couple of
402:36 - times by now
402:37 - and now finally
402:40 - we need a selection underscore cool
402:44 - down and this one again it's just going
402:47 - to be a basic timer so if not self dot
402:51 - can move
402:53 - then i want to get my current underscore
402:55 - time it's going to be pygm.time.get
402:58 - underscore ticks
403:01 - and then finally if my current time
403:05 - minus myself dot selection time
403:08 - is greater or equal than a certain
403:10 - number
403:11 - um let's say for this one 30
403:12 - milliseconds
403:15 - once we have that can move is back to
403:17 - true
403:19 - and now
403:21 - we can get rid of this surface fill
403:24 - and just replace it with self dot input
403:29 - and self dot selection
403:32 - cool down
403:34 - actually let's
403:36 - do this slightly differently this self
403:38 - dot can move
403:40 - probably makes more sense when we put it
403:44 - as a general one
403:46 - all the way at the top
403:48 - and then check all of the other keys
403:50 - sorry about that
403:52 - this makes more sense
403:53 - because there's one more thing that we
403:55 - do have to check so if we are all the
403:57 - way to the right
403:59 - we don't want to be able to go any
404:01 - further so i'm going to check and self
404:04 - dot selection index
404:06 - is smaller than myself dot attribute
404:10 - number
404:11 - and this one needs to have negative one
404:13 - because of the way we are counting in
404:15 - the length method
404:17 - and then the same thing for left so self
404:20 - dot
404:22 - selection
404:23 - index
404:25 - except this one needs to be greater or
404:27 - equal than one
404:29 - at the very least
404:31 - and now finally
404:33 - we can also start
404:36 - with our space button so in here
404:41 - i also want to run the timer
404:43 - and what i want to do for now is just to
404:45 - print my self dot selection index so at
404:49 - least we have something
404:51 - and let's try all of this is working
404:53 - i press m
404:55 - the game pauses now if i press space
404:57 - you can see zero in the bottom left if i
405:00 - press right we get to four
405:03 - and if i press down we get back to zero
405:05 - so something with the input doesn't work
405:08 - just yet
405:09 - and the reason is that this selection
405:11 - index
405:12 - should be
405:14 - selection time
405:17 - now let's try this again if i press m
405:19 - never press space we just get one if i
405:21 - press to the right
405:23 - we get one result
405:25 - up to four
405:27 - but if i go back
405:30 - we get
405:32 - the numbers that i actually wanted cool
405:34 - so this is working now
405:36 - okay this really is a long tutorial
405:39 - now i can minimize my selection cooldown
405:42 - i don't need it anymore
405:45 - and for now let's minimize the input
405:47 - method as well so we can see a bit
405:49 - better what's going on
405:51 - now basically what i want to do let me
405:54 - draw this out
405:56 - here we have our entire game window
406:01 - and what i want to do i want to spawn a
406:03 - couple of boxes over
406:06 - this thing
406:07 - five in total
406:08 - and each of these boxes should have some
406:11 - kind of bar
406:12 - on the inside that shows us how much we
406:15 - have and on top we want to have the name
406:18 - of that stat and at the bottom here we
406:20 - want to have the cost
406:22 - and i'm going to create a class for each
406:24 - of these boxes so each of these red
406:26 - boxes is going to be one instance of a
406:29 - class
406:30 - but to be able to do that i first have
406:32 - to figure out a couple of dimensions
406:35 - about the screen so i have to know how
406:38 - wide each of these boxes have to be and
406:40 - how tall they have to be
406:42 - and for that i need to do some math so
406:44 - let's work on that first
406:47 - and we can do this straight in the init
406:49 - method let's do it right here
406:52 - so i called the class item
406:54 - and we want to get item dimensions
406:57 - and we need the height
407:00 - we need self dot width as well
407:03 - and height is the easier one
407:05 - i basically want to get myself dot
407:08 - display surface
407:10 - and in here get size
407:12 - and this is going to give us x and y and
407:15 - we only care about y
407:17 - and i am just going to multiply this by
407:21 - 0.8
407:22 - so we have most of the screen but we are
407:24 - losing about 20 percent so we have a
407:27 - offset essentially
407:29 - now for the width i can actually copy
407:32 - most of this
407:34 - except this one should be zero so we get
407:36 - x
407:38 - and i'm going to divide this
407:40 - by
407:41 - six
407:42 - which is my attribute number plus one
407:45 - so that way i have my five elements and
407:48 - the sixth one or the width of the sixth
407:50 - one is going to be the padding between
407:52 - them
407:53 - and now i can create
407:56 - another method
407:58 - and i call this one create
408:00 - items
408:02 - and for this one we don't need any
408:04 - arguments
408:05 - and essentially let me create a class
408:07 - right now
408:09 - i want to create a class that i called
408:11 - items or item
408:13 - and each of those is going to be one box
408:17 - that we can upgrade
408:18 - and for this one
408:20 - i need an init
408:22 - method
408:23 - and then here i want the left i want the
408:25 - top i want a width i want a height
408:28 - i want an index so we know what is
408:30 - selected and i want a font
408:34 - so all of this is what we have to figure
408:36 - out in this create items
408:39 - i guess for now let me add pass in here
408:41 - so python doesn't throw an error
408:45 - okay
408:46 - now first of all i want to store all of
408:48 - these items in the list so let's call it
408:50 - self dot item underscore list for now
408:53 - it's just an empty list
408:56 - and now i just want to go for i let's
409:00 - sorry for item
409:01 - in range self dot
409:04 - attribute number
409:06 - and now i have to figure out the
409:08 - horizontal
409:09 - position
409:10 - i need to figure out the vertical
409:13 - position
409:15 - and then i have to use that to create
409:16 - the object
409:19 - so let's do the last step first
409:22 - item is going to be my item
409:25 - and in here i want to have a left the
409:28 - top
409:29 - then the width i already have that's the
409:30 - one i have up here so
409:33 - self dot with
409:35 - and self dot height
409:38 - then the index we're also going to get
409:40 - in just a second and then the font we
409:42 - already have that's just self dot font
409:44 - so essentially we have to figure out the
409:46 - left the top and the index
409:48 - and once we have all of that
409:51 - i can get myself dot item list dot
409:54 - append
409:56 - and my item now we have to figure out
409:58 - the horizontal and the vertical position
410:01 - and the vertical position is kind of
410:04 - easier so let's start with this one and
410:05 - here we need the top
410:07 - and right now we know let me draw this
410:10 - actually
410:11 - so if this is the entire height of our
410:15 - game let's call this h so this is the
410:17 - entire window in specific numbers this
410:19 - would be 12
410:20 - 80.
410:22 - and we know that 80
410:25 - of this so let's say roughly this one is
410:28 - going to be our current self.height so
410:31 - this number here
410:33 - so we have 10
410:35 - here
410:35 - and we have 10
410:38 - up here
410:39 - now because i want my boxes to start on
410:43 - this line
410:44 - essentially all i really need is 10
410:47 - of the screen height starting from the
410:49 - top of the screen that's the only number
410:51 - i need for the top
410:53 - and this one is really easy to get so i
410:56 - need self dot display surface dot get
411:01 - underscore size
411:03 - i need the y number again
411:05 - and now
411:07 - i have to multiply this by 0.1 i guess
411:10 - you could make this system a bit more
411:11 - flexible by putting these two numbers
411:13 - inside of one variable but i'm not going
411:15 - to worry too much about it
411:17 - but all right with that we have our top
411:20 - now our left unfortunately is going to
411:23 - become a bit more difficult
411:25 - i guess first of all i want to have my
411:28 - full
411:29 - width
411:30 - and this one i can actually copy it
411:34 - is this number here except we want to
411:36 - have zero
411:38 - so right now we know the entire width of
411:40 - our window
411:41 - then i want to know by what increment i
411:45 - want to move to the right
411:46 - and let me actually draw this so right
411:49 - now
411:50 - this here
411:51 - is the entire height of our game so
411:53 - let's call it h
411:55 - oh and this one is actually 1280. the
411:58 - height before window is 20. the height
412:00 - of our window is 720. uh well i guess
412:03 - you get the idea but anyway this one
412:05 - right now is 1280 pixels wide and this
412:08 - is what i got with
412:10 - full width
412:12 - and now what i essentially want to get
412:15 - is i want to have
412:17 - a bit of an offset from the left
412:19 - and then i want to have my first element
412:21 - so let's start here with the left of the
412:23 - first element
412:24 - the first element should then go let's
412:26 - say roughly to here
412:28 - and then i want to have a bit further to
412:30 - the right another element and this
412:33 - should then be the left of the second
412:34 - element
412:35 - or i guess to be a bit more specific
412:37 - this should be
412:39 - the index zero and this should be the
412:41 - index one that is a bit easier to
412:43 - comprehend
412:44 - and this number is then going to be the
412:46 - increment it's basically the distance
412:48 - from the left to get the left side of
412:50 - each item
412:52 - and this number i basically get with my
412:54 - full width
412:56 - divided by myself
412:58 - attribute number
413:00 - so right now we are splitting the entire
413:02 - window into five different parts
413:05 - and with all of the information i can
413:07 - get my left
413:09 - so now all i have to do is i want to get
413:12 - my current item number so this could be
413:14 - either 0 1 2 and so on
413:16 - and multiply this
413:18 - by my increment
413:20 - and then to what's that
413:22 - i want to get my increment
413:25 - and from that subtract my self.width
413:28 - of each of the items and floor divide
413:30 - this by two
413:32 - and that way we are offsetting each of
413:34 - the elements a little bit further to the
413:36 - left
413:36 - and well with that we have our left side
413:41 - now finally i need the current index and
413:44 - the best way to get the index is just to
413:46 - use
413:47 - the
413:48 - enumerate method
413:51 - and then we get item and index
413:56 - so with that we have the basic setup to
414:00 - create each of these items
414:02 - and let's actually draw them so we see
414:04 - what's going on i know it's getting a
414:06 - bit theoretical
414:08 - so basically what i want to do in the
414:10 - init i first of all
414:13 - want to create a self dot rect
414:17 - and this is just going to be a pygame
414:19 - dot rect and then here we can just pass
414:22 - in left top width and height
414:25 - and besides that i also want to get
414:27 - myself dot index
414:29 - and that is going to be
414:31 - the index
414:33 - and i want to get myself dot font and
414:35 - that's going to be the font
414:37 - and now each of these items is going to
414:40 - have their own
414:42 - display method
414:44 - and for this one besides self we need
414:47 - the surface to draw on so our display
414:49 - surface
414:50 - then
414:51 - we need this selection underscore num so
414:55 - what our currently selected item is so
414:57 - we can highlight it
414:58 - and then we need the values we actually
415:00 - want to display so be aware the item is
415:03 - essentially a box that could display any
415:06 - kind of information whatever we pass in
415:08 - so we actually have to pass in our stats
415:10 - so i want to have a name
415:12 - a value
415:14 - a max
415:16 - value
415:17 - and a cost
415:18 - and these are the informations i want to
415:21 - draw
415:22 - now that we have all of that for now
415:25 - let's just draw some basic thing
415:29 - all i want to do is pygame.draw.rect
415:34 - and we get the surface from the
415:36 - parameters
415:38 - then for the colors for now i just want
415:40 - the background color
415:42 - from my settings oh actually in my
415:44 - settings we need to import a bit more
415:45 - information
415:47 - because in here the upgrade menu has its
415:50 - own colors
415:51 - so
415:52 - finally a tiny bit more this is the last
415:54 - bit we need
415:56 - but
415:57 - for the background i just want to have
416:00 - the ui
416:01 - bg
416:02 - color so let's copy this one and paste
416:06 - it in here
416:07 - and finally
416:09 - self.wrecked the one we created
416:14 - up here here
416:16 - so for now we're just drawing a basic
416:18 - rectangle to see if something is going
416:20 - on in the first place
416:22 - and now finally
416:24 - for my display
416:25 - i can just draw all of them
416:29 - so i can for item in self dot item list
416:35 - i can do something but first of all i
416:37 - forgot to actually call self.createitems
416:40 - and let's do it below
416:43 - this one so self.create
416:45 - items
416:47 - and let's call this section just item
416:50 - creation
416:51 - okay we are nearly done sorry this
416:54 - section gets a bit more complex it's
416:55 - kind of hard to visualize
416:58 - but now in my for loop i just want to
417:01 - get item dot display
417:05 - and here we need the different arguments
417:07 - so we need all of these arguments
417:11 - let me copy them so surface is going to
417:15 - be myself dot display surface
417:19 - selection number for now we're not going
417:20 - to care about it it's going to be 0.
417:23 - name let's say for now we can just write
417:25 - test for value it's going to be 1 max
417:27 - values let's say 2 and cost 3. these
417:30 - numbers for note don't matter i just
417:31 - want to see if this is working in the
417:32 - first place
417:34 - but
417:35 - now
417:36 - we should see something so let's try to
417:39 - run main.pi and press m and there we go
417:43 - we can see our five different boxes so
417:45 - at the very least this is working and
417:48 - i'm fully aware
417:49 - that the logic here is getting a bit
417:52 - more complex
417:53 - so i would recommend you to go over this
417:55 - if you're struggling with this so
417:57 - especially to create items
417:59 - can be a bit finicky
418:01 - but well let's continue with what we
418:04 - have
418:05 - now the first thing i want to do is to
418:07 - actually display the names of what we
418:10 - are dealing with so for now i want to
418:11 - show the name of the attributes and i
418:13 - guess what we added we can show the cost
418:16 - and for that to work
418:18 - we have to
418:20 - let's call it get
418:22 - attributes
418:24 - and we will need the name
418:26 - we will need the value
418:31 - we will need the max value
418:34 - and finally we will need the cost
418:37 - and since we also have to figure out
418:39 - what the index of each number is i also
418:42 - want to put item list
418:44 - in an enumerate method
418:47 - so this should be index and item
418:50 - and now let's work for them one by one
418:53 - first of all the name we already have
418:56 - in our attribute names
418:58 - so in here all i really have to do is
419:01 - get myself dot attribute names
419:05 - and then select the index
419:07 - for the values i need to get
419:10 - myself.player
419:12 - and for this one i want to write another
419:15 - method in the player that i called
419:17 - getvalue
419:19 - by
419:20 - index
419:22 - and this one's going to get the index
419:23 - we're going to write that in just a
419:24 - second
419:26 - now for the max values i want to get
419:28 - them
419:29 - right at the top here
419:31 - because those don't change so in here
419:34 - self dot let's call it max
419:37 - values
419:38 - and to get this one it's supposed to be
419:41 - a list
419:42 - and i want to get my player.max
419:47 - stats i think i called it it is mac
419:50 - stats here
419:51 - and from this one i want to get the
419:53 - values
419:55 - so now for my max value
419:58 - i can just look at myself.max
420:01 - values
420:03 - and pick the one by the right
420:06 - index
420:07 - and finally for the cost
420:09 - this one also i want to get myself dot
420:11 - player and then get cost
420:14 - by index and we want to pass in the
420:18 - index
420:19 - all right and now in the player let's
420:21 - create those two methods and let me
420:23 - actually copy them so it saves me a bit
420:26 - of writing
420:27 - and let's write them
420:29 - right below the other two getter methods
420:31 - so we have get value by index self and
420:34 - index
420:36 - and then let me copy all of this
420:39 - and get
420:42 - cost by index
420:45 - and in here i essentially want to return
420:48 - just the value for each specific value
420:51 - in our stats
420:53 - so essentially
420:55 - i want to get my current value from
420:58 - this list here
421:01 - or this dictionary rather
421:04 - and all we have to return is first of
421:06 - all
421:07 - we need a list with our self dot stats
421:11 - dot values
421:14 - and from that i want to select the index
421:16 - and that's really all we need it's not a
421:18 - particularly complex one
421:21 - and now
421:22 - i can copy this and now instead of stats
421:25 - i want to look at my upgrade cost
421:28 - so this way we also get our current
421:31 - index
421:32 - right in here with just one line of code
421:37 - and now all we have to do is to pass all
421:40 - of this information in the display
421:41 - method
421:42 - so first of all the surface we still
421:45 - have
421:46 - and now
421:48 - for the selection number
421:49 - i want to pass in myself dot
421:52 - selection index
421:56 - then
421:57 - next up
421:59 - we have my name and this can just be
422:02 - name
422:03 - then we have the value that's going to
422:05 - be value
422:06 - then we have max value
422:09 - and then we have the cost
422:11 - so let's check if this is the working
422:14 - we're not getting an error message
422:16 - that's at the very least a good sign
422:19 - so now we are passing in all the
422:21 - information we need in here so let me
422:23 - for now hide the upgrade menu we're not
422:26 - going to need it for a while
422:29 - so essentially all i have to do now
422:31 - is create a couple of methods to display
422:34 - the different things
422:35 - first of all i want to write display
422:38 - underscore names
422:40 - and then here
422:42 - we need self
422:44 - we again need the surface to draw on
422:46 - then we need the name
422:48 - and we need the cost
422:50 - and i also want to check if this is the
422:52 - currently selected box
422:55 - and in here we are going to create the
422:58 - title text and we are going to create
423:00 - the cost text
423:01 - and then at the end once we have created
423:03 - them we are going to draw everything
423:06 - so let's create the title first and then
423:09 - here i just want to create a title
423:11 - surface
423:12 - this one is going to be self dot
423:16 - font dot render
423:18 - and what we want to render is the name
423:21 - we already have
423:23 - and since we're drawing pixel art i
423:25 - don't want to anti-aliasing
423:27 - and now we are going to need a color and
423:30 - the color i am getting from my settings
423:34 - and in here we have a text color
423:38 - so let's pass this in here
423:41 - and then besides the surface we need a
423:43 - title
423:44 - rect and what i want to do is to get my
423:48 - title surface get wrecked
423:52 - and now the mid top
423:56 - should be where myself dot rekt dot
424:00 - mid top is
424:02 - and from that i want to give it an
424:04 - offset so pygame dot math dot
424:09 - vector 2
424:10 - we want 0 offset in x and in my case 20
424:14 - pixels in the y direction
424:16 - and with that
424:18 - we can get our surface
424:21 - and blit
424:23 - and create a title surface and the title
424:25 - rectangle
424:27 - so
424:28 - now
424:29 - in my display method
424:31 - i can run self dot display names
424:36 - and then here pass in the surface we
424:38 - already have
424:39 - then we want the name we want the cost
424:43 - and let's say selected for now is going
424:45 - to be false we're going to change that
424:47 - later on
424:48 - okay and let's try this if i press m
424:51 - we are getting an error because get rekt
424:55 - here
424:56 - should not be capitalized
424:58 - and now let's try this again
425:00 - there we can now see health energy
425:02 - attack magic and speed this is working
425:05 - really well
425:06 - and now besides that i also want to
425:09 - display the cost
425:11 - and this could be a good exercise for
425:13 - you so just like the title try to
425:16 - display the cost except now the cost
425:18 - should be at the bottom of each of the
425:20 - bars
425:26 - right first of all i want to create a
425:29 - cost surface
425:31 - going to be
425:32 - self.font.render again
425:34 - and in here i want to draw my cost but
425:37 - my cost right now is a number
425:39 - so i'm going to turn this into an f
425:42 - string
425:44 - and there is a chance that my cost might
425:47 - become a floating point number so i'm
425:48 - also going to convert it into an integer
425:51 - but besides that we can just copy
425:54 - the other arguments from my title
425:56 - surface
425:58 - and now once we have that
426:00 - we need our cost
426:02 - rect
426:03 - and our cost serve dot get underscore
426:07 - rect
426:08 - and this time i want to place my mid
426:10 - bottom
426:12 - and it's going to be myself dot rect dot
426:15 - mid
426:16 - bottom
426:18 - except with an offset
426:21 - so
426:23 - pygame.math.vector2
426:27 - and 0 and 20.
426:30 - although now be aware we are subtracting
426:33 - that vector without increasing like in
426:35 - the upper one
426:37 - and now all we have to do is surface dot
426:41 - blit
426:42 - we need my cost surface
426:45 - and cost
426:47 - and that should be all we needed let's
426:50 - try now
426:51 - and there again we can see our cost
426:57 - now there's one more thing that we do
426:59 - have to do and that is to work with this
427:01 - selected
427:02 - and essentially what i want to do is
427:07 - in my upgrade i have a selection index
427:12 - and if the selection index
427:14 - and the index of each item is identical
427:18 - then i want to highlight this
427:20 - and actually let me illustrate this this
427:21 - might be slightly confusing so this
427:24 - right now
427:25 - is our entire window
427:27 - and in here
427:29 - we have a couple of bars
427:32 - let's do all of them so here we have
427:34 - five and each of those has an index
427:37 - that's the index we created just here
427:40 - and there are zero one
427:42 - two three
427:45 - and four
427:46 - and besides that i also have a selection
427:49 - index
427:51 - and this one could be anything between
427:52 - zero to four
427:55 - and this is also the number we can
427:56 - influence with our keyboard input and
427:58 - essentially what i want to do if for
428:00 - example our selection index is a 1
428:03 - then i want to highlight
428:05 - this box here
428:07 - and if it's let's say a 4 i want to
428:09 - highlight this box here so whenever the
428:12 - index of our item
428:14 - is the same as our selection index then
428:17 - i know i want to highlight this box and
428:19 - i can change some colors
428:20 - that's the entire idea here
428:23 - and i have both available in my class
428:25 - actually so this selection number is our
428:28 - selection index so the one we are
428:30 - passing in here
428:32 - and essentially all i have to do is
428:35 - if myself dot index
428:39 - is identical with the
428:42 - selection
428:45 - number i think i called it yeah
428:46 - selection number
428:47 - if that is the case
428:49 - we should be drawing something in a
428:51 - highlighted way
428:52 - and we're going to use this later but
428:54 - for now let's add pass in here and what
428:57 - we can also do is copy all of this
429:00 - and pass this in here for the true or
429:03 - false argument
429:05 - so this comparison can become either
429:07 - true or false
429:09 - so now that this selected here gives us
429:11 - either a true or false statement
429:13 - we can use that to influence the color
429:17 - and we have two different colors in our
429:19 - settings so we have the text color and
429:22 - text color selected
429:24 - so now if my text color is selected
429:27 - i basically want to do
429:30 - i have text color selected
429:32 - if selected is true and if that is not
429:34 - the case so else i just want to have my
429:37 - text color
429:40 - and now i can pass in color for both of
429:42 - the text colors
429:44 - and we should be good to go let's try
429:47 - this
429:48 - so now i press m and now my health and
429:52 - my health cost are darker
429:54 - if i press to the right we now have
429:57 - other fields selected
429:59 - and this is working quite well now
430:01 - obviously right now this is very hard to
430:03 - see but later on we are also going to
430:05 - change the background color for each of
430:07 - these items so it's going to be easier
430:09 - to see but for now this is working quite
430:11 - well
430:13 - i guess we can actually do it right now
430:16 - so if this if statement here is true
430:19 - we want to draw a selected color
430:22 - and if it's not true we just want to
430:24 - draw
430:25 - the regular background rectangle
430:28 - and i guess while we're at it i can
430:30 - duplicate this one because we also want
430:32 - to have a border color so i want 4 for
430:35 - the width and now for the border color i
430:38 - have ui border color
430:41 - and back in my upgrade i can change this
430:44 - one and let's try if this is working
430:48 - and yeah this looks pretty good oh now
430:50 - you can even tell we're not drawing any
430:52 - background for the currently selected
430:54 - item
430:56 - not ideal but it does look kind of funny
430:58 - but we can change this quite easily by
431:00 - just copying
431:02 - those two and putting them in here
431:04 - and now in my settings
431:07 - we have upgrade bg selected that we can
431:10 - place in here and ui border color
431:13 - actually stays the same
431:15 - so now let's try this
431:17 - and i press m
431:18 - and there we go this is looking really
431:20 - nice
431:22 - so with that we can properly see which
431:24 - one is
431:26 - selected what we have to do next is
431:30 - create
431:31 - another method and this is going to self
431:34 - dot display
431:36 - let's call it the bar and this is going
431:38 - to be the upgrade bar
431:39 - and then here let's actually create the
431:41 - method because this one also needs a
431:44 - couple of parameters
431:46 - so display underscore bar
431:49 - self as always we need a surface
431:52 - then we need our value
431:54 - we will need a max value
431:57 - and we need to know if this one is
431:59 - selected or not because that will change
432:01 - the color
432:02 - and now let's talk about what we have to
432:04 - do
432:05 - this one here
432:06 - is going to be one of the items
432:09 - and inside of each item i want to have a
432:11 - bar
432:13 - and inside of each bar we have the name
432:15 - and the cost that one doesn't matter
432:17 - right now
432:18 - but now what i want to do is to place a
432:20 - line in here
432:21 - and on this line we have a rectangle
432:23 - that shows us how much the player
432:26 - currently has in this skill
432:28 - and this one can go all the way to the
432:30 - max level
432:32 - and actually let me leave this one up
432:33 - here right now
432:35 - might be kind of helpful
432:36 - and let me spell properly this should be
432:38 - display bar
432:40 - now first of all
432:42 - we need some let's call it drawing
432:45 - set up
432:47 - and in here we want to know what the top
432:50 - and the bottom and i guess also the
432:52 - color of this bar is going to be so
432:55 - right now we just want to know what is
432:57 - the top and what is the bottom of this
432:59 - bar going to be
433:01 - is going to be
433:04 - self.wrecked.mid top
433:07 - and then i want to give this one an
433:08 - offset so plus pi game dot math dot
433:13 - vector
433:14 - vector 2
433:16 - and 0 and 60. so we're going down a tiny
433:19 - bit
433:20 - and then for the bottom we can do
433:22 - something fairly similar
433:25 - except now we look at the mid
433:27 - bottom
433:30 - and we are subtracting
433:34 - in the y axis
433:36 - and for the color we have in our
433:38 - settings bar color and bar color
433:40 - selected
433:43 - so
433:44 - i want to have
433:45 - bar colors selected
433:48 - if selected
433:50 - and if that is not the case
433:52 - i just want to have the normal
433:55 - bar color
433:57 - and i guess we can actually already draw
433:59 - this line so draw
434:01 - elements
434:03 - and essentially what i want to do is pie
434:05 - game.draw.line
434:07 - and this one first of all is going to
434:08 - the surface and the surface we have from
434:10 - our parameters
434:12 - besides that we need a color this one we
434:14 - also have
434:15 - and then we need a top and a bottom also
434:19 - elements that we have so all of the
434:21 - stuff we just created
434:23 - so now
434:24 - i can actually call my
434:27 - bar so let me copy all the parameters
434:29 - again my surface is going to be my
434:31 - surface again
434:33 - my value we already have my max value we
434:35 - also have and selected
434:38 - is going to be the same thing
434:40 - we got from earlier
434:42 - so now this should be working let's try
434:45 - and there we can see we have a line
434:48 - although it is very very thin
434:51 - and the reason why it is so thin is
434:53 - because i didn't set a border width by
434:56 - that we can add with another argument
434:58 - and let's give it a width of five
435:01 - and now let's try this again there we go
435:03 - this fits better
435:05 - and this is looking pretty good
435:08 - so now what i essentially want to do is
435:11 - to place a rectangle somewhere on here
435:13 - to illustrate how much of this value my
435:16 - player currently has
435:19 - so we have to get
435:21 - let's call it a bar
435:23 - set up
435:24 - and first of all i need to know the full
435:27 - height of this thing
435:29 - and that is just going to be bottom and
435:32 - be aware my bottom right now has an x
435:33 - and a y position and i only care about
435:36 - the y one
435:37 - and from that i want to subtract my top
435:41 - and i also want just the y position
435:43 - and be aware here
435:45 - the origin of our window is in the top
435:47 - left so the bottom one is the higher
435:49 - number which is why we are subtracting
435:51 - top from bottom
435:53 - but all right now i want to have the
435:55 - relative
435:57 - number
435:59 - this right now is the value that i
436:02 - currently have divided by the max
436:04 - value
436:06 - so
436:07 - let me add a bit of space let's say
436:09 - right now
436:11 - in my init method they're my stats
436:13 - so if my health is 100 and my max health
436:16 - is 300 i want this bar to be at one
436:20 - third of the maximum amount
436:23 - and this is exactly what we are doing
436:24 - here
436:26 - so this is going to give us something
436:27 - like 0.3
436:29 - and this then i just want to multiply
436:31 - with the full height to turn this into a
436:33 - pixel measurement
436:35 - and now i can create let's call it a
436:37 - value rectangle
436:39 - and this is going to be pygame dot rect
436:42 - and this one does need to be capitalized
436:45 - and in here we need left
436:48 - we need top
436:49 - we need a width and we need a height and
436:52 - for the width and height i just went
436:53 - with 30 and 10. fairly random numbers i
436:57 - just went with what looked good
436:59 - now for the left i just went with either
437:03 - top or bottom doesn't matter they have
437:04 - the same position anyway
437:06 - and i went with zero so this is going to
437:08 - give me the x of the top and from that
437:11 - i'm going to subtract 15
437:13 - which is half of my width
437:16 - and then the top is going to be the
437:19 - bottom of my bar
437:21 - so one
437:22 - and from that i'm going to subtract the
437:25 - relative number
437:27 - so just to illustrate what's happening
437:28 - here
437:29 - if this is our entire bar
437:32 - then bottom one this bit here
437:36 - is this point all the way at the bottom
437:39 - and then the relative number
437:41 - is going to be however
437:44 - much
437:45 - of a gap that is from the bottom so this
437:48 - way our bar would be here ish
437:51 - and all right with that
437:53 - we
437:54 - have something to draw so
437:55 - pygmy.draw.rect
437:59 - i again want the surface
438:01 - the color
438:03 - and this time i want to draw a value
438:05 - rectangle
438:06 - and now let's try this
438:08 - and this is looking pretty good
438:11 - with that we only need to figure out how
438:14 - to actually increase any of these values
438:18 - and for that
438:19 - i have
438:20 - another method
438:22 - and this i called
438:24 - trigger
438:25 - and trigger needs self and player
438:29 - and we first of all have to figure out
438:31 - how to actually call this thing
438:33 - and this is going to happen
438:35 - let me minimize all of these methods
438:39 - this is going to happen essentially in
438:41 - here
438:43 - so right now we're just printing our
438:44 - selection index it doesn't really do
438:46 - anything right now
438:47 - instead
438:49 - i want to call
438:50 - this trigger
438:53 - inside of my item and we can minimize
438:55 - quite a few different things so it's a
438:57 - bit easier to see
438:59 - that is feeling slightly better i guess
439:03 - ah there we go
439:05 - okay essentially i want to get the
439:07 - trigger from my item list in here
439:11 - so i first of all want to get myself dot
439:14 - item list
439:16 - and from that thing i want to get myself
439:18 - dot selection index
439:22 - and this one then
439:23 - i want to call the trigger method on
439:26 - and pass in self.player
439:29 - and now in this trigger method we can
439:31 - get the first of all let's call it the
439:33 - upgrade attribute
439:36 - and this we get with player dot stats
439:41 - dot keys
439:43 - turn all of this into a list
439:47 - and once we have that we can use self
439:50 - dot index to get one specific value
439:53 - and index will always be the same for
439:54 - each item
439:56 - and i guess for now let's just print
439:59 - our upgrade attribute so we know this is
440:02 - working
440:03 - so
440:04 - back in here i can press space on health
440:07 - we get health energy attack magic and
440:10 - speed so this way we know which element
440:13 - we are selecting
440:15 - now besides that we have to first figure
440:19 - out if the player has enough experience
440:21 - to upgrade this certain kind of value so
440:24 - i want to check if my player.exp
440:29 - is greater or equal
440:31 - then my player dots upgrade underscore
440:35 - cost it was called
440:37 - so in my player we have upgrade cost
440:41 - so upgrade cost
440:43 - and i am only caring about my upgrade
440:46 - attribute
440:47 - and now once i have that and that is
440:50 - actually true
440:51 - i want to get my player.exp
440:54 - minus equal player dot upgrade cost
440:58 - again
440:59 - and get my upgrade attribute
441:02 - so now we are lowering dxp
441:05 - and then for my player.stats now we can
441:08 - finally upgrade something yep we have my
441:11 - upgrade attribute
441:13 - and in my case
441:15 - i'm just going to multiply each value by
441:17 - 1.2
441:19 - and what i'm also going to do
441:21 - every time we are upgrading a certain
441:23 - part
441:24 - i want to increase my upgrade cost
441:27 - by
441:28 - 1.4 so we get increasingly more value
441:32 - and it becomes even more expensive every
441:34 - time we upgrade
441:35 - and now actually let's try this
441:38 - so now if i press space on health
441:41 - we get 140
441:42 - and our experience did go down
441:45 - so now we get to 64 and we can't press
441:48 - this anymore because we don't have
441:50 - enough experience
441:51 - and let's actually try to destroy some
441:54 - enemies
442:00 - okay this should be enough
442:01 - now our health still stays at 274 and i
442:04 - can press space again and now we get
442:06 - even more health
442:07 - cool this is working really well and i
442:10 - can still heal up
442:12 - and all of this is working really nicely
442:15 - so with that we have some basic upgrade
442:17 - mechanic
442:18 - now there's one more thing we do have to
442:20 - do
442:21 - and that is if our current value exceeds
442:25 - the maximum value i don't want that to
442:27 - be possible
442:29 - so
442:30 - if player dot stats
442:33 - and we want to check my upgrade
442:36 - attribute
442:37 - is greater than my player dot max
442:42 - stats
442:44 - and again my upgrade attribute
442:47 - and if that is the case
442:50 - i just want to set those two equal to
442:52 - each other
442:54 - and i guess what we could also do
442:56 - is in here
442:58 - we only allow the player to upgrade if
443:03 - my
443:04 - player stats
443:06 - is
443:08 - lower than my max stats
443:11 - i guess just another safeguard
443:14 - can't hurt to have those
443:16 - and all right with that we have a
443:17 - trigger and i guess we can test this so
443:20 - in my player i'm going to give the
443:21 - experience of 5000.
443:25 - now in the game i can upgrade i guess my
443:28 - attack is the highest one right now i
443:30 - can increase this to well the maximum
443:33 - and we can't go any further so seems to
443:35 - work just fine
443:37 - and alright with that we have our
443:39 - upgrade menu there's one more thing i do
443:41 - have to do because in my player
443:44 - so far we had self.speed but we don't
443:47 - really upgrade this after we upgrade so
443:49 - after unit method this self.speed is not
443:51 - being used anymore
443:53 - so i can get myself.speed and now all
443:56 - the way in my update method
443:58 - i don't want to use self.speed i want to
444:01 - use self.stats.speed
444:03 - and now in my game
444:04 - this is how we move by default
444:06 - and if i increase my speed
444:09 - all the way to the top
444:11 - we are moving significantly faster so we
444:13 - know the upgrades actually do something
444:16 - in the game
444:17 - cool except i'm still terrible at my own
444:18 - game but never mind
444:21 - and that was the last major section in
444:24 - the game there's only one more thing we
444:27 - have to do well two things we have to
444:29 - add the sound and there are some tiny
444:31 - details i do want to change
444:34 - but let's talk about them in their own
444:35 - section the first one is to fix a couple
444:38 - of smaller issues that are annoying me
444:40 - they are mostly visual and once we have
444:42 - that we are going to work on the audio
444:45 - and essentially what i want to do in my
444:48 - game in terms of visuals
444:50 - that in the original i had an offset for
444:53 - each individual object so the trees and
444:55 - the grass for example had different
444:57 - kinds of offset because they have
444:58 - different sizes and this i forgot
445:00 - earlier so i did want to include it and
445:03 - besides that right now if we walk too
445:06 - far to the right of our map
445:08 - we can see the black background which
445:11 - looks a bit weird actually let me
445:12 - illustrate all of this straight in the
445:14 - code and then we can work on it so here
445:17 - we are in the game and if i run this
445:20 - and move all the way to the right let's
445:23 - go all the way here i think you can see
445:25 - it
445:26 - there you can see the background is just
445:28 - black which looks kind of weird
445:30 - and
445:31 - for this or well the reason is we have a
445:34 - black background color but in my
445:36 - settings
445:38 - we have a watercolor
445:40 - and this i just want to copy
445:42 - in here
445:43 - and we have our settings available
445:46 - so this watercolor is the same color as
445:49 - the water that's why it's called
445:50 - watercolor
445:51 - and well now if i run this
445:55 - we can
445:56 - go
445:57 - back here and now we can see only water
446:00 - so this looks a bit better although
446:02 - admittedly the water does look a bit
446:04 - boring
446:05 - but well
446:07 - we are at least getting a decent color
446:10 - so now besides that in my settings i
446:13 - also want to add another entry
446:16 - let's put it all the way up here and
446:18 - that is called
446:20 - hitbox
446:21 - offset
446:22 - and in here we have one for the player
446:24 - one for the object one for grass and one
446:27 - for invisible tiles
446:29 - so let's actually go through them
446:31 - and in my player let me minimize
446:35 - everything again
446:37 - in the init method here
446:39 - we have our hitbox
446:41 - and there we already have the 26 so we
446:44 - could leave it as it is but just to have
446:46 - everything in the settings
446:48 - let me call the hitbox offset
446:50 - and in there i want to get the key
446:53 - player
446:54 - and what i also want to do
446:56 - is just for the player
446:58 - i want to reduce the hitbox for the x
447:01 - dimension as well although not by much
447:04 - let's say by 6. and let's try this and
447:08 - with this it becomes a bit easier for
447:10 - our player to move through smaller gaps
447:14 - so especially here well it's kind of
447:16 - hard to see
447:17 - but
447:18 - with our player being a bit less wide it
447:20 - does make it easier to move around
447:24 - not a major change but it does make the
447:26 - game feel significantly better
447:29 - okay with that then we have to work
447:31 - through the appetites so we have the
447:33 - player now we need the object and the
447:35 - grass
447:36 - and all of this happened in my tile
447:40 - this one here
447:41 - and in here we are getting our hitbox
447:44 - all the way at the bottom
447:46 - and this one can change depending on if
447:48 - we have grass or an object so i want to
447:51 - put this in a separate variable let's
447:54 - call it y offset
447:55 - and in here we're just going to use
447:57 - hitbox
447:59 - offset
448:01 - and then we have
448:03 - a sprite type
448:05 - so sprite type we are getting from our
448:08 - level and we are getting it from create
448:11 - map
448:12 - and in here
448:14 - we have grass and we have object
448:17 - so we're passing them in here or in here
448:20 - so this is how we then get the y offset
448:22 - and now we can just get the y offset and
448:24 - paste it
448:26 - in our inflate method to get the hitbox
448:29 - and that way we have quite a larger
448:32 - offset for the trees
448:34 - so the objects get minus 40 and the
448:36 - grass only negative 10. so this is now
448:38 - going to make it drastically easier to
448:40 - move around because we can move much
448:42 - further behind the trees
448:44 - and this means that when we work for the
448:45 - forest things are much better in terms
448:48 - of movement so this feels
448:51 - considerably better for the movement
448:54 - and that is
448:55 - kind of all i wanted
448:58 - for the basic movement
449:01 - oh and i actually forgot in my settings
449:03 - there's also invisible
449:05 - and invisible we get from our boundary
449:08 - tiles
449:09 - and they also work in here with the
449:11 - sprite type so this tile class actually
449:13 - pulls a ton of weight
449:16 - but all right so with that
449:18 - we have a couple of fixes that i really
449:20 - wanted to add that make our game feel
449:21 - surprisingly better
449:23 - but now that we have that all we have to
449:26 - do is add sound and then we are done and
449:30 - okay i guess we can go through it step
449:32 - by step add the different sound effects
449:34 - and all the way at the end we add the
449:36 - soundtrack for the game
449:38 - so let's go through it step by step
449:40 - first and i guess we can start with the
449:42 - player
449:43 - that one probably has the most common
449:45 - sounds
449:46 - so here we have the player and in my
449:48 - indian method
449:50 - i want to
449:52 - import his sound and all i want for the
449:54 - player is self dot weapon
449:58 - attack
449:59 - sound
450:00 - and this one we get with pygame
450:03 - dot mixer dot sound
450:06 - and in here we need a path
450:09 - we have to go up out of the folder then
450:12 - into audio
450:13 - and then we have sword dot wav
450:16 - and one thing i also want to do is for
450:19 - my attack sound i want to set the
450:24 - volume to 40
450:26 - of what it is that way it's not getting
450:29 - too annoying
450:30 - and now in my input method
450:34 - whenever i have my attack input
450:38 - i also want to call self dot
450:41 - weapon
450:43 - attack
450:45 - sound and play it
450:47 - and that should be all we need for this
450:49 - one sound
450:50 - let's try it now
450:53 - and
450:54 - seems working just fine now next up we
450:57 - can add some sound to the magic because
450:59 - in there
451:00 - in my init method
451:01 - i want to have let's call it self.sounds
451:05 - and this is going to be a dictionary and
451:07 - here we want to have a sound for heal
451:11 - and another sound for the flame
451:15 - and in here i want to run pygame dot
451:18 - mixer dot sound
451:21 - and we have to
451:24 - go up a folder
451:25 - then to audio and then to heal dot wav
451:29 - now i can copy all of this
451:32 - and paste it in here except now we want
451:35 - flame
451:37 - and i guess if you want to make this a
451:40 - bit more elegant you could paste these
451:42 - sounds or the path to these sounds into
451:45 - this magic data i have actually done
451:47 - this for the sounds for the attacks but
451:52 - in our case the magic sounds are so few
451:54 - it doesn't really matter
451:56 - all right now when we are playing the
451:59 - health effect we can somewhere in there
452:02 - round self dot sounds
452:04 - call
452:06 - heal
452:07 - and then
452:09 - lay it
452:11 - and
452:12 - then we can do the same thing oh and we
452:14 - have to reactivate the energy cost for
452:16 - the flame effect
452:17 - and while we had added we can add the
452:20 - flame sound
452:22 - and now let's try this
452:25 - so we are getting an error that
452:27 - audioflame.wlv
452:29 - was not found let's have a look
452:33 - so i couldn't find this one because the
452:36 - file was called fire.wav
452:40 - now let's try this again and that looks
452:42 - better
452:43 - attack still works and now the name
452:46 - works
452:47 - and magic also works just fine cool
452:52 - so with that we
452:54 - can close the magic file and not worry
452:58 - about it anymore
452:59 - then next up i have my enemy sounds
453:04 - and
453:05 - that is going to be in the enemies
453:09 - let's open that file
453:11 - enemies enemy enemy
453:15 - and in here just in the init method
453:17 - i want to have a sound section
453:21 - and we essentially have two sounds self
453:24 - dot def
453:26 - sound
453:28 - this one is going to be pygame dot mixer
453:31 - dot sound
453:33 - and i want to have my fold up then my
453:37 - audio
453:38 - and then here we have def dot wav
453:42 - now i can copy all of this
453:43 - and i have a
453:46 - hit sound
453:48 - and this one is called hit.wav
453:52 - and now for both of these self dot def
453:55 - sound i want to set the volume
453:58 - a tiny bit lower to 0.2
454:02 - and the same for the hit sound
454:05 - and now we just have to figure out where
454:07 - to call them
454:10 - and the death sound is the easier one
454:12 - actually let me minimize all of the
454:13 - methods
454:15 - this code is really getting extensive so
454:17 - in my check dev
454:19 - if this is true
454:20 - i want to call self.def that's not how
454:23 - you spell that
454:25 - deathsound.play
454:27 - that's the first one
454:28 - and the other one
454:31 - we want to play when we get to get
454:36 - damage down here
454:38 - so in get damage
454:40 - we want to play this once
454:42 - self dot hit sound dot
454:46 - play and that should be all we need so
454:49 - let's try this
454:53 - that feels pretty good
455:02 - now for the enemy again there's one more
455:06 - sound we have to import
455:08 - and let's put it right here as well
455:11 - actually let's put it right here so in
455:13 - my settings
455:14 - we have one more sound this attack sound
455:17 - for each of the different attack types
455:20 - so
455:21 - self dot
455:22 - let's call it the attack
455:25 - sound
455:27 - and this one is going to be pygame dot
455:29 - mixer dot sound
455:30 - again
455:32 - and in here i want to have first of all
455:35 - the entire dictionary so my monster data
455:39 - and in here i first of all need to get
455:41 - my monster info i think i called it so
455:44 - in here we get the entire dictionary
455:48 - so the dictionary we get is this one for
455:50 - example for the squid and in there we
455:53 - want to pick the attack sound string and
455:56 - this one we can just get by indexing
455:59 - and i also want to reduce self dot
456:02 - attack
456:04 - sound dot set volume
456:07 - and this one i set to 0.3
456:10 - and now we just have to figure out when
456:12 - to play it and this happens in my
456:14 - actions
456:15 - so in here if the status is attack my
456:18 - enemy is attacking so what i can do is
456:20 - self dot attack sound
456:23 - dot play
456:25 - and now this should be working so let's
456:27 - try this one
456:30 - and i can edit here the bamboo enemies
456:33 - i can hear
456:35 - all of the enemies
456:42 - and there certainly is some sound cool
456:45 - seems to be working
456:47 - so the final thing in this entire
456:50 - project
456:51 - is going to be in my main file where we
456:53 - start playing the sound
456:55 - so
456:55 - right here in the init method of my game
456:59 - i want to have sound
457:01 - and i'm going to import main sound
457:05 - and i am importing pygame dot mixer dot
457:09 - sound
457:11 - and in here we have a string we go one
457:13 - fold up we go to audio
457:16 - and there's a file in there called main
457:18 - dot o g g
457:20 - and this main sound i want to play
457:25 - and in here importantly we want to
457:27 - determine the loops they should be -1 so
457:29 - we are playing this continuously
457:33 - now let's try this
457:36 - [Music]
457:57 - all right now i think the one thing i do
457:59 - want to do is main sound dot set
458:03 - underscore
458:04 - volume
458:05 - and set this to something like 0.5 it's
458:08 - probably a touch loud right now
458:09 - [Music]
458:12 - and
458:13 - [Music]
458:16 - okay this one feels better i guess in
458:18 - terms of fine tuning the enemy sound
458:20 - effects feel a bit quiet
458:23 - so let's
458:25 - set those to 0.6
458:28 - and let's see how that feels
458:33 - [Music]
458:37 - and yeah this is feeling much better and
458:40 - all right
458:42 - with that we are actually done i think
458:45 - that covers the entire game so thank you
458:47 - so much for sticking around if you
458:49 - actually managed to get all the way to
458:50 - the end of this project i hope you got
458:52 - something out of it
458:54 - and well i'll see you around

Cleaned transcript:

in this tutorial we will be creating a zelda style rpg and it is going to involve a lot of components like sophisticated animations and graphics rpg mechanics and we are going to use tiled for the level creation and we are even going to create enemy ai speaking of ai i would like to give a shout out to the sponsor of this video ai camp if you want to learn more about artificial intelligence and build some seriously cool projects they have something for you ai camp offers either oneonone guidance or a summer camp during which students create real world ai projects like face mask detectors sign language identifiers currency exchange automation and much more student testimonials from past summer camps are very positive and many students received either partial or even full scholarships to attend by visiting my partner link in the description you can apply for a unique scholarship opportunity to fund your time at ai camp and best of all it only takes 10 minutes and even more upon successful completion the top aicam students are hired to work for ai camp or for other silicon valley startups if you want to study ai or computer science at university or work in the field professionally this is a great experience to get started ai camp is currently looking for people to join their summer camp and i would strongly recommend you to check it out if you are interested now before i jump into the project a quick note on this setup we have one folder with four subfolders although we will only make changes to the one that contains the code and since the tutorial is quite long you can find the game files for each stage on github there are 15 in total there are also placement files to get started and to copy code it takes a bit longer to type and well that's basically it i hope you enjoy it so here we are in the code and right now i have three different files open we have main we have settings and we have debug and all three of those are python files and if i run the main file that's the really important one we are getting this window here plain lag doesn't do anything right now but at the very least we have a window that is all we are going to need for now and i guess before we get into the proper code let's go through this to have a solid basis now we are starting all the way up here with importing pygame and says that's the usual stuff the more important stuff comes right below where we are importing everything from settings and settings looks like this we basically have two sections in here the first one contains the main game variables most importantly here we have width and height of our game window and those would be flexible so if the game window is too large for your window you can make these smaller i guess you could also make them larger if you wanted to and then besides that we have the fps and the tile size and i would recommend to keep those two numbers static now besides that we have our world map and the world map is for now going to be the layout of our game in this world map we have our player that's the p then besides that we have axis and that is going to be a rock on obstacle same thing and then besides that we have a ton of empty space and that is going to be space the player can walk on so then if i go back to our main file we have a game class let's talk about this in a second but what we are doing with the class comes down here we first check if this is our main file then we are creating an instance of this game class and then we call the method run of this class so let's look at our game class and in here not much is actually happening we have our init method and in here we are initiating pi game we are creating a display surface and we are creating a clock so this is the basic setup you always need for pi game then more importantly we have our run method and in here two things essentially happen the first one is going to be this bit here and that is going to be our event loop and right now we are just checking if we are closing the game now besides that down here we are filling the screen with a black color we are updating the screen and we are controlling the frame rate so none of this should be difficult if you have any experience with pygame however if you have no idea what any of this means check out my introduction to pygame it explains all of this in quite some detail but alright so this is going to be our basic setup now there's one more file that we have to talk about and that is debug and debug isn't actually going to influence our game instead it's as the name suggests a debug tool so it's really just there to give us information about whatever is going on in the game but it's not actually going to influence the game so you could ignore it entirely if you don't care about it and i am going to use it just to illustrate in a bit more detail what's going on in the game and let me actually demonstrate what it does so if i go to my main file in here i can from debug import debug and then in my game loop i can run debug and print any kind of information that i think is important so let's say hello and let's see what we get now in the top left of our window we get the word hello and obviously right now not particularly helpful but later on this could be a game variable that we want to illustrate so this is very helpful all right but right now i don't want it so let me get rid of all of that now with that we have our basic setup although there's one more thing i would like to add in here and that is that right now let me actually demonstrate in the top left of our window it says play game window and i would rather that this says zelda or something more customized and this would be a challenge for you that i want you guys to change this text to something more custom in my case it's going to be zelda but you could write whatever you want alright let's try together let me close this and we only really need one line when we are initiating all of pi game so it happens right here after i create a display surface and the line we need is pygame spelled correctly dot display dot set underscore caption and then here we have to pass in a string and in my case it's going to be zelda and now if i run this we can see zelda in the top left it really isn't going to make much of a difference but well it looks a bit nicer so with that we have our basic setup and now we can talk about the actual level and our level class is going to become incredibly important it's essentially the central part of the entire game so effectively it's going to be the container that contains all the essential game elements like the player all the enemies the level map all of the obstacles and so on it is really important and that is actually bringing us to the core concept the level class has to manage and that is that we have to take all of our sprites for the game put them in different groups and somehow manage all of this efficiently and the key concept to make that work is to use different groups to give different functionality to different sprites so let me give an example for start we are going to create two groups in our level class one is called visible sprites the other is called obstacle sprites and literally any sprite that is going to be visible will be in the visible sprites class so this is the only group that we will draw on the screen at the end of this project it will contain the player the map all the enemies all the obstacles and so on so if a sprite is not inside of this class it will not be drawn and for the obstacle group well anything that is going to be in here will be able to collide with the player and anything that isn't in here will not be able to collide that's fairly straightforward and how this will become useful later on is that for example for our level boundary so the coastline effectively i have basically placed sprites there that will interact with the player via collisions but they are not drawn because they're not in the visible sprites group you will see how that is going to work later on but the main thing you should understand is this that you can put sprites into different group and the sprite can be in multiple groups at the same time and depending on what group it is in it should be interacting with its environment slightly differently and that is going to become a key concept to make this entire project work but let's actually jump into our code and let's implement all of this so here i'm back in the code and i want to create a new file and i will save this one as level dot pi and in here as always we have to import pi game nothing else for now though and now we have to create a class level there's no inheritance but we do need an init method that needs self and nothing else and i guess now we can go straight to creating the two sprite groups that i just talked about so let me add a comment here and let's call this sprite group set up and in here i want to create self dot visible underscore sprites and this is just going to become pygame dot sprite dot group and now i can copy all of this and i want to create obstacle sprites so these two groups will become really important and essentially what i want to do later on in my level class is i want to give it another method that i'm going to call run doesn't need any argument besides self and in here i want to essentially update and draw the game but for now i'm just going to add pass because it's not doing anything and now that i have my level i can go back to my main i can import so from level import level and what i can do now is create self dot level is going to be the level and then in the game i can call self dot level dot run so we are essentially creating an instance of our level class this one here in our main game and then we are running all of this inside of our loop so really all we're doing is we are calling this method here and let me just run all of this to see if it's working and yeah it's still looking good we still can't see anything but that comes later so now we have a basic level now next up there's one more thing i will need in the init method and that is the display surface because at the end of the game we want to draw all of our game on this self.screen so we can approach this in two different ways we could either take this self.screen and pass it in this level this would be perfectly fine although in my case in my level i am let's do it right at the top we can use a function to just get the display surface from anywhere in our code and the code for that let's call this one self dot display underscore surface all we need is pygame dot display dot get underscore surface and this is going to get us the display surface from anywhere in our code which is quite handy as a matter of fact in the debug method we are using the very same line if you're interested but that doesn't matter too much so now we have our basic level class it still doesn't do all that much because we're not drawing anything and to draw something we essentially have to go through this world.map and draw either a rook wherever there's an x nothing if there's an empty space or the player if there's a p and the problem we have right now is that we neither have an x nor a player so let's create both of these in a very simple way and then we're going to cycle through this entire map to place them on the screen so back in my level well actually this should be a new file and let me save this one as tile dot pi and for now this is going to be a class that will always going to be a rock but later on we are going to make it slightly more flexible so it goes to become a tree or statue or basically any kind of object import pie game as always that was terrible spelling and from settings import everything and now i want to have a class called tile and this one is going to be a sprite so pygame dot sprite dot sprite for inheritance that is really important and now i want to create a dunder init method that needs self and now this one is going to do a couple of things most importantly we are going to need a position so we know where to place it besides that i am also going to give it an argument called groups and this is going to be the spread group it should be part of how that is going to work you see in just a second but there's a very handy feature to assign a sprite to a group via the arguments you see in a second what i mean actually we can do this right now so these are the two arguments i need and the first thing you always eat in a sprite that's very easy to forget is super dot init and then brackets so we initiate this class here essentially and what you can do that is super handy is if you pass the groups in here so the argument we have just declared now we are going to need two things the first one is always self.image and we need self.rect the two main things you always need for any kind of sprite and direct is the easier part we need self dot image dot get underscore rect and the top left is just going to be the position so this is the position that we get up here that we will give this tile when we create it now for the image i want to import a file so pygame dot door and in here we first have to get outside of our folder so right now we are in the code folder so dot dot then we have to go into the graphics folder and inside of the graphics folder there's a folder called test and inside of test we have a player and a rock and for this one i want to use rock.png and really important do not forget to convert alpha this rock with that we have our basic rock or well a basic tile that's a pretty good start and i guess what we can also do is let me copy all of this and now i want to create a new file and this one is going to become our player so let me save it as player dot pi and now i can paste all of this and change the class name from tile to player and now instead of the rock i want to have the player and the rest can stay the same although this player class later on we are going to massively change so there's no point using inheritance between these two classes with that we have a player and a tile or rock so now in our level we can actually set some basic stuff up so we can finally actually see something but first of all let's see if things are still working and they do that's they're looking pretty good and i guess let me really quickly explain what we are going to do so the really important part in our settings is this world map and let's go through this thing really quickly just to explain what it is and how it's going to work so essentially world map is a list here's the start and here's the end and this list contains a ton of individual lists and inside of each list we have one string there could either be an x a space or a p and this we are going to translate into specific positions for example this top left x should have the top left position so this point here should be position 0 and 0. for the simple reason that it's right in the top left now the x right next to it so this one here should have the top left position let me add a small arrow to make it a bit easier to see this should have an x position of 64 because our tile size is 64 but then the y position should still be zero because it's right at the top and now for another example let's say if we want to place the player i still want to place the top left and now i have to figure out the x and the y position and this could actually be a really good exercise for you try to figure out what the coordinates of the player are supposed to be i know the player is in the column with the index two so we have zero we have one and we have two so the x position of this point here should be 2 times 64. and let me add x here and that is going to be 128 and now for the y position that's one we haven't done so far we can use the list themselves so we know this is list number zero this is list number one and this is list number two so our player is in the list with index number two so for y we also have to place the player at 2 times 64 which is still going to be 100 so the top left of the player should be a position 128 and 128 and this sort of logic we are going to do for every single item in this entire list so i want to go back to my level and in here i am going to create a new method let's call it create underscore map it doesn't need any arguments besides self and in here essentially i have to nest a couple of for loops and let me build this up slowly first of all i need 4 row in world underscore map and now let's print what we get so print row and i guess when we set up the class we can call this method so in here let me add another section and let's call it sprite set up and what i want to do is self dot create map so we're just calling this method here and now if we run out of this we are getting an error that world map is not defined for the simple reason that i didn't import the settings so from settings import star now this should be working there we go so now we still can't see anything but now we have printed essentially the entire map that we can see in the settings so the same map we can see here pretty good start although not particularly helpful because there's a really important thing i need to get here that for each row i need to know the index because that is going to be the number i will multiply with the tile size to get the y position so besides the row information i also need to know what index it's on and this is information i am getting with the enumerate method so enumerate and we need row index and row so now i can let me copy this i can print the row index and the row so now if i run this and close the window we can see that we have index zero then the first row index one and then the second row about the first row the row of the index one let's put it this way and this is really important information because this entire row here i want to multiply for the y position with zero times 64 which is going to be zero but for the second row or the row of the index one we want to go with one time 64. so that way there's always going to be a 64 pixel offset between each row and all right now we have our row and our row index so that is going to give us the y position but from that we also need the x position so this is going to be another for loop so let me go back to my settings essentially we went through every single list with this for loop and we got the list and the index now what we want to do is that inside of each of the lists we want to look at each of these x's and then figure out what the information is so what's inside of the string and what index this string is on and that way we're going to get our x position and this is going to look very similar so for let's call it call index and column in enumerate and now it's going to be the row and that is literally all we are going to need for the basic setup so this is going to cycle through every single item so every single x empty string or p inside of this world map and it's also going to give us the x and the y position and i guess just for the formula now we can get an x and we can get a y position the x is going to be the column index multiplied by the tile size and y is going to be the row index multiplied by the tile size and with that we have converted the world map into a position so now what we can do is if the column so each individual item inside of this world map so x empty space or p and use that information to create a certain kind of sprite so for example if column is going to be equal to an x then we want to create a rock and for that to work we obviously have to import the tile for the rock so from tile import tile i think i called it yeah tile and i guess what we added from player import player essentially all we want to do is if we have an x we want to create a tile and the tile has two arguments we have to figure out we need a position and the groups so let me copy them and the position we already have that is just going to be a tuple with x and y and for the groups all i want is a list with all the groups this one is supposed to be in let's say for now it's just going to be self dot visible sprites so we can see them but later on there are going to be more groups in here and with that we have the basic setup this is not looking bad at all so first of all let's run out of this to see if we get an error and we don't that's generally a good sign so now we just have to display this visible sprites and we should be good to go and i think this could be a good exercise to see if you are still following along so try to display all the sprites inside of visible sprites i hope that was a simple exercise because all we have to do is self dot visible and then we need the surface we want to draw on which in our case is self dot display surface and now let's see if this is working and it is indeed working we can see the top part of our game we can't see the bottom part but for that we are going to create a camera later on but for now this is looking pretty good and let me make this a bit smaller so with that we have our rocks next up we also want to place the player so if the column is equal to the letter p then we want to place the player so we want to just create the player and the player is in here it also has position and groups for now so let me just copy them in here and we can actually just copy the arguments from the rock and place them in here so essentially right now the tile and the player identical but they are going to become very different very soon but let's try this and there we can see our player so with that we have our basic level setup and i guess one more thing that we can do for now is that the tile for the rock should be in two different groups it should be indivisible sprites and it should also be let me copy it it should also be in the obstacle sprites i guess let me call it obstacle sprites not obstacles sprite that's very annoying to pronounce now you will not be able to see a difference but now whenever we create a tile this tile is going to be in the visible sprites and inside of the obstacle sprites and later on this will become incredibly helpful because essentially what we will do is we will check the obstacle sprites and the player and if there is any collision we are going to influence the player from that collision and this is actually something we could start working on right now so the next part is going to be about the player and the player is going to become quite substantial because well it's the main player of the game but for now we are going to focus on two things only the movement of the player and the collision mechanics and that is going to allow us to sort of run around the level already and i guess let's do all of this straight in the code that should be the easiest way here we are back in the code and i want to look at my player and right now our player really doesn't do all that much so we have to add a few more things here now first of all we need some kind of direction the player is supposed to walk in and this in my case is going to be a 2d vector so self.direction is usually a good name and what i want is pie game dot map dot vector 2 and don't forget the brackets if you leave them empty it's going to be 0 and 0. and this is going to give us a vector that is going to have x and y and right now by default both are going to be zero and what we want to do is to use keyboard input to change either of these numbers to a certain direction for example if we are pressing right then this zero for the x should be a one and then later on we are going to multiply this vector with a certain kind of player speed and that way this direction would become something let's say 5 and 0 and our player would move to the right at the speed of 5 pixels per frame so we essentially have to do two things number one we have to get keyboard input and number two we have to multiply this vector by a speed and well let's start with the keyboard input so let's call it just input needs self and nothing else as always and in here we need to get our keyboard input and i guess this could become a good exercise so try to get the keyboard input for up down left and right on the keyboard and see if you can figure this out so first of all i need to get all the keys that are potentially being pressed and this happens with pygame dot key dot get underscore pressed and now what i can do is if keys and we can check for specific key let's say i want to start with pygame.k underscore up and if that is the case i want to set self.direction.y to negative one and that's all we need now we can copy this thing and change this one to down and now y should be one and now we can copy both of them although don't forget they should be alif so right now we are pressing negative one so our player is going up later on at some point now for pressing down this y becomes 1 so our player is moving downwards however now we have a problem that let's say in our game we pressed down and then we lift up the key again our player would keep on moving down because this y being 1 sticks around because we don't change it anymore and well our play will just keep on moving downwards which is not ideal but we can fix that quite easily by adding an else statement that self.direction is going to be zero so really all we're checking is is the up key being pressed if that's the case y is negative one if we're pressing down y is going to be positive one and if we are pressing neither of these buttons the player doesn't move in the y direction at all actually i forgot direction dot y and that's it for the y direction now i can just copy the entire thing and do the very same logic for right and left let's say we want to start with right and right is going to be x and it is the positive number and if we go with k left this should also be x and it should be negative one and then direction x is going to be zero this one doesn't have positive or negative and all right with that we have our basic input so now we can give this class an update method so update self that's horrible spelling and for now i just want to get self dot input and now what i want to do back in my level dot pi i also want to update all of the visible sprites so self dot visible sprites dot update and now let's run all of the code and let's see if anything happens so we can't see anything right now but something is happening at least hopefully inside of our player and actually we are able to visualize what's happening by using our debug function but first of all back at my level when i created the player i also want to put this inside of self dot player player and the reason for that is that i'm going to use this software player quite a bit and this way i can target it directly but it is still going to be inside of this visible sprites and well now what i can do is right at the top i can from debug import so this function here and now in my run method i can call debug and i can call self dot player dot direction and now if we run out of this we can see in the top left we have 0 and 0 right now and that's our direction and if i press to the left we get negative 1 for x or positive 1 if i press to the right and if i press up we get negative one and if i press down we get plus one for the y and that way i can press in a different directions and we get different numbers so this is already going to give us the keyboard input and all we want to do is to multiply this with a certain kind of speed and that is also going to happen inside of the player so now besides direction i also want to give my player self dot speed at least for now and let's put it at 5. although be aware later on this speed is going to disappear because we will replace it with a proper dictionary of all the player attributes but for now we can work with it quite well and besides that i want to create a move method and this one itself and it's going to need the speed and in here we are going to move the player all we have to do is self.rect.let's say center plus equal self.direction multiplied by the speed and that is all we need so now i can run in the update method self.move and the speed is going to be self.speed and let's actually try this and see what happens so nothing happens if i don't press a button but if i press to the right or to the left or up and down our player is moving so this is working quite well although well you can see that the overlap with the different rocks doesn't work at all right now and we have no collisions but we can at least move around obviously we also don't have a camera so if the player moves outside the window it just disappears but that comes soon although before we get to that there's one more thing i do want to work on and let me illustrate what the problem is right now if i just move left or right or up and down we have a certain kind of speed however if i move to the right and down we are moving significantly faster i think it's quite good to see and the reason for that is trigonometry essentially that if we apply two different directions we are moving slightly faster and this we have to account for and essentially what we have to do in this player so this direction here we have to normalize it and what normalizing means is that we are changing the length of a vector to 1. and that way if we multiply by the speed it's always going to have the same speed no matter what direction we are going in and well doing that is actually super easy all we have to do is if self dot direction dot magnitude 2 that's how you spell that so magnitude essentially is the length of the vector and if that is different from zero then i want to get myself dot direction and simply get self.direction.normalize so first of all we are checking if our vector has any kind of length and as soon as it has a length we are setting the length of the vector to one that way it doesn't matter which direction it's going in it's always going to be one which down here instead number 3 is going to result in the same speed in all directions now the reason why we need this if statement is because a vector of 0 cannot be normalized pygame would throw an error this is why we need this if statement but now if i run main.pi i can move left and right still works but now if i move down now we can see in the top left we get 0.7 and that is because of the normalization but well you can see in the game now the movement looks significantly more constant so that's a pretty good start and you might have one question that in the player why do i add the speed as an argument instead of just writing self.speed now this would work but the reason why i'm not doing this is later on for the enemies we want to use the same move method so what i'm essentially going to do is i'm going to later on remove this move method from the player and put it inside of another class along with a couple of other methods actually and then both the player and the enemies are going to inherit from that class and that way i'm going to keep things a bit more flexible so both the enemy and the player can inherit from them and use all of these methods so just keep that in mind if you want to use self.speed but okay with that we have our basic movement so next up we have to work on the collision and collisions generally can be a bit finicky to work with for the simple reason that in pygame all we can really check is if two sprites are overlapping but pygame doesn't tell us where they're overlapping so let me put two sprites on the screen right now we have one sprite and one sprite slightly to the right and the bottom now these two obviously overlap but do they overlap from the right or from the bottom that's a really important thing because what we want to do if they overlap we want to place the colliding rectangle either to the right or to the bottom of this other sprite so the problem we might have is that if we get a collision from the right pie game might get confused and place the sprite at the bottom of the other sprite and in the game this would look like our players teleporting around and it might even break the entire game but fortunately it can be fixed fairly easily all we have to do is to apply each direction individually let's say we're going to start with the horizontal movement so we're going to move the player in the horizontal space check for collisions and if there is a collision we are going to move the player to the point of that collision and once all of that is done we are going to work on all of the vertical movement and collisions that way there cannot be a confusion between what kind of collision is going to happen and well that is all we need to get started so let's go back into our code and let's have a look at this here we're back in the code and i have my player class open now what i would like is to have all of the collisions inside of this class the problem is that this player doesn't know where all of these obstacle sprites are so we have to pass them into the player and this is going to happen by simply giving the player another argument and let's call this one the obstacle sprites and then in the init method i want to get myself dot obstacle sprites it's just going to be obstacle sprites and now when we create the player at the end it is going to get self dot obstacle sprites be aware here we are placing the player inside of this group and then we are giving the player this group here but just for the collisions the player itself isn't in that group that is a really important distinction all right with that we can actually create let me create the collision method in here so let's call it collision it needs self and i want to give it a direction essentially what we are going to do first of all we are going to check the direction and this one could either be horizontal and then we want to do stuff and i guess let's be a bit specific so if direction is going to be vertical then we want to do other collision stuff and let's work on the horizontal one first essentially what i want to do i want to look at all of the sprites inside of my obstacle sprites so for sprite in obstacle sprites in self dot obstacle sprites and now for all of these sprites if sprite dot wrecked dot collide wrecked and self dot rect so we are essentially checking the rectangle of the sprite with the rectangle of the player so this information is going to tell us if there is a collision between these two but we still don't know if this collision happens on the left or on the right but this we can also get quite easily because we know the direction of the player so for example if this is our player and our player is moving to the right then it would be pretty unlikely to have a collision on the left side that would be a little bit strange instead we can kind of predict that we are always going to have a collision on the right side if the player is moving to the right and then the same thing for the left side if we're moving left all of our collisions are going to be on the left as well i guess important to say here all of our obstacles are going to be static so that should make it much easier all we have to do is if self dot direction dot x let's say is greater than zero so if that is the case we are moving right and if we are moving right we need self.rect.right that's not how you spell that is going to be sprite dot wrecked dot left so now essentially what's happening here if we have our player so this again is our player our player is moving to the right and now our player is colliding with some kind of obstacle and they are overlapping right now what i essentially want to do is to move the right side of my player so this side here to the left side of the obstacle we have been colliding with so that way it looks like the player is always on this particular side and they're not overlapping and that is all we have to do with this line here so now next up we have to do the very same thing for the other side so if self.direction dot x is smaller than zero then self.rect.left is going to be sprite dot direct dot right so the exact flip side of the upper line this is then all we need for the horizontal collisions now next up we have to do the very same thing for the vertical ones and this i think could be a really good exercise for you so after looking at the horizontal collisions try to do the same thing for the vertical ones so you want to check for the up and the down movement let's try together now but first of all i want to add proper comments so this is moving left and now let me just copy the entire thing now the first two lines are still perfectly fine but besides that i now want to look at direction dot y so if direction dot y is greater than zero we are moving down and if that is the opposite way so we are smaller than zero we are moving up so if we are moving down we want to place the bottom of the rectangle at the top of the sprite so essentially what we are doing if this is our player again right now our player is moving down and if now we are colliding with any kind of obstacle the bottom of our player should be at the top of the obstacle so this line here and then we have to do the same thing for the up movement so the top of our rectangle is going to be at the bottom of the collision object and all right with that we have our collisions actually not all that bad so let me minimize this and now we have to work in this move method and essentially we have to take this method here and split it apart into the x and the y movement so self.direct self.rect.x plus equals self.direction.x multiplied by the speed and then we can do the same thing for the y so if i just left it at this and ignore the collision method entirely we shouldn't see any kind of difference and things are still looking pretty identical cool good start but now what i want to do after we are moving our player let's say on the x after we have done this i want to call myself dot collision and i want to check my horizontal collisions and let's just use one of them to see what is happening so now if i run my main file i can move to the left and i have proper collisions although if i move from the top nothing is going to happen and pie game is getting a bit glitchy but this we can fix quite easily because all we have to do is call self dot collision and now we want the vertical collisions so now if i run out of this we get very nice working collisions and everything is working just fine cool this is looking really good there are no bugs as far as i can see this is working very nicely now the problem is i can actually demonstrate this i can move outside of the window no problem so this is not ideal also the game doesn't look as good as it could because there are no overlaps so for example if i'm on top of a rock my player stops where the rock begins but ideally there should be a tiny bit of overlap to give the illusion of depth which is what we are also going to need so let's work on these two bits now to achieve both of these things the camera and the overlap we essentially have to create our own group or at the very least we have to take a spread group and change some key functionality and that is very neatly going to bring us into a bit more of an advanced concept inside of pygame so far if you follow this channel we only ever used a group to place a sprite in there to update them and to draw them but you can totally take a sprite group and rewrite some core functionality but to do that we first have to understand what a group is actually doing and fortunately it really isn't all that complicated essentially all that the spread group really does is that it stores a ton of different sprites then it can call the update method and all of these sprites and we can also draw all of the sprites and all that is really going to happen inside of a draw method of a group is that we are going to call blit with the sprite and the rectangle of whatever sprite we have inside of that group so with that knowledge we can totally override key parts of a group or give it extra functionality here i'm back in my code and i want to go to my level and i want to change this visible sprites class to a custom made group and let's create that class in the same file i think that makes sense and i'm going to call this new class y sword camera group and it's going to inherit from pygame.sprite.group and the naming here has two key parts number one the more obvious one the camera group so this spread group is going to function as a camera and that's the part we are going to work on in just a second the other part the y sword means that we are going to sort the sprites by the y coordinate and that way we are going to give them some overlap now in here we are going to need a couple of different things first of all as always we need a dunder init with self and nothing else and let me start with a general setup of all the stuff we are going to need now first of all as always like with the sprite we need super ideally spelled correctly that tends to help dot init no arguments are needed now once we have this we can actually replace our visible sprites with this group so why sort camera group and since we haven't replaced any functionality yet and we've initiated the original class this should still work let's try it and we still get the very same functionality everything works as intended so at the very least we didn't break anything yet but with the setup we can make some simplifications for example what we could be doing let me actually go to the display surface and let me copy this line here just to illustrate what we can do a very simple example now with our display surface inside of our class so now i can create a new let's call it custom draw and itself and nothing else for now and really all we need to create our custom draw is for sprite in self.sprites and don't forget the brackets and now we can get all of the sprites and now all we have to do is self dot display surface dot blit and we need sprite dot image and sprite dot rect so this is essentially what a normal sprite group is going to do and now in our run method we can replace our draw from the original group with custom draw and now we don't need any arguments because we already have the display surface and let's run this and it's still working just fine except now we're using a custom draw that is going to give us significantly more power and i guess what i can do we can get rid of this debug it isn't useful anymore now we want to use this for two specific purposes number one we want the camera number two we want some overlap between the different sprites in the y direction and let's start with the camera that's the more important bit and the logic to make the camera work is actually surprisingly simple and all of it happens in the custom draw but by default we are always drawing this bright image in the same position as the sprite rectangle but we don't have to we can totally give this bright rectangle a certain kind of offset and this is what we are going to use for the camera so really all that's going to happen in practice when we are calling blit on the surface we are still going to keep our sprite dot image but now for the sprited rect we are going to add a vector to give them a certain kind of offset and this vector is essentially going to be our camera because it's going to give us control where the sprites are going to be drawn and then really all we have to do is to get the offset from our player and connect this to this bright rect vector and once we have that we are good to go essentially we are going to give the offset of the world to wherever the player is going to be and well i think this makes much more sense once we actually implement it so let's go back into the code and here we still have our y sword camera group and what i want to achieve is that the player is always right in the middle of the window but that's going to come in just a second first of all let me illustrate what i mean with the offset essentially all that's going to happen is we're going to create a vector let's call it offset and this offset is going to be pygame.math.vector2 needs to be capitalized and by default is going to be 0 and 0. and this vector we are going to add to our sprite rectangle so all we have to do in here let me create a new let's call it the offset rectangle and this offset rectangle is going to be the sprite dot direct dot top left and then plus self dot offset and that way we are going to get a new position it's not a rectangle anymore but well high game is happy with a tubal so this is still fine so now we can do is put this offset rect actually let me call it offset position that's going to make more sense so offset position and now anytime we have any kind of offset we are going to add this to our rectangle now right now this is going to be zero so we should not be seeing any kind of change so let's run main.pi and we still get the same outcome but what we are now able to do is if i give this vector some starting positions let's say 100 and 200 now if we run out of this our entire game is slightly offset so this is the offset we have just given it so what you can see here is that this distance is 100 and this distance is 200 so essentially our game itself didn't actually change any kind of position we are just drawing all of the elements in a different spot and the distance to that spot is determined by our offset so this is working really well now next up what i have to figure out is how to connect this offset to my player and since i want the player to be exactly in the middle of the screen i first need half the screen width and half the screen height and we can do this in the init method so let's call this half with and all we need to get this is self dot display surface dot get underscore size and for x we need zero and we want to floor divide this by two so we are getting an integer now we can do the same thing for the height and all we have to change is from the tube we get from get size we need the first one and that's going to be the y one so now we know how much distance we want from the left and from the top so all we have to do in our custom draw i want to get another argument and that is going to be the player so when i call custom draw up here i want to pass in self dot player so now i can access the player and get the player position and let me add another comment here and let's call it getting the offset and in here i want self.offset.x and then dot y so now we have to figure out these two positions and unfortunately we couldn't just add player.rect.center x and player.rect.center y although it would be nice and simple actually let's try and see what happens if we just use those two numbers so now back in my main file now if i move the player we get something but looks a bit weird but we do get something that's at least a start and essentially all we have to do is from this number subtract either self dot half with and self dot half height so now we are getting some kind of weird outcome and i might be able to see the player i could see her there for a bit so now the camera movement is a bit weird and the reason for that is that this plus here should be a negative and now let's try this again it should work and there we go this feels significantly better and with that we have our offset and if you're really interested in the math here i would recommend to go over the geometry a couple of times it is a little bit weird but once you go over it it should make sense and probably just draw it out a couple of times eventually it starts to make sense but that is literally all we needed for the camera movement so now we have covered the first part we have a proper camera movement so i guess now we can start working on part number two the overlap and this one consists essentially of two things the first one is a hitbox for all of our sprites so right now for example for our player the hitbox is the entire image but i don't want that to be the case i want the hitbox of the player to be slightly smaller than the original image and these parts are going to be the overlapping parts but this by itself wouldn't be enough because our group right now doesn't know what elements to draw on top and what element to draw on the bottom this is going to be another part we have to make ourselves it's not actually that difficult but it's something we have to implement but i guess let's go through it step by step and let's first of all start by creating all of our sprites a custom hitbox so here we are back in the code and i want to start with the tile that's going to be the easiest one and right now we have our rectangle so this is always going to be the full size of our entire image i want to give it another attribute and that is going to be self dot hit box and the hitbox is going to be essentially the same as self.rect except now we want to change the size and this happens with inflate and what inflate essentially does is it takes a rectangle and it changes the size so in my case really all i want to do is if this is my original rectangle then i want the hitbox to look something like this so we have the same width the same center but the top and the bottom are a bit shorter and that way later on the player could be standing behind this for example and that's really the entire idea of all of this and inflate needs two arguments one for x and one for y now my x can just remain zero but for my y i want to have a specific number and let's say just to get started let's go with negative 10. oh and by the way this is going to keep the center point at the same position so let me draw all of this again this is our original rectangle and now our hitbox is going to have the same center but now on the top and the bottom we are going to have a 5 pixel because we specified negative 10 up here and negative 10 makes the entire thing shrink by 5 pixels on each side and now we have to do the very same thing for the player and let me do it right below the rectangle so self dot hitbox is going to be self dot wrecked dot inflate and for my player let's say for now i want to go with 0 and since the player is a little bit taller i want to go with negative 26 and now let's run the code and well this shouldn't make any difference for now but at least the code isn't crashing so that's a good start but now essentially what i want to do i am not going to move the rectangle anymore instead i'm going to move the hitbox and i'm going to move the hitbox and check collisions on that hitbox as well and after all of that is done i'm going to put the center of the rectangle where the hitbox is going to be so that way the rectangle always follows the hitbox and that way i can get all the collisions with the hitbox and have some overlaps but then draw the player in the correct position so essentially what we have to do let's go with move first and let's get rid of this comment we don't need that one anymore so instead of self.rec.x we want to move self.hitbox and we want to move both x and y and at the end of all of this we want to get self.rect.center is going to be self.hitbox.center and now what we can do that instead of checking the rectangle of all of the sprites we want to check the hitbox so this should be hitbox and we're also not going to check the rectangle of our player but the hitbox of our player and this is going to happen for basically all of the rectangles we are going to replace them with the hitbox so this should be hitbox this should be hitbox this should be hitbox hitbox hitbox and finally hitbox and now let's see if this is going to work so now we can indeed see some offset so right now our player is behind the rocks and this is looking really really good the problem we have now is that our player is always below the rocks so no matter where we go oh except here because these rocks were created earlier in the level setup so these rocks are behind the player because they created earlier in the code but these were created after these were created after and further down here all of these rocks are above our player so this is going to look kind of silly but we are very nearly there so we are making some definite progress there's only one more thing that we need so right now we have a custom hitbox for both our player and for our tiles now the last thing we have to do in our ysort camera group we have to order our sprites so we have to tell it when to draw each of these sprites and right now they are being ordered by the time of when they are being created this happens here some of the tiles were created before the player but some tires were created after the player was created so those tiles would be on top of the player whereas the titles created before the player was created they would be below the player and in most situations this really doesn't matter but in our case we don't want to order our sprites by that logic instead we want to order our sprites by the y position and essentially the sprite that should be drawn on top should be the one with the highest y position because if the sprite is a lower wide position than another sprite then the sprite that should be behind or high up on the screen should be behind that other sprite in godot for example this is just being called y sword and this is basically what we're implementing ourselves manually right now and the way we are doing it is by using the sorted function and let's do this straighten the code so here right now we are just going through all of the sprites but this i don't want to do anymore instead i want to go with for sprite in sorted and sorted essentially takes two arguments first of all it wants a list of what we want to sort and this we do have it's just self dot sprites and again don't forget the brackets it's very easy to do and next up it wants some kind of key and the key essentially going to be by what kind of metric we are going to sort all of the sprites now in our case this should be the y position of each of the sprites and to get that we basically need a lambda function so lambda and i want to look at this sprite and all i want to return is sprite.rect.center y i guess let me know if you want a specific video on the sorted function once you're nested lambdas it's actually pretty simple but now we have overlaps so let me run the code again and now we are still behind the rocks but now if i go a bit further down now we are on top of the rocks but if we go behind them we are well behind them and all of our collisions still work just fine and all of the overlapping works really nicely and this is going to make our game look really good so cool this is working exceptionally well nice there are no bugs so anything this is all working good cool and with that we have a basic topdown game with a camera collisions overlaps and all of the good stuff now i guess for the rest of the game we are just going to add more and more visual detail and enemies and extra stuff to it to make all of this into a proper game but at this stage you already have the basic logic you need to really create any kind of top down game i guess next up we can start working on importing the actual map to make this entire thing look significantly better now for the graphics we are going to need quite a few different things for now we only had our world map and we spawned either a rock or player which really wasn't ideal but to get the actual graphics of the entire game we are first of all going to need significantly more data and that is going to be way more data than i could assemble by hand so we have to use a program and the program that i am using is called tiled which is super useful completely free and it allows you to assemble graphics and let me actually show how this looks so here we have the tiled editor and right now you can see our entire map and this thing i essentially created from these tiles on the right so here we have all our floor tiles here we have the details we have flowers and we have trees so i could for example literally just pick a tile and draw over this thing and expand it and i have made an entire tutorial on how to use tiled so for this video i am not going to go over it and i will keep the map i have already created so this thing took about an hour possibly a bit more to assemble as a whole actually let's go through the entire thing layer by layer and then i can explain how this comes together so right now we have nothing and the bottom layer looks like this this is going to be our ground and on top of that we have some details they will be integrated into the ground as well and essentially what i'm going to do i am going to export this entire thing as one image and this one image will be below all of the other objects so even below the player and then if we move this map it looks like our player is moving on top of an actual surface but in reality we are just moving an image now on top of that something we can't see but that's really important is floor blocks and flow blocks if i make it visible is going to be our constraint that our player cannot walk outside of the map so all of these red squares are going to be obstacles that the player cannot cross and they are blocking the entire map so the player cannot leave it and in the game they are not going to be visible so let's hide them now on top of that we have our entities the blue p is our player and besides that we have all of our enemies now then we have grass and the grass is well the grass and finally we have the larger objects and those are of the statues the trees the rocks all of that kind of stuff and importantly all of the objects the grass the entities and the flow blocks have to be placed by going over the entire layer so we have to circle through the entire layer like we have done for the world map and place all of these elements and to make that work in our game we will later on have to import quite a few different things for example we have to import the graphics for each individual tree and rock and statue into pie game same for all the enemies same for the player and there is going to be a lot of importing and also when we export these data sets we get a csv file which stands for comma separated value which effectively is a long list with numbers and these numbers tell us where stuff needs to be and those numbers we also have to import and all of that gets quite complex so this section will be quite heavy on managing all of that data but i guess let's go for the step by step and let's start with the easier bit and that is going to be the floor and for that we are just going to be importing an image and placing it below every other element and then we are good to go here we are back in the code and i want to go to level and all of our drawing is happening in this section down here so essentially this part here draws all of our elements and we kind of want to draw our floor in there as well the problem is that the floor is slightly different from all of the other elements so we couldn't just add the floor to the sprites and call it a day for the simple reason let me actually draw this that right now we are drawing all of our elements by their y position so this is essentially how our drawing is going to work so the greater of a white position an object has the higher up on this thing is going to be drawn and we are looking at the center of the y position now the problem with that is that our map is always supposed to be on the bottom so our map is always supposed to be here it needs to be below all of the other elements otherwise it wouldn't be a ground or a floor so we have to place this in here anyway and if we didn't do it it would end up somewhere let's say here and since it's a giant image it would essentially cover up the entire field and we wouldn't be able to see anything so we have to make sure it's below all of the other elements so what we are going to do to this group we are going to add a surface and a rectangle for the floor specifically and that is not going to be a sprite but then in this custom draw we are going to draw it and i guess let me implement this straight away so in here creating the floor and for this i need two different parts first of all i need the actual image of the floor so self dot let's call it floor surface and this is just going to be an image so pygame.image.load and this i need to go up i need to go to my graphics in my graphics there's a folder called tilemap and in tile map we have ground dot png and this we also want to convert but we don't need convert alpha this time and next up since we do want to place it i also want to have self.floor underscore rect and let me call it surf instead of surface so things are lining up a bit nicer and this is just going to be self dot floor surface dot get underscore rect and the top left for now is going to be 0 and 0 but this doesn't actually matter all that much since we are going to change it well right now and really what we have done so far in our custom map we have created an offset position and the offset position came from the top left of the rectangle and the offset and the offset we got from the player so now what we want to do is the exact same thing except now we only want to do it for the floor surface and not for all of the sprites and this could be a pretty good exercise for you so try to implement the offset for the floor and then draw the floor before the for loop for the sprites now first of all let's add another section and let's call this one drawing the floor and first of all we are going to need a floor offset position and this we get in the same way that we have used just before so we want self dot floor rect dot top left and then minus self dot offset and that is going to be all that we need so now we can run self dot display surface dot blit and self dot floor surface and i call this one floor offset position and that is literally all we needed so let's run this and see what happens and there we go now in the top left of our world we have oh well below our player we have the entire world map now right now we can't really walk over it and we can well we can kind of walk over it but you get what i mean but right now all of the rocks don't line up at all anymore so we have to make a few more changes but at the very least for now the basics are working so this is quite nice and now next up we have to work on all of the other objects and this one is going to need a little bit more work but i guess we can start with by removing the old stuff and just placing the player somewhere in the middle of the screen and this is going to happen in our level and let me minimize our camera group so we can focus on this a bit more so right now we are using all of this stuff here to set up our world and this worked so far but now we want to get rid of it so let me comment out essentially all of this except i want to copy the player and now i want to place the player somewhere on the map let's see what works let's say 400 and 300 and that might be a good position yeah okay i probably need larger numbers let's say 2000 and 1500. we are almost there let's say one thousand four hundred thirty because that way we should be on the path and we make sure we are not going to hit any other tile so our player isn't going to collide with anything by default but now we can move around our entire map there are no collisions yet but well we have a much better system so now essentially all we have to do is to reintroduce all of the layers and then work with them although they just might be a little bit oversimplifying things so let's go through what we are going to do first of all we have to make our tile a bit more flexible because so far the rocks are the only tile we could have but in this section we have many more and many more differently sized tiles and we also have some tiles that shouldn't have any graphic whatsoever for example the tile for the collisions that limit our player they don't have a graphic but since they are also sprites they will need some kind of surface so essentially our tile class needs to be able to accept any size graphics and also be able to accept no graphics at all and i guess let's implement this and all of this is going to happen in our title class or well the tile file and this is going to get two more arguments the first one i want to call sprite type because later on we do want to have a bit more control over what kind of sprite we have and besides that i also want to pass in a surface as an argument and this could then be anything but if we don't pass in any surface this class should generate its own surface so as the default argument here i want to have pygame dot surface so this is just going to give us a black surface that we can work with and the size of that should be tile size and tile size so by now since our tile size is 64. the one we determine here if we don't pass in the surface as an argument we get a tile size of 64 by 64. and then for the image this is then going to be what we get and besides that i also want to get self.sprite type is going to be sprite type and this later on for example could be an enemy or could be invisible or it could be any of those things and that's going to allow us to target in a bit more detail what's going to happen to any of these so we are using both groups and the sprite type to determine what a sprite is going to do in the game for example later on if the player attacks grass the grass should disappear immediately but if we attack an enemy we should just reduce the health of the enemy but both of those are going to be in essentially the same groups this is for now all we need for our title class now we can go back to our level and what we first of all have to do is to import all of the layouts because right now let me open them in the folder so in our project we have a map folder and in here we have six different files we don't need all of them so map floor and map details we could just ignore but floor blocks we do need to import and by default we couldn't work with a csv file so we have to figure out how to import this kind of file and then convert it so it looks more or less like this world map so that we can work with it and this i still want to do in my create map and since we have a couple of different files i want to turn this into a dictionary and in here let's start with the easiest one the boundary so this is going to be what limits our player and in here essentially what i want to store is this kind of world map except for all of the boundaries so i have to write a function like import csv layout and this one should then get the path to my csv file something like this so what we have to do is to actually write this function and this since we are going to be using it quite often i put into a separate file so let's create a new file and i save this one as support dot pi and in here we want to define import csv layout and it needs a path and nothing else and just to demonstrate what i'm doing while we're doing it let's call this function and let's see what it does so right now if i press pass we run this file nothing is going to happen because pass doesn't do anything now the first thing that we have to do is to figure out how to read a csv file and fortunately python has a module just for that but i don't want to import all of it instead i want from csv import reader and this is allowing us to read a csv file and now to use it we first have to open the csv file so with open and we pass the path in here and then python wants a name for this file and i called it level map and all of this so far could work for any file so this could also be a text file and unfortunately right now you wouldn't really be able to see anything so if i print my level map all you would get is something in our memory not particularly helpful but this thing we now have to convert with our reader to something actually readable and the reader needs two arguments first of all the file we want to work with which in our case is level map and besides that it also wants it delimiter and a delimiter in our case is a comma and what it means is what separates each individual entry in our file this could also be a space for example now this information is going to return another value that i'm going to store as layout now unfortunately still if i print the layout now we get a csv reader object so at the very least i guess we know we have a csv object but that's about it but now comes the actual part where we get to see something because now what we can do is for row in layout we can print the row and now we can see the actual files so in here we can see a whole lot of negative ones but all the way at the top you can already see we now have a list so here the list starts and the list is ending here and wherever we have a negative 1 there is no tile however if we have 395. so any of these numbers here there should be a constraint for the player so the player wouldn't be able to move over this tile and it's really hard to see right now but if all of these tiles were on the same line they would in my tiled editor have the same shape as this red line here but in our case since the line isn't wide enough this is really hard to see but now all we want to do is to put all of these lists into a separate container which is going to be another list so let's call this one terrain map and this one is just going to be a list and now for each row that we get from the layout i want to append this to my terrain map so this could just be row although just to be sure i want to convert this row to a list and now the last thing we are going to need is to return that terrain map and now whenever we get this import csv layout we can put all of this for example in a print statement print it and now we get a list that contains a whole bunch of other lists that give us the layout of our map so that is going to be quite useful and now let's actually go straight ahead and use it so in my level dot pi i now have the boundary for my floor blocks as i called it which is just going to be my boundary now i actually want to place them in the same way i have used it earlier with the tile map but what did i call it my world map so now my boundary has the same kind of layout as this thing except it's significantly larger so let's work with it and since it's so similar we can reuse all of this code except there's going to be one modification i want to place all of this inside of another for loop and what the other followup is going to be let's call it style and layout in layout let's call it layouts that makes a bit more sense dot items and don't forget the double colon so essentially the style is going to be boundary right now and the layout is going to be this csv map and right now we only have a single one of these so it doesn't make too much sense however later on we are going to add more and more data in here and then this followup is going to make significantly more sense so that way our code is nice and scalable but now we are still looking at the y position we get the x position and we are converting all of this into an x and y position so now we can use this quite well and all we have to do now is if the style is equal to boundary then we can create a new tile so we can now create a new tile group and let me copy all of the parameters place them in here and let's go for them one by one actually or actually even better try to figure this one out yourself to place in all the proper arguments for each of the parameters to place the boundary for the world map all right let's go through it one by one first of all position that should be the easiest one because in here we just want to get x and y and that's just going to be what we created up here and actually this should be indented one more line next up we want our groups and for now let's place let me copy from the player i want the visible sprites and i want the obstacle sprites then we need the sprite type and the sprite type i have called invisible because they're not supposed to be visible later on and then finally we have our surface and this one we can just ignore since it's then going to use the default argument and all right that is then going to be all we need for the boundary and let's actually see what happens so we don't get an error we do get an error and the error we're getting is import csv layout is not defined that is an error i tend to make very often fortunately it's quite easy all i did was i forgot to from support import star so that this function is another file and we didn't import that file now let's try this again and now i made another mistake the obstacle sprites are not defined and that is probably because i forgot the self there we go and now if i run the code we can see something strange so at the very least we get some kind of collision although something is definitely gone wrong here and i think i can already tell the problem so right now when we are calling this boundary our boundary is slightly different compared to this map here because for boundary there is no empty space we get a negative one actually in my support file let me open it again so let me copy this one and let's call import csv layout and let's print it so what we can see here is the number 395 a whole lot of time and besides that a lot of negative ones and what pygame did it always put a block where we have a negative one but we only want to block at 395 and that was different from our world map so let me get rid of this one again so what we want to do in here when we go through the column we want to add another if statement that if our call is different from the string negative one and only if that is the case we want to do anything in here and negative one in a tiled export means there's not supposed to be anything so this negative one would work for any kind of layout so now let's try this again and let's see what we get we still get a giant block that seems like something is going wrong with the position so let's investigate what the problem is and i just realized the problem is i am very very stupid well so in here we are still using the world map we are not actually using the layout so that may have been a problem so now let's try this again that should fix the issue so now if i go to the right at some point there we go now we have the black coastline that we can't walk over and we still get our overlap that one works pretty well cool and now we are not able to leave this game anymore but we can still use something like a bridge and we can move on this tiny island and obviously right now we don't want to draw any of these black tiles and to get rid of them at least in terms of visibility we can just remove the visible spreads group and now let's run this again now we can't see them anymore however we can still not move over into the water so this is all working very very nicely this is a very nice upgrade cool okay that took way more time than i expected but well here we are all right so for now we need two more objects we need the grass and we need the objects so all of the trees and the statues and stuff like that and for that first of all we have to import two more csv layouts and let me just copy them that's going to save me a bit of writing so one is called grass and the other i have called object so essentially what we need to do with those two is if this style is going to be grass let me just add a comment create a grass tile and if the style that's not how you spell that if the tile is object then we want to create an object tile and we do have most of it but we don't have the most important part we don't have the graphic for either the grass or any of the objects what we have right now is two folders one with three different grass images and another folder with like 20 different objects and right now those really aren't usable and i really do not want to import every single one of these images individually so i want to create a function that does all of this for us and this is also quite easily done let me add a path in here so python doesn't throw an error and in my support file besides import csv layout i want to create another function and i call this one import underscore folder it also needs a path and this one is going to go through a folder import all of these images as a surface into pygame or well into our python code and there's one module that we will need for this it is called the os module and i don't want to get all of os instead i just want to get the one that's called walk and walk just allows you to walk through the file system that's really all it does and let's actually check out what it is doing so for data in walk and now we have to add a path and let me use the path for the grass objects that one is looking like this and now let's just print our data and now let's run import folder oh i made a mistake the import grass should be what we pass into the function and then walk gets the path from the parameter that looks much cleaner now let's run this and now we are getting three different bits of information first of all we get the folder name the first bit here in our case we just don't care about it and we already have it anyway so this one we could just ignore next up we have an empty list this one here and if there was any folder inside of this folder this list would contain the names of these folders in our case we just don't care about it now finally we have the list of the images or well the files inside of this folder and this is what we care about essentially what we want to do let me clean this up a bit basically what i want to do is i want to combine this path here with any of these names so these three names and that is going to give me a whole file path to that image from my code wherever i run it in my setup and once i have that i can just import this file as a surface so i would just loop over all of these names turn them into a full file path and then import all of this as a surface and that is what we are going to do so first of all let me rename the data and split this into three different parts now for the first one before the name i'm going to use an underscore since i don't care about the information for the subfolders i can use a double underscore because i don't care about this either now finally i have the let's call it the image files this is what i actually care about and this is still going to be a list so i want to split this up so i need another for loop so for image in img files and now if i print each individual image we get the list ideally of our grass images so grass one two and three and now what i can do with them is i can turn them into a full path so right now all we have is strings that we can combine quite easily and what i want to do is to get my path on that i'm going to add the string of a forward slash and to that i'm going to add my image so if i print this full path i have a nice path to my image that i can use to import this image so literally all i want to do let's call it my image surface i want pygame.image.load i need my full path and don't forget convert alpha and spelling this correct also helps and this is then going to be our image or our surface now finally we want to return this entire list and right now we can't really do that so what i usually do is i just create a surface list that by default is empty and then as soon as we create this image surface we get our surface list and we append this image surface and at the end of all of this we are returning the surface list and that way let me print what import folder gives us ah we get an error pi game is not defined because we need to import pygame and i suspect we get another error aya right now we haven't initialized pygame.display because we're only running this file by itself so i can't really show this right now but fortunately when we are running our level we have initiated pi game this happens in the main file so this happens here as a consequence we don't have to worry about this error you're gonna see in a second what this means actually let's import all of the graphics that we need and since we have more than one i want to put this into a dictionary as well so we have graphics it's going to be a dictionary and in here for now we only have the grass and for the grass i want import underscore folder and i have called it this one here and now we can actually print our graphics so let's run all of this we get our file no error and now we can see in the dictionary we have grass and we have three surface files inside of a list that's exactly what we wanted so all right you can get rid of this and now we can actually work out our grass tiles and essentially what i want to do i want to pick a random image from this folder or from this list and then create a tile with that random image and this could be a really good exercise for you so try to create a tile with the grass and the sprite type should also be grass and see how far you get all right so first of all let me get rid of all of this and the first thing i want is to get a random grass image so we want to pick one item from the list and to do that we need the choice method which we get from random import choice so now in here we can just call choice and get our graphics and i want to get the grass list and once we have that we can just create another tile now the x and y position is still going to be x and y that one didn't change but now for the groups we want self dot visible sprites and self dot obstacle sprites because the grass is supposed to be visible and collidable and finally i gave those a type of grass and now this should be working and oh yeah i know what i forgot so we can see something but we have a problem and look at this for a second and just think about what i forgot the important thing i forgot was the actual graphic so random grass image now let's try this again there we go this is much better so now we have our grass image and they are collidable they are very much visible and this is working really well so now we have our grass this is working really nicely i think down here we have quite a few more there we go this is coming together quite well cool so with that we have the grass and then finally we need the larger objects and we already have up here the object in our layout and besides that we are also going to need the graphics and this one i called objects and then here we just want to get the import folder and the file path towards it i have called this and with these two things we have a layout and we have the graphics so we can start working on actually creating these tiles here but now we do have a bit of a problem because for the grass tiles we could just select a random grass tile from the list for the objects we cannot do that because each of these objects is one specific thing that we couldn't just randomly pick now fortunately that isn't too much of a problem and let me open tiled again to explain why so here we have tiled and all of the objects are in here and if i click on one let's say this tree stump this is the id of zero if i go to the next one it's the id of one then two three four and five and so on and essentially what tiled is exporting is this id and this is really useful because we can use this id to import the index of the image in that folder so when we import the images they are in the list so they can be indexed and the way we're importing them right now is by the name and since you can see it in the image the name is 0 1 2 and so on so the naming here lines up quite nicely with the file name and that way we can use the id as an index and this means all that we have to do to get our surface we have to get our graphics and in here we want to get the objects and this is then going to return a list and from this list we want to get the index and the index we get is this column here so this is the column we want to use for indexing now right now this column is going to be a string so we want to turn this into an integer and now we can just use this surface so i can just copy the tile we again need x and y then we also want visible and obstacle sprites so i can just copy them and for the type i call this one object and finally for the image we want the surface and that is all we needed almost at least so now if we run this we can see some trees so this is coming together very nicely the problem is this isn't working perfectly so for example here you can see the flower and the column on top of each other and i think further here that this one's actually working quite well um i guess if i go in here you can see a couple of overlapping things that don't look as good as they should be oh especially down here you can see some problems and the problem is this in our tile.pi right now we are basically assuming that all of the files or all of the images are 64x64 pixels but the larger objects really aren't that and let me explain this issue entitled now here we can see the thing that we just saw doesn't work in code and the problem is this that in tile we always assume we have a 64 by 64 tile grid and this works for most of the objects like the grass for example where it doesn't work is with these larger objects so this column here for example is much larger than 64 pixels and we are always placing the top left of this column but since this is larger than 64 pixels we are placing this column somewhere here on this line so we are placing it here as a matter of fact all of these larger elements are a bit further down than they are supposed to be but that's something we can fix quite easily so let me go back in the code and when we are placing the rectangle now we have to adjust things a tiny bit and essentially what i want to check if this bright type is equal to object because those are the only things that are going to be larger than that and these we get from object here and we're placing them in here and that way we do have access to them and if they are an object we want to do an offset but if they're not an object we just want else else and do the thing we have already done and the rest can stay exactly the same now if we do have an object we still want to get self.write and we still want to get self.image.get underscore act and we are still placing the top left but now we are still placing it x and y as well and the x stays exactly the same so this is going to be position zero so we are splitting apart this position into the first and the second integer and now for the y we have to make a tiny adjustment i guess we still want the first index but now we have to reduce a tiny amount from that and here our life is going to be made a tiny bit easier because all of these larger objects have twice the height of all of the other elements so really all we have to do is to subtract the tile size from it here is a normal tile it's 64 by 64 pixels and the larger tiles look either like this where we have 64 by 128 or we have even larger tiles that look something like this well we have 128 and 128 and the problem that we faced is that all of these tiles are being offset over here so the position we want to place is actually this one instead of this one so what we want to do is to just move any of these larger objects a little bit further up and since they're always the same height with 128 pixels we can just move them up by 64 pixels or exactly the tile size which is making our life significantly easier and all right that's all we needed so now let's run this we don't get an error and that is looking quite good i can't see any overlaps this is also looking really good and yeah i think we have a pretty nice looking map that is coming together very much so all right with that we can get rid of these old comments and we can get rid of in our settings of the world map we don't need it anymore so i guess with that we can start working on a better looking player so we have the different kind of animations and that is going to be the next section so let's talk about the player animation and to make our player animations work we have to figure out what our player is doing at any given time so what the status of the player is and at the end of the day there are going to be 12 different states our player can have we can either walk in any of the four directions we can be idle in any of these directions or we can be attacking in any of these four directions so it's going to be 4 times 3 and that's how we get to 12 different states and in the most basic sense all we really have to do is whenever there is a certain kind of state we are going to play a certain kind of animation that's the easiest way to think about it but that's still quite a bit away first of all we have to import all of these graphics and we also have to give our player the ability to attack and to cast magic and i guess we should work on those two first here we are back in the code and i only want to work on my player we don't need anything else right now as a matter of fact let me minimize the functions so it's a bit easier to see what we are doing that makes a bit more sense first of all in my input here we are getting the input to move around and i want to get a few more and let me actually add a few more comments so this here is the movement input and down here we have the attack input and then a bit further we get the magic input and for the attack input we can still use our keys so if keys and in my case i use pygame dot k underscore space so the spacebar means that we are attacking and for now if we are attacking let me just print attack and now we can do the same thing for the magic i can just copy all of this and and for magic i use the left control which is triggered with lc tr so left control and if that is being triggered i want to cast some magic and now if i run this we don't get an error if i press space we get attack if i press ctrl we get magic so that's a good start but there is a bit of a problem right now let me run the game again so if you press attack we attack multiple times same for the magic and the reason for that is that our game runs at 60 frames per second if we press space once pygame checks for this multiple times a second and it finds the bar being pressed for longer than a few milliseconds that's why it triggers it multiple times so for these two if statements we have to add a timer that can only be triggered every few milliseconds so in our player let me add another section or it's our first section here actually and let's call those um i guess we can call them movement let's just give it a movement and we can put them up here and in here i also want to create a few more variables or attributes first of all the first point is called attacking and by default it's going to be false next up i want to have a self dot attack cool down and let's put this one for now at 400 i think is a good number and finally self dot attack time and by default this is none or could be zero doesn't really matter and these three numbers we are going to use to create a timer so what i want to do whenever we call keys for attacking and for magic we also want to check that our player currently is not self dot attacking and this we want to do for both magic and attacking and those two get the same variable for the timer because i want that to be an offset that the player can't cast an attack and magic at the same time or really fast after each other now once we are calling either of these i want to set self dot attacking to true and let me copy it to both and now what we should be seeing is that we can attack or cast magic once so let me press space for attack and now i keep on pressing space or control nothing happens and there shouldn't be anything happening because now attacking is true so this if statement cannot trigger anymore but obviously eventually we do want to attack again so we want to create another method that i am going to call cool downs needs self and nothing else and in here we are going to have all of our cool downs and let me explain the logic so i explained this a couple of times but the problem is that high game by itself doesn't have a timer function so we couldn't just tell pygame to do something in half a second it just doesn't have that and also i should check my spelling so instead we have to create our own timer which we can do and essentially what we want to do so here we have the timeline of our game so this is time 0 and this is time x this is the maximum time once we close the game and we want to check two things we want to check when our attack has occurred so let me use this in a different color let's say our attack occurred right here at around let's say milliseconds at 700. and now from this point we want to continuously measure our time so as the game goes on we want to check what the time is so for example here we could have 800 here could be 900 here we could have a thousand and here we could have 1100 and what we basically want to check let me write it so 1100 now what we basically want to check is this distance here and that is going to be our timer i have actually made a video specifically on timers but really all we are checking is one point in time and then we continuously check the time and if difference between our current time and our starting time is greater than our cooldown in this case then we want to trigger whatever code we have so i hope that makes sense we need to get our current time and stored in the variable and to get our current time we need pygame dot time dot get underscore ticks so this is going to continuously measure what our time is and the other thing we need is when the attack actually occurred and this we can get up here so what we want to do in here is self dot attack time this is going to be pygame.time.getticks as well now a really important thing here is that this sketch is only called once and once only because this if statement is only going to be run once however this get ticks down here will be run basically infinitely because there's no restriction on it and we're going to put this cooldown in the update method in just a second so to get ticks down here is being run multiple times they get ticks up here is only run once that's how these two functions differ okay but now all we have to do is let's say if self dot attacking because that's the only reason why we reject this if our current time minus self dot attacking time is greater or equal than self dot cool down should just be cool down did i make a typo again oh i put this down as attack cooldown so let's call it attack cooldown and if that is the case self dot attacking should just be false again and that is a very simple timer and later on we are going to add a few more timers in here for example when the player is vulnerable or when the player is switching a weapon but this is the most basic one and now all we have to do let's put it right on the input self dot cool downs and now let's try this again i can press space we only get it once but if i keep on pressing it it only happens after about half a second and this also works oh um magic is still a bit different so let's have a look ah the problem for magic is we didn't set the starting time so this is what we need now let's run this again and now both magic and attack work much better so now our player has the ability to move around up here and to attack and cast magic at least in theory so now we can actually import all of the animations to show what the player is doing and that is going to become quite extensive so let me minimize all of the functions and put all of this in a new method and let's call it import player assets needs self and nothing else and then here first of all i want to get my character path to the folder this shouldn't be capitalized and the path to my folder is going to be one fold up then graphics and then the player and then forward slash don't forget that because in this folder there are a couple of subfolders and now we need all the different states that our player can have and this i want to put in a dictionary because this will get quite extensive and let me just copy all of this it's going to look like this and there's a bit much white space like this so this is what i talked about earlier we have the animation states for the player walking in all the four directions the player being idle in all the four directions and the player attacking in all of the four directions so these are all the possible states the player can have and if you look at the folders they are named in the exact same way and that makes it really easy for us to use the names of these dictionary entries to import all of the graphics so what i can do now is for animation in self dot animations dot keys let's say if i just print it to illustrate what i'm getting so animation and in the init method i want to call this so let's put it right at the beginning in here and let's call it a graphics setup and self dot import player assets and now if i run the game we can see we have all of our different states the player can have that's working quite well and keep in mind those are names for folders we are not working with images yet but basically what i want to do i want to combine this player path here with all of these different subfolders and that is actually going to look really similar compared to our support file here so to what we have done with this and then once i have the full path i want to use my input folder function and fill the list for each of the states with the graphics from each folder and this might be a good exercise for you try to figure this out yourself that you go through every single animation you create a full path you use the input for the function to fill each of these folders with the associated images so try to do this yourself first of all we are going to need our full path and the full path is just going to be the character path plus the animation and now for each self dot animations and we can target the animation i want to set each of these lists to my import folder and this import folder i have to import into my player so from support import import folder and now my input folder just needs a path and that is going to be my full path so at the end of all of this let me just print my self dot animations and let's see what we get let's open certain error that looks good in here you can see for example we have up so that's walking up and there are a bunch of different surfaces in there next up we have down more surfaces then we have left at some point we have right then we have right idle and all of the different states are in here which is exactly what we wanted so now we have effectively imported all of the assets for our player so now we can minimize this method and not worry about it anymore with that we have covered the first part that we have figured out how to get the resources into our player now next up we have to figure out how to actually play all of these states and for that we have to talk about state management and essentially what we are going to do our player is going to get an attribute called self.status and this self.status is going to correspond with one of the keys in self.animation so for example it could be up down left right up idle left idle left attack up attack any of those and for example if it is up we are going to pick all the surfaces inside of the up folder and play those repeatedly so with that we have to figure out our state management and really what this one comes down to is we are going to look at our player direction and our player input and see what kind of movement the player is doing for example in our direction vector if we have something like 1 and 0 we know our player is moving to the right and just now from the timer if self.attacking is true we know the player has just been attacking so we want to play the attack animation and really all we are going to do is figure out the right condition for each of the 12 possible states and once we have that we can display an animation and be done with it so let's try to figure out some states here we are back in the code and let's put it under graphic setup self.status and let's say by default this is going to be down and now we also want to create another method and i call this one get status and itself and nothing else as always and in here we have to figure out how to get all of the different states and let's start with the easiest one the idle status and this one is actually fairly easy all we want to check is if self.direction.x is equal to zero and self.direction.y is equal to zero but now we have a problem and let me actually illustrate this by drawing so here is our player and right now we know our player is not moving so we want to play the idle animation now the problem that we have is that we don't know what direction our player was working so we have four different idle statuses we have down left up or right but right now all we know is that our player is idling we don't know in which direction he or she is idling and that is something we do have to figure out and i guess there are two ways to figure this out one way we could look at the direction before the player stopped moving so for example the direction before we stopped was positive one here the player was probably walking to the right but that would involve quite a bit of extra code that would be a bit annoying to work with so instead what i'm going to do i'm going to check the current status so for example right now it's down which means the player is walking downwards and all i'm really going to do is to add towards this and idle so that way i keep my downwards movement but now instead of walking it's going to be idle and really what we are doing i think the best way to think about this is if i show the animations so here we have up down left and right and then for idle we have right idle left idle up idle and down idle so to move from up to up idle all we have to add is underscore idle and the naming here is very intentional it's the same for attack so if we are moving right and we are attacking we just have to add underscore attack to up and we go from walking to the right to attacking to the right so basically all i'm going to do is instead of overwriting self.status i am just going self dot status last underscore idle and now what we can do in the update method let's say after cooldowns self dot get status and i guess what we can do we haven't used our debug method in a while i still have it i don't uh let's do this in the player so in here right now we have our run method and i want to call debug or myself.player.status just to see what's going on because right now we don't have an animation we just have the status so let's see what it's doing so right now you can see the problem that we keep on adding idle to it and we also don't get updated down not working too well yet and i guess i jumped a little bit had with the idle here because we first want to figure out the walking directions and this happens in the input method because we know if we are pressing up our player is going to move up so what we can do in here itself.status is going to be up and we can do the same thing for down and we can do the same thing for right and then finally we have left so this way we are just determining the directions and let me minimize input again and let's comment out get is for now just so not be confusing so now main.pi we have down we have right left up and down so this is working pretty well and even if i stop moving it still says right left down and up so these directions are working really really well the problem is right now i have no way to separate between our player walking and our player idling and that is what we have to work on and this is what all of this code here is for i should have planned that a little bit better sorry about that so now if i uncomment this method here what we basically get is if we are moving things are well but now if i stop moving we keep on adding idle and well it's not particularly helpful oh and what is annoying me i don't want to print self.animations all right now the problem is we don't check if our status already has idle in there so we have to add another if statement that if not idle in self dot status so what we basically do we first of all check if our direction for x and y is zero that's this part here so then we would assume if we are not moving we are idling now next up we are checking if our status doesn't already contain the idle part and only if that is the case we are going to add underscore idle to our status and that way we are only adding idle once and not multiple times at least hopefully let's check this now so we have down idle we have up idle left if i stop moving that looks pretty good so now we have some nice upgrades although if i now attack it doesn't change anything but the animation i want to play should be left attack or down attack so that's the next part and that is just going to be another if statement so if self dot attacking first of all i don't want the player to be able to move and attack at the same time so if we are attacking self.direction dot x should be zero and the same for y and now basically what we want to do is copy this line here and let me actually just copy the entire thing and i first want to check if we don't already have attack in our status and if that is not the case i want to add attack to my status and this is i guess kind of going to work let's try so now we have down idle up this is the working and now if i press attack we get left idle attack and right idle attack and well it's kind of working but the problem we have is that we only want left underscore attack we don't want the idle in there so what we want to do for attack is that we don't want to just attach a tag we want to remove idle if it is in there and the same thing here that if we are attacking we don't want the player to play the idle animation or to add the idle tag and this is just a matter of another if statement or well a longer if statement so for example for the status if not idle and self.status and not attack in self. status so now we are checking if the player isn't moving and we don't already idle or we are attacking and only if neither of these are true then our player is going to idle now at the same time for the other if statement we first want to add another if statement so in idle in self.status so if that is the case we want to overwrite idle but if that is not the case then we can just add attack to the status but now we want to overwrite the idle and this is done with self dot status is going to be self dot status dot replace and here we have idle and we want to replace it with underscore attack and that is technically all we need so now let's move up down left and right that is still working now if i stop we have left idle right idle up idle and down idle and now if i attack with down attack left attack right attack and up attack but the one final problem we have is that you can still see it in the top upper tag still sticks around so what i want to do after self.attacking is over up attack should automatically switch back to up idle and that's going to be the final bit and this is going to still happen in get status and this could also be a pretty good exercise so one self.attacking is false i want to remove the attack and self.status so try to figure this out yourself all right so we know this if self.attacking is only going to run if self.attacking is true so if we had an else statement at the bottom here we are checking if self.attacking is going to be false and in here all we want to do is self.status is going to be self.status.replace and now we want to replace underscore attack with an empty string although this by itself might throw an arrow because python might try to remove attack if there's no attack in the string so this needs to have another if statement that if attack in self dot status so now this should be working and i guess with that we have our player status let's try so down idle up idle attack we go back to idle we have left right i can attack i go back to idle this also works with magic and yeah this is working really good cool so this is then going to be our get status now i can minimize this and now we come to the finally good part where we actually animate our player so let's really briefly talk about the logic for the animation it really isn't all that difficult essentially all we have to do right now we always have the same image for our sprite and for an animation all we want to do is to loop over a list of different images for example if our player is moving to the right we have five different images to loop over for the animation and once we have that we are well we are good to go it really isn't that complicated so all that we have to figure out in our code is how to quickly loop over different sprites in our animation frames and let's do this straighten the code that should be the easiest here we are back in our player and i want to create a new method let's put it all the way down here and i call this one animate we need self and no other arguments and first of all i want to have an animation and the animation is going to be self dot animations and then we get the key from self dot status so if i open the play assets again our player status can only be any of these 12 states so if we pick any of these keys we are going to get a list with the right animation that we want to loop over so that's the first part now next up we have to give our player a couple of extra attributes and let's put them all the way up here first of all we need self dot frame underscore index which by default is zero and then self dot animation underscore speed and in my case this is going to be 0.15 now let me minimize this again and essentially what we are going to do now is that we are going to loop over the frame index so really what i want to do is self dot frame index plus equal self dot animation speed so this is going to give me a continuously larger number and let me actually draw this so we're going to start at zero and then we're going to get larger and larger numbers and let's say eventually we want to pick one we want to pick two we want to pick three we want to pick four and so on but the problem we have right now is that our animation so this thing here has a finite number of frames so we want to make sure that once we reach the end of this list we want to go back all the way to zero and this we can do simply by checking if self dot frame index is greater or equal than the length of our animation and if that is the case self dot frame index is going to be zero all we are doing is we are increasing a number and once the number is larger than the length of our animation frame index goes back to zero so that way we continuously loop over our list so that should be a pretty easy part now next up we want to actually set the image and all we have to do here is to create a new self.image and the image we want to get is from our animation and in here we want to get self dot frame index however right now pi game or python in general for this indexing expects number like 0 or 1 or 2 essentially an integer the problem is our animation speed is 0.15 so a floating point number hence if we passed this number in here python would be very unhappy so we have to convert this frame index to an integer which we can do very easily with the end function and we are good to go although there's one more thing i do want to do that if we are changing the image we also want to update the rectangle again so self.image.get and the center is going to be where our self.hitbox.center was in the last frame the reason here is that different images of our player have different dimensions so if we didn't update the rectangle the player might shift by a couple of pixels around it would make it look slightly weird but that's really all we needed so now after get status self dot animate and let's see how this is going to look so now the player can move up left right and things are looking good so now if i attack we get an attack animation now the sword and the magic attack are the same but well doesn't really matter however there's one last thing i do want to fix because right now let me run the code again so if i attack i can move to the left i think it's good to see now and i don't want the player to be able to change direction mid attack essentially i don't want a player to do any keyboard input during an attack anyway so what i want to do let me minimize animate and go back to input i only want to do all of this if the player so if not self dot attacking and now i can't do anything during an attack i guess with that we can also remove these lines here because they are not necessary anymore so now let's try this again still feels pretty good and yeah is working really well so with that we have player animations and for the next part let's add some weapons and essentially all that we are going to do whenever the player presses attack we're going to create a new sprite with any of the weapons we have quite a few different ones actually and that way we can already see the weapon the only thing we really have to do is to work with the position and then destroy weapon one self.attacking of the player is over but that's basically it essentially what we are doing is we are creating a sprite for a short period of time and that sprite shows the weapon of the player and later on we will have to add a bit more to make the weapon actually do anything but that comes later i guess for now let's actually show the weapon and the first thing we will need is some data so let's start working on that straight in our code here i am back in the file and i want to keep my data broadly in settings and right now it doesn't actually have that much so i want to import oh well not import but rather paste one dictionary that looks like this and this one has our weapon data so in here we have our sword our lance our x our repair rapier whatever it's called and our sigh and each has its own cooldown its own damage and its own graphic that we are going to show later in the ui and now that we have that i want to create a new class but let me first close debug and tiled so you can see all of the tabs i guess we can also close support we don't need those anymore so now i want to create a new file that i'm going to save as weapon dot pi and then here we are going to need the usual so import by game and then we have to create a class that i'm going to call weapon and this one is going to be a sprite so we need pygame.sprite.sprite and then we have our init method for now we're just going to go with self and then as always we need super dunder in it and now we have to figure out well we have to figure out two major things the first one is self.image and the second one is self.wrecked and let me actually draw what i'm hoping to do this square here is our player and our player is facing to the right and essentially what we want to do with our weapon is to spawn another sprite that essentially starts at the right side of our player and then stays roughly here so for now what we have to figure out is what is the direction of the player and from that how can we use that direction to spawn the weapon to that side of the player and i guess just to keep things simple for now our self.image is just going to be pygame dot surface with uh let's say 40 and 40. so for now it's just going to be a black square but later on it's gonna be a proper graphic so we have to figure out the rectangle the problem is to figure out the right position we need our player since our weapon is supposed to be right next to the player so we have to import let's say the actual player and i guess while we add it we can also add groups to know where the groups are supposed to be and for now just to have something let's say our rect is going to be self.image.get underscore rect and the center is going to be just on top of the player so player dot rect dot center and to spawn that weapon we need a twostep process first of all in our level this is where our weapon has to be let me actually minimize all of this so it's a bit easier to see so right now in our level class we have all of our well sprites all of our everything so my weapon has to be in here as well and that way it's later possible to interact between a weapon and an enemy or between the grass so our weapon has to be available inside of the level the problem is we are getting the attack input from our player so from this line here so our attack happens inside of the player but we want to sort inside of our level that's the main problem we have right now so we have to get around that and that fortunately is quite easy essentially what we are going to do in our level class we are going to create another method and let's call it create attack needs self and nothing else and what we want to do in here is to create our weapon and for that we also have to import it so from weapon import weapon and now let me copy the parameters again so we can figure out the arguments so our player we do have we created this in create map so our player is stored right now in self. player down here so i can literally just copy this one and paste it in here and let me minimize this again that makes our class significantly easier to read now for the groups for now i want this thing to just be in self dot visible sprites and well that is it for this method at least for now now next up what i want to do in my create map when i create a player i want to pass this method in here so self.create attack and really important here we are passing the function into this method we are not calling the function so there should not be brackets let me actually cross it out so these brackets here should not be there if they are there you are going to get some weird result because this function we want to call from inside of the player so inside of my player let me minimize everything in here as well there we go so now in our init method for the player we have another argument that we called create attack and let's put this under i guess movement works so self dot create attack it's just going to be create attack and now we have this method here available inside of our player and now what we can do in our input method we can call under create input instead of attack we can call self dot create attack and now we have no arguments so it should be fine by itself so let's run this and let's see what happens so now if i press space we can see a black square on top of our player and that is going to be our weapon cool so this is working already so now with our level and our player we have the ability to create a weapon although granted it's not particularly helpful right now but that's something we can work on and there are two things we essentially have to figure out the first one is where to place the weapon and the second one is how to figure out the graphic for the weapon because each direction is going to be different and since we already talked about the direction let's talk about with the placement of the weapon but let me actually separate this so here we want to talk about the graphic and then a bit further down we want to talk about the placement now in either of these cases we need the direction of the player because if the player is moving to the right we want to place the weapon to the right and also show the right image of the weapon so we have to figure out let's do it all the way at the top let's call it direction and this i think could be a pretty good exercise so try from the player to get our direction so our player has a ton of different attributes that he could be using try to figure out one so he can reliably tell which way the player is facing i guess there are two ways you could approach this you could either look at the status of the player or at the direction they both would work but in my case self.status i think is the easier one so that's the one i am going to use so really all i'm going to do is player and status and what i want to get essentially is let me illustrate it here so i want to have these four directions so up down left and right my problem right now is that i have to get rid of these other directions so right idle would be kind of annoying but this is fortunately quite easy to get rid of because for that we have the split method and split method needs two arguments the first one is at which character we want to split things in my case at the underscore because back my player the up for example is split from the idle by the underscore so if we split this string by the underscore we get up and idle so that's then the first thing i'm caring about and you could also pass in a second argument that tells you how many times you could potentially split the string but in my case that shouldn't matter and now let's actually print what we get that's probably the easiest way to illustrate this so now when i run this again i press space now we get right now down and idle now if i move up we get up we get left and idle right down left this is working pretty good now what you do notice if we only stand and we have up and idle then python splits this but if we are moving and we only have up then we only get a single element but in both cases this is working really well so essentially this split method here if it doesn't find an underscore it's just going to ignore whatever it has but now we have a list of our directions and if the player is idling or not now the information if the player idles i was attacking i don't care about so i'm just going to pick the item with the index 0 because our string is always going to start with the direction which is the only part i really care about so with this simple line we already have the direction of our player so with that we can start figuring out the positioning of our weapon so if direction is equal to right i now have to figure out a different kind of rectangle and again let me visualize what i want to do and let me draw it a little bit larger so here we have our player and the weapon should be if we're moving to the right should be right here and i would invite you to think about how we could place the weapon in the middle of the player to the right of the player so that they're right next to each other and do think about this for just a second basically what i am going to do is our player has a mid right position of the rectangle so that's the position we are going to use for the player and then when we are placing the weapon we are going to place the mid left so let's call this one ml and this one is going to be m r so if we place those two points in such a way we would have both of these right next to each other when my player is walking to the right i want to place the mid left of my weapon and the position where i want to place it is at the mid right of my player and for now let's just add an else statement so we have something so self.rect is self.image.get underscore rect and center is going to be layer.rect.center so we don't get an error but now if we're running the game and we're moving to the right our rectangle should be spawned to the right of the player so let's try this and if i move to the right we get indeed something that almost works so we have our rectangle of the weapons pointing to the right of the player but if we look a bit closely and during the attack animation our player's hand is a bit too low and the reason for that is that the player hand is a bit below the middle part of the sprite so we don't actually want to spawn our weapon right in the middle of the player we want to give it a tiny offset and this we can add quite easily actually so this position here right now is a tiny bit too high but really all we have to do to change it is pygame.math.vector2 and we don't want to move it in the x position but we do want to move it down by 16 pixels so now let's try this again and now we have a weapon exactly where the hand is supposed to be so with that we have one direction now all we have to do is figure out all of the other directions so l if direction is equal to left and for this one i can just copy paste the right direction and change mid left to mid right and then mid right to mid left and the vector can actually stay the same that one's perfectly fine so now if i move right still works if i move left name left is not defined let's have a look ah should be in quotation marks so now let's try this again so right is still working and left is still working so cool now we already have two directions that work just fine okay now next up we have l if direction is going to be down and i guess let me copy the line again except now we want to place the mid top of our weapon and we want to place this at the mid bottom of our player and now for the vectors we do have to make a slight adjustment so in this case we do want to move the x position but not the y position so let's try this and we have right we have left and now we have down this one also seems to work so the one thing left is up and this we could put in the else statement so in here we want to place the mid bottom of our weapon and it should be in the mid top of our player and then we want to add this vector to it now we should have the placement of our weapon so down all directions look pretty good so i can't see any problems with this nice so with that we have the placement of our weapon obviously right now doesn't look very good because we have to figure out the actual graphics of the weapon now fortunately this is quite simple and let me show you the folder setup so here we have all of our folders and the one i care about right now is weapons and inside of weapons we have our five different weapons now if i go inside of sword we can see down full left right and up and the full sword is the one that's going to be in the ui but all the other directions we are going to actually display in the game and notice here down is exactly named like the direction or the status of our player so we can use the string of our player to select a specific weapon inside of this folder which is exactly the idea here although before we can actually select any direction we first have to select the weapon we actually want to use so we have to tell our player what weapon is currently selected and that is the first one we have to work on so let me do it straight back in the code so here we're back in the weapon code and right now we want to pick one image of the weapon but to pick the right weapon we need to know what weapon the player has selected and this i want to keep in the player so let me minimize this one again the input as well so in the movement let me actually add a whole new section here and let's call this one uh let's call it a weapon i guess that works and then here we can actually put create a tag as well that works a bit better now what i want to do in here is self dot weapon index and right now it's zero and later on this is the number we are going to change to select different weapons and how that is basically going to work is i'm going to get my self.weapon and this is going to cycle through this weapon data list here and we are already importing all of the settings so i can just use weapon data so i want to get one specific key from this weapon data and to get that we need a couple of different things first of all right now we only care about the keys so in our weapon if we have a sword allowance an x or any of the other weapons and from this i want to get myself dot weapon index so for example if our weapon index is zero i want to pick the sword if my weapon index was 1 it would be the lance but right now this would not be working because what keys returns isn't the list that you can index from apparently so we have to turn it into a list and now we can just pick from this list with a different index and let me demonstrate so print self dot web pin and in theory now if we start the game we should be getting sword so let's try it and windy gets sword so this is actually working nice so now we know what weapon our player is supposed to have with that information back in my weapon i can now get a full path to that weapon and that is going to become an f string and first of all we have to go up to the graphics folder and inside of the graphics folder we have to go to weapons now inside of weapons we have to get the specific kind of weapon our player has selected fortunately the naming of the variable is the same as the folder so we can just go with player dot weapon now next up we want to select the right direction and this we get with direction and finally all we need is dot png so now we have the weapon and the direction so really all we have to do now is use pygame.image.load and import the full path and as always don't forget to convert alpha all of this and technically this is all we needed so now let's run this and now if i press to the right we get an error and you can see down here we have graphics swords weapons sword right essentially i forgot one slash so back in my weapon after weapons there should be forward slash so now let's try this again and there we go we have a sword that works in all the different directions and that's a pretty good start although you can see the problem right now our weapon does stick around which is not ideal although it's kind of looking funny but okay cool this is working pretty well so the last thing we have to figure out is how to despawn the weapon once it's supposed to end and this i am also going to do in my level.pi file and in here let me minimize everything again i just want to create another method that i'm going to call destroy weapon and in itself and nothing else and now i want to first check if this weapon exists in the first place now right now we can't really do this because we have no way to identify if this thing exists so i want to store it in its own variable so in my init method i'm going to create let's put it actually even better let's add a whole another section and let's call it the attack sprites because there's going to be a bit more later on but for now i just want to have self.current attack and it's going to be none by default and then when we create the weapon it's going to be stored in self dot current attack so now in our destroy weapon all we have to do is if self dot current attack exists then we want to get self.current attack and kill it and i guess just for good form we can also set self.current attack back to none and now all we have to figure out is how to call this method here and i think this could be a pretty good exercise for you so try to figure it out and it's going to work in a very similar way compared to create a tag so let me minimize the init method again and in my create map i have already put self.create attack in there and now besides that i also want self self. destroy weapon oh i just realized the naming here isn't ideal let's call it destroy attack and destroy attack and here as well that way our naming is a bit more consistent okay and then in our player we now want self dot destroy attack as well and that one is just going to be destroy the tag and this one then is going to be another parameter so now we can call destroy tag inside of our player we just have to figure out when to call it and the answer in my case is in my cooldowns because we know after this cooldown our player's attack is supposed to be over so we can attack again so what we can do in here is self dot destroy attack and that is all we needed i believe so now i can attack in each direction and we can see the weapon so this is actually coming together really nicely and on top of that our weapon is also obeying the drawing order so it's drawn above or below different sprites so all of this is working super well now i guess there's one more thing that we do have to implement because right now we cannot switch between different weapons or well i guess we can if we go to my player and we change weapon index let's say to a free let's see what we get if i now press now we get the whatever this weapon is called but it's definitely working so we have to figure out in code how to change this weapon index from inside of the game and well let's do this in the input so in here we already have quite a few different things and i just want to add another if statement and in my case if keys now in my case the key i am using to switch the weapon is q so pygame dot k underscore q and in the most basic sense all that this one is supposed to do is get myself dot weapon index and add 1 to it unfortunately by itself it's not that easy for the same problem that we have seen with the attack and the magic input that if we didn't add a timer in here pygame would press or would trigger this code very often because the normal button press for normal human being is going to be let's say half a second long now for pygame half a second is a lot of frames in our game and for each of those frames this button would be pressed so if we press this button once python would update weapon index with plus 1 probably about 10 times so instead we have to create another timer like we have done earlier and now this timer has to be independent from the attack and the magic one because the player should be able to switch weapons at basically any time so i want to create another timer and the first we have to do for that is let's say in my weapon i think it makes sense there and what i want to create in here is going to look very similar compared to these lines here so first of all i want to create another variable that i called can switch underscore weapon and by default this one should be true and then besides that i want to have self dot weapons switch time and this by default is going to be none so that's the equivalent of our attack time now finally we need to cool down duration and in my case it's going to be the same thing for the weapon and for the magic switching so we can call this one self dot switch duration cooldown and this one i put at 200 so now we have all we need to create a basic timer so now back in this line here i only want to trigger the cue press if we press the button and if self dot can't switch weapon is true and if we have pressed it then self dot can't switch weapon should be false and just like we have done up here we also want to get the time that we press this button so self dot i think what did i call it weapon switch time so weapons which time is going to be dot time dot get underscore ticks and only once that is the case we want to update our weapon with plus equal one and let me just check if i'm starting at weapon zero yep so now in the game secondly we should be able to switch our weapon once let's try so right now if i press the attack we get our sword now if i press q we still get our sword and i think i know why so back in my player we are updating our weapon index but if i go up to the init method we have changed right now our weapon index but what we have not updated is our actual weapon so this was only set in the init method but it's not being updated when we press the button so that's what we have to do as well and let me just copy the entire list i think that's the easiest way to approach this so after i've updated the index i also want to update myself.weapon and this happens basically with the same line well exactly with the same line so now let's try this again so sort now if i press q and now we get the lance although since i don't have a timer to react to weight my can't switch weapons we can't change it again but that we can do now and that's going to happen down here in cooldowns and i would actually recommend you to look at our cooldown for the attack animation and copy it so we can switch weapons and have a timer for that what i basically want to do is if self dot can switch weapon and i want to check if this is not the case because we are setting this thing up here to false so only if this is false we want to run the timer and if the time is running i want to get my current time and subtract self dot weapon switch time and if that is greater or equal to self dot weapons which what i call it again we start to have a lot of variables switch duration cooldown there we go so down here switch duration cooldown now if that is the case we want to set self dot can switch weapon back to true and now let's try this again so now my weapon still works now if i press q we get the lance if i press it again we get the x press it again different weapon and a different weapon but now i press it again and now we have list index out of range and this happens if i go to my player that we are always updating this number by one but we only have five weapons inside of our list so at some point this number is going to exceed the length of that list but that we can fix fairly easily and really all we have to do is if self dot weapon index is more than the length of the list of our keys so this thing here and only if that is the case we want to add plus one to our weapon index now if that is not the case we want to do something else and what we want to do is to set our self.weapon index back to zero so once we're exceeding that number we are going back to zero and that way i don't have to implement a backwards mechanic for this button but you could totally do that if you wanted to but with that logic we have the weapon mechanic so let's try so now i get sword lens x next one next one now if i press q again we still get an error okay not great let's have a look ah and what i just saw this should be length minus one because we start counting from zero so now let's try this again different weapons different weapons and answer again now we're back to sort cool so now this is working so this is a common thing in python that the length of our list was one too large because of the way we're counting the length of the list but well now we have our proper weapon mechanic so all right with that we have a weapon although right now you can't really see the weapon so next up we are going to work on the ui and i guess while we're at it we can also implement the health bar the energy bar the experience or the souls and then the magic we currently have selected so we have all of the stuff in one place so i guess let's talk about how to approach the ui that's going to be the next section i guess in the most basic sense the ui is going to consist of two different elements number one is our player is going to have a ton of different data for example what our current weapon is that's one we already have but besides that we also need health energy experience our magic and i guess that's it and these are the things we have to add to our player now once we have all of them we can actually start working on the ui elements that are visible and this is going to involve a couple of different things for example we have to show the health bar and the energy bar and both of those for example are just rectangles and the width is determined by the amount of health as a proportion of our full health or our full energy so we're not really going to do anything sophisticated we're just creating different rectangles and the weapon and the magic are just the images with some background rectangles one has a color one only has an outline and if we combine these different elements we basically get some nice looking ui that i think came together really really well and i guess this part is best explained when i actually implemented so let's start with number one and let's give our player a couple of key attributes to actually create a game here i am back in my player and let me go down and add another section here and let's call this one stats and what i'm going to paste in here is just going to be a dictionary so we have our health our energy our attack our magic and our speed and i guess if you're confused right now we have attack here and for each weapon we have damage and what i'm going to do later on is our ultimate damage of the player is the base attack plus the weapon damage so these are going to be our base stats but we need a few more things so right now our health is at 100 and this would be our current maximum but now imagine we run the actual game and an enemy hits us then we have to lower this amount but we still have to know what our maximum amount is and for that i want to add self.health and by default it's going to be self.stats and just health so by default our self.health is going to be the same as the maximum we can have however later on in the game we can actually lower this amount and then we can have a different between the maximum and our current health and we can do the same thing since we're going to need it anyway is our energy and this is just going to be self.stats and in here our energy and there's one more thing that we do need for the ui and that is self.exp and this one doesn't have a stats entry because it's well just the experience and let's say just so we have a number let's go with one two three and actually while we're here we can also now determine self dot speed is going to be self dot stats and speed so now we can go up a tiny bit and get rid of this speed here because later on we want to be able to update this and i guess it should be five by default so we keep the same speed okay now our player has some stats and some current stats that we can work with so now we actually have to create the ui and what i want to do is to create a new file that i'm going to save as ui.pi and in here as always we need import pygame and from settings import all of it and now i want to create a new class called ui and then here as always we need our init method with self and nothing else and for now let's just add a pass in here and figure out how to call this thing in the first place and i want to call this from the level because in here we are drawing all of it and let me minimize all the methods so it's a bit easier to see let's say we can minimize this one as well now in my level class i want to create another section and let's call this one the user interface and what i want to do here is self.ui is going to be ui so the class we have just created this one here and for that to work we have to do from ui import ui so now we can actually use it and pretty much what i want to do in my run method on top of everything else i guess i can get rid of the debug one i can run self dot u i and essentially i want to give it one method that i call display and to get the information from the player i want to pass self dot player in here and that is pretty much all we have to do in our level now we can just work in our ui and all we need is one method that was called this play and we need self and the player as the arguments so now we can go pass and now we have a class where we have access to the player and we can call it from the level itself or well we are always calling it and now let's run this we don't get an error so at the very least it's working cool so now we just have to figure out all of the ui elements and there are quite a few different ones so let's go through this thing step by step first of all we need a couple of general bits of information so let's call this general and first of all i want to have access to the display surface and this we get as always with pygame dot display dot get underscore surface now next up we also have some text so i want to create self dot font now we do have a font that we can just import and i also know the font size but for my ui design i have quite a few parameters like the bar height the width of all the elements the box sizes of the weapon and magic items and i want to store all of this in my settings so before i import the font let me go to my settings and in here i want to add another sections that i called the ui and in here i have a couple of parameters that look like this and these are all the elements i will need to well make the ui work and actually while we are here there are a couple more and these ones are going to be colors so we have our general colors we have the water the uibg color the border color and the text color and then we have the health bar color the energy bar color and then if we select something you're going to see how those look later on but for now all of these are just very simple variables that don't really store anything complicated so all right now we can use them so first of all i want to import my font and this is going to happen with pygame.font.font and in here we need the font we want to import which in my case is i called this one ui font so ui underscore font and then we need a font size which in my case is stored in ui underscore font underscore size and now we have to choose which element to start with so we can either do the health and the energy bar the experience or the weapon or magic and let's say we're going to start with the health and energy bar i'm going to add another tab here and let's call it for now the bar setup and right now i want to create some general rectangle where the health and where the energy bar is going to be and this is just going to be a rectangle and i'm going to call this health bar rect and this is going to be pygame dot rect and now for this one we need the left the top the width and the height now the width and the height we do have in here so we have a health bar width that we can put in here and the bar height is identical so it's just called bar height so bar height now next up for the left and the top i just went with 10 and 10 which is in the top left now besides that i also want self dot energy bar rect and this one is going to work in a very similar way so pygame direct and now again we need to left we need the top we need to weft and we need the height and now the height we already have is just the bar height for the width we have energy bar width in our settings so within here and i want this one to start on the same x position but the top is supposed to be a bit further down i went with 34 and now once we have that we could actually already try to draw something so let's see if this works in the first place so i just want to use pygame.draw.rect and in here we need a surface we need a color and we need a rectangle and for the surface we have self dot display surface let's say for the color for now it's going to be black we're going to change this anyway and for the rect let's go with dot health bar rect so now let's try this and we can indeed see a health bar in the top left and this one stays in a nice position so this is working very well cool but i don't want to draw this element right here so let me add a pass in there again instead i want to create a function that is a bit more flexible so just a function that can take a current amount a max amount a background rectangle and a color and then display either health bar or energy bar so we can use it for both and well let's implement this one so i call this one show bar and in here we need a couple of different arguments so first one we need the current amount then we need the max amount then we need the background rectangle and then we need a color so for example what i essentially want to do i want to call self.showbar and then in here i want to pass in player dot health and player dot stats and health so that's our max health then i want to pass in this rectangle and this is going to give us the position of where the health bar is going to be and then finally i want to give this thing a color and a color we get from our settings we have health color although granted it's just red so in my ui i can pass this in here and where this system is really useful now we could just copy all of this and change health to energy and then this health should also be energy and our health color should be the energy color although again the energy color is just blue all right now we have a function to create the health and the energy bar we just have to write it first of all we have to draw the background that is what i basically wrote just a second ago so again pygame.draw.rect and here we again need self.display surface then we need a color and in my case the color is the ui bg color so i can paste this here and then we're going to need our bg rectangle and i guess quite important this color here is not supposed to be this color up here so that's not the case right now we are just drawing the background of our bar we're not drawing the bar that's supposed to indicate the health right now that will come in just a second but now actually this should already work let's try this and yeah now we can see our two bars for health and energy in the top left and they are working perfectly fine and now that we have that we can start working on drawing the bar although now we do have a problem and let me illustrate what the problem is so right now we have one bar let's say it has a length of something like this and i know from my settings so the health bar width for example that this entire thing right now is 200 pixels wide and all of that so far worked pretty well now the problem is that my health is not in pixels so this player health here at the current maximum would be 100. so this would be our full health the problem is inside of this thing we have to convert this 100 to a 200 and this should then obviously be flexible so we have to figure out how much is 100 health in terms of pixels in our health bar so we need a bit of math to convert our health into pixels and let me actually add another section to that so converting stat to pixel and first of all i want to figure out a ratio and that is going to be my current amount divided by my max amount and that is going to tell me how much of my max amount do i actually have and this is already getting us really close to a pixel measurement because i know for example for my health my max amount is going to be 200 pixels wide so what i want to figure out next is my current width from that and all i really want to do in here is get my background rectangle and get the width from that so that is my max width in pixels and this i just want to multiply by the ratio and let's do some numbers just to illustrate how this is going to work so our current health right now is 100 and our maximum is also 100 so if you divide one by the other you end up with one now our b direct for our health is going to be 200 pixels wide and if our ratio then is one we are going to get a pixel width of 200 for our entire bar so this is then working quite well now let's say we have different numbers so instead of 100 we get 50. now our result is going to be 0.5 and if we multiply 200 with 0.5 we don't get 200 we get 100 which is exactly half of the width of our background rectangle all right so now we have to use that information to create a new rectangle so let's call it current rect and since i already have in my background rectangle most of the information i can just copy this one and now for my current react dot width i'm going to set this to my current width so this way i have a rectangle in the same position with the same height but with this line i give it a different width so all we have to do now is to draw this rectangle so pygame.draw.rect now we still need self.display surface next up we need the color and that color we are getting from the parameters so we don't have to worry about it and finally i want to draw my current rect and now let's try this there we go now in our top left we can see our health and our energy bar and what i can also do so let's say in my player just to illustrate let me multiply our health by 0.5 and our energy by 0.8 now if we run this you can see that we have half of our health and most of our energy so this way we can change the health and the energy of the player and it updates automatically so this system works super well now there's one more thing i did add to this and that is basically a border around the health bar which does make it look a bit nicer and this is just pygame.draw.org self dot display surface now for the color we have in settings a ui border color so that's the one i'm going to use here and then besides that we have the current rectangle so right now we are just drawing a rectangle on top of the other rectangle which wouldn't be very helpful but now if we are giving this another argument this would be the line width in my case it's free and once it gives something in line within pie game the fill disappears and we only have the line let me actually demonstrate now it looks like this oh when i did make a mistake right now we are just drawing a bar around our actual health which is not what i want instead i want to draw around my bg rect so we are covering the entire bar with an outline so now let's try this again and there we go this is looking quite a bit better it's a touch hard to see but if you look at the left of it it is definitely there so alright with that we have our health bars wasn't actually that bad so now i can minimize my show bar and never worry about it again so with that part covered we can start working on the experience and that part should be really easy basically what i want to do i'm going to call another method and this one's going to be called show exp so let's create that method show underscore ex and this one besides self also needs let's call it the exp and now what i want to do first of all i want to create a text surface and the text is going to be the experience and essentially this means i want self.render and in here we need the information we need antialiasing and we need a color and let's go through them one by one let's start with the easiest one antialiasing in my case it's false because i have pixel art and this one shouldn't be in the earliest and besides that for the color i can go to my settings and in settings i have a text color so that's the one i'm going to use and then finally we have our information and this is supposed to become the axp and right now exp is going to be in our player and it is this number here an integer now the problem is that python for this one needs a string so this one wouldn't work by itself but we can fix that fairly easily by using the string method and there's one more thing i would like to do and that is that i want to convert this number into an integer now why do i want to do that because right now our experience already is an integer essentially this is to make sure that our numbers don't get too long so if by some weird math we end up with a floating point number with 10.0001 this would look very strange in the experience and converting this experience to an integer avoids that problem entirely so next up we have to figure out how to place this surface and i did that with a rectangle and really all we need here is the text surface and get rekt and since i want to place this thing in the bottom right let me actually draw it really quick so if this is my entire game window i want the experience to be down here ish and to place it down here i think the best point would be the bottom right so let's place that one actually i think this could be a pretty good exercise so try to place the text rectangle on the bottom right of the window wherever you think it looks good and then draw the text on the display surface first of all i need bottom right that's the point i would like to place and for this one i need x and y so i have to figure out what the dimension of these two variables are going to be and let's do them in separate variables so it's a bit easier to see what i'm doing now what we have to be aware of here if this again is our entire window and we are placing our experience down here with this origin point the thing i have to figure out is the maximum width of my window so this distance here and this would give me the right side of the window and now what i have to figure out from here is how far away i want to get from there and this would then give me my origin point on the xaxis and the same for the y we essentially first have to get the entire height of the window and then from that point subtract how high we want the experience to float from the bottom of the window so what that means in practice is we first have to get the dimensions of our window and this we can get with self dot display surface and get size and this is going to return as a tuple of x and y and for x we only care about the first one that is the x dimension now we can copy all of this and target the first one so with these two points our window would be right at the bottom right of the screen but i want that to be a tiny offset and in my case for x i went with 20 and for y i had the same number so now our text rectangle is in the bottom right of the window now all we have to do is call self dot display surface and blit and pass in the text surface and the text rectangle and we are almost done the one thing we haven't done yet is in show xp we have to pass in the experience and this we get from player and that is still the player we are getting from the argument of the display method but player right now isn't good because we want the experience of the player so i want player.exp i believe i called it so in here yeah player.exp and now this should be working so let's try to run all of this and there we go in the bottom right of the window so all the way down here you can see the experience so not a bad start although also not a great one because you can barely read it but this we can fix quite easily because we can use the text rectangle to draw a background and a frame around this box so let's do that and first of all the background has to be behind our text and all i really need to do in here is to call pygame.draw.rect and in here i need my display surface so self.display surface then i need a color which in my case i called u i b g color the same as the health bar and finally a rectangle so our text rectangle and now this is already looking quite a bit better although not ideal because i would like the box to be slightly larger than the text but this we can also fix so this rectangle i want to be slightly larger and this we can also do with the inflate method that's the same method we've seen earlier to create the hitboxes and earlier we passed the negative numbers to make the rectangle smaller but if we pass the larger numbers let's say 20 and 20 now our rectangle is going to become larger and that is exactly what i wanted so with that we have our background but i also want to draw a frame around this box and for that i am just going to copy the draw method and now i can add another argument and that way we get a frame which in my case has a width of three and then we also need another color and i call this one ui border color and now let's have a look and there we go the effect is fairly subtle but i do think it does make it look a little bit better but all right now we can show our experience so now let me minimize the experience method and now there's only one more element we have to cover and that is the selection box for the weapon and the magic and this i want to work kind of like the health and the energy bar that i have one method that just creates a box and then i can give this box different arguments to display different player statistics although this one has to become a little bit more complex since we're displaying an image but it's not that bad i guess let's work on it straight in the code now first of all i want to create another method that i have called selection underscore box needs self as always and then we need a position and i call this left and top and that is all we are going to need for now although there is going to be a change later on and this selection box is essentially going to give us the background box for our weapon so this is the box and then later on we are going to paste an image of the weapon in here so this selection box gives us the box and the position where to place this surface you're going to see a second what i mean now first of all we need a rectangle and i call this one the bg rectangle and for this one we want to create a rectangle so pygame.rect and for this one we have to figure out the left the top the width and the height and left on top we already have that part is literally the arguments we are getting from the function itself so those two we don't have to worry about now width and height are also very simple because in my settings i have an item called item box size and this one is supposed to determine the size of this box and since we are creating a square it's the same dimension for both x and y so now we have our background rectangle and what we can do already is draw it so pygame.draw.rect we need self dot display surface then ui bg color and then bg wrecked we can already call it just to see what's going on so selection box and let's say for the left i will go with 10 and for the height let's say 1150 so now let's try this and we can't see anything ah for the simple reason that this number is way too high it should be more like 600 let's try now there we go now in the bottom right you can see the rectangle i guess let's put it a tiny bit further down let's say 630. oh yeah this feels much better so now we have a rectangle cool now what we can also do is copy this entire thing give it a border radius and now call this ui border color and with that we also have the frame around this box which is already making it look better nice and this is basically all we are going to need for the overlay for either the weapon or the magic so essentially what i'm going to do is call this twice the first one is for the weapon and the second one is for the magic and for the magic box i went with 85 and i put it a slight bit further down i think 35 is what i used so let's call it and there we go now we have our two boxes and they are slightly overlapping which i think looks pretty good actually let's give it a bit more of an overlap let's turn this to an 80. and there we go i think this looks really nice cool so with that we have our selection boxes now what we have to figure out is how to pass the weapon or the magic image in here and i realize we don't have the magic yet we're gonna work on that in the next section but for now let's figure out the weapon and i'm gonna put this in its separate method and let's call it the weapon overlay and since this method has to know what weapon the player is using i also want to get what i call the weapon index and this weapon index is going to be this weapon index in our player file or player class and i'm going to use that to figure out which surface we want to draw now first of all i want to call this selection box method from inside the weapon overlay and for that i can just copy all of this and paste it in here that already cleans things up and instead of calling this method i can call weapon overlay and i guess what we call the method i can also place in the argument so player dot weapon index so right now there shouldn't be any change and there isn't so now we are already drawing our background but this is only one thing i want from this because what i really want from this background is the position where my surface is supposed to be placed so ideally what i would like to do is to take this background rectangle and somehow get it inside of my weapon overlay and then place my surface of the weapon inside of that rectangle and that i can just get by returning the bg rect at the end of this method so now in this other method i can get let's just keep calling it be direct and i can get rid of the comment i suppose so now we have our bg rectangle available in our weapon overlay and i can minimize selection box we don't need it anymore and now essentially what i want to do i want to get myself.display surface and blit and i want to get a weapon surface and a web pin rect the weapon surface i'm going to get from settings and in my weapon data it's this graphic here and my weapon rectangle is going to be just a rectangle and the center of this rectangle is going to be in the center of this bg rectangle and that way our weapon is inside of our background i hope that makes sense so we have to figure out two things first of all we need the weapon surface and for that we have to look at our settings and in here we want essentially get this information although right now this is slightly difficult to get because this is a dictionary and we only have an index so instead we have to convert this dictionary here into a more usable list and that i want to do in the init method so let me add a comment here and let's say convert weapon dictionary and really all i want to do i want to have self.weapon weapon graphics as a list and i also want to spell this correctly and in this list i want to have all of the surfaces of my weapons so essentially what i want to do is for weapon in my settings i want to get the weapon data so in weapon data and i don't really care about the keys i only care about the values so what i essentially get now is another dictionary and inside of this dictionary i only really care about graphic so let's save this one in path and we get this one in weapon and graphic i think graphic or graphics just graphic and now what i can do is get my weapon and just pygame dot image dot load and i need my path and as always i need my convert alpha and once i have that i just want to add this weapon to my weapon graphics so append and my weapon so now i have all of my weapons in an accessible list and what i can do with that in this weapon surface down here in my weapon overlay i can just get self dot weapon graphics and pick the one with the weapon index and that is literally all i needed now i have the graphic and now i can get my rectangle and this is just going to be my weapon surface dot get underscore rect and i want to place the center at the center of my bg rect so dot center and now we should be having a weapon let's try and there we go we can indeed see a weapon and now if i press q we also get different weapons depending on well what we have selected so this is working very very well attacking also still works with the same result nice now there's one more change i would like to make and that is when we change the weapon i want the frame of this box to be highlighted in yellow so we get some indication of what we are doing and that's just adding some visual niceties to it it really isn't anything major and all this really means in code is that this border color should have a different color while our player is switching the weapon and we know when the player is switching the weapon because in my player i have can switch weapon and essentially if this one is false i want to have the border color of this one differently and well for that we have to pass a couple of arguments through so let's start with the selection box that's the first one down and in here i want to add another argument and let's call this has switched and now i can add an if statement that if s switched is true then i want to do something but if that is not the case so else then i want to keep on doing what we already have done by drawing this border color however if it is the case that we have switched i can copy this and just draw this frame in a different color and the different color we have it's ui border color active although this one is just gold i'm very lazy with colors okay now we have border color active cool so now we have to figure out how to get this hair switched inside of our weapon overlay so in here our selection box also need has switched which we can't get right now because we only have the weapon index so i need to give this one another parameter and i guess we can keep on calling this as switched and now finally when we call this method we're getting our weapon index and now we have to figure out an argument and we know it's going to come from the player but now in my player we have can switch weapon but if i just pass it in here actually let's try this but first of all we have to comment this selection box out otherwise we get an error so now if i run this we get the golden border by default and if i switch my weapon it disappears for a second so we have to do the exact opposite because by default this attribute here checks if we can switch the weapon but what we want to check in here if the player has switched the weapon is the exact opposite and well all we have to do is add a not before that and now we should be good to go so now we're checking the inverse of that variable and now if i press this we are getting the right selection so this is working pretty good nice and i guess to get the magic in there as well we actually have to give our players some magic abilities and i guess let's work on that and once we have the magic we're going to finish the ui and the magic is going to work kind of like the sword at least in terms of data and the player so we have a dictionary with lots of data we give our player a timer and the ability to switch between different kinds of magic and then once we are casting magic we are doing something although that something is going to be slightly more complex than just spawning a sprite because our magic is going to be a bit more complex so for now we are going to skip this part and we are still going to just print at our players doing something the reason here is that to actually make the magic work we need particle effects that we don't have yet and that are really really important hence we can't really do this but we'll come back to this later but for now let's do at least the basic magic so we can finish the ui and there really isn't anything new so let's jump straight into the code and here we are back in my main file and i want to go to settings i need another dictionary for my data and this one is for my magic and if i paste this we essentially have two spells we have flame and we have heal and this dictionary works very similarly compared to the weapon data and for the ui the important one we care about is this file here or this string to an image and i guess for the player we also have a strength and a cost but really nothing particularly complicated so now we have to figure out in my player how to use this and i guess we need a couple more attributes and let's put it right below weapon it makes the most sense there and first of all i need a magic index that by default is going to be zero and that is the same idea we had for dot weapon index so those two are going to be the same as a matter of fact we are going to copy quite a bit from here since our weapon and our magic at least in terms of data are very similar so the next thing i want to do actually i can copy this entire thing and paste it in here so now i want to get myself.magic so the magic i currently have selected and for that i want to get my magic data dot keys and self dot magic index so this information essentially gives me either of these two strings which is the key for this dictionary then besides that we also want can switch magic to select it for the ui and by default this should also be true and then we need self dot magic switch time and this by default is going to be none essentially what we have done in these four lines here is the same we have done earlier for our weapon so nothing new although there's one more thing that we do need and for our weapon we have self.create attack and we are going to need the same thing for our magic and i guess just to keep the symmetry let's put it right at the top so self. let's call it create magic and this one is going to be create magic and this create magic we have to get from our parameters so here create magic now in my level let me minimize all of the methods besides create attack i also want to define create magic and this create magic is going to need a few more parameters first of all i want the style of magic i'm using then i want the strength of that style and finally i want to have the cost of that style and in this method later on we are going to have a system to select different kind of magic spells but well that's quite a bit off for now we're just going to print this style we're going to print the strength and we're going to print the cost so at the very least we can tell what's going on and besides that what we need is when we create the map and we create the player actually let me add a bit of a few more lines here so we can actually tell what's going on with the player okay this is much easier to read so now finally i want to add create magic and as always make sure you're not calling this method you're just passing it into the player and all right now in our player we have to create magic method and we have all of the attributes we need i hope i didn't forget any so for the next step let me actually minimize all of the methods for the player so it's a bit easier to see now the next thing i want to do is in my input right now we have one way to cast magic and what we have done so far we just printed magic but now i want to self dot create magic and for that create magic i need my three arguments i need my style i need my strength and i need my cost and let's put those three in the separate lines so it's a bit easier to see so we need a style we need a strength and we need a cost and this is information we will get from this dictionary here and we know which of these to target by using our in the unit method by using this magic index and i feel like this could be a pretty good exercise so try to use the magic index that when we are pressing the magic button we are calling this create magic in the proper way alright let's start with the easiest one this style and we first want to look at the magic underscore data and what style is supposed to be is a string that either says flame or here so we need the keys of this dictionary so magic data dot keys and this i want to turn into a list with list so we can use indexing on it and once we have that all we really need is self dot magic index and then we are good to go that is actually all we needed so next up we want to do something fairly similar so let me copy all of this and now we want to figure out the strength so let's look at the dictionary again now we actually want to look at one of the values for these dictionaries and from this dictionary we want to get the one that is called strength that has the key strength rather and that is actually kind of simple as well so now instead of keys we are looking at values so this list here would be a list of all of our values and if we pick one we end up with one dictionary let's say this line here if it was zero would be giving us this dictionary and once we have that all we need is to pick one element from this dictionary and i want the key strength is what i called it i think yes strength and now for the cost all we have to do is copy this thing and now instead of strength we are looking at cost and i guess just to check if this is even working let's try this in our game so let's run my game and let's press ctrl and we get flame 5 and 20. so this is actually working nice although there's one change i would like to make that right now my strength is just from the settings this strength here but essentially what i want to do is to give my player also a magic ability actually my player already has that this magic here that's basically the in build magic power of the player and we're gonna add this to the magic damage so for the strength i want to get the strength of the spell plus myself dot stats and i call this one magic i think yeah magic so this self dot stats magic here so that way we can level up our spells and we make them stronger so let's try this again and now we get five plus four is nine so this is working really well so with that we can call our magic and next up we have to be able to switch between different kinds of magic and that's going to look very similar compared to this weapon switching mechanic so i suppose what we can do is just copy the entire thing and then let's work from there first of all on the first line instead of q i want to look at e and then can't switch weapon should be can switch magic now the next line can't switch weapon is false should be can switch magic and for the time it should not be weapon switch time it should be magic switch time then next up we don't want our weapon index in any of these so this should be magic and then the list we are looking at shouldn't be weapon it should be magic but everything else is still the same this weapon should also be magic and then finally self dot magic should be our list with not weapon data or the weapon index it should instead be our magic index and now this should technically be working so let's try this in the game so now i press ctrl we get flame 9 and 20. now if i press e now we get here 24 and 10. if i press e again we should go back to flame and we are not it sticks to heal so let's have a look here we have our entire if statement and i think i just figured out what the problem is that for our weapon we have a timer that reactivates the weapon whereas for the magic we don't have a timer so once can switch magic goes to false it never turns on again we can actually test this so at the end of this if statement i want to print magic and now if i call this we get flame if i press e we get magic but if i press e again i don't see anything so we only ever update or we only ever call this one here once and the reason we can only call it once is because further down in our cooldowns there's no cooldown for the magic but we can create one quite easily by just copying the weapon switch mechanic so if can switch magic i want to get my current time then my magic switch time is what i called it and if that is greater than my switch duration cooldown that's the one that can stay constant or well the one that doesn't change between the weapon and the magic and if that is the case mike can switch magic should be true so now we have the cooldown now let's try this again so i get my flame 9 and 20 i press e we get heal i press e again now we're back to flame and i can keep on pressing this it always works nice and with that we have our basic magic obviously it doesn't do anything right now but that will come later i guess what we can do now is work on the ui to display the magic and this is going to work in essentially the same way that we have done for the weapon overlay so let's actually implement it straight away although if you want to do this as an exercise i would recommend you to try this out in my case let's call this one magic overlay and here we need self we need the magic index and we again need has switched and if that is the case actually let me copy all of this again since it's going to look fairly similar so magic overlay might be direct is now going to have these two numbers so these two numbers and i actually also want to call self dot magic overlay with my player dot magic index and then not player can switch magic i believe i called it so those two methods are basically identical except we're using different data and the bgrack still works but now we need a magic surface and a magic rectangle and for the magic surface we need our magic graphics and our magic index oh and i just realized we don't have our magic graphics yet let me cover this one in just a second first of all for magic rectangle i want to get my magic surface and the rest can stay the same and now i want to replace weapon with magic okay we are nearly done the one thing i did forget is that in the init method we also have to get the convert magic dictionary so kind of the same thing we have done for the weapons that we create a list with all of the surfaces and i want to do pretty much the same so self dot magic graphics by default it's an empty list and now for magic in magic underscore data dot values i guess for this one we can go straight to the magic surface and i want to get pygame dot image dot load and the path is going to be magic and graphic and as always for this one we also need convert alpha and then self dot magic graphics dot append magic i guess if you were to do all of this by yourself i would recommend to combine these two imports into one function so you can reuse them it's a bit more elegant and i guess you could also combine these two functions here in a bit more detail but i guess there are so few lines in my case i don't really mind that much but alright now we have our import graphics and this magic overlay also works and i think we're done let's try so i can see my magic and i can see my weapon if i change my weapon it still works if i change my magic it also works cool so now i can change between my different magic and weapons and we can still use them in the game as well so this is working really well so with that we have the ui all covered next up i guess we can actually start adding some enemies to make the game a bit more interactive and the enemies have to be able to do quite a bit because they are nearly as complex as the player so there are a couple of things that we have to implement here and there's one more thing i would also like to cover that since our player and our monsters are fairly similar they can share a couple of methods with each other in my case the methods they do share is the move and the collision method they essentially move in the same way the only difference is that our player gets the direction from the input whereas the enemies get the direction from what the player is doing so if the player is very close to them they're moving towards the player and if the player is further away they don't move at all but once we do have a direction they are basically going to work in the same way so what we have to do for now first of all we have to import a bunch of data for the enemies to actually display the very basics of them then we have to split some methods from our player and create a new class called entity and then both our player and our enemies are going to inherit from that class and once we have all of that we can actually start implementing some enemy functionality so i guess let's jump straight into the code and let's have a look at this so here i'm back in my code and first of all i need some data and all of that is in the settings and in here i want to add yet another section that i called enemy and in there i want to import another dictionary that looks like this so in here we have our enemies for example we have let's say the raccoon we have a health experience damage their attack type and their attack sound and then at the end we get quite a few more like speed resistance attack radius and notice radius and all of these things are going to determine how they are going to operate but that is literally it besides that the classes are going to be identical and i guess really quick to go through what each of these pairs do health should be fairly obvious it's how healthy they are experience is how much experience they give and damage is well how much damage they do to the player attack type is purely for the particle effects so when the enemy is attacking the player this is going to be what will be displayed on the window and besides that at the end speed should be fairly obvious resistance basically means if the player is hitting the enemies so let's say this is our player and this is our enemy and if the player hits the enemy then our enemy is supposed to go a little bit backwards and the distance by how much the enemy is being pushed back that's the resistance then we have attack radios and notice radius and essentially what they mean let's say that this here is our enemy and the enemy has two radiuses the first one is the attack radius and let's say this one is going to look something like this it is literally a radius around the enemy and if the player is inside of this radius let's say right now our player is here if that is the case then the enemy is supposed to attack the player and that is the attack radius and you see it's 80 and 120 or very small numbers they basically mean if the enemy and the player are very close to each other then the enemy should attack now besides that we have our notice radius and the notice radius is substantially larger it essentially is something like this let me draw it out and if our player is inside of this radius then the enemy should only move towards it but it should not attack so that way once our enemy is close enough to the player it starts moving towards the player and then once the enemy is close enough to the player so the players inside of the attack radius then the enemy is going to attack and if the player is outside of that so here then the enemy isn't going to do anything so i hope that makes sense and all right with that we have the data for our enemy they do get fairly substantial now next up in my player let me minimize all the different methods so it's a bit easier to see now right now the move and the collision method we want to reuse for the enemies as well so what we could do is make the enemies inherit from the player but that feels kind of weird so instead i'm going to take these two methods out and put them in a separate class and let me for that create a new file and let's call this one entity dot pi and in here we have to import pi game and then i want to create a class that i called entity it has to inherit from pygame.sprite.sprite and once we have that i want to give this thing a done there init method in itself and groups and then in the super dot init method we're going to pass in the groups now once we have that we can from the player get this move and this collision method so let me just copy them paste them in here and now our entity has these two methods so what we can do now in the player i can literally just delete both of these methods and now the player isn't supposed to inherit from sprite anymore instead we want to inherit from entity and for that to work we have to from entity import entity and now technically nothing should change and this is still looking very good cool we can still do all the stuff yep that looks very good this is then what we can use for the enemies as well it's going to make our life a bit easier and on top of that we can actually add a few more things in here so we could for example add the self dot frame index with a start of zero self.animation speed could also be in here so 0.15 and self.direction is going to be pygame.math.vector2. these basic attributes are going to be shared across our player and our enemies anyway so having them in here seems to make a bit more sense so now in my player i can get rid of frame index and animation speed and from direction and just to make sure things are still working let's try and seems to be all good and working so with that we have a basic setup for our enemies and with that we can start creating the actual enemy class but first of all let me clean this up a bit so we don't need our ui anymore and we also don't need the weapons and if i close them we have a bit more space and now let me create a new file and i'm going to save this one as enemy dot pi and in here as always we have to import pi game then from settings import everything and don't forget from entity import entity and now we can create our class and me and this one is supposed to inherit from entity and that way we already have all of this available so we don't have to rewrite it but we are still going to need an init method needs self first of all then i do want a couple of different things first of all i want something like a monster name and this monster name is going to be used in a bit to pick either squid raccoon spirit or bamboo so we get different monsters then besides that i also need a position so i know where to place it at the beginning of the game and don't forget we also need the groups now besides that let's start with a general setup and in here the first thing we always need is the super done the ended method and in here we have to pass in our groups and there's one more thing that i would like to add that is self.sprite underscore type and in this case it's just going to be enemy and this sprite type let me open my tile again it was in here so this is our tile class for all the inanimate objects this one also has a sprite type although this one is a tiny bit more flexible because we have different types of tiles but for our enemy we are always going to have our enemy and the reason here is that these are supposed to react differently that if our player attacks an enemy for example then we want to reduce the health or kill the enemy if the health goes below zero however if our player attacks a tile that is a grass for example then we want to destroy the grass immediately the grass doesn't even have any kind of health and then if we have something like a tree or a statue they are not supposed to react to the player whatsoever and for that reason we need different kinds of sprites and i guess you could organize this with different groups as well but i feel like using this system is a little bit more straightforward but there are different solutions to this all right now we have our spread type now next up we have to work on the graphics setup and i guess for now let's just place the enemies on the map and then improve them continuously so what i want to do for now is create a self.image and a self.wrecked and that way we can just place them on the map and then improve on them and for now for the image i just want pygame dot surface let's say 64 and 64. we're going to change that anyway and self.image dot get rekt and the top left should be the position and with that we have our enemies now if you remember all the way back in our level we made this thing here and we are still going to use it to place the enemies and for that we first have to import the csv file which fortunately is very easy so in here i want to create my entities and this is going to be both my enemies and my player and we again want import csv layout and in there we have one more string that we didn't import so far and let me just copy it in here it looks like this it's in the same folder as all of the other csv files we just didn't import it earlier because we didn't need it but we always had it and all right so now this for loop is going to get another csv layout so what we can do is add another if statement in here so if the style is equal to entities and there are a few different kinds of enemies we have to be aware of so this if statement will get more complex but for now we only really have two different kinds of tiles we either have the player that one's actually right here and then we have our basic enemy class that for now is just black image and how this is going to work is if the column is a certain number for example the player in this list is number 394 and if that is the case i want to create my player in that if statement and let me just indent things properly so it's a bit easier to see uh this player also works yes okay now i think you might be confused where do we get this 394 from and the best way to see this is if i just open tiled you're going to see it in a second alrighty here we are entitled and this is our entire map and we got this map from this tile set here and let me open the tile set by itself and here we have the tile map and if i just click on the random tile let's say this one here let me add an arrow to make this a bit more visible so this tile here has an id of 252 and if we export this tire set that is the number we get and now if we click for example on the player it says 394 exactly the number i used to import the player and if you clicked on different kinds of enemies we get 390 91 92 and 93. so basically where this number comes from is on this tile set tiled orders each tile from 0 all the way to the end so we have 0 1 2 3 4 5 6 and so on so if you ever have to double check the numbers that's where they are coming from so now we are importing our player and later on we are going to have more if statements with the different numbers for the enemies as well but now we can also update the position of our player it should not be this random position i gave it it should instead be x and y and those are the numbers we created ages ago all the way up here so we're just reusing those and i guess for now let's just see if this is working in the first place and there we go now our player is starting in a slightly different position but besides that nothing has changed but at the very least we know it is working so now back in my level i can for now just add an else statement and what i want to create in here is an enemy although for that to work i have to import the enemy class so chrome enemy import and me and now we can use it in here and i guess let me copy the parameters and paste them in here so it's a bit easier to work with now for the monster name let's say for now we can just say monster doesn't really matter for the position we keep on using x and y and for the groups let me copy it from the player so we definitely want the enemies to be in the visible sprites but besides that since the player isn't supposed to be able to collide with the enemies that's all we need for now so now we technically should be having all we need to create some basic sprites and there we go this is actually working well i guess kind of at the very least we can't see where the enemies are supposed to be so that's at the very least a start so i guess now we can just flesh out our enemy class and add more and more to this to make it actually work and i guess the first thing we can start with is the graphics setup so we can actually see what's going on and to get our graphics i want to import something and this i would like to keep in its own method so let's call this import graphics and since we have different kinds of data so in my settings i for example want to import all the data for this squid for that i will need the monster name and this i'm going to add in the import graphics so in here we are going to add monster name and i guess let's create that one so import graphics self and let's just call it name and this import graphic is going to be kind of similar compared to what we have done for the player so if i go back and here we have import player assets we had a character path and then we had different kinds of animation states in a dictionary and i want to do something similar for the enemies so the first thing i want to do let's call it self dot animations and this is going to be a dictionary with only three different value pairs we have idle then we have move and finally we have attack and these three states correspond to what the enemy is supposed to do so if the player is really far away it's supposed to idle if the player is kind of close it's supposed to move and then move towards the player and play the move animation and then if it's close enough it's supposed to attack and if you look at the folders there is a folder for each enemy that corresponds to this name so for example the squid has one folder for idle one for move and one for attack and this is going to work exactly like we have done for the player so what we can do we can create a main path and this is going to be an f string and in here i want to go up a folder i want to go to graphics then i want to go to monsters i called it and now we want to go to the specific subfolder for our enemy and this is going to be the name and now don't forget we want to go into different subfolders so we need one more forward slash so this path is going to lead us to each individual enemy and let's call it main path and now all i have to do is for animation in self dot animations dot keys and in here self dot animation and animation sorry this should be animations so essentially we want to get this dictionary and go for every single key of this dictionary so right now we want to get the idle and for this idol i want to import a couple of graphics and what is i need again my import folder function so from support import let's just say star so now i want my import folder the one we created earlier and then here i just want to create my main path plus the animation so just to explain what's happening here this main path is what we have created up here and then the animation is what we get from the for loop and this for loop could for example be idle move or attack and we are just combining them and that way we get a whole path to a specific folder and then we're using the import folder function to import every single image inside of that folder and turn it into a surface and that way we can use them in our dictionary so with that we have our import graphics now next up in my init method i want to set self.status and for now this is going to be idle but later on we are going to work with this to make a change depending on how far away the player is so this could be any value inside of this dictionary could be idle move or attack and depending on the status the enemy is then going to do different actions so now we have a dictionary and we have a status pretty much the same thing we had for the player and with that we can actually start setting the image and i think this could be a good exercise to see if you're still paying attention the video is getting quite long so try to use the imported graphics so selfdot animations and the status to pick out one image for each monster i want first of all to get myself.animations so i want to get this dictionary here and from the dictionary i want to pick one of the animations depending on what my status is and right now my status is idle so i want self.status i guess could be anything but right now it is idle so this would give me a list but image wants a surface so from this i have to get self dot frame index and you might be asking yourself where do we get this frame index from do we have to create it in this class and the answer actually is no because in our entity we have the frame index and this frame index already works in the player so in this player we have no frame index but the animations still work just fine somewhere down here so frame index comes from the entity and we don't have to declare it so we don't have to worry about it but there is one thing we do have to worry about and that is the different kind of monsters so in my level we always call it a monster but that wouldn't be accurate because in my settings i have squid raccoon spirit and bamboo and for now let's just use this squid those i think look the best and now this would actually work with the import and now let's try this and there we go we can see some enemies they don't do anything right now and they're all the same but at the very least it is working also we can't detect them but that comes later so for now we have some enemies now obviously we have different kinds of enemies and that's something we have to work on now and essentially what i want to do i want to create a monster name variable and now i want to create some if statements to check what kind of name we are going to get and this could for example look like if the column is going to be 390 then my monster name is supposed to be bamboo then l if if my column name is equal to 391 then my monster name is supposed to be spirit that's not how you spell that now next up if that is not the case and my column is 392 i am really bad at typing today if that is the case my monster name should be raccoon and if neither of these is the case so else then my monster name should be squid and let me indent them all properly python tends to be a bit annoying if you use if statements on the same line oh well sublime is a bit weird but with these couple of lines we now select the right kind of monster for the specific monster name and now let's try this again and we are getting an error that we have list index out of range and the error here let me close it all is simply that when python looks at this file here for the raccoon i misspelled it it should be spelled with a double c and because of that misspelling when we imported the folder python couldn't find it and try to loop over it and well that didn't work but now let's try this and now we can see different enemies so in here all of this is working really nicely so this is then giving us a ton of different kinds of enemies that we would like to have and i guess there's one small downside here let me actually open it again so our enemies have very different sizes these bamboo ones are 64 by 64. same for the squid and same for these little flames but the big raccoons are quite a bit larger and you could give the larger ones an offset but in my case i'm not going to worry because they're basically in the right spot but that's something you could work on but it doesn't really matter that much alright now we can place our different kinds of enemies and we can actually see them in the game i guess now we can start working on their movement and let me add a separate section to it and let's call it movement and then here we already have the rectangle and besides that i also want to give them self.hit box and this is going to be self.rect and let's go with 0 and negative 10. and this hitbox we are definitely going to need because in our entity we are moving the hitbox not the rectangle so our enemies are going to need a hitbox and besides that we are also going to need self dot obstacle sprites and that's just going to be obstacle sprites and again this is going to work just like we have done for the player so in our entity we are looking through self. obstacle sprites so our enemy has to have this attribute as well and well this one we are going to get from the parameters so this is obstacle sprites and then on our level for the argument just like the player we need obstacle sprites and that way our enemies also get collision mechanics with the rest of the level it would look very silly if they didn't have that so now they have the ability to move but they well don't move at all right now so that's something we do have to work on and to make them work we first of all need an update method and this one itself and nothing else it's the usual sprite update method and in here i want to add self.move and now this move method will need some kind of speed and i want to pass in self.speed in here and to get that kind of speed in the init method i want to give the enemy some stats and actually while we're here we can add a couple of different stats and let me just copy them it is quite a few so this is going to look like this so we get the monster name and that's just going to be the monster name then we get some monster info and that is then going to give us the health the experience the speed the attack damage resistance attack radius notice radius and attack type so all of this is basically this dictionary here just now converted into attributes and that way we can use them significantly easier and in here we have our speed so now they could be moving and although if i run the game they are not going to move for the simple reason that they don't have any kind of direction or well they do have a direction but each of their direction is zero and zero so i guess you could say they're all moving except they're moving in the same place so well kind of pointless and that means we have to give them another method to check where the player is and this is done in another method that i called get status and this one itself and we have to know where our player is and all we really want to do in here is we want to get the distance to the player so in here let's just add a question mark for now because this one gets a bit more complex but let's just imagine for now that we have the distance all i really want to do is if the distance is smaller or equal than our self dot attack radius then i want to set self.status to attack then l if if my distance is small or equal to self dot notice radius then self.status to move and if neither of these is the case then self.status should just be idle so really all we're doing in here is here we have our enemy so this is our enemy then we have one radius around it and we have a larger radius around it and if our player is inside of the yellow circle then we want to attack and if the enemy is inside of the blue circle then the enemy is supposed to move towards the player and if the player is outside of that then the enemy is just supposed to idle and not do anything and that's really all we need we have to make some more refinements in here later on but for now this is good to go so now we have to figure out what's the distance to the player and in here i want to create an extra method because we essentially need two bits of information let me actually draw them actually let me just redo the entire circle i've just done and let's say our player is here right now and i want the enemy to move towards the player now for that to happen i need two bits of information first of all i need the distance so how far the player is from the enemy but to move the enemy towards the player i will also need the direction so i need to know what angle this arrow is going to be so that i can move the enemy in this direction but once i have this direction i can just move it with my speed and then use the move method and then my enemy would be moving basically what all of this means i want to create a method it's called define that is going to get player distance and direction and this one itself and the player again and what this method at the end of the day is really all supposed to do is to return a distance and a direction direction so now we have to get both of these things and this might be a good exercise to check your vector math so try to figure out the distance and the direction between the player and the enemy although don't worry if you can't do it yourself all right let's do some vector math first of all i want to get some vectors let's call it my enemy vector and my player vector and essentially all that means is i want to use pygame.math.vector2 and pass in self.rect.center so that way we are converting the center of our enemy into a vector and that makes it much easier to work with and i want to do the same thing for my player so pygame.math.vector2 and then player.center so now i have two vectors and that's going to make my math significantly easier and that's already bring us to the first variable we want to get the distance and really all we want to get is the distance between these two vectors and the first thing we have to do for that is get our player vector and subtract the enemy vector from that so this is going to give us another vector that shows us the relation between these two vectors but importantly this is not a distance right now it's just another vector and let me illustrate this this can be a bit confusing so right now this is our entire game window and let's say our player is here and our enemy is here and each of those have their own separate vector and remember a vector is essentially an arrow so the vector looks like this for the player and like this for the enemy so we're going in x and the y direction to get to our player or our enemy and when we subtract these two vectors from each other we are getting this vector here and let's say just for some numbers this could potentially be something like for the x it's going to be positive so x could be let's say 100 and for y possibly a bit less let's say 80. so this would be the vector that shows us the distance between our player and our enemy oh well not the distance just the arrow to get from the player to the enemy but importantly this is not a distance we couldn't really use this by default to understand how far away the enemy is but this we can change quite easily all we need is dot magnitude and this is converting a vector into a distance and this we can actually use so with that we already have our distance and i guess with that we can also work on the direction and this one isn't all that much more difficult it's actually very similar so we again want to get my player vector and subtract my enemy vector from that so again now we have our vector let me actually again bring it up again so now we have this vector but the problem we have now is let's say we have this vector and we want to multiply it with the speed let's just call it s to move our enemy towards the player the issue we have now is that this vector is going to be way too large so if you just multiply it with s being 5 then this arrow here wouldn't go towards the player it would go all the way to something like this so our enemy would just move way past our player since the original vector is way too large so essentially what that means is we want to reduce the length of this vector to one so we keep the direction but we reduce the length of this thing to make it exactly with a length of one and that way we can multiply it with the speed and have a proper movement and what that basically means is we have to normalize it and that way we will get a proper direction that we can actually use fortunately that is a very easy thing to do because all we have to do is pass in normalize afterwards and we are basically good to go although we do have to be careful and this is something we have seen with the entity earlier so in the move here we had to first check that the magnitude of our vector isn't zero and only then could we normalize because you cannot normalize a vector that has a length of zero so essentially we have to check if the length of this vector is greater than zero and only then can we normalize it now fortunately we already know how long this vector is going to be it's just our distance so we can use the distance in an if statement and just check if this is greater than zero and only if that is the case we want to get this vector and this distance could actually be zero if our player and our enemy are in exactly the same spot remember there's no collision between the enemies and the player and i guess what we can also do is if that actually happens so if my player and our enemy are on the exact same position we know in that case the direction could just be pygame.math.vector2 with 0 and 0. so if our enemy is right on top of the player we can just give it a vector of 0 and 0 and not move it at all and well with that we have our proper function that gives us a distance and the direction so now let me copy it we can paste it in here make sure to call it and pass in the player and right now we only really care about the first one so we only care about this distance here for now we don't care about the direction that will come very soon though but now we have another problem that i want to get myself.get status but now i have to get my player in this update method unfortunately this update method is going to run for every single way to have it every single visible sprite and passing in an extra argument to all of these seems kind of inefficient since only the enemy is going to need a player in the update method so instead here's what i'm going to do let me minimize all the methods in my level and in my ysort camera group i'm going to give this another method and i've got this one enemy update and only in here we get self and we get the player and essentially what i want to do in here i first of all want to get all of my enemy sprites and this we're gonna get in just a second and then for enemy in enemy sprites i want to call sprite dot enemy update and then in here i can pass in the player and then in my run method besides the regular update i want to call self.visiblesprites.enemyupdate and this one is going to get self dot player lay here so that way we can separate the enemy with the update method and i guess that means i want to copy or cut out all of this and give this enemy the enemy update method that is going to work very similar compared to the update method except now it's for the enemy only and this one gets self and player so now we have access to the player so the last one we have to figure out is how to actually get all of the enemy sprites and essentially what i want to do is i want to get my sprite or sprite in self.sprites so this would give us literally all of our sprites and i only want to select the ones with the enemies from that so this is going to be an if statement and here it becomes important that each of our tiles or each of our classes has a sprite type so our enemy has a sprite type and our tile has a sprite type and our player should have one as well not sure if i gave him one but doesn't really matter the player doesn't need one so what i want to check if sprite dot sprite underscore type is equal to enemy because in my enemy my sprite type is enemy now this can be a tiny bit dodgy because if a sprite doesn't have a sprite type attribute we're gonna get an error so what i want to check first is another if statement that if has attribute now has attribute basically just checks first a class and then we can check for a specific kind of attribute which in my case is sprite underscore type so we are first checking if the sprite has a sprite type attribute in the first place and once we have that we are checking if that sprite type is going to be enemy so that way it doesn't matter if the player has a sprite type or not or if we just forgot it for some other tile or maybe if you want to add more tiles later on this would basically save you alright so now we should be having a distance to the player i guess let me run the code nothing should happen yet we get invalid syntax let's check it out ah the problem here is this should not be an if statement so we only need one if statement and then we can combine the different if statements so now let's try this again and now we have name sprite is not defined oh and the reason here is i call this enemy i didn't call it sprite so next attempt and we get now name in our enemy name get player distance direction is not defined i think i know where this is coming from exactly here this should be self so now the next attempt and now things are working again although still nothing is happening but at the very least we are not getting an error so what's happening now is we are getting the status but we are not using that to move the enemy but let's work on that now then we can actually see what's going on so i want to create another method and let's call this actions and then here we need self and we again are going to need our player and in here i want to check my status so if self.status is equal to attack then i want to do a certain thing for now let's just print attack then i want an l if statement if myself dot status is equal to move i believe i called it let's double check yeah move so if this move is the case let's say we're going to work on this in a second let's call it pass for now and if neither of these is the case i well don't really want to do anything but let's just say self direction is going to be pygame.math.vector2 this line here is important if our player let me draw it actually so if this is our enemy and this is the circle that attacks if the enemy is supposed to move towards the player if the player is inside of the circle then our enemy is going to move towards the player but i also want to make sure that if the player moves out of that circle then the enemy is supposed to stop moving so this is what this line essentially ensures that once the player is leaving the circle the direction of my enemy gets back to zero so it stops moving all right the actually interesting one is this one here i want to make my enemy move towards the player once the player is getting closer and this is again going to be in self dot direction and in here we need self dot get player distance direction it needs the player and now we care about the second element being returned so index one which is the direction so this is what we are getting now and now in my any update i can call self dot actions pass in the player and now let's try this so now we can actually see something moving so now the enemies are coming towards us if we are close enough on the cache you see if the enemy is overlapping we get attack in the bottom left so now we can actually do something so this section was probably one of the more difficult parts of this tutorial because there are lots of steps that need to be taken together so if you struggle to come along i would really recommend to double check each of these methods and see what they are doing there wasn't really any easier way of doing all of this but all right i guess now what we can work on is to animate the enemies and in here we basically want to do the same kind of animate we have done for the player let me just have a look actually let's minimize all of the methods here and i kind of want to do the same thing i've done for the player to animate the different kinds of states although for the enemy it's going to be a tiny bit different so we couldn't put this animate in the entity and also apply to the enemy although it is arguably somewhat similar but let's go for it step by step so first of all i want to get myself dot frame index and add plus equal self dot animation speed so these two parameters we are getting from the entity they are all the way at the top and now i want to check if self dot frame index is greater or equal than the length of self dot animations and then myself dot status and if that is the case i want to set self dot frame index back to zero so this is pretty much the same thing we have done in these two lines except i guess the animation we have set for the player in a separate variable makes it a bit easier to read let's do it here as well so now length of our current animation so so far those two are pretty much identical and for now they will continue to be identical because now we can set self dot image is going to be my animation and i want to get my integer of self dot frame index and importantly here what we have done for the player as well we have to update the self.rect so let me copy it actually and now we are setting our rectangle in the center of the hitbox because remember we are moving the hit box we are not moving the rectangle so if we didn't add this we wouldn't display the enemy in the right position but now we can in the update method actually called self dot animate and let's try this now and we actually get animation and they don't really have a good attack animation i think this one is an attack animation yep there we go so now this thing has an attack animation and i guess the proper attack animation comes with the raccoon and there we go this is working not badly although now we have a problem and let me actually stand here i want to make sure that my enemies have a proper attack animation so for the raccoon for example it's supposed to play the entire thing and not be stuck in the attack loop which i think looks a bit silly so that is something we have to work on in our enemy and i think it's a good idea to minimize all the methods in my enemy it's getting a bit longer and in my init method i want to add another section and let's call this one player interaction and for now on here i want to have one method that's called self.can attack and by default this should be true and then in my get status i only want the enemy to be able to attack if the player is close enough and if self dot can attack is true and now in my actions once the player has actually attacked i now want to restart the timer to make the enemy not attack anymore but now we have a problem so this entire graph is the entire length of our attack animation for the enemy and for the sake of simplicity let's say it has just a couple of frames so we have zero one two three and four and each of these is a frame for the different cycles of the attack now if we set dot can attack defaults in here then we would only get to the first step and then our attack would stop so we would not actually see the attack so what we want to do is we want to set self can attack only to false after the animation has finished and this is then going to happen in my animate would i put it down here animate function so what i want to do in here is if self dots self.status is equal to attack so right now we're checking if our current frame index is longer than the animation and if we are attacking and only if those two are correct then we can set self dot can attack back to false and that way the player only stops being able to attack after the attack animation so now we have a proper method here so technically now the enemies should only be able to attack once let's try this with the raccoon so there you could see our raccoon could attack once but not again so this is working reasonably well so now what i want to do i want to create a timer that the enemies can attack again after a certain period of time and this i think could be a pretty good exercise so check the previous cooldowns we have created and try to make a similar one for the attack animation of the enemies alright first of all we need two more attributes we need self dot let's call it attack time by default it's going to be none and we are going to need some kind of let's call it attack cool down in my case i've set this one to 400 it's identical for all of the different enemies although this you could also put into this dictionary if you really wanted to but mine is already getting quite long so i didn't worry too much about it now let me minimize all of those methods and let's put it down here i want to create a timer for the attack cooled down and in here i first want to check if not self dot can attack because we only want to check this timer if this one is wrong and here we have to get our current time with pygame.time dot get underscore ticks that was atrocious spelling all around this one should work now and now if my current time minus myself dot attack time is greater or equal than myself dot attack cooldown and if that is the case self dot can attack should be set back to true now the one thing i haven't done is to get my attack time and this is going to happen in my not in my animate it's going to happen in my actions so in here besides print attack i want to get self dot attack time and it should be pygame by game dot time dot get underscore ticks and now let's try this and we get invalid syntax in the enemy ah because for attack cooldown i forgot the self now let's try it again and there we go so now we get attack okay that's a bit hard to see so the animation still doesn't seem to work perfectly let's see what went wrong ah and i believe in my get status in this line here after we have just attacked i want to check if self dot status is different from attack and if that is the case i want to set self.frame index back to zero so we essentially always want to be able to reset the animation once we switch to different animations maybe that helped nope also didn't make a difference so there's something else i missed sorry the code is getting very long it's a bit hard to plan this oh and i think i've just realized the mistake that this attack cooldown we don't actually call so self dot attack cooldown and while doing this i realized we have one attribute called the tag cooldown and the method is called the same so let's just call it cooldown our enemy only has one anyway so now let's try this again so let's go to the raccoon and this is looking much better cool there we go so now we have proper attack animations and once we add particles this is going to look even better but now we have the basic enemy logic and i guess this was a really long section so let's finish this one for now and for the next one we are going to start with the interaction between the player and the enemies so let's talk about that and this has to go two ways on the one side our player has to be able to attack the enemies with the weapon or with magic and on the other side the enemies have to be able to attack the player as well now the logic for the enemies attacking the player is actually quite simple we already made most of it all we really have to check is if the enemy is close enough and then triggers an attack and if that is the case we can just call a function to reduce the player's health now the other way around is a bit more complicated because we have to check if the player weapon actually collides with an enemy and here's how we are going to do that we are going to create two more sprite groups one is called attack sprites the other is called attackable sprites and whenever we create a weapon we are going to put it into the attack sprites and magic is also going to go in there and all of the enemies or anything that can be attacked will go into attackable sprites and then in our level we're going to check the collision between any sprite and attack sprites with the attackable sprites and if there is any kind of collision then we're going to check the tile type and trigger a certain thing for example if we have grass we're going to destroy the grass if we have an enemy we are going to lower the health of the enemy and that's pretty much the entire logic there are a couple of visual things we are going to add but let's implement the basic logic first here we are back in our main file and i want to go to level and in here we already have quite a few different methods and i want to go to my init method and add a bit more here and i guess we can put this under attack sprites it doesn't really matter where you put it so here we have attack sprites and this is just pygame.sprite.group then i can copy it and let's create another group that's called attackabilt sprites so the basic logic is we are going to spawn our weapons and our logic inside of this group all our enemies will be in this group and then we can check the collisions between these two groups and check if we hit anything but for that to work we actually have to assign things to the different groups so let's start with the enemies in create map so in this section here actually in this section here we are creating all of our enemies and right now the enemies are just invisible sprites but they should also be in selfdot attackable sprites and i guess for this one let me put the enemy on multiple lines so it's a bit easier to see what's going on because enemies will get a few more lines of code and i'd like to keep it a bit more readable now next up when we are creating an attack so in this method here we have our weapon and right now this one is also only invisible sprites and it should also be in self dot attack sprites so now we have well different kinds of sprites and there's one thing i forgot because the grass is also supposed to be attackable and that could be a good exercise so try to figure out which group the grass should belong to should be really easy so in my grass right now i have self.visible sprites and self.obstacle sprites and i want to add a third group that is self dot attack a bill sprites attack bill sprites there we go and since grass is also getting quite large let's put this on multiple lines so it's a bit easier to read so now we have a couple more groups although if i run the game nothing is going to change but now in my level let me minimize the create map function again it's getting a bit large i want to create another method and let's put it right at the end and let's call this one player attack logic and we need self and nothing else and in here we basically want to cycle through all of the attack sprites and then check if any of those are colliding with any of the attackable sprites and be aware for now we only ever have single attack sprite whatever our weapon is but later on once we have magic there could be multiple sprites inside of that group so just be aware of that so first of all let's use an if statement to check if anything is in attack sprites in the first place because if not we don't have to bother anyway now once there is something inside we can check for attack sprite in self dot attack sprites and now i want to use pygame dot sprite dot sprite collide and in here we need a sprite we need a group and then we need to do kill argument and let's go through what this one means and sprite is the easiest one it's just going to be a sprite let's say it is this sprite here then we are going to check this sprite if it collides with any sprite inside of a group so let's say we have our group here and inside of this group we have a bunch of sprites it doesn't really matter how many you have it's completely relevant and this method basically goes through if this sprite is colliding with any of these sprites and then the do kill argument determines if the yellow sprite is gliding with the purple sprite are we going to destroy that sprite and that's literally all that sprite collide does so in my case i don't want to kill any of the sprites for the sprite i want to check my attack sprite and for the group i want to look at it's going to be self dot attackable sprites and this then returns a list of all the sprites that have been colliding so we can store it in let's call it collision sprites so what we can do now once we have that we can check if collision sprites exists so if we have any kind of collision and then once we have that we can cycle through that list and let's call it for target sprite in collision sprites and now we finally have the sprite that have been colliding with our weapon so what we can do now is check different kind of things but i guess for now we can just check if this is working so let's say target sprite dot kill so we essentially destroy any kind of sprite we are attacking and we have to make sure we're actually calling it let's call it right after the enemy update so self dot player attack logic and now let's run it we don't get an error it's good start and now i can attack the grass it disappears i can attack the enemies they disappear and this seems to be working quite well obviously not ideal so far but at the very least something is working the problem now is we don't just want to destroy the target sprite we want to do something else and to figure out what we have to do we have to figure out the sprite underscore type so for example for my grass the sprite type would be grass that's the one we set here so this is basically then an if statement so if the target sprite is equal to grass then well if that is the case we just want to destroy the grass anyway so in here we actually do want to get target sprite dot kill and let's try this now so i can attack the grass this one still disappears and if i attack the enemies they also disappear so something has gone wrong here let's check oh and i realized that this argument here should be false because i do not want to destroy the sprite so you have just seen that because this one was true we are destroying any kind of sprite so we basically never got across this line so now it is false let's try it again now so we can still destroy the grass but now the enemies we can't destroy anymore now it's working and right now this destroying here looks kind of boring but later on once we had some particles it does end up looking significantly better but step by step now besides that if we're not attacking grass i guess i can just add an else statement because we only really have one other thing we can attack and that's the enemies although each of our enemies also has a sprite type so you could be more specific if you really wanted to but now we can again target our spread type and now i want to give them a method and let's call it get damage and for this one i need a couple of arguments so first of all i want to know what the player is doing and besides that i also have to know with what attack we are hitting the enemy so are we using a weapon or are we using magic so i basically want to know the attack sprite dot sprite type so this is the attack sprite we got from all the way up here that we are going to pass in there and let me just make sure that our weapon actually has a sprite type so we can reopen our weapon and right now this one doesn't have a sprite type so we have to give it one and let's do it right at the top so self.sprite underscore type is going to be weapon so now we can use it and let me close it again so we don't have too much random stuff and all right now in our enemy we have to create this method and i guess let me copy it so we can work on the parameters so back in my enemy let me minimize things in here i want to create get damage and we will need the player and besides that we are also going to need let's just call it the attack type and essentially what i want to do in here is if the attack type is equal to weapon then i want to set self dot health negative equal and now i have to figure out by how much i should lower the health and for that i have to know what is the player's damage and this i'm gonna get with another function and from the player i want to create a new method let's call it get full weapon damage so this is basically a getter function and let's copy this one and now we can go to my player in here let's minimize things as well and now we can add another method in here itself and nothing else and in here really all we want to do is want to get our player base damage we can get this from this dictionary here so our base attack is going to be this one and then besides that we also want to get our current weapon so the one we have basically up here and we basically want to get these two together and that is our full damn mitch so we're just adding those two numbers together so in this function let's first get the two different kinds of damage we have so we have our base damage and we have our weapon damage and all i essentially want to return is my base damage plus my weapon damage so all i have to figure out is what these two numbers are going to be and actually let's do this as an exercise so try to figure out from the player what is the full damage so what is the base damage plus the weapon damage for the base damage we essentially want self.stats and in there we have what is called attack we are essentially looking at this dictionary entry up here and then besides that i want to have my weapon damage and for that i first have to get my weapon data so in settings i am essentially accessing this data here and i want to get one of those keys let's say right now my weapon is a sword and then i want to get this key and this is information i can get from self.weapon what i can do here is weapon data and then self.web pin and once we have that i can just pick another entry because now we have this dictionary for the sword and inside of this dictionary we have damage and well all i have to do is add this to damage oh and while we are here i realized i forgot something because in our settings we also have a weapon cooldown and i didn't include that one in our player cooldown so in my player in cooldowns here we have the attack cooldowns and this is my base cooldown and to watch this i also want to add the weapon cooldown so in here we can basically do the same thing so we still use our weapon data let's copy the entire thing but except now instead of damage i want to add cool down and that is going to be this cool down here all right but now we have our get full damage so with that we can return to our enemy and now we have something i guess later on what we're also going to do is else let's add a pass in here but this is going to be magic damage it's going to work slightly differently and right now i guess this would work but we would never be able to see it because well our enemies don't have anything to well react to so i want to add another method again and this is just going to be check def needs self and nothing else and all we're going to check in here is if self dot health is smaller or equal to zero and if that is the case i just want to run self self.kill although right now this logic isn't going to work but i guess let's just try the entire thing and see if things are working so we can still destroy the grass enemy get damaged doesn't work so let's have a look should be here in my player attack logic so we have self the player and the tech sprite so this one seems to be working so in our enemy i'm pretty sure i know what i forgot and what i forgot itself so now let's try this again let's attack an enemy and we can see that nothing has happened and this happened because in my enemy i'm not calling check def so in my update method we can run self.jackdev you could also call it in the enemy update it doesn't really matter so now let's try this again and there we go now we have something that maybe a tiny bit weird that all of our enemies die in one hit so even the bigger ones they just die immediately and this happens even though they should be having quite a bit of health so in my settings for the monster data the raccoon for example has 300 health but all of our damage is like 15 or maybe 30. and the problem here is that get damage runs on every cycle of our game so we think we're hitting the enemy once but pygame just sees a collision and it runs this get damage every time it has this collision which in our case is 60 times a second and that way we are essentially multiplying our damage by 60 which kills anything instantly so it's not really fair and essentially what we have to do is to create a timer that enemies can only be hit after a short amount of time so essentially all that means is we have to create another timer and let's put it all the way down here so here we have let's call it the invincibility timer and let's add something like let's call it vulnerable by default this is going to be true then we have self dot hit time by default this is none and let me spell it properly and then self dot invincibility duration let's say it's going to be 300 but again this number you could also put into the settings to have different kind of enemy behavior in my case well it wasn't really needed so now we have the basis for another timer but first of all let's implement that our enemy can only be hit once in a while and this is going to happen in my get damage so in here i want to check is if self dot vulnerable and only if that is the case i want to run all of this and by the end of it once we have run everything else i want to run self dot vulnerable is going to be false and i guess now let's try this so now the enemies shouldn't disappear anymore and they don't cool so seems to be working but obviously we do want to be able to attack the enemies so what we also have to get is self dot hit time is going to be pygame dot time dot get underscore ticks and with that we have all we need to get another timer and i guess this cooldown let's call it cooldowns and now in here we can check if self dot vulnerable if that is the case then we want to run this timer and i guess i can run the current time outside of this function so we have it available everywhere and then here we just want to check if my current time minus self.hit time is greater or equal than myself dot invincibility duration and if that is the case self. vulnerable is going to be true and i forgot this should be not self.vulnerable and now let's try this so i probably have to hit the enemy a couple of times but it does disappear eventually let's look at this one so i hit it once i hit it twice there we go this looks pretty good okay those ones are going to take longer so i just assume it's going to work but all right so with that we have the ability to damage our enemies the problem right now is the enemies aren't really being pushed back so our attack is well kind of pointless because the enemies can attack us right away anyway so i want to get them some kind of hit reaction that they are being pushed backwards and that is going to be another method let's call it hit reaction and basically what i want to do in here i just want to check if not self. vulnerable so if my enemy has just been hit then i want to set myself dot direction and multiply it with myself dot resistance and this number should be negative so think of it like this right now this is our enemy and this is our player and our player has just attacked the enemy essentially what i want to achieve is that my enemy is being pushed back in the same direction and the distance by how much the enemy is being pushed back should come from the self dot resistance and this self.resistance we are getting from somewhere in the enemy so i believe it is there resistance so that's kind of all we are going to need and this i just want to call in my update let's call it right before move so hit reaction that way it's going to happen early on but now i also have to make sure i actually get the right direction so in my get damage all the way at the top i want to set myself dot direction and in here self dot get player distance direction i want to pass in the player that i already have and then just get the value with number one so this is the direction and really all we're doing here is we are working with the direction of the enemy and just moving it in a different direction so i guess let's try if this is working so there we go they're being pushed back and this is making all of this feel much better and let's use different weapons this also works cool so now we have well a better get damaged method although there's one more thing i would like to implement and that is that my enemies are flickering once they are being hit actually they should apply both to my enemy and my player so essentially i want some kind of indicator that they are being hit and usually in games this works by flickering and to achieve that i have to work with the visibility of both my player and my enemy and that is something we can kind of put inside of the entity although since our player and our enemy are animating slightly differently we do have to put this in kind of different ways but let me actually implement it so in the enemy for my animate i want to add a bit more at the bottom to make them flicker once they are being hit and essentially what that means is if self dot vulnerable and again this should be not because we're checking once the enemy is being hit then we want to essentially flicker and if that is not the case so else then i just want to get myself.image and set the alpha to 255. so when you set the alpha you set a transparency of the layer and 255 is the full value so all of this basically means if the enemy is not vulnerable anymore this one then we are setting the full alpha but if that is not the case i want to get a specific kind of alpha and this we are going to get from somewhere else and this can either be a 0 or 255 so invisibility or full visibility and then self dot image dot set underscore alpha with the alpha so now we just have to figure out a function that toggles between 0 and 255 and the same thing we are going to need for the player so i'm going to create this in my entity and let me minimize all the other stuff in here we are not going to need it so in here let's call it a wave value l u we need self and nothing else and let me explain what we are going to do and we are going to use a sine wave in here and let me explain how it's going to work so let's say this is going to be a graph we have here our time and on the y axis we have the well y axis and a sine wave kind of looks something like this except in beta drawn and we can check each point of this value in time and pretty much what i want to do is if this curve is positive so if we are here we are going to return 255 and if we are below that curve so we are down here then we are going to return zero that way we are switching between those two numbers actually pretty simple but first of all for that to work we need from math import syn and now all i want to get is my value and i need to get my sign value and in here i have to pass in some kind of x which in my case is going to be the time and the time i get with pygame the time dot get underscore ticks and now if this value is greater or let's say equal to zero then i want to return 255 and if that is not the case i want to return zero and let's add proper indentation and there should be return and that's all we need for this method i can go back to my enemy now and self.wave value and no arguments are needed and now this should actually be working let's try so now this is working beautifully cool makes the game look significantly more responsive nice now if you wanted to do the same thing with a white color instead of invisibility you would probably want to work with a mask but in my case that's a bit of an overkill but i have made a whole tutorial on how to use a mask you could totally use that one as well but alright now i want to give my player the ability to flicker as well so in my player i want to minimize all the different methods again and look at my animate and in here i want to add flicker now unfortunately to actually implement this we well we need to know if the player has been hit or not which we don't know just yet so let's first implement the enemies hitting the player and then we can work on the flicker and fortunately this isn't all that difficult the only real limitation is that we have to figure out how to get from our enemy back to the level so we know when the enemy is attacking the player that's going to happen in where are my actions so we know in here we can print an attack if the enemy is attacking the player that one is working perfectly fine but the issue is from this place we can't really access the player actually we can we have the player right here so technically we could run something on the player from here but i don't want to do that but a simple reason that later on whenever the enemy is attacking i also want to create some particle effects and for that to work i have to create this function in the level so essentially what i'm going to create is create a couple of methods inside of my level and one of them for example is going to be damage layer this one will need self as always then we need an amount and then we need an attack type amount should be fairly obvious it's the amount of damage the enemy can deal attack type is going to be in settings it's what we get from attack type it's basically what kind of particle we are going to spawn once the enemy is attacking but for now we are not going to use it so now in here we want to write a function that can damage the player but first of all we need to deal with the same problems we have with our enemies that we first want to check if self dot player dot vulner vulnerable so essentially we want to create a timer after the player is hit so we can't attack the player multiple times in one attack but essentially once we have that we're going to implement that in just a second we want to get self dot player dots health and from that reduce the amount then we want to set self.player.vulnerable to false and in our player we want to have self dot player dot let's call it hurt time and this is going to be pygame dot time dot get underscore ticks and at the end later on we want to spawn particles but we don't have that one just yet now this damage player i want to create from the enemies so in my create map when i am creating the enemies so all the stuff down here i want to pass this one in there as well so self dot damage player and as always don't call this function and now in my enemy we also have to put this into a parameter uh spelling it correctly there we go so now in my let's call it player interaction i guess it fits best in there so self dot damage player is going to be damage underscore players what i called it oh i wrote parameter well never mind uh damage player that makes more sense so now our enemy has the ability to damage the player and now in my actions instead of printing attack i want to run self dot damage player and in here we have to figure out an amount and an attack type and well if you look at the init method we have a ton of statistics in here so the first one is self.attack damage we can just pick this one and paste it in the amount and we can do the same thing with the attack type it is all the way at the bottom this one here so attack type and actions this one here so now our enemy is able to attack the player and i guess let me minimize all of the methods it really is getting a larger project all right so this should be working at least hopefully now in my player we just have to set up all the attributes for the timer and let's add another section to this and let's call it a damage timer and in here we have self.vulnerabil which is true by default then we have self. i believe i called it hit time or was it hurt time it's hard to tell i called it her time there we go so self.her time and this by default is going to be none and finally we need something like self.invulnerability duration and let's say this one could be 500 seems like a decent value but you can take it with this and all right now in my not animate but in cooldowns i can add another timer so in here if not self dot vulnerable then i want to run the timer so if current time minus self dot hurt time is greater or equal than so self dot invulnerability duration and once that timer is running we want self. vulnerable and set it back to true so now okay well now we can't really see it but we should actually be able to see it in our health bar so let's try it and there we can actually see it in our health bar it's going down so obviously if it goes below zero we should be dying but in my case that doesn't really matter so much at the very least we know it's working so now in the player not the level the player we can now start working on the flickering and let's do this as an exercise so try to figure out to make the player flicker once we get hit should be very similar compared to the enemy right so if self. vulnerabil is not the case then i again want to get my alpha value and we want self.wave value the thing we get from the entity so this one here and we want to get our self.image.set and paste in the alpha in here and if that is not the case then self dot image dot set underscore alpha and set this to 255 so full visibility and that should be all we needed let's try this now and we indeed get hit and we can still attack the enemies and that is working really well now i guess the one downside is it's very easy for enemies to overlap but well not going to worry too much about that but you can add a few more collision mechanics and improve on this alright so with that we have pretty much all of our collision mechanics at least in the most basic sense so with that let's start working on the particles that's going to be another major section now a particle effect sounds difficult in theory but in practice it really isn't that hard we already kind of created the basics for it anyway so essentially for my particle effects it is just going to be another sprite that animates for a couple of different images the only difference now is that this particle effect is going to disappear once we're running out of animation frames so we're not looping the animation anymore we're just playing it once and then we are giving it a position and that's kind of all we need although there's one downside here that we have a lot of different images for all of the different animations so i think in total we have about 15 different animations and each animation individually has about 5 different frames so we are looking at a lot of images overall and what i want to do is to import all of these images when the game starts and then keep them in memory and only play them when they're needed in the game and the massive downside to avoid here is that we are importing images every time we are creating a new particle effect because that would be very slow importing images does take some time although i guess this is something that we can work on when we actually work on it so let's go into the code and let's have a look at this here i'm back in my file and i can close a couple of things because we don't need them for now so my entity and my tile and i guess for now my enemy as well i'm not going to need them and i do want to create a new file and let's call this one particles.pi and in here as always i want to import pi game and i already know that from support i want to import my import folder and now let's just create a dummy particle effect and that's going to be a particle effect class and this one is going to inherit from pygame.sprite.sprite and in here i want an init method as always we need self spelled properly then we need a position and we want some animation frames so this is what we are going to loop over where we are getting this from you will see in a bit and then finally what groups we want to pass this into and then we need super and dunder init as always with not self but with the groups and now in here we need all the basics for an animation so self.frame index is going to be 0 then self.animation speed is going to be 0.15 self dot frames is going to be the animation frames but now we can already set the first image so self.image is going to be self dot image dot get underscore rect and then here self dot frame index so essentially this is going to be the basic setup for any kind of animation and now that we have that we can create an animate function give itself and nothing else and now self dot frame index plus equals self dot animation speed and now here we come to the difference so if self dot frame is greater or equal than the length of my self dot frames so we are going beyond the length of our animation then we want to self.kill but else self.image is going to be self.frames and we want an integer of self dot frame index so really all we are going to do in here is we are increasing frame index and if we are still inside of the list we are just picking one image from this list however if we go beyond that list then we are going to destroy that sprite so this way we are only running this animation once and once the animation has finished we are destroying the sprite and now we also have to be able to call this particle effect with the update method and then here self dot animate now we have a basic particle effect the problem is we need to figure out where to get these animation frames and now you might be tempted to just create another method like import particle images or something like that but that'd be a really bad idea for the simple reason that we have a lot of particles and if pygame always imports something when we destroy an enemy or some grass the game is going to run very slowly so i'm going to do something else i'm going to create another class and this i have called animation player doesn't need any inheritance and in here we are going to create an init method with self and also nothing else and this one is going to get one long dictionary where we are importing every single thing so this is going to look like this a slightly longer dictionary that well um imports all of the different material so we have our flame our aura and our heel so these are both played when the player heals then these are different attack types then we have our monster deaths and we have different leaves when we are destroying grass although in here i have created one more method that is called reflect images and this we also have to create in here let's make sure i am on the right line should be this one let me actually minimize this dictionary it's getting very hard to read things so what i want to do in here is reflect images and we need self and frames and let me demonstrate what this one is doing right now for the leaves so this is when we're destroying grass we have six different animations and pretty much what i'm doing here is i'm importing these animations twice once in the proper direction and then once reflected so that way we are going to get a bit more variability in there that's really all it is and really all i'm going to do in here is for frame in frames i'm going to create a flipped frame and this is going to be pygame dot transform dot flip and we want to flip the frame for true and false flip can reverse something up in the x or in the y axis in my case i only want to flip the xaxis and ignore the yaxis which is why this one is true and false and now i have a flipped image and i want to save this one in a new list so let's call it new frames and that one's going to be an empty list and now new frames dot append and i want to get the flip frame and at the end of all of this i want to return my new frames and that is basically all we are going to need for now and now back in my level we can start working with this particle effect so in here all the way at the top actually let me minimize all of this stuff again it is getting a bit confusing so at the bottom here i want another section and let's call this one particles and i'm going to create my animation player with my animation so the animation player we have created in here and this animation player is basically going to be able to run a particle effect i'm going to see in a second how that's going to work but first of all we have to import it so from particles import animation player and to illustrate how that is going to work let's create our grass particles so in my player attack logic i know when i have destroyed some grass so in here i want to add a bit more logic to spawn some particles and basically what i want to do is run self dot animation player and do something like create grass particles but for that to work i am going to need two bits of information at the very least i need a position and i need to group so i can put these sprites into the visible sprite group but i am also going to need a position so let's first get the position and the position we can get fairly easily all i need is my target sprite dot rect dot center so we are playing these particles right where the grass used to be now next up for the group we just want self dot visible sprites and let's put it in the list so we're doing it in the same way we have done earlier pretty much all we have to do now is actually create this method here in my particle animation player this is going to happen down here great grass particle we need self we need a position and we need the groups and in here first of all i want to get some animation frames and the animation frames we are getting from self.frames because in here we have our leaf and i essentially want to pick a random animation from this list and to pick a random animation we need from random import choice and now in here i can just call choice and pick for myself dot frames and in there i have leaf so leaf is essentially a tuple with a bunch of lists inside and we are picking one of these lists and now that we have that we can actually create a particle effect so particle effect and then we need these parameters let me just copy them in here so position we already have animation frames we get from animation frames and then groups we get from groups so we didn't actually have to make any kind of change and well that should be it let's try so we get an error with inconsistent use of space let's see where he's complaining in there and in return new frames and from level a couple of errors so from particles in there not sure what happened with this one that was very strange okay there we go and now you can actually see that this one it took quite a bit of time to load and we get a key error so let's check my particles and oh i didn't mean left i mean leave okay now let's try this again now we get self where was that arrow so in particles we are getting self.image okay it is getting a bit late let's try this again now and now particle effect has another problem let's check it out and self.image this should be self.frames um it may be getting a bit very late let's check this out let's try again okay and now for the particle we are going to need a rectangle and this we get with self dot rect is going to be self dot rect dot get rekt and then here i just want to place the center is going to where the position will be okay we are working for all the errors so now particle effect has the same error that shouldn't happen anymore self dot image okay i am going to take a break after this section okay now particle effect we are back here and this should be self dot frame index so another attempt there we go finally now we have some particle effects that are going to spawn randomly and this is looking much better now there are a couple of things we have to work on first of all right now we are only spawning a single leaf which is not great so i want to create multiple and essentially what i want to do for a leaf in range and then here i'm going to use rand int which i have not imported yet i believe from random we have choice but we don't have rendent i want to get random number between let's say three and six and then for each of those numbers we are going to create another animation and that way we get a bit more particles let's try this now this already feels a bit better so this is quite a nice effect cool although now i feel like in my level this position doesn't feel like it's really appropriate so i want to give this one a tiny bit of an offset so i'm just going to add an offset and this is going to be pygame.math.vector2 and here 0 and 75. so we're just lifting up the particle effect by a tiny bit and this i'm just going to subtract from my position and that just feels like it's looking better and there we go might even be a bit too high although this one feels pretty good and okay with that we have some basic particle effects and we are making some solid progress okay let me close it and now we can work on the other particles for the enemies and fortunately we already have in my level let me minimize all of this again we already have one method that's called damage player and in here we want to spawn some particles so what i want to do in here is self dot animation player and let's call this a bit more generic generate particles although for this one we need a few more arguments so i want to know what the attack type is going to be so which of these different attack types are we going for so slash claw thunder and leaf attack besides that i need a position and i will need the groups where they should be and we can basically figure out all of these things right now so the tag type is pretty straightforward this is the one we already get from the argument position is going to be self.player player.rect.center and for the groups i'm just going to go with the visible sprites so now all we have to figure out is how to create this function here about this method so in my particle effect i want to create my particles we have a tag type we want a position and we want the groups and let's do this one as an exercise so now try to write this function that our animation player plays one particle once the enemy is attacking the player alright first of all we need animation frames again and we want to pick from self.frames and in there we have different kinds of attack as a key so we can just pass in the attack type actually i think since we are later going to use discrete particles for something other than attacks let's call this not attack type but animation type that makes a bit more sense and now we have our animation frames now i can just call particle effect we again need a position we need the animation frames and we are going to need our groups back in my level now i have all i need i think and let's try this actually let's check let's reopen my enemy and let's see if we are passing in the right information so when we call in my where is my actions so in my actions when we call damage player we pass in attack damage and attack type so attack type is what we need i guess let's try it and let's see what we get so again we have problems with the indentation i do not know what his problem is okay let's try now and now if the enemies hit us we get an error so three position arguments but four were given so let's have a look i think i already know the problem i forgot self okay now let's try this again and now we get proper animations and let's try different enemies so we get this one and we get sparks we get all of this i may have spawned too many enemies uh okay but this is looking pretty good let's get to this squid as well and this one okay yep you can definitely see it but yeah i pretty much spawn too many enemies but who cares right now okay so with that we have our basic particle system and what you can see in there as well we have used basically the attack animations and the leaf animations now there's two more that we need to figure out we have the monster death animation and we have the magic one the monster deaths we can already take care of the magic ones come in the next section so let's talk about the monster deaths and essentially all we have to do is play this animation once the monster is being destroyed all this really means is back in my level let me minimize this one i want to create let's call it trigger death particles and we need self and a position and a particle type and all i'm really going to do in here is get myself dot animation player and call create particle the decoded particles create particles yes particles and i get the particle type from the argument same for the position and they should always be in self dot visible sprites and now all i have to do is when i create all of the enemies again so all the stuff down here i'm going to pass this function in there as well so self dot trigger def particles and now in my nme class i guess let me minimize all the methods here as well we first want to create another parameter so let's call it trigger def particles this one has to be stored let's put it into play interactions self dot trigger def particles is going to be trigger death particles so now we can call this method from inside of the enemy actually let's do this as an exercise so try to figure out when to call this method with the different arguments all right so i want to trigger this when the enemy is dying so this line here and really what i want to call is selftaught trigger death particles and in here i need let me actually copy it from the particles so we're just calling the animation type a position and a group and in here let me open it in the level we want to trigger def particles we need a position and a particle type so in the enemy position and particle type now position is going to be self.rect.center and the particle type is just going to be self.monster name i think i called it all the way at the top uh monster name there we go so this is the name if you look at the particles monster name is the name of the particle or the name of the key and with that we should be good to go let's try so now if i tag any of these we're getting a proper animation so let's try it again looks pretty good and let's try with a different enemy u and this is also working so i assume they all work identically and with that we have most of our particles covered the one thing we still need is the magic so in the next section we are going to figure out the magic that one is going to be a bit more complicated but we are getting very close and i'm going to take a break before i go to the next section because those were way too many errors sorry about that so let's talk about the magic and for the magic we right now have two different spells one for fire and one for healing and those two do very different things the flame is going to work kind of like the sword that it damages enemies whenever there's contact and this is literally going to work like the sword in the sense that we are going to put the flame inside of the attackable sprites and then check for collisions so all we really have to do is place the flames and animate them for which we have most of the things we actually need now for healing it is getting a little bit easier because this one doesn't need any collision with the enemies we just have to spawn some particles and heal the player so increase the health but i want to create this in a slightly more flexible way so i'm going to put all of this into a separate class and let's implement this straight in the code i think that's going to make the most sense so here we are back in our project and i want to create a new file that i'm going to call magic dot pi and in here i want to do the usual so import pygame and from settings import all of it and now i want to create a class that i called magic player there's no need for inheriting anything and i want to create an init method with self and besides self we also want to get an animation player as a matter of fact this is the animation player we have created here so when we create this magic player it can play animations from our animation player so in here all i want is my animation player and that's going to be my animation player and now basically all i want to do i want to have one method for here needs self as always we're going to add more parameters later on but for now let's add pass and i want to create a flame that for now works in the same way that it doesn't do anything so right now we have two spells you could be adding more here if you really wanted to so how can we actually use this thing now well in my level let me actually move it all the way to the left because it's the most important one and let's minimize some methods so essentially what i do in here in my init method besides the animation player i also want to create a self.magic underscore player and this one is going to be my magic player and as the one argument we need the self dot animation player and for this to work we have to import from magic import magic player so now we have our magic player and as a matter of fact we already have a create magic method and then here we have the style the strength and the cost and this we can use to cast the magic so essentially what i want to do is if the style is equal to heal is one i want to cast some healing and if the style is equal to flame i want to do something else which for now is going to be pass but let's start with healing that's the easier one i think so we already have our self.magic player and all i want to do here is call heal so i want to call this heal method and i just realized this is a horrible way to spell magic so let me save this one and let's spell this one properly so magic dot pie all right now in my here i want to actually cast the heel but let's first check if this is working in the first place so i want to print heal and this should actually be working for now so let's try it let me go to my heel and we can see heal we still get the other stuff but that doesn't matter right now so i printed this one as well but i guess we can get rid of it we don't need it anymore at the very least we know this heal spell is going to work and in here now we have to figure out a couple of parameters so i first of all want to know my player then i want to know my strength then i need the cost and then i need the sprite groups and now when we call this thing we can pass all of this in here let me actually copy all of the parameters that's going to make things a bit easier my player is just going to be self.player in this one we need for the position now the strength and the cost i already have is just the strength and the cost up here so we can just pass both of those in here and we are good to go now finally for the groups this is going to be a list again and in here i just want to have myself dot visible sprites and since there's no collisions with these sprites we don't need anything else but for the flame we will also need our attack sprites but all right now we have all the arguments we need now we can actually work with this and the first thing we will need is if we can actually call this spell so if my player dot energy is greater or at very least equal to the cost and if that's not the case nothing should happen and once that is the case i want to get my player dot health and at plus equal the strength of the spell and besides that i also want to get my player.energy minus equal the cost so we're increasing the health of our player and decreasing the energy that's kind of how all of this works and i guess now we can actually try this so now let's select the magic spell it is working but now we if we press this again well we keep on increasing our health bar but once we're running out of enough energy we stop being able to cast it although the animation still plays but i kind of like the effect all right now what we have to figure out is that if our energy gets too large we don't want to overshoot on the health bar which also is fairly easy to do all we want to do is if our player health is greater than or equal to my player dot stats and then here health now this health is our maximum health so in the player i have it right here our stats is what we initiate the player with so 100 here right now is the maximum player health and then in our code we are keeping our actual current health in this variable or this attribute so this is going to be our max health if our current health is greater than our max health i just want to set my player health equal to my player dot stats and the health in here so now i can select my healing spell again now we have maximum and i made a typo this should be player now let's try this again and now we have our energy still decreasing but we cannot increase our health anymore and i guess here we have to make a decision do we want to play it to be able to increase the health or cast the healing spell if we already are at maximum health and i think most games handle it by allowing the player to cast the healing spell even though we have full health so i'm not going to worry about it but with that we have the basic healing mechanic now finally we have to spawn some particles and in my particles i have aura and heal and i want to spawn both of those once we are casting a spell hence we should be calling this animation player here twice and i think this could be a good exercise for you use from our particles they create particles method and spawn the aura particles and the heal particles every time we are calling the heel magic effect right so in my heel method i want to get myself dot animation player and create underscore particles so now we are calling this method here and this method has three arguments and in my magic i want to paste the paradise so animation type the first one is going to be aura then for the position this should be in the center of my player so i have my player i want to get the rect and the center and groups we are just going to get from the groups we pass in into the parameters so that's something we're going to figure out in a bit but now in my level i am already casting self.visible sprites in here so i have the right group and this should give us one particle animation let's try it actually so now we get the aura spell this looks pretty good and once you run out of energy it doesn't work anymore and now i also want the heal particle and for that i can just duplicate this line and right here for the particle type so now let's run this again and now we get the other particle as well what you could theoretically do give this heel extra effect an offset that can look kind of nice so in magic when you add the center you can add plus pi game dot math dot vector 2 and 0 for x and something like negative 60 or the height and now if you try this again this thing is now slightly on top um whatever you think looks better in my case i'm not going to care too much about it so let me just remove it so all right with that we have our healing spell although there's one more thing i would like to add because right now we don't really have any way to increase our energy once it's run out which doesn't feel very good so in my player let me minimize all of the methods here i want to create another method that i called energy recovery and we need self and nothing else and basically what i want to do in here is if self.energy is smaller or equal to myself dot stats and energy and then i want to get self dot energy and for now let's say plus equal one although that number is going to be way too high and now if our energy for whatever reason gets greater than our maximum energy so else i want to set self dot energy equal to self dot stats and energy and now we can call this method so self dot energy recovery and we should have recovering energy so now you can already tell our energy is increasing really fast i can't even cast the spell fast enough to deplete my energy but at the very least it's working but we do have to make some adjustments in my player first of all they shouldn't be smaller or equal they should just be smaller so now let's rise again and now our energy bar stops at the maximum but if we cast a spell it still recovers way too fast so instead i don't want to add one i want to add 0.01 and now if i cast this again now we can see a small increase and even if i cast the magic it still keeps on increasing so this works quite nicely now what you can also do is use in my stats i have it right here in here we have magic and this one i think is best to use it for two purposes one is our magic damage and then the other is our magic recovery so i want to multiply this with self dot stats and magic so that way if we're leveling up our magic we do more damage and we recover energy faster so now let's try this again and we have i guess it's kind of fast but you can play with this around and see what works well but i quite like this so now we have magic recovery and we have our healed spell so next up we can work on the flames and those do get a bit more complex although not that much let me explain the basic logic before we start right now we have our player here and essentially what i want to do is i want to cast five different flame spells that go in the direction of the player so for example if our player is facing to the right i want to create one flame two flames three flames four and five flames and then each of those flames get a bit of an offset to create some randomness here to make it look better and well that's the general idea and let me leave the graphic open for now we're going to need it in just a second again but first of all in my flame i want to check if my player dot energy is greater or equal to the cost of the spell oh and i forgot we need the parameters again so in here i want to get my player i want to get my costs and i want to get my groups now importantly here we have no strength i'll show you later how to get that strength but now we can work on the cost and once we have cast a spell i want to get my player energy minus equal the cost so now we have the basic setup and now what we have to figure out is how to get this direction because this direction determines if the flames are spawned to the right to the bottom to the left or up so this direction is really important to figure out fortunately we can get it reasonably easy from the player itself and we have kind of done something similar before so what i want to get is if my player dot status and my player status i can get from let me minimize all of this again it's kind of hard to read so when i imported all of the player assets we created animations and in here we have all of our possible player states and i just want to get just the direction so up down left or right and if we have something like down underscore idle i want to get rid of the underscore idol actually let's do this as an exercise because we have done this like four hours ago so figure out how to split this string to only get the direction and ignore anything like idle or attack alright so what we need is the split method and in here the one argument we need is an underscore so that is going to return a list with the strings that we have split so for example if we had down idle we would get a list of down and idle and in my case i don't care about anything that comes after the first element so i just want to get the index of zero and if that happens to be let's say right then i want to create a direction that is going to be a vector so pygame.math.vector2 and a vector facing to the right is 1 and 0. and that way we can use the vector in some math and now i can just copy all of this three times to have it three times and turn this into an l if statement and then at the end we have an else statement now first of all here we have left and left should be negative one and zero then let's say we can go with up and up has zero on the x and minus one on the y and then finally for else let me copy this direction so else is going to be just one which is downwards so with that we have our different directions and i feel like putting all of those on the same line looks a bit cleaner although it's entirely up to you to do this but in my case when i have a one line if statement tends to feel better to have all of this on one line now we have our direction and now basically what i want to do since i want to spawn five flames i want to create a for loop so let's call it for i in range and then here you might be tempted to go something like five but i want to use this i for the offset so the first element should be a 1 and that way we can multiply this one with the tile size to get an offset of 64 pixels to the player center so this shouldn't start at zero it should start at one and since we still want five elements it should stop at five and go up two but not include six so now we have a proper for loop and now for the math i have to split this thing into horizontal and vertical direction so if direction dot x exists so it's different from zero this is going to be horizontal and else it's going to be vertical and let's just add a pass here for now so we don't get an error now we can work on let's start with the horizontal one first of all i have to get an offset and this one is in the x direction and basically what i want to do let me draw this out let me get a bit of space here we have my player again and let's say my player is facing to the right so my direction is going to be a vector that is one and zero the one we have created up here and essentially what i want to do i want to multiply this with i so the number we got here so if the vector is positive this one is going to get us further to the right and if the vector is negative for example if it was going to the left this would give us an increasingly larger negative number but now we would still just go by pixels of one so we go one to the right two to the right three to the right and so on so i want to multiply all of this again with my tile size and that way the first flame is going to be right to next of the player and we have an offset here of 64 pixels which is going to be the tile size and then for the next flame since i now is 2 we go another 64 pixels further to the right and now the center of our rectangle is going to be here the arrow should be a bit let's put the arrow but here so essentially all i want to do i want to get my direction dot x and multiply it with i and now i want to multiply all of this with my tile size i think i called it yep tile size this one and now for each of the flames i want to get an x and a y and once we have all of that i want to call myself dot animation player and create particles and then in here i want to call my flame so in my particles the flame here and besides that i will need a position and my groups so i need my flame i need x and y and then i need the groups i am getting from the parameters so all we have to do is figure out the x and we have to figure out the y and this might be a good exercise for you so try to figure out where each individual flame needs to be spawned so where the center x and y is supposed to be alright so first of all i want to get my player.rect.centerx and player.reg.center y because my flames are always supposed to start from my player now for the x position i want to get my offset x and that's basically all i need and for my y position since we're only moving in the horizontal direction we can just leave it as it is and that is basically all we need so now in my level when i call flame i can call self.magic player and the arguments i passed in here was player cost and groups so player is going to be self.player again cost we already have and groups let's say for now this is only going to be self dot visible sprites the attack sprites we do later let's first figure out the flames by themselves so now if i run this we are getting an error because the dict has no attribute split so this is going to happen in my magic and self.stats it shouldn't be stats it should be stat twist so now if i run this down isn't going to work but if i look to the right we are getting some flames and if i look to the left we're also getting some flames so this seems to be working just fine and let's try one more time we do need enough energy there we go so i'm happy with that although there's one small change i would like to do right now i feel like those flames look too predictable like they're too much in one straight line so i want to give them a bit of a random offset for both x and y and for that i need a random number generator so from random import rand and now for both of these positions i want to add rand and essentially what i have done i went from negative tile size divided by 3 all the way up to tile size divided by 3 except in the positive direction and this i have also done for the y position so essentially tile size is 64. if you divide this by 4 you get a number around 21. and that way if we have a larger tile size we get a larger offset so let's try this now and this looks a bit more random i kind of like that one so with that we have the horizontal flames now all we have to do is do the same thing for the vertical ones so let me copy all of this we can pass it in here and now instead of offset x we have offset y instead of direction.x we want to get direction.y and the rest for this line can stay the same now for x and y we need the offset x removed from the x position and added to the y position and this should now be offset y and besides that we don't need anything else so let's try it now so this side is working this side is working let's wait for some energy this side is working as well nice so now we have our flame spell it doesn't do anything just yet but we can work on it i guess let's work on it right now first thing that we have to work on is we have to place each of our flames also inside our self dot attack sprites so let's try this but we will get an error once we attack an enemy so for the grass it should work and it does it's actually really cool effect so this is pretty good but now if we attack an enemy let's say this one we get an error that particle object has no attribute sprite type and this error happens in player attack logic so player attack logic in here and in here we have target sprite get damage and in our enemy let me minimize all of the methods in here we have where's get damage get damage is here so in here we need an attack type and for our weapons we have a sprite type called weapon and this sprite type we are passing in here so our attack sprite dot sprite type is the attack type in the enemy the problem is our particles don't have one so in this particle effect we don't have a sprite type we can give it one though so self dot sprite underscore type is going to be magic and magic is a bit broad but right now we only have a single attack spell but if you had multiple types of spells you could just get another parameter in here and there classify what kind of sprite type you have or you could even get a whole new particle effect that inherits from this particle effect and this one has a sprite type for different kind of spells so you can certainly make this very flexible with just a bit more effort but in my case i don't really mind and now let's try this actually to see what's happening now so now if i attack an enemy we are actually getting something but you see now it doesn't actually damage the enemies in any meaningful way and the reason for that is in my enemy i have weapon and we're reducing the health but when we have anything else nothing is really happening so in here we want to do something else and in here we have to figure out how much damage we are going to get but first of all we have to get our health regardless of what we are doing but besides that i want to get from my player which we still have available from the parameters so we're going to pass this in here and now from this player i want to get full magic damage like we have done just above so now in my player i right below get full weapon damage actually let me open this method just for reference so in here define get underscore full magic damage needs self and nothing else and in here again we need a base damage and we need let's call this one is spell damage and then we are going to return the base damage plus the spell damage and well for our base damage we have self.stats and this one is magic and then for our spell damage we have magic data and in here i want to get self dot magic and then from that i want to get what i called the strength so now this should be working let's try so now if i attack an enemy they should theoretically disappear let's try it again um okay this needed okay let's try this properly without reducing for the flame damage the energy cost so that way we can call it indefinitely so let's try this again let's use this one and let's do it again i'm not sure how much damage i gave ah there we go so it does indeed work and everything else still works just fine cool so with that we also have our proper flame spell so now in my player let me minimize all of the methods again and i think with that we have our magic figured out so that's another major part of this game and now it's actually coming together really nicely and we can call different spells different attacks and all of this is working very very nicely cool we are actually getting very close to being done the one thing we still have to figure out is the upgrade mechanic and that's going to be the next major section actually the last major section all right now how can we implement an upgrade mechanic and there are a couple of things that we need first of all something i haven't done yet our player should get some experience once we are destroying an enemy that one's really easy to implement and once we have that the basic upgrade mechanic works like this in our self.stats we want to be able to upgrade any of the key value pairs so for example we want to increase health by 20 and every time we are doing that we are reducing the amount of our experience by a certain amount so i guess it's not really experience it's more like salts from dark souls but you get the mechanic and i guess the only really complicated bit in all of this is the gui for the upgrade mechanic because for that we need quite a few different bits but i guess let's do it step by step and let's first add an xp mechanic and then give our player a bit more data so here we are back in the code and i want to close down a couple of things so we don't need magic anymore we do need the enemies we don't need particles and settings can stay open i guess so in my player in the ending method i have down here right now my stats and i am going to need a few more stats the first one is going to be max stats so this is the maximum amount of health or energy or attack damage that my player can have and i realized speed of 12 was a bit high so let's go with 10. i also want to have an upgrade cost so this is going to be how expensive each upgrade is going to be and now just to get started let's increase our experience to something like 500 so we can work with this a bit more easily and now the first thing we are going to need is that our player should get some experience every time we are destroying an enemy and for that in our level let me minimize all the methods in here again i want to create another method and that's just going to be add xp and this one needs self and amount and really all we're doing in here is we are getting our self dots player dot exp and plus equal the amount and now this method i want to place into the enemies so when we are creating all of our enemies the final method i get is self dot add xp and now in my enemies when they die so check def in here i also want to call self dot add exp and then we can add the amount but first of all in the parameters we have to add add exp and then let's say player interaction self dot add exp and now we can actually call it so add exp now we have to figure out how much experience the enemy should give and that information we have up here so for each monster we have a custom experience so we can just copy this one and place it in here so self dot exp and now this should actually already be working let's try and we are getting an error so enemy object has no add experience which no enemy and it's in the level and let's call it self.exp self.exp and then in my enemy the parameter is called add exp and oh i just forgot add exp okay now let's try this again there we go and now if i take an enemy there we go and we get some experience trice again there we got another 120 experience and let's try this one again and we get even more experience and i can also heal and well technically we should have just died but in my case i didn't really implement the death mechanic because well the game is already getting complex as it is but if you had an actual game this could lead you to an over world or something alright now in our enemy we have the ad experience so we can close enemies and minimize the create map method and add xp as well so all right now with that our player has the experience and we have the data now all we have to figure out is how to increase the stats of our player and for that i want to create a separate menu and that i actually want to do in my main file because in here i have my event loop and what i want to check in here is if event dot type is equal to pygame dot k down so we're pressing any button and if event dot key is equal to pygame dot k underscore m so my case the m button is the upgrade menu button and if we are pressing that i want to run myself.level and then there i have a method called toggle or i want to create a method so now in my level i can create a toggle method actually let's call it toggle menu that feels a bit more appropriate so toggle menu and if i'm doing that self dot toggle underscore menu wii itself and nothing else and basically all i want to do i want to create self dot game underscore paused is going to be not self dot game underscore paused and in my init method let's say all the way in the basic setup self.gamepast by default is going to be false and now what i can do in my run method of this level essentially what i want to do in here is if gamepost is true i want to display the upgrade menu and if that is not the case i want to run the game and now we have to figure out what to draw in here what to draw on here and what to draw all the time so let's go through it one by one our visible sprites we always want to draw even if the game is paused however we only want to update them if the game is not paused and same with the visible sprites and the enemy update then the attack logic should also be in here but my ui display i always want to display even if the game is paused because there we can see the experience so now we can get rid of all of those and now we have to figure out what to do when the game is paused and for now i just have pass in here and to actually get the full menu i want to create yet another python file and this one i called upgrade dot pi that is actually going to be our final new file so we are getting very close to finishing this project and in here as always we have to import pi game and from settings import everything now i have my class upgrade there is no need for inheritance and in here i want it under init method with self and i want to place the player in here as the parameter and in this method for now i want to have a general set up and first of all we need to display underscore surface that's just going to be pygame dot display dot get underscore surface and then self dot player is going to be my player we will need quite a bit more but that comes later the really important thing i want to have for now is a method called display this one doesn't need any arguments and for now i just want to make sure we can see what we are doing so for now i just want to get myself dot display surface dot fill and let's say we're going to fill it with black so whenever we have this menu open we're going to fill the screen with black and once it's gone we are not going to fill it so essentially what that means in my level i want to from upgrade import upgrade i believe i called it yep upgrade and now in the innit method all the way down here i guess this is also user interface so self.upgrade is going to be upgrade and this one is going to need self dot player so let's minimize this one now and now in my run method i want to run self dot upgrade dot display so now we can toggle at least in theory between a menu so in my game we get game paused not defined in my level.run because this should be self dot game paused there we go the game runs now if i press m it goes to black and if we press it again we go back to the same stage actually let me get chased by some enemies now press m and now we return back to the same stage where we were earlier so this is actually a pause mechanic and this keeps on working just fine cool and the reason why this is working is because when our game is paused we are not updating the main part of our game anymore and because of that the game picks up once we are stopping this so this is a nice pause mechanic so all we have to figure out now is how to create a proper menu and that is going to become a slightly longer section so i guess let's work through it one by one now first of all we need some input and for that again we need keys and pygame dot key dot get underscore pressed and then if keys and pi game dot k underscore right then let's say for now we just want to pass and l if keys pi game dot k left we want to move left but for now this is going to be passed as well and finally i want to check if keys and pie game that's not how you spell that pie game dot k space we also want to pass but this is going to be our select button and let's spell keys correctly all right so now we have to figure out how to actually implement these mechanics for left and right and let me explain how this is going to work i am basically going to create a selection index and this selection index can be a number between 0 and 5 and that is the amount of stats my player has so once that could be health the other set could be energy and then i have speed attack and magic and then for each of those five i'm going to create a box and each of those boxes is going to be one class so three four five and essentially what i'm then going to do is i'm going to have a selection number that let's say right now it could be one and if it is one we're going to select the box with the index number one if it is three we're going to select this box here so that way when we press left or right we are either increasing or decreasing this number and that's then all we need to do okay but for that to work we need a couple of things first of all we need our self dot attribute number and all i really want in here is the length of my player dot stats so the length of in my player i want to get this dictionary and in there i have these different values and i guess while we're at it i can also get the names so self dot attribute names and this one is just going to be a list with my player.stats and from that i just want to get the keys and finally i am also going to need a font just like we needed one for the ui so self.font and in here we have pygame dot font dot font and now we can use the same font from our ui so ui font and ui font size so ui font and ui font size and that would then be all the basic information we are going to need but besides that we are also going to need let's call it a selection system and that is the number i just talked about that we're going to increase from zero to five and this i called self dot selection index and by default it's going to be zero and since we're going to move it we are also going to need a timer so self dot selection underscore time by default it's going to be none and then self dot can underscore move and by default this one is going to be true and now in my keys the most basic thing i want to do is self dot selection index not selection time selection index plus equal one if we are going to the right or minus equal one if we are going to the left but now for the proper timer we also want to set self dot can move to false and self dot selection time is going to be pygame dot time dot get underscore ticks and these two lines we need for both of the movement so in there and there we go and now when we call left and right besides the button we also want to check and self can move so this is basically our basic movement that we have implemented a couple of times by now and now finally we need a selection underscore cool down and this one again it's just going to be a basic timer so if not self dot can move then i want to get my current underscore time it's going to be pygm.time.get underscore ticks and then finally if my current time minus myself dot selection time is greater or equal than a certain number um let's say for this one 30 milliseconds once we have that can move is back to true and now we can get rid of this surface fill and just replace it with self dot input and self dot selection cool down actually let's do this slightly differently this self dot can move probably makes more sense when we put it as a general one all the way at the top and then check all of the other keys sorry about that this makes more sense because there's one more thing that we do have to check so if we are all the way to the right we don't want to be able to go any further so i'm going to check and self dot selection index is smaller than myself dot attribute number and this one needs to have negative one because of the way we are counting in the length method and then the same thing for left so self dot selection index except this one needs to be greater or equal than one at the very least and now finally we can also start with our space button so in here i also want to run the timer and what i want to do for now is just to print my self dot selection index so at least we have something and let's try all of this is working i press m the game pauses now if i press space you can see zero in the bottom left if i press right we get to four and if i press down we get back to zero so something with the input doesn't work just yet and the reason is that this selection index should be selection time now let's try this again if i press m never press space we just get one if i press to the right we get one result up to four but if i go back we get the numbers that i actually wanted cool so this is working now okay this really is a long tutorial now i can minimize my selection cooldown i don't need it anymore and for now let's minimize the input method as well so we can see a bit better what's going on now basically what i want to do let me draw this out here we have our entire game window and what i want to do i want to spawn a couple of boxes over this thing five in total and each of these boxes should have some kind of bar on the inside that shows us how much we have and on top we want to have the name of that stat and at the bottom here we want to have the cost and i'm going to create a class for each of these boxes so each of these red boxes is going to be one instance of a class but to be able to do that i first have to figure out a couple of dimensions about the screen so i have to know how wide each of these boxes have to be and how tall they have to be and for that i need to do some math so let's work on that first and we can do this straight in the init method let's do it right here so i called the class item and we want to get item dimensions and we need the height we need self dot width as well and height is the easier one i basically want to get myself dot display surface and in here get size and this is going to give us x and y and we only care about y and i am just going to multiply this by 0.8 so we have most of the screen but we are losing about 20 percent so we have a offset essentially now for the width i can actually copy most of this except this one should be zero so we get x and i'm going to divide this by six which is my attribute number plus one so that way i have my five elements and the sixth one or the width of the sixth one is going to be the padding between them and now i can create another method and i call this one create items and for this one we don't need any arguments and essentially let me create a class right now i want to create a class that i called items or item and each of those is going to be one box that we can upgrade and for this one i need an init method and then here i want the left i want the top i want a width i want a height i want an index so we know what is selected and i want a font so all of this is what we have to figure out in this create items i guess for now let me add pass in here so python doesn't throw an error okay now first of all i want to store all of these items in the list so let's call it self dot item underscore list for now it's just an empty list and now i just want to go for i let's sorry for item in range self dot attribute number and now i have to figure out the horizontal position i need to figure out the vertical position and then i have to use that to create the object so let's do the last step first item is going to be my item and in here i want to have a left the top then the width i already have that's the one i have up here so self dot with and self dot height then the index we're also going to get in just a second and then the font we already have that's just self dot font so essentially we have to figure out the left the top and the index and once we have all of that i can get myself dot item list dot append and my item now we have to figure out the horizontal and the vertical position and the vertical position is kind of easier so let's start with this one and here we need the top and right now we know let me draw this actually so if this is the entire height of our game let's call this h so this is the entire window in specific numbers this would be 12 80. and we know that 80 of this so let's say roughly this one is going to be our current self.height so this number here so we have 10 here and we have 10 up here now because i want my boxes to start on this line essentially all i really need is 10 of the screen height starting from the top of the screen that's the only number i need for the top and this one is really easy to get so i need self dot display surface dot get underscore size i need the y number again and now i have to multiply this by 0.1 i guess you could make this system a bit more flexible by putting these two numbers inside of one variable but i'm not going to worry too much about it but all right with that we have our top now our left unfortunately is going to become a bit more difficult i guess first of all i want to have my full width and this one i can actually copy it is this number here except we want to have zero so right now we know the entire width of our window then i want to know by what increment i want to move to the right and let me actually draw this so right now this here is the entire height of our game so let's call it h oh and this one is actually 1280. the height before window is 20. the height of our window is 720. uh well i guess you get the idea but anyway this one right now is 1280 pixels wide and this is what i got with full width and now what i essentially want to get is i want to have a bit of an offset from the left and then i want to have my first element so let's start here with the left of the first element the first element should then go let's say roughly to here and then i want to have a bit further to the right another element and this should then be the left of the second element or i guess to be a bit more specific this should be the index zero and this should be the index one that is a bit easier to comprehend and this number is then going to be the increment it's basically the distance from the left to get the left side of each item and this number i basically get with my full width divided by myself attribute number so right now we are splitting the entire window into five different parts and with all of the information i can get my left so now all i have to do is i want to get my current item number so this could be either 0 1 2 and so on and multiply this by my increment and then to what's that i want to get my increment and from that subtract my self.width of each of the items and floor divide this by two and that way we are offsetting each of the elements a little bit further to the left and well with that we have our left side now finally i need the current index and the best way to get the index is just to use the enumerate method and then we get item and index so with that we have the basic setup to create each of these items and let's actually draw them so we see what's going on i know it's getting a bit theoretical so basically what i want to do in the init i first of all want to create a self dot rect and this is just going to be a pygame dot rect and then here we can just pass in left top width and height and besides that i also want to get myself dot index and that is going to be the index and i want to get myself dot font and that's going to be the font and now each of these items is going to have their own display method and for this one besides self we need the surface to draw on so our display surface then we need this selection underscore num so what our currently selected item is so we can highlight it and then we need the values we actually want to display so be aware the item is essentially a box that could display any kind of information whatever we pass in so we actually have to pass in our stats so i want to have a name a value a max value and a cost and these are the informations i want to draw now that we have all of that for now let's just draw some basic thing all i want to do is pygame.draw.rect and we get the surface from the parameters then for the colors for now i just want the background color from my settings oh actually in my settings we need to import a bit more information because in here the upgrade menu has its own colors so finally a tiny bit more this is the last bit we need but for the background i just want to have the ui bg color so let's copy this one and paste it in here and finally self.wrecked the one we created up here here so for now we're just drawing a basic rectangle to see if something is going on in the first place and now finally for my display i can just draw all of them so i can for item in self dot item list i can do something but first of all i forgot to actually call self.createitems and let's do it below this one so self.create items and let's call this section just item creation okay we are nearly done sorry this section gets a bit more complex it's kind of hard to visualize but now in my for loop i just want to get item dot display and here we need the different arguments so we need all of these arguments let me copy them so surface is going to be myself dot display surface selection number for now we're not going to care about it it's going to be 0. name let's say for now we can just write test for value it's going to be 1 max values let's say 2 and cost 3. these numbers for note don't matter i just want to see if this is working in the first place but now we should see something so let's try to run main.pi and press m and there we go we can see our five different boxes so at the very least this is working and i'm fully aware that the logic here is getting a bit more complex so i would recommend you to go over this if you're struggling with this so especially to create items can be a bit finicky but well let's continue with what we have now the first thing i want to do is to actually display the names of what we are dealing with so for now i want to show the name of the attributes and i guess what we added we can show the cost and for that to work we have to let's call it get attributes and we will need the name we will need the value we will need the max value and finally we will need the cost and since we also have to figure out what the index of each number is i also want to put item list in an enumerate method so this should be index and item and now let's work for them one by one first of all the name we already have in our attribute names so in here all i really have to do is get myself dot attribute names and then select the index for the values i need to get myself.player and for this one i want to write another method in the player that i called getvalue by index and this one's going to get the index we're going to write that in just a second now for the max values i want to get them right at the top here because those don't change so in here self dot let's call it max values and to get this one it's supposed to be a list and i want to get my player.max stats i think i called it it is mac stats here and from this one i want to get the values so now for my max value i can just look at myself.max values and pick the one by the right index and finally for the cost this one also i want to get myself dot player and then get cost by index and we want to pass in the index all right and now in the player let's create those two methods and let me actually copy them so it saves me a bit of writing and let's write them right below the other two getter methods so we have get value by index self and index and then let me copy all of this and get cost by index and in here i essentially want to return just the value for each specific value in our stats so essentially i want to get my current value from this list here or this dictionary rather and all we have to return is first of all we need a list with our self dot stats dot values and from that i want to select the index and that's really all we need it's not a particularly complex one and now i can copy this and now instead of stats i want to look at my upgrade cost so this way we also get our current index right in here with just one line of code and now all we have to do is to pass all of this information in the display method so first of all the surface we still have and now for the selection number i want to pass in myself dot selection index then next up we have my name and this can just be name then we have the value that's going to be value then we have max value and then we have the cost so let's check if this is the working we're not getting an error message that's at the very least a good sign so now we are passing in all the information we need in here so let me for now hide the upgrade menu we're not going to need it for a while so essentially all i have to do now is create a couple of methods to display the different things first of all i want to write display underscore names and then here we need self we again need the surface to draw on then we need the name and we need the cost and i also want to check if this is the currently selected box and in here we are going to create the title text and we are going to create the cost text and then at the end once we have created them we are going to draw everything so let's create the title first and then here i just want to create a title surface this one is going to be self dot font dot render and what we want to render is the name we already have and since we're drawing pixel art i don't want to antialiasing and now we are going to need a color and the color i am getting from my settings and in here we have a text color so let's pass this in here and then besides the surface we need a title rect and what i want to do is to get my title surface get wrecked and now the mid top should be where myself dot rekt dot mid top is and from that i want to give it an offset so pygame dot math dot vector 2 we want 0 offset in x and in my case 20 pixels in the y direction and with that we can get our surface and blit and create a title surface and the title rectangle so now in my display method i can run self dot display names and then here pass in the surface we already have then we want the name we want the cost and let's say selected for now is going to be false we're going to change that later on okay and let's try this if i press m we are getting an error because get rekt here should not be capitalized and now let's try this again there we can now see health energy attack magic and speed this is working really well and now besides that i also want to display the cost and this could be a good exercise for you so just like the title try to display the cost except now the cost should be at the bottom of each of the bars right first of all i want to create a cost surface going to be self.font.render again and in here i want to draw my cost but my cost right now is a number so i'm going to turn this into an f string and there is a chance that my cost might become a floating point number so i'm also going to convert it into an integer but besides that we can just copy the other arguments from my title surface and now once we have that we need our cost rect and our cost serve dot get underscore rect and this time i want to place my mid bottom and it's going to be myself dot rect dot mid bottom except with an offset so pygame.math.vector2 and 0 and 20. although now be aware we are subtracting that vector without increasing like in the upper one and now all we have to do is surface dot blit we need my cost surface and cost and that should be all we needed let's try now and there again we can see our cost now there's one more thing that we do have to do and that is to work with this selected and essentially what i want to do is in my upgrade i have a selection index and if the selection index and the index of each item is identical then i want to highlight this and actually let me illustrate this this might be slightly confusing so this right now is our entire window and in here we have a couple of bars let's do all of them so here we have five and each of those has an index that's the index we created just here and there are zero one two three and four and besides that i also have a selection index and this one could be anything between zero to four and this is also the number we can influence with our keyboard input and essentially what i want to do if for example our selection index is a 1 then i want to highlight this box here and if it's let's say a 4 i want to highlight this box here so whenever the index of our item is the same as our selection index then i know i want to highlight this box and i can change some colors that's the entire idea here and i have both available in my class actually so this selection number is our selection index so the one we are passing in here and essentially all i have to do is if myself dot index is identical with the selection number i think i called it yeah selection number if that is the case we should be drawing something in a highlighted way and we're going to use this later but for now let's add pass in here and what we can also do is copy all of this and pass this in here for the true or false argument so this comparison can become either true or false so now that this selected here gives us either a true or false statement we can use that to influence the color and we have two different colors in our settings so we have the text color and text color selected so now if my text color is selected i basically want to do i have text color selected if selected is true and if that is not the case so else i just want to have my text color and now i can pass in color for both of the text colors and we should be good to go let's try this so now i press m and now my health and my health cost are darker if i press to the right we now have other fields selected and this is working quite well now obviously right now this is very hard to see but later on we are also going to change the background color for each of these items so it's going to be easier to see but for now this is working quite well i guess we can actually do it right now so if this if statement here is true we want to draw a selected color and if it's not true we just want to draw the regular background rectangle and i guess while we're at it i can duplicate this one because we also want to have a border color so i want 4 for the width and now for the border color i have ui border color and back in my upgrade i can change this one and let's try if this is working and yeah this looks pretty good oh now you can even tell we're not drawing any background for the currently selected item not ideal but it does look kind of funny but we can change this quite easily by just copying those two and putting them in here and now in my settings we have upgrade bg selected that we can place in here and ui border color actually stays the same so now let's try this and i press m and there we go this is looking really nice so with that we can properly see which one is selected what we have to do next is create another method and this is going to self dot display let's call it the bar and this is going to be the upgrade bar and then here let's actually create the method because this one also needs a couple of parameters so display underscore bar self as always we need a surface then we need our value we will need a max value and we need to know if this one is selected or not because that will change the color and now let's talk about what we have to do this one here is going to be one of the items and inside of each item i want to have a bar and inside of each bar we have the name and the cost that one doesn't matter right now but now what i want to do is to place a line in here and on this line we have a rectangle that shows us how much the player currently has in this skill and this one can go all the way to the max level and actually let me leave this one up here right now might be kind of helpful and let me spell properly this should be display bar now first of all we need some let's call it drawing set up and in here we want to know what the top and the bottom and i guess also the color of this bar is going to be so right now we just want to know what is the top and what is the bottom of this bar going to be is going to be self.wrecked.mid top and then i want to give this one an offset so plus pi game dot math dot vector vector 2 and 0 and 60. so we're going down a tiny bit and then for the bottom we can do something fairly similar except now we look at the mid bottom and we are subtracting in the y axis and for the color we have in our settings bar color and bar color selected so i want to have bar colors selected if selected and if that is not the case i just want to have the normal bar color and i guess we can actually already draw this line so draw elements and essentially what i want to do is pie game.draw.line and this one first of all is going to the surface and the surface we have from our parameters besides that we need a color this one we also have and then we need a top and a bottom also elements that we have so all of the stuff we just created so now i can actually call my bar so let me copy all the parameters again my surface is going to be my surface again my value we already have my max value we also have and selected is going to be the same thing we got from earlier so now this should be working let's try and there we can see we have a line although it is very very thin and the reason why it is so thin is because i didn't set a border width by that we can add with another argument and let's give it a width of five and now let's try this again there we go this fits better and this is looking pretty good so now what i essentially want to do is to place a rectangle somewhere on here to illustrate how much of this value my player currently has so we have to get let's call it a bar set up and first of all i need to know the full height of this thing and that is just going to be bottom and be aware my bottom right now has an x and a y position and i only care about the y one and from that i want to subtract my top and i also want just the y position and be aware here the origin of our window is in the top left so the bottom one is the higher number which is why we are subtracting top from bottom but all right now i want to have the relative number this right now is the value that i currently have divided by the max value so let me add a bit of space let's say right now in my init method they're my stats so if my health is 100 and my max health is 300 i want this bar to be at one third of the maximum amount and this is exactly what we are doing here so this is going to give us something like 0.3 and this then i just want to multiply with the full height to turn this into a pixel measurement and now i can create let's call it a value rectangle and this is going to be pygame dot rect and this one does need to be capitalized and in here we need left we need top we need a width and we need a height and for the width and height i just went with 30 and 10. fairly random numbers i just went with what looked good now for the left i just went with either top or bottom doesn't matter they have the same position anyway and i went with zero so this is going to give me the x of the top and from that i'm going to subtract 15 which is half of my width and then the top is going to be the bottom of my bar so one and from that i'm going to subtract the relative number so just to illustrate what's happening here if this is our entire bar then bottom one this bit here is this point all the way at the bottom and then the relative number is going to be however much of a gap that is from the bottom so this way our bar would be here ish and all right with that we have something to draw so pygmy.draw.rect i again want the surface the color and this time i want to draw a value rectangle and now let's try this and this is looking pretty good with that we only need to figure out how to actually increase any of these values and for that i have another method and this i called trigger and trigger needs self and player and we first of all have to figure out how to actually call this thing and this is going to happen let me minimize all of these methods this is going to happen essentially in here so right now we're just printing our selection index it doesn't really do anything right now instead i want to call this trigger inside of my item and we can minimize quite a few different things so it's a bit easier to see that is feeling slightly better i guess ah there we go okay essentially i want to get the trigger from my item list in here so i first of all want to get myself dot item list and from that thing i want to get myself dot selection index and this one then i want to call the trigger method on and pass in self.player and now in this trigger method we can get the first of all let's call it the upgrade attribute and this we get with player dot stats dot keys turn all of this into a list and once we have that we can use self dot index to get one specific value and index will always be the same for each item and i guess for now let's just print our upgrade attribute so we know this is working so back in here i can press space on health we get health energy attack magic and speed so this way we know which element we are selecting now besides that we have to first figure out if the player has enough experience to upgrade this certain kind of value so i want to check if my player.exp is greater or equal then my player dots upgrade underscore cost it was called so in my player we have upgrade cost so upgrade cost and i am only caring about my upgrade attribute and now once i have that and that is actually true i want to get my player.exp minus equal player dot upgrade cost again and get my upgrade attribute so now we are lowering dxp and then for my player.stats now we can finally upgrade something yep we have my upgrade attribute and in my case i'm just going to multiply each value by 1.2 and what i'm also going to do every time we are upgrading a certain part i want to increase my upgrade cost by 1.4 so we get increasingly more value and it becomes even more expensive every time we upgrade and now actually let's try this so now if i press space on health we get 140 and our experience did go down so now we get to 64 and we can't press this anymore because we don't have enough experience and let's actually try to destroy some enemies okay this should be enough now our health still stays at 274 and i can press space again and now we get even more health cool this is working really well and i can still heal up and all of this is working really nicely so with that we have some basic upgrade mechanic now there's one more thing we do have to do and that is if our current value exceeds the maximum value i don't want that to be possible so if player dot stats and we want to check my upgrade attribute is greater than my player dot max stats and again my upgrade attribute and if that is the case i just want to set those two equal to each other and i guess what we could also do is in here we only allow the player to upgrade if my player stats is lower than my max stats i guess just another safeguard can't hurt to have those and all right with that we have a trigger and i guess we can test this so in my player i'm going to give the experience of 5000. now in the game i can upgrade i guess my attack is the highest one right now i can increase this to well the maximum and we can't go any further so seems to work just fine and alright with that we have our upgrade menu there's one more thing i do have to do because in my player so far we had self.speed but we don't really upgrade this after we upgrade so after unit method this self.speed is not being used anymore so i can get myself.speed and now all the way in my update method i don't want to use self.speed i want to use self.stats.speed and now in my game this is how we move by default and if i increase my speed all the way to the top we are moving significantly faster so we know the upgrades actually do something in the game cool except i'm still terrible at my own game but never mind and that was the last major section in the game there's only one more thing we have to do well two things we have to add the sound and there are some tiny details i do want to change but let's talk about them in their own section the first one is to fix a couple of smaller issues that are annoying me they are mostly visual and once we have that we are going to work on the audio and essentially what i want to do in my game in terms of visuals that in the original i had an offset for each individual object so the trees and the grass for example had different kinds of offset because they have different sizes and this i forgot earlier so i did want to include it and besides that right now if we walk too far to the right of our map we can see the black background which looks a bit weird actually let me illustrate all of this straight in the code and then we can work on it so here we are in the game and if i run this and move all the way to the right let's go all the way here i think you can see it there you can see the background is just black which looks kind of weird and for this or well the reason is we have a black background color but in my settings we have a watercolor and this i just want to copy in here and we have our settings available so this watercolor is the same color as the water that's why it's called watercolor and well now if i run this we can go back here and now we can see only water so this looks a bit better although admittedly the water does look a bit boring but well we are at least getting a decent color so now besides that in my settings i also want to add another entry let's put it all the way up here and that is called hitbox offset and in here we have one for the player one for the object one for grass and one for invisible tiles so let's actually go through them and in my player let me minimize everything again in the init method here we have our hitbox and there we already have the 26 so we could leave it as it is but just to have everything in the settings let me call the hitbox offset and in there i want to get the key player and what i also want to do is just for the player i want to reduce the hitbox for the x dimension as well although not by much let's say by 6. and let's try this and with this it becomes a bit easier for our player to move through smaller gaps so especially here well it's kind of hard to see but with our player being a bit less wide it does make it easier to move around not a major change but it does make the game feel significantly better okay with that then we have to work through the appetites so we have the player now we need the object and the grass and all of this happened in my tile this one here and in here we are getting our hitbox all the way at the bottom and this one can change depending on if we have grass or an object so i want to put this in a separate variable let's call it y offset and in here we're just going to use hitbox offset and then we have a sprite type so sprite type we are getting from our level and we are getting it from create map and in here we have grass and we have object so we're passing them in here or in here so this is how we then get the y offset and now we can just get the y offset and paste it in our inflate method to get the hitbox and that way we have quite a larger offset for the trees so the objects get minus 40 and the grass only negative 10. so this is now going to make it drastically easier to move around because we can move much further behind the trees and this means that when we work for the forest things are much better in terms of movement so this feels considerably better for the movement and that is kind of all i wanted for the basic movement oh and i actually forgot in my settings there's also invisible and invisible we get from our boundary tiles and they also work in here with the sprite type so this tile class actually pulls a ton of weight but all right so with that we have a couple of fixes that i really wanted to add that make our game feel surprisingly better but now that we have that all we have to do is add sound and then we are done and okay i guess we can go through it step by step add the different sound effects and all the way at the end we add the soundtrack for the game so let's go through it step by step first and i guess we can start with the player that one probably has the most common sounds so here we have the player and in my indian method i want to import his sound and all i want for the player is self dot weapon attack sound and this one we get with pygame dot mixer dot sound and in here we need a path we have to go up out of the folder then into audio and then we have sword dot wav and one thing i also want to do is for my attack sound i want to set the volume to 40 of what it is that way it's not getting too annoying and now in my input method whenever i have my attack input i also want to call self dot weapon attack sound and play it and that should be all we need for this one sound let's try it now and seems working just fine now next up we can add some sound to the magic because in there in my init method i want to have let's call it self.sounds and this is going to be a dictionary and here we want to have a sound for heal and another sound for the flame and in here i want to run pygame dot mixer dot sound and we have to go up a folder then to audio and then to heal dot wav now i can copy all of this and paste it in here except now we want flame and i guess if you want to make this a bit more elegant you could paste these sounds or the path to these sounds into this magic data i have actually done this for the sounds for the attacks but in our case the magic sounds are so few it doesn't really matter all right now when we are playing the health effect we can somewhere in there round self dot sounds call heal and then lay it and then we can do the same thing oh and we have to reactivate the energy cost for the flame effect and while we had added we can add the flame sound and now let's try this so we are getting an error that audioflame.wlv was not found let's have a look so i couldn't find this one because the file was called fire.wav now let's try this again and that looks better attack still works and now the name works and magic also works just fine cool so with that we can close the magic file and not worry about it anymore then next up i have my enemy sounds and that is going to be in the enemies let's open that file enemies enemy enemy and in here just in the init method i want to have a sound section and we essentially have two sounds self dot def sound this one is going to be pygame dot mixer dot sound and i want to have my fold up then my audio and then here we have def dot wav now i can copy all of this and i have a hit sound and this one is called hit.wav and now for both of these self dot def sound i want to set the volume a tiny bit lower to 0.2 and the same for the hit sound and now we just have to figure out where to call them and the death sound is the easier one actually let me minimize all of the methods this code is really getting extensive so in my check dev if this is true i want to call self.def that's not how you spell that deathsound.play that's the first one and the other one we want to play when we get to get damage down here so in get damage we want to play this once self dot hit sound dot play and that should be all we need so let's try this that feels pretty good now for the enemy again there's one more sound we have to import and let's put it right here as well actually let's put it right here so in my settings we have one more sound this attack sound for each of the different attack types so self dot let's call it the attack sound and this one is going to be pygame dot mixer dot sound again and in here i want to have first of all the entire dictionary so my monster data and in here i first of all need to get my monster info i think i called it so in here we get the entire dictionary so the dictionary we get is this one for example for the squid and in there we want to pick the attack sound string and this one we can just get by indexing and i also want to reduce self dot attack sound dot set volume and this one i set to 0.3 and now we just have to figure out when to play it and this happens in my actions so in here if the status is attack my enemy is attacking so what i can do is self dot attack sound dot play and now this should be working so let's try this one and i can edit here the bamboo enemies i can hear all of the enemies and there certainly is some sound cool seems to be working so the final thing in this entire project is going to be in my main file where we start playing the sound so right here in the init method of my game i want to have sound and i'm going to import main sound and i am importing pygame dot mixer dot sound and in here we have a string we go one fold up we go to audio and there's a file in there called main dot o g g and this main sound i want to play and in here importantly we want to determine the loops they should be 1 so we are playing this continuously now let's try this all right now i think the one thing i do want to do is main sound dot set underscore volume and set this to something like 0.5 it's probably a touch loud right now and okay this one feels better i guess in terms of fine tuning the enemy sound effects feel a bit quiet so let's set those to 0.6 and let's see how that feels and yeah this is feeling much better and all right with that we are actually done i think that covers the entire game so thank you so much for sticking around if you actually managed to get all the way to the end of this project i hope you got something out of it and well i'll see you around
