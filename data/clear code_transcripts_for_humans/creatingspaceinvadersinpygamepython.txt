With timestamps:

00:04 - in this tutorial
00:05 - we are going to create space invaders in
00:07 - pygame and this can be either in a
00:09 - modern style or with a retro overlay i
00:11 - will cover both
00:13 - now this is a slightly more advanced
00:14 - pygame tutorial
00:16 - so i assume that you already know the
00:17 - basics however
00:19 - if you don't or you want a refresher i
00:21 - have made an extensive pygm tutorial
00:23 - that would prepare you perfectly for
00:24 - this video
00:25 - so check this one out if you're a bit
00:27 - lost and this is only going to be the
00:29 - first advanced pie game tutorial and
00:31 - there will be quite a few more
00:33 - the next one is going to be a mario
00:35 - style platformer with pirates
00:36 - so get subscribed if you don't want to
00:38 - miss it also you can check my twitter
00:40 - for updates on what i work on and let me
00:42 - know in the comments if you would like
00:43 - to see a game in the future
00:44 - but with all of that covered let's go
00:46 - into the game and i hope you enjoy
00:48 - alrighty so let's get started with the
00:50 - first part of this game
00:52 - and for now we are only going to set up
00:54 - the main window
00:55 - and the class that is going to contain
00:57 - the logic of the entire game
00:59 - so for now we're not really going to
01:01 - draw anything we're just setting up the
01:03 - actual game
01:05 - so let's jump straight into pygame and
01:07 - let's have a look at this
01:08 - and in here i already have a couple of
01:11 - things open
01:12 - most importantly we have the basic pie
01:14 - game setup
01:15 - nothing fancy happens here then i set
01:18 - the display width and height
01:20 - and use those to create a display
01:24 - surface
01:25 - and that one we call later down here
01:28 - to limit the frame rate and then in the
01:30 - actual game loop
01:31 - we are checking for the escape button we
01:34 - are drawing a background color and then
01:36 - we are drawing anything that was drawn
01:38 - in the game loop
01:39 - so this entire thing right now is
01:40 - essentially the most basic setup for
01:42 - pygame that
01:43 - doesn't do much yet so if you execute
01:46 - all of this
01:47 - you would get a blank window with a
01:49 - darkish background so
01:50 - really not much is happening here and
01:52 - this code isn't going to
01:54 - change all that much because most of our
01:56 - game logic happens inside of a class
01:58 - and all we do in here is create an
02:00 - instance of the class and run
02:01 - one method of that class in the game
02:03 - loop however there is one change i would
02:06 - like to make
02:07 - and that is i want to place this entire
02:10 - code inside of an
02:11 - if statement that if done the name
02:15 - is equal to the string thunder main
02:19 - and if i execute this code we are not
02:21 - going to get
02:22 - any kind of change and the reason why i
02:25 - am using this if statement
02:26 - is because we are going to work with
02:28 - multiple files so there is a very small
02:30 - chance that you might execute some code
02:32 - you don't actually intend to run
02:34 - and this if statement prevents that
02:37 - entirely
02:38 - so it's essentially a safeguard that we
02:39 - didn't necessarily need but it is good
02:41 - practice
02:42 - so now we have our basic setup now with
02:45 - that covered
02:45 - i want to create a class and this i code
02:48 - game because it contains the game logic
02:50 - and for now this class is going to have
02:53 - two methods
02:54 - one is the init method that for now
02:57 - doesn't do anything so i just add pass
02:59 - in here
03:00 - and then i also want a method called run
03:05 - and this one also gets a pass so we
03:07 - don't get an error message
03:09 - so let's talk about these two methods
03:11 - init is the usual initiate method of a
03:13 - class
03:14 - and we are essentially going to add lots
03:16 - of sprite groups here
03:17 - for example the player has a sprite
03:19 - group the obstacles and aliens are
03:20 - sprite groups each
03:21 - and stuff like that and that is
03:23 - essentially going to be the framework of
03:25 - our game
03:26 - and then in the run method we are going
03:29 - to
03:29 - update all sprite groups and
03:33 - we are going to draw all sprite groups
03:36 - so this run method is essentially the
03:38 - main part of our game
03:41 - so in the if statement i want to create
03:44 - an instance
03:45 - of this game and then
03:48 - in the game loop i want to run
03:51 - game.run and that way we can add all of
03:54 - our game logic
03:55 - in this game.run and write the actual
03:58 - code
03:58 - inside of this class and this is
04:02 - a nice setup to keep our actual game
04:04 - loop clean and have all of the logic
04:06 - inside of the class
04:07 - and that should make running the entire
04:08 - game much simpler
04:10 - and already with that we already have
04:12 - the basic framework for our game
04:14 - now obviously right now it really
04:16 - doesn't do all that much
04:17 - but that we can start working on now and
04:20 - the first thing i want to work on is the
04:22 - player
04:24 - and the player will have to do a couple
04:26 - of different things
04:28 - it needs to show an image of the player
04:30 - itself it needs to be able to move
04:32 - it needs to be constrained to the screen
04:34 - so we can't move outside of it
04:36 - and it has to be able to shoot a laser
04:37 - and to recharge
04:39 - which basically means there's a timer
04:40 - between shooting a laser so the player
04:42 - can't shoot continuously
04:44 - and all of this is going to happen
04:46 - inside of a sprite class
04:47 - so we keep the entire code organized and
04:49 - have one class for the player
04:51 - so let's jump straight back into the
04:53 - code and let's have a look at this
04:55 - so here i am back in my main file
04:58 - and i want to create a new one so let me
05:00 - create a new one and let me save it
05:02 - and i'm going to call this one
05:04 - player.pie
05:06 - and in here first of all i want to
05:07 - import pygame and next up
05:10 - i want to create a player class and this
05:13 - one has to inherit from
05:15 - pygame.sprite.sprite
05:18 - and in here as always we need the init
05:20 - method
05:21 - needs self and for now nothing else and
05:24 - first of all
05:25 - we need super dot init very easy to
05:28 - forget
05:28 - but very important and now
05:31 - like any other sprite class we are going
05:34 - to need
05:35 - self.image and we are going to need
05:38 - self.rect
05:40 - and both of those are very easy to get
05:43 - for
05:44 - the image itself i just want to import
05:46 - an image so pygame.image.load
05:49 - and filepath is going to be
05:52 - this one so we are going to the parent
05:55 - folder
05:55 - and there's a folder called graphics and
05:58 - in there there's an image called
05:59 - player.png
06:01 - and i want to convert alpha
06:04 - this image and now for the rectangle
06:07 - i want to grab myself dot image and get
06:11 - the rectangle
06:12 - and i want to place the mid bottom and
06:15 - where i want to place it
06:17 - is going to be a position that
06:20 - we are going to get when we initiate
06:22 - this class
06:23 - so effectively this position here is
06:25 - going to be a tuple that we pass
06:27 - in here and already this is going to be
06:31 - the most basic setup for sprite class
06:34 - and now you should be able to call this
06:37 - class
06:38 - inside of our main file and this could
06:41 - actually be a really good exercise
06:43 - that i want you guys to do two things
06:45 - first of all
06:46 - add one attribute to our game class that
06:48 - is called player
06:49 - and this player is going to be a group
06:51 - single that contains the player sprite
06:54 - and then in our run method i want you
06:56 - guys to draw this class
06:58 - and this should be somewhere on the
06:59 - screen it doesn't really matter where
07:01 - ideally put it somewhere on the bottom
07:07 - alright so first of all i want to create
07:11 - self.player in my game class
07:14 - and this is going to be
07:17 - pygame.sprite.group
07:18 - single and in here we have that our
07:21 - player
07:21 - although in my case i first want to
07:24 - create a player sprite
07:26 - and this is going to be player with a
07:29 - certain position
07:31 - let's say for now i want to place it
07:32 - right in the middle of the screen so 300
07:35 - and 300 however if we were to run
07:38 - this player we would get an error
07:40 - because this doesn't exist in our file
07:42 - yet
07:42 - because we have to import it and well
07:46 - all i have to do
07:47 - is from player import player so we want
07:50 - to import
07:51 - this player file here and from this file
07:53 - we want to import this
07:54 - player and once we have that i want to
07:57 - put this player's bright
07:59 - inside of my group single and now we
08:02 - have a group single with one sprite
08:04 - inside
08:04 - so inside of our run method we can call
08:08 - self dot player and i want to draw this
08:12 - and i want to draw this on the surface
08:14 - screen
08:15 - which is going to be our display surface
08:20 - and now let me run the code to see if
08:21 - this is working and indeed there we can
08:23 - see our player
08:24 - so this is working quite well but now
08:27 - obviously we want this player to be at
08:28 - the bottom of the screen
08:30 - so instead of placing it in the middle
08:32 - in the y axis
08:33 - this should be 600 or even better
08:36 - this should be screen height and
08:41 - the x-coordinate should be screen width
08:44 - over two and now let's run this again
08:47 - there we go
08:48 - now our player is in the bottom middle
08:50 - of the screen for the simple reason
08:52 - that we have first gotten this green
08:55 - with
08:56 - and divided by two so it's going to be
08:58 - half of the screen
08:59 - and the bottom of the player is at this
09:02 - position here
09:03 - at 600 and since this is going to be the
09:07 - bottom border this puts our player also
09:09 - at the bottom border
09:10 - this is already a pretty good start so
09:14 - with that we can start working on the
09:16 - player input
09:17 - and this also happens in the class and
09:20 - let's call this one
09:21 - get input it needs self as usual but
09:24 - nothing else
09:25 - and in here we first of all want to get
09:27 - all the keys
09:28 - and for that we need pygame dot key
09:32 - dot get underscore pressed
09:35 - and now we can check different keys
09:36 - being pressed so if keys
09:40 - highgame.k right so we're pressing the
09:44 - right arrow down
09:45 - and if that is the case i want to grab
09:48 - self.rect
09:49 - and move it somewhere to the right and
09:52 - the amount
09:52 - i want to move it i want to defined in
09:54 - self.speed
09:56 - so when we initiate the class i want
09:59 - self.speed
10:00 - and let's say for now we can put this
10:02 - down to a five
10:04 - so whenever we're pressing the right
10:06 - button our player rectangle is moved to
10:07 - the right
10:08 - so the entire thing is being moved to
10:09 - the right now along with that
10:12 - we also want to do the same thing for
10:15 - pi game dot k left
10:19 - and this time it would be self.direct
10:21 - minus equals self.speed
10:24 - and with that we would have at least for
10:26 - now all the input we are going to need
10:29 - and next up i want to create an update
10:32 - method and in this update method for now
10:35 - we just call getinput and this needs to
10:38 - be
10:38 - self.getinput so now if i go back
10:43 - to my game class i can call
10:48 - self.player.update
10:49 - and this should be working so let's try
10:53 - and it is not working
10:56 - for the simple reason that this should
10:59 - not be the rectangle
11:00 - it should be rect.x because we're only
11:02 - moving in one direction
11:04 - but now let's try this again and now it
11:07 - is going to work
11:08 - so with that we can move our player left
11:10 - and right however there's one problem
11:12 - our player can move outside of the
11:14 - screen
11:15 - so that's not great
11:19 - and this could actually be a really good
11:20 - exercise for you to work on
11:22 - that i want you guys to figure out how
11:24 - to constrain the player to the actual
11:26 - window
11:27 - and this should happen inside of the
11:28 - player class
11:36 - let's start working on it and first of
11:38 - all our player has to know how wide the
11:40 - screen is
11:42 - so what i'm initiating the class here i
11:44 - want to add
11:45 - another argument and that is going to be
11:47 - the screen
11:48 - width and while we're at it i think it's
11:51 - also a good idea to determine the speed
11:53 - of the player in here
11:54 - so i'm going to add another variable for
11:56 - the speed so
11:58 - this is the maximum constraint of the
12:00 - player and this is the speed
12:02 - so with that let's go back and here we
12:05 - have to define
12:06 - a constraint and a speed
12:10 - and the speed is the easier part we just
12:12 - add speed in here
12:14 - and now i'm going to add another
12:16 - attribute that is going to be max
12:18 - x constraint
12:22 - and this one is going to get my
12:23 - constraint
12:26 - and now this attribute we can use to
12:28 - constrain the player
12:29 - and this i'm going to do by creating
12:32 - another method
12:34 - and let's call this one constraint
12:38 - and then here we don't really have to do
12:40 - all that much
12:41 - all we really want to do is to check the
12:43 - left and the right side of the player
12:45 - so if self.direct.left for example
12:49 - is smaller or equal to zero
12:53 - because that's our left side and if that
12:55 - is the case
12:57 - i want to set the self.rect.left
13:01 - exactly to zero so essentially what is
13:04 - happening here
13:05 - is that whatever our player is further
13:07 - to the left than the screen
13:09 - we are placing the player right on the
13:10 - left side of the screen
13:13 - and we can also do the same thing for
13:15 - self.direct.right
13:17 - if this is greater or equal to self.maxx
13:20 - constraint
13:22 - and if that is the case self.rect.right
13:26 - is going to be exactly on that point
13:29 - and that is literally all we needed to
13:32 - make this work
13:33 - so let's call self.constraint
13:37 - let's save the file and let's run our
13:40 - main game
13:40 - and let's try this again
13:44 - and there you can see this is working
13:45 - quite well that the player cannot leave
13:48 - the screen
13:49 - which feels much more realistic
13:52 - now with that part covered we can add
13:55 - the laser shooting mechanic of the
13:56 - player
13:57 - and this is going to be another part in
14:00 - our get input method
14:03 - and really all i want to do in here is
14:05 - if keys
14:06 - pygame dot k underscore space so we are
14:10 - pressing the space button
14:12 - then i want to run a method and let's
14:14 - call this self.shoot
14:17 - laser and obviously now we are going to
14:21 - need
14:21 - that method so define
14:24 - shoot laser needs self and nothing else
14:28 - however right now we can't really create
14:31 - the entire laser yet
14:32 - for the simple reason that the laser is
14:35 - going to be its own spread class
14:37 - that we simply spawn in here and we
14:39 - haven't created laser yet
14:41 - so we can't use it instead i'm just
14:44 - going to print
14:45 - shoot laser for now and we're going to
14:48 - change this
14:49 - in just a bit and let me save the file
14:52 - and let's test if this is going to work
14:54 - so now if i press space you can see in
14:56 - the bottom right that we are shooting
14:58 - the laser
14:58 - multiple times and this is actually one
15:01 - of the problems that we have to address
15:03 - that this laser needs a timer because if
15:06 - there wasn't a timer the player could
15:08 - simply keep on pressing space and shoot
15:10 - forever
15:11 - which would make the game very simple
15:13 - which we want to avoid
15:15 - so in our player class we have to add a
15:17 - timer and that is going to work with a
15:19 - couple of different variables
15:21 - first of all i create a variable called
15:23 - ready and by default
15:25 - it is going to be true then i want a
15:27 - variable
15:28 - called self dot laser
15:31 - time which is going to tell us when we
15:33 - have shot the laser and by default this
15:35 - is zero
15:36 - then i want self.laser cool down
15:40 - and this is going to be 600 so we will
15:43 - be able to shoot a laser every 600
15:45 - milliseconds
15:46 - and we will only be able to shoot a
15:48 - laser if we are pressing space
15:50 - and if self.ready and
15:54 - every time we have shorter laser
15:56 - self.ready
15:58 - is going to be false so if i just have
16:01 - this setup
16:02 - we should be able to shoot at least once
16:04 - but not multiple times
16:06 - and now if i keep on pressing space we
16:08 - can't see anything
16:09 - but we have shot our laser once so this
16:12 - is
16:12 - working at least for now but we do want
16:15 - to wait to set ready back to true again
16:17 - and for that we have to add a little bit
16:19 - more here first of all
16:21 - i want self.laser time
16:24 - is equal to pygm.time.getticks
16:29 - so we are measuring the time since our
16:30 - game has started
16:32 - and now let me put it right below
16:36 - we need another method that i have
16:38 - called recharge
16:40 - it does not need any arguments besides
16:42 - self
16:43 - and in here we are first going to check
16:45 - if not
16:46 - self read d so if we have to recharge
16:49 - the laser
16:51 - if that is the case we want to check our
16:53 - current time
16:54 - and for that we need
16:56 - pygame.time.getticks
16:58 - the very same line we have used up here
17:00 - the only difference here
17:02 - is that this get ticks is only used
17:06 - once so we're getting one point in time
17:09 - whereas this get ticks here is being run
17:12 - continuously
17:14 - so we get multiple times and that
17:16 - difference
17:17 - is very important because we can use
17:20 - that very well
17:21 - and what we want to do is to check if
17:24 - our
17:24 - current time minus self.laser time
17:28 - is greater or equal than our self.laser
17:32 - cooldown and let me visualize this on a
17:35 - timeline
17:36 - so here we have the entire time of our
17:39 - game
17:39 - and let me use a different color for
17:41 - this that let's say
17:43 - on this point here we have our laser
17:46 - being shot
17:47 - and let's say hypothetically this is at
17:49 - 1
17:50 - 000. so this is our current time
17:53 - let's say at this point here we are
17:56 - going to be at 1
17:58 - 100 at this point here we are at 1
18:02 - 400 and then at some point here
18:05 - we are going to be at 1 600.
18:10 - and really all we are going to do is we
18:12 - are checking
18:13 - this time and subtracting our starting
18:16 - time from that
18:17 - and in this case this would be a hundred
18:21 - if we use this case here this would be
18:24 - 400
18:25 - however if we get to this case here this
18:27 - would be
18:28 - 600 and as a consequence
18:31 - this if statement down here
18:34 - would trigger and that way we have a
18:37 - timer so
18:38 - if this timer triggers we want to set
18:40 - self.ready
18:41 - back to true and now
18:44 - obviously what we have to do we have to
18:46 - call self.recharge
18:50 - and that should be all we need for the
18:53 - timer so now let me keep on pressing
18:56 - space
18:57 - and you can see that we only get the
18:59 - laser
19:00 - ever so often so this is working really
19:02 - well
19:03 - and with that we pretty much have
19:07 - most of the player class ready there is
19:10 - very little we actually have to add
19:11 - to this the most important thing and let
19:14 - me minimize everything else
19:16 - is that we have to be able to create a
19:18 - laser and right now that doesn't exist
19:21 - so let's start working on the laser and
19:23 - the laser is going to be incredibly
19:25 - simple
19:26 - because at the end of the day it is
19:28 - literally just a sprite class
19:30 - with a position and a speed and really
19:33 - what we are going to do
19:34 - whenever the player presses space we are
19:36 - going to spawn a laser sprite in the
19:38 - position
19:39 - of the player and move it upwards and
19:41 - then later on we are going to use the
19:43 - same laser class
19:44 - to spawn it in the position of an alien
19:46 - whenever they shoot
19:47 - and then move it downwards but that's
19:50 - really all it does
19:51 - it's essentially a sprite class with
19:53 - position and a speed
19:54 - and well that's it so let's jump back
19:57 - into our code
19:58 - and let's create it here i'm back in my
20:01 - code i have main and player
20:03 - and i want to create a new class that
20:05 - i'm going to save
20:06 - as laser dot pi
20:09 - and here again we have to import pygame
20:13 - and again i want to create a class that
20:15 - i call
20:16 - laser and this one again has to inherit
20:18 - from pygame.sprite.sprite
20:22 - and here as always we need our init
20:25 - method needs self
20:27 - for now and we need super
20:30 - and then under init again and now first
20:34 - of all
20:34 - we are going to need self.image and
20:36 - self.direct
20:37 - as always and here we don't even have a
20:40 - graphics
20:41 - instead i just create pygame.surface so
20:44 - an empty surface and this i have set to
20:47 - width of 4
20:48 - and a height of 20. and then for
20:51 - pygame.rect
20:52 - we get our self.image.getrekt
20:57 - and in here i set the center to a
20:59 - specific position
21:01 - and this position again i am going to
21:04 - get
21:04 - when we initiate the class and there's
21:07 - one more thing i would like to add
21:09 - and that is the image needs to be filled
21:12 - because right now it's black which
21:14 - wouldn't look particularly good
21:16 - and i just want to fill it with white
21:18 - and that again
21:19 - is a very simple setup for our laser so
21:22 - now i can save this file
21:23 - and go back to my player and now i want
21:26 - to import
21:27 - from laser import laser
21:31 - and now every time this laser shoot is
21:34 - being run
21:34 - i want to create one instance of this
21:37 - laser class
21:38 - and for that first of all i am going to
21:40 - need a sprite class
21:42 - so in the init method self.lasers
21:45 - and this is going to be
21:47 - pygame.sprite.group
21:49 - and now every time we are running shoot
21:52 - laser
21:53 - i want to get myself.lasers
21:56 - and add laser
22:00 - and now this is going to need a position
22:02 - and this position
22:04 - i can get from self.direct.center
22:08 - so literally all that's going to happen
22:10 - is every time we are shooting a laser
22:12 - we are creating a new sprite and the
22:13 - position of our player
22:15 - so now i can save the code and i can run
22:17 - the entire game
22:18 - and now if i press space nothing is
22:20 - going to happen
22:21 - for the simple reason that we are not
22:23 - drawing any of these lasers
22:26 - and that i would like to do in this
22:29 - run method because that gives me the
22:31 - most control over where stuff is being
22:32 - drawn
22:34 - and well all i want to do is self dot
22:37 - player
22:38 - dot sprite dot lasers
22:42 - dot draw and this has to be on screen
22:46 - and let me put it below the update
22:48 - method so we are separating updating and
22:49 - drawing
22:50 - and now we should be able to see the
22:52 - lasers so let me run off this again
22:55 - now i press space and now we can see a
22:57 - laser being spawned
22:59 - now obviously right now they're not
23:01 - moving upwards so that's what we have to
23:02 - work on next
23:04 - but we do have a start and this could
23:07 - actually be a
23:08 - really good exercise for you that i want
23:10 - you guys to add
23:11 - a little bit of code to move the lasers
23:13 - upwards
23:14 - so try to figure this out yourself
23:21 - alrighty let's try together
23:24 - so back in my laser class i want to set
23:27 - a speed and then this
23:30 - is going to be self.speed is equal to
23:33 - speed and now this laser
23:36 - is going to get an update method
23:39 - that we are going to get self.direct.y
23:43 - minus equal self.speed
23:46 - and really all we're doing here we are
23:48 - moving the rectangle upwards by a
23:50 - certain speed
23:52 - and since most of our lasers are going
23:54 - to move
23:55 - upwards we can add a default argument in
23:57 - here
23:58 - let's put it to negative 8 that i think
24:01 - looked good
24:03 - and now in our player class what we have
24:06 - to do
24:07 - is to update this laser so self dot
24:10 - lasers dot
24:13 - up date and now when we create our laser
24:17 - here
24:18 - we could add another argument but
24:22 - since we have a default argument we
24:23 - don't necessarily have to
24:26 - but by itself this should already work
24:28 - so let's try now if i press space
24:34 - nothing is working and that
24:37 - is because this has to be plus equals
24:39 - self.speed
24:40 - because right now we had negative 8 and
24:43 - we subtracted negative 8
24:44 - so it became positive so our laser moved
24:46 - downwards
24:47 - but now if we have this for positive
24:50 - let's try this again
24:51 - now we have a laser that is already
24:53 - working really well
24:57 - so this is going quite well nice
25:01 - but there's one more thing that i do
25:03 - have to add here
25:05 - that right now these lasers never
25:07 - disappear
25:09 - so we have to destroy them once they
25:11 - leave the screen
25:12 - and let's call it destroy and
25:15 - all we want to check is if self.rect.y
25:20 - is either smaller or equal to negative
25:23 - 50 let's say
25:25 - or if self.rect.y
25:28 - is greater or equal to the height
25:31 - of the window so this would be
25:34 - 650. however i want the game to be
25:37 - flexible so we can make it larger
25:39 - so we need to get this number and this
25:42 - has to be
25:43 - another argument so screen
25:48 - height so
25:51 - self thought let's call it height y
25:54 - constrained and this is going to be
25:57 - screen
25:58 - height and then in here self dot
26:02 - height y constraint and let's add 50
26:04 - just to have a little bit of wiggle room
26:07 - and if that is the case we have to run
26:10 - self.kill
26:11 - to destroy the sprite entirely and
26:14 - don't forget to actually call the
26:16 - function so self.destroy in our update
26:18 - method
26:19 - and now when we create a laser we have
26:22 - to add this argument as well
26:24 - so and here when we create our laser
26:27 - let's say now i want to go with negative
26:29 - 8 for the speed
26:31 - and in here we do have a minor problem
26:34 - now for the y constraint
26:35 - because we didn't actually pass that in
26:38 - we only have the x position
26:40 - however what we do have is the bottom of
26:42 - the player
26:43 - so this self.rectangle we just want to
26:45 - get the bottom
26:46 - so self.rect.bottom
26:50 - and this is actually a fairly realistic
26:52 - way that whenever the laser is below our
26:54 - player we want to destroy it which i
26:56 - think does start to make sense
26:59 - and well that should be it let's try to
27:01 - run the game now
27:03 - and oh well we have a non-default
27:05 - argument follows a default argument
27:07 - so let's get rid of this
27:11 - negative eight
27:14 - and now it works our laser still works
27:17 - you can't
27:18 - really see the laser disappearing
27:21 - but now our game should not spawn
27:24 - infinite lasers
27:25 - so this is going to help our game be
27:27 - slightly more efficient
27:28 - and with that we have both our player
27:30 - and our laser
27:32 - and that's literally all we have to do
27:33 - for both of these
27:35 - later on we are going to do a bit with
27:37 - collision but that happens inside of our
27:39 - main class not inside the player or the
27:41 - laser
27:42 - and that means we already finished a
27:43 - major part of this game
27:45 - now with that covered we have two topics
27:48 - to address
27:50 - one is the placement of the aliens and
27:52 - number two is the placement of the
27:53 - obstacles
27:54 - and they are independent of each other
27:56 - so it really doesn't matter which one we
27:58 - are going to start with
27:59 - and both of these are done in very
28:01 - similar ways so if you understand one
28:03 - you probably are going to understand the
28:05 - other fairly easily
28:06 - and let's start with the obstacle i
28:08 - think that is going to be the easier one
28:10 - and let me first explain how the
28:12 - obstacle is going to work
28:14 - and here you can see one of the
28:15 - obstacles on the screen
28:17 - and it looks like this is one solid
28:19 - figure
28:20 - but that actually isn't the case instead
28:23 - this obstacle consists of individual
28:25 - blocks and each of these blocks is a
28:27 - sprite
28:28 - and really all i have done is i have
28:30 - arranged all of the sprites in such a
28:32 - way that they look like the obstacle
28:34 - but that is literally it all that you
28:36 - are looking at is a couple of square
28:37 - shaped sprites
28:38 - in a certain shape so we have to figure
28:42 - out how to create this kind of shape
28:44 - and for that we are going to need a
28:46 - nested for loop with the enumerate
28:48 - method so let me explain how this is
28:50 - going to work
28:52 - and here is how this would look like in
28:54 - code at least in a more generalized way
28:56 - essentially what we are going to have is
28:59 - a list with strings inside
29:01 - and each string is going to be one row
29:03 - of our obstacle
29:04 - and this would be our first for loop and
29:07 - here we use the enumerate method to
29:09 - figure out on which row we are on
29:11 - and then a nested for loop is going to
29:13 - look at each individual column inside of
29:15 - this
29:15 - row and again we are going to use the
29:18 - enumerate method to figure out on what
29:20 - column we are on
29:21 - and if you combine these two enumerate
29:23 - methods you get a grid with specific
29:25 - positions
29:26 - so for example the top left would be
29:28 - zero and zero and to the right of that
29:30 - we would have one
29:31 - and zero and to the bottom of that we
29:33 - would have zero and one
29:35 - and this we can then use to place
29:37 - elements on the screen
29:38 - and we can even make this more flexible
29:40 - by adding offsets for example to move
29:42 - all of the shapes in a certain direction
29:44 - but that's literally
29:45 - it it really isn't all that hard when it
29:47 - comes down to it
29:49 - but alright that again was a lot of talk
29:52 - so
29:52 - let me actually implement and let's
29:54 - create one obstacle and once we have
29:56 - that we can create multiple
29:58 - and here we are back in the code and the
30:00 - first thing i want to do is to create a
30:02 - new file
30:03 - and i want to save this one as obstacle
30:06 - dot
30:06 - pi and here again we need to import
30:09 - pi game and in here i want to create a
30:13 - class that i call
30:14 - block and this one again is going to be
30:16 - a sprite so we need pygame dot sprite
30:18 - dot sprite
30:20 - now we need the usual init method with
30:22 - self and nothing else
30:24 - and then we need super down there
30:27 - in it for this one as well so everything
30:29 - works well
30:30 - and now we have to create self.image and
30:34 - self.rect
30:36 - and for the image literally all i want
30:38 - to get is a surface
30:41 - and now we have to figure out the size
30:42 - of the surface and
30:44 - i want to set this from our main class
30:46 - so what i'm going to do
30:48 - is when i am creating this class i'm
30:51 - going to set a size
30:52 - and since we want squares the size for x
30:55 - and y is going to be the same
30:57 - so we put size in both of those
31:01 - so with that we have our surface now
31:04 - next up before we get to the rectangle
31:06 - i want to fill the rectangle with a
31:08 - color
31:09 - and this color i also want to set from
31:11 - the main class
31:12 - so i'm going to place this also as an
31:14 - argument
31:15 - or parameter and then finally
31:18 - direct itself.image.getrekt
31:23 - and here i want to place the top left
31:27 - and the position i do not know yet so
31:30 - this is just going to be
31:31 - x and y and usually
31:34 - for this position here i use a tuple so
31:37 - for most other classes i just write
31:39 - pause but in this case i want to have
31:42 - specific control of
31:43 - x and y which is why i'm going to
31:45 - separate them by each variable
31:47 - you're going to see in a second why that
31:48 - is helpful but well that's just going to
31:51 - be another parameter for x and y
31:54 - and that is literally all that we needed
31:56 - so this is going to be
31:57 - one part of our obstacle now there's one
32:00 - more thing we need outside of the class
32:03 - and that is the actual shape and this is
32:05 - going to be a list with strings
32:08 - and in my case let me just paste it in
32:11 - it looks something like this so let me
32:14 - explain how this shape is going to work
32:16 - in here we have lots of strings and
32:18 - there's two options
32:19 - we either have an x so for example this
32:22 - one or we have a space
32:23 - so let me use a different color that
32:25 - here
32:27 - you can see a space all we are going to
32:29 - do at the end of the day
32:31 - is wherever we have an x we are going to
32:33 - create
32:34 - a block so for example this x here is
32:36 - going to be a block
32:38 - this x here is going to be a block all
32:40 - of these x's are going to be a block
32:42 - and if there's a space so like this area
32:45 - here there's not going to be a block
32:47 - and that way we're going to recreate
32:48 - this shape as sprites
32:51 - and for that we are going to use the
32:52 - function i explained earlier
32:54 - but this is literally all we needed from
32:56 - our class
32:57 - so now i can save it and go back to my
32:59 - main file
33:01 - and first of all i have to import my
33:04 - obstacle file and now
33:07 - before we get into an actual method to
33:09 - create all of this we have to create a
33:10 - couple of basic variables
33:12 - and let me actually add a couple more
33:14 - comments to be a bit more specific
33:16 - so let's call this one player setup and
33:19 - below that we have the obstacle
33:22 - set up i should really use comments more
33:26 - regularly but alright
33:28 - the first thing i want to do is to
33:29 - capture the shape of our obstacle
33:31 - so self.shape and this is going to be
33:34 - obstacle
33:35 - dot shape so literally
33:38 - this thing here and that is just to make
33:41 - it a bit easier to work with inside of
33:43 - the game class
33:44 - now next up i want to set myself dot
33:47 - block size
33:51 - and i set this to a six so this is the
33:54 - number we are going to pass
33:56 - in here later on and finally
33:59 - we want to have a group that collects
34:00 - all of these sprites we are going to
34:02 - create in just a bit
34:03 - and i've got this one blocks and for now
34:06 - this is just going to be
34:08 - pygame.sprite.group
34:09 - with nothing inside and that is all we
34:12 - need for basic variables
34:14 - now we have to create a function that
34:16 - creates one obstacle
34:18 - and well let's call it create obstacle
34:21 - and for now we are not going to pass any
34:23 - arguments inside of this
34:25 - but we are going to pass some in just a
34:27 - bit
34:28 - and now we have to use the function i
34:30 - talked about earlier
34:31 - so what we want to do is we want to loop
34:34 - over
34:35 - this shape here so let's start with for
34:37 - row
34:38 - in self dot shape and
34:41 - each row in here would be one of these
34:44 - rows
34:45 - now the problem with just using
34:48 - self.shape is we wouldn't know
34:49 - on what row we are on and to get that
34:52 - information
34:53 - i want to get the enumerate method and
34:56 - what this one does
34:57 - is it returns an integer on what index
34:59 - we are on
35:00 - so for example this would be the index 0
35:03 - this would be the index 1 the index 2
35:05 - the index 3
35:06 - and so on and this is the information we
35:09 - are going to use
35:10 - to set a certain information for our
35:12 - height orbital for our row
35:14 - so once we have that we know on what row
35:17 - we are on
35:18 - now next up we have to figure out on
35:21 - what column we are on
35:22 - and well for that i'm going to approach
35:24 - this in a very similar way
35:26 - so we have call index and call in
35:29 - enumerate and this is just going to be
35:32 - row
35:33 - so let me explain again what we are
35:34 - going to do
35:37 - so let's say we are currently on the
35:39 - first row so
35:40 - we are in here now each of those items
35:44 - is going to get one index so this would
35:47 - be zero
35:48 - this would be one then this one here
35:51 - would be two
35:52 - and then this one here would be three
35:54 - and by using these enumerate methods we
35:56 - get the specific positions
35:58 - of each of these x's for example this
36:01 - x here would have the index 0 and
36:04 - 0 whereas this index here
36:08 - would have the index of 0 and 2 i think
36:12 - and this is the information we need to
36:14 - place something on the screen
36:15 - and all right this is all we need to
36:18 - find the position
36:19 - now obviously what we want to do is an
36:21 - if statement so
36:22 - if the column is equal to the letter x
36:26 - because we want to ignore all the empty
36:28 - spaces and well
36:30 - now we have to figure out the x and the
36:33 - y position
36:35 - and once we have that we can create one
36:37 - block
36:38 - that is going to be obstacle dot block
36:42 - and now in here we have to add a couple
36:44 - of arguments
36:46 - so let me copy them really quick so we
36:48 - can
36:49 - work through them one by one and the
36:51 - size we already have
36:52 - it's literally just this one up here so
36:55 - this one is the easiest one to get
36:57 - we just want to get self dot
37:00 - block size next up the color
37:04 - is also very easy because i have a tuple
37:07 - that i want to use here
37:09 - and the tuple i want to use is this one
37:11 - so this one is pretty fine
37:13 - and this is a reddish color that i think
37:15 - looks quite good
37:16 - now finally we need our x and y
37:19 - coordinates
37:20 - and those we are going to create now and
37:22 - this could actually be a really good
37:23 - exercise for you
37:25 - try to figure out what we have to do for
37:27 - x and y to place each block in the right
37:29 - position
37:35 - so for x we obviously have to look at
37:37 - our columns
37:38 - so this part here and the first we need
37:40 - is to get our call
37:42 - index so this will give us a number from
37:45 - 0
37:45 - 1 2 3 4 and i think the maximum column
37:49 - we have is 11
37:50 - so the highest number here will be a 10
37:52 - and the lowest is 0.
37:54 - and this would then be a start however
37:56 - we don't just want to move the x by 1
37:58 - pixel we want to move it by the size of
38:00 - each block
38:01 - so each block starts after the previous
38:03 - block has ended
38:04 - and well for that all we need is to
38:06 - multiply the index by self
38:08 - dot block size and well that's literally
38:12 - all we need to get this thing started
38:14 - now for y
38:15 - we are going to do basically the same
38:17 - except now we use the row index
38:19 - but we're still going to multiply by
38:20 - self.block size
38:22 - and well with that we have our basic
38:24 - block now the final thing we have to do
38:26 - in here
38:27 - is to get our self.blocks and
38:30 - add the block we have made to it
38:33 - and that is already going to be a really
38:36 - good start
38:37 - now what i want to do is when we
38:39 - initiate the class
38:40 - i just want to run self.create obstacle
38:44 - and then in our game method i want
38:47 - to get myself dot blocks and
38:50 - draw all of them on the screen and
38:54 - let's just see what happens and there
38:57 - you can see in the top
38:58 - left we have our first obstacle so this
39:01 - is actually already working
39:03 - now obviously the obstacle isn't
39:05 - supposed to be in the top left
39:06 - so that's something we do have to work
39:08 - on but well it's a good start
39:10 - so what we have to work on now is to
39:13 - offset
39:14 - all of this to place all of them a bit
39:16 - further down
39:17 - and well that isn't all that difficult
39:19 - because literally
39:20 - all i want to do is to set an x start
39:24 - variable
39:24 - and a y start variable and then
39:28 - every time we are placing either the x
39:30 - or the y we want to add this number
39:32 - towards them
39:32 - so x start plus all of this or
39:37 - y start plus all of this
39:40 - and now when we create our obstacle we
39:43 - can pass a number in here
39:45 - let's say for x we can start with 40 and
39:48 - for y
39:48 - i think i went with 480. and now let's
39:51 - try this
39:54 - and we are getting an error because i
39:56 - made a typo
39:58 - there we go this is looking much better
40:00 - so now we have one obstacle
40:02 - doesn't do anything yet but that we're
40:04 - going to cover later on
40:06 - but this is going to be our first
40:07 - obstacle so alrighty with that we have
40:10 - our first one
40:12 - and now what you could be doing is to
40:13 - run this function four times
40:15 - and figure out the positions by yourself
40:17 - and that would be an approach but
40:19 - not an approach i would like because
40:21 - that seems like a lot of writing
40:23 - instead what i have done is i created
40:26 - another function
40:27 - and this i have called create multiple
40:32 - obstacles and first of all here we are
40:35 - going to need
40:35 - self then besides that i want to pass in
40:38 - the x start
40:40 - and this would be the same x start we
40:42 - have used here i just want to be able to
40:43 - call it from this function
40:45 - because literally what we are going to
40:47 - do is i'm going to call this function
40:49 - only inside of this method here i am not
40:52 - going to call it
40:53 - inside of the init method directly and i
40:56 - also want to do the same
40:57 - for y start and next up
41:00 - i have to get some kind of offset so i
41:03 - have to know what the distance between
41:04 - each of the obstacles is going to be and
41:07 - in my case
41:08 - i don't actually know how many obstacles
41:10 - i am going to have
41:11 - so i want to use a parameter that i can
41:13 - later use to add as many arguments as i
41:15 - want
41:16 - and this is going to look like this i
41:19 - use a star
41:20 - and then offset and that's called
41:22 - another packing operator
41:24 - and that's going to be super useful and
41:27 - now what i want to do in this function
41:28 - is for x in offset so all the arguments
41:32 - we are going to pass in here
41:33 - we are going to loop over and then in
41:36 - here
41:36 - we are going to run self dot create
41:39 - obstacle
41:40 - and now we have to pass in a couple of
41:42 - arguments
41:43 - the first two are the easy ones because
41:45 - we already have our size and our color
41:48 - so for now we have to figure out these
41:50 - two
41:51 - arguments to pass in here
41:54 - and well they're not that hard because
41:57 - we already have
41:58 - x start and we have y start
42:01 - but now there's one more thing we have
42:02 - to do that we have to get the offset
42:05 - in here as well so what i want to do is
42:08 - to add my x variable in here as well so
42:10 - the one
42:10 - we have just looped over but for that to
42:12 - work we have to add
42:14 - another argument in here and that i
42:16 - called off
42:17 - set x and actually let me
42:21 - name things properly so instead of for x
42:24 - is offset x and then we place all of
42:26 - this in here so this should make this a
42:27 - bit easier to read
42:29 - and with that we have the two functions
42:31 - we need to make all of this work
42:33 - so now inside of my init class i want to
42:36 - create
42:37 - multiple obstacles and again let me copy
42:40 - the parameters we need
42:41 - to work through this one by one first of
42:43 - all we will need the x start
42:45 - and let me just place a zero in here so
42:47 - we start the left side of the screen
42:49 - for y start i just want to go with 480
42:53 - because i think that number worked quite
42:54 - well
42:55 - and now for the offset for now
42:59 - let me just place in a couple of random
43:01 - numbers so let's
43:02 - start with 0 then 100 and then 200
43:06 - and there's one thing i did forget and
43:08 - that is
43:09 - this line here that i want to
43:12 - add my offset
43:16 - x and let me quickly go through this
43:19 - line because that is the really
43:21 - important one
43:22 - so essentially what happens in here is
43:24 - this line is the really
43:26 - important bit because this is what we
43:28 - are going to use to check
43:29 - what position we are on inside of our
43:31 - shape
43:32 - and then we are going to offset this
43:34 - position twice
43:36 - first of all we are going to get a start
43:38 - position
43:39 - so this is going to be how far we are
43:41 - from the left
43:42 - and then plus that we are going to
43:45 - create
43:45 - another offset and this ensures that if
43:48 - we have multiple obstacles they're not
43:50 - all on the same position
43:51 - because if we didn't include this line
43:53 - here they would all be on the same
43:55 - position
43:56 - but we want to use this information here
43:59 - to offset
44:00 - each obstacle so the first one is going
44:02 - to start at 0
44:04 - but then the second one is going to be
44:05 - 100 pixels further to the right and the
44:08 - next one
44:08 - is going to be 200 pixels further to the
44:10 - right and that way we can get all of our
44:13 - obstacles
44:14 - so let's try this and we are getting an
44:16 - error message because i made a silly
44:18 - mistake
44:19 - that this here should not be
44:22 - in a tuple it should just be numbers by
44:24 - themselves
44:25 - because this offset already places them
44:27 - in a tuple
44:28 - so now let's try this again and now we
44:31 - can see all of our obstacles
44:32 - obviously not in the right position and
44:34 - we are missing one but we can work on
44:36 - that
44:37 - and i think right now this line here
44:40 - is very difficult to read so instead i
44:43 - want to use named arguments in here
44:45 - but we can't use positional arguments
44:48 - after named arguments
44:50 - so i want to move this x start and y
44:52 - start
44:53 - after the offset so i also want to move
44:57 - those two to the end
45:01 - and now i can call them x start
45:05 - and i can call them y start
45:09 - and all the stuff with in the beginning
45:11 - is just going to be the offset
45:14 - and let's try this again and it's still
45:16 - working just fine
45:18 - so now what we do have to figure out
45:21 - is how to space our obstacles in the
45:24 - right amount
45:25 - and this again i want to be flexible so
45:27 - we can make the screen larger or smaller
45:29 - and it shouldn't really matter
45:30 - and i also want to have flexibility over
45:32 - how many obstacles i am going to have
45:34 - so i'm going to add another attribute
45:37 - that i called
45:38 - obstacle amount and i just went with
45:42 - four
45:43 - and now with that information i'm going
45:45 - to create another attribute
45:47 - that i have called obstacle x
45:51 - positions and now we have to figure out
45:54 - how to get these positions here that
45:57 - space out the entire screen
45:59 - and let's start building this thing up
46:00 - step by step
46:02 - so first of all i want to get num for
46:05 - num
46:06 - in range and this is going to be self
46:09 - dot obstacle amount so for now we would
46:12 - get a list of the numbers 0
46:14 - 1 2 and 3 because our highest number is
46:16 - 4 and we're just looping over it
46:18 - and well all we have to do now with that
46:21 - is to multiply
46:22 - that number with our screen width
46:25 - divided by self dot obstacle
46:29 - amount and that is a slightly longer
46:31 - line now
46:32 - but let me go over what's going to
46:34 - happen here we're going to start with
46:36 - this number
46:37 - and this number is either going to be 0
46:39 - 1
46:40 - 2 or three and for the sake of an
46:43 - example
46:44 - let's assume that this number here is
46:46 - two
46:47 - then we're going to multiply all of this
46:50 - with screen width divided by obstacle
46:51 - amount
46:52 - and screen width in our case is going to
46:54 - be 600
46:57 - and obstacle amount is going to be four
47:00 - and if we divide one by the other
47:02 - we get a hundred and fifty and if you
47:05 - multiply this by two
47:07 - we get the position of 300
47:11 - which is exactly in the middle of the
47:13 - screen and then let me use a different
47:14 - color
47:15 - if we had three in there we would also
47:17 - multiply this by 150
47:19 - and we would get 450
47:22 - so a nice offset to the right and well
47:25 - with that
47:26 - we can just pass in self dot obstacle
47:29 - x positions in here however right now
47:32 - this would not be working
47:33 - because this is going to be a list and
47:36 - we just have to pass in individual
47:38 - numbers
47:39 - so what i have to use again is the
47:41 - unpacking operator
47:43 - so this star here means that we're going
47:46 - to unpack
47:46 - this list straight away and well
47:49 - let's try this and now we are getting
47:52 - much better
47:53 - so now we have all of our obstacles
47:55 - nicely spaced out
47:57 - so now the final problem is that we have
47:58 - no offset on the left
48:00 - and well for that we have our x start
48:04 - not this one we have this x start
48:07 - or this one here that is zero for now
48:10 - and for this one
48:11 - i gotta be honest i was a little bit
48:13 - lazy because
48:14 - all i did i went with screen with
48:17 - divided by 15 and if you run this
48:21 - it kind of looks okay i'm not sure if
48:23 - the math is entirely correct
48:25 - you would have to look at it in a bit
48:26 - more detail but i think this looks good
48:28 - enough
48:29 - but this probably isn't pixel perfect
48:31 - but i think this works just fine so
48:34 - with that we have our obstacles and now
48:37 - we can use that knowledge to place all
48:39 - of our aliens and this is also going to
48:41 - happen with a nested for loop that uses
48:43 - the enumerate method
48:45 - i'll buy in a slightly different way but
48:48 - the broad strokes are essentially the
48:50 - same
48:51 - and well there's not much point
48:52 - explaining all of this in too much
48:53 - detail
48:54 - let's implement it straight away so here
48:57 - i
48:57 - am back in the code and the first thing
48:59 - i want to do is to create a new file
49:01 - that i am going to save as alien dot
49:04 - pi and in here again i want to import
49:08 - pi game and create a new class that i
49:10 - have called alien
49:11 - this one again is going to be a sprite
49:14 - so we have to do the inheritance thing
49:16 - we need a niche with a space in between
49:20 - it needs self for now and then we need
49:24 - super and under
49:28 - init all right and again
49:31 - we need an image and we need a rectangle
49:35 - and in here each image is going to be a
49:37 - graphic we are going to import
49:39 - so what we first have to figure out is a
49:41 - file path
49:43 - so let's just call it file path and
49:46 - here's what i did whenever we create an
49:49 - alien
49:49 - we have to specify a color so this could
49:51 - be red yellow or green
49:53 - and then in the folder i have named each
49:55 - file either red green or yellow
49:58 - and what that allows us to do so i go up
50:00 - a folder
50:01 - and then i go to graphics and then
50:04 - i am going to add
50:08 - my color to it and then i'm going to add
50:11 - the file
50:12 - ending with dot png
50:15 - so if i were to write the string right
50:17 - in here we would get graphics
50:19 - slash red dot png which is exactly what
50:22 - we need for our file path
50:24 - and that way i don't have to work with
50:26 - different if statements and our code
50:27 - stays nice and clean
50:29 - and now i can use that file path to use
50:31 - pygame
50:32 - dot image dot load add in my file path
50:36 - and then convert alpha
50:40 - the same thing we have seen so many
50:41 - times by now and then for the rectangle
50:44 - i want to get myself dot image dot get
50:48 - wrecked and here again i want to place
50:50 - the top left
50:51 - and this again is going to be x and y so
50:55 - we have to add
50:56 - x and y in here as well and that
50:59 - is going to be our basic alien so
51:02 - this is a pretty good start
51:05 - and all right so with that we can return
51:07 - to our main file
51:09 - and start working with the align and
51:11 - first of all for that we have to import
51:13 - it
51:13 - so from alien import alien
51:17 - and now in the indent method i want to
51:20 - create a couple of basic setup points
51:24 - so let's add a comment with alien setup
51:28 - and in here for now i am only going to
51:30 - need a single thing
51:31 - and that is self.aliens and that is at
51:34 - pygame.sprite
51:37 - so all the aliens are going to be in
51:38 - this group and now with that
51:41 - i want to create a function that is
51:43 - going to create all of these aliens
51:45 - in a specific position and i call this
51:48 - alien set up
51:52 - and now let's create this function
51:56 - so def alien set
52:01 - up and for now we are only going to use
52:03 - self
52:05 - and now let me actually open the create
52:07 - obstacle function as well
52:09 - because we are effectively going to do
52:11 - the same thing we have done here
52:13 - so again i want for row
52:16 - index and row in
52:19 - enumerate and now i want some kind of
52:23 - row
52:23 - or let's call it rows for now and
52:26 - in there for call index
52:30 - and call in enumerate and for this one
52:34 - we want to figure out how many columns
52:35 - we have or calls
52:37 - and now we have to figure out how many
52:39 - rows and how many columns we want to
52:41 - have for our aliens
52:42 - and well that's going to be parameters
52:44 - so let's start with rows
52:46 - and with columns so whenever we call the
52:49 - function we have to specify that
52:51 - information
52:52 - and once we have that we have to again
52:54 - create an x
52:55 - and a y variable and once we have that
52:58 - i want to create an alien sprite
53:01 - that is going to be alien and let me
53:04 - copy the parameters we need
53:06 - so we need color x and y and the color
53:09 - is the easiest part because i have a
53:11 - couple of predefined ones
53:13 - so let's start with red and then we need
53:15 - x and y
53:17 - and once we have that i want to get
53:18 - myself dot aliens
53:21 - and add the alien sprite
53:24 - so now we have most of the stuff we need
53:26 - we just need
53:27 - x and y and this could actually be a
53:30 - really good exercise for you
53:32 - try to work through the logic here and
53:35 - see how you can use this to place the
53:36 - aliens on the screen
53:38 - and most importantly try to think about
53:40 - what bits of information you are going
53:42 - to need to enable all of this
53:49 - let's start with x and in here as always
53:52 - we are going to need our call index
53:55 - and the same for y we need our row index
53:59 - so this would give us numbers in the
54:00 - single digits which
54:02 - is well not great yet actually let me
54:04 - pass in specific numbers
54:06 - and for the rows i went with 6 and for
54:09 - the calls
54:10 - i went with 8. so this means this call
54:13 - index
54:14 - is going to be from 0 to 7
54:18 - and then the row index is going to go
54:20 - from 0 to
54:21 - 5. so let's just see how this would look
54:24 - like right now
54:25 - and all we need to do for that is
54:28 - in our self.run function i also want to
54:30 - get myself.aliens.draw
54:33 - and do this on the screen and now let's
54:35 - run this code
54:37 - and we get an error message because this
54:39 - rows and this column has to be in a
54:41 - range function
54:42 - so let's put this inside of range
54:48 - and now let's try this again so now
54:51 - in the top left you can see a
54:54 - reddish blob and this is not an obstacle
54:56 - this is an
54:57 - alien the reason why it is looking so
54:59 - weird is because we have a couple of
55:01 - aliens on top of each other with an
55:03 - offset
55:04 - so this is what we have to start working
55:06 - on and here
55:07 - it really helps to look at our earlier
55:10 - grade obstacle function
55:12 - because for this one we had essentially
55:14 - four bits of information
55:16 - we had the column index then we had the
55:18 - size of each block
55:20 - we had the starting position and we had
55:22 - the offset
55:25 - so four pieces and right now we only
55:27 - have one
55:28 - we have the column index so we have to
55:31 - add a couple of bits of information here
55:33 - and there are two major things we need
55:35 - the first one
55:36 - is the size
55:40 - and the other part is the offset
55:46 - and we don't really need a start
55:48 - variable because our aliens are going to
55:50 - move on the screen anyway
55:52 - so it doesn't really matter where they
55:53 - are going to start but we definitely
55:55 - need a size and an offset
55:56 - both for x and y so this is what we have
55:59 - to create
56:00 - and essentially what that means is we
56:02 - have to create a few more parameters
56:04 - and the first two we need is x distance
56:07 - and
56:07 - y distance and literally all i want to
56:11 - do
56:11 - is to multiply each side with
56:15 - the distance we need so x distance
56:18 - and y distance and i think it's a good
56:21 - idea to add some default parameters
56:23 - in here so let's say for the x distance
56:26 - by default this should be 60
56:28 - and for the y distance this should be 48
56:31 - and now let's try this again and now
56:34 - this is looking so much better
56:35 - so now we have an actual proper grid and
56:38 - if you had more columns or more rows you
56:40 - could make this more dense or more
56:41 - widespread
56:42 - it's up to you but now the obvious
56:44 - problem is that all of our aliens are
56:46 - starting in the top
56:47 - left so that means we have to give all
56:50 - of this an offset
56:51 - so we are going to need an x offset
56:55 - and we are going to need a y offset
56:59 - and then literally all that we are going
57:00 - to do is to add plus
57:03 - x offset and plus
57:06 - y offset and here again
57:10 - i'm just going to give it some default
57:12 - parameters
57:13 - let's say for x offset we're going to go
57:16 - with 70
57:17 - and for y offset i put in 100
57:21 - and now it stress again and there we go
57:24 - now we have our aliens nicely set up on
57:26 - the screen
57:27 - still don't do anything but that's going
57:29 - to come in a second
57:31 - and with all of the default arguments we
57:34 - can have
57:35 - our alien setup function nice with a
57:37 - couple of rows and columns
57:39 - and we don't end up with a ton of
57:41 - arguments in here
57:43 - so this is working quite well but now we
57:46 - have another problem
57:47 - that right now all of our aliens have
57:49 - the same color
57:50 - so that's not exactly what i want and
57:53 - instead for different rows
57:54 - i want to have different colors for each
57:57 - alien
57:58 - and for that we are going to need a
58:00 - couple of if statements
58:02 - and here again the enumerate method is
58:04 - going to help us
58:05 - enormously because this is going to tell
58:07 - us what row we are on
58:09 - for example if we are on row 0 this one
58:11 - is going to tell us we are on row 0. so
58:14 - this is super helpful
58:15 - and this is what i need in my if
58:16 - statement so if
58:18 - row index is equal to zero
58:21 - so we're on the top row and if that is
58:24 - the case
58:25 - i want my alien sprite to be
58:29 - yellow now if that is not the case
58:33 - and my row index is between
58:36 - one and two
58:40 - then i want to create an alien sprite
58:44 - that is an alien with the color
58:48 - green and we again are going to need
58:51 - x and y those stay the same and now for
58:54 - all the other rows
58:55 - so else i want to create an
58:58 - alien sprite that is going to be
59:01 - alien with the color red and again with
59:05 - x and y
59:06 - and now let's try this and there we go
59:09 - now we have nice colors and let's go
59:12 - through what actually happens here
59:13 - and the really important line is this
59:16 - one here
59:17 - because this one is telling what row we
59:19 - are on so this row here would have the
59:21 - index 0
59:22 - this row would have the index 1 then 2
59:25 - and 3
59:26 - 4 and 5. and this is the information we
59:30 - are using
59:31 - down here that if we are on row zero so
59:34 - this one here then we want to create a
59:37 - yellow alien
59:39 - however if we are between one and two
59:42 - we are on those two so we want the green
59:45 - alien
59:46 - and then for any other case so three
59:48 - four and five
59:49 - we have the else statement so we create
59:51 - a red alien
59:53 - and well with that logic we have all of
59:55 - our aliens so this is working
59:57 - really nicely and with that we have our
60:00 - basic alien setup so now we can close
60:03 - this method
60:03 - and not worry about it ever again but
60:06 - now the problem is that our aliens are
60:08 - static
60:09 - so that's not particularly helpful and
60:11 - to move them
60:12 - we have to go back to our alien file and
60:14 - in here i want to specify
60:16 - an update method and this one itself
60:19 - and it will also need a direction and
60:23 - really what i want to do in here
60:24 - is self.direct.x plus equal direction
60:30 - and now we can use this function to
60:32 - update all of the aliens
60:33 - so if i go back to my main function i
60:36 - can let's add all of the update methods
60:39 - right at the beginning
60:40 - so self dot aliens
60:44 - and now here we have to specify how fast
60:47 - our aliens are going to go
60:49 - and this i think should be an attribute
60:52 - of the game class
60:53 - so let's call itself.alien direction
60:57 - and this we are going to create in our
60:59 - init method
61:00 - let's place it here self dot alien
61:04 - direction and by default it's going to
61:06 - be one
61:08 - and now let's run this and now we have
61:11 - all of our aliens moving to the right
61:13 - obviously they don't stop but that's
61:15 - fine
61:16 - so now what we have to figure out is if
61:19 - any of the aliens is on the right of the
61:21 - screen
61:21 - we want to change this number to
61:23 - negative one so all the aliens are
61:25 - moving to the left instead of the right
61:27 - and this is going to be another function
61:30 - over method
61:32 - and this i called alien position
61:35 - checker and here's the logic that's
61:38 - going to make all of this work
61:40 - essentially we're going to cycle through
61:42 - every single alien
61:43 - and if any of the aliens is too far to
61:46 - the right
61:47 - we are going to change the direction of
61:48 - all of the aliens and then the same if
61:51 - any of the aliens is too far to the left
61:53 - or smaller than zero then we are also
61:55 - going to change the direction again
61:57 - so first of all we have to get all
61:59 - aliens
62:01 - and this is going to be self dot aliens
62:04 - dot sprites and don't forget the
62:06 - brackets here they are really important
62:08 - we are calling a method
62:10 - and now we can look for alien in
62:14 - all aliens so this way we can look at
62:18 - all the sprites individually
62:20 - and this could be a really good exercise
62:21 - for you that inside of this for loop
62:24 - you can access direct of each alien so
62:27 - use that in an if statement to change
62:29 - the direction if any of the aliens goes
62:31 - outside of the screen either left or
62:33 - right
62:38 - let's start with the right side so if
62:41 - any of the alien
62:42 - dot rekt dot right so the right side of
62:45 - all the aliens
62:47 - if any of those is greater than the
62:49 - screen
62:50 - width and now inside of this function
62:54 - all i want to do is to get myself dot
62:57 - alien direction and set this to negative
63:00 - one
63:01 - and well this should now be working so
63:04 - in our run function
63:05 - we can call self.alienpositionchecker
63:09 - and don't forget to call it and now
63:12 - let's run this
63:13 - and there we go this is working
63:15 - obviously we don't have a left side
63:17 - so there they keep on going forever but
63:19 - this we can work on now
63:20 - because all we need is an l if statement
63:23 - that checks if
63:25 - alien.rect.left is smaller
63:28 - or equal to zero and if that is the case
63:33 - myself.alien.direction is going to be
63:35 - one
63:36 - and now aliens go left
63:40 - they go right and all of this is working
63:43 - super well
63:44 - cool so with that we have our left and
63:46 - right movement
63:47 - but this is only part of the movement
63:50 - because what i also want to achieve
63:52 - is any time our aliens hit either the
63:54 - left or the right side
63:55 - i want to move them downwards by a
63:57 - couple of pixels
63:59 - and that is going to be another method
64:01 - and i have called this one
64:03 - alien move down and in here
64:07 - i want to move for alien in
64:10 - self self.aliens.sprites
64:14 - so kind of like what i've done up here i
64:16 - just check all of the sprites
64:18 - and literally all i want to do is to get
64:21 - my alien
64:23 - and get direct and y so the y position
64:26 - and just that plus equal a certain
64:28 - distance
64:29 - and this distance i'm going to specify
64:31 - every time i run this method
64:33 - and there's one thing i would like to
64:36 - add in here
64:37 - and that is i want to add all of this
64:40 - inside of an if statement
64:42 - and the if statement is going to be if
64:44 - self dot aliens
64:47 - so this is only going to be run if they
64:49 - are aliens inside of the alien class
64:51 - and the reason for that is if the player
64:53 - shot down all of the aliens so they all
64:55 - disappeared
64:56 - we don't really want to run this anymore
64:58 - because it would cause an error
64:59 - so this is a nice way to make our code a
65:01 - bit less buggy
65:03 - but right so with that we have a
65:05 - distance and now
65:06 - we have to call this method every time
65:09 - our aliens hit either the left or the
65:10 - right side of the screen
65:12 - so in here self dot alien move down
65:16 - and the distance i moved them down was
65:18 - two and this
65:20 - function you have to call for both if
65:22 - statements
65:24 - then well let's try this and this
65:27 - is working quite well so now the aliens
65:30 - are moving down
65:34 - so with that we have covered all of the
65:36 - movement of the aliens
65:37 - now the last part we need for them is to
65:40 - give them the ability to shoot lasers
65:43 - and well that's going to be just another
65:45 - method
65:46 - that we are going to call once in a
65:48 - while and let's call it
65:50 - alien underscore shoot and it
65:53 - only needs self as always and let me
65:55 - minimize all the other functions because
65:57 - they start to get a bit annoying
66:00 - and that feels much better
66:03 - and in here i first want to start with
66:06 - the same
66:06 - if statement we used for alien move down
66:09 - that
66:10 - we only want to run this if there are
66:13 - aliens
66:14 - inside of our aliens group and if that
66:16 - is the case
66:17 - i want to select a random alien first so
66:20 - i want to get
66:21 - a random alien and for that
66:24 - i need the random module so all the way
66:27 - at the top
66:27 - i want to import from random
66:30 - import choice
66:34 - and this choice we can then use down
66:36 - here to pick one alien
66:38 - and this happens with
66:40 - self.aliens.sprites
66:42 - so this line here literally just selects
66:44 - a single alien out of
66:46 - all of our aliens and this we are going
66:49 - to use for the x and y position of the
66:51 - laser
66:51 - and we still have our laser from earlier
66:54 - so
66:54 - we can use the position the speed and
66:57 - the screen height
66:58 - so let me copy all of the parameters and
67:01 - let's create a laser
67:03 - sprite this is going to be laser
67:06 - and let me pass in all of the arguments
67:08 - we are going to need
67:10 - and since we're using laser we also have
67:12 - to import it
67:13 - so from laser import laser
67:17 - and in here we have to figure out the
67:18 - different arguments
67:20 - although screen height is literally just
67:22 - the screen height we have specified down
67:24 - here
67:25 - so this one is already covered next up
67:28 - for the position
67:29 - all we need is random
67:32 - alien dot rect.center
67:36 - and then we are going to need a speed
67:38 - and for the alien lasers
67:40 - i went with six but this number
67:44 - is basically random so
67:47 - now we have a laser and in
67:50 - here we have to figure out on what
67:52 - sprite group to add it
67:54 - and there's going to be a minor problem
67:56 - because we already have
67:57 - one group for lasers and that is this
68:00 - one here
68:01 - and this laser is inside of the player
68:04 - and
68:04 - we couldn't just add these lasers to
68:07 - this group here
68:08 - for two reasons mostly first of all it
68:11 - wouldn't really make sense
68:12 - that is bright class inside of our
68:15 - player shouldn't be used for the alien
68:17 - lasers
68:18 - although that is more for the logic of
68:20 - the code itself it would
68:21 - technically work however the second
68:24 - reason would be more important for the
68:25 - game itself
68:27 - that this laser has to be in a different
68:29 - group
68:30 - than these lasers because later on we
68:32 - are going to check collisions
68:34 - that if any of these lasers is colliding
68:36 - with the player
68:37 - and if we had to put all the lasers in
68:39 - one group we would cause the player to
68:41 - be hit
68:42 - every time the player spawns a laser
68:44 - because the laser is drawn
68:45 - right behind the player so this laser
68:48 - sprite
68:48 - has to be in a separate group and well
68:51 - what that means
68:52 - is that we have to create another group
68:54 - so self
68:55 - dot alien lasers and pygame dot sprite
68:59 - dot
68:59 - group and let me put it right below the
69:02 - other group
69:03 - and this is what we're going to add the
69:05 - laser to so
69:06 - self dot alien lasers
69:09 - dot add laser sprite
69:14 - and i hope the logic here makes sense
69:16 - that the lasers from the player
69:18 - and the lasers from the alien have to be
69:19 - separated for the simple reason that we
69:21 - are always spawning the laser
69:23 - right behind the relevant sprite so if
69:26 - we were to spawn
69:26 - a sprite right behind the player and
69:28 - then check for collision between
69:30 - all lasers and the player we would
69:32 - always hit the player
69:34 - so this would make the game unplayable
69:36 - and that's why we need two different
69:37 - groups for our lasers
69:39 - however now we don't really want to call
69:42 - this function all the time
69:44 - oh actually let me call this function
69:45 - all the time and let me demonstrate
69:47 - what's going to happen
69:48 - so self dot alien
69:51 - shoot then we have to self dot alien
69:55 - lasers dot update and then we have to
69:58 - draw all of the lasers
70:00 - so self dot alien
70:03 - lasers dot draw and on the screen
70:07 - and now if i run this you can
70:11 - i think see why this wouldn't be
70:13 - particularly fair
70:14 - or well it would be a little bit of a
70:16 - difficult game
70:18 - so we don't want to run the alien shoot
70:19 - all the time we want to have a timer in
70:21 - between
70:23 - and that is going to happen down here
70:26 - that we want to create a timer and this
70:29 - happens
70:30 - with let's call it alien laser
70:33 - and here we have to create pygame a user
70:36 - event
70:37 - plus one and then pygame.time.set
70:42 - timer and now we want to get the alien
70:45 - laser
70:46 - and now i want to set the time how often
70:48 - this is going to run
70:50 - i went with 800 milliseconds so we have
70:52 - one laser shot
70:53 - about once a second but again you can
70:57 - make the game more difficult if you
70:58 - reduce this number
71:00 - and now if event dot
71:03 - type is equal to the alien laser
71:07 - only if that is the case i want to get
71:10 - my game
71:11 - and run alien shoot
71:15 - so we don't run this method inside of
71:18 - our run function
71:20 - instead we only run it inside of this
71:21 - timer
71:23 - and that we can now run
71:26 - and now we only have a laser that looks
71:30 - much more reasonable we still don't have
71:32 - any collisions but that we can start
71:34 - working on
71:35 - but before we are going to start working
71:38 - on that
71:38 - i want to add an extra alien because a
71:41 - key part of space invader is to get a
71:43 - high score
71:43 - and in the original game there's this
71:45 - top alien coming once in a while at the
71:47 - top of the screen that you can try to
71:49 - hit for extra points
71:50 - and this alien i also want to include
71:53 - and for that
71:54 - we have to create another kind of class
71:57 - in our alien file
71:59 - and this i called class extra
72:02 - this also has to be a
72:05 - pygame.sprite.sprite
72:06 - and as always it needs a
72:10 - init method then we need a super
72:13 - init method and then we're going to do a
72:17 - self.image
72:18 - and a self.rect and to get the image we
72:22 - can just use the usual pygame.image.load
72:25 - and the file path is this one and then
72:29 - convert alpha as always so we are just
72:32 - going to import a graphic
72:34 - for the image but now the rectangle is
72:37 - going to be a little bit more difficult
72:39 - because this extra alien is supposed to
72:41 - ever come in from the left and go to the
72:43 - right
72:43 - or coming from the right and go to the
72:45 - left so what i want to specify
72:47 - is the side this thing is supposed to
72:49 - start on and now we have to add
72:53 - an if statement in here that if side is
72:56 - equal to
72:57 - right then i want to create an x that is
73:00 - the screen width
73:01 - and right now we can't access the screen
73:03 - with so this
73:04 - is going to be another parameter so
73:07 - screen
73:08 - width and this is going to be screen
73:10 - width and let's say
73:12 - plus 50 just for some bit of wiggle room
73:14 - and if we are going to write anything
73:16 - other than right
73:17 - we assume that the extra alien is
73:19 - supposed to start from the left
73:20 - so the x can just be minus 50.
73:24 - and now we have all we need for the
73:26 - rectangle
73:27 - so self.direct is going to be
73:30 - self.image.getrekt as always
73:32 - and in here i want my top left to be
73:36 - x and then for y i just went with 80.
73:39 - and this code would either spawn the
73:41 - extra on the left or the right side of
73:42 - the screen
73:43 - depending on what we specify in here but
73:46 - if we were to add this extra
73:47 - to our aliens we wouldn't see it because
73:50 - it's outside of the screen
73:52 - so instead i want to add a speed to it
73:55 - so let's give it an
73:56 - update function that is going to get
74:00 - self.rect.x
74:01 - plus equals self.speed so this speed
74:05 - is ever going to be positive or negative
74:07 - depending on what side we are spawning
74:08 - the extra alien
74:10 - so we have to specify it so this would
74:13 - be self.speed is equal to let's say
74:16 - negative three and then if we're moving
74:19 - to the right self.speed should just be
74:22 - free and that way if our extra alien is
74:25 - on the right side of the screen
74:27 - so this one here we are moving it to the
74:29 - left and if it is on the left side of
74:30 - the screen we are moving it to the right
74:33 - and that way you should be able to see
74:35 - it once we spawn it in the game
74:38 - so with that i can return to my main
74:41 - file
74:43 - and now you might be tempted let me go
74:46 - up
74:47 - you might be tempted to add the extra
74:49 - alien to this
74:50 - aliens.group but that would not be
74:53 - working
74:54 - actually let me go back and tell you why
74:57 - because
74:57 - this alien sprite has a specific update
75:00 - method
75:00 - because here we are changing the
75:02 - direction of all of the sprites
75:05 - and also in the alien move down function
75:08 - we are moving down all of the aliens
75:10 - inside of this group
75:12 - and this is not something we want to do
75:13 - with our extra alien
75:15 - it's just supposed to stay on the top
75:18 - so we couldn't really add the extra
75:20 - alien to the self.aliens group
75:23 - it just wouldn't work so instead
75:26 - we have to create another group and i
75:29 - just called this one self.extra
75:31 - and since we only ever want to have a
75:33 - single one of those on the screen
75:35 - this could be a group single and
75:38 - i guess we can move this to its own
75:41 - group
75:41 - that is a bit easier to read let's call
75:43 - this extra
75:45 - setup and now this extra alien i only
75:48 - want to spawn
75:49 - ever so often and i want to keep this
75:52 - one
75:52 - inside of the function itself although
75:54 - you could also add another timer to it
75:56 - that will also work
75:57 - but in my case let's do a couple of
75:59 - different approaches
76:00 - so what i want to create is self.extra
76:05 - spawn time and for this
76:08 - i just want to get a random integer
76:10 - let's say between
76:11 - 400 and 800 and for that we need to rent
76:15 - in
76:16 - method so at the top i want to get
76:19 - my from random import choice and rent
76:22 - int
76:23 - so now let's say this number could be
76:24 - 600 and literally all i'm going to do
76:27 - is every time we are running this after
76:30 - the run method
76:31 - we are subtracting a certain amount from
76:33 - this number
76:34 - and whenever it hits 0 we are going to
76:36 - spawn an extra alien
76:38 - so for that we have to create another
76:42 - method
76:43 - and let's call this one extra alien
76:46 - timer needs self and nothing else
76:50 - and now i just want to get myself dot
76:52 - extra
76:53 - alien spawn time minus equal one
76:56 - and then if myself dot extra
77:00 - spawn time is smaller or equal to zero
77:04 - and i want to get myself dot extra group
77:07 - so this group single
77:11 - and add an instance of the extra to it
77:16 - so this would be extra and in here
77:19 - we need two bits of argument we first
77:22 - need decide
77:23 - and then we need this screen width
77:26 - unfortunately the screen width we
77:27 - already have that one's easy
77:29 - but now we have to get the side and this
77:31 - one is just going to be choice
77:35 - and into choice we have to pass in a
77:37 - list
77:38 - that is either right or
77:42 - left and then finally we have to run
77:45 - this function in there
77:46 - again so we set up a new timer for the
77:48 - extra spawn time
77:49 - so essentially what happens in here is
77:52 - we start
77:52 - with a number up here and we get an
77:55 - extra spawn time number
77:56 - and let's say for the sake of the
77:57 - argument for now this is going to be
77:59 - 600 then inside of extra alien timer
78:03 - we're going to reduce this number by one
78:05 - so if we run this once we get
78:07 - to 599 then
78:10 - 588 and so on and
78:13 - eventually we are going to hit zero and
78:16 - if we hit zero
78:17 - we're going to run this if statement and
78:20 - what we're doing there on the first line
78:22 - is we're going to create an extra alien
78:25 - that whatever spawn
78:26 - on the left or the right side and well
78:28 - then we give it a screen width to tell
78:30 - when it's supposed to disappear
78:31 - and well that's all we really have to
78:33 - worry about in this instance
78:35 - and then we are going to set a new
78:37 - random integer
78:38 - so now instead of 600 let's say we could
78:40 - get 520
78:44 - so now the next extra alien would spawn
78:46 - a little bit faster
78:47 - so the only thing we have to worry about
78:49 - now is to actually calling this function
78:52 - and let's also place it right down here
78:55 - so self dot extra alien
78:59 - timer and now before we are going to
79:02 - call it
79:02 - i forgot that we have to import it so
79:05 - we are from alien import alien and extra
79:09 - and just to test this i am going to set
79:13 - the spawn time for the first spawn
79:15 - between
79:16 - 40 and 80 so we don't have to wait for
79:18 - too long
79:19 - so now let's try this
79:22 - and oh right we're not going to see
79:25 - anything
79:26 - because we are not drawing this extra
79:29 - alien
79:31 - so in here we have to get self
79:34 - dot extra
79:38 - dot draw this has to be on the screen
79:41 - again and then we have to update it as
79:43 - well
79:45 - so self dot update and now let's try
79:48 - this
79:50 - and there we can see it we have a nice
79:53 - little extra alien on the top
79:55 - and if i wait a tiny bit longer this
79:58 - should reappear at some point there we
80:00 - go
80:01 - and now at some point we should also get
80:03 - one that comes from the left
80:04 - i think we just got not very lucky for
80:06 - now and yeah there we go
80:08 - so this is also working very well cool
80:12 - so with that i can minimize this
80:14 - function as well
80:16 - and we are making some really good
80:18 - progress
80:19 - so now we have all the players all the
80:21 - obstacles and all the aliens
80:23 - now we have to work on the collisions to
80:25 - actually turn this into a game
80:27 - and the collision function is going to
80:29 - be the longest part of this game
80:31 - however it's not particularly
80:34 - complicated
80:35 - because all we are really going to do is
80:37 - we check different sprite collisions
80:39 - so for the laser sprites we check with
80:41 - the obstacles and the aliens
80:43 - and for the alien lasers we also checked
80:45 - with the obstacles but now with the
80:47 - player
80:48 - so it should be a fairly straightforward
80:50 - thing to work on so let's jump into the
80:52 - code and let's have a look at this
80:53 - and here i am back and it is getting
80:57 - quite extensive
80:58 - but right at the bottom i want to add
81:00 - one more method
81:02 - and this one i just called collision
81:05 - checks
81:06 - it needs self and nothing else and now
81:09 - in here
81:10 - we have to check a couple of things and
81:13 - let me start
81:14 - with the player lasers that is probably
81:17 - going to be the most interesting one
81:19 - and first of all i want to check if
81:21 - there are any lasers from the player
81:24 - so if self dot player
81:27 - dot sprite dot lasers and
81:31 - if that is the case i want to look for
81:33 - laser
81:34 - in self.player.sprite.lasers
81:38 - bit of an extensive thing but well and
81:41 - let me spell this properly as well that
81:43 - tends to help
81:44 - and now i want to check for two
81:46 - different things
81:47 - if either of these lasers connects with
81:49 - the obstacle or with the aliens
81:51 - and let's start with the obstacle
81:55 - collisions and really all we need in
81:57 - here
81:58 - is if pie game dot sprite dot sprite
82:01 - collide and then here we want one sprite
82:04 - that's the laser
82:06 - then i want to have myself dot blocks
82:10 - so each block of the obstacle and then i
82:12 - need a third argument and that's the do
82:14 - kill
82:15 - and this one should be true because we
82:17 - want to destroy
82:18 - this block as soon as it collides with
82:20 - the laser and for now
82:22 - inside of this if statement let's just
82:24 - call
82:25 - laser for now and don't forget to run
82:28 - this function
82:28 - so we can test it properly so self dot
82:32 - collision checks and now let's try this
82:36 - and now you can see that this is indeed
82:40 - working and we can destroy the obstacles
82:42 - now obviously this isn't working as
82:45 - intended because our laser doesn't
82:47 - disappear and keeps on going and
82:49 - destroys all of the obstacles
82:53 - but this we can change very easily
82:55 - because all we have to do
82:56 - is we have to get our laser sprite and
82:59 - run kill on it
83:02 - so essentially what's going to happen
83:03 - here is when this
83:05 - if statement runs it destroys the block
83:08 - it's colliding with
83:09 - and then if that is the case we are also
83:11 - going to destroy the laser right inside
83:13 - of the if statement
83:15 - and if we do that now we have
83:18 - a well a pretty well working laser with
83:21 - the obstacles
83:22 - and you can keep on destroying
83:24 - individual parts
83:25 - and then use this in the normal way so
83:28 - this is literally all we needed to make
83:30 - the basic laser work for the player and
83:32 - the obstacles
83:34 - now next up we need the alien
83:37 - collisions and well for now we can just
83:40 - copy this entire line
83:42 - and change self.block to self.aliens
83:46 - and well that's all we have to make for
83:48 - change so now let's try this
83:49 - and we can also destroy the aliens so
83:52 - this is also working quite well
83:54 - although later on we are going to make
83:56 - some changes to this line when we add
83:58 - the score but that comes later
84:01 - and then we need the final one and
84:03 - that's the extra
84:05 - collision and here again i can just copy
84:08 - this
84:08 - if statement and change this to
84:11 - self.extra
84:13 - and now okay this is going to be very
84:16 - difficult to hit
84:18 - but i am quite confident that it is
84:20 - going to work but
84:22 - well in an actual game do test this a
84:24 - bit more
84:25 - but right so with that we have our basic
84:28 - collisions for the player
84:30 - now next up we have to do the exact same
84:33 - thing
84:33 - for the alien lasers and this could be a
84:37 - really good exercise for you
84:39 - that i want you guys to create the
84:40 - collision logic for the alien laser
84:42 - colliding with the obstacles and with
84:44 - the player
84:49 - i first want to check if there are any
84:51 - alien lasers
84:52 - so if self dot alien
84:56 - lasers is the case
85:00 - and if that is the case i want to loop
85:02 - over all of the lasers so for
85:03 - laser again in self.alien lasers
85:08 - and now for the obstacle collision i can
85:11 - literally just copy
85:12 - this line here and well that's all we
85:15 - had to do
85:17 - and let's try this and let's open alien
85:19 - hits and obstacle and yeah there we go
85:21 - this is working indeed cool now we can
85:24 - copy this
85:25 - if statement again and now we want to
85:29 - check the laser
85:30 - against self dot player and this one
85:34 - has to be false because we don't want to
85:36 - destroy the player
85:37 - and then here you could close the game
85:39 - but for now i'm just
85:41 - going to print dead so let's try this
85:44 - and let's hope i can get hit there we go
85:46 - this is working quite well
85:48 - and we can be hit by aliens so with that
85:52 - we have the collisions for all of the
85:53 - lasers and this actually wasn't all that
85:56 - bad
85:56 - although well we are going to make some
85:58 - additions to this
85:59 - but there's one more collision that we
86:01 - are going to need
86:02 - and that is between the aliens
86:04 - themselves and the obstacle blocks
86:07 - and then i guess with the player as well
86:09 - although if an alien collides with the
86:10 - player
86:11 - we are going to game over immediately
86:13 - anyway but
86:14 - we do have to work with that so let's
86:16 - call this one aliens
86:18 - and in here i just want to check if self
86:21 - let me scroll down
86:22 - if self.aliens so if there are any
86:25 - aliens on the screen
86:27 - i want to check for alien in self.aliens
86:32 - and now again i can again check this
86:34 - same line
86:35 - except now this doesn't have to be an if
86:38 - statement because we don't want to
86:40 - destroy the alien
86:41 - we just want to destroy the block and
86:43 - this shouldn't be laser this should be
86:45 - alien
86:47 - but we also want to check if an alien
86:50 - collides with the player
86:51 - so let me copy this line here
86:55 - so if pygame.sprite.sprite collide and
86:58 - we want to check between the
86:59 - alien and the player and
87:02 - if that is the case i guess then we can
87:05 - close the game
87:06 - so pygame dot quit and
87:09 - sys.exit and this is going to be kind of
87:12 - annoying to test
87:13 - because we would have to wait quite a
87:15 - while so just for now
87:18 - for our alien position checker
87:21 - i want to set the speed to negative 10
87:24 - and
87:24 - plus 10. so now they should speed up
87:28 - quite a bit
87:29 - now our obstacles disappear and we go to
87:32 - game over
87:33 - once the aliens collide with the player
87:36 - so this is working cool
87:37 - so this is actually all we needed for
87:40 - the collisions wasn't actually that bad
87:42 - and with that we essentially have a game
87:44 - although not a very good game yet
87:46 - because we want to add a couple more
87:48 - things
87:49 - and i think the most important one for
87:50 - space invaders is to add a score and a
87:53 - live system
87:54 - so that's going to be what we start
87:55 - working on now and let's start with the
87:57 - lives that
87:58 - i guess is the easier one and i think
88:01 - this is best approach
88:02 - by just going straight into the code and
88:04 - going through this one by one
88:06 - so let's start with that so here you can
88:09 - see the main file again
88:10 - and i want to work on my knit method and
88:13 - in here
88:14 - i want to add another section and let's
88:16 - call this one
88:17 - health and score setup and in here we
88:20 - have to specify a couple of different
88:22 - things
88:23 - since we are starting with the lives i
88:24 - want self.lives
88:27 - and i want to have three different lives
88:29 - and since i want to display
88:30 - all of these lives as the player in the
88:32 - top right i also need a surface so let's
88:35 - call this live
88:36 - surface and for this we need pygame
88:39 - dot image dot and this is going to be
88:42 - the same file we have for the player
88:45 - this one here and then we have to again
88:48 - convert alpha all of this and there's
88:51 - one more thing that we need
88:53 - and that is going to be live x
88:56 - start position
88:59 - so effectively we want to place all of
89:01 - these lives in the top right of the
89:03 - screen
89:04 - but for that we have to know how far of
89:06 - an offset we need from the right side of
89:08 - the screen and this is what this is
89:11 - going to be for
89:12 - and in here i want to first get my
89:14 - screen width and from that
89:16 - i want to subtract a couple of things
89:18 - and basically what i want to get
89:19 - first of all is self dot live surface
89:23 - dot get size
89:26 - and this should be zero so effectively
89:30 - what we're doing here we are first
89:32 - getting our live surface
89:34 - so the thing we have literally just
89:36 - imported then i want to get
89:38 - getsize and this is going to give me an
89:40 - x and a y parameter
89:42 - and from that i only care about the x
89:44 - part so i'm going to get zero
89:46 - so this will ultimately get me the width
89:48 - of my live surface
89:50 - that's literally all this does so this
89:52 - would give me the width of one player
89:54 - live
89:55 - but i don't just want to show one i want
89:57 - to show
89:58 - two and then along with that i also want
90:00 - to have an offset
90:02 - and that i have just set to 20. and now
90:05 - we have a somewhat reasonable offset
90:07 - from the right side of the screen that
90:09 - we can use
90:10 - so with that i can close the init
90:15 - function and create another
90:18 - method all the way at the bottom and
90:20 - let's call this one
90:22 - display lives it doesn't need any
90:26 - arguments
90:27 - and in here i want to loop over my life
90:29 - so for life
90:30 - in range self dot lives however
90:34 - here i only ever want to display my
90:36 - lives
90:37 - minus one so let me explain what this
90:40 - does
90:41 - essentially i want to have the ability
90:43 - on the top right
90:44 - to either show two lives one lives or
90:46 - zero lives left
90:48 - but with zero lives we are still alive
90:50 - we just can't see any lives in the top
90:52 - right anymore
90:53 - and this is i think how the original
90:55 - space invaders also worked
90:56 - and this is why i want to have the minus
90:58 - one that we still have one life left but
91:00 - we can't see it in the top right because
91:02 - it's our last life
91:03 - so i hope that makes sense and really
91:07 - all we want to do in here
91:08 - is to use screen dot blit
91:11 - we want to get myself dot live surface
91:15 - and now we are going to need an x and a
91:17 - y position
91:19 - the y position is the very easy part so
91:22 - we just need eight
91:23 - it's a random number i have chosen
91:25 - because it's very close to the top
91:27 - but for x i'm going to put this in its
91:29 - own variable
91:30 - and first of all i want to get the left
91:33 - side of my starting position
91:34 - so self dot live x start position
91:38 - and that is the variable we created
91:42 - up here this one
91:45 - so this is going to tell us when our
91:47 - lives should start on the left side
91:49 - but we don't want to place all of our
91:51 - lives right on there
91:52 - so we have to add something to it and
91:55 - what we have to add
91:56 - to it is going to be for now our life
92:00 - so this one here and this right now
92:03 - would either be zero
92:04 - or one but with this by itself we would
92:06 - only move it by one or two pixels
92:09 - so this wouldn't be good enough by
92:10 - itself instead
92:12 - we have to multiply it by the width of
92:13 - the player live so again
92:16 - we have to get self dot live surface
92:20 - get the size again
92:23 - and again zero and this will place both
92:27 - of the lives
92:27 - right next to each other and i want to
92:30 - have a slight offset
92:31 - so let's add plus 10 to it and this
92:34 - should give us all of our lives
92:35 - so now in our run method
92:39 - self dot display lives and let's see
92:43 - what's going to happen
92:44 - and we are getting an error message and
92:47 - the reason for that
92:48 - is up right here getsize is a method
92:51 - so i just forgot the brackets and since
92:55 - i'm calling get
92:56 - size again down here you also have to
92:58 - add it in there
93:00 - now let's try it again and now this is
93:02 - working although the top right is a bit
93:05 - too close to each other
93:06 - and this we can avoid by putting those
93:09 - two
93:10 - inside of a bracket and now stress again
93:13 - and this is looking better
93:14 - so now we have a live system
93:18 - now the problem is it doesn't really
93:20 - work with our collisions
93:21 - so this is what we have to work on now
93:23 - that every time our players sit i want
93:25 - to reduce our lives by one
93:28 - so effectively we have to go back to our
93:30 - collisions
93:32 - and in here the important part is this
93:35 - if statement that i don't want to print
93:39 - that anymore instead i want to give
93:42 - self dot lives minus equal
93:45 - one and what we can also do while we're
93:48 - here
93:48 - is if self.lives is smaller or equal to
93:52 - zero then we want to end the game
93:55 - so pygame dot quit and
93:58 - says dot exit and let's try this
94:02 - so i hope i can get hit there it's
94:04 - reduced by one now we have just one life
94:06 - left and now you can see
94:07 - we can't see lives on the top and now if
94:09 - i get hit again we are dead
94:11 - so this is working very nicely
94:14 - and with that we have our live system
94:17 - now next
94:18 - up i also want to add a score to all of
94:20 - this
94:21 - and for that we have to make a couple of
94:23 - changes to
94:24 - a few different things we have to update
94:27 - our collisions
94:28 - and we have to update our aliens so they
94:30 - all have a certain kind of score
94:32 - so i guess let's jump straight back into
94:35 - the code and let's have a look at this
94:37 - so here i have my entire setup again and
94:40 - it is really getting quite extensive
94:42 - but for now i want to work on my init
94:44 - method again and in here
94:46 - i want to add two more attributes the
94:48 - first of all
94:49 - is self.score and by default this is
94:54 - zero
94:55 - and besides that i also want to have a
94:57 - font
94:59 - because now we have to display some text
95:01 - and for the font
95:02 - i need pygame.font.font
95:06 - and the font i am going to import is
95:09 - also in the folders
95:10 - and the file path towards that is this
95:12 - one and the font size i went with was
95:15 - 20. so now we have a font that we can
95:18 - use
95:19 - and that's all we needed in the ended
95:21 - method and now we can create
95:24 - another method that i have called
95:27 - display score it needs
95:30 - self and nothing else and in here we
95:33 - have to do three different things
95:35 - we have to first get a score surface so
95:37 - we have to render the text
95:39 - then we have to get a rectangle of that
95:41 - surface and then we have to put both of
95:42 - these on the screen
95:44 - and this could be a really good exercise
95:46 - for you that i want you guys to create
95:48 - this display score method
95:49 - and use it to display the score 0 on the
95:51 - screen for now
95:52 - ideally in the top left but well
95:54 - wherever you really want it to be
96:00 - all right so first of all i want to
96:03 - create a score
96:04 - surface and for that we need
96:08 - self.font.render
96:09 - and i want to create an f string that
96:12 - says
96:13 - score and then we get our self.score
96:18 - and for the anti-aliasing i want folds
96:21 - since we're using pixel art
96:22 - and for the color i just went with white
96:25 - and with that we have our surface
96:27 - now i want to get my score rectangle and
96:31 - this is going to be
96:32 - score surface dot get
96:35 - wrecked as always and in here i want to
96:38 - place the top left
96:40 - and for now let's place it at 0 and 0.
96:43 - although i'm going to change that in
96:44 - just a second
96:45 - and finally i just want screen dot blitz
96:49 - with my score surface and my score
96:53 - wrecked and well that's all we needed
96:57 - so now i can open
97:00 - up the run method and actually display
97:03 - lives should not be there
97:05 - it should be down here and i also want
97:08 - self dot display the score
97:13 - and i guess by now i can just delete
97:15 - these two comments they don't
97:17 - really do anything anymore and this run
97:20 - method has become quite extensive
97:22 - it might be a good idea to clean it up a
97:23 - tiny bit let's do that now actually
97:26 - so here we are drawing all of this and
97:29 - there we are
97:30 - updating everything and i guess it is a
97:33 - good idea
97:34 - to have all of the update methods
97:37 - in one chunk and
97:41 - that makes a little bit more sense yeah
97:44 - i think that looks a bit better
97:45 - so here we're updating all of the spread
97:47 - groups then
97:48 - here we are adding extra updates and
97:51 - here we are drawing everything
97:53 - let's try this now and we can see the
97:55 - score
97:56 - in the top left and
97:59 - it doesn't update right now but we can
98:01 - work on that in a second but first of
98:03 - all
98:03 - i want to work with this top left and
98:05 - there might be one thing you have
98:06 - noticed
98:07 - that this font is not in the top left
98:10 - there's a slight y
98:11 - offset even though we specified zero
98:14 - in the score and the reason for that is
98:16 - that the font is
98:18 - rather large so for the x offset i want
98:21 - to go with 10
98:22 - and for the y with negative 10
98:25 - and that's going to look like this which
98:27 - i think is better
98:28 - and well the score here is just very
98:30 - very tall for some reason
98:33 - but well that's literally all we needed
98:35 - now so now we have a score
98:37 - and the one thing we have to figure out
98:38 - now is how to
98:40 - update this number here and for that
98:44 - we have to go to our alien file and give
98:46 - each alien a score
98:48 - relative to that color and well that is
98:51 - literally just an if statement
98:53 - so if the color is equal to red
98:57 - then self.value is going to be a hundred
99:02 - l if color is equal to
99:06 - green then we have self.value
99:10 - is going to be 200 and if we have
99:13 - neither of these cases
99:14 - so we have else then self.value
99:17 - is going to be 300. so this would be the
99:21 - yellow aliens all the way at the top
99:23 - and now we can look at our
99:26 - collision checks in here and the two
99:29 - if statements you want to look at are
99:31 - these two and the easier one
99:33 - is going to be this one because there's
99:36 - only one extra alien
99:37 - so if we hit that one we want self.score
99:41 - plus equal 500. and that is all we
99:44 - needed here
99:45 - and let me place it above laser.kill not
99:48 - for any particular reason
99:49 - it just feels better all right but
99:52 - now this statement here is going to
99:55 - become
99:55 - a little bit more complex and that is
99:58 - because right now
99:59 - we are only deleting the alien once it's
100:01 - being hit
100:02 - but we don't know which alien is hit and
100:04 - since we don't know what alien has hit
100:06 - we don't know what the score is going to
100:08 - be so instead
100:10 - we have to do this slightly differently
100:13 - and let me actually copy
100:14 - all of this and what i want to find out
100:18 - is first i want to get all the alien
100:21 - let's call it aliens hit
100:23 - and this is going to be
100:24 - pigem.sprite.spread collide
100:26 - and it is still going to be true and
100:28 - this is still going to destroy the alien
100:30 - however now
100:31 - it is also going to store it in this
100:33 - aliens.hitlist
100:35 - so i can get rid of all of this and i
100:38 - can check if
100:39 - aliens hit and if that is the case
100:43 - i still want to get laser.kill that
100:46 - stays the same
100:47 - however now i can also loop over all the
100:50 - aliens
100:51 - so for alien in alien
100:54 - hit and then self.score
100:57 - is simply going to be plus equal alien
100:59 - dot value
101:01 - oh and this should be for alien in alien
101:03 - set
101:04 - and now let's try this and it is working
101:07 - indeed
101:07 - i can shoot at the aliens and i get
101:09 - different scores and they hit the green
101:11 - one
101:13 - and the score is updating quite nicely i
101:16 - hope i can get to hit
101:18 - a yellow one and there we go so
101:21 - this is working very well so with that
101:25 - we also have our score and that is
101:28 - basically finishing up the game by
101:31 - itself
101:32 - so let me close everything and i think
101:35 - what i really want you guys to get away
101:36 - from this is that none of this was
101:38 - particularly difficult we just added
101:40 - lots of simple systems on top of each
101:42 - other
101:42 - and thereby created complexity and the
101:44 - only two things i really want to add
101:47 - number one is i want to add some crt
101:49 - styling on top
101:51 - and i think that makes the game look
101:52 - much better although it's not strictly
101:54 - necessary and you might not like it at
101:56 - all
101:57 - and the second one is going to add sound
102:00 - and that's going to be the really easy
102:01 - part so i will leave that for the end
102:03 - but first of all i want to draw on top
102:06 - of this
102:07 - so by the end of this section our game
102:09 - goes from this
102:10 - to this but literally all we are going
102:12 - to do here
102:13 - is we are drawing some elements on top
102:15 - of the game and then reducing the
102:17 - opacity
102:18 - and well let's jump into the code and
102:20 - let's create this
102:21 - so here i'm back in the main game and i
102:24 - want to create a new class
102:26 - and let me minimize the game class so we
102:28 - have a bit more space
102:30 - and this class i called crt it does not
102:33 - inherit from anything
102:35 - and we just set an init method
102:38 - and it here i want to have self.t
102:43 - and this is just going to be an image so
102:46 - pygame.image.load
102:48 - and the file path for that is this one
102:51 - so it's in the same graphics folder
102:52 - and i also want to convert alpha this
102:56 - and you're going to see in a second what
102:58 - that actually does
102:59 - and what i'm going to do is i'm going to
103:01 - create a draw
103:03 - function that needs self and for now
103:06 - all we're going to do is screen dot blit
103:08 - blitz self.tv
103:11 - and it should be in the top left so 0
103:13 - and 0.
103:14 - and now in our if statement for the main
103:18 - game
103:18 - i'm going to create crt
103:21 - as an instance of the crt class and then
103:25 - on top of our game run or below in the
103:27 - code
103:29 - crt.draw and now let's have a look what
103:31 - this does
103:32 - and there we go so really all this does
103:35 - is
103:36 - it well it draws a tv style thing
103:40 - around the address of the screen but now
103:43 - this image has a problem and let me
103:46 - actually demonstrate this
103:47 - that if i increase the width of our game
103:50 - now this image doesn't cover the
103:53 - entirety of the game which starts to
103:54 - look very very silly
103:56 - so we have to add some code here to make
103:59 - this
104:00 - wider along with the screen and let me
104:03 - move it back to 600.
104:05 - and for that we can use pygame.scale
104:08 - and well all we are going to need is
104:10 - self.tv
104:11 - is pygame.transform.scale
104:16 - and in here we need a couple of
104:17 - arguments the first one is the surface
104:20 - itself
104:20 - so self.tv and then we're going to need
104:24 - the width and the height we want this to
104:25 - be
104:26 - so in our case this is screen width and
104:29 - screen height and both of these have to
104:32 - be inside of a tuple
104:35 - so if i run this by itself we can't see
104:38 - any difference
104:39 - however if i make the screen wider now
104:42 - this is going to scale up along with it
104:44 - so this way our game keeps on being
104:47 - responsive
104:48 - which is quite nice but let me keep it
104:51 - at 600 to 600
104:53 - and there's one thing that is kind of
104:55 - annoying right now
104:56 - so we can't really see the edges too
104:58 - well and this we can change by lowering
105:01 - the opacity
105:02 - of this surface and to do that all we
105:04 - need is self.tv
105:05 - and set alpha and then here you have
105:08 - that a number between 0 and 100
105:10 - with 0 being invisibility and 100 being
105:13 - the standard value so you can see
105:14 - everything so let me put it to 50
105:18 - and now this is looking much better and
105:21 - what we can even do in here
105:22 - because traditional crt monitors
105:24 - flickered a bit
105:26 - and i imitated that effect by using a
105:29 - random opacity
105:30 - between 75 and
105:33 - 90. and what is going to happen here is
105:36 - that every time we are running the draw
105:38 - method
105:38 - so well every frame we are changing the
105:41 - opacity a tiny bit
105:42 - which makes the entire thing look much
105:44 - more dynamic
105:46 - and i think you can see it this
105:49 - starts to feel better so all right
105:53 - this is then working quite well but now
105:56 - these old tvs
105:57 - also showed a couple of lines and for
105:59 - that
106:00 - i want to define create
106:03 - crt lines and let's place this above
106:07 - draw
106:07 - again we are going to need self and now
106:10 - we need a couple of different things
106:12 - first of all i want to get a line height
106:14 - so how tall each line is going to be
106:17 - and i just went with three and then we
106:19 - have to figure out how many lines we
106:21 - want to have
106:21 - so line amount and really all we need
106:25 - is this green height divided by the line
106:28 - height and this i want to be an
106:31 - integer so we can work with it a bit
106:33 - more easily
106:34 - and well all we have to do now is for a
106:37 - line in
106:38 - range line amount
106:42 - i want to draw the lines and for that i
106:45 - need a y position
106:47 - and well this line position is just
106:49 - going to be line
106:50 - multiplied by line height so we figure
106:53 - out what line we are on
106:55 - and then we are multiplying this by the
106:57 - height of each line
106:58 - and now we can start drawing so
107:02 - pygame.draw.line
107:04 - and here is one important thing that
107:06 - usually
107:07 - when i use this.draw i always draw
107:10 - on the screen however now i'm going to
107:13 - draw
107:13 - on self.tv so self.tv
107:17 - and the reason why i am doing that is
107:20 - because i want to have the same opacity
107:22 - for the lines and for the tv and if i
107:25 - put all of them on the same surface
107:27 - when we run this line they are all going
107:29 - to have the same opacity
107:31 - which makes the game look a bit more
107:32 - consistent now we are going to need our
107:35 - color
107:36 - and in my case i just went with black
107:39 - and now we need the start point
107:41 - and the end point of each line and a
107:44 - width
107:44 - the width is the easiest part i just
107:46 - went with one and for the start point
107:49 - we need a tuple and here we are going to
107:52 - need
107:52 - x and y and both of these are very easy
107:56 - because x is just going to be zero so
107:58 - the left side of whatever window we have
108:01 - and y is just going to be the y position
108:05 - and for the endpoint this is also quite
108:07 - easy so we need
108:08 - x and y again and y is just going to be
108:11 - the y position
108:13 - and x is going to be this green width
108:16 - and well that was literally all we
108:19 - needed
108:20 - so now i have to call self dot create
108:23 - crt lines and let's run this game
108:26 - and there we go this is looking very
108:29 - well
108:30 - so now we have a much more retro feeling
108:32 - game
108:33 - that i think is looking better than the
108:35 - original
108:38 - but you could just not run crt.draw
108:41 - and then if you like this one more this
108:43 - would also work just fine
108:47 - and with that we have all of our styling
108:51 - done
108:53 - now with that we have the final part of
108:56 - our game
108:56 - and that is going to be the music and
108:58 - the sounds and well
109:00 - there really isn't anything complicated
109:02 - now this is going to be very easy
109:04 - so let's go straight into the code and
109:06 - let's have a look at this
109:08 - so here we have our entire game setup
109:10 - and i want to look at my game class
109:12 - again
109:12 - and if you open this one you can see the
109:14 - init method and all the other methods we
109:16 - created earlier
109:17 - and the first thing i have to do is to
109:21 - import all the music let's call it audio
109:24 - actually
109:25 - and first of all i want to import the
109:27 - music itself so the background music
109:30 - and this is going to be pygame dot mixer
109:32 - dot
109:33 - sound and the file path towards that
109:37 - file
109:37 - is this one next up i want to
109:41 - set the volume of this file and i set it
109:45 - to 0.2
109:46 - so it doesn't get too loud and finally i
109:49 - want music dot
109:50 - play and for the loops we want to set it
109:54 - to negative one so at this place forever
109:57 - and now if i run this
110:01 - you should be able to hear that so i
110:04 - hope this is working
110:05 - so this would then be the first part and
110:08 - this could be a really good exercise for
110:09 - you
110:10 - there's also a laser sound and an
110:11 - explosion sound try to import them
110:14 - set the volume and play them at the
110:16 - appropriate time
110:23 - all right i'm going to shorten this a
110:25 - bit because this is very samey
110:28 - so let me just copy them and here we
110:30 - have a laser sound
110:31 - and we set the volume and then we have
110:33 - an explosion sound and we're also going
110:35 - to set the volume
110:36 - that's literally all that's happening
110:37 - here so now we have to figure out when
110:39 - each of these sound is supposed to be
110:41 - played
110:41 - and let's start with the laser sound and
110:44 - the laser
110:44 - is going to happen every time an alien
110:46 - shoots so
110:48 - in here alien sound dot play
110:51 - and the explosion sound i want to play
110:55 - if we have a collision check between
110:58 - the player laser and the alien so in
111:01 - here
111:02 - and let's just play it right afterwards
111:06 - and let's try this
111:15 - although there's one part missing that
111:17 - if our player shoots a laser we don't
111:19 - hear sound
111:20 - and for that we have to go back into our
111:22 - player class
111:24 - and in here i also want to import the
111:26 - laser sound
111:28 - so here the literal same thing we have
111:30 - done earlier
111:31 - and now every time we're pressing the
111:33 - space button and we are ready
111:35 - i want to self dot
111:38 - laser sound dot
111:41 - play and now stress again
111:57 - really well however there's one thing i
112:00 - did forget and that is a victory message
112:03 - once we have destroyed all of the aliens
112:05 - so let's add this one really quick sorry
112:08 - about that
112:09 - but this is not a difficult thing to add
112:12 - and
112:12 - really what i want to do is if there are
112:14 - no more alien sprites i want to display
112:16 - a text that says you won
112:18 - that's literally all it is so let's jump
112:20 - straight into the game and let's fix
112:22 - this really fast and then we are
112:23 - finished
112:24 - here we are back in our game class and i
112:26 - just want to add
112:27 - another method and let's call it
112:32 - victory message
112:35 - it doesn't need any arguments and really
112:38 - all we're going to check in here
112:39 - is if not self.aliens.sprites
112:44 - so if there are no more aliens in the
112:45 - aliens group then we know we have one
112:49 - and in there all we need to do is create
112:51 - a victory
112:53 - surface and this is going to be
112:56 - self.font.render
112:58 - that says u1 needs to be false for
113:01 - anti-aliasing
113:02 - and the color is going to be white and
113:05 - then i also want to get
113:06 - a victory rectangle so we can place it
113:09 - in the middle of the screen
113:10 - and this is just going to be victory
113:12 - surface dot get direct
113:15 - and the center is going to be the screen
113:19 - width over 2 and then also the screen
113:22 - height
113:23 - over 2 and then finally screen
113:28 - dot blit victory
113:32 - surface and victory rectangle
113:37 - and then of course also don't forget to
113:39 - run this
113:40 - so self dot victory message
113:44 - and for that i am going to cheat ever so
113:47 - slightly here
113:48 - so what i'm going to do is in the
113:50 - collision check
113:52 - i am going to comment out laser.kill
113:56 - and replace it with pass whenever our
113:58 - play hits an obstacle
114:02 - and we're also going to comment it out
114:03 - whenever we hit an alien so that way our
114:05 - player is
114:06 - basically going to shoot
114:29 - [Music]
114:34 - so now i can uncomment all of this
114:39 - get rid of this and with that
114:42 - we have the entirety of the game
114:46 - so i hope that was helpful and i will
114:48 - see you around

Cleaned transcript:

in this tutorial we are going to create space invaders in pygame and this can be either in a modern style or with a retro overlay i will cover both now this is a slightly more advanced pygame tutorial so i assume that you already know the basics however if you don't or you want a refresher i have made an extensive pygm tutorial that would prepare you perfectly for this video so check this one out if you're a bit lost and this is only going to be the first advanced pie game tutorial and there will be quite a few more the next one is going to be a mario style platformer with pirates so get subscribed if you don't want to miss it also you can check my twitter for updates on what i work on and let me know in the comments if you would like to see a game in the future but with all of that covered let's go into the game and i hope you enjoy alrighty so let's get started with the first part of this game and for now we are only going to set up the main window and the class that is going to contain the logic of the entire game so for now we're not really going to draw anything we're just setting up the actual game so let's jump straight into pygame and let's have a look at this and in here i already have a couple of things open most importantly we have the basic pie game setup nothing fancy happens here then i set the display width and height and use those to create a display surface and that one we call later down here to limit the frame rate and then in the actual game loop we are checking for the escape button we are drawing a background color and then we are drawing anything that was drawn in the game loop so this entire thing right now is essentially the most basic setup for pygame that doesn't do much yet so if you execute all of this you would get a blank window with a darkish background so really not much is happening here and this code isn't going to change all that much because most of our game logic happens inside of a class and all we do in here is create an instance of the class and run one method of that class in the game loop however there is one change i would like to make and that is i want to place this entire code inside of an if statement that if done the name is equal to the string thunder main and if i execute this code we are not going to get any kind of change and the reason why i am using this if statement is because we are going to work with multiple files so there is a very small chance that you might execute some code you don't actually intend to run and this if statement prevents that entirely so it's essentially a safeguard that we didn't necessarily need but it is good practice so now we have our basic setup now with that covered i want to create a class and this i code game because it contains the game logic and for now this class is going to have two methods one is the init method that for now doesn't do anything so i just add pass in here and then i also want a method called run and this one also gets a pass so we don't get an error message so let's talk about these two methods init is the usual initiate method of a class and we are essentially going to add lots of sprite groups here for example the player has a sprite group the obstacles and aliens are sprite groups each and stuff like that and that is essentially going to be the framework of our game and then in the run method we are going to update all sprite groups and we are going to draw all sprite groups so this run method is essentially the main part of our game so in the if statement i want to create an instance of this game and then in the game loop i want to run game.run and that way we can add all of our game logic in this game.run and write the actual code inside of this class and this is a nice setup to keep our actual game loop clean and have all of the logic inside of the class and that should make running the entire game much simpler and already with that we already have the basic framework for our game now obviously right now it really doesn't do all that much but that we can start working on now and the first thing i want to work on is the player and the player will have to do a couple of different things it needs to show an image of the player itself it needs to be able to move it needs to be constrained to the screen so we can't move outside of it and it has to be able to shoot a laser and to recharge which basically means there's a timer between shooting a laser so the player can't shoot continuously and all of this is going to happen inside of a sprite class so we keep the entire code organized and have one class for the player so let's jump straight back into the code and let's have a look at this so here i am back in my main file and i want to create a new one so let me create a new one and let me save it and i'm going to call this one player.pie and in here first of all i want to import pygame and next up i want to create a player class and this one has to inherit from pygame.sprite.sprite and in here as always we need the init method needs self and for now nothing else and first of all we need super dot init very easy to forget but very important and now like any other sprite class we are going to need self.image and we are going to need self.rect and both of those are very easy to get for the image itself i just want to import an image so pygame.image.load and filepath is going to be this one so we are going to the parent folder and there's a folder called graphics and in there there's an image called player.png and i want to convert alpha this image and now for the rectangle i want to grab myself dot image and get the rectangle and i want to place the mid bottom and where i want to place it is going to be a position that we are going to get when we initiate this class so effectively this position here is going to be a tuple that we pass in here and already this is going to be the most basic setup for sprite class and now you should be able to call this class inside of our main file and this could actually be a really good exercise that i want you guys to do two things first of all add one attribute to our game class that is called player and this player is going to be a group single that contains the player sprite and then in our run method i want you guys to draw this class and this should be somewhere on the screen it doesn't really matter where ideally put it somewhere on the bottom alright so first of all i want to create self.player in my game class and this is going to be pygame.sprite.group single and in here we have that our player although in my case i first want to create a player sprite and this is going to be player with a certain position let's say for now i want to place it right in the middle of the screen so 300 and 300 however if we were to run this player we would get an error because this doesn't exist in our file yet because we have to import it and well all i have to do is from player import player so we want to import this player file here and from this file we want to import this player and once we have that i want to put this player's bright inside of my group single and now we have a group single with one sprite inside so inside of our run method we can call self dot player and i want to draw this and i want to draw this on the surface screen which is going to be our display surface and now let me run the code to see if this is working and indeed there we can see our player so this is working quite well but now obviously we want this player to be at the bottom of the screen so instead of placing it in the middle in the y axis this should be 600 or even better this should be screen height and the xcoordinate should be screen width over two and now let's run this again there we go now our player is in the bottom middle of the screen for the simple reason that we have first gotten this green with and divided by two so it's going to be half of the screen and the bottom of the player is at this position here at 600 and since this is going to be the bottom border this puts our player also at the bottom border this is already a pretty good start so with that we can start working on the player input and this also happens in the class and let's call this one get input it needs self as usual but nothing else and in here we first of all want to get all the keys and for that we need pygame dot key dot get underscore pressed and now we can check different keys being pressed so if keys highgame.k right so we're pressing the right arrow down and if that is the case i want to grab self.rect and move it somewhere to the right and the amount i want to move it i want to defined in self.speed so when we initiate the class i want self.speed and let's say for now we can put this down to a five so whenever we're pressing the right button our player rectangle is moved to the right so the entire thing is being moved to the right now along with that we also want to do the same thing for pi game dot k left and this time it would be self.direct minus equals self.speed and with that we would have at least for now all the input we are going to need and next up i want to create an update method and in this update method for now we just call getinput and this needs to be self.getinput so now if i go back to my game class i can call self.player.update and this should be working so let's try and it is not working for the simple reason that this should not be the rectangle it should be rect.x because we're only moving in one direction but now let's try this again and now it is going to work so with that we can move our player left and right however there's one problem our player can move outside of the screen so that's not great and this could actually be a really good exercise for you to work on that i want you guys to figure out how to constrain the player to the actual window and this should happen inside of the player class let's start working on it and first of all our player has to know how wide the screen is so what i'm initiating the class here i want to add another argument and that is going to be the screen width and while we're at it i think it's also a good idea to determine the speed of the player in here so i'm going to add another variable for the speed so this is the maximum constraint of the player and this is the speed so with that let's go back and here we have to define a constraint and a speed and the speed is the easier part we just add speed in here and now i'm going to add another attribute that is going to be max x constraint and this one is going to get my constraint and now this attribute we can use to constrain the player and this i'm going to do by creating another method and let's call this one constraint and then here we don't really have to do all that much all we really want to do is to check the left and the right side of the player so if self.direct.left for example is smaller or equal to zero because that's our left side and if that is the case i want to set the self.rect.left exactly to zero so essentially what is happening here is that whatever our player is further to the left than the screen we are placing the player right on the left side of the screen and we can also do the same thing for self.direct.right if this is greater or equal to self.maxx constraint and if that is the case self.rect.right is going to be exactly on that point and that is literally all we needed to make this work so let's call self.constraint let's save the file and let's run our main game and let's try this again and there you can see this is working quite well that the player cannot leave the screen which feels much more realistic now with that part covered we can add the laser shooting mechanic of the player and this is going to be another part in our get input method and really all i want to do in here is if keys pygame dot k underscore space so we are pressing the space button then i want to run a method and let's call this self.shoot laser and obviously now we are going to need that method so define shoot laser needs self and nothing else however right now we can't really create the entire laser yet for the simple reason that the laser is going to be its own spread class that we simply spawn in here and we haven't created laser yet so we can't use it instead i'm just going to print shoot laser for now and we're going to change this in just a bit and let me save the file and let's test if this is going to work so now if i press space you can see in the bottom right that we are shooting the laser multiple times and this is actually one of the problems that we have to address that this laser needs a timer because if there wasn't a timer the player could simply keep on pressing space and shoot forever which would make the game very simple which we want to avoid so in our player class we have to add a timer and that is going to work with a couple of different variables first of all i create a variable called ready and by default it is going to be true then i want a variable called self dot laser time which is going to tell us when we have shot the laser and by default this is zero then i want self.laser cool down and this is going to be 600 so we will be able to shoot a laser every 600 milliseconds and we will only be able to shoot a laser if we are pressing space and if self.ready and every time we have shorter laser self.ready is going to be false so if i just have this setup we should be able to shoot at least once but not multiple times and now if i keep on pressing space we can't see anything but we have shot our laser once so this is working at least for now but we do want to wait to set ready back to true again and for that we have to add a little bit more here first of all i want self.laser time is equal to pygm.time.getticks so we are measuring the time since our game has started and now let me put it right below we need another method that i have called recharge it does not need any arguments besides self and in here we are first going to check if not self read d so if we have to recharge the laser if that is the case we want to check our current time and for that we need pygame.time.getticks the very same line we have used up here the only difference here is that this get ticks is only used once so we're getting one point in time whereas this get ticks here is being run continuously so we get multiple times and that difference is very important because we can use that very well and what we want to do is to check if our current time minus self.laser time is greater or equal than our self.laser cooldown and let me visualize this on a timeline so here we have the entire time of our game and let me use a different color for this that let's say on this point here we have our laser being shot and let's say hypothetically this is at 1 000. so this is our current time let's say at this point here we are going to be at 1 100 at this point here we are at 1 400 and then at some point here we are going to be at 1 600. and really all we are going to do is we are checking this time and subtracting our starting time from that and in this case this would be a hundred if we use this case here this would be 400 however if we get to this case here this would be 600 and as a consequence this if statement down here would trigger and that way we have a timer so if this timer triggers we want to set self.ready back to true and now obviously what we have to do we have to call self.recharge and that should be all we need for the timer so now let me keep on pressing space and you can see that we only get the laser ever so often so this is working really well and with that we pretty much have most of the player class ready there is very little we actually have to add to this the most important thing and let me minimize everything else is that we have to be able to create a laser and right now that doesn't exist so let's start working on the laser and the laser is going to be incredibly simple because at the end of the day it is literally just a sprite class with a position and a speed and really what we are going to do whenever the player presses space we are going to spawn a laser sprite in the position of the player and move it upwards and then later on we are going to use the same laser class to spawn it in the position of an alien whenever they shoot and then move it downwards but that's really all it does it's essentially a sprite class with position and a speed and well that's it so let's jump back into our code and let's create it here i'm back in my code i have main and player and i want to create a new class that i'm going to save as laser dot pi and here again we have to import pygame and again i want to create a class that i call laser and this one again has to inherit from pygame.sprite.sprite and here as always we need our init method needs self for now and we need super and then under init again and now first of all we are going to need self.image and self.direct as always and here we don't even have a graphics instead i just create pygame.surface so an empty surface and this i have set to width of 4 and a height of 20. and then for pygame.rect we get our self.image.getrekt and in here i set the center to a specific position and this position again i am going to get when we initiate the class and there's one more thing i would like to add and that is the image needs to be filled because right now it's black which wouldn't look particularly good and i just want to fill it with white and that again is a very simple setup for our laser so now i can save this file and go back to my player and now i want to import from laser import laser and now every time this laser shoot is being run i want to create one instance of this laser class and for that first of all i am going to need a sprite class so in the init method self.lasers and this is going to be pygame.sprite.group and now every time we are running shoot laser i want to get myself.lasers and add laser and now this is going to need a position and this position i can get from self.direct.center so literally all that's going to happen is every time we are shooting a laser we are creating a new sprite and the position of our player so now i can save the code and i can run the entire game and now if i press space nothing is going to happen for the simple reason that we are not drawing any of these lasers and that i would like to do in this run method because that gives me the most control over where stuff is being drawn and well all i want to do is self dot player dot sprite dot lasers dot draw and this has to be on screen and let me put it below the update method so we are separating updating and drawing and now we should be able to see the lasers so let me run off this again now i press space and now we can see a laser being spawned now obviously right now they're not moving upwards so that's what we have to work on next but we do have a start and this could actually be a really good exercise for you that i want you guys to add a little bit of code to move the lasers upwards so try to figure this out yourself alrighty let's try together so back in my laser class i want to set a speed and then this is going to be self.speed is equal to speed and now this laser is going to get an update method that we are going to get self.direct.y minus equal self.speed and really all we're doing here we are moving the rectangle upwards by a certain speed and since most of our lasers are going to move upwards we can add a default argument in here let's put it to negative 8 that i think looked good and now in our player class what we have to do is to update this laser so self dot lasers dot up date and now when we create our laser here we could add another argument but since we have a default argument we don't necessarily have to but by itself this should already work so let's try now if i press space nothing is working and that is because this has to be plus equals self.speed because right now we had negative 8 and we subtracted negative 8 so it became positive so our laser moved downwards but now if we have this for positive let's try this again now we have a laser that is already working really well so this is going quite well nice but there's one more thing that i do have to add here that right now these lasers never disappear so we have to destroy them once they leave the screen and let's call it destroy and all we want to check is if self.rect.y is either smaller or equal to negative 50 let's say or if self.rect.y is greater or equal to the height of the window so this would be 650. however i want the game to be flexible so we can make it larger so we need to get this number and this has to be another argument so screen height so self thought let's call it height y constrained and this is going to be screen height and then in here self dot height y constraint and let's add 50 just to have a little bit of wiggle room and if that is the case we have to run self.kill to destroy the sprite entirely and don't forget to actually call the function so self.destroy in our update method and now when we create a laser we have to add this argument as well so and here when we create our laser let's say now i want to go with negative 8 for the speed and in here we do have a minor problem now for the y constraint because we didn't actually pass that in we only have the x position however what we do have is the bottom of the player so this self.rectangle we just want to get the bottom so self.rect.bottom and this is actually a fairly realistic way that whenever the laser is below our player we want to destroy it which i think does start to make sense and well that should be it let's try to run the game now and oh well we have a nondefault argument follows a default argument so let's get rid of this negative eight and now it works our laser still works you can't really see the laser disappearing but now our game should not spawn infinite lasers so this is going to help our game be slightly more efficient and with that we have both our player and our laser and that's literally all we have to do for both of these later on we are going to do a bit with collision but that happens inside of our main class not inside the player or the laser and that means we already finished a major part of this game now with that covered we have two topics to address one is the placement of the aliens and number two is the placement of the obstacles and they are independent of each other so it really doesn't matter which one we are going to start with and both of these are done in very similar ways so if you understand one you probably are going to understand the other fairly easily and let's start with the obstacle i think that is going to be the easier one and let me first explain how the obstacle is going to work and here you can see one of the obstacles on the screen and it looks like this is one solid figure but that actually isn't the case instead this obstacle consists of individual blocks and each of these blocks is a sprite and really all i have done is i have arranged all of the sprites in such a way that they look like the obstacle but that is literally it all that you are looking at is a couple of square shaped sprites in a certain shape so we have to figure out how to create this kind of shape and for that we are going to need a nested for loop with the enumerate method so let me explain how this is going to work and here is how this would look like in code at least in a more generalized way essentially what we are going to have is a list with strings inside and each string is going to be one row of our obstacle and this would be our first for loop and here we use the enumerate method to figure out on which row we are on and then a nested for loop is going to look at each individual column inside of this row and again we are going to use the enumerate method to figure out on what column we are on and if you combine these two enumerate methods you get a grid with specific positions so for example the top left would be zero and zero and to the right of that we would have one and zero and to the bottom of that we would have zero and one and this we can then use to place elements on the screen and we can even make this more flexible by adding offsets for example to move all of the shapes in a certain direction but that's literally it it really isn't all that hard when it comes down to it but alright that again was a lot of talk so let me actually implement and let's create one obstacle and once we have that we can create multiple and here we are back in the code and the first thing i want to do is to create a new file and i want to save this one as obstacle dot pi and here again we need to import pi game and in here i want to create a class that i call block and this one again is going to be a sprite so we need pygame dot sprite dot sprite now we need the usual init method with self and nothing else and then we need super down there in it for this one as well so everything works well and now we have to create self.image and self.rect and for the image literally all i want to get is a surface and now we have to figure out the size of the surface and i want to set this from our main class so what i'm going to do is when i am creating this class i'm going to set a size and since we want squares the size for x and y is going to be the same so we put size in both of those so with that we have our surface now next up before we get to the rectangle i want to fill the rectangle with a color and this color i also want to set from the main class so i'm going to place this also as an argument or parameter and then finally direct itself.image.getrekt and here i want to place the top left and the position i do not know yet so this is just going to be x and y and usually for this position here i use a tuple so for most other classes i just write pause but in this case i want to have specific control of x and y which is why i'm going to separate them by each variable you're going to see in a second why that is helpful but well that's just going to be another parameter for x and y and that is literally all that we needed so this is going to be one part of our obstacle now there's one more thing we need outside of the class and that is the actual shape and this is going to be a list with strings and in my case let me just paste it in it looks something like this so let me explain how this shape is going to work in here we have lots of strings and there's two options we either have an x so for example this one or we have a space so let me use a different color that here you can see a space all we are going to do at the end of the day is wherever we have an x we are going to create a block so for example this x here is going to be a block this x here is going to be a block all of these x's are going to be a block and if there's a space so like this area here there's not going to be a block and that way we're going to recreate this shape as sprites and for that we are going to use the function i explained earlier but this is literally all we needed from our class so now i can save it and go back to my main file and first of all i have to import my obstacle file and now before we get into an actual method to create all of this we have to create a couple of basic variables and let me actually add a couple more comments to be a bit more specific so let's call this one player setup and below that we have the obstacle set up i should really use comments more regularly but alright the first thing i want to do is to capture the shape of our obstacle so self.shape and this is going to be obstacle dot shape so literally this thing here and that is just to make it a bit easier to work with inside of the game class now next up i want to set myself dot block size and i set this to a six so this is the number we are going to pass in here later on and finally we want to have a group that collects all of these sprites we are going to create in just a bit and i've got this one blocks and for now this is just going to be pygame.sprite.group with nothing inside and that is all we need for basic variables now we have to create a function that creates one obstacle and well let's call it create obstacle and for now we are not going to pass any arguments inside of this but we are going to pass some in just a bit and now we have to use the function i talked about earlier so what we want to do is we want to loop over this shape here so let's start with for row in self dot shape and each row in here would be one of these rows now the problem with just using self.shape is we wouldn't know on what row we are on and to get that information i want to get the enumerate method and what this one does is it returns an integer on what index we are on so for example this would be the index 0 this would be the index 1 the index 2 the index 3 and so on and this is the information we are going to use to set a certain information for our height orbital for our row so once we have that we know on what row we are on now next up we have to figure out on what column we are on and well for that i'm going to approach this in a very similar way so we have call index and call in enumerate and this is just going to be row so let me explain again what we are going to do so let's say we are currently on the first row so we are in here now each of those items is going to get one index so this would be zero this would be one then this one here would be two and then this one here would be three and by using these enumerate methods we get the specific positions of each of these x's for example this x here would have the index 0 and 0 whereas this index here would have the index of 0 and 2 i think and this is the information we need to place something on the screen and all right this is all we need to find the position now obviously what we want to do is an if statement so if the column is equal to the letter x because we want to ignore all the empty spaces and well now we have to figure out the x and the y position and once we have that we can create one block that is going to be obstacle dot block and now in here we have to add a couple of arguments so let me copy them really quick so we can work through them one by one and the size we already have it's literally just this one up here so this one is the easiest one to get we just want to get self dot block size next up the color is also very easy because i have a tuple that i want to use here and the tuple i want to use is this one so this one is pretty fine and this is a reddish color that i think looks quite good now finally we need our x and y coordinates and those we are going to create now and this could actually be a really good exercise for you try to figure out what we have to do for x and y to place each block in the right position so for x we obviously have to look at our columns so this part here and the first we need is to get our call index so this will give us a number from 0 1 2 3 4 and i think the maximum column we have is 11 so the highest number here will be a 10 and the lowest is 0. and this would then be a start however we don't just want to move the x by 1 pixel we want to move it by the size of each block so each block starts after the previous block has ended and well for that all we need is to multiply the index by self dot block size and well that's literally all we need to get this thing started now for y we are going to do basically the same except now we use the row index but we're still going to multiply by self.block size and well with that we have our basic block now the final thing we have to do in here is to get our self.blocks and add the block we have made to it and that is already going to be a really good start now what i want to do is when we initiate the class i just want to run self.create obstacle and then in our game method i want to get myself dot blocks and draw all of them on the screen and let's just see what happens and there you can see in the top left we have our first obstacle so this is actually already working now obviously the obstacle isn't supposed to be in the top left so that's something we do have to work on but well it's a good start so what we have to work on now is to offset all of this to place all of them a bit further down and well that isn't all that difficult because literally all i want to do is to set an x start variable and a y start variable and then every time we are placing either the x or the y we want to add this number towards them so x start plus all of this or y start plus all of this and now when we create our obstacle we can pass a number in here let's say for x we can start with 40 and for y i think i went with 480. and now let's try this and we are getting an error because i made a typo there we go this is looking much better so now we have one obstacle doesn't do anything yet but that we're going to cover later on but this is going to be our first obstacle so alrighty with that we have our first one and now what you could be doing is to run this function four times and figure out the positions by yourself and that would be an approach but not an approach i would like because that seems like a lot of writing instead what i have done is i created another function and this i have called create multiple obstacles and first of all here we are going to need self then besides that i want to pass in the x start and this would be the same x start we have used here i just want to be able to call it from this function because literally what we are going to do is i'm going to call this function only inside of this method here i am not going to call it inside of the init method directly and i also want to do the same for y start and next up i have to get some kind of offset so i have to know what the distance between each of the obstacles is going to be and in my case i don't actually know how many obstacles i am going to have so i want to use a parameter that i can later use to add as many arguments as i want and this is going to look like this i use a star and then offset and that's called another packing operator and that's going to be super useful and now what i want to do in this function is for x in offset so all the arguments we are going to pass in here we are going to loop over and then in here we are going to run self dot create obstacle and now we have to pass in a couple of arguments the first two are the easy ones because we already have our size and our color so for now we have to figure out these two arguments to pass in here and well they're not that hard because we already have x start and we have y start but now there's one more thing we have to do that we have to get the offset in here as well so what i want to do is to add my x variable in here as well so the one we have just looped over but for that to work we have to add another argument in here and that i called off set x and actually let me name things properly so instead of for x is offset x and then we place all of this in here so this should make this a bit easier to read and with that we have the two functions we need to make all of this work so now inside of my init class i want to create multiple obstacles and again let me copy the parameters we need to work through this one by one first of all we will need the x start and let me just place a zero in here so we start the left side of the screen for y start i just want to go with 480 because i think that number worked quite well and now for the offset for now let me just place in a couple of random numbers so let's start with 0 then 100 and then 200 and there's one thing i did forget and that is this line here that i want to add my offset x and let me quickly go through this line because that is the really important one so essentially what happens in here is this line is the really important bit because this is what we are going to use to check what position we are on inside of our shape and then we are going to offset this position twice first of all we are going to get a start position so this is going to be how far we are from the left and then plus that we are going to create another offset and this ensures that if we have multiple obstacles they're not all on the same position because if we didn't include this line here they would all be on the same position but we want to use this information here to offset each obstacle so the first one is going to start at 0 but then the second one is going to be 100 pixels further to the right and the next one is going to be 200 pixels further to the right and that way we can get all of our obstacles so let's try this and we are getting an error message because i made a silly mistake that this here should not be in a tuple it should just be numbers by themselves because this offset already places them in a tuple so now let's try this again and now we can see all of our obstacles obviously not in the right position and we are missing one but we can work on that and i think right now this line here is very difficult to read so instead i want to use named arguments in here but we can't use positional arguments after named arguments so i want to move this x start and y start after the offset so i also want to move those two to the end and now i can call them x start and i can call them y start and all the stuff with in the beginning is just going to be the offset and let's try this again and it's still working just fine so now what we do have to figure out is how to space our obstacles in the right amount and this again i want to be flexible so we can make the screen larger or smaller and it shouldn't really matter and i also want to have flexibility over how many obstacles i am going to have so i'm going to add another attribute that i called obstacle amount and i just went with four and now with that information i'm going to create another attribute that i have called obstacle x positions and now we have to figure out how to get these positions here that space out the entire screen and let's start building this thing up step by step so first of all i want to get num for num in range and this is going to be self dot obstacle amount so for now we would get a list of the numbers 0 1 2 and 3 because our highest number is 4 and we're just looping over it and well all we have to do now with that is to multiply that number with our screen width divided by self dot obstacle amount and that is a slightly longer line now but let me go over what's going to happen here we're going to start with this number and this number is either going to be 0 1 2 or three and for the sake of an example let's assume that this number here is two then we're going to multiply all of this with screen width divided by obstacle amount and screen width in our case is going to be 600 and obstacle amount is going to be four and if we divide one by the other we get a hundred and fifty and if you multiply this by two we get the position of 300 which is exactly in the middle of the screen and then let me use a different color if we had three in there we would also multiply this by 150 and we would get 450 so a nice offset to the right and well with that we can just pass in self dot obstacle x positions in here however right now this would not be working because this is going to be a list and we just have to pass in individual numbers so what i have to use again is the unpacking operator so this star here means that we're going to unpack this list straight away and well let's try this and now we are getting much better so now we have all of our obstacles nicely spaced out so now the final problem is that we have no offset on the left and well for that we have our x start not this one we have this x start or this one here that is zero for now and for this one i gotta be honest i was a little bit lazy because all i did i went with screen with divided by 15 and if you run this it kind of looks okay i'm not sure if the math is entirely correct you would have to look at it in a bit more detail but i think this looks good enough but this probably isn't pixel perfect but i think this works just fine so with that we have our obstacles and now we can use that knowledge to place all of our aliens and this is also going to happen with a nested for loop that uses the enumerate method i'll buy in a slightly different way but the broad strokes are essentially the same and well there's not much point explaining all of this in too much detail let's implement it straight away so here i am back in the code and the first thing i want to do is to create a new file that i am going to save as alien dot pi and in here again i want to import pi game and create a new class that i have called alien this one again is going to be a sprite so we have to do the inheritance thing we need a niche with a space in between it needs self for now and then we need super and under init all right and again we need an image and we need a rectangle and in here each image is going to be a graphic we are going to import so what we first have to figure out is a file path so let's just call it file path and here's what i did whenever we create an alien we have to specify a color so this could be red yellow or green and then in the folder i have named each file either red green or yellow and what that allows us to do so i go up a folder and then i go to graphics and then i am going to add my color to it and then i'm going to add the file ending with dot png so if i were to write the string right in here we would get graphics slash red dot png which is exactly what we need for our file path and that way i don't have to work with different if statements and our code stays nice and clean and now i can use that file path to use pygame dot image dot load add in my file path and then convert alpha the same thing we have seen so many times by now and then for the rectangle i want to get myself dot image dot get wrecked and here again i want to place the top left and this again is going to be x and y so we have to add x and y in here as well and that is going to be our basic alien so this is a pretty good start and all right so with that we can return to our main file and start working with the align and first of all for that we have to import it so from alien import alien and now in the indent method i want to create a couple of basic setup points so let's add a comment with alien setup and in here for now i am only going to need a single thing and that is self.aliens and that is at pygame.sprite so all the aliens are going to be in this group and now with that i want to create a function that is going to create all of these aliens in a specific position and i call this alien set up and now let's create this function so def alien set up and for now we are only going to use self and now let me actually open the create obstacle function as well because we are effectively going to do the same thing we have done here so again i want for row index and row in enumerate and now i want some kind of row or let's call it rows for now and in there for call index and call in enumerate and for this one we want to figure out how many columns we have or calls and now we have to figure out how many rows and how many columns we want to have for our aliens and well that's going to be parameters so let's start with rows and with columns so whenever we call the function we have to specify that information and once we have that we have to again create an x and a y variable and once we have that i want to create an alien sprite that is going to be alien and let me copy the parameters we need so we need color x and y and the color is the easiest part because i have a couple of predefined ones so let's start with red and then we need x and y and once we have that i want to get myself dot aliens and add the alien sprite so now we have most of the stuff we need we just need x and y and this could actually be a really good exercise for you try to work through the logic here and see how you can use this to place the aliens on the screen and most importantly try to think about what bits of information you are going to need to enable all of this let's start with x and in here as always we are going to need our call index and the same for y we need our row index so this would give us numbers in the single digits which is well not great yet actually let me pass in specific numbers and for the rows i went with 6 and for the calls i went with 8. so this means this call index is going to be from 0 to 7 and then the row index is going to go from 0 to 5. so let's just see how this would look like right now and all we need to do for that is in our self.run function i also want to get myself.aliens.draw and do this on the screen and now let's run this code and we get an error message because this rows and this column has to be in a range function so let's put this inside of range and now let's try this again so now in the top left you can see a reddish blob and this is not an obstacle this is an alien the reason why it is looking so weird is because we have a couple of aliens on top of each other with an offset so this is what we have to start working on and here it really helps to look at our earlier grade obstacle function because for this one we had essentially four bits of information we had the column index then we had the size of each block we had the starting position and we had the offset so four pieces and right now we only have one we have the column index so we have to add a couple of bits of information here and there are two major things we need the first one is the size and the other part is the offset and we don't really need a start variable because our aliens are going to move on the screen anyway so it doesn't really matter where they are going to start but we definitely need a size and an offset both for x and y so this is what we have to create and essentially what that means is we have to create a few more parameters and the first two we need is x distance and y distance and literally all i want to do is to multiply each side with the distance we need so x distance and y distance and i think it's a good idea to add some default parameters in here so let's say for the x distance by default this should be 60 and for the y distance this should be 48 and now let's try this again and now this is looking so much better so now we have an actual proper grid and if you had more columns or more rows you could make this more dense or more widespread it's up to you but now the obvious problem is that all of our aliens are starting in the top left so that means we have to give all of this an offset so we are going to need an x offset and we are going to need a y offset and then literally all that we are going to do is to add plus x offset and plus y offset and here again i'm just going to give it some default parameters let's say for x offset we're going to go with 70 and for y offset i put in 100 and now it stress again and there we go now we have our aliens nicely set up on the screen still don't do anything but that's going to come in a second and with all of the default arguments we can have our alien setup function nice with a couple of rows and columns and we don't end up with a ton of arguments in here so this is working quite well but now we have another problem that right now all of our aliens have the same color so that's not exactly what i want and instead for different rows i want to have different colors for each alien and for that we are going to need a couple of if statements and here again the enumerate method is going to help us enormously because this is going to tell us what row we are on for example if we are on row 0 this one is going to tell us we are on row 0. so this is super helpful and this is what i need in my if statement so if row index is equal to zero so we're on the top row and if that is the case i want my alien sprite to be yellow now if that is not the case and my row index is between one and two then i want to create an alien sprite that is an alien with the color green and we again are going to need x and y those stay the same and now for all the other rows so else i want to create an alien sprite that is going to be alien with the color red and again with x and y and now let's try this and there we go now we have nice colors and let's go through what actually happens here and the really important line is this one here because this one is telling what row we are on so this row here would have the index 0 this row would have the index 1 then 2 and 3 4 and 5. and this is the information we are using down here that if we are on row zero so this one here then we want to create a yellow alien however if we are between one and two we are on those two so we want the green alien and then for any other case so three four and five we have the else statement so we create a red alien and well with that logic we have all of our aliens so this is working really nicely and with that we have our basic alien setup so now we can close this method and not worry about it ever again but now the problem is that our aliens are static so that's not particularly helpful and to move them we have to go back to our alien file and in here i want to specify an update method and this one itself and it will also need a direction and really what i want to do in here is self.direct.x plus equal direction and now we can use this function to update all of the aliens so if i go back to my main function i can let's add all of the update methods right at the beginning so self dot aliens and now here we have to specify how fast our aliens are going to go and this i think should be an attribute of the game class so let's call itself.alien direction and this we are going to create in our init method let's place it here self dot alien direction and by default it's going to be one and now let's run this and now we have all of our aliens moving to the right obviously they don't stop but that's fine so now what we have to figure out is if any of the aliens is on the right of the screen we want to change this number to negative one so all the aliens are moving to the left instead of the right and this is going to be another function over method and this i called alien position checker and here's the logic that's going to make all of this work essentially we're going to cycle through every single alien and if any of the aliens is too far to the right we are going to change the direction of all of the aliens and then the same if any of the aliens is too far to the left or smaller than zero then we are also going to change the direction again so first of all we have to get all aliens and this is going to be self dot aliens dot sprites and don't forget the brackets here they are really important we are calling a method and now we can look for alien in all aliens so this way we can look at all the sprites individually and this could be a really good exercise for you that inside of this for loop you can access direct of each alien so use that in an if statement to change the direction if any of the aliens goes outside of the screen either left or right let's start with the right side so if any of the alien dot rekt dot right so the right side of all the aliens if any of those is greater than the screen width and now inside of this function all i want to do is to get myself dot alien direction and set this to negative one and well this should now be working so in our run function we can call self.alienpositionchecker and don't forget to call it and now let's run this and there we go this is working obviously we don't have a left side so there they keep on going forever but this we can work on now because all we need is an l if statement that checks if alien.rect.left is smaller or equal to zero and if that is the case myself.alien.direction is going to be one and now aliens go left they go right and all of this is working super well cool so with that we have our left and right movement but this is only part of the movement because what i also want to achieve is any time our aliens hit either the left or the right side i want to move them downwards by a couple of pixels and that is going to be another method and i have called this one alien move down and in here i want to move for alien in self self.aliens.sprites so kind of like what i've done up here i just check all of the sprites and literally all i want to do is to get my alien and get direct and y so the y position and just that plus equal a certain distance and this distance i'm going to specify every time i run this method and there's one thing i would like to add in here and that is i want to add all of this inside of an if statement and the if statement is going to be if self dot aliens so this is only going to be run if they are aliens inside of the alien class and the reason for that is if the player shot down all of the aliens so they all disappeared we don't really want to run this anymore because it would cause an error so this is a nice way to make our code a bit less buggy but right so with that we have a distance and now we have to call this method every time our aliens hit either the left or the right side of the screen so in here self dot alien move down and the distance i moved them down was two and this function you have to call for both if statements then well let's try this and this is working quite well so now the aliens are moving down so with that we have covered all of the movement of the aliens now the last part we need for them is to give them the ability to shoot lasers and well that's going to be just another method that we are going to call once in a while and let's call it alien underscore shoot and it only needs self as always and let me minimize all the other functions because they start to get a bit annoying and that feels much better and in here i first want to start with the same if statement we used for alien move down that we only want to run this if there are aliens inside of our aliens group and if that is the case i want to select a random alien first so i want to get a random alien and for that i need the random module so all the way at the top i want to import from random import choice and this choice we can then use down here to pick one alien and this happens with self.aliens.sprites so this line here literally just selects a single alien out of all of our aliens and this we are going to use for the x and y position of the laser and we still have our laser from earlier so we can use the position the speed and the screen height so let me copy all of the parameters and let's create a laser sprite this is going to be laser and let me pass in all of the arguments we are going to need and since we're using laser we also have to import it so from laser import laser and in here we have to figure out the different arguments although screen height is literally just the screen height we have specified down here so this one is already covered next up for the position all we need is random alien dot rect.center and then we are going to need a speed and for the alien lasers i went with six but this number is basically random so now we have a laser and in here we have to figure out on what sprite group to add it and there's going to be a minor problem because we already have one group for lasers and that is this one here and this laser is inside of the player and we couldn't just add these lasers to this group here for two reasons mostly first of all it wouldn't really make sense that is bright class inside of our player shouldn't be used for the alien lasers although that is more for the logic of the code itself it would technically work however the second reason would be more important for the game itself that this laser has to be in a different group than these lasers because later on we are going to check collisions that if any of these lasers is colliding with the player and if we had to put all the lasers in one group we would cause the player to be hit every time the player spawns a laser because the laser is drawn right behind the player so this laser sprite has to be in a separate group and well what that means is that we have to create another group so self dot alien lasers and pygame dot sprite dot group and let me put it right below the other group and this is what we're going to add the laser to so self dot alien lasers dot add laser sprite and i hope the logic here makes sense that the lasers from the player and the lasers from the alien have to be separated for the simple reason that we are always spawning the laser right behind the relevant sprite so if we were to spawn a sprite right behind the player and then check for collision between all lasers and the player we would always hit the player so this would make the game unplayable and that's why we need two different groups for our lasers however now we don't really want to call this function all the time oh actually let me call this function all the time and let me demonstrate what's going to happen so self dot alien shoot then we have to self dot alien lasers dot update and then we have to draw all of the lasers so self dot alien lasers dot draw and on the screen and now if i run this you can i think see why this wouldn't be particularly fair or well it would be a little bit of a difficult game so we don't want to run the alien shoot all the time we want to have a timer in between and that is going to happen down here that we want to create a timer and this happens with let's call it alien laser and here we have to create pygame a user event plus one and then pygame.time.set timer and now we want to get the alien laser and now i want to set the time how often this is going to run i went with 800 milliseconds so we have one laser shot about once a second but again you can make the game more difficult if you reduce this number and now if event dot type is equal to the alien laser only if that is the case i want to get my game and run alien shoot so we don't run this method inside of our run function instead we only run it inside of this timer and that we can now run and now we only have a laser that looks much more reasonable we still don't have any collisions but that we can start working on but before we are going to start working on that i want to add an extra alien because a key part of space invader is to get a high score and in the original game there's this top alien coming once in a while at the top of the screen that you can try to hit for extra points and this alien i also want to include and for that we have to create another kind of class in our alien file and this i called class extra this also has to be a pygame.sprite.sprite and as always it needs a init method then we need a super init method and then we're going to do a self.image and a self.rect and to get the image we can just use the usual pygame.image.load and the file path is this one and then convert alpha as always so we are just going to import a graphic for the image but now the rectangle is going to be a little bit more difficult because this extra alien is supposed to ever come in from the left and go to the right or coming from the right and go to the left so what i want to specify is the side this thing is supposed to start on and now we have to add an if statement in here that if side is equal to right then i want to create an x that is the screen width and right now we can't access the screen with so this is going to be another parameter so screen width and this is going to be screen width and let's say plus 50 just for some bit of wiggle room and if we are going to write anything other than right we assume that the extra alien is supposed to start from the left so the x can just be minus 50. and now we have all we need for the rectangle so self.direct is going to be self.image.getrekt as always and in here i want my top left to be x and then for y i just went with 80. and this code would either spawn the extra on the left or the right side of the screen depending on what we specify in here but if we were to add this extra to our aliens we wouldn't see it because it's outside of the screen so instead i want to add a speed to it so let's give it an update function that is going to get self.rect.x plus equals self.speed so this speed is ever going to be positive or negative depending on what side we are spawning the extra alien so we have to specify it so this would be self.speed is equal to let's say negative three and then if we're moving to the right self.speed should just be free and that way if our extra alien is on the right side of the screen so this one here we are moving it to the left and if it is on the left side of the screen we are moving it to the right and that way you should be able to see it once we spawn it in the game so with that i can return to my main file and now you might be tempted let me go up you might be tempted to add the extra alien to this aliens.group but that would not be working actually let me go back and tell you why because this alien sprite has a specific update method because here we are changing the direction of all of the sprites and also in the alien move down function we are moving down all of the aliens inside of this group and this is not something we want to do with our extra alien it's just supposed to stay on the top so we couldn't really add the extra alien to the self.aliens group it just wouldn't work so instead we have to create another group and i just called this one self.extra and since we only ever want to have a single one of those on the screen this could be a group single and i guess we can move this to its own group that is a bit easier to read let's call this extra setup and now this extra alien i only want to spawn ever so often and i want to keep this one inside of the function itself although you could also add another timer to it that will also work but in my case let's do a couple of different approaches so what i want to create is self.extra spawn time and for this i just want to get a random integer let's say between 400 and 800 and for that we need to rent in method so at the top i want to get my from random import choice and rent int so now let's say this number could be 600 and literally all i'm going to do is every time we are running this after the run method we are subtracting a certain amount from this number and whenever it hits 0 we are going to spawn an extra alien so for that we have to create another method and let's call this one extra alien timer needs self and nothing else and now i just want to get myself dot extra alien spawn time minus equal one and then if myself dot extra spawn time is smaller or equal to zero and i want to get myself dot extra group so this group single and add an instance of the extra to it so this would be extra and in here we need two bits of argument we first need decide and then we need this screen width unfortunately the screen width we already have that one's easy but now we have to get the side and this one is just going to be choice and into choice we have to pass in a list that is either right or left and then finally we have to run this function in there again so we set up a new timer for the extra spawn time so essentially what happens in here is we start with a number up here and we get an extra spawn time number and let's say for the sake of the argument for now this is going to be 600 then inside of extra alien timer we're going to reduce this number by one so if we run this once we get to 599 then 588 and so on and eventually we are going to hit zero and if we hit zero we're going to run this if statement and what we're doing there on the first line is we're going to create an extra alien that whatever spawn on the left or the right side and well then we give it a screen width to tell when it's supposed to disappear and well that's all we really have to worry about in this instance and then we are going to set a new random integer so now instead of 600 let's say we could get 520 so now the next extra alien would spawn a little bit faster so the only thing we have to worry about now is to actually calling this function and let's also place it right down here so self dot extra alien timer and now before we are going to call it i forgot that we have to import it so we are from alien import alien and extra and just to test this i am going to set the spawn time for the first spawn between 40 and 80 so we don't have to wait for too long so now let's try this and oh right we're not going to see anything because we are not drawing this extra alien so in here we have to get self dot extra dot draw this has to be on the screen again and then we have to update it as well so self dot update and now let's try this and there we can see it we have a nice little extra alien on the top and if i wait a tiny bit longer this should reappear at some point there we go and now at some point we should also get one that comes from the left i think we just got not very lucky for now and yeah there we go so this is also working very well cool so with that i can minimize this function as well and we are making some really good progress so now we have all the players all the obstacles and all the aliens now we have to work on the collisions to actually turn this into a game and the collision function is going to be the longest part of this game however it's not particularly complicated because all we are really going to do is we check different sprite collisions so for the laser sprites we check with the obstacles and the aliens and for the alien lasers we also checked with the obstacles but now with the player so it should be a fairly straightforward thing to work on so let's jump into the code and let's have a look at this and here i am back and it is getting quite extensive but right at the bottom i want to add one more method and this one i just called collision checks it needs self and nothing else and now in here we have to check a couple of things and let me start with the player lasers that is probably going to be the most interesting one and first of all i want to check if there are any lasers from the player so if self dot player dot sprite dot lasers and if that is the case i want to look for laser in self.player.sprite.lasers bit of an extensive thing but well and let me spell this properly as well that tends to help and now i want to check for two different things if either of these lasers connects with the obstacle or with the aliens and let's start with the obstacle collisions and really all we need in here is if pie game dot sprite dot sprite collide and then here we want one sprite that's the laser then i want to have myself dot blocks so each block of the obstacle and then i need a third argument and that's the do kill and this one should be true because we want to destroy this block as soon as it collides with the laser and for now inside of this if statement let's just call laser for now and don't forget to run this function so we can test it properly so self dot collision checks and now let's try this and now you can see that this is indeed working and we can destroy the obstacles now obviously this isn't working as intended because our laser doesn't disappear and keeps on going and destroys all of the obstacles but this we can change very easily because all we have to do is we have to get our laser sprite and run kill on it so essentially what's going to happen here is when this if statement runs it destroys the block it's colliding with and then if that is the case we are also going to destroy the laser right inside of the if statement and if we do that now we have a well a pretty well working laser with the obstacles and you can keep on destroying individual parts and then use this in the normal way so this is literally all we needed to make the basic laser work for the player and the obstacles now next up we need the alien collisions and well for now we can just copy this entire line and change self.block to self.aliens and well that's all we have to make for change so now let's try this and we can also destroy the aliens so this is also working quite well although later on we are going to make some changes to this line when we add the score but that comes later and then we need the final one and that's the extra collision and here again i can just copy this if statement and change this to self.extra and now okay this is going to be very difficult to hit but i am quite confident that it is going to work but well in an actual game do test this a bit more but right so with that we have our basic collisions for the player now next up we have to do the exact same thing for the alien lasers and this could be a really good exercise for you that i want you guys to create the collision logic for the alien laser colliding with the obstacles and with the player i first want to check if there are any alien lasers so if self dot alien lasers is the case and if that is the case i want to loop over all of the lasers so for laser again in self.alien lasers and now for the obstacle collision i can literally just copy this line here and well that's all we had to do and let's try this and let's open alien hits and obstacle and yeah there we go this is working indeed cool now we can copy this if statement again and now we want to check the laser against self dot player and this one has to be false because we don't want to destroy the player and then here you could close the game but for now i'm just going to print dead so let's try this and let's hope i can get hit there we go this is working quite well and we can be hit by aliens so with that we have the collisions for all of the lasers and this actually wasn't all that bad although well we are going to make some additions to this but there's one more collision that we are going to need and that is between the aliens themselves and the obstacle blocks and then i guess with the player as well although if an alien collides with the player we are going to game over immediately anyway but we do have to work with that so let's call this one aliens and in here i just want to check if self let me scroll down if self.aliens so if there are any aliens on the screen i want to check for alien in self.aliens and now again i can again check this same line except now this doesn't have to be an if statement because we don't want to destroy the alien we just want to destroy the block and this shouldn't be laser this should be alien but we also want to check if an alien collides with the player so let me copy this line here so if pygame.sprite.sprite collide and we want to check between the alien and the player and if that is the case i guess then we can close the game so pygame dot quit and sys.exit and this is going to be kind of annoying to test because we would have to wait quite a while so just for now for our alien position checker i want to set the speed to negative 10 and plus 10. so now they should speed up quite a bit now our obstacles disappear and we go to game over once the aliens collide with the player so this is working cool so this is actually all we needed for the collisions wasn't actually that bad and with that we essentially have a game although not a very good game yet because we want to add a couple more things and i think the most important one for space invaders is to add a score and a live system so that's going to be what we start working on now and let's start with the lives that i guess is the easier one and i think this is best approach by just going straight into the code and going through this one by one so let's start with that so here you can see the main file again and i want to work on my knit method and in here i want to add another section and let's call this one health and score setup and in here we have to specify a couple of different things since we are starting with the lives i want self.lives and i want to have three different lives and since i want to display all of these lives as the player in the top right i also need a surface so let's call this live surface and for this we need pygame dot image dot and this is going to be the same file we have for the player this one here and then we have to again convert alpha all of this and there's one more thing that we need and that is going to be live x start position so effectively we want to place all of these lives in the top right of the screen but for that we have to know how far of an offset we need from the right side of the screen and this is what this is going to be for and in here i want to first get my screen width and from that i want to subtract a couple of things and basically what i want to get first of all is self dot live surface dot get size and this should be zero so effectively what we're doing here we are first getting our live surface so the thing we have literally just imported then i want to get getsize and this is going to give me an x and a y parameter and from that i only care about the x part so i'm going to get zero so this will ultimately get me the width of my live surface that's literally all this does so this would give me the width of one player live but i don't just want to show one i want to show two and then along with that i also want to have an offset and that i have just set to 20. and now we have a somewhat reasonable offset from the right side of the screen that we can use so with that i can close the init function and create another method all the way at the bottom and let's call this one display lives it doesn't need any arguments and in here i want to loop over my life so for life in range self dot lives however here i only ever want to display my lives minus one so let me explain what this does essentially i want to have the ability on the top right to either show two lives one lives or zero lives left but with zero lives we are still alive we just can't see any lives in the top right anymore and this is i think how the original space invaders also worked and this is why i want to have the minus one that we still have one life left but we can't see it in the top right because it's our last life so i hope that makes sense and really all we want to do in here is to use screen dot blit we want to get myself dot live surface and now we are going to need an x and a y position the y position is the very easy part so we just need eight it's a random number i have chosen because it's very close to the top but for x i'm going to put this in its own variable and first of all i want to get the left side of my starting position so self dot live x start position and that is the variable we created up here this one so this is going to tell us when our lives should start on the left side but we don't want to place all of our lives right on there so we have to add something to it and what we have to add to it is going to be for now our life so this one here and this right now would either be zero or one but with this by itself we would only move it by one or two pixels so this wouldn't be good enough by itself instead we have to multiply it by the width of the player live so again we have to get self dot live surface get the size again and again zero and this will place both of the lives right next to each other and i want to have a slight offset so let's add plus 10 to it and this should give us all of our lives so now in our run method self dot display lives and let's see what's going to happen and we are getting an error message and the reason for that is up right here getsize is a method so i just forgot the brackets and since i'm calling get size again down here you also have to add it in there now let's try it again and now this is working although the top right is a bit too close to each other and this we can avoid by putting those two inside of a bracket and now stress again and this is looking better so now we have a live system now the problem is it doesn't really work with our collisions so this is what we have to work on now that every time our players sit i want to reduce our lives by one so effectively we have to go back to our collisions and in here the important part is this if statement that i don't want to print that anymore instead i want to give self dot lives minus equal one and what we can also do while we're here is if self.lives is smaller or equal to zero then we want to end the game so pygame dot quit and says dot exit and let's try this so i hope i can get hit there it's reduced by one now we have just one life left and now you can see we can't see lives on the top and now if i get hit again we are dead so this is working very nicely and with that we have our live system now next up i also want to add a score to all of this and for that we have to make a couple of changes to a few different things we have to update our collisions and we have to update our aliens so they all have a certain kind of score so i guess let's jump straight back into the code and let's have a look at this so here i have my entire setup again and it is really getting quite extensive but for now i want to work on my init method again and in here i want to add two more attributes the first of all is self.score and by default this is zero and besides that i also want to have a font because now we have to display some text and for the font i need pygame.font.font and the font i am going to import is also in the folders and the file path towards that is this one and the font size i went with was 20. so now we have a font that we can use and that's all we needed in the ended method and now we can create another method that i have called display score it needs self and nothing else and in here we have to do three different things we have to first get a score surface so we have to render the text then we have to get a rectangle of that surface and then we have to put both of these on the screen and this could be a really good exercise for you that i want you guys to create this display score method and use it to display the score 0 on the screen for now ideally in the top left but well wherever you really want it to be all right so first of all i want to create a score surface and for that we need self.font.render and i want to create an f string that says score and then we get our self.score and for the antialiasing i want folds since we're using pixel art and for the color i just went with white and with that we have our surface now i want to get my score rectangle and this is going to be score surface dot get wrecked as always and in here i want to place the top left and for now let's place it at 0 and 0. although i'm going to change that in just a second and finally i just want screen dot blitz with my score surface and my score wrecked and well that's all we needed so now i can open up the run method and actually display lives should not be there it should be down here and i also want self dot display the score and i guess by now i can just delete these two comments they don't really do anything anymore and this run method has become quite extensive it might be a good idea to clean it up a tiny bit let's do that now actually so here we are drawing all of this and there we are updating everything and i guess it is a good idea to have all of the update methods in one chunk and that makes a little bit more sense yeah i think that looks a bit better so here we're updating all of the spread groups then here we are adding extra updates and here we are drawing everything let's try this now and we can see the score in the top left and it doesn't update right now but we can work on that in a second but first of all i want to work with this top left and there might be one thing you have noticed that this font is not in the top left there's a slight y offset even though we specified zero in the score and the reason for that is that the font is rather large so for the x offset i want to go with 10 and for the y with negative 10 and that's going to look like this which i think is better and well the score here is just very very tall for some reason but well that's literally all we needed now so now we have a score and the one thing we have to figure out now is how to update this number here and for that we have to go to our alien file and give each alien a score relative to that color and well that is literally just an if statement so if the color is equal to red then self.value is going to be a hundred l if color is equal to green then we have self.value is going to be 200 and if we have neither of these cases so we have else then self.value is going to be 300. so this would be the yellow aliens all the way at the top and now we can look at our collision checks in here and the two if statements you want to look at are these two and the easier one is going to be this one because there's only one extra alien so if we hit that one we want self.score plus equal 500. and that is all we needed here and let me place it above laser.kill not for any particular reason it just feels better all right but now this statement here is going to become a little bit more complex and that is because right now we are only deleting the alien once it's being hit but we don't know which alien is hit and since we don't know what alien has hit we don't know what the score is going to be so instead we have to do this slightly differently and let me actually copy all of this and what i want to find out is first i want to get all the alien let's call it aliens hit and this is going to be pigem.sprite.spread collide and it is still going to be true and this is still going to destroy the alien however now it is also going to store it in this aliens.hitlist so i can get rid of all of this and i can check if aliens hit and if that is the case i still want to get laser.kill that stays the same however now i can also loop over all the aliens so for alien in alien hit and then self.score is simply going to be plus equal alien dot value oh and this should be for alien in alien set and now let's try this and it is working indeed i can shoot at the aliens and i get different scores and they hit the green one and the score is updating quite nicely i hope i can get to hit a yellow one and there we go so this is working very well so with that we also have our score and that is basically finishing up the game by itself so let me close everything and i think what i really want you guys to get away from this is that none of this was particularly difficult we just added lots of simple systems on top of each other and thereby created complexity and the only two things i really want to add number one is i want to add some crt styling on top and i think that makes the game look much better although it's not strictly necessary and you might not like it at all and the second one is going to add sound and that's going to be the really easy part so i will leave that for the end but first of all i want to draw on top of this so by the end of this section our game goes from this to this but literally all we are going to do here is we are drawing some elements on top of the game and then reducing the opacity and well let's jump into the code and let's create this so here i'm back in the main game and i want to create a new class and let me minimize the game class so we have a bit more space and this class i called crt it does not inherit from anything and we just set an init method and it here i want to have self.t and this is just going to be an image so pygame.image.load and the file path for that is this one so it's in the same graphics folder and i also want to convert alpha this and you're going to see in a second what that actually does and what i'm going to do is i'm going to create a draw function that needs self and for now all we're going to do is screen dot blit blitz self.tv and it should be in the top left so 0 and 0. and now in our if statement for the main game i'm going to create crt as an instance of the crt class and then on top of our game run or below in the code crt.draw and now let's have a look what this does and there we go so really all this does is it well it draws a tv style thing around the address of the screen but now this image has a problem and let me actually demonstrate this that if i increase the width of our game now this image doesn't cover the entirety of the game which starts to look very very silly so we have to add some code here to make this wider along with the screen and let me move it back to 600. and for that we can use pygame.scale and well all we are going to need is self.tv is pygame.transform.scale and in here we need a couple of arguments the first one is the surface itself so self.tv and then we're going to need the width and the height we want this to be so in our case this is screen width and screen height and both of these have to be inside of a tuple so if i run this by itself we can't see any difference however if i make the screen wider now this is going to scale up along with it so this way our game keeps on being responsive which is quite nice but let me keep it at 600 to 600 and there's one thing that is kind of annoying right now so we can't really see the edges too well and this we can change by lowering the opacity of this surface and to do that all we need is self.tv and set alpha and then here you have that a number between 0 and 100 with 0 being invisibility and 100 being the standard value so you can see everything so let me put it to 50 and now this is looking much better and what we can even do in here because traditional crt monitors flickered a bit and i imitated that effect by using a random opacity between 75 and 90. and what is going to happen here is that every time we are running the draw method so well every frame we are changing the opacity a tiny bit which makes the entire thing look much more dynamic and i think you can see it this starts to feel better so all right this is then working quite well but now these old tvs also showed a couple of lines and for that i want to define create crt lines and let's place this above draw again we are going to need self and now we need a couple of different things first of all i want to get a line height so how tall each line is going to be and i just went with three and then we have to figure out how many lines we want to have so line amount and really all we need is this green height divided by the line height and this i want to be an integer so we can work with it a bit more easily and well all we have to do now is for a line in range line amount i want to draw the lines and for that i need a y position and well this line position is just going to be line multiplied by line height so we figure out what line we are on and then we are multiplying this by the height of each line and now we can start drawing so pygame.draw.line and here is one important thing that usually when i use this.draw i always draw on the screen however now i'm going to draw on self.tv so self.tv and the reason why i am doing that is because i want to have the same opacity for the lines and for the tv and if i put all of them on the same surface when we run this line they are all going to have the same opacity which makes the game look a bit more consistent now we are going to need our color and in my case i just went with black and now we need the start point and the end point of each line and a width the width is the easiest part i just went with one and for the start point we need a tuple and here we are going to need x and y and both of these are very easy because x is just going to be zero so the left side of whatever window we have and y is just going to be the y position and for the endpoint this is also quite easy so we need x and y again and y is just going to be the y position and x is going to be this green width and well that was literally all we needed so now i have to call self dot create crt lines and let's run this game and there we go this is looking very well so now we have a much more retro feeling game that i think is looking better than the original but you could just not run crt.draw and then if you like this one more this would also work just fine and with that we have all of our styling done now with that we have the final part of our game and that is going to be the music and the sounds and well there really isn't anything complicated now this is going to be very easy so let's go straight into the code and let's have a look at this so here we have our entire game setup and i want to look at my game class again and if you open this one you can see the init method and all the other methods we created earlier and the first thing i have to do is to import all the music let's call it audio actually and first of all i want to import the music itself so the background music and this is going to be pygame dot mixer dot sound and the file path towards that file is this one next up i want to set the volume of this file and i set it to 0.2 so it doesn't get too loud and finally i want music dot play and for the loops we want to set it to negative one so at this place forever and now if i run this you should be able to hear that so i hope this is working so this would then be the first part and this could be a really good exercise for you there's also a laser sound and an explosion sound try to import them set the volume and play them at the appropriate time all right i'm going to shorten this a bit because this is very samey so let me just copy them and here we have a laser sound and we set the volume and then we have an explosion sound and we're also going to set the volume that's literally all that's happening here so now we have to figure out when each of these sound is supposed to be played and let's start with the laser sound and the laser is going to happen every time an alien shoots so in here alien sound dot play and the explosion sound i want to play if we have a collision check between the player laser and the alien so in here and let's just play it right afterwards and let's try this although there's one part missing that if our player shoots a laser we don't hear sound and for that we have to go back into our player class and in here i also want to import the laser sound so here the literal same thing we have done earlier and now every time we're pressing the space button and we are ready i want to self dot laser sound dot play and now stress again really well however there's one thing i did forget and that is a victory message once we have destroyed all of the aliens so let's add this one really quick sorry about that but this is not a difficult thing to add and really what i want to do is if there are no more alien sprites i want to display a text that says you won that's literally all it is so let's jump straight into the game and let's fix this really fast and then we are finished here we are back in our game class and i just want to add another method and let's call it victory message it doesn't need any arguments and really all we're going to check in here is if not self.aliens.sprites so if there are no more aliens in the aliens group then we know we have one and in there all we need to do is create a victory surface and this is going to be self.font.render that says u1 needs to be false for antialiasing and the color is going to be white and then i also want to get a victory rectangle so we can place it in the middle of the screen and this is just going to be victory surface dot get direct and the center is going to be the screen width over 2 and then also the screen height over 2 and then finally screen dot blit victory surface and victory rectangle and then of course also don't forget to run this so self dot victory message and for that i am going to cheat ever so slightly here so what i'm going to do is in the collision check i am going to comment out laser.kill and replace it with pass whenever our play hits an obstacle and we're also going to comment it out whenever we hit an alien so that way our player is basically going to shoot so now i can uncomment all of this get rid of this and with that we have the entirety of the game so i hope that was helpful and i will see you around
