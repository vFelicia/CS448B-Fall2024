With timestamps:

00:00 - [Music]
00:13 - hello there
00:14 - in this tutorial we are going to be
00:15 - making this game however
00:17 - the game itself isn't really the point
00:19 - of the video instead
00:21 - it is more of a vehicle to explore
00:23 - pygame essentially
00:25 - this is an introduction to all the major
00:26 - components of pygame that you need to
00:28 - start making games in python
00:30 - and by the end of it you should have all
00:32 - the tools to approach
00:34 - any 2d game starting from text
00:36 - adventures and pong
00:37 - going all the way to the first
00:38 - generation of doom and wolfenstein games
00:41 - and i do plan to make more advanced
00:43 - games in pygame
00:44 - so get subscribed if you don't want to
00:46 - miss those and
00:47 - really quickly before i start you should
00:49 - know some python already
00:51 - it doesn't have to be much but i do
00:53 - assume that you know how to use
00:54 - functions and simple classes so nothing
00:57 - fancy
00:58 - but the basics of python and if you want
01:00 - to code along
01:01 - you can find all the assets in the
01:02 - description so i hope you enjoy
01:06 - alrighty so before we get into any
01:09 - actual code
01:10 - let's first talk about how video games
01:12 - work on a general level
01:13 - that is really going to help us
01:15 - understand what pygame does
01:17 - and how it actually works so how do
01:19 - video games work
01:20 - and i think the best way to think about
01:22 - that is to start with movies
01:24 - because that is the technology video
01:25 - games leaked off from
01:27 - essentially a movie is really just a ton
01:30 - of images playing really fast after each
01:32 - other
01:33 - so for example here's a movie and all i
01:35 - have to do is to slow it down and you
01:37 - can see individual images
01:39 - although for movies these are usually
01:40 - called frames but it's
01:42 - well it's the same thing and most of the
01:44 - time a movie has 24 frames per second
01:48 - so you see 24 images per second and your
01:50 - eye perceives this as a moving image
01:52 - at least in most situations and if you
01:55 - do this long enough you eventually have
01:56 - a movie that lasts about an hour and a
01:58 - half
01:59 - and that's essentially it the only real
02:01 - difference between different kinds of
02:03 - movies is how each individual image is
02:05 - being made
02:06 - and there are basically three different
02:07 - ways to approach this
02:09 - number one you could get a camera and
02:11 - just point it at something and record it
02:13 - number two you could draw an image or
02:15 - number three you could use a computer to
02:17 - create a 3d image
02:18 - and each of these approach would give
02:20 - you a very different look of your
02:22 - movie but at the end of the day all
02:24 - we're doing is creating lots of
02:25 - individual images and playing them
02:27 - really fast after each other and that's
02:29 - literally it
02:30 - so with that we have movies and video
02:33 - games are quite similar to that
02:35 - and in the most basic sense a video game
02:37 - basically works like a movie
02:39 - that you have lots of individual images
02:41 - being played really fast after each
02:43 - other
02:44 - but obviously there need to be a couple
02:45 - of differences to really make all of
02:47 - this
02:47 - work number one and i guess the most
02:50 - important one
02:51 - is that on a video game each individual
02:53 - image isn't set in stone
02:55 - instead it's dynamic meaning that each
02:58 - individual image is created on the fly
03:00 - and plays dynamically depending on what
03:02 - the game needs so for example is the
03:04 - enemy in a certain position
03:06 - or did the player press a certain kind
03:08 - of button to move in a certain direction
03:10 - and then each individual frame is being
03:12 - updated automatically
03:14 - whereas for a movie each individual
03:16 - image is basically always the same
03:18 - so this already makes video games
03:20 - different that you have dynamic content
03:22 - and that already brings us to the second
03:24 - point that for video games we are
03:26 - checking player input
03:28 - which means that at the beginning of
03:30 - each image that we are drawing
03:32 - we are first checking the input from the
03:34 - player so we are checking if the player
03:36 - presses the button on the keyboard or
03:37 - moves the mouse or
03:39 - says something into a microphone lots of
03:41 - different things that we could be
03:42 - checking
03:44 - and then we are using that information
03:45 - to place something dynamically on the
03:47 - screen
03:48 - and well once we have accounted for
03:50 - those two differences
03:51 - we basically have a video game so let's
03:53 - give how a video game works on a
03:55 - conceptual level
03:57 - we always start by taking the player
03:58 - input and this is usually called an
04:00 - event loop
04:01 - so each kind of event could be a
04:03 - different kind of thing a player does
04:05 - it could also be something else for
04:07 - example a timer running out
04:08 - but essentially we are taking all the
04:10 - necessary inputs we need to draw the
04:12 - current image
04:14 - and once we have all that information we
04:16 - are actually placing
04:17 - all the relevant parts on the screen so
04:20 - we are placing the player in a certain
04:21 - position
04:22 - we are placing all the enemies we are
04:24 - drawing the health indicator the coin
04:25 - indicator
04:26 - whatever we really need and well once we
04:29 - have all of that
04:30 - we have one finished frame so this is
04:32 - one image the player is going to see
04:35 - now once this process is finished we are
04:37 - getting rid of the entire image again
04:40 - and starting this process from scratch
04:42 - and we are doing this
04:43 - multiple times per second usually about
04:46 - 30 to 60 times
04:47 - depending on how fast the computer is
04:49 - now that is really it
04:51 - and this applies both to 2d and 3d games
04:54 - so it doesn't really matter if you have
04:56 - a 2d image or 3d object to generate each
04:58 - individual frame
05:00 - at the end of the day you are just
05:01 - putting different elements together and
05:03 - displaying them to the player
05:05 - so with that let's talk about how pygame
05:07 - comes into this
05:09 - and well pygame has a couple of key
05:11 - functionalities that we can use to make
05:12 - a game
05:13 - and it doesn't necessarily have to be a
05:15 - game we could also make a movie in pi
05:17 - game or we could display some graphs
05:19 - this would also be possible
05:21 - so what does pygame actually do in the
05:24 - most basic sense pygame gives you a
05:26 - really good way to display
05:27 - images and this might be relevant if you
05:30 - just started with python development
05:32 - you might have realized that drawing
05:33 - anything on the screen is actually
05:35 - really hard
05:36 - and most of the time you just work with
05:38 - a console where you can see text
05:40 - but displaying actual images and
05:42 - animations is not that
05:44 - easy and this is the first thing that
05:46 - pygame is
05:47 - really good at that it helps us create a
05:49 - window and it helps us display images
05:51 - something that is well important for
05:53 - video games
05:54 - and along with that pie game can also
05:56 - play sounds this goes along with that
05:58 - quite well
06:00 - now the second point pygame can do well
06:02 - is to look for player inputs
06:03 - so pygame can help you get the mouse
06:05 - position or get keyboard inputs or even
06:07 - get gamepad input lots of different
06:09 - things that it can do
06:11 - and again in standard python you have
06:13 - the input method but this one stops the
06:15 - entire code if you want to get
06:17 - input which would break any kind of game
06:20 - so this would be the second important
06:22 - part of pygame that we can get actual
06:24 - player input
06:25 - and those are the two really important
06:28 - parts that pycam helps us with
06:30 - but there are a couple more that are
06:32 - general helpful things for a video game
06:34 - for example pygame is really good to
06:36 - help us with collision detection
06:38 - or pygm can help us create text and
06:40 - timers
06:41 - lots of things that are important for a
06:43 - video game but these are things you
06:45 - could also do in standard code but
06:46 - pygame has lots of ways to make it
06:48 - easier
06:49 - when it comes down to it pygame is a
06:51 - very simple module
06:53 - now there's one important thing i do
06:55 - want to address
06:56 - that if you want to make really
06:58 - sophisticated games let's say a dark
07:00 - souls or an assassin's creed
07:02 - then you would not use something like
07:04 - pygame because it doesn't really give
07:05 - you too many tools for this kind of
07:07 - thing
07:08 - instead you would use a proper game
07:10 - engine and this would be something like
07:12 - unreal
07:13 - unity godot and there are quite a few
07:15 - more and the game
07:16 - engine has a lot of additional tools
07:18 - that make game developments
07:19 - significantly easier
07:21 - for example there's gravity detection
07:23 - there's support for 3d objects there's
07:25 - lots of inbuilt stuff that makes game
07:26 - development very easy
07:28 - and along with that there's also
07:30 - graphical user interface that allows you
07:32 - to place elements on the screen and you
07:34 - see the game
07:34 - as you develop it and pygame doesn't
07:37 - have
07:37 - any of that it's well not really
07:40 - designed for that sort of purpose
07:42 - so just keep that in mind now this
07:44 - already brings us to the first important
07:46 - point
07:47 - why would you want to use pygame over
07:49 - something like unreal or unity
07:51 - and this is actually bringing us to one
07:53 - of the important parts of pygame
07:55 - that most of the time pie game isn't
07:57 - used for actual game development at
07:59 - least for games that you want to publish
08:01 - instead pygame is incredibly good to
08:03 - learn how to code and to create systems
08:05 - yourself
08:06 - so if you only ever use a proper game
08:08 - engine and you have all the systems in
08:10 - place for you you
08:12 - don't really learn good programming
08:14 - instead you learn to rely on external
08:16 - tools that somebody else provides for
08:18 - you
08:18 - but if you develop all of this in py
08:20 - game yourself you become a much better
08:23 - programmer
08:24 - and later on if you have more experience
08:26 - in programming
08:27 - you can very easily switch to other
08:28 - engines and actually make professional
08:30 - games
08:31 - but to get started working in pygame is
08:33 - really useful because you learn very
08:35 - good practices and become a much better
08:37 - programmer
08:39 - so now let's actually get started in
08:41 - pygame
08:42 - and before we can start with pygame we
08:45 - first have to install it because pygame
08:47 - does not come with python automatically
08:50 - but installing it is super easy all you
08:52 - have to do is either go to the terminal
08:54 - or the powershell
08:55 - and type pip install pygame and then you
08:58 - should be seeing a short animation
09:00 - and after that you should get the
09:01 - message that the module was installed
09:03 - successfully
09:05 - so with that let's actually get started
09:07 - by creating a window in pi game
09:11 - so here i have an entirely empty sheet
09:13 - of code
09:14 - and the first thing i want to do is to
09:16 - import my game
09:19 - and at this stage i would already
09:21 - recommend to run the code
09:23 - here we can see we have pygame version
09:25 - 2.0.0
09:27 - you can see our python version and then
09:30 - you have a hello from the pygame
09:31 - community
09:32 - and a link where you can contribute so
09:35 - if you can see this message
09:36 - you have installed pygame successfully
09:39 - if at this stage you get some kind of
09:40 - error message
09:41 - you probably didn't install pygame
09:43 - successfully so check that stage
09:45 - so now we have pygame how can we
09:47 - actually use it and well
09:49 - the first line we need is pygame.init
09:52 - and don't forget to call it that's
09:53 - really important
09:55 - and pygame.init is incredibly important
09:57 - and absolutely necessary to run before
10:00 - any other pygmy code so pi gamma knit
10:02 - essentially starts pygame and initiates
10:05 - all the sub-parts of pygame that you
10:07 - need to make a game
10:08 - for example this init helps us render
10:10 - images and play sounds
10:11 - and stuff like that basically
10:14 - and while it does lots of complicated
10:16 - stuff you don't really have to worry
10:18 - about this at
10:19 - all all you really have to do is to call
10:21 - it in the first place but once you have
10:23 - called it it's basically good to go
10:25 - think of it like starting the engine of
10:27 - a car that when you actually do that
10:29 - lots of really complicated stuff happens
10:31 - but for you as a driver well
10:33 - you turn around the keys and that's
10:35 - basically it that's
10:36 - essentially the same principle here now
10:39 - on the next line
10:40 - we have to create what is called a
10:42 - display surface
10:43 - and a display surface is basically the
10:45 - window the player is going to see in the
10:47 - end
10:48 - and this we have to store in a variable
10:50 - that is usually called screen
10:52 - and to create a display surface we need
10:55 - pygame.display.set
10:57 - mode and into this set mode we have to
11:00 - place at the very least
11:01 - one argument and this has to be a tuple
11:03 - and this one should contain the width
11:05 - and the height of our game window so
11:08 - essentially later on when we create our
11:10 - window the width is going to be this
11:14 - part
11:14 - and the height is going to be this part
11:16 - so uh well
11:17 - that's all we really need and in this
11:20 - case i want to go with a width of
11:22 - 800 pixels and a height of 400 pixels
11:26 - and now once we have that we can
11:28 - actually run the code and let's see what
11:30 - happens
11:31 - and there you could see a window for
11:34 - just about one frame
11:36 - and this is the intended behavior for
11:39 - now so if you get the same result you
11:41 - have done everything
11:42 - correct and let me explain why this is
11:44 - happening
11:45 - what happens right now is that we are
11:48 - importing pygame we are initializing
11:51 - pygame
11:52 - and we are creating a display surface
11:55 - but
11:55 - after that is done our code ends and our
11:58 - computer stops running this python code
12:00 - and as a consequence of the code ending
12:02 - this display surface
12:04 - also disappears so we are seeing it for
12:06 - a second because pygame is starting to
12:08 - run it but then closes it basically
12:10 - immediately afterwards
12:11 - and this is why we only see it for a
12:13 - second or so and
12:15 - well the solution to that is that we
12:16 - need to figure out some kind of
12:18 - way to keep our code running forever and
12:21 - well for that all we really need is a
12:24 - wild
12:24 - true loop so this while true loop is
12:28 - going to run forever for the simple
12:30 - reason that this condition in here
12:32 - is never going to be false and we have
12:34 - to break the while loop from the inside
12:37 - so basically our entire game is going to
12:39 - run inside of this well true loop
12:42 - and in here we are going to draw all our
12:46 - elements and also update everything
12:49 - so this is all going to happen inside of
12:51 - a while loop and
12:53 - there is one important line we have to
12:55 - add in here as well
12:56 - and that is pygame dot display dot
12:59 - update and all that bond is really doing
13:02 - is it updates this display surface so
13:06 - that anything we have drawn
13:07 - inside of this while loop we actually
13:10 - want to display to the player
13:11 - so we have to take it and actually put
13:13 - it on the display surface
13:14 - and this is what this line here is for
13:17 - so
13:18 - don't forget this one either but again
13:20 - just like with pygame.init
13:22 - you only really have to call it and then
13:24 - you don't really have to think about it
13:25 - that much more
13:27 - so all right now we could be running
13:30 - this code now and
13:32 - we would get a window that would stay
13:34 - open forever however
13:36 - please do not call the code right now
13:38 - because you wouldn't be able to close it
13:40 - by itself
13:41 - for the simple reason that right now we
13:43 - do not check for any kind of player
13:44 - input
13:45 - and one type of player input would be to
13:48 - close the window
13:49 - so keep that in mind as well that if you
13:51 - didn't check specifically for closing
13:53 - the game
13:54 - well the player wouldn't be able to
13:56 - close the game so let's add that one
13:58 - first
13:59 - and this again happens in the well true
14:01 - loop and really what we want to do here
14:03 - is to check for all the possible types
14:05 - of player input and this is called an
14:07 - event loop
14:09 - and more practically this is just a for
14:11 - loop we are looking at all the possible
14:13 - types of player input and see if one of
14:15 - them is happening right now
14:17 - so what we want to do is for event so
14:20 - all the possible events
14:21 - and to get the events we use
14:25 - pygm.event.get
14:26 - so this method here would get us all the
14:30 - events
14:30 - and this part here just loops through
14:32 - all of them that's really all that's
14:34 - happening here
14:35 - and for now all we want to check is if
14:38 - the event
14:39 - type we are looking for is equal to
14:41 - pygame
14:42 - dot quit so this pygame.quit here
14:46 - is a constant that is synonymous with
14:49 - the x button of the window
14:50 - so if the type of the event is equal to
14:52 - pygm.quit we are indicating what to
14:54 - close the window
14:56 - and if that is the case we want to do
14:59 - pygame dot quit and let me add
15:03 - a proper double colon and indent
15:05 - everything so now this is working
15:08 - and well now we run the code this should
15:10 - be working much better and now you can
15:12 - see the actual window
15:14 - and i can also close it so let me close
15:16 - it and we're getting an error message
15:19 - that we are getting the error you can
15:22 - see it right here
15:23 - that we have a pygame error video system
15:26 - is not initialized
15:28 - and let me explain what's going wrong
15:29 - here whenever we call pygame.quit
15:33 - we are basically doing the opposite to
15:36 - pygame.init
15:38 - so these two are essentially polar
15:40 - opposites
15:41 - that pygame.net initializes all of
15:43 - pygame pygm.quit uninitializes
15:46 - everything
15:46 - so once we're running this code we can't
15:48 - display anything anymore
15:50 - so we couldn't for example run this
15:52 - method here because pygame needs to be
15:54 - initialized for this to be possible
15:57 - and basically what happens here is that
15:59 - we are calling this method
16:01 - and then we continue down our code and
16:03 - then python encounters this line
16:05 - and it can't run it so it throws an
16:07 - error so the problem here
16:09 - is that we are closing pygame but we
16:11 - still keep this while loop open
16:13 - and this is causing the problem so
16:15 - really what we have to do
16:16 - is to end this well true loop on the
16:19 - spot
16:20 - and well you could call something like a
16:23 - break statement in here
16:24 - but the most secure way to close pygame
16:26 - is to use the sys module
16:28 - and the sys module is something inbuilt
16:30 - into python
16:31 - and it gives you access to different
16:33 - system commands one of these commands is
16:35 - to close any kind of code you have
16:37 - opened entirely
16:39 - which is exactly what we want so well i
16:41 - want to import another module
16:44 - and i only want to import one specific
16:46 - part from it so i use
16:48 - from sys import exit
16:51 - and this exit method closes any kind of
16:54 - code once you call it
16:55 - so well i just want to do that so i call
16:58 - exit
16:59 - and once we have called this exit here
17:03 - this weld true loop will also be gone
17:06 - so then we are not calling this pygame
17:09 - dot update anymore
17:10 - and our code is just going to end so now
17:13 - let's try all of this again
17:16 - so i can still see the window if i close
17:18 - it now
17:19 - our code just finishes and we don't get
17:21 - an error message
17:22 - so this is working pretty well
17:25 - now with that we have a basic setup for
17:27 - our game
17:28 - although there are two more things i
17:30 - would like to add one is very simple
17:33 - the other is slightly more complex so
17:35 - let's start with the most simple one
17:37 - and well what i want to do is to give
17:39 - our game a title
17:41 - because if you check right now we just
17:43 - call it pygame.window
17:45 - so we can see it up here in the title we
17:47 - have pygame.window which
17:49 - well doesn't sound particularly good
17:52 - and we can update this title let's say
17:55 - do it right up here
17:57 - all we have to do is call display
18:00 - dot set caption and in here
18:04 - you have to pass in a string with the
18:05 - name of the game in my case i just
18:07 - called it runner
18:08 - and now if you run it again you can see
18:11 - runner in the top left
18:12 - now you could also change the icon but
18:15 - in my case i don't really care so much
18:17 - but okay this is a pretty good start now
18:20 - for the next part
18:22 - we have to talk about something really
18:24 - important and that is the frame rate
18:27 - or how fast our game is going to run and
18:30 - this is something
18:30 - really important to keep in mind so let
18:32 - me illustrate
18:33 - in a movie the speed is always the same
18:36 - usually 24 frames per second
18:38 - and this stays constant but for a video
18:40 - game
18:41 - the framerate can fluctuate quite a bit
18:44 - so for example if you try to run a
18:46 - modern game on a computer from 25 years
18:48 - ago
18:49 - you would probably only get one to two
18:51 - frames even at the best computer from
18:53 - that time
18:54 - and this would basically make it
18:56 - impossible to play that game
18:58 - but there's also the other side that if
19:00 - you have a modern computer
19:01 - your computer might be able to run the
19:03 - game at something like a thousand or two
19:04 - thousand frames per second
19:07 - and if the game wasn't optimized to
19:09 - handle these kind of frame rate
19:10 - differences
19:11 - the game might run incredibly fast and
19:14 - this
19:14 - might be a problem because our animation
19:17 - speed depends on how fast we're updating
19:19 - the game
19:20 - so think of it like this we have a main
19:22 - player character
19:23 - and let's say we are moving him 10
19:25 - pixels to the right on every single
19:27 - frame
19:28 - now if you are doing this with 1 frame
19:29 - per second you are moving him by 10
19:32 - pixels
19:32 - every second now if you are doing this
19:35 - with 100 frames per second
19:36 - you're moving him a thousand pixels per
19:38 - second so you have a massive difference
19:40 - in speed
19:41 - and this is something we have to be able
19:43 - to address because you want your game to
19:45 - run consistently on basically any
19:47 - platform at least within reason
19:50 - and in our case we just want to keep the
19:52 - frame rate constant
19:53 - so we don't want our game to run too
19:55 - fast and we also don't want to run it
19:57 - too slow
19:59 - ideally we would like to run our game at
20:01 - 60 frames per second
20:02 - constantly so we have to create a
20:04 - ceiling and a floor for our
20:06 - frame rate and well creating the ceiling
20:08 - is very easy but creating the floor
20:10 - is much more difficult for the simple
20:13 - reason that you can just tell your
20:14 - computer not to run the game
20:16 - faster than a certain speed and if your
20:18 - computer can run a game at 100 frames
20:20 - per second
20:21 - you could just tell it to run slower
20:22 - that shouldn't really be a problem
20:24 - however if your computer is too slow to
20:26 - run the game
20:27 - then well you couldn't magically tell it
20:29 - to run faster and be more capable
20:32 - so to account for the minimum frame rate
20:34 - you just have to be a good video game
20:36 - developer
20:37 - and ensure that there's never too much
20:39 - on the screen at the same time for
20:40 - example
20:41 - something that video game developers are
20:43 - very much concerned with
20:44 - but setting the maximum frame rate is
20:46 - very easy to do so let's
20:48 - actually do that so here i'm back in pi
20:50 - game and what i want to do
20:52 - is to create a clock object because the
20:54 - clock object helps us with
20:55 - time and this also helps us with well
20:58 - controlling the frame rate
20:59 - and this usually put in a separate
21:01 - variable that i have called clock
21:03 - and to create a clock object we need
21:06 - pygame.time.clock
21:07 - and make sure that the c in clock is
21:10 - capitalized that is really important
21:13 - and now this is going to give us a clock
21:15 - object now
21:16 - by itself it doesn't really do anything
21:18 - but when we call it in our while loop
21:21 - we can call clock.tick and
21:24 - in here you can add an integer in my
21:26 - case 60
21:28 - and this 60 is telling pygame that
21:31 - this wild true loop should not run
21:34 - faster than 60 times per second
21:36 - or about one while loop for every 17
21:38 - milliseconds
21:40 - and that way our game is not going to
21:41 - run too fast
21:43 - i will illustrate later on in this
21:44 - tutorial how this is actually making a
21:46 - difference for the animation
21:48 - but alright so with that we have set a
21:50 - maximum frame rate
21:52 - now the minimum frame rate we can't set
21:54 - with one line of code we just have to
21:56 - make sure our game doesn't become too
21:58 - complex
21:59 - now that being said we are only going to
22:01 - create basic 2d games in pygame
22:04 - and those are basically never going to
22:05 - run to promise for even reasonably
22:07 - modern computers
22:09 - so we don't really have to worry about a
22:10 - minimum frame rate
22:12 - but it is something to keep in mind if
22:13 - you want to make more sophisticated
22:15 - games
22:16 - but alright so with all of that we
22:18 - finally have our basic setup for our
22:20 - window
22:21 - so obviously this still isn't great
22:23 - because we are not displaying anything
22:26 - so let's actually start working on that
22:28 - and let's put some basic images on
22:30 - our display surface so how can we
22:32 - actually draw anything in pygame
22:34 - and well to draw any kind of image we
22:37 - need one important concept
22:39 - and that is called a surface and there
22:42 - are two different kinds of surfaces in
22:44 - pie game
22:44 - and the one we have already seen was the
22:47 - display surface
22:48 - so a surface can just be the main window
22:50 - the player can see
22:52 - but there's another kind of surface that
22:54 - we are going to use much
22:55 - more so let me explain if you want to
22:57 - display anything in pygame you
22:59 - essentially always put it on some kind
23:01 - of surface
23:02 - what the player is going to see at the
23:03 - end is anything that was put
23:06 - on the display surface so this is the
23:08 - actual window that we are going to
23:09 - display
23:10 - but to display anything on this display
23:12 - surface we need regular surfaces
23:15 - and a regular surface or just a surface
23:18 - is basically just an image and this
23:21 - image can be different kind of things
23:24 - it could for example be an image you
23:25 - have imported it could just be a plain
23:27 - color
23:28 - or it could be some kind of text these
23:31 - are
23:31 - basically the three different kinds of
23:32 - possibilities
23:34 - and then you could place a surface with
23:36 - some content on the display
23:38 - surface and that way you would actually
23:40 - display the regular surface
23:42 - i think the best way to understand this
23:44 - is like this
23:45 - imagine you want to create a really big
23:47 - post and present it to people
23:49 - the actual canvas you are putting stuff
23:51 - on is the display surface
23:53 - so this is what you are going to present
23:55 - at the end but by itself
23:56 - just having a canvas doesn't really help
23:58 - you all that much
24:00 - so instead you have to place individual
24:02 - post-it notes and pictures on this
24:04 - display surface
24:05 - and each individual post-it note and
24:07 - image is going to be a regular surface
24:10 - and if you place enough surfaces on the
24:12 - display surface
24:13 - at the end you are going to have
24:14 - something that hopefully looks quite
24:16 - nice
24:17 - so that really is all the difference
24:19 - here that we have to worry about
24:21 - but just to mention it we can only have
24:23 - one display surface
24:25 - and the display surface is always shown
24:27 - so we can basically never hide it
24:29 - however for regular surfaces we can have
24:32 - as many as we want there's no limitation
24:34 - to it
24:35 - however a regular surface is only
24:37 - displayed if we actually put it on the
24:39 - display surface
24:40 - so you could have created a thousand
24:42 - surfaces unless they are specifically
24:44 - attached to the display surface
24:46 - they will not be visible so all right
24:49 - that was again quite a bit of theory so
24:51 - let's actually get into our code
24:53 - and let's create a basic surface and for
24:56 - this section
24:56 - i want to create three different kinds
24:58 - of surfaces one with a plain color
25:01 - one with an image that we imported and
25:03 - one with text
25:04 - and they all work by creating first the
25:06 - surface and then placing the surface on
25:08 - the display surface
25:10 - let's start with the simplest one to
25:11 - just create a surface with a plain color
25:14 - here i'm back in my code and i want to
25:16 - create a new variable
25:18 - and let's just call this test surface so
25:20 - we are going to play around with this
25:21 - one
25:22 - and then later on we are going to delete
25:24 - it to replace it with something more
25:25 - proper
25:27 - and to just create a plane surface we
25:29 - need pygame dot
25:30 - surface and here again make sure
25:34 - that this s is capitalized otherwise it
25:36 - is not going to work
25:38 - and this surface is going to need a
25:40 - tuple
25:41 - with the width and the height so here we
25:43 - want to get width and height
25:46 - and this is very similar compared to
25:48 - what we have seen for the display
25:49 - surface
25:50 - and this is something you are going to
25:52 - see very often that the display surface
25:54 - and the regular surface have lots of
25:56 - things in common
25:57 - and this would be just one of them and
25:59 - in my case i want to give
26:01 - this surface a width of 100 and a height
26:04 - of 200. so now we have created a surface
26:09 - now the next thing we have to do is to
26:10 - actually display this
26:12 - and this is going to happen in this well
26:14 - true loop
26:15 - and let me get rid of the comments they
26:17 - don't really help us all that much
26:19 - so in the first indentation of this well
26:21 - true loop i want to actually attach this
26:24 - test surface to our display surface and
26:26 - this happens by first calling our
26:28 - display service itself
26:29 - and then using the blit command and
26:32 - blitz stands for block image transfer
26:35 - which is essentially a fancy way of
26:37 - saying you want to put one surface on
26:39 - another surface
26:40 - and in here we need two arguments we
26:42 - first need the surface we want to place
26:44 - and then the position and well the
26:47 - surface we already have
26:49 - is just our test surface and for
26:52 - position
26:52 - for now i just want to place it in
26:54 - position 0 and 0.
26:56 - and you are going to see in a second
26:57 - what that actually means
26:59 - but now let's run the code and well
27:02 - what we can see is that we well can't
27:05 - see anything
27:06 - and there's a specific reason for that
27:08 - and the reason is quite simple actually
27:10 - that right now both our surfaces are
27:12 - plain black
27:13 - so this surface here is black and this
27:15 - surface here is black
27:17 - and if you put something black on
27:18 - something else that is black you just
27:20 - get more black
27:21 - it doesn't help you all that much so
27:23 - what we have to figure out
27:24 - is how to add color to either of these
27:27 - surfaces
27:28 - and well fortunately that is very easy
27:30 - to do because there's a specific command
27:33 - for it
27:34 - and let me just run this on test surface
27:36 - because all we need
27:37 - is the fill command and in the fill
27:41 - command we can add a specific color
27:43 - and pie game has a couple of ways to add
27:45 - color and the simplest way is to use a
27:47 - couple of
27:48 - named arguments that are predefined for
27:50 - pygame and there's a long list online
27:52 - that you can find
27:52 - that i would recommend to check out i'll
27:54 - put a link in the description of the
27:56 - video
27:57 - and one that we could use is just red
28:00 - so that we want to fill this test
28:02 - surface with a red color
28:04 - and now let's run the code and now we
28:07 - can actually see
28:08 - our red surface in the top left of the
28:10 - screen
28:12 - and now i really want you guys to think
28:13 - about why is this thing in the top left
28:16 - that is really important to understand
28:18 - and well
28:19 - i guess let me actually explain what's
28:21 - happening here most importantly
28:23 - our main window is this display surface
28:26 - and is 800 pixels wide
28:27 - and 400 pixels high so this here would
28:30 - be the height
28:32 - and let me actually put it down here so
28:33 - this would be 400
28:36 - and our width would be this entire width
28:39 - and this would be 800. so this is just
28:42 - the arguments we specified up here
28:44 - but there's one super important thing
28:46 - you have to understand about this
28:48 - that you have to think about this window
28:50 - as a coordinate system
28:52 - think of it like in basic math where you
28:54 - had a coordinate system that looked
28:56 - something like this
28:57 - and on this you could have displayed a
28:59 - graph or something like this
29:01 - and the really important part of this
29:02 - coordinate system is that the origin
29:05 - point was always in the bottom left
29:07 - so this point was always 0 and 0.
29:11 - and if you wanted to go either to the
29:12 - left or upwards
29:14 - you had to increase either of these
29:16 - numbers
29:17 - now in the case of pygame this is
29:20 - slightly different
29:21 - so what you have to be aware of for
29:23 - pygame is that the origin point is in
29:25 - the top left
29:26 - so this point here is the point zero
29:30 - and zero so if you want to go to the
29:33 - right
29:34 - you still have to increase x so let's
29:36 - call it plus x
29:37 - however if you want to go downwards
29:40 - you have to increase y
29:44 - whereas in the system you learned in
29:45 - high school if you wanted to go
29:47 - downwards you had to decrease y
29:48 - so this is slightly different for pi
29:50 - game and this is also something you see
29:52 - in lots of other game engines
29:54 - and especially in the beginning
29:56 - unfortunately this is really confusing
29:58 - and you will need some time to get used
30:00 - to it for basically any game engine
30:02 - so something important to learn so this
30:05 - is the first thing you have to
30:06 - understand here
30:07 - that this is our origin point so now
30:09 - when we place something at zero
30:11 - and zero we are looking at this point up
30:14 - here
30:15 - now this brings us to the second point
30:17 - that when we have this test surface
30:20 - there's one specific point we place when
30:22 - we place this surface
30:23 - and the specific point we are placing is
30:26 - always the top
30:26 - left so when we specify this
30:30 - 0 and 0 here we are saying essentially
30:33 - that we want to get
30:34 - the top left position of this test
30:36 - surface and place it
30:38 - right in the top left of our display
30:41 - surface
30:42 - and that way we have our surface right
30:44 - in the top left so this is really
30:46 - important to understand for pygame to
30:48 - understand how the coordinate system
30:49 - works
30:50 - with a bit of practice this should come
30:52 - quite naturally to you
30:54 - and let's actually do an exercise if you
30:56 - want to follow along
30:57 - that right now i don't want this surface
30:59 - to be in the top left anymore
31:01 - instead i want it to be 200 pixels from
31:03 - the left and 100 pixels from the top
31:05 - so try to implement this yourself
31:12 - all right welcome back so let's try to
31:14 - do this together now
31:15 - so right now we are placing the top left
31:18 - position in 0 and 0
31:20 - which is not appropriate anymore instead
31:23 - i want this to be 200 pixels from the
31:25 - left
31:25 - and 100 pixels from the top and now if i
31:28 - run the code again
31:30 - we can see let me draw on this again
31:33 - we have this distance here is 200 pixels
31:37 - from the left
31:38 - and we have 100 pixels from the top
31:42 - so this is what these two numbers here
31:44 - illustrate and again
31:46 - we are placing this point here so
31:48 - actually this line here should have been
31:50 - rather right on top of that
31:53 - so i hope that makes sense and if you
31:55 - get stuck on this
31:56 - definitely play around with the
31:58 - different kind of points it's really
31:59 - important
32:00 - to understand and later on we are going
32:02 - to learn a specific method to help us
32:04 - place something more deliberately
32:06 - but for now this should be good to go
32:09 - so that way we can create a basic
32:12 - surface that has a plain color
32:14 - but obviously that still isn't all that
32:16 - great because
32:17 - well our game isn't going to consist out
32:19 - of plain colors instead we want to have
32:21 - actual images
32:23 - and well for that we want to import some
32:25 - images
32:26 - and well the first we need for that is
32:28 - to actually have some images
32:30 - and in my case i have a couple of
32:31 - folders that are in the same folder
32:33 - where my code is
32:34 - so let me open that one and in here we
32:37 - have our runner code
32:38 - and then we have three more folders we
32:40 - have graphics
32:42 - we have font and we have audio and well
32:45 - each of these contain what the name
32:46 - implies they contain
32:48 - so let me open graphics and there we
32:50 - have for example a ground and the sky
32:53 - these are what we are going to use in
32:55 - just a second
32:56 - but there's also a couple of enemies and
32:58 - the player itself
33:00 - so these are the tools i'm going to work
33:02 - with for now and i will always assume
33:04 - that our actual code is in the same top
33:07 - folder as these three other folders
33:09 - so when we import something we have to
33:11 - specify a specific path
33:13 - and if you want to follow along keep the
33:14 - same folder set up
33:16 - but right let me go back to the code and
33:19 - now
33:20 - i want to get rid of all of this and
33:23 - instead import an image and to import an
33:26 - image we need pygame.image.load
33:30 - and in here we have to specify a path
33:33 - and in my case i want to go into the
33:35 - folder called graphics
33:37 - and in that folder we have an image
33:40 - called sky and don't forget we need the
33:43 - file ending so my case this is dot png
33:46 - and well with that we have imported an
33:49 - image so now let's run the code again
33:51 - and we have our background and right now
33:54 - you can actually see the offset
33:55 - really well let me get rid of the offset
33:58 - entirely so i just want to place this
34:00 - background on position 0
34:01 - and 0. we can see the actual background
34:05 - so this way it's super easy to import an
34:08 - image
34:09 - and one important thing to keep in mind
34:10 - here
34:12 - every time you import an image into
34:14 - pygame
34:15 - you are putting this new image on its
34:17 - separate surface
34:18 - so any kind of graphical import is going
34:20 - to be a new surface
34:22 - and in this case i guess we can call
34:24 - this our sky
34:26 - surface because we can actually keep it
34:28 - this one works pretty well already
34:30 - so sky surface and with that we have our
34:33 - sky
34:34 - and now actually this is something we
34:36 - can practice really well
34:37 - because there's another image inside of
34:39 - the folder that is called ground.png
34:42 - and i want you guys to import this and
34:44 - place it somewhere in the bottom of the
34:45 - screen
34:46 - so we actually have something that looks
34:48 - halfway decent already
34:49 - so try this yourself if you want to code
34:51 - along
34:57 - let's first create a new variable that i
34:59 - called ground surface
35:01 - and to import this one we are going to
35:03 - need the same setup so pygame dot image
35:05 - to load
35:06 - i want to look at graphics and in there
35:10 - we have a file called ground.png
35:14 - and i guess something slightly tricky
35:15 - about this that
35:17 - this ground is not capitalized whereas
35:19 - this sky is
35:20 - and uh well that's just my mistake sorry
35:23 - about that
35:24 - but now we have our ground surface so
35:27 - this is just another image
35:29 - and let me place this right before our
35:31 - sky
35:32 - so i again want screen.lit
35:35 - this time i want ground surface and for
35:37 - now let me place it at
35:38 - position zero and zero just to see what
35:41 - happens
35:42 - and another one the code we can see an
35:45 - error because i made a typo
35:47 - so this should be graphics so now let's
35:50 - run it again
35:51 - and now we can see that we can't see the
35:54 - background
35:55 - and this again is intentional so right
35:58 - now the problem here is
36:00 - that we have our sky that's the main
36:02 - image we have
36:03 - and our ground is right behind it so our
36:06 - ground would basically be
36:08 - somewhere here ish but we can't see it
36:11 - because the sky image is
36:13 - right on top of it so it overlaps it
36:15 - entirely
36:16 - and the reason for that is that we first
36:18 - create our ground and then we put the
36:20 - sky on top of that
36:22 - and pygame always draws an order of when
36:24 - you call the code
36:26 - so in this case we first draw the ground
36:28 - and then we put the sky on top of that
36:29 - which
36:30 - doesn't really help us all that much but
36:32 - we can fix that very very easily
36:34 - all we have to do is to first draw the
36:37 - sky
36:37 - and then the ground and now we run the
36:40 - code again
36:40 - you can see the actual ground so now
36:43 - we're drawing the ground on top of the
36:45 - sky surface
36:48 - and okay right now we can see that our
36:50 - ground is
36:51 - way too high so we have to place it a
36:53 - little bit further down
36:55 - and well in here you can just play
36:57 - around with this and see what looks good
37:00 - let's try 300 this i think looks pretty
37:03 - good
37:04 - so with that we already have a fairly
37:06 - basic setup by just importing two images
37:10 - so with that we have basically already
37:12 - covered the two most basic kinds of
37:14 - surfaces
37:15 - we have a surface with a plain color and
37:17 - a surface with an image
37:19 - now there's a third kind that you can
37:21 - have a surface with some text
37:23 - and here the really important thing to
37:25 - understand is that every time you want
37:27 - to create
37:28 - text you first have to create an image
37:30 - of the text and place that on a surface
37:32 - and then you place that surface on the
37:34 - screen and this
37:36 - is a slightly cumbersome process
37:38 - although it is quite workable
37:40 - but to work with text you essentially
37:42 - need three different steps
37:44 - number one you first have to create a
37:46 - font that stores your basic font
37:48 - information
37:49 - so the style of the font and the font
37:50 - size then in the next step you use that
37:53 - font information to create some actual
37:56 - text
37:56 - and this text is going to be on the
37:58 - surface and then in the third step
38:00 - you're placing that surface on the
38:02 - actual image
38:03 - and that's really all you need so let's
38:06 - actually implement all of this
38:08 - so here i'm back in the code and the
38:10 - first thing i want to do
38:11 - is to create a font and i'm going to
38:13 - place this right in our starting
38:15 - variables
38:16 - but you could basically place it
38:17 - wherever you want and let's just call it
38:20 - test font for now
38:22 - and to create a font in pi game we need
38:25 - pygame.font.font
38:27 - and here again the first letter of the
38:29 - second font has to be capitalized
38:31 - otherwise this is not going to work
38:33 - and in here we have to specify two
38:35 - arguments the first one is the font type
38:37 - you want to use
38:38 - and the second one is the font size that
38:41 - we want to have
38:42 - and for the font size that's the easier
38:45 - one it's just an integer
38:46 - i went with 50. and for the font type
38:48 - for now i'm just going to use
38:50 - none so we are using the default font of
38:52 - pie game but we are going to change this
38:54 - in just a second so now we have a font
38:58 - and later on we are going to use that to
39:00 - display the score
39:01 - but for now i just want to write some
39:04 - basic information so we know it's
39:05 - working
39:06 - so that brings us to the second step and
39:09 - let me place this right below our other
39:11 - surfaces
39:12 - and in here i want to create a new
39:14 - surface and let's call this one the text
39:17 - surface and to create this surface we
39:20 - first need our test font
39:21 - and then the method render and render is
39:24 - going to need three bits of information
39:27 - number one is the text information
39:29 - number two if you want to anti-aliase it
39:31 - and number three is the color let's go
39:34 - through those one by one
39:35 - first up is the text and this one
39:38 - literally is just the text we want to
39:39 - display
39:40 - and in my case i am just going to call
39:42 - this my game for now
39:44 - next up is anti-aliasing and
39:47 - anti-aliasing basically means that we
39:49 - are going to smooth the edges of the
39:51 - text
39:51 - which in this case is not something we
39:54 - want to do because we are working with
39:55 - pixel art
39:56 - but if you are working with any text
39:58 - that's not pixel art you
40:00 - basically always want this to be true
40:01 - because it makes your text look a little
40:03 - bit better
40:05 - and then finally we have our color and
40:07 - here again we can use the same kind of
40:08 - approach we have seen earlier
40:10 - so in this case i want to go with let's
40:13 - go with green this time
40:14 - so essentially i'm going to create some
40:16 - text that says my game
40:18 - and it's green that's really all that's
40:20 - happening here
40:21 - and with that we have a surface so now
40:24 - all we have to do is to use screen
40:28 - dot blit again use our text surface
40:31 - and now place this somewhere in the
40:34 - middle of the screen at the top
40:35 - and the numbers here don't have to be
40:37 - specific we are learning later on a
40:39 - better way to place text
40:41 - but i know in this case our window is
40:43 - 800 pixels wide and 400 pixels high
40:46 - so i want to place this roughly at 300
40:48 - from the left
40:49 - and 50 from the top and now let's
40:52 - actually run this
40:53 - and there we go we can see my game right
40:56 - in the top of the screen
40:57 - now obviously the font doesn't really
40:59 - match the rest of the game
41:01 - and this we can work on right now
41:03 - actually so right now we have the
41:05 - problem that we are using the default
41:07 - font of pygame which
41:08 - is none up here which well doesn't look
41:11 - particularly good
41:13 - but if we specify a specific file in
41:16 - here
41:16 - we can use a much better looking font
41:21 - and again if you look at the folder
41:23 - there's one specific file that we can
41:26 - use
41:27 - so so all i have to do is go to font
41:30 - and in front we have a file called pixel
41:32 - type and this is a ttf file
41:35 - so this specifies a font and all i want
41:38 - to do
41:38 - is to import this file so i specify it
41:41 - in here
41:42 - so we have our font and then
41:43 - pixeltype.ttf
41:46 - and now we're on the code we can see a
41:48 - very different looking text
41:50 - and this one i think looks much better
41:53 - and i guess the green color doesn't work
41:55 - too well with it so let's go with black
41:57 - for now
41:58 - and yeah this is looking much better now
42:01 - so with that we have the three different
42:03 - kinds of surfaces
42:04 - that we can draw some text we can draw a
42:07 - basic color
42:08 - and we can also import some images and
42:10 - display them
42:11 - and this is already bringing us so much
42:13 - closer to an actual working game
42:15 - but obviously right now nothing is
42:16 - moving which isn't great for a game
42:19 - so let's actually start animating some
42:21 - of this
42:22 - and the logic to animate something in
42:24 - pygame is actually fairly
42:25 - straightforward and here again you have
42:28 - to remember the basic logic about video
42:30 - games i talked about earlier
42:32 - so right now we are drawing three
42:34 - different images
42:35 - our sky our ground and our text and we
42:38 - always place them in the same position
42:41 - and the important thing you really have
42:42 - to understand here is that we are not
42:44 - drawing a static image right now
42:46 - it just looks like a static image to us
42:48 - but essentially we are updating this
42:50 - entire image over and over again 60
42:52 - times per second
42:54 - now the problem for us right now is that
42:56 - we are placing all of these images
42:58 - always in the same position and this is
43:00 - what it looks static to us
43:02 - but if we were to update the position of
43:04 - each of these surfaces
43:06 - we would get a moving image so really
43:09 - all we have to do in the most basic
43:10 - sense
43:11 - is when we use screen.blit we don't use
43:13 - one constant position
43:15 - instead we use a variable that we
43:16 - continuously update
43:18 - and once we have that we have a moving
43:21 - image that's literally all it is
43:23 - so what i want to do in this section is
43:25 - to get our snail enemy
43:27 - and move it from the right of the screen
43:28 - to the left of the screen
43:30 - so well let's actually jump into our
43:32 - code and let's have a look at this here
43:34 - i'm back in my code
43:35 - and the first thing i want to do is to
43:37 - import our snail image
43:39 - so let me call this snail surface
43:42 - and here again we need pygame.image.load
43:46 - and the path to the snail is graphics
43:50 - snail and snail one
43:52 - there are multiple snail images because
43:54 - they show an animation of the snail
43:56 - itself we're going to cover that later
43:58 - on but for now just work with snail one
44:01 - so this would give us our snail surface
44:03 - and let me actually draw this on the
44:05 - screen
44:06 - so again i want screen dot blitz i want
44:09 - our snail
44:10 - surface and let's place this
44:13 - about 600 pixels from the left and
44:16 - 250 pixels from the top so now if i run
44:19 - this
44:20 - we can see our snail so this one is
44:22 - already working fairly well
44:25 - and the problem here right now
44:28 - is that this is static because these two
44:31 - numbers are never going to change
44:33 - we always place the snail in the same
44:35 - position and well we are placing all of
44:37 - this always in the same position
44:39 - but we don't necessarily have to do that
44:42 - what we could do for example is create
44:45 - another variable let's call this
44:47 - snail x position
44:51 - and by default this is going to be 600
44:53 - so i just copy this 600 and place it in
44:56 - here
44:56 - and then call snail x position
45:02 - so all we really did is move this 600
45:05 - into a specific variable
45:07 - so right now if we run the code we are
45:09 - going to get the same result
45:11 - our snail is still static but now what
45:14 - we can do
45:15 - is every time this while loop is running
45:18 - we want to increase
45:19 - our snail x position by one
45:22 - so that every time we come to this line
45:24 - here our snare lacks position is going
45:27 - to be increased by one
45:29 - and if we run the code now we can see
45:31 - our snail moving to the right
45:33 - because the x position is going to be
45:35 - greater on every single cycle of this
45:37 - while loop
45:39 - and now if you want to move this nail to
45:41 - the left all we need is minus equal 1
45:44 - and now our snail is going to move to
45:46 - the left and this is already working
45:48 - pretty well
45:49 - and well minus one is probably a bit
45:51 - slow let's go with four
45:53 - and yeah this looks like a decent speed
45:56 - cool but now obviously once the snail is
45:59 - leaving the screen this snail is going
46:01 - to keep on moving to the left and we
46:02 - will never see it again
46:05 - so this isn't great yet but
46:08 - really all we have to do to overcome
46:10 - this is use an if statement
46:12 - that if our snail exposition is too low
46:15 - we want to again put our snail
46:16 - exposition on a higher number
46:18 - and this is a very simple if statement
46:21 - and this could actually be an exercise
46:23 - try to figure out how you could place
46:24 - the snail on the right of the screen if
46:26 - it crosses the left side of the screen
46:33 - let's try together now so i want to use
46:36 - an if statement
46:37 - and i want to look at my snail x
46:38 - position and really i want to do
46:41 - is to check if this is smaller than
46:43 - let's say minus a hundred
46:45 - and if that is the case i want to get my
46:47 - snail x position
46:49 - and set it to something like 800
46:54 - and now if i run the code i can still
46:57 - see the snail
46:58 - if it moves too far to the left now it
46:59 - reappears on the right
47:01 - and well really all that's happening
47:03 - here is we look at this point here
47:06 - so about minus 100
47:09 - and if our snail x position so this
47:11 - point here
47:13 - gets further to the left than that we
47:15 - are putting this position
47:16 - all the way over here
47:20 - so this way it looks like our snail is
47:22 - looping
47:23 - but really all we're doing is we're
47:24 - looking at this snail x position and we
47:26 - are updating it
47:27 - and then placing the snail in a specific
47:29 - part so really all we are seeing right
47:31 - now
47:31 - is that our snail is continuously
47:33 - updated and our brain interprets all of
47:35 - this as a moving image but okay
47:38 - and i guess now what we can actually do
47:41 - just to illustrate how the animation
47:42 - works
47:43 - is this clock.tick right now is at 60.
47:46 - but if i set it to 1 you can actually
47:49 - see what's happening
47:50 - so now let me run the code again and now
47:53 - you can see the snail
47:54 - is just being updated a little bit
47:56 - further to the left every single time
47:58 - and we're just drawing a new image every
48:00 - single time
48:02 - and if this is slow enough it looks like
48:05 - well our snail is very sloppy
48:09 - and on the counter side if i set this to
48:11 - something like 600
48:14 - then our snail is going to be
48:16 - significantly faster
48:18 - so because of that our frame rate
48:21 - is really important and we really want
48:23 - to make sure that this stays at least
48:25 - somewhat constant
48:28 - so all right with that we have a basic
48:31 - animation so this is already going
48:32 - pretty well
48:35 - now before we continue there's one more
48:38 - thing i do want to show you guys
48:39 - and let me just comment out all the
48:42 - images we have drawn earlier
48:44 - so right now we have no sky we have no
48:46 - ground and we have no text
48:48 - the only thing we are drawing is the
48:50 - snail and
48:51 - now we run the code we get a very
48:54 - strange looking result
48:56 - and the reasons for that should make
48:58 - sense if you think about it for a tiny
49:00 - bit
49:00 - that right now all we are drawing is the
49:02 - snail and the snail doesn't cover the
49:04 - entire screen
49:06 - so every time we are updating this
49:08 - surface
49:09 - we don't really get rid of the previous
49:11 - frame we're just drawing on top of it
49:13 - and since we are not drawing on the
49:14 - entire surface we can still see the
49:17 - previous frame
49:18 - and as a consequence it just looks like
49:20 - we are stretching out something which
49:21 - well
49:22 - looks terrible so always keep in mind
49:25 - that you want to draw a proper
49:27 - background for your display surface
49:29 - otherwise you will be able to saw the
49:31 - previous frames you are drawing which
49:32 - looks very strange
49:34 - unless well it's something you actually
49:35 - want to achieve
49:37 - but okay so with that we have our basic
49:40 - animation
49:40 - and this is already looking pretty good
49:42 - i think and there's one more thing i
49:43 - would like to talk about before we get
49:45 - into the next section
49:47 - and that is converting our surfaces so
49:50 - let me go to the surfaces right now we
49:53 - have imported
49:54 - three different surfaces we have our sky
49:58 - we have our ground and we have our snail
50:01 - and right now all of them used to be png
50:03 - files
50:04 - and this is fine for basic setup however
50:08 - ideally we would like to convert all of
50:10 - them into something pygam can work with
50:12 - more easily
50:13 - and this we can do very easily all we
50:15 - have to do
50:16 - is to add the line.convert after we are
50:19 - importing an image
50:20 - and this i do want to do for all of the
50:24 - imported images
50:26 - and all this really does is it converts
50:28 - the image to something pi game can work
50:29 - with more easily so our game is going to
50:31 - run faster
50:32 - that's really all that's going to happen
50:34 - here but now
50:35 - if i run this we're going to see
50:36 - something strange so now our snail is
50:39 - going to look well
50:40 - slightly weird and the problem here is
50:43 - that we didn't respect the alpha values
50:45 - so this is all the white and black stuff
50:47 - behind the snail
50:49 - and to get rid of that all we have to do
50:51 - is change convert to convert
50:53 - alpha and that way we are removing the
50:56 - alpha values
50:57 - enough around this now we can see our
50:59 - snail properly and you can't
51:01 - really see a difference however now our
51:03 - game should be running faster at least
51:05 - in theory
51:06 - and especially once we have more stuff
51:08 - on the screen this might become
51:09 - important
51:10 - although in our case it really shouldn't
51:12 - make that much of a difference
51:13 - but it's generally good practice so
51:15 - don't forget to add this line
51:17 - every time you import an image so with
51:20 - that i do want to start working on the
51:22 - player character
51:23 - however there's one more really
51:25 - important concept we have to cover
51:27 - to really make the player character work
51:30 - and that is called a rectangle
51:32 - and rectangles in pygame essentially
51:34 - have two different functions
51:36 - at least in the most basic sense they
51:37 - can do quite a few more things
51:39 - but the two core functions of rectangles
51:41 - are this
51:42 - number one is that they're helping you
51:44 - place a surface much more efficiently
51:46 - and much more precisely
51:47 - and number two rectangles are going to
51:49 - help you detect collisions
51:52 - something we are going to see very soon
51:54 - but for now i do want to focus on using
51:56 - rectangles to place a surface on the
51:58 - screen
51:59 - so let me explain what we are going to
52:01 - do right now when we place the snail we
52:04 - couldn't really place it precisely
52:06 - because we can only ever place the top
52:07 - left which made it very difficult to
52:10 - place the bottom of the snail
52:11 - right on the ground so ideally we would
52:13 - like to grab a point on the bottom of
52:15 - the snail and place that point
52:18 - which we couldn't do with surfaces by
52:20 - themselves but something we could do
52:21 - with rectangles
52:23 - and this is something that you see all
52:25 - the time in pygame
52:26 - that you separate placing images in two
52:28 - different steps
52:29 - the actual image information is placed
52:31 - on the surface
52:33 - but then the position information is
52:35 - placed in a rectangle
52:36 - so essentially you are splitting your
52:38 - image into two different variables
52:41 - that you then have to control together
52:43 - and much later on in this tutorial
52:45 - we are going to see the sprite class and
52:47 - this one combines these two so you can
52:49 - work with them more efficiently
52:51 - so then how does a rectangle work well a
52:54 - rectangle is
52:55 - a well rectangle but this rectangle has
52:58 - a couple of points that we can work with
53:00 - we can either get points that are a
53:02 - tuple so they have an x in the y
53:03 - position
53:04 - or we can have points that are
53:06 - individual positions like left and right
53:08 - you can see all of them on the screen
53:10 - right now and we can grab each of these
53:12 - points and either measure
53:13 - or move them and if we move any
53:15 - individual point on a rectangle
53:17 - we move all the other points as well so
53:20 - the points always stay relative to each
53:22 - other
53:23 - and then we can use a rectangle to place
53:26 - a surface
53:27 - right in the middle of the rectangle so
53:29 - a rectangle we could place for example
53:31 - in the top
53:32 - left or in the center on the bottom mid
53:34 - or on the mid right we could literally
53:36 - place all of these points
53:38 - and then we can use that information to
53:39 - place the surface
53:41 - right into this rectangle and that way
53:43 - we are going to have much more control
53:45 - over how our surface is going to be
53:47 - placed
53:48 - and later on we can also use that
53:49 - rectangle to detect collisions
53:51 - but that's coming later for now let's
53:54 - just use a rectangle to place a surface
53:57 - so here i'm back in the code and the
53:59 - first thing i would like to do is to
54:00 - import the surface of the player
54:02 - so let's call this for now player
54:05 - surface
54:06 - and this again we just have to go with
54:09 - pygame.image.load
54:10 - and here the path is in graphics
54:14 - and for this one the path is graphics
54:16 - player
54:17 - player walk1 so again we have multiple
54:20 - images that we are later going to use
54:21 - for animation but for now we're just
54:23 - going to use
54:24 - one and this again i want to use with
54:26 - convert alpha
54:28 - so it's going to run slightly faster
54:31 - and let's just put this on the screen so
54:34 - we can see it
54:35 - so i want to use screen dot blit again
54:38 - i want to place my player surface
54:41 - and for now let's place it let's say
54:44 - 80 pixels from the left and 200 pixels
54:47 - from the top
54:48 - and now let's see how it looks now we
54:50 - can see our player
54:51 - and here you can already tell that
54:53 - there's a distance between
54:55 - the bottom of the player and the ground
54:57 - so this
54:58 - area here we want to bridge but the
55:01 - problem is
55:02 - that well we don't really know how big
55:05 - this area here has to be
55:07 - so placing just the top left of the
55:08 - player is very difficult
55:11 - and to fix that we are going to use a
55:14 - rectangle
55:15 - so step number one for this is we have
55:17 - to create a rectangle
55:18 - and there are different ways to do that
55:21 - so for now let's just call it the player
55:23 - rectangle and in the most basic sense
55:26 - you could create a
55:27 - rectangle by using pygame.rect and
55:30 - in here you could specify a left a top
55:33 - the width
55:33 - and the height and then this would
55:35 - create a rectangle
55:36 - however this is not something you see
55:39 - all that often actually
55:40 - because ideally you want to have a
55:42 - rectangle that is the exact same size
55:44 - as this surface and this we can create
55:48 - all we're going to need is our player
55:49 - surface so player surface
55:52 - and then the method get rekt
55:56 - so all that this get rekt does is it
56:00 - takes a surface
56:01 - and then it draws a rectangle around it
56:04 - and then for this rectangle
56:05 - we can specify a specific position where
56:08 - we want to place it
56:09 - so in here we could for example use top
56:11 - left
56:12 - and then give it an x and a y position
56:15 - so here for example
56:16 - i could copy the information from down
56:19 - here
56:19 - and just place it in there and let's
56:21 - just start with that so
56:23 - let me copy all of this and now we have
56:26 - a rectangle that is
56:27 - in the same position as our surface used
56:29 - to be
56:30 - and now when we use blit we can use a
56:33 - rectangle to place
56:34 - this surface so all i have to do in here
56:37 - is insert
56:37 - player right so now essentially what we
56:40 - are doing
56:40 - we are taking a player surface and we're
56:43 - placing it in the position of this
56:44 - rectangle
56:45 - so now if i run this we can see no real
56:49 - difference
56:49 - because the rectangle is in the same
56:51 - position where the surface used to be
56:53 - but what we can do for example now use a
56:55 - different position on this rectangle for
56:58 - example we could use
56:59 - mid left instead of top left and now if
57:01 - we run this
57:02 - our player is slightly higher or we
57:05 - could also use
57:06 - mid bottom and now our player
57:10 - is again in another position and really
57:12 - what you have to understand about this
57:14 - is that we are placing
57:15 - this point here right at the bottom of
57:17 - the player
57:18 - whereas for surface we always grab this
57:21 - point
57:21 - up here so let me draw a rough rectangle
57:23 - around it
57:25 - so for surface we always place this
57:27 - point but for a rectangle we can grab
57:30 - any of these points around it there are
57:33 - lots of points we can grab
57:35 - and that way we can have much more
57:37 - control over what point we want to place
57:40 - so this is super useful and now
57:44 - we can use that to place the player
57:47 - right on the ground and we know where
57:49 - the bottom of the player has to be
57:50 - because we know the ground
57:52 - is at position 300 so that's when the
57:54 - ground starts
57:55 - so the bottom of our player has to be on
57:57 - this position as well
57:59 - so let's say for the mid bottom i want
58:01 - to go with 300
58:03 - and now let's run this and now we can
58:06 - see our player is touching the bottom
58:07 - perfectly
58:08 - and here again you might be wondering
58:10 - that this setup is kind of
58:12 - tedious and time consuming so that
58:14 - whenever we want to place a surface and
58:16 - have any control over how it's going to
58:18 - be placed
58:19 - we always have to create two variables
58:20 - first a surface and then a rectangle
58:23 - and i agree it is quite cumbersome and
58:26 - later on in this tutorial
58:28 - we are going to see a sprite class
58:31 - and a sprite class essentially combines
58:34 - a surface and a rectangle and places
58:35 - them in one class
58:37 - and this makes it much easier to work
58:38 - with them so later on we are going to
58:40 - make all of this much more streamlined
58:43 - but for now i do want to work with them
58:45 - separately so you understand them better
58:47 - so with that we have our player
58:49 - rectangle
58:50 - and now what we can do with this player
58:52 - rectangle we could move every single
58:54 - point of this rectangle
58:55 - and then use that to control the surface
58:58 - so for example what i could be doing
59:00 - right in our game loop i want my player
59:03 - rectangle
59:04 - and i want to grab any individual point
59:06 - from it so for example i could get
59:08 - the left of the player and this i could
59:11 - either measure or
59:12 - move so really what i could do here for
59:14 - example is just move this to the right
59:17 - so add plus one to it
59:19 - and now if i run this we can see our
59:21 - player moving to the right
59:23 - so this is how you would actually move
59:25 - something in pygame
59:26 - that you don't move the surface instead
59:28 - you move the rectangle that contains the
59:30 - surface
59:32 - but what you can also do is you can
59:34 - print
59:35 - this information so i just want to print
59:38 - it
59:39 - and now you can see that the left of our
59:41 - players are position 48
59:44 - so we know that this line here is 48
59:48 - which can be really useful to measure
59:50 - different things
59:52 - so this is stuff that is going to be
59:53 - really useful but for now
59:55 - i don't really going to need it but
59:57 - something i do want to do
59:59 - and this could be a really good exercise
60:00 - for you as well is that i want you guys
60:02 - to update this snail
60:04 - that we don't just use the surface to
60:06 - move it instead i want you guys to place
60:07 - a rectangle around the snail
60:09 - and then influence that rectangle to
60:11 - move the snail
60:12 - so if you want to code long pause the
60:14 - video now and try this yourself
60:20 - all right let's try together now so my
60:23 - snail
60:24 - is this line here and this net
60:26 - exposition i don't need anymore
60:28 - instead i want to create a snail
60:31 - rectangle
60:32 - and let me use the surface
60:35 - line a bit more consistently so instead
60:37 - of writing surface i always write surf
60:39 - because it's a bit shorter
60:41 - and i really like to keep this a bit
60:42 - more consistent
60:44 - so faster surface i just write snail
60:46 - surf that makes it a bit easier to read
60:48 - i think
60:49 - but okay now to get this rectangle i
60:52 - want to get my snail
60:53 - surface again and call get wrecked on it
60:57 - and now again in here i have to specify
60:59 - a position where i want to place this
61:01 - rectangle
61:02 - and here again i could use mid bottom
61:04 - again
61:05 - but just to mix things up a bit i could
61:07 - use the bottom
61:09 - right for example although in this case
61:11 - it really doesn't make much of a
61:12 - difference
61:14 - and where i used to place this was at
61:16 - position 600
61:18 - and now for the height i want to go with
61:19 - 300 so again
61:21 - the important coordinates that we have
61:23 - to worry about
61:24 - is this ground here this is where our
61:27 - snail has to be on top
61:28 - so when we specify the bottom of our
61:30 - snail it has to be the same
61:32 - position so just keep that in mind
61:36 - and now we just have to use that
61:37 - rectangle to place the snail
61:40 - and that happens on this line here so
61:43 - now instead of placing it in this one
61:44 - position
61:45 - i just want to use my snail rectangle
61:49 - and along with that we don't need all of
61:53 - this information anymore
61:54 - so let me get rid of it and instead i
61:56 - want to do all of this with a rectangle
61:58 - but let's first try if it works in the
62:00 - first place and there we go
62:02 - now we can see our snail right on the
62:04 - ground this already looks much more
62:06 - realistic but now i do want to move the
62:08 - snail
62:09 - and well for that all i need is my snail
62:12 - rectangle
62:13 - and then get one of the points that we
62:15 - want to move so
62:17 - here you can really pick any point you
62:18 - like let's say in my case i want to go
62:21 - with
62:21 - x and this i just want to move by minus
62:24 - equal
62:24 - let's say 4. and now if i run this
62:28 - we can see our snail moving again and
62:30 - now if you want to move the snail back
62:32 - to the right of the screen
62:33 - all i need is an if statement and get my
62:35 - snail wrecked again
62:37 - and here we want to measure if our snail
62:39 - leaves the screen
62:41 - so effectively what i want to know is
62:43 - when the right side of the snail
62:44 - is smaller than zero because then i know
62:47 - the snail
62:48 - has left the screen so what i want is to
62:50 - get the right side of the snail
62:51 - and check if this is smaller or equal to
62:54 - zero
62:55 - and if that is the case i want to get my
62:57 - snail wrecked
62:59 - again and now i want to place the left
63:02 - and this is supposed to be at position
63:05 - 800 because 800
63:08 - is our right side of the screen
63:11 - it's that position up here and well
63:15 - with that line this snail should be
63:17 - working okay
63:18 - so let's try this now and we can see our
63:21 - snail moving to the left
63:22 - and now it reappears and this way we
63:25 - have
63:25 - much more control over the different
63:27 - points of our snail so this
63:29 - is super useful but this is essentially
63:31 - it when it comes to using rectangles to
63:33 - position
63:34 - surfaces it really is quite tedious
63:37 - especially early on
63:38 - but once you get used to this this is
63:39 - actually quite a powerful system
63:42 - but alright with that one we can learn
63:44 - about this second aspect of rectangles
63:46 - where they are really useful
63:48 - and that is collisions so what i want to
63:50 - do for this section
63:51 - is to get a collision between our snail
63:53 - and our player
63:54 - and this is actually super easily done
63:56 - with rectangles
63:58 - because all i really want to do is to
64:00 - check if there's a collision between the
64:01 - player
64:02 - and the snail or the rectangles that
64:04 - contain them
64:05 - and this can be done with the collide
64:07 - rect method which just checks if one
64:09 - rectangle is colliding with another
64:11 - rectangle that's
64:12 - really all that's happening here so
64:15 - let's jump right into our code and let's
64:17 - implement this
64:19 - so here i'm back in the code and all i
64:21 - want to do is go
64:22 - right to the bottom and
64:26 - in here i want to check if my player
64:28 - rack is colliding with the snail right
64:30 - and really all i have to do is to get my
64:32 - player rectangle
64:33 - and use collide rect
64:37 - and in there i have to place the other
64:39 - rectangle i want to check against
64:41 - so this would be my snail rectangle
64:44 - and this method returns either a zero
64:48 - or a one so if there's no collision we
64:51 - get a zero
64:52 - if there is a collision between these
64:53 - two rectangles we are going to get a one
64:56 - and that information we can then use in
64:58 - an if statement
64:59 - but first let me print the entire thing
65:01 - so just you can see what's actually
65:03 - happening here
65:05 - so now if we run this we can see lots of
65:07 - zeros but once the snail is colliding
65:09 - with the player we can see
65:10 - once then we go back to zeros then we go
65:12 - back two once all the way down here
65:15 - and this happens over and over again so
65:17 - we can tell that this
65:19 - here is returning one so this i can then
65:22 - use
65:22 - an if statement so in here you could
65:25 - write
65:26 - if this is equal to one but
65:29 - since python automatically converts a
65:31 - zero to false we don't really need that
65:34 - so this line here by itself is fine as
65:36 - well
65:38 - and well if that is the case let me just
65:40 - print
65:41 - collision just to see if it works and
65:44 - now if i run this
65:46 - we can see a collision once the snail is
65:48 - colliding with the player
65:50 - so we know this line here is working but
65:52 - there's one thing you really want to
65:54 - keep in mind here
65:55 - that this might trigger multiple times
65:58 - because right now
65:59 - when our snail is overlapping with the
66:01 - player
66:02 - pygame checks every single frame of the
66:05 - game if there's a collision or not
66:06 - so if we just had this line then this
66:09 - collision might trigger multiple times
66:12 - which if you have some kind of health
66:13 - system would be a big problem
66:15 - because later on we are going to end the
66:16 - game once there's a single collision
66:19 - but if you have a hard system or some
66:20 - kind of health bar you really want to
66:22 - make sure you only have a single
66:24 - collision and then you have some kind of
66:26 - invincibility frames
66:27 - something lots of games actually have
66:29 - but in our case this kind of collision
66:31 - system is
66:32 - fine and this would be then the basics
66:35 - of collision
66:36 - now there's a different kind of
66:38 - collision that you can use with
66:39 - rectangles and that's collide point
66:42 - and this is not something we are going
66:44 - to use too much but it is also quite
66:46 - important
66:46 - so i do want to talk about it and all
66:49 - that collide point really does
66:50 - is it checks if one point collides with
66:52 - a rectangle the name should kind of make
66:54 - sense here
66:56 - and this isn't something you are going
66:57 - to use too often however
67:00 - if you ever want to click with a mouse
67:02 - on something then collide point is
67:03 - incredibly important
67:05 - and this is kind of why i'm going to
67:06 - talk about it so in this section
67:08 - we are going to talk about collide point
67:11 - and using the mouse and pygame
67:13 - just as a small interlude we're not
67:14 - going to use it too much
67:16 - so let's go for both of these and let's
67:18 - first talk about politepoint
67:20 - we are basically calling this like
67:22 - collide right so we first need our
67:24 - rectangle and then calling this as a
67:26 - method
67:26 - but now as an argument into collide
67:28 - point we don't pass in a rectangle
67:31 - instead we have to pass in a tuple with
67:32 - an x and a y position
67:35 - and then pygame checks if this one
67:36 - position is inside of the rectangle or
67:38 - not
67:39 - and then it again is going to return
67:41 - something that we can use in an if
67:42 - statement
67:43 - so far so good but now how can we get
67:46 - individual points
67:47 - or rather how can we measure the mouse
67:49 - position
67:51 - and for that pi game has two different
67:53 - approaches
67:54 - we could either target the mouse with
67:55 - pygame.mouse
67:57 - or we could look in the event loop and
67:59 - check the events that check the mouse
68:01 - position
68:02 - those basically get you the same
68:03 - position but there are two different
68:05 - ways to approach it
68:06 - and well i'm going to demonstrate both
68:09 - so the first one is pygame.mouse
68:11 - and this one gives you lots of
68:12 - information about the mouse for example
68:14 - the position
68:15 - or what buttons are being pressed you
68:17 - could also set the position of the mouse
68:19 - or if the mouse is visible in the first
68:21 - place
68:22 - and if you check the documentation there
68:24 - is quite some more stuff you could be
68:25 - working with
68:27 - but in my case i am only going to work
68:29 - with get pressed and get position
68:31 - so get the mouse buttons pressed and get
68:32 - the position of the mouse
68:34 - now besides that approach you could also
68:37 - use the events
68:38 - so when we have the event loop in there
68:40 - you could also work with the mouse
68:41 - position
68:42 - but that was quite a bit of talk let me
68:44 - actually implement all of this
68:47 - so here we are back in the code but now
68:49 - what i want to do
68:50 - is to check if our mouse is also
68:51 - colliding with the player
68:53 - and just to make this a bit easier to
68:55 - see i'm going to comment this one out
68:57 - for just a second
68:58 - so we don't get too much at the same
69:00 - time
69:01 - so i again want to get my player
69:04 - rectangle
69:06 - and i want to get collide
69:09 - point and in here we have to pass in a
69:12 - tuple that has
69:13 - x and y positions so this is the point
69:16 - we want to measure
69:17 - if it is inside of the player rectangle
69:19 - and then again we can use this
69:21 - inside of an if statement and check and
69:24 - print
69:25 - if there's a collision
69:29 - now then the important question is how
69:30 - do we get this x and y position
69:33 - so let me put this inside of a new
69:34 - variable that i'm going to call mouse
69:37 - position
69:39 - and to get the x in the y of the most
69:40 - position all we need is
69:44 - pygame.mouse.getposs
69:46 - and this would give us an x and the y
69:47 - position that we can then use
69:49 - inside of this so what i want to do is
69:52 - to copy my mouse position
69:53 - and place it in here so now let me
69:56 - activate the mouse
69:57 - and now if i run the game now i can see
70:00 - my mouse and if i hover over
70:02 - the player with my mouse you can see
70:03 - collision so this one is already working
70:06 - quite well
70:07 - so really all we have done here is we
70:10 - have used
70:10 - this pygame.mouse and used getpost to
70:13 - get the position of the mouse this one
70:14 - should be quite straightforward
70:16 - now pygame.mouse has quite a few more
70:18 - methods that we can use
70:20 - and one would be get pressed so let me
70:22 - call this one
70:23 - if we are hovering over playerrec so
70:27 - pygame.mouse.get
70:28 - pressed and of course i do want to print
70:32 - all of that information and now we run
70:35 - the code again
70:36 - and you can again see my mouse i hover
70:39 - over the player
70:40 - and now you can see faults falls and
70:41 - faults and this
70:43 - is a boolean value for each of my mouse
70:45 - buttons
70:48 - so if i press any of the mouse buttons
70:50 - and let me scroll down a tiny bit here
70:51 - actually
70:54 - so now you can see all of my mouse
70:56 - buttons and if i press the left mouse
70:57 - button you can see true
70:59 - if i press the right mouse button you
71:00 - can see true on the final boolean
71:02 - statement
71:03 - and if i press the middle mouse button
71:04 - you can see true in the middle
71:06 - so this is basically which mouse button
71:08 - i am pressing
71:10 - so that way you could check if i am
71:12 - pressing different mouse buttons
71:14 - so that way you could check what the
71:16 - mouse position is and what buttons are
71:18 - being pressed
71:19 - so this would be one way to approach
71:21 - this now what we can also do
71:23 - in the event loop we can also access the
71:25 - mouse position
71:27 - so we want to check for a different kind
71:28 - of event and this would be if
71:30 - event dot type is equal to pygame
71:34 - dot mouse motion all in uppercase
71:37 - letters
71:38 - and this would give us the mouse
71:40 - position
71:41 - and this would only trigger if we move
71:43 - the mouse so if you don't move the mouse
71:46 - this is not going to give you anything
71:48 - but once you do have it
71:49 - you can print the event position
71:54 - so this would then give us also the
71:55 - mouse position and now let me run this
71:57 - code again
71:58 - now i can see my mouse again and now
72:00 - okay let me scroll down again
72:04 - now you can see wherever i move my mouse
72:06 - you can see the actual position so if
72:08 - you move to the top left you can kinda
72:10 - get closer to zero and zero
72:12 - and if i get to the bottom right you can
72:14 - see close to eight hundred and four
72:16 - hundred
72:18 - and well that way we can also get our
72:19 - mouse position
72:22 - so this would be another way to approach
72:23 - this now another thing that you could
72:26 - use in here
72:27 - is mouse button up
72:30 - and mouse button down so this would ever
72:33 - check if we are pressing the mouse
72:34 - button down
72:35 - or if we are releasing it so let me
72:37 - start with mouse button down
72:38 - and if that's the case i just want to
72:40 - print mouse
72:42 - down so now let me run this again
72:46 - and let me spell all of this correctly
72:48 - now this works
72:49 - and now whenever i click we get mouse
72:51 - down
72:53 - and now if we change this to mouse
72:54 - button up this is only going to be
72:56 - triggered once we release the mouse
72:58 - button
72:58 - so let me go with mouse up
73:01 - and if i run this now well you can't
73:03 - really see it but now i'm pressing the
73:04 - button
73:05 - and nothing happens only if i release
73:07 - the button we can see mouse up
73:09 - so this would be a good way to check if
73:10 - the button is pressed or released
73:12 - but this is basically all you have to
73:14 - know to use pygame with a mouse
73:16 - if you check the documentation there's
73:17 - quite a bit more about small details but
73:19 - this
73:20 - is the basic and the most important
73:21 - stuff and let's do one small exercise to
73:24 - finish
73:24 - this part off that i want you guys to
73:27 - use the event loop
73:28 - to check if the mouse is over the player
73:30 - rectangle
73:32 - and well pause the video now and see if
73:34 - you can figure this out
73:40 - let's try together now obviously i want
73:43 - to work
73:43 - in this line here and figure out
73:47 - how i can use that information to check
73:49 - if my mouse is over the player rectangle
73:52 - and well the first thing i need to get
73:54 - is the mouse position so i want to go
73:55 - with mouse
73:56 - motion and once i have that
74:00 - i can print the event
74:04 - position so this would be the first step
74:08 - to approach this and this is what we
74:09 - have seen earlier
74:10 - but now what you have to be aware of
74:13 - that this event position
74:15 - is also going to give us an x and a y
74:18 - position
74:18 - so this is something we can use in
74:20 - collide point with a rectangle
74:22 - so all we have to do in here is to check
74:25 - our
74:26 - layer rectangle and then use
74:29 - collide point with the event
74:33 - position and use this in an if statement
74:37 - and if that is the case i want to print
74:41 - let's call it collision and let me
74:44 - disable and comment out all of this down
74:46 - here so we don't get confused with that
74:48 - line
74:50 - so now in theory this should print a
74:52 - collision and let's try this
74:54 - and now we can indeed see collision all
74:57 - right
74:57 - and with that we would be having our
75:00 - mouse collision
75:01 - now for now i am going to comment all of
75:05 - those
75:05 - out but we will later on revisit them
75:09 - to implement a proper collision for our
75:10 - player and our obstacles
75:13 - but before that there's one more thing i
75:15 - would like to address and that's the
75:16 - score
75:17 - and right now the score or
75:20 - my game is not really centered in the
75:23 - middle
75:24 - of the window so this is something i
75:26 - would like to address
75:28 - and well this we can also use with
75:30 - rectangles quite easily
75:31 - but along with that i would also like to
75:34 - highlight another functionality of
75:35 - rectangles
75:36 - because rectangles can be used to draw
75:39 - images on the screen
75:40 - but let's talk about that after we have
75:42 - centered the score so we go step by step
75:45 - so let's get started by centering the
75:47 - score and this again could be a
75:49 - challenge for you
75:50 - so if you want to go long try this
75:51 - yourself right now
75:57 - all right so let's try to do it together
75:59 - and
76:00 - here we have our text surface and let me
76:03 - put this
76:04 - in like a separate paragraph and again i
76:07 - don't want surface as a whole word i
76:09 - just want surf
76:10 - i think that's a bit more readable so a
76:13 - bit further down
76:14 - we have our text surface here
76:18 - and actually i think a better way to
76:20 - call this would be score surface
76:21 - that's making more sense so let's call
76:25 - this
76:26 - score surface sorry about the renaming
76:29 - i should have really thought about this
76:31 - earlier but never mind
76:33 - so now we have our surface again and the
76:35 - first thing i want to do is to create a
76:37 - rectangle
76:38 - so i have score rect and this is going
76:40 - to be our score
76:41 - surface and i want to get get rekt
76:45 - and this score rectangle i want to be
76:48 - right in the center of the screen
76:49 - and roughly in the top of the screen
76:51 - with a little bit of an offset between
76:53 - the top of the window
76:54 - so the point i want to place is the
76:56 - center
76:58 - and in here again we need x and y and we
77:00 - know our entire window is 800 pixels
77:03 - wide
77:03 - so half of that is going to be 400
77:06 - and i think the original offset of
77:10 - 50 so the value we have specified
77:13 - down here should still be fine so all
77:16 - i'm going to do
77:16 - is to place this 50 in here and we're
77:19 - good to go
77:21 - so all i need is 50 and then i want to
77:24 - get this
77:25 - score rectangle and place it in the
77:28 - score surface
77:30 - and now if i run this we can see my game
77:34 - right in the middle of the screen so
77:36 - this is working quite well
77:37 - so far we have used rectangles for two
77:40 - different purposes
77:41 - we have used them for positioning and
77:43 - for collisions
77:44 - but there is a third one that you also
77:46 - see fairly regularly
77:47 - although not as often as the first two
77:49 - and that is you can use rectangles to
77:51 - draw
77:52 - or at least rectangles are part of the
77:54 - drawing module you can use other tools
77:55 - to draw as well
77:57 - so let me explain within pygame there's
77:59 - a sub module called draw
78:01 - and in draw you could for example pass
78:03 - in a rectangle and then you would be
78:05 - drawing this
78:06 - rectangle you could also be passing in a
78:08 - rectangle
78:09 - and then you would draw a circle inside
78:10 - the boundary box of that rectangle
78:12 - but you don't necessarily have to use a
78:14 - rectangle you could also draw a line
78:16 - from one point to another where you
78:18 - would just specify two points you
78:20 - wouldn't need a rectangle for that
78:22 - and this is also quite a useful thing to
78:24 - work with so how i want to illustrate
78:27 - this
78:27 - is i am going to give our score some
78:29 - background color so it looks a little
78:31 - bit nicer
78:32 - oh yeah and along with that we are also
78:34 - going to talk about colors after that
78:36 - but step by step so the first thing i
78:38 - want to do
78:39 - is i want to draw this score rectangle
78:43 - and well all i have to do for that is in
78:46 - the line before that
78:47 - i have to call pygame.draw.rect
78:51 - and all that's happening here is the
78:52 - first help again we want to draw a
78:54 - certain thing with the draw module
78:56 - and then we want to specify what kind of
78:58 - shape we are drawing in this case it's
79:00 - going to be a rectangle
79:01 - but if you look at the documentation
79:03 - there are quite a few more shapes
79:05 - that you could be drawing for example a
79:06 - polygon or an ellipse
79:08 - but in my case i will just draw a
79:10 - rectangle
79:11 - and in here we have to specify three
79:14 - different arguments
79:15 - we first need the surface we want to
79:16 - drawn so our display surface in this
79:18 - case
79:19 - then we need a color and then the actual
79:21 - rectangle we want to draw
79:22 - so in my case this is actually quite
79:24 - easy so i want to start with
79:26 - the screen itself that's our display
79:28 - surface
79:29 - then i'm going to need a color and for
79:31 - now we are just going to use the default
79:33 - colors so let's go with pink it's
79:35 - going to look terrible but that doesn't
79:37 - matter for now and then
79:39 - i want to draw the actual rectangle so
79:42 - score rectangle
79:44 - and now if i run out of this we can see
79:46 - a pink background that doesn't actually
79:48 - look
79:48 - all that bad and in here
79:51 - well you can see that the background
79:54 - covers the text
79:55 - just about there's no margin whatsoever
79:59 - and that isn't great and
80:02 - well you can work with that quite a bit
80:05 - more so if you go to the documentation
80:07 - there are quite a few more arguments
80:09 - that you could be passing into this
80:11 - the one you are probably going to see
80:13 - the most are width and border radius
80:16 - so let's specify both of those just to
80:18 - see how they look like
80:19 - so argument number four that you could
80:21 - pass in here but don't have to repeat
80:23 - with
80:24 - and let's just pass in is six for now
80:26 - and let's just see what happens
80:28 - and now we can see something probably
80:31 - slightly weird
80:32 - that we only get the surrounding we
80:34 - don't get the actual rectangle itself
80:36 - anymore
80:37 - so this is something you should be aware
80:38 - of when you work with this
80:40 - that once you specify a line width pi
80:43 - game stops drawing the center of the
80:44 - rectangle
80:45 - so this is a little bit annoying but now
80:47 - i can also specify another argument
80:49 - and this would be the border radius so
80:52 - let me put it 20 in here
80:53 - and now we have quite a bit of rounding
80:56 - but in my case i don't want to have any
80:59 - border rounding
81:00 - i just want to keep the border with so
81:02 - now how could you draw a rectangle that
81:03 - both has a border width
81:05 - and a center that's colored and well all
81:08 - you really have to do
81:09 - is to copy this line and then add one
81:12 - without a width and one with one so now
81:14 - if i run this
81:15 - we can see that we have a bit more of a
81:17 - margin around the text
81:19 - and let me change this to a 10 and now
81:22 - let's try this again
81:23 - and this is looking marginally better
81:25 - not great
81:26 - but i would say good enough so
81:29 - this is something you could work with to
81:31 - draw different kind of shapes
81:33 - and let's just play around with this and
81:36 - this could be a really good exercise
81:38 - so i want you guys to look at the
81:39 - documentation and just draw a line from
81:42 - the top left of the screen to the bottom
81:43 - right of the screen
81:44 - so check out the documentation and see
81:47 - if you can figure this out yourself
81:54 - right welcome back so right now here's
81:57 - the documentation
81:58 - and in there we have two methods that
82:00 - can be used with us
82:01 - we have pygm.draw.line and
82:04 - pygm.draw.antialias line or aa line
82:07 - and those two basically do the same
82:09 - thing except one line is anti-alias the
82:11 - other one isn't
82:12 - and those two for the most part are
82:13 - going to be identical so i'm just going
82:15 - to work with line
82:16 - and if we look at this one in more
82:18 - detail this one is going to need five
82:20 - different arguments
82:21 - we have a surface a color a start
82:23 - position and end position and a width
82:25 - so that's really all we need and
82:29 - well let's implement that so here i'm
82:31 - back in the code
82:32 - and let me add a new line with
82:35 - pygm.draw.line
82:37 - and in here we are going to need five
82:38 - different arguments
82:40 - so the first one is this green or what
82:42 - surface we want to draw on
82:43 - then we need a color for now let's go
82:45 - with gold
82:47 - and then we are going to need two points
82:49 - so the start point
82:50 - and the end point and both have to be
82:52 - two builds
82:53 - and since i want to start in the top
82:55 - left and end it in bottom right
82:57 - i have to start with zero and zero so
82:59 - the top left and the bottom right is 800
83:02 - and 400 and now i have to specify a
83:05 - width
83:06 - so let's go with 10 but you could leave
83:08 - out this argument but let's specify it
83:11 - and if we run this we can see a line
83:13 - going from the top left to the bottom
83:14 - right
83:16 - and even better what you could for
83:17 - example be doing in here
83:19 - is replace this with pygame dot mouse
83:22 - dot
83:22 - get pause and now what you would get
83:26 - is a line that always follows the mouse
83:28 - which is kind of cool i think
83:32 - but we don't really need it so let me
83:34 - get rid of it
83:35 - and let's do one more that i just want
83:36 - to draw a circle
83:38 - and this would be an ellipse and for the
83:41 - ellipse
83:42 - we would again need the surface to drawn
83:45 - now we need a color let's go with brown
83:50 - and this rectangle is going to be the
83:51 - bounding box for the surface
83:54 - and really what we can do in here is
83:56 - generate this surface on the fly
83:59 - and we could do one of the rectangles we
84:00 - have created earlier
84:02 - although what i also want to cover is
84:04 - that we haven't created a rectangle from
84:06 - scratch yet
84:07 - which can also be useful sometimes so
84:09 - what i want to do in here
84:10 - is pygame.rect so we are creating a
84:13 - rectangle
84:14 - right inside of the method and this is
84:16 - going to need four arguments
84:18 - we need the left argument the top the
84:21 - width and the height so let's place this
84:25 - i don't know 50 pixels from the left
84:28 - let's say 200 pixels from the top
84:30 - i want this to be a hundred pixels wide
84:34 - and 100 pixels high and now let's run
84:36 - this
84:37 - and now we are getting a circle
84:40 - or well an ellipse with an equal width
84:42 - and height but that doesn't really
84:44 - matter
84:45 - but we do have a problem right now that
84:49 - the colors don't really match up so when
84:52 - i open this again
84:53 - the black text and the pink background
84:55 - just don't look very good
84:57 - and the problem here is that for now we
85:00 - always rely on the predefined colors
85:02 - which can be okay for starting point but
85:05 - don't look
85:06 - too great so how could we specify more
85:08 - specific colors
85:11 - and there are two ways to specify colors
85:13 - in pygame and this also applies to
85:14 - basically any other program
85:16 - and they're called rgb colors and
85:18 - hexadecimal colors
85:20 - and they do essentially the same thing
85:22 - so let me start with rgb colors
85:25 - all that rgb stands for is red green and
85:28 - blue that's
85:29 - really all it means and all we are doing
85:31 - here is that we are specifying how much
85:33 - of each color we would like to have
85:36 - and then pie game mixes all of them
85:37 - together and we are getting one
85:39 - customized color
85:40 - out of that that's really all we are
85:41 - doing and for each color you can choose
85:43 - between 0
85:44 - and 255 with 0 being the absence of the
85:47 - color
85:48 - and 255 being the full color so for an
85:51 - rgb value we would specify a tuple with
85:54 - three different values
85:55 - one with the amount of red one with the
85:57 - amount of green and one with the amount
85:59 - of blue
86:00 - and for example if you had an rgb tuple
86:02 - with 255
86:04 - 0 and 0 you would have a plain red color
86:07 - because we would have only red
86:08 - and no green or blue and now for
86:11 - hexadecimal colors we are basically
86:13 - doing the same thing
86:14 - we just write it down in a slightly
86:16 - different way
86:18 - so we don't have a tuple anymore instead
86:20 - we have the hash symbol followed by
86:22 - six numbers and the first two numbers
86:24 - are for the red color
86:25 - the third and the fourth number are for
86:27 - the green color
86:28 - and the final two are for the blue color
86:31 - and then for each of these two we can
86:33 - specify the amount of each color we want
86:35 - to have
86:36 - and with that you basically have the
86:37 - same outcome as rgb
86:39 - now how you count how much of each color
86:41 - you have for this is slightly weird
86:43 - because the lowest possible value is 0
86:45 - and 0
86:46 - and the highest possible one is f and f
86:49 - so the counting here is slightly
86:51 - different
86:51 - if you want to read more on this i put a
86:54 - link in the description
86:55 - but essentially you are never going to
86:57 - create your own code
86:59 - instead you would use something like
87:00 - photoshop or some kind of website to
87:02 - create a color for you
87:04 - nobody ever really reads these things by
87:05 - themselves they're not really made for
87:07 - that
87:08 - so with that we have some colors let's
87:10 - actually implement them
87:12 - and there are two colors that we are
87:13 - going to need one is the color for the
87:16 - text
87:16 - and the other is the color for the box
87:18 - behind it and i'm going to use an rgb
87:20 - color for the text and a hexadecimal
87:22 - color for the box
87:23 - just to show you how both are going to
87:25 - look like and
87:26 - here are the two colors i am going to
87:28 - use so you can see what they look like
87:30 - so let's implement all of this so here i
87:34 - am back in the code and if i run out of
87:36 - this we can still see our pink box with
87:39 - the black text
87:40 - and let's start working on the text
87:42 - itself and to change the color of the
87:44 - text
87:45 - we have to work up here and we have to
87:49 - update the text when we create the
87:51 - surface
87:52 - and right now we are just creating a
87:54 - black text inside of a surface
87:57 - and i'm going to get rid of that and
87:59 - instead replace it with an rgb tuple
88:02 - and this one is going to have 64 for all
88:05 - three colors
88:06 - so we have 64 for red 64 for green
88:10 - and 64 for blue which gives us a fairly
88:13 - darkish gray
88:14 - so this would then be the text and
88:16 - that's really all we had to do
88:18 - now if i run this again now our text is
88:21 - looking slightly more grayed out
88:24 - it still doesn't look all too good
88:26 - because the background is pink so
88:28 - let's work on that one and for that
88:32 - i have to scroll down a little bit and
88:34 - now i want to change
88:36 - this pink here to a different kind of
88:38 - color
88:39 - and this happens with a hexadecimal
88:41 - string although you could also use an
88:43 - rgb string
88:44 - and in my case i have a string that
88:48 - looks like this
88:49 - and really important here do not forget
88:52 - the hashtag in the beginning that one is
88:56 - super important if you don't include
88:57 - that one it's not going to work
89:00 - but this is well it's a bluish color
89:03 - let me run the code and now you can see
89:06 - that this color of the text box is the
89:08 - same color as the background
89:10 - so this is i think the best kind of
89:12 - color for this
89:14 - and here again if you want to choose
89:16 - your own colors either for rgb
89:18 - or for hexadecimal there are loads of
89:20 - programs that you can be using
89:22 - for example in photoshop you can see
89:24 - both the rgb
89:25 - and the hexadecimal color but alright so
89:28 - with that we have the different colors
89:31 - next up i want to start working on the
89:33 - player and this
89:34 - is going to involve a couple of
89:36 - different steps
89:38 - number one is i want keyboard input and
89:41 - well most games are used with a keyboard
89:43 - so this one should be quite
89:44 - straightforward
89:45 - but what i essentially want to achieve
89:47 - is that if the player presses space our
89:49 - player is going to jump
89:51 - so we have to implement a jump mechanic
89:53 - but to implement that
89:55 - we are also going to need gravity so
89:57 - those two things are going together
89:58 - that you can both jump and fall at the
90:00 - same time
90:02 - but once we have that there's one more
90:04 - thing that we do need
90:06 - and that is some kind of floor because
90:08 - if we can jump and fall down
90:10 - if we don't continuously jump our player
90:12 - would eventually fall into nothingness
90:14 - so this is then the third one we have to
90:16 - implement and these are three things
90:18 - that
90:18 - are kind of independent of each other so
90:21 - i go for them step by step
90:22 - and let's start with keyboard input
90:24 - because this should be the simplest one
90:26 - by now because we have already seen
90:28 - something similar with mouse input
90:30 - and keyboard input isn't all that
90:32 - different from that
90:33 - and here again we have two different
90:35 - ways of getting input
90:36 - we could either get all of the keyboard
90:38 - inputs with a specific method
90:40 - or we could use the event loop and well
90:43 - there isn't really all that much to talk
90:45 - about let's actually go straight into
90:47 - the code and let's implement all of this
90:49 - and then we are going to look at both
90:50 - kinds of inputs
90:52 - so here i'm back in the code and it is
90:55 - already taking shape quite a bit
90:57 - but now what i want to do is to get all
90:59 - the keyboard input
91:01 - and let's start with the first one that
91:03 - we want to use the sub module called
91:05 - keys and to access that we need pygame
91:08 - dot key and in there we have a method
91:12 - called
91:12 - get underscore pressed
91:16 - this one is going to return an object
91:17 - that contains all the buttons
91:19 - and their current state so if they are
91:21 - being pressed or not
91:23 - and well let's just print the entire
91:25 - thing and see what's going to happen
91:28 - and right now you can see a ton of
91:30 - different zeros
91:32 - and each of these zeros is going to
91:33 - stand for one button
91:35 - with zero meaning the button is not
91:37 - pressed and the one meaning the button
91:38 - is
91:38 - pressed so this is very similar compared
91:41 - to the mouse
91:42 - and that information we can use to well
91:44 - access the button and see if it's
91:46 - pressed or not
91:47 - and how you would usually do that let me
91:49 - stop all of this is
91:50 - you would use this kind of like a
91:53 - dictionary
91:54 - that you would first store it in a
91:56 - variable let's say in my case i'm going
91:57 - to call it keys
91:59 - and then you can use keyword arguments
92:00 - to find specific buttons inside of this
92:03 - object
92:04 - so what we could for example do is look
92:06 - for one specific button
92:08 - and if you look online in the
92:10 - documentation you can find
92:12 - all the constants that represent
92:13 - specific keys there's quite a long list
92:15 - of different things you can do
92:17 - the one i want to look for is called
92:19 - pygame dot
92:20 - k space which stands for the space
92:24 - button
92:24 - and this one is going to return either a
92:26 - 0 or 1
92:28 - and that information we can again use an
92:30 - if statement
92:31 - so if that is the case let's say i want
92:34 - to print
92:35 - jump and now let's run this and let me
92:38 - press space
92:39 - and here again we can see jump so this
92:41 - is working pretty well
92:43 - so this would be one way to access all
92:46 - the different keys that you can have
92:48 - but again this we don't really want to
92:50 - do right now
92:51 - so let me comment it out and let's look
92:52 - at the other way because you can achieve
92:55 - the same thing
92:56 - in the event loop as well so in here and
92:59 - let's work on that actually
93:01 - and in here you have a little bit more
93:03 - control over what you do with the
93:05 - keyboard
93:06 - because in here you wouldn't just check
93:08 - for what button was being pressed
93:10 - instead you would go for a two-step
93:12 - process
93:13 - number one is you would first check if
93:15 - any button was pressed in the first
93:17 - place
93:17 - and only then would you check the
93:19 - specific button that was pressed
93:21 - and then you can do the same way with a
93:22 - button being released this is again kind
93:24 - of similar compared to what we have done
93:26 - with a mouse click
93:28 - but all right let's implement it here so
93:30 - i want to look for an
93:31 - event dot type that
93:34 - is equal to pie game dot key down
93:37 - and if that is the case for now let's
93:39 - just print key
93:41 - down and just to illustrate what we can
93:43 - also do
93:46 - we can print
93:49 - key up so this would be releasing the
93:51 - key
93:52 - and then we can print key up and now
93:55 - let me run all of this our game is still
93:58 - working
93:58 - and now let me just press a button and
94:01 - we can see
94:02 - key down on the bottom of the window and
94:05 - i keep the button pressed for now
94:07 - and this is why you can't see key up but
94:09 - now if i release the button
94:11 - now i can see key up so this way we can
94:14 - separate if the button is being pressed
94:15 - or released which can be quite useful in
94:17 - some
94:18 - instances so this would then be one way
94:21 - to check if a button was pressed in the
94:23 - first place
94:24 - what if i want to check for a specific
94:26 - key here
94:28 - well all we would have to do is look for
94:30 - the event
94:31 - key and this would compare
94:35 - with the same keyword arguments that we
94:37 - have seen down here
94:38 - so here again we could use pygame.kspace
94:44 - and if that is the case no i want to
94:46 - print
94:47 - let's call it jump again and now if i
94:51 - press
94:51 - space we can see jump and also key up
94:54 - so this one is working super well and
94:57 - well
94:58 - with that you basically have all the
95:00 - different ways that a player could enter
95:02 - information into the game
95:03 - so you have seen different ways to work
95:05 - with the mouse and also with the
95:06 - keyboard now
95:08 - and you can do this either in the event
95:10 - loop or you could do this
95:12 - inside of the game itself and now i
95:16 - guess there's
95:17 - one question that's been looming over
95:18 - input so far
95:20 - that why do you have two different
95:21 - methods in the first place why do you
95:23 - need that
95:24 - and the answer here is actually quite
95:26 - obvious that
95:27 - later on we are going to learn about
95:29 - classes that are ideally self-contained
95:32 - and this would also include input
95:34 - methods and for that it is super useful
95:37 - to have input that we can work
95:38 - separately from the event loop
95:40 - but for most of the time the event loop
95:42 - should be the good way to go
95:44 - because then we have all of our input
95:45 - nicely organized in one place so it's
95:47 - easy to work with
95:49 - but again this is something you are
95:51 - going to understand later on once you
95:52 - actually work with it so for now
95:54 - just don't worry about it too much so
95:57 - now we have all the input we need and i
96:00 - don't think there's too much we need to
96:01 - practice with this
96:02 - so let's go straight to the next part
96:05 - and that is that i want to give our
96:07 - player the ability to jump
96:08 - and also to fall so what do we need for
96:11 - that
96:12 - and well the first thing that we are
96:14 - going to need is some kind of gravity
96:16 - because well our player needs to be able
96:18 - to fall and here's a slight problem that
96:20 - we are going to have
96:22 - that in reality gravity isn't a linear
96:24 - function instead it's exponential
96:27 - which basically means that the more you
96:28 - fall the faster you fall
96:30 - and if that doesn't happen falling is
96:32 - going to look really weird it looks like
96:34 - we're in space
96:35 - so we have to create some kind of method
96:37 - that looks like our player is going to
96:39 - fall in an exponential speed
96:41 - which is kind of annoying to do so we
96:43 - are only going to imitate that we're not
96:45 - going to replicate it
96:46 - although it's something you could be
96:48 - doing but essentially all we're going to
96:50 - do
96:50 - is we're going to separate this process
96:52 - into two different parts
96:54 - where number one we're going to create a
96:55 - variable that has a gravity
96:57 - and this gravity is going to increase so
96:59 - it's just the number for now that just
97:01 - increases constantly
97:03 - and then we're going to add this number
97:05 - to move our player downwards
97:07 - and since our gravity is getting larger
97:09 - and larger it looks like our player is
97:11 - falling at a faster and faster speed
97:13 - it's not exponential but it starts to
97:15 - look quite a lot like it
97:16 - and especially since we are not falling
97:18 - that far this
97:20 - is not something that a player would
97:21 - notice and this is something you see
97:23 - really often in video games
97:25 - that game developers just don't really
97:26 - care about physics as long as it looks
97:29 - and feels good
97:30 - if it's actually physically accurate
97:32 - nobody really cares but
97:34 - alright that was again lots of talk
97:36 - let's actually implement all of this
97:38 - so here we are back in the code and the
97:40 - first thing i want to do
97:42 - is to create some kind of variable that
97:43 - tracks gravity
97:45 - and this let me put it right below the
97:46 - player so let's call this player
97:49 - gravity and by default this is going to
97:52 - be zero
97:54 - but now what's going to happen in our
97:56 - game loop
97:57 - and let me separate the player a little
97:59 - bit and let's add a comment here
98:01 - so we know we're always working with the
98:02 - player that should organize our code a
98:04 - little bit better at least
98:07 - so before we are drawing our player i
98:10 - want to increase the gravity
98:12 - by one so player gravity plus equal one
98:15 - so on every single cycle of the game
98:17 - loop we are going to increase our
98:19 - gravity by a bit
98:21 - but right now this isn't going to do
98:23 - anything because this player gravity
98:25 - and this player rectangle are well
98:27 - they're not connected
98:28 - so they don't influence each other
98:30 - whatsoever
98:31 - and well let's change that so what i
98:34 - want to do
98:35 - is this increase in gravity i want to
98:37 - use that to move the player downwards
98:39 - and this could actually be a really good
98:41 - exercise for you guys
98:42 - so i want you guys to use this player
98:44 - gravity to move the player downwards
98:46 - continuously
98:47 - so pause the video now if you want to
98:48 - code along and implement this yourself
98:57 - all we have to do is to get our player
98:59 - rectangle
99:00 - and then target one of the vertical
99:02 - attributes doesn't really matter which
99:04 - one
99:04 - in my case i'm just going to go with y
99:07 - and here all we have to do
99:09 - is to plus equal this with player
99:11 - gravity
99:13 - and now let's try this and now we can
99:16 - see our player falling downwards
99:18 - obviously this isn't going to look too
99:20 - great because our player just disappears
99:22 - immediately
99:23 - but let me explain what's happening here
99:25 - that at the beginning our player gravity
99:27 - is zero and then we add plus equals one
99:30 - to it
99:31 - so we will get one out of it and this is
99:33 - then what we would add
99:34 - to our player gravity so then our player
99:37 - gravity would be 301
99:40 - but on the next cycle of the loop let me
99:42 - use a different color for that
99:43 - we would start with one already and we
99:46 - would add
99:47 - one towards it so now we will get to two
99:51 - and now if we add this to the player
99:53 - gravity we would get
99:56 - 303 so we have an
99:58 - increase in speed in terms of how fast
100:00 - we are falling down
100:02 - and this is going to look very much like
100:04 - our player is falling in real world
100:06 - gravity
100:07 - and this to our primitive brains looks
100:09 - like the player is falling at the
100:10 - natural speed
100:11 - although it's not real gravity so with
100:15 - that
100:15 - we have to find a counter measure that
100:17 - our player has to jump
100:18 - upwards and this is also
100:22 - something we can implement quite easily
100:24 - because right now
100:26 - this player gravity is moving our player
100:29 - downwards because it's positive
100:31 - but if this number were to become
100:33 - negative our player would move
100:35 - upwards and let me actually demonstrate
100:38 - this
100:39 - so when i set this player gravity right
100:41 - now 0
100:42 - but i could set this to minus 20.
100:45 - another on the code
100:47 - we can see we have one jump
100:50 - because we initially move the player
100:51 - upwards but then we're moving it
100:53 - downwards at an increasing speed
100:56 - and this we don't want to do when we
100:58 - create a player gravity
101:00 - we only want to do when we are pressing
101:03 - a button
101:04 - so in here we want to do it and
101:07 - well this is then all we have to do so
101:09 - we have to get our player gravity
101:12 - and set this to negative 20.
101:15 - and let me get rid of key up because we
101:17 - are really not going to need it
101:19 - and now if i try this again i can see
101:23 - if i keep on pressing space we have a
101:25 - jumping player
101:27 - still not particularly realistic but we
101:30 - are definitely getting there
101:32 - so with that we have gravity and the
101:34 - ability to jump
101:35 - and actually on that note i also want to
101:38 - reactivate
101:40 - this mouse motion to click on the player
101:44 - so what i want to do in here is if the
101:46 - player is clicking on the player
101:48 - i want the player to jump as well and
101:51 - this could again be a good exercise for
101:53 - you
101:54 - that just implement some kind of system
101:56 - that if the user clicks on the player
101:58 - then the player jumps as well so pause
102:00 - the video now and try this yourself
102:07 - so to fix this kind of problem we have a
102:10 - couple of different ways to go
102:12 - for example we could check our most
102:13 - position and then check if there is a
102:15 - collision and we are pressing the mouse
102:17 - button
102:18 - or we could check if we are pressing the
102:20 - mouse button and then there is a
102:21 - collision
102:22 - and that's basically the same result in
102:24 - my case i
102:25 - first check if the mouse button was
102:26 - pressed in the first case and then i
102:28 - checked for a collision
102:30 - and the different approaches here really
102:31 - aren't going to make a big difference
102:33 - although they might make a small
102:35 - difference and keep that in mind
102:37 - that if we first check for mouse button
102:39 - press and then we check a collision
102:40 - is more efficient at checking for a
102:42 - collision and then for a mouse button
102:44 - press
102:44 - because checking for a mouse button is
102:46 - much easier than checking a collision
102:50 - and it's not going to make much of a
102:51 - difference but if you have 20 or 30 of
102:53 - these small differences
102:55 - they might actually add up to a faster
102:57 - game so just keep that in mind for
102:59 - actual games
103:00 - that you always want to have the most
103:01 - efficient way to run your game
103:03 - which can make a difference but alright
103:06 - let's actually implement all of this
103:08 - so here i'm back in the code and i first
103:10 - want to check for mouse button press
103:12 - so this is mouse button down
103:16 - so we check if any mouse button was
103:18 - being pressed
103:19 - and i'm not going to care which mouse
103:21 - button so any mouse button is fine
103:24 - and then i actually already have all the
103:26 - code we are going to need
103:28 - so if if player collide point event
103:30 - pause this still
103:31 - works because the event position we can
103:34 - always check
103:35 - and well if that's the case let me put
103:37 - it on the next line
103:38 - i just want to copy this code here and
103:41 - then
103:42 - add it in there and let me actually try
103:45 - if this is going to work this is going
103:46 - to be slightly difficult to do
103:47 - and yeah now if i click on the player we
103:50 - can indeed see
103:51 - that the player is jumping if i click on
103:53 - it although it's
103:55 - much harder to do than just pressing
103:57 - space alright
103:58 - this is indeed working so with that
104:02 - we have some kind of gravity and a
104:03 - proper jump mechanic
104:05 - and there's one more thing i do want to
104:07 - do and that is to get rid of all of this
104:09 - stuff down here
104:10 - because we are not going to use any of
104:12 - those for a while
104:13 - and i want to keep my code clean so
104:17 - all right with that we have quite a bit
104:19 - of progress
104:20 - now there's one more thing i do want to
104:22 - achieve
104:23 - that i want to create some kind of
104:24 - ground for the player
104:26 - and here you might be tempted to do
104:29 - something very inefficiently
104:31 - that you might want to check the
104:33 - collision between the ground and the
104:34 - player
104:35 - and anytime the player is colliding with
104:37 - the ground we want to move the player up
104:39 - and this would be possible but it also
104:41 - wouldn't be a good solution
104:43 - for the simple reason that is complete
104:45 - overkill that we don't really have to
104:47 - check for collision with the ground
104:48 - because we effectively only need one
104:50 - point
104:51 - and that is the point 300 on the y-axis
104:54 - and if the player is going below that we
104:56 - want to move the player on top of it
104:59 - so effectively we don't want to check a
105:00 - collision we just want to check if the
105:02 - player is on that point
105:05 - so here we are only going to simulate a
105:07 - collision there's no
105:08 - actual collision all we really are going
105:10 - to do is if the player is below 300
105:13 - we are going to put the player at
105:14 - position 300 and that way it's going to
105:17 - look like the player is standing but in
105:19 - reality it really isn't the case
105:22 - so here back in the code i want to add
105:26 - one more line before we draw the player
105:28 - and that is
105:29 - if player rect dot bottom
105:33 - so we check the bottom of the player is
105:35 - greater or equal than
105:37 - 300 so this position here
105:41 - and this is why i've chosen 300 that the
105:44 - top of the ground and the bottom of the
105:46 - player
105:47 - once those two are identical of the
105:49 - players overlapping with the ground
105:51 - if that is the case i want to get my
105:54 - player rectangle
105:55 - and the bottom of it and set this to
105:58 - 300. so every time our players exceed in
106:02 - the ground
106:02 - we are going to set the player on top of
106:04 - the ground and
106:05 - well that's all we have to do so now our
106:08 - player is going to stand
106:10 - and if i jump we are falling down and
106:12 - well
106:13 - the player is still standing on the
106:14 - ground so now it looks like there's a
106:17 - collision with the ground on the player
106:18 - but in reality there really isn't
106:21 - and again this is a common thing for
106:22 - video games that you just
106:24 - simulate something that looks realistic
106:26 - to us but well
106:28 - we're not really creating the real thing
106:30 - because that would be really difficult
106:31 - to do
106:33 - so all right with that we are almost
106:36 - done
106:36 - there's one more thing that we have to
106:38 - address and that is
106:40 - let me run the game again now if i keep
106:42 - on pressing space
106:43 - while we are in the air our player keeps
106:45 - on jumping
106:47 - so effectively we are flying
106:51 - and well this i want to get rid of
106:55 - and this we can do quite easily all we
106:57 - have to do
106:58 - is in these two lines we have to add one
107:01 - more condition
107:01 - that we are only able to jump if we are
107:04 - touching the floor
107:05 - and this again could be a small exercise
107:07 - for you so again
107:08 - if you want to code along try to figure
107:10 - this out yourself
107:11 - that how can we check if the player is
107:13 - touching the ground
107:21 - right so all we really have to do in
107:23 - here is to check if
107:25 - our player rectangle and the bottom of
107:28 - it
107:29 - is greater or equal to 300.
107:32 - effectively the same condition we have
107:34 - used down here
107:36 - and well that's literally it and don't
107:38 - forget an end between the two so it
107:39 - works
107:40 - and this we have to do for both of these
107:43 - if statements
107:44 - you could also put all of this inside of
107:46 - an if statement it really doesn't matter
107:49 - but now let me run all of this again
107:52 - and now i keep on pressing space but the
107:54 - player is only going to jump if we
107:56 - actually touching the floor
107:58 - so this is then getting much closer to
108:00 - an actual game
108:02 - and in here i can almost try to play the
108:05 - game
108:05 - where we are well having almost a game
108:09 - nothing really happens yet if our player
108:11 - touches the snail
108:12 - but that comes next so
108:15 - let's talk about that part that i want
108:17 - to end our game if our player touches
108:20 - one of the snails
108:22 - and well we already have the collision
108:24 - mechanics so this is something we can
108:26 - already implement
108:27 - and let's actually do this right now so
108:29 - here i'm back in the code
108:31 - and again somewhere in our game loop i
108:34 - want to implement a function that ends
108:36 - the game
108:37 - if our player touches the snail and
108:40 - let me add a comment first so
108:43 - we have collisions here and all i want
108:45 - to check for now
108:46 - is if our snail rectangle
108:50 - is collide wrecked
108:53 - with the player rectangle
108:58 - and this has to be an if statement of
108:59 - course and if that is the case
109:02 - for now i just want to end the game so i
109:04 - just copy those two lines
109:05 - and if this is
109:08 - working then our game should just end if
109:11 - these two collide
109:12 - so let's run all of this and we can see
109:15 - our game is ending
109:16 - once the player is touching the snail
109:19 - so this would kind of work and we would
109:22 - actually have a game at this point
109:24 - obviously not a very good game but this
109:26 - is kind of working but
109:28 - instead i want to do something slightly
109:30 - different that i have two states in my
109:32 - game
109:33 - one is the actual game we have already
109:35 - seen but then i want to have some kind
109:37 - of start screen
109:38 - so that if the player is colliding with
109:40 - an object we are
109:42 - coming to an overview screen where the
109:43 - player can see the score
109:45 - and press a button to start again so for
109:47 - that we have to figure out how can we
109:49 - have different states in our game
109:51 - and well the answer here is actually
109:54 - surprisingly simple
109:55 - that right now in our game loop we are
109:58 - drawing and checking certain things
110:00 - and all we really have to do is to put
110:02 - all of this inside of an if statement
110:04 - so for example if our game is active we
110:06 - want to draw all the stuff we have seen
110:08 - so far however once we are colliding we
110:10 - are setting this game active to false
110:12 - and then we have an else statement that
110:14 - draws something else
110:16 - that's literally all we have to do now
110:19 - obviously this is a very simple setup
110:21 - and not particularly good for really
110:22 - complex games but it is the basic logic
110:25 - you have to understand
110:26 - to basically create any kind of
110:28 - multi-level system
110:30 - so let's start by implementing that one
110:32 - so here i'm back in the code
110:34 - and right at the top because it's an
110:36 - important variable
110:37 - i want to create game active
110:42 - and this by default for now is going to
110:44 - be true
110:45 - and then further down all of the stuff
110:48 - we have drawn
110:49 - so far so literally all
110:52 - of this bit here
110:56 - we only want to do if our game is active
110:58 - and actually
110:59 - if i go further up
111:03 - this part here as well i only really
111:06 - want to do if our game is active
111:08 - although that we are going to work on
111:09 - later for now
111:11 - i just want to put all of this here into
111:15 - an if statement
111:16 - so i'm going to indent all of it and add
111:18 - an
111:19 - if statement so if our game is active
111:22 - then i want to do all of this and
111:25 - since this game active right now is true
111:28 - i can run the game
111:30 - and we have the same outcome cool so
111:32 - this is still working
111:34 - but now what i can do is if i was
111:37 - nervous colliding with the player
111:38 - i want to set my game active to false
111:42 - and now if i run this and our player is
111:44 - colliding with this nail
111:46 - well nothing is going to happen anymore
111:48 - our game stops
111:49 - for the simple reason that we don't
111:52 - update
111:53 - any of this anymore but we don't draw
111:55 - anything on top of it
111:57 - so all we can really see is the last
111:58 - frame of this game loop
112:00 - but now what we could for example do is
112:02 - add an else
112:04 - statement in here and let's say for now
112:06 - i just want to screen
112:08 - dot fill and let's add yellow
112:11 - just to see what happens so now i use
112:14 - the game
112:15 - and now we have yellow and then here we
112:17 - could literally add any kind of code we
112:19 - want
112:19 - so this could be much more extensive and
112:22 - we are going to add quite a bit on this
112:24 - later on but for now
112:25 - this would be pretty good way to
112:26 - separate our game that
112:29 - all of this code here is going to be our
112:32 - actual
112:33 - game or the game part of our game and
112:36 - all the stuff down here is going to be
112:38 - some kind of
112:39 - intro or menu screen and that way we can
112:42 - separate our game into
112:44 - logical parts that are also going to be
112:46 - easier to work with
112:48 - and well with that the one thing we have
112:52 - left to do for this part
112:54 - is to set up some kind of way to restart
112:56 - our game
112:58 - and well all really have to do for that
113:00 - is
113:01 - if our game active is false we have to
113:04 - check for some kind of player input
113:06 - and if that's the case we're going to
113:07 - restart the game
113:10 - and this is then going to bring us up
113:12 - here that right now
113:14 - we only want to check all of this if our
113:17 - game is active
113:18 - and then we want to do something else
113:20 - down here
113:21 - if the game is not active anymore and
113:24 - this could be a good challenge for you
113:26 - that if game active is false and we're
113:28 - pressing the space button
113:29 - we want to restart the game try to
113:31 - implement this yourself and see how far
113:33 - you get
113:39 - the first thing we have to do just like
113:41 - with our main code
113:43 - we want to put all of this inside of an
113:45 - if statement that if
113:46 - game active we are checking all of this
113:51 - and what we can do now is add an
113:55 - else statement in here and i just want
113:58 - to check if we are pressing the space
114:00 - button
114:01 - so let me copy this line here so right
114:04 - now we're checking if our key is down
114:06 - and we could also put these two lines
114:09 - here
114:11 - on the same line just to save some space
114:13 - and let me do that now
114:15 - so i want to check
114:18 - if the event type is key down and
114:21 - the event key is case space
114:24 - and if that is the case i want to get my
114:27 - game active
114:28 - and set this to true again
114:31 - and well let's trial of this now that's
114:34 - kind of all we needed
114:35 - so now our game stops and now i press
114:38 - space
114:38 - and okay this kind of almost worked
114:42 - that right now our game goes straight
114:45 - back
114:45 - because our snail if you can see it is
114:48 - overlapping with the player
114:50 - so now it stopped and now we can play
114:53 - again
114:53 - and i can jump over the snail this is
114:55 - actually working really well
114:57 - but now i collide it again and now we go
114:59 - to the game over state
115:01 - but a problem here is if i start the
115:02 - game again
115:04 - our player is still overlapping with the
115:06 - snail and hence the game stops after one
115:08 - frame
115:10 - so this is something we do have to work
115:12 - on but at least in theory for now
115:14 - this is working and actually what we
115:18 - could be doing
115:20 - is we can set our snail
115:23 - rectangle dot left
115:27 - to something like 800 just to make it
115:29 - work for now
115:30 - so now let's try this again so now we go
115:33 - to game over
115:34 - and now i can start again and we have a
115:37 - proper working game
115:38 - so at this point we actually have a
115:40 - really working game
115:42 - where you have a failed state where you
115:43 - have a challenge it's not a very good
115:45 - game
115:46 - but well it does work so for the rest of
115:48 - this tutorial
115:49 - it's basically all about making this
115:51 - more interesting and making our code
115:53 - better organized
115:55 - but you really have all the basics you
115:56 - need to create basic games
115:58 - so well done so far so for the next part
116:01 - let's start working on the score
116:03 - and all i really want to display here is
116:05 - the amount of time the player managed to
116:06 - stay alive
116:07 - so for this one we have to figure out
116:09 - how to measure time
116:11 - and for that we are going to need a new
116:13 - method and that one is called
116:15 - pygame.time.getticks
116:17 - and all this one is doing is it gives us
116:19 - the time since we started pygame
116:21 - in milliseconds and that is really all
116:24 - we are going to need to create our timer
116:27 - although the actual logic to implement
116:29 - all of this gets a little bit more
116:30 - complex
116:32 - but we get to that when we get to that
116:34 - so let's go into our code and let's have
116:36 - a look at this
116:37 - so here i'm in the code and right now we
116:39 - are creating our text
116:40 - right here so right now we are only
116:43 - displaying
116:44 - my game and it doesn't really do
116:45 - anything and
116:47 - further down in the game right here
116:51 - we are putting that text on the surface
116:54 - but
116:54 - obviously this doesn't really help us
116:56 - all that much so we have to make a
116:58 - couple of updates here
117:00 - and let me start by just commenting out
117:03 - all of
117:04 - this because we are going to make some
117:05 - changes and here's what we want to do
117:08 - we want to continuously update our score
117:11 - which means that in our game loop
117:13 - we have to continuously create a new
117:15 - score surface and put that on the screen
117:18 - so that every time we are creating a new
117:20 - frame we are also creating some new text
117:23 - and to keep our code a bit more
117:24 - organized i'm going to put all of this
117:26 - into its own function
117:29 - so here i'm back in the code and i want
117:31 - to create a new function and let's do it
117:32 - right at the top
117:33 - and let's call this one display
117:36 - score we are not going to need any
117:39 - arguments
117:40 - so let's go straight into the body and
117:42 - the first thing we are going to need is
117:43 - our current time
117:45 - and that we are going to achieve with
117:48 - pygame.time.getticks
117:51 - and this is going to give our time in
117:53 - milliseconds
117:54 - and let's actually for now just print it
117:57 - and see what's going to happen
117:58 - and let me actually put it into its own
118:00 - variables so you can work with it a bit
118:02 - easier let's call it current time
118:05 - so i just want to print my current time
118:08 - and now if i go down we are drawing all
118:12 - of our stuff
118:12 - in these three lines so what i want to
118:15 - do with them
118:16 - is to just comment them out for now
118:19 - and now let's run this and now we can
118:21 - see that we have a time that
118:23 - continuously updates
118:24 - at least as long as our game is active
118:26 - and that is our time
118:29 - so we can see that our game roughly
118:31 - ended two seconds
118:32 - after it started and that is information
118:34 - we can use very well
118:36 - so let me close all of this and let me
118:39 - go back to the top
118:40 - so that's the information that we want
118:42 - to use and all we really have to do
118:45 - is to put this on a new surface and put
118:46 - that surface on the display surface
118:49 - so let's create a new variable that i
118:52 - call score
118:53 - surface and for this one we are going to
118:56 - need our test
118:56 - font and render again and
119:00 - in here for now all i really want to
119:01 - display is our current time
119:04 - then i needed two hour arguments which
119:06 - is false for anti-aliasing
119:08 - and then i'm going to need the color
119:10 - which was 64 64 and 64.
119:13 - so now we have a new surface now with
119:16 - that
119:16 - we have to create a score rectangle
119:20 - and this one is just going to be our
119:22 - score surface
119:24 - with get rekt and in here the center
119:28 - is going to be
119:33 - 450 the same position we had earlier
119:37 - and now the final step we have to go
119:39 - with is screen
119:40 - dot blit and we want our score surface
119:43 - and our score
119:44 - rectangle and then i can get rid of our
119:47 - print statement
119:48 - and we should be good to go at least in
119:50 - the most basic sense
119:52 - and we are getting an error because this
119:54 - right now
119:55 - is an integer and this function here
119:58 - wants to have a string
120:00 - so we can approach this in a couple of
120:02 - ways in my case
120:04 - i'm going to put this into an f string
120:09 - so that way it's going to be converted
120:12 - to a string anyway
120:13 - and now let me run all of this and you
120:15 - can see a score
120:17 - and if i keep on running the game this
120:19 - is still working
120:20 - however here's one problem right now the
120:23 - game ended
120:24 - but now if i restart it the score has
120:26 - continued to increase
120:28 - which obviously doesn't work too well
120:31 - and
120:31 - here it's really important to understand
120:33 - what get ticks does
120:35 - and what it does is it gives us the time
120:38 - since pygame started
120:39 - or more specifically since we called
120:41 - pygame.init
120:43 - but obviously in our current setup this
120:45 - causes a problem
120:46 - because we only check the current time
120:49 - we don't really adjust this for
120:50 - restarting the game
120:52 - which is what's causing the problem here
120:54 - so
120:55 - how can we adjust for this and well the
120:58 - answer here is kind of simple
121:01 - all we really have to do is when we are
121:03 - restarting the game we are taking the
121:04 - time when the game is restarting
121:07 - and then when we are calculating our
121:08 - score we are always subtracting that
121:10 - beginning time from our actual
121:12 - score and that way we are always
121:14 - starting from zero and going from there
121:17 - so let's implement that and the first
121:20 - thing i want to do is to create a new
121:22 - variable
121:23 - that i'm going to call start time and by
121:26 - default this one is going to be 0.
121:29 - and now essentially what i want to do is
121:32 - when i'm getting this number
121:34 - i want to subtract my start time from it
121:36 - so i'm going to subtract my start
121:38 - time from it now right now
121:42 - this really isn't going to do much
121:43 - because we just subtract 0 from this
121:45 - number
121:47 - but now what i can do if i scroll down a
121:49 - bit
121:50 - in this bit here i am checking for
121:54 - keyboard input to restart the game
121:56 - and what i want to do in here once this
121:59 - is activated
122:00 - i want to set my start time to
122:03 - pygame dot time thought get ticks
122:07 - and that in the most basic sense is all
122:10 - we needed
122:10 - so let's try this now so a game still
122:13 - works properly well
122:15 - now i failed and let's try it again now
122:17 - and again we start from zero
122:19 - it's very hard to see because our
122:20 - counter starts too fast but it does work
122:23 - and let's try it again let's restart and
122:26 - this is still working pretty well
122:28 - so this is actually working really well
122:30 - cool
122:32 - and let me just go through what happens
122:33 - here
122:35 - now every time we are looking for
122:38 - our current time we are checking in this
122:41 - bit here
122:42 - our current time since the beginning of
122:44 - our game
122:45 - so since this line here has run
122:49 - however from that number we are going to
122:51 - subtract
122:52 - the start time so when the current
122:54 - iteration of our game has started
122:57 - so that way every time the player starts
122:59 - the actual game part of our game
123:01 - we are going to have a zero for our
123:02 - score and then we're adding towards that
123:05 - score
123:05 - which is then giving us a proper scoring
123:07 - system
123:09 - now there's one more problem that right
123:11 - now if i run it again
123:14 - i think the score adds up a bit too fast
123:16 - and it's very hard to read
123:18 - so i don't really want that high of a
123:20 - number i want this to look more like
123:22 - one two three and four and so on and
123:24 - that could actually be a really good
123:26 - exercise for you
123:27 - try to change our current time in such a
123:30 - way that you get more manageable numbers
123:38 - now for this exercise i think it was
123:40 - very easy to overthink the problem which
123:42 - is a common issue in programming
123:43 - so let me explain my approach
123:46 - essentially
123:47 - this pygame.gettix gives us the
123:49 - milliseconds so
123:50 - if we add second one we would have a
123:53 - number of
123:54 - 1000.
123:58 - now this number i want to get to look
124:01 - like a one
124:02 - and really all we have to do for that is
124:05 - to subtract
124:06 - this thing by one thousand and that
124:09 - literally is all we had to do in here
124:12 - so what i want to do is to subtract this
124:14 - number by
124:15 - 1000 and let's put it into
124:19 - brackets just to be a bit more clear
124:22 - and what you can also do to avoid
124:25 - floating point numbers
124:26 - is to set this to an integer so this way
124:29 - this number here would always become a
124:31 - zero or
124:31 - one or two and that is then the number
124:34 - we want to go for
124:35 - now there's one important thing you have
124:37 - to be aware of that let me copy it
124:39 - that right now when we set our start
124:41 - time this has to look the same
124:44 - actually let me demonstrate what happens
124:45 - if we don't do it so let me run the game
124:48 - now
124:48 - we get 0 1 and this is working really
124:51 - well but now i failed let's start again
124:53 - and now we get negative 5000 so this
124:57 - is well kind of weird and the reason for
125:00 - it is that this number here returns
125:02 - numbers in the thousands
125:04 - this one here returns numbers from 0 to
125:06 - 10 basically
125:08 - so that's something to keep in mind but
125:10 - alright
125:11 - so if i add this in here now our game
125:13 - should be running pretty well
125:15 - and the score is updating properly and
125:18 - if our game ends and i start again we
125:21 - start again with zero
125:23 - so this is working quite well and i
125:26 - think i have to increase the speed of
125:27 - the snails that's a bit annoying but
125:29 - okay i'm gonna work on that in a bit
125:31 - there's one more thing i would like to
125:32 - add and that i want to actually call
125:34 - this
125:35 - score just to be a bit more clear
125:38 - so now if i run this again you can see
125:40 - score at the top but
125:42 - let's well it's up to you if you want to
125:43 - add it
125:45 - now next up i think the next big issue
125:48 - is that our game over screen looks kind
125:50 - of
125:50 - empty so i want to add a couple of
125:53 - things to make it look a bit nicer
125:55 - which is going to end up looking like
125:57 - this that we have our player in the
125:59 - middle
125:59 - we have the name of the game and we have
126:01 - a short line at the end that tells the
126:03 - player how to restart the game
126:05 - none of this is particularly fancy and
126:07 - you should already be able to do
126:08 - most of this although there's one more
126:10 - important concept i would like to add in
126:12 - here
126:13 - and that is how to transform surfaces
126:16 - so for example if you want to increase
126:18 - the size or rotate the surface
126:20 - that's what transform is all about
126:23 - and well pygame has a transform method
126:27 - and if you look in the documentation
126:29 - this part of pygame has lots of
126:31 - different methods that you can use
126:33 - for example you can rotate something you
126:35 - can scale some you can flip
126:37 - something you can do lots of different
126:38 - things with surfaces
126:40 - now in my case all i really want to do
126:42 - is to scale up our player to make it
126:44 - look a little bit nicer
126:46 - but all of the transfer methods work in
126:48 - basically the same way
126:49 - so let's actually jump into this so here
126:52 - i'm back in my code
126:53 - and let me minimize our display score
126:55 - first because we're not going to need it
126:57 - anymore
126:58 - now next up i want to create our game
127:02 - over screen
127:02 - in here and all of this
127:05 - our game so far we can ignore because
127:08 - we're not going to work on it
127:10 - so i am going to minimize all of this
127:13 - and let me also minimize the event loop
127:15 - so all of this is a bit easier to see
127:18 - and first of all i don't want this to be
127:20 - yellow anymore instead
127:22 - i'm going to add a tuple that is 94
127:26 - 129 and 162
127:29 - and actually just to test all of this
127:32 - i'm going to set game active to false
127:35 - when we start our game
127:37 - so that way we go straight to the game
127:38 - over screen so
127:40 - let's run this and now you can see a
127:42 - much nicer color
127:44 - and again if i press space our game
127:46 - starts as always
127:47 - so this one is working pretty well cool
127:50 - and
127:50 - i guess with that we can add the player
127:52 - in the middle of the screen
127:54 - and for that i first want to import our
127:56 - player
127:58 - and let me do this right in the
127:59 - beginning so i already have my
128:02 - player variables and i want to create a
128:04 - new one here let's call this player
128:06 - stand
128:08 - and all we have to do in here is
128:11 - pygame.image.load
128:12 - as always and there's one file
128:15 - that is just called playerstand
128:19 - and i am going to import is like all the
128:21 - other ones and i'm going to convert
128:23 - alpha this as well
128:26 - and now on the next line i'm going to
128:28 - call this player stand
128:33 - a rectangle and this one is just going
128:36 - to be player stand
128:38 - and get rekt and then the center
128:42 - is going to be right in the middle of
128:44 - our screen so
128:45 - 400 and 200
128:48 - and let me actually add some comments um
128:51 - i think that's a bit easier to see so
128:52 - let's call this
128:53 - intro screen
128:57 - now this is then what i want to display
128:58 - in the game over screen
129:01 - so all we have to do in here is to use
129:04 - screen
129:05 - dot blit and our player stand
129:09 - and our player stand rectangle
129:13 - so now let's try this and then we can
129:15 - see our little player
129:17 - this works pretty well so far so now i
129:20 - want to scale this one up and how would
129:22 - i do that
129:23 - and to scale something in py game we
129:25 - actually have a couple of different
129:26 - methods
129:27 - so if you open the documentation we have
129:29 - scale we have rotozoom
129:31 - we have scale to x and we have smooth
129:33 - scale
129:35 - and they all essentially do the same
129:37 - thing that they are changing the scale
129:39 - but they do it in slightly different
129:41 - ways
129:43 - and the result is going to look
129:44 - different depending on what method you
129:46 - are using
129:47 - but for now let's keep things simple so
129:50 - i just want to use
129:52 - pygame.transform.scale
129:53 - the simplest one i would say and if you
129:56 - open this one
129:57 - it tells you to add at very least two
129:59 - arguments
130:00 - the surface you want to scale up and
130:02 - then a new width and a new height
130:04 - both inside of a tuple and then this one
130:06 - is going to return a new surface
130:08 - and then you can use this surface like
130:10 - any normal surface
130:12 - so let's have a look at that
130:15 - now when i import our player stand
130:18 - i want to create a new player stand
130:21 - and just for clarity let's call this
130:24 - scaled
130:27 - and really all i want to do in here is
130:29 - to get my pie game
130:30 - transform and
130:33 - scale and now i am going to need a tuple
130:37 - with my wife
130:38 - and my height and unfortunately here
130:41 - right now
130:42 - i have no idea about the dimensions of
130:44 - our player um so let's go with random
130:46 - numbers
130:47 - let's say for the weft i want to go with
130:49 - 200
130:50 - and for the height i want to go with 400
130:54 - and well now for our player stand rect
130:58 - we also have to update this but all we
131:00 - have to do is to get a new variable
131:04 - so now i am simply updating this line
131:07 - here
131:08 - to get a rectangle around this new
131:10 - scaled surface
131:11 - instead of our player stand and besides
131:15 - that
131:15 - i also have to update the player stand
131:17 - down here to have this scaled
131:19 - one in there so let's do that as well
131:23 - so we want player stand scaled and now
131:26 - this should already be working
131:27 - so let's try it and there you can see
131:30 - our player is very obviously scaled up
131:32 - really doesn't look all that good so
131:35 - let's close this one
131:37 - but this would be one approach with
131:38 - scale although not a very good one and
131:41 - not the one i would recommend to use
131:44 - however before we are learning a better
131:46 - way to scale something there's one more
131:48 - update i want to make
131:49 - because right now this here doesn't feel
131:52 - like good code
131:53 - because we are creating more variables
131:55 - than we really need to
131:56 - so let me update this slightly before we
131:58 - get into the proper bit
132:00 - and really all we have to do is to get
132:02 - rid of this scaled
132:04 - and then again we want to get rid of
132:07 - this scale as well
132:08 - and this scale at the bottom here and
132:11 - uh well that's all we have to do so let
132:14 - me go for what happens here that's kind
132:15 - of important to understand
132:17 - we are starting number one by importing
132:20 - this image
132:22 - now on the next step so this number two
132:24 - here
132:25 - we are taking the image and then
132:28 - updating it with this
132:31 - pygame.transform.scale and this one is
132:32 - returning a new surface
132:34 - and we're using that new surface to
132:36 - overwrite the initial surface
132:39 - and that's perfectly fine to do that you
132:41 - take one surface
132:42 - you scale it and then you assign it to
132:44 - the variable that you originally used
132:46 - and then we are creating the rectangle
132:48 - in step number three
132:50 - and then in step number four you are
132:52 - drawing all of this
132:54 - so i hope that makes sense and this is
132:55 - something you see fairly often
132:57 - and also what you see fairly often is
132:59 - that you could just take
133:00 - all of this and paste it
133:04 - directly into the scale method and
133:07 - if i run this this would also still work
133:10 - although the downside of that is you
133:11 - would get one
133:12 - very long line that i think would be
133:14 - quite hard to read so i'm not going to
133:16 - do that
133:17 - and i think this is a fairly good middle
133:19 - ground between readability
133:20 - and efficiency of code so i'm going to
133:22 - go with that one
133:24 - however the problem now is that this
133:25 - scaling just doesn't look very good
133:27 - because it well
133:28 - it distorts the image a lot and there
133:31 - are two methods that would be better
133:33 - here
133:33 - the first one is called scale 2x and
133:36 - this one is a really simple scale method
133:38 - all it does is it takes a surface and
133:40 - makes it twice as large
133:42 - and this one works by just calling scale
133:45 - 2x
133:45 - and this one needs only one argument and
133:47 - that's the surface you want to scale
133:52 - so now let's have a look at this and now
133:54 - we can see a much better player
133:56 - but there's one more method that i do
133:58 - want to show you
133:59 - and that is called row to zoom and
134:02 - rotozoom
134:02 - is a more complex method because it does
134:05 - three different things that you have to
134:07 - be aware of
134:08 - number one it rotates the surface number
134:10 - two it scales the surface
134:12 - and number three it filters the surface
134:15 - and the filter here is intended to make
134:17 - the resulting surface a bit smoother
134:19 - so to make it look a bit better in some
134:20 - instances
134:22 - and to call rotozoom we are going to
134:24 - need three different arguments
134:26 - we need the surface the rotation and the
134:28 - scale
134:29 - so let me update this to row to zoom
134:32 - we are still going to need our player
134:34 - stand for angle for now i'm going to go
134:36 - with zero
134:37 - and then for the scaling let's go with
134:39 - two
134:40 - and that literally is all we needed so
134:42 - let's run this
134:44 - and now we can see a surface that looks
134:46 - very similar
134:48 - although if i compare these two images
134:50 - side by side
134:52 - you can tell some very slight
134:53 - differences
134:55 - and this is because of the filtering and
134:57 - i actually think this rotozoom looks the
134:59 - best
134:59 - so i am going to stick with this one and
135:02 - actually what you can also do with
135:03 - rotozoom
135:04 - you can change the angle so if i change
135:06 - this to for example 90
135:09 - we would also get a rotated surface so
135:11 - this is a very easy way to both scale
135:13 - and rotate something and still have the
135:15 - resulting surface look quite good
135:18 - but i don't want to rotate it so this
135:21 - one is perfectly fine by itself
135:23 - so alright with that we have learned
135:25 - about the basics of influencing a
135:27 - surface
135:28 - now next up we do have to add a couple
135:30 - of lines of text
135:31 - so we do have to add the name of the
135:33 - game the score and the instructions to
135:35 - start the game
135:36 - and this could actually be a really good
135:38 - exercise for you
135:40 - that try to implement all of this
135:42 - yourself and see how far you get
135:44 - but at this point you know all the tools
135:46 - to make this work
135:53 - so here we are back in the code and i
135:56 - am going to go to our intro screen and
135:59 - in here i just want to create a new
136:00 - variable called game name
136:02 - and for this one we need our test
136:04 - font.render again
136:06 - and now we have to specify the name of
136:08 - our game and
136:09 - i just called this one pixelrunner but
136:12 - well
136:12 - give it whatever name you want then for
136:15 - ntl you're saying i want false
136:17 - and for the color i go with one one one
136:20 - one nine six and one six nine
136:24 - so with that we would have the surface
136:26 - of our text
136:28 - next up we would need our game name
136:31 - rectangle and this one is just going to
136:35 - be
136:35 - game name dot get wrecked
136:39 - and this i want to place at position 400
136:41 - and 130
136:43 - so in the middle of the screen slightly
136:45 - to the top
136:46 - and that is all we needed to get the
136:48 - name of the game so now
136:50 - in our game over loop we have to draw
136:52 - all of this
136:55 - so we just need screen dots
136:58 - blitz then game name
137:02 - and game name rectangle and now let's
137:05 - see
137:07 - and that is a little bit too far down
137:10 - so let me go up again and let's put this
137:13 - to
137:14 - let's go with 80.
137:18 - and that is looking much better all
137:20 - right so with that
137:22 - we have the name of the game in there
137:25 - everything else still works just the
137:26 - same
137:27 - cool and now i'm going to add a second
137:31 - bit of text
137:32 - and this one is going to pull double
137:34 - duty if there's no score
137:36 - it is just going to tell press space to
137:38 - run however if there is a score
137:40 - it just shows the score and to implement
137:43 - all of that
137:44 - all we really need is an if statement
137:45 - that cycles between two different text
137:47 - surfaces
137:48 - so let's start with the first text and
137:51 - this i called game
137:52 - message and this again we need to test
137:56 - font.render and test font really isn't a
137:58 - good name but i guess now we're stuck
138:00 - with it
138:00 - and this is press space to run
138:04 - then i want false again and now for the
138:07 - text color
138:08 - i just want to copy the text we had
138:10 - above
138:12 - so with that we have our surface and now
138:14 - i want my game
138:16 - message rectangle
138:20 - and this one again is going to be game
138:22 - message
138:24 - dot get wrecked
138:28 - and here once more i want to place the
138:30 - center
138:33 - and now in here i want to put it in the
138:36 - middle
138:37 - and no for the y position let's go with
138:40 - 320
138:41 - let's see if that one is going to work
138:44 - and well
138:44 - now again we have to go with screen
138:48 - dot blit i called this game message
138:52 - and game message rect
138:55 - and let's see if this one is working and
138:58 - it does
138:59 - not let's see what went wrong here oh
139:02 - and the reason is that
139:03 - i have the wrong rectangle so this
139:05 - should be game message wrecked
139:07 - there we go this is much better
139:10 - and i think i could move this text
139:12 - slightly
139:13 - further down so let's go with 340.
139:18 - now this one is again and uh okay tiny
139:21 - bit higher
139:22 - so now the last thing that we have to do
139:25 - is to add some kind of if statement that
139:27 - we only show the
139:28 - text if there's no score and if there is
139:31 - a score
139:31 - we don't want to show the game message
139:33 - instead we want to show the score
139:35 - and for that we do have to make a couple
139:37 - of changes
139:38 - so let me go through them one by one and
139:41 - i think it's best to explain it first
139:43 - and then we get into it
139:45 - so right now we are keeping all of our
139:48 - score instead of the update score
139:49 - function
139:50 - which works fine by itself but we want
139:53 - to access the score to display it in our
139:55 - game over screen
139:56 - so we have to get the current time
139:58 - variable inside of the update score
140:00 - function and
140:02 - for that we could either create a global
140:04 - variable or we could return the value
140:06 - and both would be okay i'm going to go
140:08 - with the return statement
140:10 - but once we have that all we have to do
140:12 - is to put this current time on its own
140:14 - surface
140:14 - and then display it that's literally all
140:16 - we have to do so
140:18 - let's go back in the code and let's have
140:19 - a look at this
140:21 - so here i'm back in the code and right
140:24 - now
140:24 - the variable that we have to access is
140:28 - this current time here because that
140:30 - effectively is our score
140:32 - so how can we access this we could
140:35 - either go with
140:36 - global current time
140:39 - [Music]
140:40 - to make it accessible everywhere or what
140:43 - we could also
140:44 - do is after this function is run we can
140:47 - return
140:47 - current time and this is the one i'm
140:50 - going to go with because it's a bit more
140:52 - focused
140:54 - so now that we have that i can create
140:56 - another variable let's call it score
140:59 - and this by default is going to be zero
141:01 - however now
141:03 - every time our update or display score
141:05 - is going to run
141:08 - this score is going to get the value of
141:09 - whatever is being returned by this
141:11 - display score
141:12 - which is going to be our actual score
141:15 - so this way we can access the value of
141:17 - our score basically any time
141:20 - so now what we have to do in the game
141:23 - over screen
141:24 - we have to turn this into a surface and
141:28 - well this is going to work in exactly
141:29 - the same way as before
141:31 - so i create a new variable let's call it
141:33 - score message
141:34 - and this one again i want my test
141:37 - font.render
141:38 - and in this case i want to go with an f
141:41 - string
141:42 - that says your score
141:45 - and then we put our actual score in
141:49 - there
141:51 - then again we need false and for the
141:53 - color i am just going to copy this same
141:56 - one again
141:59 - and then after that you should know this
142:01 - by now really well
142:03 - we want to turn this into a rectangle or
142:06 - we want to put a rectangle around it
142:07 - rather
142:08 - so i want score message dot get rekt
142:12 - and for the center i'm going to go with
142:14 - 400
142:17 - 400 and 330
142:21 - so now this is going to give us our
142:24 - score
142:25 - and now this score i only want to print
142:28 - when there actually is a score
142:30 - so when we are starting the game this
142:32 - isn't visible however
142:33 - as soon as we have a score all of this
142:36 - is going to replace
142:39 - this game message here and well to
142:41 - achieve all of that
142:42 - all we need is an if statement so if our
142:45 - score
142:46 - is equal to zero we know we don't have a
142:48 - score yet and then i want to display
142:51 - my game message and if that is not the
142:55 - case
142:55 - so else i want to go with screen
142:59 - dot blitz and score message
143:03 - and score message wrecked
143:06 - and well let's try so i can run the game
143:09 - we can still see our basic setup now let
143:11 - me run it
143:12 - now we get a score of 2 and there we can
143:15 - see it
143:16 - so now every time we have a score we can
143:18 - see it and this is looking really well
143:20 - then
143:20 - so i can also jump over snail or i can't
143:23 - and now we get a score of four so this
143:25 - one is indeed working
143:27 - very nice and let me just update them
143:31 - ever so slightly to put them on the same
143:34 - line because that
143:35 - feels better cool
143:39 - so all right with that we have all the
143:41 - text that we are going to need
143:43 - so with that let's work on another
143:46 - really important topic to make the game
143:47 - look better
143:48 - and that is to spawn different kinds of
143:50 - obstacles
143:51 - so right now we only ever have a snail
143:54 - and i want to mix this up a tiny bit
143:56 - that we have a chance to ever get a
143:58 - snail or a fly
144:00 - so the player has to make a choice
144:01 - between jumping or well not jumping
144:04 - and this is going to be a really good
144:06 - opportunity to work on something a bit
144:08 - more complex to spawn our enemies
144:11 - because right now this is a bit overly
144:13 - simplistic
144:14 - that we don't really spawn multiple
144:16 - enemies instead we have a snail
144:18 - we keep on moving from the right to the
144:19 - left and then we just place it back to
144:21 - the right
144:22 - and the problem here is that we have
144:24 - very little control for example we don't
144:26 - have control how fast the snail is
144:28 - moving
144:28 - and we also don't really have control
144:30 - over how often it's spawning
144:32 - so it's always the same interval which
144:34 - is kind of boring
144:35 - and to update it we are going to need
144:37 - one new concept
144:39 - and that is a timer so that we can tell
144:42 - pygame to run a certain kind of code in
144:44 - certain time intervals
144:46 - and this timer is going to be quite
144:47 - simple because all we really are going
144:49 - to do is to create a new user event
144:51 - that's triggered by pygame
144:53 - and so far all of our user events were
144:56 - something the player is doing
144:58 - but that doesn't necessarily have to be
145:00 - the case because a user event could also
145:02 - be triggered by pygame
145:04 - and a timer is one of those instances
145:07 - where we tell pygm to trigger a user
145:09 - event at certain intervals
145:10 - which is what a timer really is and
145:13 - there are three steps to doing all of
145:14 - this
145:15 - number one we have to create a custom
145:17 - user event
145:18 - number two we have to tell pygm to
145:20 - trigger this user event at a certain
145:21 - interval
145:22 - and then number three we have to add
145:24 - code in our event loop to do
145:26 - something when this event is being
145:28 - triggered but that is all we needed
145:30 - so let's actually implement this so here
145:33 - i
145:33 - am back in the code and let me add a new
145:37 - section with a comment let's call it
145:39 - timer
145:41 - and in here i want to have an obstacle
145:43 - timer
145:46 - and all we need to create a custom user
145:48 - event is pygame dot
145:50 - user event all in uppercase letters
145:54 - and here one important thing is to add
145:56 - plus one
145:58 - the reason for it is that there are some
145:59 - events that are already reserved for
146:01 - pygame itself
146:03 - and to avoid a conflict with those we
146:05 - always have to add plus one to each
146:07 - event we are going to add
146:09 - and if you want to read more on that
146:10 - there's quite a bit more in the
146:11 - documentation on this
146:13 - but by itself that's all we need here so
146:15 - this would be step number one
146:16 - that we have created a custom user event
146:19 - now what we have to do
146:20 - is to trigger this event in certain
146:23 - intervals
146:24 - and this happens with pygame.time.set
146:27 - underscore timer and this is going to
146:31 - need
146:31 - two different arguments number one the
146:34 - event we want to trigger
146:35 - and number two how often we want to
146:37 - trigger it in milliseconds
146:39 - so in my case i want to trigger my
146:40 - obstacle timer
146:42 - and i want to trigger this every 900
146:44 - milliseconds
146:46 - so a bit shy of one second but
146:49 - with that we have a timer so now in my
146:52 - event loop
146:54 - i want to go all the way to the bottom
146:58 - and here we are going to add a new event
147:01 - so here if event dot type
147:05 - is equal to obstacle timer
147:09 - and if that is the case for now let's
147:10 - just say print
147:13 - test and now let's run it
147:16 - and we can see test just about every
147:19 - second
147:19 - so this one is already working pretty
147:21 - well so with that
147:23 - we have a timer and i guess
147:26 - one thing we can add already here that
147:28 - we only want to run this
147:30 - if our game is active because if it's
147:32 - not active we don't have to spawn an
147:34 - enemy
147:35 - so now let's trace again now we can't
147:37 - see anything and if i run the game
147:39 - we can see test every just about one
147:42 - second
147:42 - cool so now we have a timer but how can
147:46 - we use that timer to work with our
147:48 - obstacles
147:49 - and well here we have to make quite a
147:51 - few changes
147:52 - so let me explain this first and then we
147:54 - are going to implement it
147:56 - but before that let me go down a tiny
147:59 - bit
148:00 - i want to get rid of this snail
148:03 - movement we had so far because this one
148:06 - is not going to be needed anymore
148:09 - so let's talk about how all of this is
148:10 - going to work
148:12 - now first of all we have to create a
148:14 - list that is going to contain
148:15 - all the rectangles of the obstacles and
148:18 - every time our timer triggers we are
148:20 - going to add a new rectangle into this
148:22 - list
148:23 - and then on every single cycle of our
148:25 - game loop
148:26 - we are going to move every single
148:28 - rectangle inside of that list
148:30 - a little bit further left and if any of
148:32 - these rectangles goes too far to the
148:34 - left we are going to delete it
148:36 - and that way we can continuously create
148:38 - new enemies and
148:40 - move them to the left and if they get
148:41 - too far to the left we just make them
148:43 - disappear
148:44 - so ultimately a fairly simple idea so
148:47 - let's implement it
148:49 - so here i'm back in the code and right
148:52 - now
148:52 - we have all of our enemies in here or
148:55 - our one enemy right now
148:56 - and let me add a section here as well
148:58 - let's call it obstacles
149:00 - just to keep the code a bit more
149:02 - organized
149:04 - and all i want to do in here is to get
149:06 - an obstacle
149:08 - wrecked list and right now
149:11 - this is just going to be an empty list
149:14 - and
149:14 - now when we go to our timer so
149:18 - down here all i want to do
149:22 - is to get this obstacle racklist and
149:24 - append
149:26 - something new and what i want to append
149:29 - is the rectangle and this we already
149:32 - have
149:33 - so this is going to be this rectangle
149:35 - here so i can just copy it
149:38 - and paste it in here although we have to
149:41 - make
149:42 - one update that right now this 600 needs
149:44 - to be higher so it just snails outside
149:46 - of the screen
149:48 - and i want to have a value between 900
149:51 - and 1100 and for that
149:55 - we are going to need a random number so
149:57 - let's import one
149:58 - so at the top i want from random
150:02 - import rand
150:05 - and this is just going to give us a
150:07 - random integer between
150:09 - two boundaries and that is exactly what
150:12 - i needed
150:13 - so now in here all i want is to get my
150:16 - rent int
150:17 - and this is supposed to be between 900
150:20 - and 1100
150:24 - so that way the snail is going to be
150:26 - spawned slightly to the right of the
150:27 - screen
150:28 - and then we are moving it further to the
150:30 - left so
150:31 - this is then going to give us our list
150:33 - but obviously right now
150:35 - nothing is going to move so to fix that
150:38 - we have to create a function that takes
150:40 - care of all of that
150:41 - and well let me put it somewhere in our
150:45 - game active loop
150:46 - and let's put it right after the player
150:49 - so let's call it here obstacle
150:54 - move mint it doesn't really matter where
150:56 - you put it
150:57 - just whatever makes the most sense to
150:58 - you and in here
151:00 - i want to create a new function that is
151:02 - called obstacle
151:04 - movement and in here i want to add one
151:08 - argument and that is the obstacle rack
151:10 - list
151:11 - so we know exactly what we are working
151:12 - with and well let's create this function
151:15 - so at the top of the code i want to
151:17 - create
151:18 - obstacle underscore movement
151:22 - and in there we need an obstacle list
151:26 - and now we have to work with this list
151:29 - however
151:30 - we first have to check if there's
151:31 - something in the list in the first place
151:34 - and that we can just do if obstacle list
151:38 - so this here is going to work because
151:40 - python if it finds an empty list
151:42 - is going to evaluate that to false so if
151:45 - our list is empty
151:46 - this if statement is not going to run
151:49 - but
151:50 - if it is going to run we want to cycle
151:52 - through all of our rectangles inside of
151:54 - that list
151:55 - so let's call it for obstacle rect
151:58 - in obstacle list
152:02 - and then we want to move with every
152:04 - single of these obstacles
152:06 - so obstacle rect let's call it dot
152:09 - x minus equal and now we have to define
152:13 - a certain kind of speed
152:14 - let's say i want to go with five
152:17 - and that way every single obstacle would
152:20 - be moved to the left by a tiny bit on
152:22 - every cycle of our game loop
152:24 - so this is exactly what we needed but
152:27 - right now
152:28 - obviously you can't see any of this so
152:31 - this is something i also want to put
152:33 - right inside of here although you could
152:35 - also place it in a separate function
152:36 - but in my case i'm going to be a little
152:38 - bit lazy
152:41 - but all i want to do here is screen dot
152:43 - blit
152:44 - and for now i just want to get my snail
152:48 - surface and then
152:51 - go with my obstacle rect
152:55 - so that way we are moving our rectangle
152:56 - and drawing the surface in the same
152:58 - position
152:59 - all in one go but right now we have a
153:01 - little bit of a problem
153:03 - that right now all the stuff inside of
153:05 - this function here
153:07 - is going to be a local variable and we
153:09 - want to make sure that we are targeting
153:11 - the global scope
153:12 - and really all we have to do to fix that
153:14 - is after we have done all of this
153:17 - we are returning a new list so the list
153:20 - we just created
153:21 - so return obstacle
153:24 - list and then
153:27 - in our game loop when we do
153:31 - all of this here i want to get
153:34 - my obstacle
153:39 - right list and overwrite it
153:43 - so let me explain what happens here
153:47 - we first run this function here
153:50 - and this is going to take our obstacle
153:52 - rack list and move every single
153:54 - rectangle inside of it
153:55 - a bit further to the left and after
153:58 - that's finished
153:59 - we are going to take this new list and
154:01 - overwrite the previous list
154:03 - and that way we can continuously update
154:05 - our list and not worry about scope in
154:08 - too much detail
154:09 - right so let's try all of this and
154:13 - we are getting an error and the reason
154:16 - for it is that python told us that
154:17 - non-type
154:18 - has no attribute append and you might
154:22 - already be able to figure out what went
154:23 - wrong here
154:25 - and let me explain basically if we run
154:28 - this
154:30 - in the beginning there's nothing inside
154:32 - of this obstacle list
154:33 - because our timer hasn't triggered yet
154:36 - and as a consequence
154:37 - this entire thing is going to return
154:40 - none
154:40 - and none doesn't have the append method
154:43 - so
154:44 - what we have to do if there's nothing
154:46 - inside of this list
154:48 - we have to else return
154:51 - an empty list that's not an empty list
154:53 - that's one
154:54 - and that way our append method should
154:56 - still work so now let's try this
155:00 - and let me run this and now we can see
155:02 - our snails
155:03 - obviously they're all way too fast right
155:06 - now or the collision doesn't work anyway
155:08 - but now you can already tell that some
155:10 - of these snails
155:11 - move slightly differently because we
155:13 - have changed the starting position
155:16 - so cool this is already working and i
155:18 - guess what we can do
155:20 - is that this 900 is probably a bit low
155:24 - let's go with a thousand four hundred
155:27 - let's try this now
155:30 - and let's see
155:34 - uh potentially still a little bit fast
155:38 - but i think this is
155:38 - kind of workable um okay let's go with
155:42 - 1500
155:44 - so with that we have a slightly more
155:46 - robust system to work with our obstacles
155:48 - but there are a couple of problems with
155:51 - this
155:52 - and let me go through them one by one
155:54 - number one the one problem we have
155:56 - already seen is that our collisions do
155:57 - not work anymore so that's one thing we
155:59 - have to work on
156:00 - number two is right now when our
156:02 - obstacle leaves the screen
156:04 - we don't delete it so we are going to
156:06 - end up with a longer and longer obstacle
156:08 - rack list
156:09 - something we really want to avoid
156:11 - because it would eventually slow down
156:12 - our game
156:14 - and number three is we only have one
156:16 - type of enemy
156:17 - so that's also something we have to work
156:19 - on so let's start with number two
156:22 - that we want to delete a rectangle if
156:24 - the rectangle goes too far to the left
156:26 - and this we can do inside of our
156:28 - function
156:29 - so inside of this function we want to
156:31 - check if any of these
156:33 - rectangles is going too far to the left
156:36 - so if this number here goes to
156:40 - let's say lower than negative
156:43 - 100 and if that's the case
156:46 - we want to kill it and all of that we
156:49 - can achieve
156:50 - fairly easily with list comprehension
156:54 - so what i want to do is to get my
156:55 - obstacle list
156:57 - and assign it a new list already and
157:00 - this list comprehension is going to
157:01 - check all of our rectangles and then
157:04 - see if they're too far to the left so
157:07 - all we have to do in here
157:08 - is to go obstacle for obstacle
157:12 - in obstacle list
157:16 - so this right now would only copy the
157:18 - existing list
157:19 - so it wouldn't do all that much however
157:22 - what we can do now
157:23 - is we only want to copy an item if
157:26 - obstacle
157:28 - dot x is greater than
157:32 - zero so
157:35 - that way we are only going to copy an
157:37 - existing item in the list
157:39 - if x is greater than zero so that way
157:42 - we are only going to copy every single
157:44 - item of the list
157:45 - if the condition is true that the x
157:48 - attribute
157:49 - is greater than zero so if the obstacle
157:51 - is on the screen
157:53 - and if that is not the case we are not
157:55 - going to copy the item
157:56 - and the item is going to disappear and
157:59 - actually let me go with
158:00 - minus 100 so we know that the obstacle
158:03 - is off the screen for sure
158:05 - so this would already be the first
158:07 - problem we had to target
158:08 - that we wanted to delete the rectangles
158:10 - if they leave the screen
158:11 - so with that let's go to the next point
158:14 - that right now
158:15 - we only have one type of obstacle which
158:18 - really isn't looking all that good so
158:20 - instead i want to have two different
158:22 - kinds of obstacle
158:24 - and if you check out the folder there
158:26 - are two different types we have a snail
158:28 - and a fly and i want to randomly spawn
158:32 - either a snail or a fly
158:34 - and this isn't very difficult to achieve
158:37 - but
158:37 - it does need a couple of steps to work
158:39 - through it so
158:40 - let me explain it while i implement it i
158:42 - think that is going to be the best way
158:44 - to approach this
158:47 - so all right let me minimize the
158:49 - function we are not going to need it for
158:51 - a bit
158:52 - and instead in my rectangles
158:55 - i want to import a new variable and
158:58 - let's call this
158:59 - fly underscore surface and this is just
159:02 - going to be
159:03 - pygame dot image dot
159:06 - load and the path towards
159:10 - this fly is going to be
159:14 - graphics.fly.fly1 again we have several
159:16 - images to get an animation
159:18 - we are going to cover that very soon but
159:21 - next up
159:21 - i need convert alpha and that is all we
159:24 - needed
159:26 - oh and actually i just realized this
159:28 - snail rectangle we don't need anymore
159:31 - so all right now we have our fly surface
159:35 - and now we have to add this to
159:39 - our obstacle rack list so right now
159:42 - we always add the fly towards this and
159:46 - here we want to randomly assign either
159:48 - the snail or the fly
159:50 - however there is going to be a problem
159:53 - that the fly cannot be on the same y
159:56 - position
159:57 - so while the snail is on position 300
159:59 - the fly
160:00 - has to be higher up because it's well
160:02 - flying
160:03 - so we can't just add a random statement
160:06 - in here
160:06 - but we can overcome this fairly easily
160:09 - because all we have to do
160:11 - is to run an if statement that randomly
160:14 - triggers either true or false
160:16 - and in my case i'm going to use rand in
160:18 - to do this
160:19 - so here we have rent in from 0 to 2 and
160:22 - this is going to give us a value that's
160:24 - either 0
160:25 - or 1 and 0 would evaluate to false and 1
160:28 - would evaluate to true
160:30 - so that way we have an if statement and
160:31 - randomly triggers true or false
160:34 - and if it is true i want to create a
160:36 - snail and if it's not true
160:38 - i want to create a fly so let me just
160:41 - copy
160:42 - this entire line here and now i want to
160:46 - get my
160:46 - fly surface and the x position for that
160:51 - is still perfectly fine
160:52 - but what i want to change is the y
160:54 - position because this one has to be high
160:57 - up
160:58 - and in my case i went with 210.
161:02 - so this way would be slightly higher up
161:04 - and now
161:05 - let's actually run this and see what's
161:07 - going to happen it's not going to work
161:08 - perfectly just yet
161:10 - oh and we're getting an error because
161:12 - this snail rect.left
161:15 - shouldn't be in there anymore now let's
161:17 - try this again
161:19 - and we are getting another error
161:21 - somewhere
161:22 - down here oh but we have the collision
161:25 - so this one
161:25 - should also go because we don't need it
161:27 - anymore and i hope now it's working
161:28 - there we go
161:30 - so now we can see a snail we can see
161:32 - another snail
161:33 - and now we can see a flying snail um i
161:36 - guess
161:36 - that also kind of works
161:40 - so the problem here now is that we
161:42 - always draw the surface of the snail
161:44 - on top of the screen and that would be a
161:47 - problem so let me go
161:48 - to the part in the code in our function
161:51 - that
161:51 - right now it doesn't really check in our
161:54 - function
161:54 - if we are drawing a fly or a snail we
161:57 - are
161:58 - always drawing our snail and this is
162:01 - something that we have to change
162:03 - so we have to figure out in this
162:05 - function if the obstacle rectangle is
162:07 - for a fly or for a snail
162:10 - and the problem here is that the
162:11 - rectangle by itself has no information
162:14 - if it belongs to a snail or to a fly
162:17 - it is literally just a rectangle of a
162:19 - size and a position
162:20 - but that information we can use
162:23 - because we know it at the bottom of the
162:25 - snail is at position 300
162:27 - and the bottom of the fly is at position
162:29 - 210
162:30 - so really all we are going to do in here
162:33 - is
162:34 - if the bottom of the rectangle is at
162:35 - position 300 we are going to draw a
162:37 - snail
162:38 - and if it is not the case we are going
162:40 - to draw a fly
162:41 - and that way we are going to draw only
162:43 - this surface that's appropriate
162:46 - so let me cut this out here for now
162:49 - and i want to get an if statement that
162:52 - if
162:52 - obstacle rect.bottom
162:56 - is equal to 300 and if that is the case
162:59 - i want to draw my snail and if that is
163:01 - not the case
163:03 - i want to draw my fly surface
163:09 - and i guess again i can put them all on
163:11 - one line that tends to make it look a
163:13 - bit cleaner
163:14 - and now let's try all of this again
163:18 - now we get a snail and now we get a fly
163:21 - cool
163:21 - so this is working pretty well
163:25 - oh yeah i don't actually have to jump it
163:26 - still works just
163:28 - fine and uh we are getting a lot of
163:32 - snails but we do get the
163:33 - odd fly eventually cool so
163:36 - let me remove a bit of the white space
163:39 - here
163:40 - and now we can close our function and
163:43 - never think about it again
163:44 - so with that we have different kinds of
163:47 - obstacles
163:48 - now the final thing i want to work on is
163:50 - a collision between the obstacles and
163:52 - the player
163:53 - and this i want to put in a whole new
163:55 - function because that i think is going
163:57 - to make the most sense
163:59 - but really all that we are going to do
164:01 - in here
164:02 - is we are going to check the player and
164:04 - the obstacle rack list
164:06 - and if the player is colliding with any
164:08 - of the rectangles inside of that
164:09 - obstacle rack list
164:11 - then we want to end our game and that is
164:13 - going to work in a very similar way
164:14 - compared to the obstacle movement
164:16 - function
164:17 - that we are just going to use a for loop
164:19 - to get every single rectangle inside of
164:21 - the list
164:21 - and then on every single rectangle we
164:23 - are going to call collide rect
164:25 - so let me start by creating a new
164:27 - function
164:28 - so let's call this collisions i guess
164:32 - that kind of works
164:33 - and in here i want to have two arguments
164:36 - first one is the player
164:37 - and then i want to have the obstacles
164:41 - and in here again i first want to check
164:43 - if there are obstacles in the first
164:44 - place
164:45 - so if obstacles very similar compared to
164:49 - what we have done earlier
164:52 - so let me actually open both functions
164:53 - so right now this one here
164:55 - is pretty much the same thing we have
164:57 - done up here
164:58 - now next up i want to cycle through
165:00 - every single rectangle inside of this
165:03 - list
165:03 - so for obstacle underscore act
165:06 - in obstacles and now
165:10 - i want to check if any of these
165:11 - obstacles is colliding with the player
165:13 - so if player dot
165:17 - collide rect
165:20 - with the obstacle rectangle
165:24 - and if that is the case i want to do a
165:27 - certain thing
165:28 - and now we have to figure out what
165:29 - certain thing i want to do
165:32 - and here let me explain the problem that
165:34 - right now
165:35 - we have all of our code inside of this
165:38 - function in the local scope
165:40 - so all of this here is the local scope
165:42 - but the problem with that is
165:45 - that we let me go down a tiny bit
165:49 - that here again we have our global scope
165:52 - and
165:53 - the problem is that this game active
165:56 - controls if our game is active or false
165:58 - and this game active is in the global
166:01 - scope
166:02 - so we have to work out how to get from a
166:04 - local scope to the global scope
166:06 - and well here again i'm just going to
166:09 - use a return statement
166:10 - so i'm just going to return false
166:14 - so as soon as our player collides with
166:16 - any of the rectangles
166:18 - this value is going to return false and
166:21 - all of this here runs without doing
166:23 - anything then we want to return
166:25 - true and now all we have to do is to
166:28 - either assign this return false
166:30 - or return true to gameactive.false
166:34 - to gameactive in our game loop so all i
166:37 - have to do is to go down to
166:39 - my game loop and in here we still have
166:42 - our collisions
166:43 - let me put it below there and there i
166:46 - want
166:47 - game active and this is going to get
166:50 - collisions collisions
166:53 - this one and here the two arguments we
166:56 - are going to need
166:57 - is our player rectangle
167:02 - and we are going to need our obstacle
167:05 - rect list and that should be all we
167:08 - needed
167:09 - so now let's run this and let's see
167:13 - if this is working and yeah there we go
167:16 - so now our game is going to end if we
167:18 - collide with any of the obstacles
167:20 - and just to explain what happens here
167:23 - that
167:23 - this collisions can either return true
167:26 - or false
167:27 - if there's a collision with an obstacle
167:29 - it is going to return false
167:30 - so this game active here is going to
167:33 - become false
167:34 - and we are going to the else statement
167:36 - because this
167:37 - game active all the way to the top is
167:39 - not true anymore
167:41 - however if that is not the case and no
167:43 - collision triggers
167:44 - this collision here is going to return
167:46 - true so this game active stays true
167:48 - and we just keep on going back to game
167:50 - active
167:52 - so that way we have a proper collision
167:54 - mechanic
167:55 - however now we have one more problem
167:58 - and let me run the game again
168:01 - and let me just collide with one of the
168:03 - snails and never run the game again
168:07 - we still have to snail in the same place
168:09 - so this is crashing our game immediately
168:13 - to account for that when our game is
168:15 - over
168:16 - i want to empty our obstacle reckless
168:19 - and well all we need is to get our
168:21 - obstacle rack list
168:22 - and clear it so that way we are going to
168:25 - so that way we are removing every single
168:27 - item inside of it
168:29 - and now let's try this again and now
168:32 - we crashed and now let's rerun the game
168:35 - and now
168:36 - the game restarts properly so this is
168:38 - working quite well
168:40 - cool and actually while we are in here
168:43 - there are two more things i would like
168:45 - to add number one
168:47 - is i want to put my player rectangle at
168:49 - the bottom again
168:51 - so dot mid bottom is going to be 80
168:55 - and 300 the same positions we have
168:57 - specified earlier
168:59 - so that way the player is always going
169:00 - to start at the bottom of the screen so
169:02 - for example if we jumped into a fly at
169:04 - the end of the game and crashed because
169:05 - of that
169:06 - our player would restart at the bottom
169:08 - so that i think makes it look a bit
169:09 - better
169:10 - and along with that my player gravity
169:13 - should also be zero
169:14 - so that way we start at the bottom and
169:16 - don't fall any further it just makes the
169:18 - game a little bit cleaner
169:20 - so alright with that we have made pretty
169:22 - good progress
169:23 - that now our game has multiple types of
169:25 - obstacles and
169:26 - everything else is still working just
169:28 - the same cool
169:30 - now with that we can start addressing
169:32 - something slightly more complex
169:33 - and that is to animate the fly the
169:35 - player and the snail
169:37 - so that we don't have a static image
169:39 - instead we have an animated image that
169:41 - looks significantly better
169:43 - however to achieve that we are going to
169:45 - need a couple of different things
169:48 - but in the most basic sense we don't
169:51 - really do
169:51 - anything complicated so let me explain
169:53 - what we are going to do
169:56 - in the most basic sense all we are going
169:58 - to do is to update the surface we are
170:00 - putting on the screen
170:01 - every few milliseconds so for example
170:03 - for the snail
170:04 - sometimes we are drawing one image and
170:06 - sometimes we are drawing an other image
170:08 - and these images are very very similar
170:10 - but slightly different
170:12 - and if you put them together fast enough
170:14 - it looks like the snail is actually
170:16 - slivering walking moving well moving in
170:20 - an animated way
170:21 - whatever you want to call it and all we
170:23 - really have to figure out is how to
170:25 - update the surface every few
170:26 - milliseconds
170:28 - and this can be done in a couple of
170:30 - different ways
170:31 - as a matter of fact our player animation
170:33 - and our obstacle animation works in
170:35 - different ways
170:37 - for our player animation we're going to
170:39 - create a random timer
170:40 - that updates on every single cycle of
170:42 - the game loop
170:43 - and if that number becomes too large we
170:46 - are going to change the image we are
170:47 - going to placing on the screen
170:49 - and for our obstacles we are going to
170:51 - create a new timer
170:54 - so that we are changing every few
170:55 - milliseconds what kind of surface we are
170:57 - going to put on the rectangles
170:59 - and that again was me talking way too
171:01 - much let's actually look at this in code
171:04 - and let's start with the player i think
171:05 - that's going to be the easier one
171:10 - so here we are back in the code and the
171:12 - first thing i have to do is to import a
171:13 - couple more images because that's what
171:15 - we need for animation
171:16 - so if i scroll down a bit in this
171:20 - part here we have imported the player
171:23 - image so far which is player walk
171:25 - one and what i want to do for now is to
171:29 - import
171:29 - more and put all of this into a list so
171:32 - let me rename a couple of things first
171:34 - of all this isn't supposed to be player
171:36 - surf anymore
171:37 - this is supposed to be player walk 1 or
171:40 - underscore 1. then i want to copy the
171:42 - entire thing
171:43 - and have player walk 2 and this is going
171:46 - to be the other image
171:47 - so our play has walk 1 and walk 2 and if
171:50 - you play those two fast after each other
171:52 - you have a walking animation
171:54 - and those two surfaces i want to place
171:57 - into a list that i call player walk
172:00 - and this is literally just a list with
172:02 - player walk 1
172:04 - and player walk and then besides that
172:08 - i also want to import a file that
172:12 - i called player jump
172:15 - and this is just going to be another
172:17 - surface
172:18 - so let me copy the entire import line
172:21 - this is just going to be jump.png
172:25 - and with that we have a surface
172:28 - that we want to display when our player
172:29 - is jumping and when our player is
172:31 - walking
172:32 - i want to alternate between these two
172:34 - different surfaces
172:35 - but there's one more variable that we
172:37 - are going to need
172:39 - and let me place it right under the
172:41 - player walk list
172:42 - and i've called this one player index
172:45 - and by default this is going to be zero
172:49 - and what this number is going to be is
172:51 - later on we're going to use it to pick
172:53 - either
172:54 - this surface here or this surface here
172:57 - and i have just realized that this
173:00 - should be
173:00 - player walk one and player work two so
173:03 - basically this player index is what we
173:04 - are going to change to pick either the
173:06 - first work surface or the second work
173:08 - surface
173:09 - and we don't need that for player jump
173:11 - because we only have one surface for the
173:12 - jumping
173:14 - and we can actually
173:17 - start using our player index right away
173:19 - because right now
173:21 - we need a player surface to get the
173:23 - player rectangle
173:25 - and this i just want to get back with
173:27 - player serve
173:28 - and when we start the game i just want
173:31 - to go with player
173:32 - walk and from that i want my player
173:36 - in this one
173:39 - so all this one right now is going to do
173:41 - because it is zero
173:43 - it is going to pick the first player
173:46 - walk
173:46 - surface so right now
173:50 - we haven't really accomplished anything
173:52 - we just imported a couple more images
173:53 - that don't really do too much
173:55 - right now so to actually make all of
173:58 - this work we have to create a function
174:00 - and let me go all the way to the top and
174:02 - create a new function here
174:05 - and i have called this one player
174:06 - underscore animation
174:08 - spelled correctly really helps
174:12 - and in here we want to do a couple of
174:14 - things
174:15 - we want to play walking
174:18 - animation if the player is on
174:21 - floor or we want to display
174:25 - the jump surface when
174:28 - player is not on floor so
174:32 - yeah i hope that makes sense and this
174:35 - player animation
174:36 - i want to call in our main game loop
174:39 - so all the way down here
174:43 - let's say we can place it right before
174:46 - we bled the player's surface
174:47 - that kind of makes sense i think so now
174:50 - we have to create this function properly
174:55 - and the first thing we have to do is to
174:57 - declare a couple of global variables
174:59 - because we want to work
175:00 - very much outside of this function and
175:02 - the two variables that we
175:04 - need is player surface and player
175:08 - index
175:12 - so we want to work with
175:16 - this player index here and this player
175:18 - surface
175:19 - those are the only two that we really
175:20 - have to influence from inside of the
175:22 - function
175:25 - okay so with that
175:28 - we first have to figure out if the
175:30 - player is on the floor or not
175:32 - so that we can either display a jumping
175:34 - animation or walking animation
175:36 - and well this is literally just an
175:38 - if-else statement so
175:39 - if player rectangle dot
175:42 - bottom is let's say smaller than 300
175:47 - then i want to show the jump animation
175:50 - and
175:51 - if that is not the case i want to show
175:53 - the walk animation
175:55 - and in here the jump animation isn't
175:57 - actually animation it's just the surface
175:58 - that we are displaying
176:00 - so all we have to do here is to set our
176:03 - player surface
176:04 - to our player jump i start to have a ton
176:07 - of variables
176:10 - but this is literally all we have to do
176:11 - to get the jump animation
176:13 - so if our player is not touching the
176:15 - floor or is above this y position
176:17 - we are just displaying the jump image so
176:19 - that's literally it
176:21 - but now for the walking animation this
176:23 - gets a little bit more complicated
176:25 - because in here we want to alternate
176:27 - between work surface 1
176:29 - and work surface 2 at a fairly slow
176:31 - speed
176:32 - and this i want to do with the player
176:34 - index so the variable we cleared earlier
176:36 - so i want to first target that one so
176:39 - player index
176:40 - and i just for now just want to add not
176:43 - one but
176:45 - 0.1 so i want to slowly increase this
176:48 - number and let me explain what i'm
176:50 - actually going to do
176:51 - so let's say here we have our list with
176:54 - our two work surfaces
176:56 - so we have w1 and w2
176:59 - short for walk one and walk two and by
177:01 - default
177:02 - walk index is going to be zero and let
177:04 - me use a different color for this
177:05 - actually
177:06 - so by default this walk index is going
177:09 - to be
177:10 - right here because it's zero
177:13 - and then i don't want to jump straight
177:16 - to the next frame to walk two because
177:17 - that's going to be too fast
177:19 - instead i want to increase walk index
177:21 - only by smaller
177:22 - increments so it takes a couple of
177:24 - frames
177:25 - to get to work to which will be our
177:28 - index one
177:29 - this is why i'm only adding 0.1 but if i
177:32 - were to add 1 here we would straight
177:34 - jump
177:35 - to the next walk cycle but that would be
177:37 - too fast
177:38 - instead i just want to go much slower so
177:41 - i hope that makes sense
177:43 - so with that what i want to do now is to
177:45 - get my player surface again
177:47 - and just look at my player walk list
177:51 - and from there i want to take the index
177:53 - of the integer
177:55 - of player in dex
177:58 - for the simple reason that we can only
178:00 - take the index with an integer
178:02 - and this would already kind of work with
178:04 - the simple problem that we would very
178:06 - fast
178:06 - run out of this list so this number here
178:09 - would go to one
178:10 - and then would go to two then we go to
178:12 - three and
178:13 - so on but our list so this player walk
178:16 - only has two elements zero and one so
178:20 - what we want to do is after we reach one
178:22 - we want to go back
178:24 - to zero so we have to add a bit more
178:28 - code to make sure
178:29 - that we get this border here that we
178:32 - don't cross
178:33 - and this is fortunately very easy to
178:35 - achieve
178:36 - all we need is an if statement between
178:38 - these two
178:39 - that if our player index
178:42 - is greater or equal than the
178:46 - length of our player walk
178:50 - and if that is the case i want to set my
178:52 - player index
178:53 - back to zero and that is literally
178:57 - all the logic we needed for this thing
178:59 - to work
179:01 - and we are already calling the function
179:03 - so let's actually trial of this
179:05 - so it still works and now we have a
179:07 - walking animation
179:08 - and now if i jump we have a jumping
179:10 - animation so this is working really well
179:14 - let me just go through this really
179:15 - quickly again i think this
179:17 - needs a bit of explanation so when we
179:20 - are starting our game
179:22 - we are simply picking the first item
179:26 - here from our player walk animation so
179:29 - we just get one of the walking animation
179:34 - however now in our game loop further
179:37 - down here
179:38 - before we blit the player we are running
179:41 - our player animation
179:44 - and if i look at this this player
179:47 - animation looks at a couple of different
179:48 - things
179:49 - first of all it looks if the player is
179:51 - on the ground or not
179:53 - so here the first line or the first if
179:56 - statement
179:57 - if the player is not on the ground or
179:59 - smaller than position 300
180:01 - we want to change the player's surface
180:03 - so the player image to play a jump
180:05 - and this way we give the illusion that
180:07 - the player is jumping because we changed
180:08 - the image
180:09 - but that's literally all that's
180:10 - happening here however if that is not
180:13 - the case
180:14 - so if the player is on the floor we want
180:17 - to show either walk one
180:19 - or walk two and to get these two
180:21 - surfaces we use player index and
180:23 - increase this number very slowly
180:25 - and if this number gets too large so
180:27 - with this if statement here
180:28 - we are setting it back to zero
180:32 - and then we use that to animate the
180:33 - player although animate here literally
180:35 - just means we have a pick walk 1
180:37 - or walk 2. that's really all that's
180:39 - happening here but alright
180:41 - with that we have our player animation
180:43 - cool
180:44 - now next up i want to animate all of the
180:47 - snails and all of the flies
180:49 - and for this we have a minor problem
180:51 - that for the player
180:52 - we only had to worry about a single
180:54 - surface but we have lots of flies and
180:56 - snails on the screen
180:58 - so animating all of those with this
180:59 - method would be a little bit annoying
181:01 - however we can approach this slightly
181:04 - differently
181:05 - and what we're actually going to do is
181:07 - use a timer both for the snails and for
181:09 - the flies
181:10 - and essentially all we're going to do is
181:12 - we're going to create a timer that runs
181:14 - pretty fast
181:15 - so it's going to trigger multiple times
181:17 - per second and every time it triggers
181:19 - we're going to change
181:20 - all of the surfaces for either the flies
181:22 - or the snails
181:24 - each of those have their own separate
181:25 - timer and well that's all we need
181:28 - let's actually have a look at this so
181:30 - here i'm back in the code
181:31 - and let me first import a couple more
181:33 - images
181:34 - so for the snail we have snail
181:37 - serve let's call this snail frame
181:41 - 1 and i want snail frame 2 as well
181:45 - and this is literally just going to be
181:46 - snail 1 and snail 2.
181:48 - and then for the fly we have the same
181:50 - thing we have frame 1
181:53 - and then we have frame 2
181:56 - and it probably is going to make sense
181:58 - to separate them
181:59 - a bit more consistently so this is going
182:02 - to be snail
182:03 - and this is going to be fly and in here
182:07 - we have to do the same thing we did for
182:09 - the player so we want a list with
182:11 - all the different frames so this would
182:13 - be snail frame
182:14 - one and snail frame
182:18 - two and then
182:21 - the same for the fly so fly
182:24 - frames is going to be a list with fly
182:28 - frame 1 and fly frame
182:32 - 2 and then both are also going to be
182:35 - needing an index so let's call it snail
182:38 - frame
182:39 - index and by default this one is also
182:42 - going to be 0.
182:43 - so fly frame
182:46 - index going to be zero as well and then
182:49 - finally
182:50 - we are going to need a default snail so
182:53 - i call this one snail surface and all we
182:56 - need here
182:56 - is our snail frames
183:00 - and then snail frame
183:03 - index and then the same for the fly
183:06 - so fly surface
183:09 - and this is going to be our fly frames
183:14 - and fly frame
183:17 - index so this is pretty much the same
183:21 - thing we did for the player you can
183:22 - actually see it right below
183:24 - and we could update each of these flies
183:27 - and snails in the same way we updated
183:29 - the player
183:29 - although this would be kind of annoying
183:31 - because we would have to do it for every
183:32 - single fly or snail on the screen
183:34 - so that's not great
183:38 - so instead i'm going to create a couple
183:40 - more timers so
183:41 - here we have our timers and i want to
183:44 - create a couple more
183:46 - so the first one is the snail animation
183:49 - timer and i'm really bad at spelling
183:52 - animation i realized
183:54 - and this is going to be pygame dot user
183:57 - event
183:58 - plus two and then we need
184:02 - pygm.time.settimer
184:04 - and here we have our snail animation
184:06 - timer
184:07 - and for the snail i went with let's say
184:09 - 500
184:10 - and now we need this same thing for the
184:13 - flies
184:14 - so let me just copy all of this and this
184:16 - is going to be our fly animation timer
184:19 - it's going to be plus and this one have
184:22 - set to 200
184:23 - because i think the fly should animate a
184:24 - bit faster than the snail
184:28 - and now if i go down a bit i just want
184:30 - to add
184:31 - a couple more if statements
184:34 - for um updating these timers and first
184:37 - of all
184:38 - i want to check if our game is active
184:39 - because i only want to do this
184:41 - if the game is actually running as a
184:44 - matter of fact
184:45 - let's make some changes here so
184:48 - i realized when we call our obstacle
184:50 - timer we already check if game is active
184:53 - so i just want to take this out here
184:57 - and
185:00 - check all the timers only if our game is
185:03 - active so if
185:04 - game is active then i want to run the
185:07 - obstacle timer
185:08 - and i also want to check if
185:12 - event.type
185:16 - is equal to let's start with the snail
185:19 - animation timer
185:20 - snail animation time this one and all i
185:23 - have to do in here
185:24 - is to change our snail frame index
185:26 - either to zero or to one
185:28 - depending on what we need for the
185:30 - animation so if our snare frame index is
185:32 - zero
185:32 - i want it to be one and if it's one i
185:34 - want it to be zero
185:36 - and this is literally a very simple if
185:38 - statement so if our snail
185:40 - frame index is equal to zero
185:44 - then i want my snail frame index to be
185:46 - one
185:47 - and if that is not the case then i want
185:50 - my snail frame index
185:53 - to be zero and
185:56 - once i have all of this information i
185:58 - want to get my snail surface again
186:00 - and i want my snail frames
186:04 - and pass in there my snail frame index
186:08 - so this way every time this timer is
186:10 - running we are updating
186:12 - all of the surfaces for the snail so
186:14 - once this timer is running
186:16 - we are going to update all of the snail
186:17 - frames and well that's all we have to do
186:21 - and now we have to do the very same
186:22 - thing for the fly
186:24 - and i haven't done an exercise in quite
186:26 - a while so let's do one now
186:28 - that i want you guys to create a timer
186:29 - for the fly
186:31 - and this is going to work in exactly the
186:33 - same way as we did for the snail
186:35 - so if you want to go long pause the
186:36 - video now and try this yourself
186:44 - alrighty so let's copy
186:47 - all of our snail timer and
186:50 - really all i have to do is to change
186:52 - snail to
186:54 - fly so we have this
186:57 - fly we have this flight this is going to
187:00 - be a
187:00 - fly frame index
187:04 - this is also going to be fly from index
187:06 - then this is a
187:07 - fly and two more to
187:11 - go we have fly here and we have
187:14 - fly here and
187:18 - already so this is done all we needed
187:20 - for the fly animation timer
187:25 - and now once we have that let's try to
187:27 - run the code
187:29 - and it's still running that's a good
187:30 - sign and now you can see
187:33 - animations for the snails and i hope i
187:35 - get a fly soon
187:36 - there we go the flies are not
187:40 - animating so let's have a look at those
187:43 - and
187:43 - i have found the error if we go up right
187:46 - now
187:47 - we call for both timers the snail
187:50 - animation timer
187:51 - so whenever we actually call the fly
187:52 - animation timer i just made a typo
187:55 - but that's very easy to fix fortunately
187:57 - because this needs to be
187:59 - fly animation timer and now let's start
188:02 - off this again
188:04 - and let's hope i get a fly fairly soon
188:07 - and there we go
188:08 - now we have flies that also animate
188:11 - and this is making the entire game look
188:14 - much more realistic and much more well
188:16 - animated
188:17 - cool so with that we have our animation
188:21 - and this is another major step towards
188:23 - the good looking game
188:25 - so with that we basically have a working
188:28 - game
188:29 - but there are two more things we really
188:30 - want to add to this
188:32 - number one is music and adding music in
188:34 - pie game is super simple
188:36 - the only reason i haven't done this is
188:37 - because i don't want to have music in
188:39 - the background every time i run the game
188:42 - but you could add the entire music in a
188:43 - couple of lines of code that's not the
188:45 - problem
188:46 - however there's one more topic i really
188:48 - want to cover that's fundamental to
188:50 - pygame
188:51 - but unfortunately this is going to be
188:54 - quite a large topic so this is going to
188:55 - be a larger section that is going to
188:57 - change our code quite substantially
188:59 - and that is going to be the sprite class
189:02 - and the sprite class you see all the
189:04 - time
189:05 - in our code so far we haven't really
189:08 - used any kind of class
189:09 - but it might be really useful for
189:11 - example for our player
189:13 - we have lots of different code snippets
189:15 - throughout our code to make our player
189:17 - work
189:17 - but if we wanted to make changes to the
189:19 - player it would be kind of annoying to
189:21 - do
189:22 - because we constantly have to look
189:23 - around our code to find different things
189:25 - we want to work on
189:27 - and our code is still very simple so if
189:30 - you get a more complex game this sort of
189:32 - setup would be a nightmare to maintain
189:34 - and it would be a much better idea to
189:36 - have all of our player in one player
189:38 - class
189:39 - so this would contain all the surfaces
189:41 - the rectangle the player input all the
189:43 - animations all of that stuff
189:44 - basically anything for the player is in
189:46 - one class
189:47 - and pygame is fully aware of that and
189:49 - that's why the sprite class exists
189:52 - because all it really is is a class that
189:54 - has a surface and a rectangle
189:56 - and these are being drawn automatically
189:58 - in the right spot
189:59 - and this makes it very easy to work with
190:01 - all of this
190:02 - and in our code more specifically i want
190:05 - to change a couple of things
190:06 - into its own separate class most
190:08 - importantly our player is going to be
190:10 - its own class
190:11 - however i also want each fly and each
190:13 - snail to be its own sprite as well
190:16 - and this would be the most common way to
190:18 - organize this sort of game
190:20 - and well that is what we are going to
190:23 - implementing before we work on the music
190:25 - and this is going to be a larger section
190:28 - so well let's go through it slowly and i
190:30 - explain why i implement it that's
190:32 - probably going to be the best so all
190:35 - right
190:35 - here we are back in the code and let me
190:37 - give some space right at the top
190:39 - and i want to create a class and let's
190:41 - call it player
190:44 - and this player has to inherit from
190:45 - another class that's called
190:48 - pygame.sprite.sprite
190:50 - and make sure you get the capitalization
190:52 - right so this second sprite here has to
190:54 - be uppercase
190:56 - and next up we have to create an init
190:59 - method
190:59 - so whenever this class is created we
191:01 - want to do something
191:02 - and this needs the usual self and in
191:05 - here
191:06 - the first line that's very easy to
191:07 - forget we need super
191:09 - and then the dunder ended as well so
191:12 - that we are initializing the sprite
191:13 - class
191:14 - right inside of this class as well so we
191:16 - can access it
191:19 - and this class is now going to need two
191:21 - attributes at the very minimum
191:24 - one is called self.image and the other
191:26 - is self.rect
191:27 - and the image is the surface that is
191:29 - going to be displayed by default
191:31 - and direct as well the rectangle to
191:33 - figure out where it's going to go
191:35 - so we need self.image and self.rect
191:40 - so in here what you could be doing for
191:43 - example
191:44 - is use pygame.image.load
191:47 - and load for example our player walk 1
191:50 - and we still need to convert the alpha
191:53 - of it
191:54 - and then for the self.rectangle we could
191:56 - get our self.image
191:59 - and then get wrecked again
192:02 - and in here let me for now just place
192:04 - the mid bottom
192:06 - at position let's go with 200 and 300.
192:10 - for now i just want to place it
192:11 - somewhere so i can show you what's going
192:13 - to happen
192:14 - so now we have an image and we have a
192:16 - rectangle
192:18 - so what we could do now let me scroll
192:20 - down a tiny bit
192:22 - and let me create our player is equal to
192:25 - layer so that way we're creating an
192:28 - instance of this class
192:31 - however if we're going to run the code
192:33 - now oh and i'm getting an error
192:36 - this needs to be called so now it's
192:38 - right again
192:39 - and now if we run the code we can't see
192:42 - anything
192:43 - but the game well still works perfectly
192:45 - fine so nothing is going wrong
192:48 - so why can't we see this class here
192:51 - and the reason why we can't see it is
192:53 - that pygame doesn't draw sprites
192:55 - automatically for the simple reason that
192:57 - a sprite is basically just a surface and
192:59 - a rectangle combined
193:01 - but we also can't use screen.blit
193:04 - because that isn't going to work with a
193:05 - sprite
193:06 - instead we have to do it differently
193:09 - instead what we have to do
193:11 - is take all of our sprites and place
193:13 - them inside of a group
193:14 - and then this group can do two different
193:16 - things they can one
193:18 - draw all of the sprites inside of it and
193:20 - it can also update all of these sprites
193:22 - which is going to be really useful for
193:24 - us later on
193:26 - and pygame has two different kinds of
193:27 - groups number one is a regular group
193:30 - and this one can contain multiple kinds
193:32 - of sprites and this would be perfect for
193:34 - our flies in our snails because they can
193:36 - all be in one big group and they are not
193:38 - going to interact with each other
193:40 - however for the player it's not really
193:42 - going to work because the player is
193:44 - supposed to be in its own group and
193:45 - self-contained
193:47 - and for that pie game has a different
193:48 - kind of group and that's called group
193:50 - single which
193:51 - is a group for a single sprite it's kind
193:54 - of weird but well it is what it is
193:56 - so our player is going to be in single
193:58 - group and all the other sprites will go
194:00 - in the normal group
194:01 - and the major reason why i put them into
194:03 - different groups
194:04 - is when we are checking for the
194:05 - collision we need to have them in
194:07 - different groups that's really important
194:09 - but that's going to come later for now
194:12 - let me first get rid of this player here
194:15 - and instead i want to for my player
194:18 - create
194:20 - pygame.sprite dot group
194:23 - single and into this group
194:26 - so player i want to add
194:30 - an instance of my player and this way
194:34 - we are going to have a group that is
194:36 - going to contain a sprite
194:37 - and this sprite is going to contain all
194:39 - of this stuff here
194:41 - and that way we are able to access it so
194:43 - now if we run the code
194:45 - we still can't see the player however
194:48 - now
194:49 - if i go to my code all the way down in
194:51 - our game loop
194:52 - our game is getting quite long here we
194:56 - have the player
194:57 - now i want to get my player
195:02 - and on this i can call the draw method
195:05 - and in here i have to specify one
195:07 - argument and that's the surface i want
195:08 - to draw on so in this case screen
195:11 - so now now we can see our actual player
195:17 - and well this is going to be there
195:18 - forever it doesn't do anything right now
195:20 - but well it's going to do very soon so
195:23 - this way once you have a bit of setup
195:28 - you can add all of your code for the
195:29 - player in
195:31 - here and then just add this
195:34 - to a group and then call the group later
195:36 - in the code
195:37 - down here and this is going to clean up
195:40 - our code considerably
195:42 - however we will have to recreate the
195:44 - entire player inside of this class
195:46 - so this is going to be a slightly longer
195:49 - thing
195:50 - so let me go through step by step
195:53 - and the first thing i want to do is to
195:55 - get my player input
195:57 - so player underscore input needs itself
196:00 - as before
196:01 - and in here we have to get our player
196:03 - input
196:04 - and here it's really useful what we
196:06 - learned like
196:07 - two hours ago that we can get all of the
196:10 - keys being pressed
196:11 - by pygame so pygame dot key dot
196:15 - get underscore pressed and this is then
196:18 - going to give us all the possible key
196:20 - inputs
196:21 - and we can just go through them so if
196:24 - keys
196:25 - pi game dot k underscore
196:29 - space and self.rect.bottom
196:35 - is greater or equal than 300.
196:38 - then we want to jump so self.gravity
196:43 - is going to be minus minus 20.
196:47 - so this is pretty much the same thing
196:49 - that we have seen
196:50 - a bit further down here
196:54 - all of this so this is just making the
196:56 - player jump
196:57 - but now obviously we need a gravity for
197:00 - all of this
197:02 - so we have to set self.gravity
197:05 - to 0 by default and now since we have
197:08 - gravity
197:09 - we also have to apply it so define apply
197:13 - gravity again with itself
197:16 - and in here i want to go self.gravity
197:20 - is plus equal 1 and then self.rect.y
197:24 - so here again we are just picking the
197:26 - rectangle to move it
197:28 - and we just apply the gravity towards it
197:30 - so plus equal
197:31 - self dot gravity
197:35 - and this should be it dot
197:39 - and then to make sure that our player
197:41 - isn't going to fall outside of the game
197:42 - we need self dot wrecked dot
197:46 - bottom if that is greater or equal than
197:48 - 300
197:49 - so our floor then i want
197:52 - self.direct.bottom
197:54 - is going to be equal to 300
197:58 - and this is going to be we have
198:01 - put all of this that is essentially
198:05 - this line here or these lines rather
198:09 - and we are essentially going to do the
198:11 - same thing the only difference now
198:13 - is instead of player rect we have
198:15 - self.right but that's literally the only
198:17 - difference that we really have to worry
198:19 - about
198:20 - so with that we have our gravity and our
198:22 - jump mechanic
198:24 - however now if we run the code nothing's
198:27 - going to happen
198:28 - for the simple reason that we don't call
198:30 - any of these methods
198:33 - and you might be tempted here to go
198:36 - with let me find it in the code here we
198:39 - have our player
198:40 - and you might be tempted to do something
198:42 - like player dot
198:44 - jump or something but that would be the
198:46 - wrong way to go on about it
198:49 - instead what we're going to do is use
198:52 - player
198:53 - dot update and this is what i mentioned
198:55 - earlier
198:56 - that sprite groups in pygame have two
198:58 - main functions
199:00 - one is to draw all of the sprites and
199:02 - the other one is to update all of the
199:03 - sprites
199:04 - and well this is what we are going to
199:06 - make use of here
199:07 - so instead of calling each method
199:09 - individually what we are going to do
199:12 - is inside of our player class
199:16 - we are going to define an update method
199:19 - it still needs self but in here
199:22 - we are going to run self.player input
199:28 - not index input
199:31 - and we are going to run self dot apply
199:34 - gravity and if you now go
199:38 - down a little bit further this play
199:41 - update here
199:42 - is going to call the update method
199:43 - inside of our player class
199:45 - so that way we are going to use that
199:47 - update method to run
199:49 - all of the other code and now let me go
199:52 - all the way to the top again
199:53 - the code is getting quite extensive so
199:56 - now if i run the code this should be
199:58 - working
200:00 - and i made a typo this should be
200:03 - self now let's try it
200:06 - and now we can see that we have
200:10 - two players that will work together and
200:13 - this is
200:14 - looking kind of freaky
200:17 - and here you can see quite well there's
200:19 - a very slight delay but in our case this
200:21 - isn't going to matter too much
200:24 - but if you use different methods of
200:26 - input so in this case
200:28 - this key.get pressed is going to make a
200:31 - very minor difference so just be aware
200:32 - of that but in our case it really
200:34 - doesn't matter
200:35 - so with that we have most of the player
200:37 - the one thing that's missing is the
200:39 - animation frames
200:40 - and well that is going to be the longest
200:42 - part and the first thing that we need to
200:44 - do is to import all the images inside of
200:46 - this class
200:48 - so let me go down a bit and here
200:51 - we have all the frames that we want to
200:54 - import and let me just copy them
200:57 - and now when we call the init method i
200:59 - still want to import
201:00 - all of these so what i want to do in
201:04 - here
201:05 - and i also want to keep
201:07 - myself.playerindex and i also need self
201:09 - dot
201:10 - player jump so let me go through what's
201:14 - happening here
201:14 - first of all we're going to import these
201:16 - two frames and place both of them
201:18 - inside of the player walk frames and
201:21 - this needs self
201:22 - because we want to access it outside of
201:24 - this init method
201:26 - then we have our self.player index this
201:28 - also needs to be available in the entire
201:30 - class
201:30 - and we need our self.jump so this is
201:33 - just the jump frames
201:36 - so this is very similar compared to what
201:38 - we did earlier mostly because i just
201:39 - copied all of it
201:42 - and now when we are loading our
201:43 - self.image i
201:45 - don't just want to have walk frame one
201:46 - for it instead
201:48 - i want to add myself dot player walk
201:53 - and from there i want myself dot player
201:56 - index and this is going to give us right
201:59 - now
202:00 - the index 0 so we would be picking
202:05 - this surface here so
202:08 - still if you are running all of this it
202:10 - is not going to make
202:11 - any noticeable difference we still have
202:15 - the same setup however what we can do
202:18 - now
202:19 - is to declare another method and this i
202:22 - called
202:22 - animation state um couldn't think of a
202:26 - better name
202:28 - and what we are going to do in here is
202:30 - we are essentially going to copy
202:32 - this player animation however now we
202:34 - don't need the global methods anymore
202:36 - because we can work with self
202:38 - so let's work through this step by step
202:40 - first of all
202:41 - again we want to check if the player is
202:43 - on the floor or in the air
202:44 - so this is ifself.rect.bottom
202:48 - is going to be smaller than 300 then we
202:51 - want to do one thing
202:53 - and if that is not the case we want to
202:54 - do something else
202:56 - and well all we want to do in here is to
202:58 - go with self.image
203:00 - and self dot player jump i think i
203:02 - called it
203:04 - uh yeah this one player jump and
203:07 - if that is not the case i want to get
203:09 - myself dot
203:10 - player index and add
203:13 - 0.1 towards it
203:17 - and then again i'm going to need the if
203:19 - statement to check
203:20 - if this index is still inside of this
203:23 - list here
203:24 - so if it is going to be 0 or 1 and well
203:27 - for that i need self
203:28 - dot player index
203:33 - is greater or equal to the length
203:36 - of our self dot player walk
203:40 - and if that condition is true i want to
203:43 - set myself
203:44 - dot player index back to zero
203:48 - and then finally self dot
203:52 - image is going to be self
203:55 - dot player walk
203:58 - then we want to take the index this
203:59 - needs to be an integer and
204:01 - self dot player index
204:04 - so all of this is essentially identical
204:08 - to what we have done down here
204:10 - the only difference now is that we add
204:12 - itself to all of the statements before
204:14 - but in terms of basic logic this is
204:16 - identical
204:19 - so with that we have our animation state
204:22 - and all we have to do now
204:23 - is to call it so dot animation state
204:28 - and now let's try off this again
204:31 - and now we have two walking players and
204:34 - they also
204:35 - jump together so this is working pretty
204:38 - well
204:39 - so this is basically covering the player
204:42 - now
204:42 - what is missing is that we don't have
204:44 - any collisions with the flies or the
204:46 - snails
204:47 - but for that we first have to create the
204:49 - sprites for all of these
204:50 - so well that's going to be the next big
204:52 - step
204:54 - that i want to minimize this class and
204:57 - create
204:58 - another class and this class i have
205:00 - called
205:01 - obstacle and also it needs to inherit
205:03 - from pygm.sprite.sprite
205:07 - and in here again we have to define an
205:09 - init method
205:10 - that needs self and this time we also
205:13 - want to have another argument
205:15 - and that's the type of obstacle so if it
205:17 - is going to be a fly
205:18 - or a snail and then on the first line of
205:21 - the init method
205:22 - we need super and then init again
205:26 - if you don't do that pi game is going to
205:28 - throw an error and it's very easy to
205:30 - forget
205:32 - and in here again we are going to need a
205:34 - self.image and
205:36 - a self.rect those are always needed
205:39 - you can't have a spread class without
205:40 - these two
205:42 - and in here i want to run an
205:46 - if statement to import different kinds
205:48 - of images depending on what i get
205:50 - so if this type is going to be snail i
205:52 - only want to import
205:55 - this stuff here and if it's a fly i want
205:57 - to input all of this
205:59 - so before i create my image i want to
206:01 - run an if statement
206:02 - that if my type is let's say fly
206:07 - so this would look something like this
206:10 - so we are still importing two different
206:12 - surfaces
206:13 - and we place both of them inside of a
206:15 - list that are called frames so this is
206:18 - still very similar compared to the
206:19 - player
206:20 - but now we are also going to need
206:22 - another thing and that is going to be
206:24 - the y
206:25 - position because the flies need to be
206:26 - higher than the snail
206:28 - so in this case let's go with 210
206:31 - and this is the number if you remember
206:33 - from a couple of hours ago
206:35 - that we have specified here so 300 or
206:38 - 210
206:42 - and well that is going to be the y
206:43 - position for the fly
206:45 - and now all i have to do is if that is
206:48 - not the case
206:49 - so if we don't type fly and type
206:51 - anything else i want to have an else
206:53 - statement and this is then going to do
206:56 - the exact same thing
206:58 - except for the snail so it's going to
207:00 - look like this
207:01 - and that way when we create the obstacle
207:03 - we can just type in what kind of
207:04 - obstacle we want
207:06 - and finally we are going to need self
207:09 - dot
207:10 - animation underscore index and that
207:12 - needs to be zero
207:15 - and now we can create our image and our
207:17 - rectangle
207:19 - so for the image we need self dot frames
207:22 - and here we need self dot
207:27 - animation index
207:30 - and then for rectangle all we really
207:33 - need is self dot image dot get
207:35 - underscore act and then mid
207:39 - bottom is going to be random dot
207:43 - rand this was between 900 and
207:46 - 1100 and
207:50 - then the y position
207:53 - all we really do is to set a certain
207:55 - kind of type and then use that type to
207:57 - either import
207:58 - all of this or all of this
208:02 - and this is just going to give us a list
208:04 - with our frames
208:05 - and a y position and then later on
208:08 - we are going to use that list to get an
208:11 - image
208:12 - and then we use that image to get a
208:14 - rectangle that's
208:15 - really all that's happening here now we
208:18 - do need a couple of other things now
208:20 - the first one is let's call it the
208:22 - animation state again
208:25 - it needs self as usual and in here
208:28 - i want to do basically the same thing i
208:30 - did for the player
208:31 - and this could be a really good exercise
208:33 - for you guys then i want you to pause
208:35 - the video
208:36 - and try to figure out the animation for
208:38 - both the flies and for the snails
208:40 - so pause the video now and try to
208:42 - implement all of this yourself
208:48 - alrighty let's do it together now so
208:51 - first of all
208:52 - i need to get myself dot animation index
208:55 - and now i just want to add plus equal
208:59 - and let's say 0.1 again although what
209:02 - you could be doing is that this
209:03 - animation index to a different kind of
209:05 - speed depending if you get a fly
209:06 - or snail but in my case i'm not going to
209:09 - care
209:10 - and now i just want to get myself
209:13 - dot animation index is greater or equal
209:17 - to the length of our self
209:19 - dot frames and if that
209:22 - is the case i want to set myself dot
209:25 - animation
209:26 - index back to zero and then finally
209:30 - my self.image is going to be
209:33 - dot frames then i take the index
209:36 - of integer and self dot animation
209:39 - index and this is going to be pretty
209:42 - much the exact same logic we have seen a
209:44 - couple of times now so if i compare to
209:46 - the play animation
209:47 - we basically did this part here
209:51 - and all right with that we have our
209:53 - animation state
209:55 - now again we have to declare an update
209:58 - method
209:59 - that needs self and in here i want to
210:01 - call myself
210:02 - dot animation state so this
210:06 - would be giving us the basic animation
210:07 - for the fly or for the snail
210:09 - and let me minimize a couple of things
210:11 - in here so it's a bit easier to see
210:13 - what we are doing
210:20 - and all right so now i have my obstacle
210:22 - class and
210:24 - i want to add it to a group so let me go
210:26 - down and
210:27 - let me properly add my groups here
210:32 - and this i just call obstacle
210:36 - group and this needs to be pygame dot
210:40 - sprite
210:41 - dot group
210:44 - however now we couldn't just add each of
210:47 - the obstacles
210:48 - right away because we only want to do
210:50 - that when the timer ticks
210:52 - so this is going to happen if i go all
210:55 - the way down
210:57 - that is going to happen in this part
210:59 - here
211:01 - where earlier we just had an obstacle
211:03 - wrecked list and we appended stuff
211:04 - towards it
211:06 - but i don't want to do that anymore and
211:09 - instead i want to get my obstacle
211:13 - group and in here i want to add
211:16 - one instance of my obstacle and for now
211:19 - let's just call it
211:20 - fly and now let's try and see what
211:24 - happens
211:26 - and we can't see anything
211:30 - and the reason for that should make a
211:31 - lot of sense so if i go all the way up
211:33 - again
211:34 - when we are initiating our class we are
211:37 - putting our fly at position 900
211:40 - to 1100 and slightly above the ground
211:43 - so it's outside of the screen and it
211:45 - doesn't move into the screen so that
211:47 - really doesn't help us and just to
211:49 - illustrate that
211:50 - it is working let me place it somewhere
211:52 - between 100 and 200
211:55 - and now if you run the code again we
211:58 - still can't see it
212:00 - and the reasons for that also makes
212:01 - sense because when i go all the way down
212:05 - we are not drawing this group so what we
212:08 - have to do
212:09 - is to get our obstacle group
212:13 - dot draw and this needs to be on the
212:16 - screen
212:18 - and now it should work for real and
212:22 - there we go
212:23 - now we can see that whenever the timer
212:25 - ticks we
212:27 - are getting another fly which right now
212:29 - looks kind of strange but we can work
212:31 - with this
212:33 - so now let me get all the way back to
212:35 - the top
212:36 - and change this back to 900 to 1100
212:43 - but now what we want to do is to move
212:46 - this fly
212:47 - a little bit to the left on every cycle
212:49 - of our game loop
212:50 - and literally all we have to do to make
212:53 - that work is to get
212:54 - our rectangle again so self.rect and
212:57 - now we need to target one of the points
212:59 - in my case i went with x
213:01 - and then we need to subtract a couple of
213:04 - pixels every single time our game
213:06 - updates
213:07 - so let's go for now with six
213:10 - and that way this entire sprite is going
213:13 - to be moved to the left
213:14 - however there's one thing we still have
213:16 - to do let me go
213:18 - all the way down right now we're only
213:21 - drawing the sprite we're not updating it
213:23 - so we need obstacle group dot
213:26 - update and now we should be seeing a ton
213:30 - of flies
213:32 - and there we can see one and well quite
213:35 - a lot more
213:37 - and well now the game becomes really
213:39 - hard uh
213:41 - i well it's basically unplayable at this
213:43 - point but okay
213:44 - we are going to clean this up in a
213:46 - little bit
213:50 - so okay so with this we have our class
213:52 - properly now
213:54 - and there's only one more thing that i
213:55 - do want to do that whenever our fly or
213:58 - our snail is moving outside of the
214:00 - screen it should be destroyed and how we
214:02 - handled this earlier
214:04 - if i go down a tiny bit
214:07 - we used this line here to remove
214:11 - any kind of rectangle that is too far to
214:13 - the left
214:14 - but if we have a class all of this is
214:17 - much easier to do
214:18 - because all we have to do is to define
214:20 - another method
214:22 - that i'm going to call destroy and self
214:26 - and in here i want to look for
214:30 - self.rect.x
214:31 - and if this is smaller or equal to
214:34 - negative 100
214:35 - i want to run self.kill
214:39 - and this self.kill is going to destroy
214:43 - this obstacle sprite and then all we
214:46 - have to do
214:46 - is in our update method called
214:49 - self.destroy
214:51 - so this way whenever this sprite goes
214:53 - too far outside of the screen it's going
214:54 - to destroy itself
214:56 - and we don't have to worry about it at
214:57 - all anymore
214:59 - although you can't really see it in our
215:01 - game itself so there's no point in
215:02 - running it
215:04 - however there's one thing that you are
215:05 - going to see that we are missing right
215:07 - now
215:08 - and if i go down a little bit further
215:11 - i can actually copy all of this out
215:14 - because we don't really want to look at
215:16 - it
215:17 - so these were the earlier sprites that
215:19 - we looked at and we don't need those
215:21 - anymore
215:22 - and what i want to work on right now is
215:24 - that we are always spawning a fly
215:26 - but i also want to spawn snails once in
215:28 - a while actually i want to spawn
215:30 - mostly snails so i have to figure out
215:33 - some kind of mechanic here
215:34 - to spawn mostly snails and sometimes a
215:37 - fly
215:38 - and there are quite a few different ways
215:40 - to make this work
215:43 - in my case i went with a little bit of a
215:45 - hack so let me explain
215:46 - first of all i imported besides rent int
215:50 - also choice and choice allows us to pick
215:53 - a random item from a list
215:54 - that's all it does so now that i have
215:58 - that i can when i pass on the fly
216:01 - i can pass in choice and this choice is
216:04 - going to pick from a couple of different
216:06 - items
216:08 - and in this list i have one fly
216:11 - and then i have a couple more snails
216:17 - let's put three in there so how this is
216:19 - going to work is whenever we are calling
216:22 - our obstacle
216:23 - this choice method is going to pick one
216:26 - of these
216:27 - four items and since we have our snail
216:31 - three times
216:32 - there's a 75 chance to get a snail
216:35 - and a 25 chance to get a fly and well
216:38 - let's trail of this
216:41 - so now we should only be seeing our
216:44 - sprites
216:46 - and well now our collision is broken but
216:48 - we should be seeing a fly and there we
216:50 - go
216:50 - and now we can only see our sprites and
216:52 - this is working pretty well
216:54 - cool and now
216:57 - let me actually hide the earlier player
217:00 - we created
217:02 - so all of this here we don't need any
217:04 - more
217:06 - and literally all we are going to need
217:08 - is these four lines that's literally how
217:09 - we need we also don't need
217:11 - our obstacle list anymore and we also
217:15 - can comment out our game active
217:19 - and i think if you followed along
217:22 - this code might look very confusing but
217:25 - the main problem
217:26 - right now is that we are both having a
217:29 - sprite setup
217:30 - and a functional setup and this can get
217:32 - really confusing
217:34 - but if you were to actually work on a
217:35 - code you would only look at these two
217:38 - classes which is
217:39 - much easier to organize and the only
217:41 - reason why all of this became so complex
217:43 - is because well i went through every
217:45 - single step
217:47 - but in an actual game all of this could
217:49 - be deleted and you would only have the
217:51 - classes
217:52 - but in my case well the code got quite
217:54 - long but if you look at this here
217:56 - all the stuff i commented out you could
217:58 - just get rid of and well that would make
218:00 - our code significantly more readable
218:03 - but alright let me update the player
218:07 - so all the way at the top let me hide
218:09 - all of this when i initiate the player
218:11 - it is supposed to be at 80 pixels from
218:13 - the left
218:15 - so now let's run this again and now we
218:18 - have the same setup
218:19 - except with sprites and well
218:22 - the one thing missing now is that we
218:24 - don't have collisions so that's the last
218:26 - one we have to add in here
218:28 - and this fortunately is also very easy
218:30 - to achieve because sprites have their
218:32 - own collision mechanics
218:33 - and the most common one is called sprite
218:35 - collide and what this one does is that
218:38 - it takes a sprite and it checks if this
218:40 - sprite is colliding with any other
218:41 - sprite in another group
218:43 - and if that's the case it's going to
218:44 - return a list with all the collision
218:46 - sprites which is super useful
218:49 - and this we can then work with in a
218:51 - function and
218:52 - as a matter of fact we already have our
218:54 - collision function
218:56 - and let me open it and what i want to do
218:59 - is to somewhat copy this
219:01 - so let's call this collision sprite
219:04 - and for this one now we don't need any
219:07 - arguments
219:08 - and really all we want to do is to first
219:10 - check pygame
219:11 - dot sprite dot sprite collide and in
219:14 - here
219:15 - we are going to need three different
219:17 - arguments we first need a sprite
219:19 - then we need a group and then we need a
219:22 - boolean we're going to explain that one
219:23 - in just a second
219:25 - but first of all we need a sprite and
219:28 - in my case i want to get my player
219:32 - and here you have to be careful because
219:34 - this player is
219:35 - not a sprite it is a group single
219:38 - that contains a sprite so that can be
219:42 - quite confusing
219:43 - so this player by itself would not be
219:46 - enough
219:46 - however we can access the sprite very
219:49 - easily
219:50 - all we need is dot sprite and since this
219:52 - class only has a single sprite this is
219:54 - quite workable however in a regular
219:57 - group
219:58 - this sprite would not work you could
220:00 - only get a list of
220:01 - all the sprites you could not get an
220:03 - individual sprite
220:05 - so this is why we have group single here
220:07 - all right but then for the group this is
220:09 - much easier all we need is our obstacle
220:11 - group
220:12 - and now we have the group that we need
220:14 - now
220:15 - for this boolean here what this
220:18 - effectively does
220:19 - is that if this sprite here
220:22 - is colliding with a sprite in this group
220:25 - we can check if this spread is going to
220:26 - be destroyed or not
220:28 - and this is what the boolean here is for
220:32 - so if you're going to set this to true
220:34 - every time our snail will collide with
220:35 - the player the snail will be deleted
220:38 - and if we set this to false the snail
220:40 - would not be deleted
220:42 - and in my case i want to go with false
220:44 - but in our case it
220:46 - really doesn't matter all that much but
220:48 - all right now this entire statement is
220:50 - going to return a list
220:52 - and if it doesn't collide with anything
220:53 - it's going to return an empty list
220:55 - and that we can use an if statement
220:59 - so if there's anything in this collision
221:01 - list we want to run some code
221:02 - and well all we really want to do is to
221:04 - return false
221:07 - and if that is not the case i want to
221:10 - return
221:11 - true and this is going to be very
221:13 - similar compared to our collision
221:15 - function
221:17 - so all right now all i have to do if i
221:19 - go down
221:20 - quite a bit by now we have down here our
221:23 - collisions
221:25 - i still have our game active variable
221:28 - and now we want to check collision
221:30 - sprite
221:32 - and well with that we should have our
221:33 - collisions back so let's check if this
221:36 - is working
221:37 - and there we go it's still working but
221:39 - now we have the same problem again
221:41 - that if i run the game again the snail
221:44 - is still in the same position
221:46 - so well our game would crash right away
221:50 - so whenever let me go all the way up
221:53 - again whenever this collision sprite
221:57 - triggers
221:57 - we want to delete all of the sprites
221:59 - inside of our obstacle group
222:02 - and this is very easy to achieve
222:05 - because all we need to do is to get the
222:07 - obstacle group
222:09 - and empty it and
222:12 - now if i run all of this this should be
222:14 - working pretty well
222:16 - so now if i collide with a fly the game
222:19 - stops
222:20 - and now it starts again with no sprites
222:22 - in there and well this is working pretty
222:25 - well
222:25 - cool so now we have our game working
222:30 - again
222:31 - so with that we have made quite some
222:34 - noticeable changes
222:36 - and there's a ton of redundancy in our
222:38 - code now which
222:39 - isn't great but i hope you get the
222:41 - principle following along
222:43 - and i'm going to upload all of the code
222:45 - in the proper way for the class-based
222:47 - approach that's
222:48 - going to help understand all of this i
222:50 - think but if you could follow along i
222:52 - hope this makes sense
222:54 - but alright there's only one more
222:55 - topping left to do and that's to add the
222:58 - sound and this is going to be a super
222:59 - easy part and well the audio part is
223:02 - going to be really quick
223:03 - because there's only really two steps
223:05 - that are both really easy
223:07 - we first have to import a sound and then
223:09 - we have to play it at certain parts in
223:10 - our game
223:11 - and all of that happens with the pygame
223:13 - dot mixer module
223:15 - and this really isn't all that
223:16 - complicated
223:19 - so i think the best way to approach this
223:21 - is to jump straight into our code
223:23 - and then let's do all of this so
223:25 - specifically i want to work with two
223:27 - sounds
223:27 - one is the background music and one is a
223:29 - jump sound
223:32 - so here we are back in the code and the
223:35 - first thing i want to do is to add the
223:36 - player jump sound
223:37 - and for that i am opening a player and
223:40 - when we initiate this class
223:41 - i want to also import the sound and
223:44 - let's call this
223:45 - jump underscore sound
223:50 - and now to import a sound we need pygame
223:53 - dot mixer dot sound
223:56 - and as always make sure the s is
223:58 - capitalized that's really important
224:00 - but now all you have to do is to add a
224:03 - path to what file you want to import
224:05 - and in this case we have audio jump.mp3
224:08 - and that's all we needed to import is
224:10 - sound so that's the first step
224:13 - and now we only want to play this sound
224:15 - when our player is jumping
224:17 - and that happens in
224:21 - this player input that whenever we play
224:24 - the button we want to jump
224:26 - so we could play this sound ideally
224:29 - in here and that would make the most
224:32 - sense
224:32 - so let's play there and to play the
224:35 - sound literally
224:36 - all that we have to do is to get our
224:39 - self.jump
224:40 - sound and then add play
224:43 - that is literally all we have to do so
224:45 - now if i run the code
224:47 - we can still see our game that's a good
224:48 - start
224:50 - and now you should be able to hear
224:53 - a jump sound so it's really as simple as
224:56 - that
224:57 - now there's one problem with this that i
224:59 - think this sound is kind of loud and
225:01 - annoying so i want to make it less loud
225:04 - and this we can also do very easily all
225:06 - we need is to target our jump sound
225:08 - again
225:09 - and then add set volume
225:13 - and in here we choose a value between 0
225:15 - and 1
225:16 - with 1 being the full sound and 0 being
225:18 - the sound muted
225:19 - and in my case i went with 0.5
225:23 - and now this should sound
225:26 - significantly better but do play around
225:28 - with it i
225:29 - guess um whatever you think is perfect
225:33 - so that's all we had to do for the jump
225:35 - sound now
225:37 - next up let me minimize all of this
225:39 - because we don't need it anymore
225:41 - and next up i want to have an actual
225:43 - game sound and let me import it
225:45 - right when we initiate the game and
225:47 - let's call this
225:48 - bg music for background music and this
225:51 - could be a really good exercise for you
225:53 - try to import this music and play it
225:56 - once once our game has started
226:02 - so all i want to do is
226:05 - pygame.mixer.sound
226:07 - and now the file that we are going for
226:10 - is this one audio slash music or wav
226:13 - and that is the music that we want to
226:15 - play and now we have to figure out two
226:18 - things
226:18 - number one is where do we have to add
226:21 - the code to play this music
226:22 - and number two is how can we loop this
226:25 - music
226:26 - so this track here is only a couple of
226:28 - minutes long and once it's over i want
226:30 - to restart it
226:31 - so that's another thing we have to
226:32 - figure out but first let me change this
226:35 - to
226:35 - lowercase music so it looks a bit more
226:37 - consistent but right
226:39 - now i want to target my pg music again
226:42 - and again what i want to do is to play
226:44 - this music
226:47 - and now as soon as our game starts we
226:49 - are going to play the music
226:50 - so let's try this
226:55 - you can play with the ball a little bit
226:57 - it's up to you i
226:58 - am not going to worry too much and now
227:01 - if you want to loop this
227:02 - all we have to add is one argument in
227:04 - here and that's called loops
227:06 - and in here we can tell pygm how often
227:08 - to loop this
227:10 - so for example if i were to add a six in
227:12 - here we would loop this track
227:14 - six times but in our case
227:17 - we don't want to loop it a certain
227:18 - amount of times instead we want to loop
227:20 - it forever
227:21 - and for that we need -1 and this is
227:24 - telling pygam to play this sound forever
227:26 - and once it's over to just restart and
227:29 - well you can't really see this in the
227:31 - game
227:33 - [Music]
227:36 - now with that we do have the entire game
227:40 - and if you have gotten this far you have
227:42 - basically learned all the fundamentals
227:44 - of pygame
227:45 - so at this stage you should be able to
227:47 - approach most 2d
227:48 - games now obviously you do have to
227:50 - practice using all of these concepts
227:52 - but this is essentially all the concepts
227:54 - you need to make them
227:56 - so i hope that was helpful

Cleaned transcript:

hello there in this tutorial we are going to be making this game however the game itself isn't really the point of the video instead it is more of a vehicle to explore pygame essentially this is an introduction to all the major components of pygame that you need to start making games in python and by the end of it you should have all the tools to approach any 2d game starting from text adventures and pong going all the way to the first generation of doom and wolfenstein games and i do plan to make more advanced games in pygame so get subscribed if you don't want to miss those and really quickly before i start you should know some python already it doesn't have to be much but i do assume that you know how to use functions and simple classes so nothing fancy but the basics of python and if you want to code along you can find all the assets in the description so i hope you enjoy alrighty so before we get into any actual code let's first talk about how video games work on a general level that is really going to help us understand what pygame does and how it actually works so how do video games work and i think the best way to think about that is to start with movies because that is the technology video games leaked off from essentially a movie is really just a ton of images playing really fast after each other so for example here's a movie and all i have to do is to slow it down and you can see individual images although for movies these are usually called frames but it's well it's the same thing and most of the time a movie has 24 frames per second so you see 24 images per second and your eye perceives this as a moving image at least in most situations and if you do this long enough you eventually have a movie that lasts about an hour and a half and that's essentially it the only real difference between different kinds of movies is how each individual image is being made and there are basically three different ways to approach this number one you could get a camera and just point it at something and record it number two you could draw an image or number three you could use a computer to create a 3d image and each of these approach would give you a very different look of your movie but at the end of the day all we're doing is creating lots of individual images and playing them really fast after each other and that's literally it so with that we have movies and video games are quite similar to that and in the most basic sense a video game basically works like a movie that you have lots of individual images being played really fast after each other but obviously there need to be a couple of differences to really make all of this work number one and i guess the most important one is that on a video game each individual image isn't set in stone instead it's dynamic meaning that each individual image is created on the fly and plays dynamically depending on what the game needs so for example is the enemy in a certain position or did the player press a certain kind of button to move in a certain direction and then each individual frame is being updated automatically whereas for a movie each individual image is basically always the same so this already makes video games different that you have dynamic content and that already brings us to the second point that for video games we are checking player input which means that at the beginning of each image that we are drawing we are first checking the input from the player so we are checking if the player presses the button on the keyboard or moves the mouse or says something into a microphone lots of different things that we could be checking and then we are using that information to place something dynamically on the screen and well once we have accounted for those two differences we basically have a video game so let's give how a video game works on a conceptual level we always start by taking the player input and this is usually called an event loop so each kind of event could be a different kind of thing a player does it could also be something else for example a timer running out but essentially we are taking all the necessary inputs we need to draw the current image and once we have all that information we are actually placing all the relevant parts on the screen so we are placing the player in a certain position we are placing all the enemies we are drawing the health indicator the coin indicator whatever we really need and well once we have all of that we have one finished frame so this is one image the player is going to see now once this process is finished we are getting rid of the entire image again and starting this process from scratch and we are doing this multiple times per second usually about 30 to 60 times depending on how fast the computer is now that is really it and this applies both to 2d and 3d games so it doesn't really matter if you have a 2d image or 3d object to generate each individual frame at the end of the day you are just putting different elements together and displaying them to the player so with that let's talk about how pygame comes into this and well pygame has a couple of key functionalities that we can use to make a game and it doesn't necessarily have to be a game we could also make a movie in pi game or we could display some graphs this would also be possible so what does pygame actually do in the most basic sense pygame gives you a really good way to display images and this might be relevant if you just started with python development you might have realized that drawing anything on the screen is actually really hard and most of the time you just work with a console where you can see text but displaying actual images and animations is not that easy and this is the first thing that pygame is really good at that it helps us create a window and it helps us display images something that is well important for video games and along with that pie game can also play sounds this goes along with that quite well now the second point pygame can do well is to look for player inputs so pygame can help you get the mouse position or get keyboard inputs or even get gamepad input lots of different things that it can do and again in standard python you have the input method but this one stops the entire code if you want to get input which would break any kind of game so this would be the second important part of pygame that we can get actual player input and those are the two really important parts that pycam helps us with but there are a couple more that are general helpful things for a video game for example pygame is really good to help us with collision detection or pygm can help us create text and timers lots of things that are important for a video game but these are things you could also do in standard code but pygame has lots of ways to make it easier when it comes down to it pygame is a very simple module now there's one important thing i do want to address that if you want to make really sophisticated games let's say a dark souls or an assassin's creed then you would not use something like pygame because it doesn't really give you too many tools for this kind of thing instead you would use a proper game engine and this would be something like unreal unity godot and there are quite a few more and the game engine has a lot of additional tools that make game developments significantly easier for example there's gravity detection there's support for 3d objects there's lots of inbuilt stuff that makes game development very easy and along with that there's also graphical user interface that allows you to place elements on the screen and you see the game as you develop it and pygame doesn't have any of that it's well not really designed for that sort of purpose so just keep that in mind now this already brings us to the first important point why would you want to use pygame over something like unreal or unity and this is actually bringing us to one of the important parts of pygame that most of the time pie game isn't used for actual game development at least for games that you want to publish instead pygame is incredibly good to learn how to code and to create systems yourself so if you only ever use a proper game engine and you have all the systems in place for you you don't really learn good programming instead you learn to rely on external tools that somebody else provides for you but if you develop all of this in py game yourself you become a much better programmer and later on if you have more experience in programming you can very easily switch to other engines and actually make professional games but to get started working in pygame is really useful because you learn very good practices and become a much better programmer so now let's actually get started in pygame and before we can start with pygame we first have to install it because pygame does not come with python automatically but installing it is super easy all you have to do is either go to the terminal or the powershell and type pip install pygame and then you should be seeing a short animation and after that you should get the message that the module was installed successfully so with that let's actually get started by creating a window in pi game so here i have an entirely empty sheet of code and the first thing i want to do is to import my game and at this stage i would already recommend to run the code here we can see we have pygame version 2.0.0 you can see our python version and then you have a hello from the pygame community and a link where you can contribute so if you can see this message you have installed pygame successfully if at this stage you get some kind of error message you probably didn't install pygame successfully so check that stage so now we have pygame how can we actually use it and well the first line we need is pygame.init and don't forget to call it that's really important and pygame.init is incredibly important and absolutely necessary to run before any other pygmy code so pi gamma knit essentially starts pygame and initiates all the subparts of pygame that you need to make a game for example this init helps us render images and play sounds and stuff like that basically and while it does lots of complicated stuff you don't really have to worry about this at all all you really have to do is to call it in the first place but once you have called it it's basically good to go think of it like starting the engine of a car that when you actually do that lots of really complicated stuff happens but for you as a driver well you turn around the keys and that's basically it that's essentially the same principle here now on the next line we have to create what is called a display surface and a display surface is basically the window the player is going to see in the end and this we have to store in a variable that is usually called screen and to create a display surface we need pygame.display.set mode and into this set mode we have to place at the very least one argument and this has to be a tuple and this one should contain the width and the height of our game window so essentially later on when we create our window the width is going to be this part and the height is going to be this part so uh well that's all we really need and in this case i want to go with a width of 800 pixels and a height of 400 pixels and now once we have that we can actually run the code and let's see what happens and there you could see a window for just about one frame and this is the intended behavior for now so if you get the same result you have done everything correct and let me explain why this is happening what happens right now is that we are importing pygame we are initializing pygame and we are creating a display surface but after that is done our code ends and our computer stops running this python code and as a consequence of the code ending this display surface also disappears so we are seeing it for a second because pygame is starting to run it but then closes it basically immediately afterwards and this is why we only see it for a second or so and well the solution to that is that we need to figure out some kind of way to keep our code running forever and well for that all we really need is a wild true loop so this while true loop is going to run forever for the simple reason that this condition in here is never going to be false and we have to break the while loop from the inside so basically our entire game is going to run inside of this well true loop and in here we are going to draw all our elements and also update everything so this is all going to happen inside of a while loop and there is one important line we have to add in here as well and that is pygame dot display dot update and all that bond is really doing is it updates this display surface so that anything we have drawn inside of this while loop we actually want to display to the player so we have to take it and actually put it on the display surface and this is what this line here is for so don't forget this one either but again just like with pygame.init you only really have to call it and then you don't really have to think about it that much more so all right now we could be running this code now and we would get a window that would stay open forever however please do not call the code right now because you wouldn't be able to close it by itself for the simple reason that right now we do not check for any kind of player input and one type of player input would be to close the window so keep that in mind as well that if you didn't check specifically for closing the game well the player wouldn't be able to close the game so let's add that one first and this again happens in the well true loop and really what we want to do here is to check for all the possible types of player input and this is called an event loop and more practically this is just a for loop we are looking at all the possible types of player input and see if one of them is happening right now so what we want to do is for event so all the possible events and to get the events we use pygm.event.get so this method here would get us all the events and this part here just loops through all of them that's really all that's happening here and for now all we want to check is if the event type we are looking for is equal to pygame dot quit so this pygame.quit here is a constant that is synonymous with the x button of the window so if the type of the event is equal to pygm.quit we are indicating what to close the window and if that is the case we want to do pygame dot quit and let me add a proper double colon and indent everything so now this is working and well now we run the code this should be working much better and now you can see the actual window and i can also close it so let me close it and we're getting an error message that we are getting the error you can see it right here that we have a pygame error video system is not initialized and let me explain what's going wrong here whenever we call pygame.quit we are basically doing the opposite to pygame.init so these two are essentially polar opposites that pygame.net initializes all of pygame pygm.quit uninitializes everything so once we're running this code we can't display anything anymore so we couldn't for example run this method here because pygame needs to be initialized for this to be possible and basically what happens here is that we are calling this method and then we continue down our code and then python encounters this line and it can't run it so it throws an error so the problem here is that we are closing pygame but we still keep this while loop open and this is causing the problem so really what we have to do is to end this well true loop on the spot and well you could call something like a break statement in here but the most secure way to close pygame is to use the sys module and the sys module is something inbuilt into python and it gives you access to different system commands one of these commands is to close any kind of code you have opened entirely which is exactly what we want so well i want to import another module and i only want to import one specific part from it so i use from sys import exit and this exit method closes any kind of code once you call it so well i just want to do that so i call exit and once we have called this exit here this weld true loop will also be gone so then we are not calling this pygame dot update anymore and our code is just going to end so now let's try all of this again so i can still see the window if i close it now our code just finishes and we don't get an error message so this is working pretty well now with that we have a basic setup for our game although there are two more things i would like to add one is very simple the other is slightly more complex so let's start with the most simple one and well what i want to do is to give our game a title because if you check right now we just call it pygame.window so we can see it up here in the title we have pygame.window which well doesn't sound particularly good and we can update this title let's say do it right up here all we have to do is call display dot set caption and in here you have to pass in a string with the name of the game in my case i just called it runner and now if you run it again you can see runner in the top left now you could also change the icon but in my case i don't really care so much but okay this is a pretty good start now for the next part we have to talk about something really important and that is the frame rate or how fast our game is going to run and this is something really important to keep in mind so let me illustrate in a movie the speed is always the same usually 24 frames per second and this stays constant but for a video game the framerate can fluctuate quite a bit so for example if you try to run a modern game on a computer from 25 years ago you would probably only get one to two frames even at the best computer from that time and this would basically make it impossible to play that game but there's also the other side that if you have a modern computer your computer might be able to run the game at something like a thousand or two thousand frames per second and if the game wasn't optimized to handle these kind of frame rate differences the game might run incredibly fast and this might be a problem because our animation speed depends on how fast we're updating the game so think of it like this we have a main player character and let's say we are moving him 10 pixels to the right on every single frame now if you are doing this with 1 frame per second you are moving him by 10 pixels every second now if you are doing this with 100 frames per second you're moving him a thousand pixels per second so you have a massive difference in speed and this is something we have to be able to address because you want your game to run consistently on basically any platform at least within reason and in our case we just want to keep the frame rate constant so we don't want our game to run too fast and we also don't want to run it too slow ideally we would like to run our game at 60 frames per second constantly so we have to create a ceiling and a floor for our frame rate and well creating the ceiling is very easy but creating the floor is much more difficult for the simple reason that you can just tell your computer not to run the game faster than a certain speed and if your computer can run a game at 100 frames per second you could just tell it to run slower that shouldn't really be a problem however if your computer is too slow to run the game then well you couldn't magically tell it to run faster and be more capable so to account for the minimum frame rate you just have to be a good video game developer and ensure that there's never too much on the screen at the same time for example something that video game developers are very much concerned with but setting the maximum frame rate is very easy to do so let's actually do that so here i'm back in pi game and what i want to do is to create a clock object because the clock object helps us with time and this also helps us with well controlling the frame rate and this usually put in a separate variable that i have called clock and to create a clock object we need pygame.time.clock and make sure that the c in clock is capitalized that is really important and now this is going to give us a clock object now by itself it doesn't really do anything but when we call it in our while loop we can call clock.tick and in here you can add an integer in my case 60 and this 60 is telling pygame that this wild true loop should not run faster than 60 times per second or about one while loop for every 17 milliseconds and that way our game is not going to run too fast i will illustrate later on in this tutorial how this is actually making a difference for the animation but alright so with that we have set a maximum frame rate now the minimum frame rate we can't set with one line of code we just have to make sure our game doesn't become too complex now that being said we are only going to create basic 2d games in pygame and those are basically never going to run to promise for even reasonably modern computers so we don't really have to worry about a minimum frame rate but it is something to keep in mind if you want to make more sophisticated games but alright so with all of that we finally have our basic setup for our window so obviously this still isn't great because we are not displaying anything so let's actually start working on that and let's put some basic images on our display surface so how can we actually draw anything in pygame and well to draw any kind of image we need one important concept and that is called a surface and there are two different kinds of surfaces in pie game and the one we have already seen was the display surface so a surface can just be the main window the player can see but there's another kind of surface that we are going to use much more so let me explain if you want to display anything in pygame you essentially always put it on some kind of surface what the player is going to see at the end is anything that was put on the display surface so this is the actual window that we are going to display but to display anything on this display surface we need regular surfaces and a regular surface or just a surface is basically just an image and this image can be different kind of things it could for example be an image you have imported it could just be a plain color or it could be some kind of text these are basically the three different kinds of possibilities and then you could place a surface with some content on the display surface and that way you would actually display the regular surface i think the best way to understand this is like this imagine you want to create a really big post and present it to people the actual canvas you are putting stuff on is the display surface so this is what you are going to present at the end but by itself just having a canvas doesn't really help you all that much so instead you have to place individual postit notes and pictures on this display surface and each individual postit note and image is going to be a regular surface and if you place enough surfaces on the display surface at the end you are going to have something that hopefully looks quite nice so that really is all the difference here that we have to worry about but just to mention it we can only have one display surface and the display surface is always shown so we can basically never hide it however for regular surfaces we can have as many as we want there's no limitation to it however a regular surface is only displayed if we actually put it on the display surface so you could have created a thousand surfaces unless they are specifically attached to the display surface they will not be visible so all right that was again quite a bit of theory so let's actually get into our code and let's create a basic surface and for this section i want to create three different kinds of surfaces one with a plain color one with an image that we imported and one with text and they all work by creating first the surface and then placing the surface on the display surface let's start with the simplest one to just create a surface with a plain color here i'm back in my code and i want to create a new variable and let's just call this test surface so we are going to play around with this one and then later on we are going to delete it to replace it with something more proper and to just create a plane surface we need pygame dot surface and here again make sure that this s is capitalized otherwise it is not going to work and this surface is going to need a tuple with the width and the height so here we want to get width and height and this is very similar compared to what we have seen for the display surface and this is something you are going to see very often that the display surface and the regular surface have lots of things in common and this would be just one of them and in my case i want to give this surface a width of 100 and a height of 200. so now we have created a surface now the next thing we have to do is to actually display this and this is going to happen in this well true loop and let me get rid of the comments they don't really help us all that much so in the first indentation of this well true loop i want to actually attach this test surface to our display surface and this happens by first calling our display service itself and then using the blit command and blitz stands for block image transfer which is essentially a fancy way of saying you want to put one surface on another surface and in here we need two arguments we first need the surface we want to place and then the position and well the surface we already have is just our test surface and for position for now i just want to place it in position 0 and 0. and you are going to see in a second what that actually means but now let's run the code and well what we can see is that we well can't see anything and there's a specific reason for that and the reason is quite simple actually that right now both our surfaces are plain black so this surface here is black and this surface here is black and if you put something black on something else that is black you just get more black it doesn't help you all that much so what we have to figure out is how to add color to either of these surfaces and well fortunately that is very easy to do because there's a specific command for it and let me just run this on test surface because all we need is the fill command and in the fill command we can add a specific color and pie game has a couple of ways to add color and the simplest way is to use a couple of named arguments that are predefined for pygame and there's a long list online that you can find that i would recommend to check out i'll put a link in the description of the video and one that we could use is just red so that we want to fill this test surface with a red color and now let's run the code and now we can actually see our red surface in the top left of the screen and now i really want you guys to think about why is this thing in the top left that is really important to understand and well i guess let me actually explain what's happening here most importantly our main window is this display surface and is 800 pixels wide and 400 pixels high so this here would be the height and let me actually put it down here so this would be 400 and our width would be this entire width and this would be 800. so this is just the arguments we specified up here but there's one super important thing you have to understand about this that you have to think about this window as a coordinate system think of it like in basic math where you had a coordinate system that looked something like this and on this you could have displayed a graph or something like this and the really important part of this coordinate system is that the origin point was always in the bottom left so this point was always 0 and 0. and if you wanted to go either to the left or upwards you had to increase either of these numbers now in the case of pygame this is slightly different so what you have to be aware of for pygame is that the origin point is in the top left so this point here is the point zero and zero so if you want to go to the right you still have to increase x so let's call it plus x however if you want to go downwards you have to increase y whereas in the system you learned in high school if you wanted to go downwards you had to decrease y so this is slightly different for pi game and this is also something you see in lots of other game engines and especially in the beginning unfortunately this is really confusing and you will need some time to get used to it for basically any game engine so something important to learn so this is the first thing you have to understand here that this is our origin point so now when we place something at zero and zero we are looking at this point up here now this brings us to the second point that when we have this test surface there's one specific point we place when we place this surface and the specific point we are placing is always the top left so when we specify this 0 and 0 here we are saying essentially that we want to get the top left position of this test surface and place it right in the top left of our display surface and that way we have our surface right in the top left so this is really important to understand for pygame to understand how the coordinate system works with a bit of practice this should come quite naturally to you and let's actually do an exercise if you want to follow along that right now i don't want this surface to be in the top left anymore instead i want it to be 200 pixels from the left and 100 pixels from the top so try to implement this yourself all right welcome back so let's try to do this together now so right now we are placing the top left position in 0 and 0 which is not appropriate anymore instead i want this to be 200 pixels from the left and 100 pixels from the top and now if i run the code again we can see let me draw on this again we have this distance here is 200 pixels from the left and we have 100 pixels from the top so this is what these two numbers here illustrate and again we are placing this point here so actually this line here should have been rather right on top of that so i hope that makes sense and if you get stuck on this definitely play around with the different kind of points it's really important to understand and later on we are going to learn a specific method to help us place something more deliberately but for now this should be good to go so that way we can create a basic surface that has a plain color but obviously that still isn't all that great because well our game isn't going to consist out of plain colors instead we want to have actual images and well for that we want to import some images and well the first we need for that is to actually have some images and in my case i have a couple of folders that are in the same folder where my code is so let me open that one and in here we have our runner code and then we have three more folders we have graphics we have font and we have audio and well each of these contain what the name implies they contain so let me open graphics and there we have for example a ground and the sky these are what we are going to use in just a second but there's also a couple of enemies and the player itself so these are the tools i'm going to work with for now and i will always assume that our actual code is in the same top folder as these three other folders so when we import something we have to specify a specific path and if you want to follow along keep the same folder set up but right let me go back to the code and now i want to get rid of all of this and instead import an image and to import an image we need pygame.image.load and in here we have to specify a path and in my case i want to go into the folder called graphics and in that folder we have an image called sky and don't forget we need the file ending so my case this is dot png and well with that we have imported an image so now let's run the code again and we have our background and right now you can actually see the offset really well let me get rid of the offset entirely so i just want to place this background on position 0 and 0. we can see the actual background so this way it's super easy to import an image and one important thing to keep in mind here every time you import an image into pygame you are putting this new image on its separate surface so any kind of graphical import is going to be a new surface and in this case i guess we can call this our sky surface because we can actually keep it this one works pretty well already so sky surface and with that we have our sky and now actually this is something we can practice really well because there's another image inside of the folder that is called ground.png and i want you guys to import this and place it somewhere in the bottom of the screen so we actually have something that looks halfway decent already so try this yourself if you want to code along let's first create a new variable that i called ground surface and to import this one we are going to need the same setup so pygame dot image to load i want to look at graphics and in there we have a file called ground.png and i guess something slightly tricky about this that this ground is not capitalized whereas this sky is and uh well that's just my mistake sorry about that but now we have our ground surface so this is just another image and let me place this right before our sky so i again want screen.lit this time i want ground surface and for now let me place it at position zero and zero just to see what happens and another one the code we can see an error because i made a typo so this should be graphics so now let's run it again and now we can see that we can't see the background and this again is intentional so right now the problem here is that we have our sky that's the main image we have and our ground is right behind it so our ground would basically be somewhere here ish but we can't see it because the sky image is right on top of it so it overlaps it entirely and the reason for that is that we first create our ground and then we put the sky on top of that and pygame always draws an order of when you call the code so in this case we first draw the ground and then we put the sky on top of that which doesn't really help us all that much but we can fix that very very easily all we have to do is to first draw the sky and then the ground and now we run the code again you can see the actual ground so now we're drawing the ground on top of the sky surface and okay right now we can see that our ground is way too high so we have to place it a little bit further down and well in here you can just play around with this and see what looks good let's try 300 this i think looks pretty good so with that we already have a fairly basic setup by just importing two images so with that we have basically already covered the two most basic kinds of surfaces we have a surface with a plain color and a surface with an image now there's a third kind that you can have a surface with some text and here the really important thing to understand is that every time you want to create text you first have to create an image of the text and place that on a surface and then you place that surface on the screen and this is a slightly cumbersome process although it is quite workable but to work with text you essentially need three different steps number one you first have to create a font that stores your basic font information so the style of the font and the font size then in the next step you use that font information to create some actual text and this text is going to be on the surface and then in the third step you're placing that surface on the actual image and that's really all you need so let's actually implement all of this so here i'm back in the code and the first thing i want to do is to create a font and i'm going to place this right in our starting variables but you could basically place it wherever you want and let's just call it test font for now and to create a font in pi game we need pygame.font.font and here again the first letter of the second font has to be capitalized otherwise this is not going to work and in here we have to specify two arguments the first one is the font type you want to use and the second one is the font size that we want to have and for the font size that's the easier one it's just an integer i went with 50. and for the font type for now i'm just going to use none so we are using the default font of pie game but we are going to change this in just a second so now we have a font and later on we are going to use that to display the score but for now i just want to write some basic information so we know it's working so that brings us to the second step and let me place this right below our other surfaces and in here i want to create a new surface and let's call this one the text surface and to create this surface we first need our test font and then the method render and render is going to need three bits of information number one is the text information number two if you want to antialiase it and number three is the color let's go through those one by one first up is the text and this one literally is just the text we want to display and in my case i am just going to call this my game for now next up is antialiasing and antialiasing basically means that we are going to smooth the edges of the text which in this case is not something we want to do because we are working with pixel art but if you are working with any text that's not pixel art you basically always want this to be true because it makes your text look a little bit better and then finally we have our color and here again we can use the same kind of approach we have seen earlier so in this case i want to go with let's go with green this time so essentially i'm going to create some text that says my game and it's green that's really all that's happening here and with that we have a surface so now all we have to do is to use screen dot blit again use our text surface and now place this somewhere in the middle of the screen at the top and the numbers here don't have to be specific we are learning later on a better way to place text but i know in this case our window is 800 pixels wide and 400 pixels high so i want to place this roughly at 300 from the left and 50 from the top and now let's actually run this and there we go we can see my game right in the top of the screen now obviously the font doesn't really match the rest of the game and this we can work on right now actually so right now we have the problem that we are using the default font of pygame which is none up here which well doesn't look particularly good but if we specify a specific file in here we can use a much better looking font and again if you look at the folder there's one specific file that we can use so so all i have to do is go to font and in front we have a file called pixel type and this is a ttf file so this specifies a font and all i want to do is to import this file so i specify it in here so we have our font and then pixeltype.ttf and now we're on the code we can see a very different looking text and this one i think looks much better and i guess the green color doesn't work too well with it so let's go with black for now and yeah this is looking much better now so with that we have the three different kinds of surfaces that we can draw some text we can draw a basic color and we can also import some images and display them and this is already bringing us so much closer to an actual working game but obviously right now nothing is moving which isn't great for a game so let's actually start animating some of this and the logic to animate something in pygame is actually fairly straightforward and here again you have to remember the basic logic about video games i talked about earlier so right now we are drawing three different images our sky our ground and our text and we always place them in the same position and the important thing you really have to understand here is that we are not drawing a static image right now it just looks like a static image to us but essentially we are updating this entire image over and over again 60 times per second now the problem for us right now is that we are placing all of these images always in the same position and this is what it looks static to us but if we were to update the position of each of these surfaces we would get a moving image so really all we have to do in the most basic sense is when we use screen.blit we don't use one constant position instead we use a variable that we continuously update and once we have that we have a moving image that's literally all it is so what i want to do in this section is to get our snail enemy and move it from the right of the screen to the left of the screen so well let's actually jump into our code and let's have a look at this here i'm back in my code and the first thing i want to do is to import our snail image so let me call this snail surface and here again we need pygame.image.load and the path to the snail is graphics snail and snail one there are multiple snail images because they show an animation of the snail itself we're going to cover that later on but for now just work with snail one so this would give us our snail surface and let me actually draw this on the screen so again i want screen dot blitz i want our snail surface and let's place this about 600 pixels from the left and 250 pixels from the top so now if i run this we can see our snail so this one is already working fairly well and the problem here right now is that this is static because these two numbers are never going to change we always place the snail in the same position and well we are placing all of this always in the same position but we don't necessarily have to do that what we could do for example is create another variable let's call this snail x position and by default this is going to be 600 so i just copy this 600 and place it in here and then call snail x position so all we really did is move this 600 into a specific variable so right now if we run the code we are going to get the same result our snail is still static but now what we can do is every time this while loop is running we want to increase our snail x position by one so that every time we come to this line here our snare lacks position is going to be increased by one and if we run the code now we can see our snail moving to the right because the x position is going to be greater on every single cycle of this while loop and now if you want to move this nail to the left all we need is minus equal 1 and now our snail is going to move to the left and this is already working pretty well and well minus one is probably a bit slow let's go with four and yeah this looks like a decent speed cool but now obviously once the snail is leaving the screen this snail is going to keep on moving to the left and we will never see it again so this isn't great yet but really all we have to do to overcome this is use an if statement that if our snail exposition is too low we want to again put our snail exposition on a higher number and this is a very simple if statement and this could actually be an exercise try to figure out how you could place the snail on the right of the screen if it crosses the left side of the screen let's try together now so i want to use an if statement and i want to look at my snail x position and really i want to do is to check if this is smaller than let's say minus a hundred and if that is the case i want to get my snail x position and set it to something like 800 and now if i run the code i can still see the snail if it moves too far to the left now it reappears on the right and well really all that's happening here is we look at this point here so about minus 100 and if our snail x position so this point here gets further to the left than that we are putting this position all the way over here so this way it looks like our snail is looping but really all we're doing is we're looking at this snail x position and we are updating it and then placing the snail in a specific part so really all we are seeing right now is that our snail is continuously updated and our brain interprets all of this as a moving image but okay and i guess now what we can actually do just to illustrate how the animation works is this clock.tick right now is at 60. but if i set it to 1 you can actually see what's happening so now let me run the code again and now you can see the snail is just being updated a little bit further to the left every single time and we're just drawing a new image every single time and if this is slow enough it looks like well our snail is very sloppy and on the counter side if i set this to something like 600 then our snail is going to be significantly faster so because of that our frame rate is really important and we really want to make sure that this stays at least somewhat constant so all right with that we have a basic animation so this is already going pretty well now before we continue there's one more thing i do want to show you guys and let me just comment out all the images we have drawn earlier so right now we have no sky we have no ground and we have no text the only thing we are drawing is the snail and now we run the code we get a very strange looking result and the reasons for that should make sense if you think about it for a tiny bit that right now all we are drawing is the snail and the snail doesn't cover the entire screen so every time we are updating this surface we don't really get rid of the previous frame we're just drawing on top of it and since we are not drawing on the entire surface we can still see the previous frame and as a consequence it just looks like we are stretching out something which well looks terrible so always keep in mind that you want to draw a proper background for your display surface otherwise you will be able to saw the previous frames you are drawing which looks very strange unless well it's something you actually want to achieve but okay so with that we have our basic animation and this is already looking pretty good i think and there's one more thing i would like to talk about before we get into the next section and that is converting our surfaces so let me go to the surfaces right now we have imported three different surfaces we have our sky we have our ground and we have our snail and right now all of them used to be png files and this is fine for basic setup however ideally we would like to convert all of them into something pygam can work with more easily and this we can do very easily all we have to do is to add the line.convert after we are importing an image and this i do want to do for all of the imported images and all this really does is it converts the image to something pi game can work with more easily so our game is going to run faster that's really all that's going to happen here but now if i run this we're going to see something strange so now our snail is going to look well slightly weird and the problem here is that we didn't respect the alpha values so this is all the white and black stuff behind the snail and to get rid of that all we have to do is change convert to convert alpha and that way we are removing the alpha values enough around this now we can see our snail properly and you can't really see a difference however now our game should be running faster at least in theory and especially once we have more stuff on the screen this might become important although in our case it really shouldn't make that much of a difference but it's generally good practice so don't forget to add this line every time you import an image so with that i do want to start working on the player character however there's one more really important concept we have to cover to really make the player character work and that is called a rectangle and rectangles in pygame essentially have two different functions at least in the most basic sense they can do quite a few more things but the two core functions of rectangles are this number one is that they're helping you place a surface much more efficiently and much more precisely and number two rectangles are going to help you detect collisions something we are going to see very soon but for now i do want to focus on using rectangles to place a surface on the screen so let me explain what we are going to do right now when we place the snail we couldn't really place it precisely because we can only ever place the top left which made it very difficult to place the bottom of the snail right on the ground so ideally we would like to grab a point on the bottom of the snail and place that point which we couldn't do with surfaces by themselves but something we could do with rectangles and this is something that you see all the time in pygame that you separate placing images in two different steps the actual image information is placed on the surface but then the position information is placed in a rectangle so essentially you are splitting your image into two different variables that you then have to control together and much later on in this tutorial we are going to see the sprite class and this one combines these two so you can work with them more efficiently so then how does a rectangle work well a rectangle is a well rectangle but this rectangle has a couple of points that we can work with we can either get points that are a tuple so they have an x in the y position or we can have points that are individual positions like left and right you can see all of them on the screen right now and we can grab each of these points and either measure or move them and if we move any individual point on a rectangle we move all the other points as well so the points always stay relative to each other and then we can use a rectangle to place a surface right in the middle of the rectangle so a rectangle we could place for example in the top left or in the center on the bottom mid or on the mid right we could literally place all of these points and then we can use that information to place the surface right into this rectangle and that way we are going to have much more control over how our surface is going to be placed and later on we can also use that rectangle to detect collisions but that's coming later for now let's just use a rectangle to place a surface so here i'm back in the code and the first thing i would like to do is to import the surface of the player so let's call this for now player surface and this again we just have to go with pygame.image.load and here the path is in graphics and for this one the path is graphics player player walk1 so again we have multiple images that we are later going to use for animation but for now we're just going to use one and this again i want to use with convert alpha so it's going to run slightly faster and let's just put this on the screen so we can see it so i want to use screen dot blit again i want to place my player surface and for now let's place it let's say 80 pixels from the left and 200 pixels from the top and now let's see how it looks now we can see our player and here you can already tell that there's a distance between the bottom of the player and the ground so this area here we want to bridge but the problem is that well we don't really know how big this area here has to be so placing just the top left of the player is very difficult and to fix that we are going to use a rectangle so step number one for this is we have to create a rectangle and there are different ways to do that so for now let's just call it the player rectangle and in the most basic sense you could create a rectangle by using pygame.rect and in here you could specify a left a top the width and the height and then this would create a rectangle however this is not something you see all that often actually because ideally you want to have a rectangle that is the exact same size as this surface and this we can create all we're going to need is our player surface so player surface and then the method get rekt so all that this get rekt does is it takes a surface and then it draws a rectangle around it and then for this rectangle we can specify a specific position where we want to place it so in here we could for example use top left and then give it an x and a y position so here for example i could copy the information from down here and just place it in there and let's just start with that so let me copy all of this and now we have a rectangle that is in the same position as our surface used to be and now when we use blit we can use a rectangle to place this surface so all i have to do in here is insert player right so now essentially what we are doing we are taking a player surface and we're placing it in the position of this rectangle so now if i run this we can see no real difference because the rectangle is in the same position where the surface used to be but what we can do for example now use a different position on this rectangle for example we could use mid left instead of top left and now if we run this our player is slightly higher or we could also use mid bottom and now our player is again in another position and really what you have to understand about this is that we are placing this point here right at the bottom of the player whereas for surface we always grab this point up here so let me draw a rough rectangle around it so for surface we always place this point but for a rectangle we can grab any of these points around it there are lots of points we can grab and that way we can have much more control over what point we want to place so this is super useful and now we can use that to place the player right on the ground and we know where the bottom of the player has to be because we know the ground is at position 300 so that's when the ground starts so the bottom of our player has to be on this position as well so let's say for the mid bottom i want to go with 300 and now let's run this and now we can see our player is touching the bottom perfectly and here again you might be wondering that this setup is kind of tedious and time consuming so that whenever we want to place a surface and have any control over how it's going to be placed we always have to create two variables first a surface and then a rectangle and i agree it is quite cumbersome and later on in this tutorial we are going to see a sprite class and a sprite class essentially combines a surface and a rectangle and places them in one class and this makes it much easier to work with them so later on we are going to make all of this much more streamlined but for now i do want to work with them separately so you understand them better so with that we have our player rectangle and now what we can do with this player rectangle we could move every single point of this rectangle and then use that to control the surface so for example what i could be doing right in our game loop i want my player rectangle and i want to grab any individual point from it so for example i could get the left of the player and this i could either measure or move so really what i could do here for example is just move this to the right so add plus one to it and now if i run this we can see our player moving to the right so this is how you would actually move something in pygame that you don't move the surface instead you move the rectangle that contains the surface but what you can also do is you can print this information so i just want to print it and now you can see that the left of our players are position 48 so we know that this line here is 48 which can be really useful to measure different things so this is stuff that is going to be really useful but for now i don't really going to need it but something i do want to do and this could be a really good exercise for you as well is that i want you guys to update this snail that we don't just use the surface to move it instead i want you guys to place a rectangle around the snail and then influence that rectangle to move the snail so if you want to code long pause the video now and try this yourself all right let's try together now so my snail is this line here and this net exposition i don't need anymore instead i want to create a snail rectangle and let me use the surface line a bit more consistently so instead of writing surface i always write surf because it's a bit shorter and i really like to keep this a bit more consistent so faster surface i just write snail surf that makes it a bit easier to read i think but okay now to get this rectangle i want to get my snail surface again and call get wrecked on it and now again in here i have to specify a position where i want to place this rectangle and here again i could use mid bottom again but just to mix things up a bit i could use the bottom right for example although in this case it really doesn't make much of a difference and where i used to place this was at position 600 and now for the height i want to go with 300 so again the important coordinates that we have to worry about is this ground here this is where our snail has to be on top so when we specify the bottom of our snail it has to be the same position so just keep that in mind and now we just have to use that rectangle to place the snail and that happens on this line here so now instead of placing it in this one position i just want to use my snail rectangle and along with that we don't need all of this information anymore so let me get rid of it and instead i want to do all of this with a rectangle but let's first try if it works in the first place and there we go now we can see our snail right on the ground this already looks much more realistic but now i do want to move the snail and well for that all i need is my snail rectangle and then get one of the points that we want to move so here you can really pick any point you like let's say in my case i want to go with x and this i just want to move by minus equal let's say 4. and now if i run this we can see our snail moving again and now if you want to move the snail back to the right of the screen all i need is an if statement and get my snail wrecked again and here we want to measure if our snail leaves the screen so effectively what i want to know is when the right side of the snail is smaller than zero because then i know the snail has left the screen so what i want is to get the right side of the snail and check if this is smaller or equal to zero and if that is the case i want to get my snail wrecked again and now i want to place the left and this is supposed to be at position 800 because 800 is our right side of the screen it's that position up here and well with that line this snail should be working okay so let's try this now and we can see our snail moving to the left and now it reappears and this way we have much more control over the different points of our snail so this is super useful but this is essentially it when it comes to using rectangles to position surfaces it really is quite tedious especially early on but once you get used to this this is actually quite a powerful system but alright with that one we can learn about this second aspect of rectangles where they are really useful and that is collisions so what i want to do for this section is to get a collision between our snail and our player and this is actually super easily done with rectangles because all i really want to do is to check if there's a collision between the player and the snail or the rectangles that contain them and this can be done with the collide rect method which just checks if one rectangle is colliding with another rectangle that's really all that's happening here so let's jump right into our code and let's implement this so here i'm back in the code and all i want to do is go right to the bottom and in here i want to check if my player rack is colliding with the snail right and really all i have to do is to get my player rectangle and use collide rect and in there i have to place the other rectangle i want to check against so this would be my snail rectangle and this method returns either a zero or a one so if there's no collision we get a zero if there is a collision between these two rectangles we are going to get a one and that information we can then use in an if statement but first let me print the entire thing so just you can see what's actually happening here so now if we run this we can see lots of zeros but once the snail is colliding with the player we can see once then we go back to zeros then we go back two once all the way down here and this happens over and over again so we can tell that this here is returning one so this i can then use an if statement so in here you could write if this is equal to one but since python automatically converts a zero to false we don't really need that so this line here by itself is fine as well and well if that is the case let me just print collision just to see if it works and now if i run this we can see a collision once the snail is colliding with the player so we know this line here is working but there's one thing you really want to keep in mind here that this might trigger multiple times because right now when our snail is overlapping with the player pygame checks every single frame of the game if there's a collision or not so if we just had this line then this collision might trigger multiple times which if you have some kind of health system would be a big problem because later on we are going to end the game once there's a single collision but if you have a hard system or some kind of health bar you really want to make sure you only have a single collision and then you have some kind of invincibility frames something lots of games actually have but in our case this kind of collision system is fine and this would be then the basics of collision now there's a different kind of collision that you can use with rectangles and that's collide point and this is not something we are going to use too much but it is also quite important so i do want to talk about it and all that collide point really does is it checks if one point collides with a rectangle the name should kind of make sense here and this isn't something you are going to use too often however if you ever want to click with a mouse on something then collide point is incredibly important and this is kind of why i'm going to talk about it so in this section we are going to talk about collide point and using the mouse and pygame just as a small interlude we're not going to use it too much so let's go for both of these and let's first talk about politepoint we are basically calling this like collide right so we first need our rectangle and then calling this as a method but now as an argument into collide point we don't pass in a rectangle instead we have to pass in a tuple with an x and a y position and then pygame checks if this one position is inside of the rectangle or not and then it again is going to return something that we can use in an if statement so far so good but now how can we get individual points or rather how can we measure the mouse position and for that pi game has two different approaches we could either target the mouse with pygame.mouse or we could look in the event loop and check the events that check the mouse position those basically get you the same position but there are two different ways to approach it and well i'm going to demonstrate both so the first one is pygame.mouse and this one gives you lots of information about the mouse for example the position or what buttons are being pressed you could also set the position of the mouse or if the mouse is visible in the first place and if you check the documentation there is quite some more stuff you could be working with but in my case i am only going to work with get pressed and get position so get the mouse buttons pressed and get the position of the mouse now besides that approach you could also use the events so when we have the event loop in there you could also work with the mouse position but that was quite a bit of talk let me actually implement all of this so here we are back in the code but now what i want to do is to check if our mouse is also colliding with the player and just to make this a bit easier to see i'm going to comment this one out for just a second so we don't get too much at the same time so i again want to get my player rectangle and i want to get collide point and in here we have to pass in a tuple that has x and y positions so this is the point we want to measure if it is inside of the player rectangle and then again we can use this inside of an if statement and check and print if there's a collision now then the important question is how do we get this x and y position so let me put this inside of a new variable that i'm going to call mouse position and to get the x in the y of the most position all we need is pygame.mouse.getposs and this would give us an x and the y position that we can then use inside of this so what i want to do is to copy my mouse position and place it in here so now let me activate the mouse and now if i run the game now i can see my mouse and if i hover over the player with my mouse you can see collision so this one is already working quite well so really all we have done here is we have used this pygame.mouse and used getpost to get the position of the mouse this one should be quite straightforward now pygame.mouse has quite a few more methods that we can use and one would be get pressed so let me call this one if we are hovering over playerrec so pygame.mouse.get pressed and of course i do want to print all of that information and now we run the code again and you can again see my mouse i hover over the player and now you can see faults falls and faults and this is a boolean value for each of my mouse buttons so if i press any of the mouse buttons and let me scroll down a tiny bit here actually so now you can see all of my mouse buttons and if i press the left mouse button you can see true if i press the right mouse button you can see true on the final boolean statement and if i press the middle mouse button you can see true in the middle so this is basically which mouse button i am pressing so that way you could check if i am pressing different mouse buttons so that way you could check what the mouse position is and what buttons are being pressed so this would be one way to approach this now what we can also do in the event loop we can also access the mouse position so we want to check for a different kind of event and this would be if event dot type is equal to pygame dot mouse motion all in uppercase letters and this would give us the mouse position and this would only trigger if we move the mouse so if you don't move the mouse this is not going to give you anything but once you do have it you can print the event position so this would then give us also the mouse position and now let me run this code again now i can see my mouse again and now okay let me scroll down again now you can see wherever i move my mouse you can see the actual position so if you move to the top left you can kinda get closer to zero and zero and if i get to the bottom right you can see close to eight hundred and four hundred and well that way we can also get our mouse position so this would be another way to approach this now another thing that you could use in here is mouse button up and mouse button down so this would ever check if we are pressing the mouse button down or if we are releasing it so let me start with mouse button down and if that's the case i just want to print mouse down so now let me run this again and let me spell all of this correctly now this works and now whenever i click we get mouse down and now if we change this to mouse button up this is only going to be triggered once we release the mouse button so let me go with mouse up and if i run this now well you can't really see it but now i'm pressing the button and nothing happens only if i release the button we can see mouse up so this would be a good way to check if the button is pressed or released but this is basically all you have to know to use pygame with a mouse if you check the documentation there's quite a bit more about small details but this is the basic and the most important stuff and let's do one small exercise to finish this part off that i want you guys to use the event loop to check if the mouse is over the player rectangle and well pause the video now and see if you can figure this out let's try together now obviously i want to work in this line here and figure out how i can use that information to check if my mouse is over the player rectangle and well the first thing i need to get is the mouse position so i want to go with mouse motion and once i have that i can print the event position so this would be the first step to approach this and this is what we have seen earlier but now what you have to be aware of that this event position is also going to give us an x and a y position so this is something we can use in collide point with a rectangle so all we have to do in here is to check our layer rectangle and then use collide point with the event position and use this in an if statement and if that is the case i want to print let's call it collision and let me disable and comment out all of this down here so we don't get confused with that line so now in theory this should print a collision and let's try this and now we can indeed see collision all right and with that we would be having our mouse collision now for now i am going to comment all of those out but we will later on revisit them to implement a proper collision for our player and our obstacles but before that there's one more thing i would like to address and that's the score and right now the score or my game is not really centered in the middle of the window so this is something i would like to address and well this we can also use with rectangles quite easily but along with that i would also like to highlight another functionality of rectangles because rectangles can be used to draw images on the screen but let's talk about that after we have centered the score so we go step by step so let's get started by centering the score and this again could be a challenge for you so if you want to go long try this yourself right now all right so let's try to do it together and here we have our text surface and let me put this in like a separate paragraph and again i don't want surface as a whole word i just want surf i think that's a bit more readable so a bit further down we have our text surface here and actually i think a better way to call this would be score surface that's making more sense so let's call this score surface sorry about the renaming i should have really thought about this earlier but never mind so now we have our surface again and the first thing i want to do is to create a rectangle so i have score rect and this is going to be our score surface and i want to get get rekt and this score rectangle i want to be right in the center of the screen and roughly in the top of the screen with a little bit of an offset between the top of the window so the point i want to place is the center and in here again we need x and y and we know our entire window is 800 pixels wide so half of that is going to be 400 and i think the original offset of 50 so the value we have specified down here should still be fine so all i'm going to do is to place this 50 in here and we're good to go so all i need is 50 and then i want to get this score rectangle and place it in the score surface and now if i run this we can see my game right in the middle of the screen so this is working quite well so far we have used rectangles for two different purposes we have used them for positioning and for collisions but there is a third one that you also see fairly regularly although not as often as the first two and that is you can use rectangles to draw or at least rectangles are part of the drawing module you can use other tools to draw as well so let me explain within pygame there's a sub module called draw and in draw you could for example pass in a rectangle and then you would be drawing this rectangle you could also be passing in a rectangle and then you would draw a circle inside the boundary box of that rectangle but you don't necessarily have to use a rectangle you could also draw a line from one point to another where you would just specify two points you wouldn't need a rectangle for that and this is also quite a useful thing to work with so how i want to illustrate this is i am going to give our score some background color so it looks a little bit nicer oh yeah and along with that we are also going to talk about colors after that but step by step so the first thing i want to do is i want to draw this score rectangle and well all i have to do for that is in the line before that i have to call pygame.draw.rect and all that's happening here is the first help again we want to draw a certain thing with the draw module and then we want to specify what kind of shape we are drawing in this case it's going to be a rectangle but if you look at the documentation there are quite a few more shapes that you could be drawing for example a polygon or an ellipse but in my case i will just draw a rectangle and in here we have to specify three different arguments we first need the surface we want to drawn so our display surface in this case then we need a color and then the actual rectangle we want to draw so in my case this is actually quite easy so i want to start with the screen itself that's our display surface then i'm going to need a color and for now we are just going to use the default colors so let's go with pink it's going to look terrible but that doesn't matter for now and then i want to draw the actual rectangle so score rectangle and now if i run out of this we can see a pink background that doesn't actually look all that bad and in here well you can see that the background covers the text just about there's no margin whatsoever and that isn't great and well you can work with that quite a bit more so if you go to the documentation there are quite a few more arguments that you could be passing into this the one you are probably going to see the most are width and border radius so let's specify both of those just to see how they look like so argument number four that you could pass in here but don't have to repeat with and let's just pass in is six for now and let's just see what happens and now we can see something probably slightly weird that we only get the surrounding we don't get the actual rectangle itself anymore so this is something you should be aware of when you work with this that once you specify a line width pi game stops drawing the center of the rectangle so this is a little bit annoying but now i can also specify another argument and this would be the border radius so let me put it 20 in here and now we have quite a bit of rounding but in my case i don't want to have any border rounding i just want to keep the border with so now how could you draw a rectangle that both has a border width and a center that's colored and well all you really have to do is to copy this line and then add one without a width and one with one so now if i run this we can see that we have a bit more of a margin around the text and let me change this to a 10 and now let's try this again and this is looking marginally better not great but i would say good enough so this is something you could work with to draw different kind of shapes and let's just play around with this and this could be a really good exercise so i want you guys to look at the documentation and just draw a line from the top left of the screen to the bottom right of the screen so check out the documentation and see if you can figure this out yourself right welcome back so right now here's the documentation and in there we have two methods that can be used with us we have pygm.draw.line and pygm.draw.antialias line or aa line and those two basically do the same thing except one line is antialias the other one isn't and those two for the most part are going to be identical so i'm just going to work with line and if we look at this one in more detail this one is going to need five different arguments we have a surface a color a start position and end position and a width so that's really all we need and well let's implement that so here i'm back in the code and let me add a new line with pygm.draw.line and in here we are going to need five different arguments so the first one is this green or what surface we want to draw on then we need a color for now let's go with gold and then we are going to need two points so the start point and the end point and both have to be two builds and since i want to start in the top left and end it in bottom right i have to start with zero and zero so the top left and the bottom right is 800 and 400 and now i have to specify a width so let's go with 10 but you could leave out this argument but let's specify it and if we run this we can see a line going from the top left to the bottom right and even better what you could for example be doing in here is replace this with pygame dot mouse dot get pause and now what you would get is a line that always follows the mouse which is kind of cool i think but we don't really need it so let me get rid of it and let's do one more that i just want to draw a circle and this would be an ellipse and for the ellipse we would again need the surface to drawn now we need a color let's go with brown and this rectangle is going to be the bounding box for the surface and really what we can do in here is generate this surface on the fly and we could do one of the rectangles we have created earlier although what i also want to cover is that we haven't created a rectangle from scratch yet which can also be useful sometimes so what i want to do in here is pygame.rect so we are creating a rectangle right inside of the method and this is going to need four arguments we need the left argument the top the width and the height so let's place this i don't know 50 pixels from the left let's say 200 pixels from the top i want this to be a hundred pixels wide and 100 pixels high and now let's run this and now we are getting a circle or well an ellipse with an equal width and height but that doesn't really matter but we do have a problem right now that the colors don't really match up so when i open this again the black text and the pink background just don't look very good and the problem here is that for now we always rely on the predefined colors which can be okay for starting point but don't look too great so how could we specify more specific colors and there are two ways to specify colors in pygame and this also applies to basically any other program and they're called rgb colors and hexadecimal colors and they do essentially the same thing so let me start with rgb colors all that rgb stands for is red green and blue that's really all it means and all we are doing here is that we are specifying how much of each color we would like to have and then pie game mixes all of them together and we are getting one customized color out of that that's really all we are doing and for each color you can choose between 0 and 255 with 0 being the absence of the color and 255 being the full color so for an rgb value we would specify a tuple with three different values one with the amount of red one with the amount of green and one with the amount of blue and for example if you had an rgb tuple with 255 0 and 0 you would have a plain red color because we would have only red and no green or blue and now for hexadecimal colors we are basically doing the same thing we just write it down in a slightly different way so we don't have a tuple anymore instead we have the hash symbol followed by six numbers and the first two numbers are for the red color the third and the fourth number are for the green color and the final two are for the blue color and then for each of these two we can specify the amount of each color we want to have and with that you basically have the same outcome as rgb now how you count how much of each color you have for this is slightly weird because the lowest possible value is 0 and 0 and the highest possible one is f and f so the counting here is slightly different if you want to read more on this i put a link in the description but essentially you are never going to create your own code instead you would use something like photoshop or some kind of website to create a color for you nobody ever really reads these things by themselves they're not really made for that so with that we have some colors let's actually implement them and there are two colors that we are going to need one is the color for the text and the other is the color for the box behind it and i'm going to use an rgb color for the text and a hexadecimal color for the box just to show you how both are going to look like and here are the two colors i am going to use so you can see what they look like so let's implement all of this so here i am back in the code and if i run out of this we can still see our pink box with the black text and let's start working on the text itself and to change the color of the text we have to work up here and we have to update the text when we create the surface and right now we are just creating a black text inside of a surface and i'm going to get rid of that and instead replace it with an rgb tuple and this one is going to have 64 for all three colors so we have 64 for red 64 for green and 64 for blue which gives us a fairly darkish gray so this would then be the text and that's really all we had to do now if i run this again now our text is looking slightly more grayed out it still doesn't look all too good because the background is pink so let's work on that one and for that i have to scroll down a little bit and now i want to change this pink here to a different kind of color and this happens with a hexadecimal string although you could also use an rgb string and in my case i have a string that looks like this and really important here do not forget the hashtag in the beginning that one is super important if you don't include that one it's not going to work but this is well it's a bluish color let me run the code and now you can see that this color of the text box is the same color as the background so this is i think the best kind of color for this and here again if you want to choose your own colors either for rgb or for hexadecimal there are loads of programs that you can be using for example in photoshop you can see both the rgb and the hexadecimal color but alright so with that we have the different colors next up i want to start working on the player and this is going to involve a couple of different steps number one is i want keyboard input and well most games are used with a keyboard so this one should be quite straightforward but what i essentially want to achieve is that if the player presses space our player is going to jump so we have to implement a jump mechanic but to implement that we are also going to need gravity so those two things are going together that you can both jump and fall at the same time but once we have that there's one more thing that we do need and that is some kind of floor because if we can jump and fall down if we don't continuously jump our player would eventually fall into nothingness so this is then the third one we have to implement and these are three things that are kind of independent of each other so i go for them step by step and let's start with keyboard input because this should be the simplest one by now because we have already seen something similar with mouse input and keyboard input isn't all that different from that and here again we have two different ways of getting input we could either get all of the keyboard inputs with a specific method or we could use the event loop and well there isn't really all that much to talk about let's actually go straight into the code and let's implement all of this and then we are going to look at both kinds of inputs so here i'm back in the code and it is already taking shape quite a bit but now what i want to do is to get all the keyboard input and let's start with the first one that we want to use the sub module called keys and to access that we need pygame dot key and in there we have a method called get underscore pressed this one is going to return an object that contains all the buttons and their current state so if they are being pressed or not and well let's just print the entire thing and see what's going to happen and right now you can see a ton of different zeros and each of these zeros is going to stand for one button with zero meaning the button is not pressed and the one meaning the button is pressed so this is very similar compared to the mouse and that information we can use to well access the button and see if it's pressed or not and how you would usually do that let me stop all of this is you would use this kind of like a dictionary that you would first store it in a variable let's say in my case i'm going to call it keys and then you can use keyword arguments to find specific buttons inside of this object so what we could for example do is look for one specific button and if you look online in the documentation you can find all the constants that represent specific keys there's quite a long list of different things you can do the one i want to look for is called pygame dot k space which stands for the space button and this one is going to return either a 0 or 1 and that information we can again use an if statement so if that is the case let's say i want to print jump and now let's run this and let me press space and here again we can see jump so this is working pretty well so this would be one way to access all the different keys that you can have but again this we don't really want to do right now so let me comment it out and let's look at the other way because you can achieve the same thing in the event loop as well so in here and let's work on that actually and in here you have a little bit more control over what you do with the keyboard because in here you wouldn't just check for what button was being pressed instead you would go for a twostep process number one is you would first check if any button was pressed in the first place and only then would you check the specific button that was pressed and then you can do the same way with a button being released this is again kind of similar compared to what we have done with a mouse click but all right let's implement it here so i want to look for an event dot type that is equal to pie game dot key down and if that is the case for now let's just print key down and just to illustrate what we can also do we can print key up so this would be releasing the key and then we can print key up and now let me run all of this our game is still working and now let me just press a button and we can see key down on the bottom of the window and i keep the button pressed for now and this is why you can't see key up but now if i release the button now i can see key up so this way we can separate if the button is being pressed or released which can be quite useful in some instances so this would then be one way to check if a button was pressed in the first place what if i want to check for a specific key here well all we would have to do is look for the event key and this would compare with the same keyword arguments that we have seen down here so here again we could use pygame.kspace and if that is the case no i want to print let's call it jump again and now if i press space we can see jump and also key up so this one is working super well and well with that you basically have all the different ways that a player could enter information into the game so you have seen different ways to work with the mouse and also with the keyboard now and you can do this either in the event loop or you could do this inside of the game itself and now i guess there's one question that's been looming over input so far that why do you have two different methods in the first place why do you need that and the answer here is actually quite obvious that later on we are going to learn about classes that are ideally selfcontained and this would also include input methods and for that it is super useful to have input that we can work separately from the event loop but for most of the time the event loop should be the good way to go because then we have all of our input nicely organized in one place so it's easy to work with but again this is something you are going to understand later on once you actually work with it so for now just don't worry about it too much so now we have all the input we need and i don't think there's too much we need to practice with this so let's go straight to the next part and that is that i want to give our player the ability to jump and also to fall so what do we need for that and well the first thing that we are going to need is some kind of gravity because well our player needs to be able to fall and here's a slight problem that we are going to have that in reality gravity isn't a linear function instead it's exponential which basically means that the more you fall the faster you fall and if that doesn't happen falling is going to look really weird it looks like we're in space so we have to create some kind of method that looks like our player is going to fall in an exponential speed which is kind of annoying to do so we are only going to imitate that we're not going to replicate it although it's something you could be doing but essentially all we're going to do is we're going to separate this process into two different parts where number one we're going to create a variable that has a gravity and this gravity is going to increase so it's just the number for now that just increases constantly and then we're going to add this number to move our player downwards and since our gravity is getting larger and larger it looks like our player is falling at a faster and faster speed it's not exponential but it starts to look quite a lot like it and especially since we are not falling that far this is not something that a player would notice and this is something you see really often in video games that game developers just don't really care about physics as long as it looks and feels good if it's actually physically accurate nobody really cares but alright that was again lots of talk let's actually implement all of this so here we are back in the code and the first thing i want to do is to create some kind of variable that tracks gravity and this let me put it right below the player so let's call this player gravity and by default this is going to be zero but now what's going to happen in our game loop and let me separate the player a little bit and let's add a comment here so we know we're always working with the player that should organize our code a little bit better at least so before we are drawing our player i want to increase the gravity by one so player gravity plus equal one so on every single cycle of the game loop we are going to increase our gravity by a bit but right now this isn't going to do anything because this player gravity and this player rectangle are well they're not connected so they don't influence each other whatsoever and well let's change that so what i want to do is this increase in gravity i want to use that to move the player downwards and this could actually be a really good exercise for you guys so i want you guys to use this player gravity to move the player downwards continuously so pause the video now if you want to code along and implement this yourself all we have to do is to get our player rectangle and then target one of the vertical attributes doesn't really matter which one in my case i'm just going to go with y and here all we have to do is to plus equal this with player gravity and now let's try this and now we can see our player falling downwards obviously this isn't going to look too great because our player just disappears immediately but let me explain what's happening here that at the beginning our player gravity is zero and then we add plus equals one to it so we will get one out of it and this is then what we would add to our player gravity so then our player gravity would be 301 but on the next cycle of the loop let me use a different color for that we would start with one already and we would add one towards it so now we will get to two and now if we add this to the player gravity we would get 303 so we have an increase in speed in terms of how fast we are falling down and this is going to look very much like our player is falling in real world gravity and this to our primitive brains looks like the player is falling at the natural speed although it's not real gravity so with that we have to find a counter measure that our player has to jump upwards and this is also something we can implement quite easily because right now this player gravity is moving our player downwards because it's positive but if this number were to become negative our player would move upwards and let me actually demonstrate this so when i set this player gravity right now 0 but i could set this to minus 20. another on the code we can see we have one jump because we initially move the player upwards but then we're moving it downwards at an increasing speed and this we don't want to do when we create a player gravity we only want to do when we are pressing a button so in here we want to do it and well this is then all we have to do so we have to get our player gravity and set this to negative 20. and let me get rid of key up because we are really not going to need it and now if i try this again i can see if i keep on pressing space we have a jumping player still not particularly realistic but we are definitely getting there so with that we have gravity and the ability to jump and actually on that note i also want to reactivate this mouse motion to click on the player so what i want to do in here is if the player is clicking on the player i want the player to jump as well and this could again be a good exercise for you that just implement some kind of system that if the user clicks on the player then the player jumps as well so pause the video now and try this yourself so to fix this kind of problem we have a couple of different ways to go for example we could check our most position and then check if there is a collision and we are pressing the mouse button or we could check if we are pressing the mouse button and then there is a collision and that's basically the same result in my case i first check if the mouse button was pressed in the first case and then i checked for a collision and the different approaches here really aren't going to make a big difference although they might make a small difference and keep that in mind that if we first check for mouse button press and then we check a collision is more efficient at checking for a collision and then for a mouse button press because checking for a mouse button is much easier than checking a collision and it's not going to make much of a difference but if you have 20 or 30 of these small differences they might actually add up to a faster game so just keep that in mind for actual games that you always want to have the most efficient way to run your game which can make a difference but alright let's actually implement all of this so here i'm back in the code and i first want to check for mouse button press so this is mouse button down so we check if any mouse button was being pressed and i'm not going to care which mouse button so any mouse button is fine and then i actually already have all the code we are going to need so if if player collide point event pause this still works because the event position we can always check and well if that's the case let me put it on the next line i just want to copy this code here and then add it in there and let me actually try if this is going to work this is going to be slightly difficult to do and yeah now if i click on the player we can indeed see that the player is jumping if i click on it although it's much harder to do than just pressing space alright this is indeed working so with that we have some kind of gravity and a proper jump mechanic and there's one more thing i do want to do and that is to get rid of all of this stuff down here because we are not going to use any of those for a while and i want to keep my code clean so all right with that we have quite a bit of progress now there's one more thing i do want to achieve that i want to create some kind of ground for the player and here you might be tempted to do something very inefficiently that you might want to check the collision between the ground and the player and anytime the player is colliding with the ground we want to move the player up and this would be possible but it also wouldn't be a good solution for the simple reason that is complete overkill that we don't really have to check for collision with the ground because we effectively only need one point and that is the point 300 on the yaxis and if the player is going below that we want to move the player on top of it so effectively we don't want to check a collision we just want to check if the player is on that point so here we are only going to simulate a collision there's no actual collision all we really are going to do is if the player is below 300 we are going to put the player at position 300 and that way it's going to look like the player is standing but in reality it really isn't the case so here back in the code i want to add one more line before we draw the player and that is if player rect dot bottom so we check the bottom of the player is greater or equal than 300 so this position here and this is why i've chosen 300 that the top of the ground and the bottom of the player once those two are identical of the players overlapping with the ground if that is the case i want to get my player rectangle and the bottom of it and set this to 300. so every time our players exceed in the ground we are going to set the player on top of the ground and well that's all we have to do so now our player is going to stand and if i jump we are falling down and well the player is still standing on the ground so now it looks like there's a collision with the ground on the player but in reality there really isn't and again this is a common thing for video games that you just simulate something that looks realistic to us but well we're not really creating the real thing because that would be really difficult to do so all right with that we are almost done there's one more thing that we have to address and that is let me run the game again now if i keep on pressing space while we are in the air our player keeps on jumping so effectively we are flying and well this i want to get rid of and this we can do quite easily all we have to do is in these two lines we have to add one more condition that we are only able to jump if we are touching the floor and this again could be a small exercise for you so again if you want to code along try to figure this out yourself that how can we check if the player is touching the ground right so all we really have to do in here is to check if our player rectangle and the bottom of it is greater or equal to 300. effectively the same condition we have used down here and well that's literally it and don't forget an end between the two so it works and this we have to do for both of these if statements you could also put all of this inside of an if statement it really doesn't matter but now let me run all of this again and now i keep on pressing space but the player is only going to jump if we actually touching the floor so this is then getting much closer to an actual game and in here i can almost try to play the game where we are well having almost a game nothing really happens yet if our player touches the snail but that comes next so let's talk about that part that i want to end our game if our player touches one of the snails and well we already have the collision mechanics so this is something we can already implement and let's actually do this right now so here i'm back in the code and again somewhere in our game loop i want to implement a function that ends the game if our player touches the snail and let me add a comment first so we have collisions here and all i want to check for now is if our snail rectangle is collide wrecked with the player rectangle and this has to be an if statement of course and if that is the case for now i just want to end the game so i just copy those two lines and if this is working then our game should just end if these two collide so let's run all of this and we can see our game is ending once the player is touching the snail so this would kind of work and we would actually have a game at this point obviously not a very good game but this is kind of working but instead i want to do something slightly different that i have two states in my game one is the actual game we have already seen but then i want to have some kind of start screen so that if the player is colliding with an object we are coming to an overview screen where the player can see the score and press a button to start again so for that we have to figure out how can we have different states in our game and well the answer here is actually surprisingly simple that right now in our game loop we are drawing and checking certain things and all we really have to do is to put all of this inside of an if statement so for example if our game is active we want to draw all the stuff we have seen so far however once we are colliding we are setting this game active to false and then we have an else statement that draws something else that's literally all we have to do now obviously this is a very simple setup and not particularly good for really complex games but it is the basic logic you have to understand to basically create any kind of multilevel system so let's start by implementing that one so here i'm back in the code and right at the top because it's an important variable i want to create game active and this by default for now is going to be true and then further down all of the stuff we have drawn so far so literally all of this bit here we only want to do if our game is active and actually if i go further up this part here as well i only really want to do if our game is active although that we are going to work on later for now i just want to put all of this here into an if statement so i'm going to indent all of it and add an if statement so if our game is active then i want to do all of this and since this game active right now is true i can run the game and we have the same outcome cool so this is still working but now what i can do is if i was nervous colliding with the player i want to set my game active to false and now if i run this and our player is colliding with this nail well nothing is going to happen anymore our game stops for the simple reason that we don't update any of this anymore but we don't draw anything on top of it so all we can really see is the last frame of this game loop but now what we could for example do is add an else statement in here and let's say for now i just want to screen dot fill and let's add yellow just to see what happens so now i use the game and now we have yellow and then here we could literally add any kind of code we want so this could be much more extensive and we are going to add quite a bit on this later on but for now this would be pretty good way to separate our game that all of this code here is going to be our actual game or the game part of our game and all the stuff down here is going to be some kind of intro or menu screen and that way we can separate our game into logical parts that are also going to be easier to work with and well with that the one thing we have left to do for this part is to set up some kind of way to restart our game and well all really have to do for that is if our game active is false we have to check for some kind of player input and if that's the case we're going to restart the game and this is then going to bring us up here that right now we only want to check all of this if our game is active and then we want to do something else down here if the game is not active anymore and this could be a good challenge for you that if game active is false and we're pressing the space button we want to restart the game try to implement this yourself and see how far you get the first thing we have to do just like with our main code we want to put all of this inside of an if statement that if game active we are checking all of this and what we can do now is add an else statement in here and i just want to check if we are pressing the space button so let me copy this line here so right now we're checking if our key is down and we could also put these two lines here on the same line just to save some space and let me do that now so i want to check if the event type is key down and the event key is case space and if that is the case i want to get my game active and set this to true again and well let's trial of this now that's kind of all we needed so now our game stops and now i press space and okay this kind of almost worked that right now our game goes straight back because our snail if you can see it is overlapping with the player so now it stopped and now we can play again and i can jump over the snail this is actually working really well but now i collide it again and now we go to the game over state but a problem here is if i start the game again our player is still overlapping with the snail and hence the game stops after one frame so this is something we do have to work on but at least in theory for now this is working and actually what we could be doing is we can set our snail rectangle dot left to something like 800 just to make it work for now so now let's try this again so now we go to game over and now i can start again and we have a proper working game so at this point we actually have a really working game where you have a failed state where you have a challenge it's not a very good game but well it does work so for the rest of this tutorial it's basically all about making this more interesting and making our code better organized but you really have all the basics you need to create basic games so well done so far so for the next part let's start working on the score and all i really want to display here is the amount of time the player managed to stay alive so for this one we have to figure out how to measure time and for that we are going to need a new method and that one is called pygame.time.getticks and all this one is doing is it gives us the time since we started pygame in milliseconds and that is really all we are going to need to create our timer although the actual logic to implement all of this gets a little bit more complex but we get to that when we get to that so let's go into our code and let's have a look at this so here i'm in the code and right now we are creating our text right here so right now we are only displaying my game and it doesn't really do anything and further down in the game right here we are putting that text on the surface but obviously this doesn't really help us all that much so we have to make a couple of updates here and let me start by just commenting out all of this because we are going to make some changes and here's what we want to do we want to continuously update our score which means that in our game loop we have to continuously create a new score surface and put that on the screen so that every time we are creating a new frame we are also creating some new text and to keep our code a bit more organized i'm going to put all of this into its own function so here i'm back in the code and i want to create a new function and let's do it right at the top and let's call this one display score we are not going to need any arguments so let's go straight into the body and the first thing we are going to need is our current time and that we are going to achieve with pygame.time.getticks and this is going to give our time in milliseconds and let's actually for now just print it and see what's going to happen and let me actually put it into its own variables so you can work with it a bit easier let's call it current time so i just want to print my current time and now if i go down we are drawing all of our stuff in these three lines so what i want to do with them is to just comment them out for now and now let's run this and now we can see that we have a time that continuously updates at least as long as our game is active and that is our time so we can see that our game roughly ended two seconds after it started and that is information we can use very well so let me close all of this and let me go back to the top so that's the information that we want to use and all we really have to do is to put this on a new surface and put that surface on the display surface so let's create a new variable that i call score surface and for this one we are going to need our test font and render again and in here for now all i really want to display is our current time then i needed two hour arguments which is false for antialiasing and then i'm going to need the color which was 64 64 and 64. so now we have a new surface now with that we have to create a score rectangle and this one is just going to be our score surface with get rekt and in here the center is going to be 450 the same position we had earlier and now the final step we have to go with is screen dot blit and we want our score surface and our score rectangle and then i can get rid of our print statement and we should be good to go at least in the most basic sense and we are getting an error because this right now is an integer and this function here wants to have a string so we can approach this in a couple of ways in my case i'm going to put this into an f string so that way it's going to be converted to a string anyway and now let me run all of this and you can see a score and if i keep on running the game this is still working however here's one problem right now the game ended but now if i restart it the score has continued to increase which obviously doesn't work too well and here it's really important to understand what get ticks does and what it does is it gives us the time since pygame started or more specifically since we called pygame.init but obviously in our current setup this causes a problem because we only check the current time we don't really adjust this for restarting the game which is what's causing the problem here so how can we adjust for this and well the answer here is kind of simple all we really have to do is when we are restarting the game we are taking the time when the game is restarting and then when we are calculating our score we are always subtracting that beginning time from our actual score and that way we are always starting from zero and going from there so let's implement that and the first thing i want to do is to create a new variable that i'm going to call start time and by default this one is going to be 0. and now essentially what i want to do is when i'm getting this number i want to subtract my start time from it so i'm going to subtract my start time from it now right now this really isn't going to do much because we just subtract 0 from this number but now what i can do if i scroll down a bit in this bit here i am checking for keyboard input to restart the game and what i want to do in here once this is activated i want to set my start time to pygame dot time thought get ticks and that in the most basic sense is all we needed so let's try this now so a game still works properly well now i failed and let's try it again now and again we start from zero it's very hard to see because our counter starts too fast but it does work and let's try it again let's restart and this is still working pretty well so this is actually working really well cool and let me just go through what happens here now every time we are looking for our current time we are checking in this bit here our current time since the beginning of our game so since this line here has run however from that number we are going to subtract the start time so when the current iteration of our game has started so that way every time the player starts the actual game part of our game we are going to have a zero for our score and then we're adding towards that score which is then giving us a proper scoring system now there's one more problem that right now if i run it again i think the score adds up a bit too fast and it's very hard to read so i don't really want that high of a number i want this to look more like one two three and four and so on and that could actually be a really good exercise for you try to change our current time in such a way that you get more manageable numbers now for this exercise i think it was very easy to overthink the problem which is a common issue in programming so let me explain my approach essentially this pygame.gettix gives us the milliseconds so if we add second one we would have a number of 1000. now this number i want to get to look like a one and really all we have to do for that is to subtract this thing by one thousand and that literally is all we had to do in here so what i want to do is to subtract this number by 1000 and let's put it into brackets just to be a bit more clear and what you can also do to avoid floating point numbers is to set this to an integer so this way this number here would always become a zero or one or two and that is then the number we want to go for now there's one important thing you have to be aware of that let me copy it that right now when we set our start time this has to look the same actually let me demonstrate what happens if we don't do it so let me run the game now we get 0 1 and this is working really well but now i failed let's start again and now we get negative 5000 so this is well kind of weird and the reason for it is that this number here returns numbers in the thousands this one here returns numbers from 0 to 10 basically so that's something to keep in mind but alright so if i add this in here now our game should be running pretty well and the score is updating properly and if our game ends and i start again we start again with zero so this is working quite well and i think i have to increase the speed of the snails that's a bit annoying but okay i'm gonna work on that in a bit there's one more thing i would like to add and that i want to actually call this score just to be a bit more clear so now if i run this again you can see score at the top but let's well it's up to you if you want to add it now next up i think the next big issue is that our game over screen looks kind of empty so i want to add a couple of things to make it look a bit nicer which is going to end up looking like this that we have our player in the middle we have the name of the game and we have a short line at the end that tells the player how to restart the game none of this is particularly fancy and you should already be able to do most of this although there's one more important concept i would like to add in here and that is how to transform surfaces so for example if you want to increase the size or rotate the surface that's what transform is all about and well pygame has a transform method and if you look in the documentation this part of pygame has lots of different methods that you can use for example you can rotate something you can scale some you can flip something you can do lots of different things with surfaces now in my case all i really want to do is to scale up our player to make it look a little bit nicer but all of the transfer methods work in basically the same way so let's actually jump into this so here i'm back in my code and let me minimize our display score first because we're not going to need it anymore now next up i want to create our game over screen in here and all of this our game so far we can ignore because we're not going to work on it so i am going to minimize all of this and let me also minimize the event loop so all of this is a bit easier to see and first of all i don't want this to be yellow anymore instead i'm going to add a tuple that is 94 129 and 162 and actually just to test all of this i'm going to set game active to false when we start our game so that way we go straight to the game over screen so let's run this and now you can see a much nicer color and again if i press space our game starts as always so this one is working pretty well cool and i guess with that we can add the player in the middle of the screen and for that i first want to import our player and let me do this right in the beginning so i already have my player variables and i want to create a new one here let's call this player stand and all we have to do in here is pygame.image.load as always and there's one file that is just called playerstand and i am going to import is like all the other ones and i'm going to convert alpha this as well and now on the next line i'm going to call this player stand a rectangle and this one is just going to be player stand and get rekt and then the center is going to be right in the middle of our screen so 400 and 200 and let me actually add some comments um i think that's a bit easier to see so let's call this intro screen now this is then what i want to display in the game over screen so all we have to do in here is to use screen dot blit and our player stand and our player stand rectangle so now let's try this and then we can see our little player this works pretty well so far so now i want to scale this one up and how would i do that and to scale something in py game we actually have a couple of different methods so if you open the documentation we have scale we have rotozoom we have scale to x and we have smooth scale and they all essentially do the same thing that they are changing the scale but they do it in slightly different ways and the result is going to look different depending on what method you are using but for now let's keep things simple so i just want to use pygame.transform.scale the simplest one i would say and if you open this one it tells you to add at very least two arguments the surface you want to scale up and then a new width and a new height both inside of a tuple and then this one is going to return a new surface and then you can use this surface like any normal surface so let's have a look at that now when i import our player stand i want to create a new player stand and just for clarity let's call this scaled and really all i want to do in here is to get my pie game transform and scale and now i am going to need a tuple with my wife and my height and unfortunately here right now i have no idea about the dimensions of our player um so let's go with random numbers let's say for the weft i want to go with 200 and for the height i want to go with 400 and well now for our player stand rect we also have to update this but all we have to do is to get a new variable so now i am simply updating this line here to get a rectangle around this new scaled surface instead of our player stand and besides that i also have to update the player stand down here to have this scaled one in there so let's do that as well so we want player stand scaled and now this should already be working so let's try it and there you can see our player is very obviously scaled up really doesn't look all that good so let's close this one but this would be one approach with scale although not a very good one and not the one i would recommend to use however before we are learning a better way to scale something there's one more update i want to make because right now this here doesn't feel like good code because we are creating more variables than we really need to so let me update this slightly before we get into the proper bit and really all we have to do is to get rid of this scaled and then again we want to get rid of this scale as well and this scale at the bottom here and uh well that's all we have to do so let me go for what happens here that's kind of important to understand we are starting number one by importing this image now on the next step so this number two here we are taking the image and then updating it with this pygame.transform.scale and this one is returning a new surface and we're using that new surface to overwrite the initial surface and that's perfectly fine to do that you take one surface you scale it and then you assign it to the variable that you originally used and then we are creating the rectangle in step number three and then in step number four you are drawing all of this so i hope that makes sense and this is something you see fairly often and also what you see fairly often is that you could just take all of this and paste it directly into the scale method and if i run this this would also still work although the downside of that is you would get one very long line that i think would be quite hard to read so i'm not going to do that and i think this is a fairly good middle ground between readability and efficiency of code so i'm going to go with that one however the problem now is that this scaling just doesn't look very good because it well it distorts the image a lot and there are two methods that would be better here the first one is called scale 2x and this one is a really simple scale method all it does is it takes a surface and makes it twice as large and this one works by just calling scale 2x and this one needs only one argument and that's the surface you want to scale so now let's have a look at this and now we can see a much better player but there's one more method that i do want to show you and that is called row to zoom and rotozoom is a more complex method because it does three different things that you have to be aware of number one it rotates the surface number two it scales the surface and number three it filters the surface and the filter here is intended to make the resulting surface a bit smoother so to make it look a bit better in some instances and to call rotozoom we are going to need three different arguments we need the surface the rotation and the scale so let me update this to row to zoom we are still going to need our player stand for angle for now i'm going to go with zero and then for the scaling let's go with two and that literally is all we needed so let's run this and now we can see a surface that looks very similar although if i compare these two images side by side you can tell some very slight differences and this is because of the filtering and i actually think this rotozoom looks the best so i am going to stick with this one and actually what you can also do with rotozoom you can change the angle so if i change this to for example 90 we would also get a rotated surface so this is a very easy way to both scale and rotate something and still have the resulting surface look quite good but i don't want to rotate it so this one is perfectly fine by itself so alright with that we have learned about the basics of influencing a surface now next up we do have to add a couple of lines of text so we do have to add the name of the game the score and the instructions to start the game and this could actually be a really good exercise for you that try to implement all of this yourself and see how far you get but at this point you know all the tools to make this work so here we are back in the code and i am going to go to our intro screen and in here i just want to create a new variable called game name and for this one we need our test font.render again and now we have to specify the name of our game and i just called this one pixelrunner but well give it whatever name you want then for ntl you're saying i want false and for the color i go with one one one one nine six and one six nine so with that we would have the surface of our text next up we would need our game name rectangle and this one is just going to be game name dot get wrecked and this i want to place at position 400 and 130 so in the middle of the screen slightly to the top and that is all we needed to get the name of the game so now in our game over loop we have to draw all of this so we just need screen dots blitz then game name and game name rectangle and now let's see and that is a little bit too far down so let me go up again and let's put this to let's go with 80. and that is looking much better all right so with that we have the name of the game in there everything else still works just the same cool and now i'm going to add a second bit of text and this one is going to pull double duty if there's no score it is just going to tell press space to run however if there is a score it just shows the score and to implement all of that all we really need is an if statement that cycles between two different text surfaces so let's start with the first text and this i called game message and this again we need to test font.render and test font really isn't a good name but i guess now we're stuck with it and this is press space to run then i want false again and now for the text color i just want to copy the text we had above so with that we have our surface and now i want my game message rectangle and this one again is going to be game message dot get wrecked and here once more i want to place the center and now in here i want to put it in the middle and no for the y position let's go with 320 let's see if that one is going to work and well now again we have to go with screen dot blit i called this game message and game message rect and let's see if this one is working and it does not let's see what went wrong here oh and the reason is that i have the wrong rectangle so this should be game message wrecked there we go this is much better and i think i could move this text slightly further down so let's go with 340. now this one is again and uh okay tiny bit higher so now the last thing that we have to do is to add some kind of if statement that we only show the text if there's no score and if there is a score we don't want to show the game message instead we want to show the score and for that we do have to make a couple of changes so let me go through them one by one and i think it's best to explain it first and then we get into it so right now we are keeping all of our score instead of the update score function which works fine by itself but we want to access the score to display it in our game over screen so we have to get the current time variable inside of the update score function and for that we could either create a global variable or we could return the value and both would be okay i'm going to go with the return statement but once we have that all we have to do is to put this current time on its own surface and then display it that's literally all we have to do so let's go back in the code and let's have a look at this so here i'm back in the code and right now the variable that we have to access is this current time here because that effectively is our score so how can we access this we could either go with global current time to make it accessible everywhere or what we could also do is after this function is run we can return current time and this is the one i'm going to go with because it's a bit more focused so now that we have that i can create another variable let's call it score and this by default is going to be zero however now every time our update or display score is going to run this score is going to get the value of whatever is being returned by this display score which is going to be our actual score so this way we can access the value of our score basically any time so now what we have to do in the game over screen we have to turn this into a surface and well this is going to work in exactly the same way as before so i create a new variable let's call it score message and this one again i want my test font.render and in this case i want to go with an f string that says your score and then we put our actual score in there then again we need false and for the color i am just going to copy this same one again and then after that you should know this by now really well we want to turn this into a rectangle or we want to put a rectangle around it rather so i want score message dot get rekt and for the center i'm going to go with 400 400 and 330 so now this is going to give us our score and now this score i only want to print when there actually is a score so when we are starting the game this isn't visible however as soon as we have a score all of this is going to replace this game message here and well to achieve all of that all we need is an if statement so if our score is equal to zero we know we don't have a score yet and then i want to display my game message and if that is not the case so else i want to go with screen dot blitz and score message and score message wrecked and well let's try so i can run the game we can still see our basic setup now let me run it now we get a score of 2 and there we can see it so now every time we have a score we can see it and this is looking really well then so i can also jump over snail or i can't and now we get a score of four so this one is indeed working very nice and let me just update them ever so slightly to put them on the same line because that feels better cool so all right with that we have all the text that we are going to need so with that let's work on another really important topic to make the game look better and that is to spawn different kinds of obstacles so right now we only ever have a snail and i want to mix this up a tiny bit that we have a chance to ever get a snail or a fly so the player has to make a choice between jumping or well not jumping and this is going to be a really good opportunity to work on something a bit more complex to spawn our enemies because right now this is a bit overly simplistic that we don't really spawn multiple enemies instead we have a snail we keep on moving from the right to the left and then we just place it back to the right and the problem here is that we have very little control for example we don't have control how fast the snail is moving and we also don't really have control over how often it's spawning so it's always the same interval which is kind of boring and to update it we are going to need one new concept and that is a timer so that we can tell pygame to run a certain kind of code in certain time intervals and this timer is going to be quite simple because all we really are going to do is to create a new user event that's triggered by pygame and so far all of our user events were something the player is doing but that doesn't necessarily have to be the case because a user event could also be triggered by pygame and a timer is one of those instances where we tell pygm to trigger a user event at certain intervals which is what a timer really is and there are three steps to doing all of this number one we have to create a custom user event number two we have to tell pygm to trigger this user event at a certain interval and then number three we have to add code in our event loop to do something when this event is being triggered but that is all we needed so let's actually implement this so here i am back in the code and let me add a new section with a comment let's call it timer and in here i want to have an obstacle timer and all we need to create a custom user event is pygame dot user event all in uppercase letters and here one important thing is to add plus one the reason for it is that there are some events that are already reserved for pygame itself and to avoid a conflict with those we always have to add plus one to each event we are going to add and if you want to read more on that there's quite a bit more in the documentation on this but by itself that's all we need here so this would be step number one that we have created a custom user event now what we have to do is to trigger this event in certain intervals and this happens with pygame.time.set underscore timer and this is going to need two different arguments number one the event we want to trigger and number two how often we want to trigger it in milliseconds so in my case i want to trigger my obstacle timer and i want to trigger this every 900 milliseconds so a bit shy of one second but with that we have a timer so now in my event loop i want to go all the way to the bottom and here we are going to add a new event so here if event dot type is equal to obstacle timer and if that is the case for now let's just say print test and now let's run it and we can see test just about every second so this one is already working pretty well so with that we have a timer and i guess one thing we can add already here that we only want to run this if our game is active because if it's not active we don't have to spawn an enemy so now let's trace again now we can't see anything and if i run the game we can see test every just about one second cool so now we have a timer but how can we use that timer to work with our obstacles and well here we have to make quite a few changes so let me explain this first and then we are going to implement it but before that let me go down a tiny bit i want to get rid of this snail movement we had so far because this one is not going to be needed anymore so let's talk about how all of this is going to work now first of all we have to create a list that is going to contain all the rectangles of the obstacles and every time our timer triggers we are going to add a new rectangle into this list and then on every single cycle of our game loop we are going to move every single rectangle inside of that list a little bit further left and if any of these rectangles goes too far to the left we are going to delete it and that way we can continuously create new enemies and move them to the left and if they get too far to the left we just make them disappear so ultimately a fairly simple idea so let's implement it so here i'm back in the code and right now we have all of our enemies in here or our one enemy right now and let me add a section here as well let's call it obstacles just to keep the code a bit more organized and all i want to do in here is to get an obstacle wrecked list and right now this is just going to be an empty list and now when we go to our timer so down here all i want to do is to get this obstacle racklist and append something new and what i want to append is the rectangle and this we already have so this is going to be this rectangle here so i can just copy it and paste it in here although we have to make one update that right now this 600 needs to be higher so it just snails outside of the screen and i want to have a value between 900 and 1100 and for that we are going to need a random number so let's import one so at the top i want from random import rand and this is just going to give us a random integer between two boundaries and that is exactly what i needed so now in here all i want is to get my rent int and this is supposed to be between 900 and 1100 so that way the snail is going to be spawned slightly to the right of the screen and then we are moving it further to the left so this is then going to give us our list but obviously right now nothing is going to move so to fix that we have to create a function that takes care of all of that and well let me put it somewhere in our game active loop and let's put it right after the player so let's call it here obstacle move mint it doesn't really matter where you put it just whatever makes the most sense to you and in here i want to create a new function that is called obstacle movement and in here i want to add one argument and that is the obstacle rack list so we know exactly what we are working with and well let's create this function so at the top of the code i want to create obstacle underscore movement and in there we need an obstacle list and now we have to work with this list however we first have to check if there's something in the list in the first place and that we can just do if obstacle list so this here is going to work because python if it finds an empty list is going to evaluate that to false so if our list is empty this if statement is not going to run but if it is going to run we want to cycle through all of our rectangles inside of that list so let's call it for obstacle rect in obstacle list and then we want to move with every single of these obstacles so obstacle rect let's call it dot x minus equal and now we have to define a certain kind of speed let's say i want to go with five and that way every single obstacle would be moved to the left by a tiny bit on every cycle of our game loop so this is exactly what we needed but right now obviously you can't see any of this so this is something i also want to put right inside of here although you could also place it in a separate function but in my case i'm going to be a little bit lazy but all i want to do here is screen dot blit and for now i just want to get my snail surface and then go with my obstacle rect so that way we are moving our rectangle and drawing the surface in the same position all in one go but right now we have a little bit of a problem that right now all the stuff inside of this function here is going to be a local variable and we want to make sure that we are targeting the global scope and really all we have to do to fix that is after we have done all of this we are returning a new list so the list we just created so return obstacle list and then in our game loop when we do all of this here i want to get my obstacle right list and overwrite it so let me explain what happens here we first run this function here and this is going to take our obstacle rack list and move every single rectangle inside of it a bit further to the left and after that's finished we are going to take this new list and overwrite the previous list and that way we can continuously update our list and not worry about scope in too much detail right so let's try all of this and we are getting an error and the reason for it is that python told us that nontype has no attribute append and you might already be able to figure out what went wrong here and let me explain basically if we run this in the beginning there's nothing inside of this obstacle list because our timer hasn't triggered yet and as a consequence this entire thing is going to return none and none doesn't have the append method so what we have to do if there's nothing inside of this list we have to else return an empty list that's not an empty list that's one and that way our append method should still work so now let's try this and let me run this and now we can see our snails obviously they're all way too fast right now or the collision doesn't work anyway but now you can already tell that some of these snails move slightly differently because we have changed the starting position so cool this is already working and i guess what we can do is that this 900 is probably a bit low let's go with a thousand four hundred let's try this now and let's see uh potentially still a little bit fast but i think this is kind of workable um okay let's go with 1500 so with that we have a slightly more robust system to work with our obstacles but there are a couple of problems with this and let me go through them one by one number one the one problem we have already seen is that our collisions do not work anymore so that's one thing we have to work on number two is right now when our obstacle leaves the screen we don't delete it so we are going to end up with a longer and longer obstacle rack list something we really want to avoid because it would eventually slow down our game and number three is we only have one type of enemy so that's also something we have to work on so let's start with number two that we want to delete a rectangle if the rectangle goes too far to the left and this we can do inside of our function so inside of this function we want to check if any of these rectangles is going too far to the left so if this number here goes to let's say lower than negative 100 and if that's the case we want to kill it and all of that we can achieve fairly easily with list comprehension so what i want to do is to get my obstacle list and assign it a new list already and this list comprehension is going to check all of our rectangles and then see if they're too far to the left so all we have to do in here is to go obstacle for obstacle in obstacle list so this right now would only copy the existing list so it wouldn't do all that much however what we can do now is we only want to copy an item if obstacle dot x is greater than zero so that way we are only going to copy an existing item in the list if x is greater than zero so that way we are only going to copy every single item of the list if the condition is true that the x attribute is greater than zero so if the obstacle is on the screen and if that is not the case we are not going to copy the item and the item is going to disappear and actually let me go with minus 100 so we know that the obstacle is off the screen for sure so this would already be the first problem we had to target that we wanted to delete the rectangles if they leave the screen so with that let's go to the next point that right now we only have one type of obstacle which really isn't looking all that good so instead i want to have two different kinds of obstacle and if you check out the folder there are two different types we have a snail and a fly and i want to randomly spawn either a snail or a fly and this isn't very difficult to achieve but it does need a couple of steps to work through it so let me explain it while i implement it i think that is going to be the best way to approach this so all right let me minimize the function we are not going to need it for a bit and instead in my rectangles i want to import a new variable and let's call this fly underscore surface and this is just going to be pygame dot image dot load and the path towards this fly is going to be graphics.fly.fly1 again we have several images to get an animation we are going to cover that very soon but next up i need convert alpha and that is all we needed oh and actually i just realized this snail rectangle we don't need anymore so all right now we have our fly surface and now we have to add this to our obstacle rack list so right now we always add the fly towards this and here we want to randomly assign either the snail or the fly however there is going to be a problem that the fly cannot be on the same y position so while the snail is on position 300 the fly has to be higher up because it's well flying so we can't just add a random statement in here but we can overcome this fairly easily because all we have to do is to run an if statement that randomly triggers either true or false and in my case i'm going to use rand in to do this so here we have rent in from 0 to 2 and this is going to give us a value that's either 0 or 1 and 0 would evaluate to false and 1 would evaluate to true so that way we have an if statement and randomly triggers true or false and if it is true i want to create a snail and if it's not true i want to create a fly so let me just copy this entire line here and now i want to get my fly surface and the x position for that is still perfectly fine but what i want to change is the y position because this one has to be high up and in my case i went with 210. so this way would be slightly higher up and now let's actually run this and see what's going to happen it's not going to work perfectly just yet oh and we're getting an error because this snail rect.left shouldn't be in there anymore now let's try this again and we are getting another error somewhere down here oh but we have the collision so this one should also go because we don't need it anymore and i hope now it's working there we go so now we can see a snail we can see another snail and now we can see a flying snail um i guess that also kind of works so the problem here now is that we always draw the surface of the snail on top of the screen and that would be a problem so let me go to the part in the code in our function that right now it doesn't really check in our function if we are drawing a fly or a snail we are always drawing our snail and this is something that we have to change so we have to figure out in this function if the obstacle rectangle is for a fly or for a snail and the problem here is that the rectangle by itself has no information if it belongs to a snail or to a fly it is literally just a rectangle of a size and a position but that information we can use because we know it at the bottom of the snail is at position 300 and the bottom of the fly is at position 210 so really all we are going to do in here is if the bottom of the rectangle is at position 300 we are going to draw a snail and if it is not the case we are going to draw a fly and that way we are going to draw only this surface that's appropriate so let me cut this out here for now and i want to get an if statement that if obstacle rect.bottom is equal to 300 and if that is the case i want to draw my snail and if that is not the case i want to draw my fly surface and i guess again i can put them all on one line that tends to make it look a bit cleaner and now let's try all of this again now we get a snail and now we get a fly cool so this is working pretty well oh yeah i don't actually have to jump it still works just fine and uh we are getting a lot of snails but we do get the odd fly eventually cool so let me remove a bit of the white space here and now we can close our function and never think about it again so with that we have different kinds of obstacles now the final thing i want to work on is a collision between the obstacles and the player and this i want to put in a whole new function because that i think is going to make the most sense but really all that we are going to do in here is we are going to check the player and the obstacle rack list and if the player is colliding with any of the rectangles inside of that obstacle rack list then we want to end our game and that is going to work in a very similar way compared to the obstacle movement function that we are just going to use a for loop to get every single rectangle inside of the list and then on every single rectangle we are going to call collide rect so let me start by creating a new function so let's call this collisions i guess that kind of works and in here i want to have two arguments first one is the player and then i want to have the obstacles and in here again i first want to check if there are obstacles in the first place so if obstacles very similar compared to what we have done earlier so let me actually open both functions so right now this one here is pretty much the same thing we have done up here now next up i want to cycle through every single rectangle inside of this list so for obstacle underscore act in obstacles and now i want to check if any of these obstacles is colliding with the player so if player dot collide rect with the obstacle rectangle and if that is the case i want to do a certain thing and now we have to figure out what certain thing i want to do and here let me explain the problem that right now we have all of our code inside of this function in the local scope so all of this here is the local scope but the problem with that is that we let me go down a tiny bit that here again we have our global scope and the problem is that this game active controls if our game is active or false and this game active is in the global scope so we have to work out how to get from a local scope to the global scope and well here again i'm just going to use a return statement so i'm just going to return false so as soon as our player collides with any of the rectangles this value is going to return false and all of this here runs without doing anything then we want to return true and now all we have to do is to either assign this return false or return true to gameactive.false to gameactive in our game loop so all i have to do is to go down to my game loop and in here we still have our collisions let me put it below there and there i want game active and this is going to get collisions collisions this one and here the two arguments we are going to need is our player rectangle and we are going to need our obstacle rect list and that should be all we needed so now let's run this and let's see if this is working and yeah there we go so now our game is going to end if we collide with any of the obstacles and just to explain what happens here that this collisions can either return true or false if there's a collision with an obstacle it is going to return false so this game active here is going to become false and we are going to the else statement because this game active all the way to the top is not true anymore however if that is not the case and no collision triggers this collision here is going to return true so this game active stays true and we just keep on going back to game active so that way we have a proper collision mechanic however now we have one more problem and let me run the game again and let me just collide with one of the snails and never run the game again we still have to snail in the same place so this is crashing our game immediately to account for that when our game is over i want to empty our obstacle reckless and well all we need is to get our obstacle rack list and clear it so that way we are going to so that way we are removing every single item inside of it and now let's try this again and now we crashed and now let's rerun the game and now the game restarts properly so this is working quite well cool and actually while we are in here there are two more things i would like to add number one is i want to put my player rectangle at the bottom again so dot mid bottom is going to be 80 and 300 the same positions we have specified earlier so that way the player is always going to start at the bottom of the screen so for example if we jumped into a fly at the end of the game and crashed because of that our player would restart at the bottom so that i think makes it look a bit better and along with that my player gravity should also be zero so that way we start at the bottom and don't fall any further it just makes the game a little bit cleaner so alright with that we have made pretty good progress that now our game has multiple types of obstacles and everything else is still working just the same cool now with that we can start addressing something slightly more complex and that is to animate the fly the player and the snail so that we don't have a static image instead we have an animated image that looks significantly better however to achieve that we are going to need a couple of different things but in the most basic sense we don't really do anything complicated so let me explain what we are going to do in the most basic sense all we are going to do is to update the surface we are putting on the screen every few milliseconds so for example for the snail sometimes we are drawing one image and sometimes we are drawing an other image and these images are very very similar but slightly different and if you put them together fast enough it looks like the snail is actually slivering walking moving well moving in an animated way whatever you want to call it and all we really have to figure out is how to update the surface every few milliseconds and this can be done in a couple of different ways as a matter of fact our player animation and our obstacle animation works in different ways for our player animation we're going to create a random timer that updates on every single cycle of the game loop and if that number becomes too large we are going to change the image we are going to placing on the screen and for our obstacles we are going to create a new timer so that we are changing every few milliseconds what kind of surface we are going to put on the rectangles and that again was me talking way too much let's actually look at this in code and let's start with the player i think that's going to be the easier one so here we are back in the code and the first thing i have to do is to import a couple more images because that's what we need for animation so if i scroll down a bit in this part here we have imported the player image so far which is player walk one and what i want to do for now is to import more and put all of this into a list so let me rename a couple of things first of all this isn't supposed to be player surf anymore this is supposed to be player walk 1 or underscore 1. then i want to copy the entire thing and have player walk 2 and this is going to be the other image so our play has walk 1 and walk 2 and if you play those two fast after each other you have a walking animation and those two surfaces i want to place into a list that i call player walk and this is literally just a list with player walk 1 and player walk and then besides that i also want to import a file that i called player jump and this is just going to be another surface so let me copy the entire import line this is just going to be jump.png and with that we have a surface that we want to display when our player is jumping and when our player is walking i want to alternate between these two different surfaces but there's one more variable that we are going to need and let me place it right under the player walk list and i've called this one player index and by default this is going to be zero and what this number is going to be is later on we're going to use it to pick either this surface here or this surface here and i have just realized that this should be player walk one and player work two so basically this player index is what we are going to change to pick either the first work surface or the second work surface and we don't need that for player jump because we only have one surface for the jumping and we can actually start using our player index right away because right now we need a player surface to get the player rectangle and this i just want to get back with player serve and when we start the game i just want to go with player walk and from that i want my player in this one so all this one right now is going to do because it is zero it is going to pick the first player walk surface so right now we haven't really accomplished anything we just imported a couple more images that don't really do too much right now so to actually make all of this work we have to create a function and let me go all the way to the top and create a new function here and i have called this one player underscore animation spelled correctly really helps and in here we want to do a couple of things we want to play walking animation if the player is on floor or we want to display the jump surface when player is not on floor so yeah i hope that makes sense and this player animation i want to call in our main game loop so all the way down here let's say we can place it right before we bled the player's surface that kind of makes sense i think so now we have to create this function properly and the first thing we have to do is to declare a couple of global variables because we want to work very much outside of this function and the two variables that we need is player surface and player index so we want to work with this player index here and this player surface those are the only two that we really have to influence from inside of the function okay so with that we first have to figure out if the player is on the floor or not so that we can either display a jumping animation or walking animation and well this is literally just an ifelse statement so if player rectangle dot bottom is let's say smaller than 300 then i want to show the jump animation and if that is not the case i want to show the walk animation and in here the jump animation isn't actually animation it's just the surface that we are displaying so all we have to do here is to set our player surface to our player jump i start to have a ton of variables but this is literally all we have to do to get the jump animation so if our player is not touching the floor or is above this y position we are just displaying the jump image so that's literally it but now for the walking animation this gets a little bit more complicated because in here we want to alternate between work surface 1 and work surface 2 at a fairly slow speed and this i want to do with the player index so the variable we cleared earlier so i want to first target that one so player index and i just for now just want to add not one but 0.1 so i want to slowly increase this number and let me explain what i'm actually going to do so let's say here we have our list with our two work surfaces so we have w1 and w2 short for walk one and walk two and by default walk index is going to be zero and let me use a different color for this actually so by default this walk index is going to be right here because it's zero and then i don't want to jump straight to the next frame to walk two because that's going to be too fast instead i want to increase walk index only by smaller increments so it takes a couple of frames to get to work to which will be our index one this is why i'm only adding 0.1 but if i were to add 1 here we would straight jump to the next walk cycle but that would be too fast instead i just want to go much slower so i hope that makes sense so with that what i want to do now is to get my player surface again and just look at my player walk list and from there i want to take the index of the integer of player in dex for the simple reason that we can only take the index with an integer and this would already kind of work with the simple problem that we would very fast run out of this list so this number here would go to one and then would go to two then we go to three and so on but our list so this player walk only has two elements zero and one so what we want to do is after we reach one we want to go back to zero so we have to add a bit more code to make sure that we get this border here that we don't cross and this is fortunately very easy to achieve all we need is an if statement between these two that if our player index is greater or equal than the length of our player walk and if that is the case i want to set my player index back to zero and that is literally all the logic we needed for this thing to work and we are already calling the function so let's actually trial of this so it still works and now we have a walking animation and now if i jump we have a jumping animation so this is working really well let me just go through this really quickly again i think this needs a bit of explanation so when we are starting our game we are simply picking the first item here from our player walk animation so we just get one of the walking animation however now in our game loop further down here before we blit the player we are running our player animation and if i look at this this player animation looks at a couple of different things first of all it looks if the player is on the ground or not so here the first line or the first if statement if the player is not on the ground or smaller than position 300 we want to change the player's surface so the player image to play a jump and this way we give the illusion that the player is jumping because we changed the image but that's literally all that's happening here however if that is not the case so if the player is on the floor we want to show either walk one or walk two and to get these two surfaces we use player index and increase this number very slowly and if this number gets too large so with this if statement here we are setting it back to zero and then we use that to animate the player although animate here literally just means we have a pick walk 1 or walk 2. that's really all that's happening here but alright with that we have our player animation cool now next up i want to animate all of the snails and all of the flies and for this we have a minor problem that for the player we only had to worry about a single surface but we have lots of flies and snails on the screen so animating all of those with this method would be a little bit annoying however we can approach this slightly differently and what we're actually going to do is use a timer both for the snails and for the flies and essentially all we're going to do is we're going to create a timer that runs pretty fast so it's going to trigger multiple times per second and every time it triggers we're going to change all of the surfaces for either the flies or the snails each of those have their own separate timer and well that's all we need let's actually have a look at this so here i'm back in the code and let me first import a couple more images so for the snail we have snail serve let's call this snail frame 1 and i want snail frame 2 as well and this is literally just going to be snail 1 and snail 2. and then for the fly we have the same thing we have frame 1 and then we have frame 2 and it probably is going to make sense to separate them a bit more consistently so this is going to be snail and this is going to be fly and in here we have to do the same thing we did for the player so we want a list with all the different frames so this would be snail frame one and snail frame two and then the same for the fly so fly frames is going to be a list with fly frame 1 and fly frame 2 and then both are also going to be needing an index so let's call it snail frame index and by default this one is also going to be 0. so fly frame index going to be zero as well and then finally we are going to need a default snail so i call this one snail surface and all we need here is our snail frames and then snail frame index and then the same for the fly so fly surface and this is going to be our fly frames and fly frame index so this is pretty much the same thing we did for the player you can actually see it right below and we could update each of these flies and snails in the same way we updated the player although this would be kind of annoying because we would have to do it for every single fly or snail on the screen so that's not great so instead i'm going to create a couple more timers so here we have our timers and i want to create a couple more so the first one is the snail animation timer and i'm really bad at spelling animation i realized and this is going to be pygame dot user event plus two and then we need pygm.time.settimer and here we have our snail animation timer and for the snail i went with let's say 500 and now we need this same thing for the flies so let me just copy all of this and this is going to be our fly animation timer it's going to be plus and this one have set to 200 because i think the fly should animate a bit faster than the snail and now if i go down a bit i just want to add a couple more if statements for um updating these timers and first of all i want to check if our game is active because i only want to do this if the game is actually running as a matter of fact let's make some changes here so i realized when we call our obstacle timer we already check if game is active so i just want to take this out here and check all the timers only if our game is active so if game is active then i want to run the obstacle timer and i also want to check if event.type is equal to let's start with the snail animation timer snail animation time this one and all i have to do in here is to change our snail frame index either to zero or to one depending on what we need for the animation so if our snare frame index is zero i want it to be one and if it's one i want it to be zero and this is literally a very simple if statement so if our snail frame index is equal to zero then i want my snail frame index to be one and if that is not the case then i want my snail frame index to be zero and once i have all of this information i want to get my snail surface again and i want my snail frames and pass in there my snail frame index so this way every time this timer is running we are updating all of the surfaces for the snail so once this timer is running we are going to update all of the snail frames and well that's all we have to do and now we have to do the very same thing for the fly and i haven't done an exercise in quite a while so let's do one now that i want you guys to create a timer for the fly and this is going to work in exactly the same way as we did for the snail so if you want to go long pause the video now and try this yourself alrighty so let's copy all of our snail timer and really all i have to do is to change snail to fly so we have this fly we have this flight this is going to be a fly frame index this is also going to be fly from index then this is a fly and two more to go we have fly here and we have fly here and already so this is done all we needed for the fly animation timer and now once we have that let's try to run the code and it's still running that's a good sign and now you can see animations for the snails and i hope i get a fly soon there we go the flies are not animating so let's have a look at those and i have found the error if we go up right now we call for both timers the snail animation timer so whenever we actually call the fly animation timer i just made a typo but that's very easy to fix fortunately because this needs to be fly animation timer and now let's start off this again and let's hope i get a fly fairly soon and there we go now we have flies that also animate and this is making the entire game look much more realistic and much more well animated cool so with that we have our animation and this is another major step towards the good looking game so with that we basically have a working game but there are two more things we really want to add to this number one is music and adding music in pie game is super simple the only reason i haven't done this is because i don't want to have music in the background every time i run the game but you could add the entire music in a couple of lines of code that's not the problem however there's one more topic i really want to cover that's fundamental to pygame but unfortunately this is going to be quite a large topic so this is going to be a larger section that is going to change our code quite substantially and that is going to be the sprite class and the sprite class you see all the time in our code so far we haven't really used any kind of class but it might be really useful for example for our player we have lots of different code snippets throughout our code to make our player work but if we wanted to make changes to the player it would be kind of annoying to do because we constantly have to look around our code to find different things we want to work on and our code is still very simple so if you get a more complex game this sort of setup would be a nightmare to maintain and it would be a much better idea to have all of our player in one player class so this would contain all the surfaces the rectangle the player input all the animations all of that stuff basically anything for the player is in one class and pygame is fully aware of that and that's why the sprite class exists because all it really is is a class that has a surface and a rectangle and these are being drawn automatically in the right spot and this makes it very easy to work with all of this and in our code more specifically i want to change a couple of things into its own separate class most importantly our player is going to be its own class however i also want each fly and each snail to be its own sprite as well and this would be the most common way to organize this sort of game and well that is what we are going to implementing before we work on the music and this is going to be a larger section so well let's go through it slowly and i explain why i implement it that's probably going to be the best so all right here we are back in the code and let me give some space right at the top and i want to create a class and let's call it player and this player has to inherit from another class that's called pygame.sprite.sprite and make sure you get the capitalization right so this second sprite here has to be uppercase and next up we have to create an init method so whenever this class is created we want to do something and this needs the usual self and in here the first line that's very easy to forget we need super and then the dunder ended as well so that we are initializing the sprite class right inside of this class as well so we can access it and this class is now going to need two attributes at the very minimum one is called self.image and the other is self.rect and the image is the surface that is going to be displayed by default and direct as well the rectangle to figure out where it's going to go so we need self.image and self.rect so in here what you could be doing for example is use pygame.image.load and load for example our player walk 1 and we still need to convert the alpha of it and then for the self.rectangle we could get our self.image and then get wrecked again and in here let me for now just place the mid bottom at position let's go with 200 and 300. for now i just want to place it somewhere so i can show you what's going to happen so now we have an image and we have a rectangle so what we could do now let me scroll down a tiny bit and let me create our player is equal to layer so that way we're creating an instance of this class however if we're going to run the code now oh and i'm getting an error this needs to be called so now it's right again and now if we run the code we can't see anything but the game well still works perfectly fine so nothing is going wrong so why can't we see this class here and the reason why we can't see it is that pygame doesn't draw sprites automatically for the simple reason that a sprite is basically just a surface and a rectangle combined but we also can't use screen.blit because that isn't going to work with a sprite instead we have to do it differently instead what we have to do is take all of our sprites and place them inside of a group and then this group can do two different things they can one draw all of the sprites inside of it and it can also update all of these sprites which is going to be really useful for us later on and pygame has two different kinds of groups number one is a regular group and this one can contain multiple kinds of sprites and this would be perfect for our flies in our snails because they can all be in one big group and they are not going to interact with each other however for the player it's not really going to work because the player is supposed to be in its own group and selfcontained and for that pie game has a different kind of group and that's called group single which is a group for a single sprite it's kind of weird but well it is what it is so our player is going to be in single group and all the other sprites will go in the normal group and the major reason why i put them into different groups is when we are checking for the collision we need to have them in different groups that's really important but that's going to come later for now let me first get rid of this player here and instead i want to for my player create pygame.sprite dot group single and into this group so player i want to add an instance of my player and this way we are going to have a group that is going to contain a sprite and this sprite is going to contain all of this stuff here and that way we are able to access it so now if we run the code we still can't see the player however now if i go to my code all the way down in our game loop our game is getting quite long here we have the player now i want to get my player and on this i can call the draw method and in here i have to specify one argument and that's the surface i want to draw on so in this case screen so now now we can see our actual player and well this is going to be there forever it doesn't do anything right now but well it's going to do very soon so this way once you have a bit of setup you can add all of your code for the player in here and then just add this to a group and then call the group later in the code down here and this is going to clean up our code considerably however we will have to recreate the entire player inside of this class so this is going to be a slightly longer thing so let me go through step by step and the first thing i want to do is to get my player input so player underscore input needs itself as before and in here we have to get our player input and here it's really useful what we learned like two hours ago that we can get all of the keys being pressed by pygame so pygame dot key dot get underscore pressed and this is then going to give us all the possible key inputs and we can just go through them so if keys pi game dot k underscore space and self.rect.bottom is greater or equal than 300. then we want to jump so self.gravity is going to be minus minus 20. so this is pretty much the same thing that we have seen a bit further down here all of this so this is just making the player jump but now obviously we need a gravity for all of this so we have to set self.gravity to 0 by default and now since we have gravity we also have to apply it so define apply gravity again with itself and in here i want to go self.gravity is plus equal 1 and then self.rect.y so here again we are just picking the rectangle to move it and we just apply the gravity towards it so plus equal self dot gravity and this should be it dot and then to make sure that our player isn't going to fall outside of the game we need self dot wrecked dot bottom if that is greater or equal than 300 so our floor then i want self.direct.bottom is going to be equal to 300 and this is going to be we have put all of this that is essentially this line here or these lines rather and we are essentially going to do the same thing the only difference now is instead of player rect we have self.right but that's literally the only difference that we really have to worry about so with that we have our gravity and our jump mechanic however now if we run the code nothing's going to happen for the simple reason that we don't call any of these methods and you might be tempted here to go with let me find it in the code here we have our player and you might be tempted to do something like player dot jump or something but that would be the wrong way to go on about it instead what we're going to do is use player dot update and this is what i mentioned earlier that sprite groups in pygame have two main functions one is to draw all of the sprites and the other one is to update all of the sprites and well this is what we are going to make use of here so instead of calling each method individually what we are going to do is inside of our player class we are going to define an update method it still needs self but in here we are going to run self.player input not index input and we are going to run self dot apply gravity and if you now go down a little bit further this play update here is going to call the update method inside of our player class so that way we are going to use that update method to run all of the other code and now let me go all the way to the top again the code is getting quite extensive so now if i run the code this should be working and i made a typo this should be self now let's try it and now we can see that we have two players that will work together and this is looking kind of freaky and here you can see quite well there's a very slight delay but in our case this isn't going to matter too much but if you use different methods of input so in this case this key.get pressed is going to make a very minor difference so just be aware of that but in our case it really doesn't matter so with that we have most of the player the one thing that's missing is the animation frames and well that is going to be the longest part and the first thing that we need to do is to import all the images inside of this class so let me go down a bit and here we have all the frames that we want to import and let me just copy them and now when we call the init method i still want to import all of these so what i want to do in here and i also want to keep myself.playerindex and i also need self dot player jump so let me go through what's happening here first of all we're going to import these two frames and place both of them inside of the player walk frames and this needs self because we want to access it outside of this init method then we have our self.player index this also needs to be available in the entire class and we need our self.jump so this is just the jump frames so this is very similar compared to what we did earlier mostly because i just copied all of it and now when we are loading our self.image i don't just want to have walk frame one for it instead i want to add myself dot player walk and from there i want myself dot player index and this is going to give us right now the index 0 so we would be picking this surface here so still if you are running all of this it is not going to make any noticeable difference we still have the same setup however what we can do now is to declare another method and this i called animation state um couldn't think of a better name and what we are going to do in here is we are essentially going to copy this player animation however now we don't need the global methods anymore because we can work with self so let's work through this step by step first of all again we want to check if the player is on the floor or in the air so this is ifself.rect.bottom is going to be smaller than 300 then we want to do one thing and if that is not the case we want to do something else and well all we want to do in here is to go with self.image and self dot player jump i think i called it uh yeah this one player jump and if that is not the case i want to get myself dot player index and add 0.1 towards it and then again i'm going to need the if statement to check if this index is still inside of this list here so if it is going to be 0 or 1 and well for that i need self dot player index is greater or equal to the length of our self dot player walk and if that condition is true i want to set myself dot player index back to zero and then finally self dot image is going to be self dot player walk then we want to take the index this needs to be an integer and self dot player index so all of this is essentially identical to what we have done down here the only difference now is that we add itself to all of the statements before but in terms of basic logic this is identical so with that we have our animation state and all we have to do now is to call it so dot animation state and now let's try off this again and now we have two walking players and they also jump together so this is working pretty well so this is basically covering the player now what is missing is that we don't have any collisions with the flies or the snails but for that we first have to create the sprites for all of these so well that's going to be the next big step that i want to minimize this class and create another class and this class i have called obstacle and also it needs to inherit from pygm.sprite.sprite and in here again we have to define an init method that needs self and this time we also want to have another argument and that's the type of obstacle so if it is going to be a fly or a snail and then on the first line of the init method we need super and then init again if you don't do that pi game is going to throw an error and it's very easy to forget and in here again we are going to need a self.image and a self.rect those are always needed you can't have a spread class without these two and in here i want to run an if statement to import different kinds of images depending on what i get so if this type is going to be snail i only want to import this stuff here and if it's a fly i want to input all of this so before i create my image i want to run an if statement that if my type is let's say fly so this would look something like this so we are still importing two different surfaces and we place both of them inside of a list that are called frames so this is still very similar compared to the player but now we are also going to need another thing and that is going to be the y position because the flies need to be higher than the snail so in this case let's go with 210 and this is the number if you remember from a couple of hours ago that we have specified here so 300 or 210 and well that is going to be the y position for the fly and now all i have to do is if that is not the case so if we don't type fly and type anything else i want to have an else statement and this is then going to do the exact same thing except for the snail so it's going to look like this and that way when we create the obstacle we can just type in what kind of obstacle we want and finally we are going to need self dot animation underscore index and that needs to be zero and now we can create our image and our rectangle so for the image we need self dot frames and here we need self dot animation index and then for rectangle all we really need is self dot image dot get underscore act and then mid bottom is going to be random dot rand this was between 900 and 1100 and then the y position all we really do is to set a certain kind of type and then use that type to either import all of this or all of this and this is just going to give us a list with our frames and a y position and then later on we are going to use that list to get an image and then we use that image to get a rectangle that's really all that's happening here now we do need a couple of other things now the first one is let's call it the animation state again it needs self as usual and in here i want to do basically the same thing i did for the player and this could be a really good exercise for you guys then i want you to pause the video and try to figure out the animation for both the flies and for the snails so pause the video now and try to implement all of this yourself alrighty let's do it together now so first of all i need to get myself dot animation index and now i just want to add plus equal and let's say 0.1 again although what you could be doing is that this animation index to a different kind of speed depending if you get a fly or snail but in my case i'm not going to care and now i just want to get myself dot animation index is greater or equal to the length of our self dot frames and if that is the case i want to set myself dot animation index back to zero and then finally my self.image is going to be dot frames then i take the index of integer and self dot animation index and this is going to be pretty much the exact same logic we have seen a couple of times now so if i compare to the play animation we basically did this part here and all right with that we have our animation state now again we have to declare an update method that needs self and in here i want to call myself dot animation state so this would be giving us the basic animation for the fly or for the snail and let me minimize a couple of things in here so it's a bit easier to see what we are doing and all right so now i have my obstacle class and i want to add it to a group so let me go down and let me properly add my groups here and this i just call obstacle group and this needs to be pygame dot sprite dot group however now we couldn't just add each of the obstacles right away because we only want to do that when the timer ticks so this is going to happen if i go all the way down that is going to happen in this part here where earlier we just had an obstacle wrecked list and we appended stuff towards it but i don't want to do that anymore and instead i want to get my obstacle group and in here i want to add one instance of my obstacle and for now let's just call it fly and now let's try and see what happens and we can't see anything and the reason for that should make a lot of sense so if i go all the way up again when we are initiating our class we are putting our fly at position 900 to 1100 and slightly above the ground so it's outside of the screen and it doesn't move into the screen so that really doesn't help us and just to illustrate that it is working let me place it somewhere between 100 and 200 and now if you run the code again we still can't see it and the reasons for that also makes sense because when i go all the way down we are not drawing this group so what we have to do is to get our obstacle group dot draw and this needs to be on the screen and now it should work for real and there we go now we can see that whenever the timer ticks we are getting another fly which right now looks kind of strange but we can work with this so now let me get all the way back to the top and change this back to 900 to 1100 but now what we want to do is to move this fly a little bit to the left on every cycle of our game loop and literally all we have to do to make that work is to get our rectangle again so self.rect and now we need to target one of the points in my case i went with x and then we need to subtract a couple of pixels every single time our game updates so let's go for now with six and that way this entire sprite is going to be moved to the left however there's one thing we still have to do let me go all the way down right now we're only drawing the sprite we're not updating it so we need obstacle group dot update and now we should be seeing a ton of flies and there we can see one and well quite a lot more and well now the game becomes really hard uh i well it's basically unplayable at this point but okay we are going to clean this up in a little bit so okay so with this we have our class properly now and there's only one more thing that i do want to do that whenever our fly or our snail is moving outside of the screen it should be destroyed and how we handled this earlier if i go down a tiny bit we used this line here to remove any kind of rectangle that is too far to the left but if we have a class all of this is much easier to do because all we have to do is to define another method that i'm going to call destroy and self and in here i want to look for self.rect.x and if this is smaller or equal to negative 100 i want to run self.kill and this self.kill is going to destroy this obstacle sprite and then all we have to do is in our update method called self.destroy so this way whenever this sprite goes too far outside of the screen it's going to destroy itself and we don't have to worry about it at all anymore although you can't really see it in our game itself so there's no point in running it however there's one thing that you are going to see that we are missing right now and if i go down a little bit further i can actually copy all of this out because we don't really want to look at it so these were the earlier sprites that we looked at and we don't need those anymore and what i want to work on right now is that we are always spawning a fly but i also want to spawn snails once in a while actually i want to spawn mostly snails so i have to figure out some kind of mechanic here to spawn mostly snails and sometimes a fly and there are quite a few different ways to make this work in my case i went with a little bit of a hack so let me explain first of all i imported besides rent int also choice and choice allows us to pick a random item from a list that's all it does so now that i have that i can when i pass on the fly i can pass in choice and this choice is going to pick from a couple of different items and in this list i have one fly and then i have a couple more snails let's put three in there so how this is going to work is whenever we are calling our obstacle this choice method is going to pick one of these four items and since we have our snail three times there's a 75 chance to get a snail and a 25 chance to get a fly and well let's trail of this so now we should only be seeing our sprites and well now our collision is broken but we should be seeing a fly and there we go and now we can only see our sprites and this is working pretty well cool and now let me actually hide the earlier player we created so all of this here we don't need any more and literally all we are going to need is these four lines that's literally how we need we also don't need our obstacle list anymore and we also can comment out our game active and i think if you followed along this code might look very confusing but the main problem right now is that we are both having a sprite setup and a functional setup and this can get really confusing but if you were to actually work on a code you would only look at these two classes which is much easier to organize and the only reason why all of this became so complex is because well i went through every single step but in an actual game all of this could be deleted and you would only have the classes but in my case well the code got quite long but if you look at this here all the stuff i commented out you could just get rid of and well that would make our code significantly more readable but alright let me update the player so all the way at the top let me hide all of this when i initiate the player it is supposed to be at 80 pixels from the left so now let's run this again and now we have the same setup except with sprites and well the one thing missing now is that we don't have collisions so that's the last one we have to add in here and this fortunately is also very easy to achieve because sprites have their own collision mechanics and the most common one is called sprite collide and what this one does is that it takes a sprite and it checks if this sprite is colliding with any other sprite in another group and if that's the case it's going to return a list with all the collision sprites which is super useful and this we can then work with in a function and as a matter of fact we already have our collision function and let me open it and what i want to do is to somewhat copy this so let's call this collision sprite and for this one now we don't need any arguments and really all we want to do is to first check pygame dot sprite dot sprite collide and in here we are going to need three different arguments we first need a sprite then we need a group and then we need a boolean we're going to explain that one in just a second but first of all we need a sprite and in my case i want to get my player and here you have to be careful because this player is not a sprite it is a group single that contains a sprite so that can be quite confusing so this player by itself would not be enough however we can access the sprite very easily all we need is dot sprite and since this class only has a single sprite this is quite workable however in a regular group this sprite would not work you could only get a list of all the sprites you could not get an individual sprite so this is why we have group single here all right but then for the group this is much easier all we need is our obstacle group and now we have the group that we need now for this boolean here what this effectively does is that if this sprite here is colliding with a sprite in this group we can check if this spread is going to be destroyed or not and this is what the boolean here is for so if you're going to set this to true every time our snail will collide with the player the snail will be deleted and if we set this to false the snail would not be deleted and in my case i want to go with false but in our case it really doesn't matter all that much but all right now this entire statement is going to return a list and if it doesn't collide with anything it's going to return an empty list and that we can use an if statement so if there's anything in this collision list we want to run some code and well all we really want to do is to return false and if that is not the case i want to return true and this is going to be very similar compared to our collision function so all right now all i have to do if i go down quite a bit by now we have down here our collisions i still have our game active variable and now we want to check collision sprite and well with that we should have our collisions back so let's check if this is working and there we go it's still working but now we have the same problem again that if i run the game again the snail is still in the same position so well our game would crash right away so whenever let me go all the way up again whenever this collision sprite triggers we want to delete all of the sprites inside of our obstacle group and this is very easy to achieve because all we need to do is to get the obstacle group and empty it and now if i run all of this this should be working pretty well so now if i collide with a fly the game stops and now it starts again with no sprites in there and well this is working pretty well cool so now we have our game working again so with that we have made quite some noticeable changes and there's a ton of redundancy in our code now which isn't great but i hope you get the principle following along and i'm going to upload all of the code in the proper way for the classbased approach that's going to help understand all of this i think but if you could follow along i hope this makes sense but alright there's only one more topping left to do and that's to add the sound and this is going to be a super easy part and well the audio part is going to be really quick because there's only really two steps that are both really easy we first have to import a sound and then we have to play it at certain parts in our game and all of that happens with the pygame dot mixer module and this really isn't all that complicated so i think the best way to approach this is to jump straight into our code and then let's do all of this so specifically i want to work with two sounds one is the background music and one is a jump sound so here we are back in the code and the first thing i want to do is to add the player jump sound and for that i am opening a player and when we initiate this class i want to also import the sound and let's call this jump underscore sound and now to import a sound we need pygame dot mixer dot sound and as always make sure the s is capitalized that's really important but now all you have to do is to add a path to what file you want to import and in this case we have audio jump.mp3 and that's all we needed to import is sound so that's the first step and now we only want to play this sound when our player is jumping and that happens in this player input that whenever we play the button we want to jump so we could play this sound ideally in here and that would make the most sense so let's play there and to play the sound literally all that we have to do is to get our self.jump sound and then add play that is literally all we have to do so now if i run the code we can still see our game that's a good start and now you should be able to hear a jump sound so it's really as simple as that now there's one problem with this that i think this sound is kind of loud and annoying so i want to make it less loud and this we can also do very easily all we need is to target our jump sound again and then add set volume and in here we choose a value between 0 and 1 with 1 being the full sound and 0 being the sound muted and in my case i went with 0.5 and now this should sound significantly better but do play around with it i guess um whatever you think is perfect so that's all we had to do for the jump sound now next up let me minimize all of this because we don't need it anymore and next up i want to have an actual game sound and let me import it right when we initiate the game and let's call this bg music for background music and this could be a really good exercise for you try to import this music and play it once once our game has started so all i want to do is pygame.mixer.sound and now the file that we are going for is this one audio slash music or wav and that is the music that we want to play and now we have to figure out two things number one is where do we have to add the code to play this music and number two is how can we loop this music so this track here is only a couple of minutes long and once it's over i want to restart it so that's another thing we have to figure out but first let me change this to lowercase music so it looks a bit more consistent but right now i want to target my pg music again and again what i want to do is to play this music and now as soon as our game starts we are going to play the music so let's try this you can play with the ball a little bit it's up to you i am not going to worry too much and now if you want to loop this all we have to add is one argument in here and that's called loops and in here we can tell pygm how often to loop this so for example if i were to add a six in here we would loop this track six times but in our case we don't want to loop it a certain amount of times instead we want to loop it forever and for that we need 1 and this is telling pygam to play this sound forever and once it's over to just restart and well you can't really see this in the game now with that we do have the entire game and if you have gotten this far you have basically learned all the fundamentals of pygame so at this stage you should be able to approach most 2d games now obviously you do have to practice using all of these concepts but this is essentially all the concepts you need to make them so i hope that was helpful
